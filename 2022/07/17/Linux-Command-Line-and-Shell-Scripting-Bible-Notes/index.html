

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="第十一章 构建基本脚本11.4 使用变量多个命令在同一行执行，使用分号隔开: 1$ date ; who  如果文本文件开头的最前面两个字符是#!，那么后面跟着的就是用来执行这个文件的程序路径. shell 通过PATH环境变量来查找命令. 引用当前目录下的文件，可以使用shell中使用单点操作符: 1$ .&#x2F;test1  对于文件而言，全权限值为666, 对于目录而言，全权限值为777. 默认权">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Command Line and Shell Scripting Bible Notes">
<meta property="og:url" content="http://example.com/2022/07/17/Linux-Command-Line-and-Shell-Scripting-Bible-Notes/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第十一章 构建基本脚本11.4 使用变量多个命令在同一行执行，使用分号隔开: 1$ date ; who  如果文本文件开头的最前面两个字符是#!，那么后面跟着的就是用来执行这个文件的程序路径. shell 通过PATH环境变量来查找命令. 引用当前目录下的文件，可以使用shell中使用单点操作符: 1$ .&#x2F;test1  对于文件而言，全权限值为666, 对于目录而言，全权限值为777. 默认权">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-17T04:43:22.000Z">
<meta property="article:modified_time" content="2022-09-09T13:58:58.851Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Linux Command Line and Shell Scripting Bible Notes - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jie</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/SteinsGate_all.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Linux Command Line and Shell Scripting Bible Notes"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-07-17 12:43" pubdate>
          2022年7月17日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          114 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Linux Command Line and Shell Scripting Bible Notes</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第十一章-构建基本脚本"><a href="#第十一章-构建基本脚本" class="headerlink" title="第十一章 构建基本脚本"></a>第十一章 构建基本脚本</h1><h2 id="11-4-使用变量"><a href="#11-4-使用变量" class="headerlink" title="11.4 使用变量"></a>11.4 使用变量</h2><p>多个命令在同一行执行，使用分号隔开:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> ; <span class="hljs-built_in">who</span></span><br></code></pre></td></tr></table></figure>

<p>如果文本文件开头的最前面两个字符是<code>#!</code>，那么后面跟着的就是用来执行这个文件的程序路径.</p>
<p>shell 通过PATH环境变量来查找命令.</p>
<p>引用当前目录下的文件，可以使用shell中使用单点操作符:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./test1</span><br></code></pre></td></tr></table></figure>

<p>对于文件而言，全权限值为666, 对于目录而言，全权限值为777.</p>
<p>默认权限值为全权限值减去umask变量的值.</p>
<h3 id="11-4-2-用户变量"><a href="#11-4-2-用户变量" class="headerlink" title="11.4.2 用户变量"></a>11.4.2 用户变量</h3><p>在变量、等号和值之间不能出现空格.</p>
<p>shell 脚本会自动决定变量值的数据类型.</p>
<p>引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时不要使用美元符:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">value1</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">value2</span>=<span class="hljs-variable">$value1</span><br></code></pre></td></tr></table></figure>
<p>没有美元符，shell会将变量名解释成普通的文本字符串.</p>
<h3 id="11-4-3-命令替换"><a href="#11-4-3-命令替换" class="headerlink" title="11.4.3 命令替换"></a>11.4.3 命令替换</h3><p>命令替换允许你将shell命令的输出赋给变量, 有两个格式:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">反引号字符<span class="hljs-comment">(`)</span><br>$<span class="hljs-comment">()</span>格式<br></code></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">testing</span>=`date`<br><span class="hljs-attr">testing</span>=$(date)<br></code></pre></td></tr></table></figure>
<p>命令替换会创建一个子shell来运行对应的命令.</p>
<h2 id="11-5-重定向输入和输出"><a href="#11-5-重定向输入和输出" class="headerlink" title="11.5 重定向输入和输出"></a>11.5 重定向输入和输出</h2><h2 id="11-7-执行数学运算"><a href="#11-7-执行数学运算" class="headerlink" title="11.7 执行数学运算"></a>11.7 执行数学运算</h2><h3 id="11-7-1-expr命令"><a href="#11-7-1-expr命令" class="headerlink" title="11.7.1 expr命令"></a>11.7.1 expr命令</h3><p>expr命令允许在命令行上处理数学表达式:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">expr</span> 1 + 5</span><br></code></pre></td></tr></table></figure>
<p>对于那些容易被shell错误解释的字符，在它们传入expr命令之前，需要使用shell的转义字符将其标出来:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">expr</span> 1 \* 5</span><br></code></pre></td></tr></table></figure>
<h3 id="11-7-2-使用方括号"><a href="#11-7-2-使用方括号" class="headerlink" title="11.7.2 使用方括号"></a>11.7.2 使用方括号</h3><p>在bash中，在将一个数学运算结果赋给某个变量时，可以使用美元符和方括号($[ operation ])将数学表达式围起来:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>var1=<span class="hljs-variable">$[</span><span class="hljs-number">1</span> + <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure>
<p>不用担心shell会误解.</p>
<p>bash shell 数学运算符只支持整数运算.</p>
<p>z shell 提供了完整的浮点运算。</p>
<h3 id="11-7-3-浮点解决方案"><a href="#11-7-3-浮点解决方案" class="headerlink" title="11.7.3 浮点解决方案"></a>11.7.3 浮点解决方案</h3><p>使用bash内建的计算器bc.</p>
<p>可以在shell提示符下通过<code>bc</code>命令访问bash计算器.</p>
<p>浮点运算是由内建变量<code>scale</code>控制，用于设置你希望在计算结果中保留的小数位数.</p>
<p>使用<code>-q</code>命令行选项可以不显示bash计算器的欢迎信息.</p>
<h4 id="在脚本中使用bc"><a href="#在脚本中使用bc" class="headerlink" title="在脚本中使用bc"></a>在脚本中使用bc</h4><p>利用命令替换, 基本格式如下:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">variable=<span class="hljs-constructor">$(<span class="hljs-params">echo</span> <span class="hljs-string">&quot;options; expression&quot;</span> | <span class="hljs-params">bc</span>)</span><br></code></pre></td></tr></table></figure>
<p>使用那联输入重定向(inline input redirection), 需指定一个文本标记来划分输入数据的开始和结尾，文本标记可以为任意字符串:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &lt;&lt; <span class="hljs-string">marker</span><br><span class="hljs-string">data</span><br><span class="hljs-string">marker</span><br></code></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">variable=$(bc &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">options</span><br><span class="hljs-string">statements</span><br><span class="hljs-string">expressions</span><br><span class="hljs-string">EOF</span><br>)<br></code></pre></td></tr></table></figure>
<p>在bash计算器中创建的变量只在bash计算其中有效，不能在shell脚本中使用.</p>
<h2 id="11-8-退出脚本"><a href="#11-8-退出脚本" class="headerlink" title="11.8 退出脚本"></a>11.8 退出脚本</h2><p>退出状态码(exit status)，一个0～255的整数值.</p>
<h3 id="11-8-1-查看退出状态码"><a href="#11-8-1-查看退出状态码" class="headerlink" title="11.8.1 查看退出状态码"></a>11.8.1 查看退出状态码</h3><p>变量<code>$?</code>来保存上个已执行命令的退出状态码.</p>
<p>成功结束的命令的退出状态码是0.</p>
<p>无效命令会返回一个exit status为127.</p>
<p>exit status为126表示用户没有执行命令的正确权限。</p>
<h3 id="11-8-2-exit命令"><a href="#11-8-2-exit命令" class="headerlink" title="11.8.2 exit命令"></a>11.8.2 exit命令</h3><p>指定exit status退出.</p>
<h1 id="第12章-使用结构化命令"><a href="#第12章-使用结构化命令" class="headerlink" title="第12章 使用结构化命令"></a>第12章 使用结构化命令</h1><h2 id="12-1-使用if-then语句"><a href="#12-1-使用if-then语句" class="headerlink" title="12.1 使用if-then语句"></a>12.1 使用if-then语句</h2><p>格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span> <br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>查看<code>if</code>后面<code>command</code>的exit status, 是0, 则执行.</p>
<p><code>then</code>部分可以有多条命令.</p>
<h2 id="12-2-if-then-else语句"><a href="#12-2-if-then-else语句" class="headerlink" title="12.2 if-then-else语句"></a>12.2 if-then-else语句</h2><p>格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">else</span> <br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">if</span><br></code></pre></td></tr></table></figure>
<p><code>else</code>部分也可以包含多条命令.</p>
<h2 id="12-3-嵌套if"><a href="#12-3-嵌套if" class="headerlink" title="12.3 嵌套if"></a>12.3 嵌套if</h2><p>使用嵌套的<code>if-then</code>语句.</p>
<p>使用<code>elif</code>语句:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span><br>   commands<br><span class="hljs-keyword">elif</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span> <br>   commands<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<h2 id="12-4-test-命令"><a href="#12-4-test-命令" class="headerlink" title="12.4 test 命令"></a>12.4 test 命令</h2><p>运用<code>test</code>命令通过<code>if-then</code>语句测试其他条件.</p>
<p>如果<code>test</code>命令中列出的条件成立，<code>test</code>命令就会退出并返回exit status 0.</p>
<p>格式:</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">test </span>condition<br></code></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> condition<br><span class="hljs-keyword">then</span><br>   commands<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>如果不写test命令的<code>condition</code>部分，它会以非零的退出状态码退出，并执行else语句快.</p>
<p>可以用test命令确定变量中是否有内容.</p>
<p>另一种测试方法，不需用test命令:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span><span class="hljs-meta"> [ condition ]</span><br><span class="hljs-attribute">then</span><br>   <span class="hljs-attribute">commands</span><br><span class="hljs-attribute">fi</span><br></code></pre></td></tr></table></figure>
<p>注意第一个方括号之后和第二个方括号之前必须加上一个空格.</p>
<p>test命令可以判断三类条件:</p>
<pre><code class="hljs">1. 数值比较
2. 字符串比较
3. 文件比较
</code></pre>
<h3 id="12-4-1-数值比较"><a href="#12-4-1-数值比较" class="headerlink" title="12.4.1 数值比较"></a>12.4.1 数值比较</h3><p>不能在test命令中使用浮点值。</p>
<h3 id="12-4-2-字符串比较"><a href="#12-4-2-字符串比较" class="headerlink" title="12.4.2 字符串比较"></a>12.4.2 字符串比较</h3><pre><code class="hljs">1. 比较时大于号和小于号必须转义。
2. 大于和小于顺序和sort命令采取的不同。比较使用的是ASCII顺序, 小写大于大写。sort命令使用的是本地英语，小写字母出现在大写字母之前.
</code></pre>
<p>使用<code>-n</code>和<code>-z</code>参数检查一个变量是否含有数据:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">if</span> [ -n <span class="hljs-variable">$var1</span> ]<br></code></pre></td></tr></table></figure>
<p>空的和未初始化的变量会对shell脚本测试造成灾难性的影响.</p>
<h3 id="12-4-3-文件比较"><a href="#12-4-3-文件比较" class="headerlink" title="12.4.3 文件比较"></a>12.4.3 文件比较</h3><p>测试Linux文件系统上文件和目录的状态.</p>
<p>还是使用参数比较.</p>
<h2 id="12-5-复合条件测试"><a href="#12-5-复合条件测试" class="headerlink" title="12.5 复合条件测试"></a>12.5 复合条件测试</h2><p>有两种布尔运算符可用:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">[ co<span class="hljs-symbol">ndition1</span> ] || [ co<span class="hljs-symbol">ndition2</span> ]<br>[ co<span class="hljs-symbol">ndition1</span> ] &amp;&amp; [ co<span class="hljs-symbol">ndition2</span> ]<br></code></pre></td></tr></table></figure>
<h2 id="12-6-if-then-的高级特性"><a href="#12-6-if-then-的高级特性" class="headerlink" title="12.6 if-then 的高级特性"></a>12.6 if-then 的高级特性</h2><p>bash shell 提供了两项可在 if-then 语句中使用的高级特性:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 用于数学表达式的双括号<br><span class="hljs-bullet">2.</span> 用于高级字符串处理功能的双方括号<br></code></pre></td></tr></table></figure>
<h3 id="12-6-1-使用双括号"><a href="#12-6-1-使用双括号" class="headerlink" title="12.6.1 使用双括号"></a>12.6.1 使用双括号</h3><p>格式:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(( expression ))<br></code></pre></td></tr></table></figure>
<p>不需要将双括号中表达式里的大于号转义。</p>
<h3 id="12-6-2-使用双方括号"><a href="#12-6-2-使用双方括号" class="headerlink" title="12.6.2 使用双方括号"></a>12.6.2 使用双方括号</h3><p>格式:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[ expression ]]</span><br></code></pre></td></tr></table></figure>
<p>这里的<code>expression</code>使用了test命令中的标准字符串比较，但它提供了模式匹配 pattern matching.</p>
<p>这里用双等号<code>==</code>其右侧为一个正则表达式.</p>
<h2 id="12-7-case-命令"><a href="#12-7-case-命令" class="headerlink" title="12.7 case 命令"></a>12.7 case 命令</h2><p>case 命令采用列表格式来检查单个变量的多个值。</p>
<p>格式：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">case <span class="hljs-keyword">variable</span> in <br>pattern1 | <span class="hljs-comment">pattern2) command1</span>;;<br>pattern3) command2;;<br><span class="hljs-comment">*) default command3;;</span><br>esac<br></code></pre></td></tr></table></figure>
<p>case 命令会将指定的变量与不同模式进行比较，如果变量和模式是匹配的，那么shell会执行该模式指定的命令.</p>
<h1 id="13-更多的结构化命令"><a href="#13-更多的结构化命令" class="headerlink" title="13 更多的结构化命令"></a>13 更多的结构化命令</h1><h2 id="13-1-for-命令"><a href="#13-1-for-命令" class="headerlink" title="13.1 for 命令"></a>13.1 for 命令</h2><p>格式:</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">for</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">in</span> list <br><span class="hljs-keyword">do</span><br>    commands<br>done<br></code></pre></td></tr></table></figure>
<h3 id="13-1-2-读取列表中的复杂值"><a href="#13-1-2-读取列表中的复杂值" class="headerlink" title="13.1.2 读取列表中的复杂值"></a>13.1.2 读取列表中的复杂值</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 使用转义字符来将单引号转义<br><span class="hljs-bullet">2.</span> 使用双引号来定义用到单引号的值<br></code></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> I don<span class="hljs-string">\&#x27;t</span> know <span class="hljs-literal">it</span> <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;this&#x27;ll&quot;</span> work<br></code></pre></td></tr></table></figure>
<p>在某个值的两边使用双引号时，shell并不会将双引号当成值的一部分.</p>
<h3 id="13-1-3-从变量读取列表"><a href="#13-1-3-从变量读取列表" class="headerlink" title="13.1.3 从变量读取列表"></a>13.1.3 从变量读取列表</h3><h3 id="13-1-4-从命令读取值"><a href="#13-1-4-从命令读取值" class="headerlink" title="13.1.4 从命令读取值"></a>13.1.4 从命令读取值</h3><h3 id="13-1-5-更改字段分隔符"><a href="#13-1-5-更改字段分隔符" class="headerlink" title="13.1.5 更改字段分隔符"></a>13.1.5 更改字段分隔符</h3><p>环境变量<code>IFS</code>, Internal Field Separator. 定义了bash shell 用作字段分隔符的一系列字符.</p>
<p>默认为:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">空格<br>制表符<br>换行符<br></code></pre></td></tr></table></figure>
<p>更改为只识别换行符:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IFS</span>=$<span class="hljs-string">&#x27;\n&#x27;</span><br></code></pre></td></tr></table></figure>
<p>在改变IFS之前保存原来的IFS值:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">IFS.<span class="hljs-attribute">OLD</span>=<span class="hljs-variable">$IFS</span><br><span class="hljs-attribute">IFS</span>=$&#x27;\n&#x27;<br><span class="hljs-built_in">..</span>.<br><span class="hljs-attribute">IFS</span>=IFS.OLD<br></code></pre></td></tr></table></figure>
<p>指定多个字符:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IFS</span>=$<span class="hljs-string">&#x27;\n&#x27;</span>:<span class="hljs-comment">;&quot;</span><br></code></pre></td></tr></table></figure>
<p>直接串起来.</p>
<h2 id="13-2-C语言风格的for命令"><a href="#13-2-C语言风格的for命令" class="headerlink" title="13.2 C语言风格的for命令"></a>13.2 C语言风格的for命令</h2><p>和C语言风格的类似，但有一些细微的不同, 基本格式:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">for <span class="hljs-comment">(( variable assignment ; condition ; iteration process )</span>)<br><span class="hljs-keyword">do</span><br>... <br><span class="hljs-keyword">do</span><span class="hljs-symbol">ne</span><br></code></pre></td></tr></table></figure>
<p>没有遵循bash shell标准的for命令:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 变量赋值可以有空格<br><span class="hljs-bullet">2.</span> 条件中变量不以美元符开头<br><span class="hljs-bullet">3.</span> 迭代过程的算式未用expr命令格式<br></code></pre></td></tr></table></figure>
<h2 id="13-3-while-命令"><a href="#13-3-while-命令" class="headerlink" title="13.3 while 命令"></a>13.3 while 命令</h2><p>格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">test</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">do</span><br>  other commmand<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<h2 id="13-3-2-定义多个测试命令"><a href="#13-3-2-定义多个测试命令" class="headerlink" title="13.3.2 定义多个测试命令"></a>13.3.2 定义多个测试命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span><br>       [ <span class="hljs-variable">$var1</span> -ge 0 ]<br></code></pre></td></tr></table></figure>
<p>只有最后一个测试命令的exit status用来决定退出.</p>
<p>每个测试命令都出现在单独的一行。</p>
<p>在每次迭代中所有的测试命令都会被执行, 包括测试命令失败的那一次迭代，其测试条件依然会全部执行.</p>
<h2 id="13-4-until-命令"><a href="#13-4-until-命令" class="headerlink" title="13.4 until 命令"></a>13.4 until 命令</h2><p>只有测试命令的exit status不为0, bash shell才会执行循环内的命令，其工作模式和while相反, 即测试条件成功时退出.</p>
<p>格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">until <span class="hljs-built_in">test</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">do</span><br>  other commands<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<h2 id="13-7-控制循环"><a href="#13-7-控制循环" class="headerlink" title="13.7 控制循环"></a>13.7 控制循环</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">break</span>, 终止某层循环<br><span class="hljs-keyword">continue</span>, 终止某次循环<br></code></pre></td></tr></table></figure>
<p>特殊用法:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">break</span> n<br></code></pre></td></tr></table></figure>
<p>n指定了要跳出的循环层级, 默认情况下n为1.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">continue</span> n<br></code></pre></td></tr></table></figure>
<h2 id="13-8-处理循环的输出"><a href="#13-8-处理循环的输出" class="headerlink" title="13.8 处理循环的输出"></a>13.8 处理循环的输出</h2><p>通过在done命令之后添加一个处理命令实现:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> /home/rich/*<br><span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> ]<br>  <span class="hljs-keyword">then</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a directory&quot;</span><br>  <span class="hljs-keyword">elif</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a file&quot;</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span> &gt; output.txt<br></code></pre></td></tr></table></figure>
<h2 id="13-9-实例"><a href="#13-9-实例" class="headerlink" title="13.9 实例"></a>13.9 实例</h2><h3 id="13-9-1-查找可执行文件"><a href="#13-9-1-查找可执行文件" class="headerlink" title="13.9.1 查找可执行文件"></a>13.9.1 查找可执行文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># finding files in the PATH</span><br><br>IFS=:<br><span class="hljs-keyword">for</span> folder <span class="hljs-keyword">in</span> <span class="hljs-variable">$PATH</span><br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$folder</span>:&quot;</span><br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-variable">$folder</span>/*<br>    <span class="hljs-keyword">do</span> <br>        <span class="hljs-keyword">if</span> [ -x <span class="hljs-variable">$file</span> ]<br>        <span class="hljs-keyword">then</span> <br>           <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;   <span class="hljs-variable">$file</span>&quot;</span><br>        <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<h3 id="13-9-2-创建多个用户账户"><a href="#13-9-2-创建多个用户账户" class="headerlink" title="13.9.2 创建多个用户账户"></a>13.9.2 创建多个用户账户</h3><p>把数据从文件中送入while命令, 在while命令尾部使用一个重定向符就可以了:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># process new user accounts</span><br><br>input=<span class="hljs-string">&quot;users.csv&quot;</span><br><span class="hljs-keyword">while</span> IFS=<span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-built_in">read</span> -r userid name<br><span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;adding <span class="hljs-variable">$userid</span>&quot;</span><br>  useradd -c <span class="hljs-string">&quot;<span class="hljs-variable">$name</span>&quot;</span> -m <span class="hljs-variable">$userid</span><br><span class="hljs-keyword">done</span> &lt; <span class="hljs-string">&quot;<span class="hljs-variable">$input</span>&quot;</span><br></code></pre></td></tr></table></figure>
<h1 id="第十四章-处理用户输入"><a href="#第十四章-处理用户输入" class="headerlink" title="第十四章 处理用户输入"></a>第十四章 处理用户输入</h1><h2 id="14-1-命令行参数"><a href="#14-1-命令行参数" class="headerlink" title="14.1 命令行参数"></a>14.1 命令行参数</h2><h3 id="14-1-1-读取参数"><a href="#14-1-1-读取参数" class="headerlink" title="14.1.1 读取参数"></a>14.1.1 读取参数</h3><p>positional parameter, 位置参数，一个特殊变量，由bash shell分配给输入到命令行的所有参数. 也就是 $0, $1 这些.</p>
<p>$0是程序名，$1是第一个参数，直到$9.</p>
<p>将文本字符串作为参数传递时，引号并非数据得一部分, 它们只是表明数据的起始位置.</p>
<p>在第九个变量之后，必须在变量数字周围加上花括号, 如${10}.</p>
<h3 id="14-1-2-读取脚本名"><a href="#14-1-2-读取脚本名" class="headerlink" title="14.1.2 读取脚本名"></a>14.1.2 读取脚本名</h3><p>当传给$0变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量$0就会使用整个路径.</p>
<p><code>basename</code>命令会返回不包含路径的脚本名.</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">name</span>=$(basename <span class="hljs-variable">$0</span>)<br></code></pre></td></tr></table></figure>
<h3 id="14-1-3-测试参数"><a href="#14-1-3-测试参数" class="headerlink" title="14.1.3 测试参数"></a>14.1.3 测试参数</h3><p>在使用参数前一定要检查其中是否存在数据。</p>
<h2 id="14-2-特殊参数变量"><a href="#14-2-特殊参数变量" class="headerlink" title="14.2 特殊参数变量"></a>14.2 特殊参数变量</h2><h3 id="14-2-1-参数统计"><a href="#14-2-1-参数统计" class="headerlink" title="14.2.1 参数统计"></a>14.2.1 参数统计</h3><p>特殊变量<code>$#</code>记录命令行参数的个数.</p>
<p>通过使用前测试参数的总数:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">if</span> [ <span class="hljs-symbol">$</span># -<span class="hljs-keyword">ne</span> <span class="hljs-number">2</span> ]<br></code></pre></td></tr></table></figure>
<p>同时，<code>$&#123;!#&#125;</code>表示最后一个命令行参数. 在花括号内不能使用美元符号，需将其替换为<code>!</code>.</p>
<h3 id="14-2-2-抓取所有的数据"><a href="#14-2-2-抓取所有的数据" class="headerlink" title="14.2.2 抓取所有的数据"></a>14.2.2 抓取所有的数据</h3><p><code>$*</code>变量会将命令行上提供的所有参数当作一个单词保存.</p>
<p><code>$@</code>变量会将命令行上提供的所有参数当作统一字符串中的多个独立的单词.</p>
<p>注意使用时添加双引号.</p>
<h2 id="14-3-移动变量"><a href="#14-3-移动变量" class="headerlink" title="14.3 移动变量"></a>14.3 移动变量</h2><p><code>shift</code>命令，将每个参数变量向左移动一个位置，$0不会改变.</p>
<p>给<code>shift</code>命令提供参数，可以一次移动多个位置.</p>
<h2 id="14-4-处理选项"><a href="#14-4-处理选项" class="headerlink" title="14.4 处理选项"></a>14.4 处理选项</h2><p>选项是跟在单破折号后面的单个字母，他能改变命令的行为。</p>
<h3 id="14-4-1-查找选项"><a href="#14-4-1-查找选项" class="headerlink" title="14.4.1 查找选项"></a>14.4.1 查找选项</h3><p>用<code>case</code>语句来判断某个参数是否为选项.</p>
<h4 id="分离选项和参数"><a href="#分离选项和参数" class="headerlink" title="分离选项和参数"></a>分离选项和参数</h4><p>shell会用双破折号(–)来表明选项列表结束，其后的参数会被当作参数处理而不是选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">  <br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># extracting command line options as parameters</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">echo</span> <br><span class="hljs-keyword">while</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span> <br>        -a) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -a option&quot;</span> ;; <br>        -b) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -b option&quot;</span> ;;<br>        -c) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -c option&quot;</span> ;;<br>        --) <span class="hljs-built_in">shift</span><br>            <span class="hljs-built_in">break</span> ;;<br>         *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> is not an option&quot;</span> ;;<br>     <span class="hljs-keyword">esac</span><br>     <span class="hljs-built_in">shift</span><br> <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>利用<code>shift</code>每调用一个选项就移除一个。</p>
<p>在Linux中，合并选项是一个很常见的做法。</p>
<h3 id="14-4-2-使用getopt命令"><a href="#14-4-2-使用getopt命令" class="headerlink" title="14.4.2 使用getopt命令"></a>14.4.2 使用getopt命令</h3><p>这个命令的作用在于 <mark>格式化命令行参数</mark>.<br>getopt命令可以识别命令行参数.</p>
<p>getopt命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式:</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">getopt optstring parameters</span><br></code></pre></td></tr></table></figure>
<p>在每个需要参数值的选项字母后面加一个冒号:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">getopt ab:<span class="hljs-built_in">cd</span> -a -b test1 -<span class="hljs-built_in">cd</span> test2 testt3</span><br></code></pre></td></tr></table></figure>
<p>这时, 命令行参数就被格式化为:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">a</span> -<span class="hljs-selector-tag">b</span> test1 -c -d -- test2 test3<br></code></pre></td></tr></table></figure>
<p><code>c</code> 和 <code>d</code> 是两个命令行选项, 所以把 <code>-cd</code> 变成了 <code>-c -d</code>.</p>
<p>因为 <code>-d</code> 没有参数, 所以后面会有 <code>--</code> 来分隔.</p>
<p>在这里的意思就是, <code>b</code> 这个选项需要参数.</p>
<h4 id="2-在脚本中使用-getopt"><a href="#2-在脚本中使用-getopt" class="headerlink" title="2. 在脚本中使用 getopt"></a>2. 在脚本中使用 getopt</h4><p><code>set</code> 命令能够处理 shell 中的各种变量</p>
<h3 id="14-4-3-使用更高级的-getopts"><a href="#14-4-3-使用更高级的-getopts" class="headerlink" title="14.4.3 使用更高级的 getopts"></a>14.4.3 使用更高级的 getopts</h3><p>getopts 内建于 bash shell, 比 getopt 多了一些扩展功能.</p>
<p>每次调用 getopts, 它一次只处理命令行上检测到的一个参数. 处理完所有参数后, 它会退出并返回一个大于 0 的推出状态码.</p>
<p>格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">getopts</span> optstring variabel<br></code></pre></td></tr></table></figure>
<p>要去掉错误信息的话, 可以在 optstring 之前加一个冒号. </p>
<p>getopts 命令会将当前参数保存在命令行中定义的 variable 中.</p>
<p>getopts 命令会用到两个环境变量:</p>
<ul>
<li>OPTARG : 会保存选项后跟的参数值</li>
<li>OPTIND : 保存参数列表中 getopts 正在处理的参数的位置, 毕竟这个函数一次只处理一个选项. 第一个选项的位置为 1</li>
</ul>
<p>getopts 命令解析命令行选项时会移除开头的单破折号, 因此在 case 中定义时不用单破折号.</p>
<p>getopts 命令可以在参数值之间加空格, 如 <code>&quot;test1 test2&quot;</code>, 也可以把选项字母和参数值放在一起使用, 而不加空格 <code>./test.sh -abtest1</code>.</p>
<p>getopts 还能将命令行上找到的所有未定义的选项统一输出成问号.</p>
<p>在 getopts 每处理一个选项, 其会把 OPTIND 环境变量值加一.</p>
<h2 id="14-5-将选项标准化"><a href="#14-5-将选项标准化" class="headerlink" title="14.5 将选项标准化"></a>14.5 将选项标准化</h2><p>Linux 命令行中的选项好多已经有了不成文的含义.</p>
<h2 id="14-6-获取用户输入"><a href="#14-6-获取用户输入" class="headerlink" title="14.6 获取用户输入"></a>14.6 获取用户输入</h2><h3 id="14-6-1-基本的读取"><a href="#14-6-1-基本的读取" class="headerlink" title="14.6.1 基本的读取"></a>14.6.1 基本的读取</h3><p>read 命令从标准输入或另一个文件描述符号中接受输入, 在收到输入后, read 命令会将数据放进一个变量.</p>
<p>例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Enter your name:&quot;</span><br><span class="hljs-built_in">read</span> name<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello <span class="hljs-variable">$name</span>, welcome to my program&quot;</span><br></code></pre></td></tr></table></figure>
<p>这里 <code>echo</code> 的 <code>-n</code> 选项表示不会在字符串末尾输出换行符.</p>
<p>这里, read 把读取的值存入 <code>name</code> 这个变量.</p>
<p>read 的 <code>-p</code> 选项, 允许在命令行直接指定提示符:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Please enter your age: &quot;</span> age<br></code></pre></td></tr></table></figure>
<p>这里 <code>Please enter your age: </code> 就和之前使用 <code>echo</code> 是一样的.</p>
<p>可以指定多个变量.</p>
<p>如果不指定变量, 值会被存在 <code>REPLY</code> 这个环境变量中.</p>
<h3 id="14-6-2-超时"><a href="#14-6-2-超时" class="headerlink" title="14.6.2 超时"></a>14.6.2 超时</h3><p>使用 <code>-t</code> 选项, 指定 read 命令等待输入的秒数, 当计时器过期后, read 命令会返回一个非零退出状态码.</p>
<p>使用 <code>-n</code> 选项, 可以让 read 命令在读取指定字符数后退出. 如 <code>read -n1</code> 表示接受单个字符</p>
<h3 id="14-6-3-隐藏方式读取"><a href="#14-6-3-隐藏方式读取" class="headerlink" title="14.6.3 隐藏方式读取"></a>14.6.3 隐藏方式读取</h3><p><code>-s</code> 选项, 避免在 read 命令中输入的数据出现在显示器上, 实际上, 数据会被显示, 只是 read 命令会将文本颜色设成跟背景色一样.</p>
<h3 id="14-6-4-从文件中读取"><a href="#14-6-4-从文件中读取" class="headerlink" title="14.6.4 从文件中读取"></a>14.6.4 从文件中读取</h3><p>每次调用 read 命令, 他都会从文件中读取一行文本, 当文件中再没有内容时, read 命令退出并返回非零状态码.</p>
<p>最常见的方法是对文件使用 cat 命令, 将结果通过管道直接传给含有 read 命令的 while 命令.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash    </span><br>count=1<br><span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span> | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line <br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Line <span class="hljs-variable">$count</span>: <span class="hljs-variable">$line</span>&quot;</span><br>    count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Finished processing the file&quot;</span><br></code></pre></td></tr></table></figure>
<h1 id="第15章-呈现数据"><a href="#第15章-呈现数据" class="headerlink" title="第15章 呈现数据"></a>第15章 呈现数据</h1><h2 id="15-1-理解输入和输出"><a href="#15-1-理解输入和输出" class="headerlink" title="15.1 理解输入和输出"></a>15.1 理解输入和输出</h2><h3 id="15-1-1-标准文件描述符"><a href="#15-1-1-标准文件描述符" class="headerlink" title="15.1.1 标准文件描述符"></a>15.1.1 标准文件描述符</h3><p>Linux 系统将每个对象当作文件处理.</p>
<p>Linux 用文件描述符 (file descriptor) 来标识每个文件对象.</p>
<p>每个进程一次最多可以有九个文件描述符, bash shell 保留了前三个文件描述符.</p>
<ul>
<li>0 SIDIN  标准输入</li>
<li>1 STDOUT 标准输出</li>
<li>2 STDERR 标准错误</li>
</ul>
<p>当命令生成错误消息时, shell 并未将错误消息重定向到输出重定向文件.</p>
<p>默认情况下, STDERR 文件描述符和 STDOUT 文件描述符指向同样的地方.</p>
<h3 id="15-1-2-重定向错误"><a href="#15-1-2-重定向错误" class="headerlink" title="15.1.2 重定向错误"></a>15.1.2 重定向错误</h3><h4 id="1-只重定向错误"><a href="#1-只重定向错误" class="headerlink" title="1. 只重定向错误"></a>1. 只重定向错误</h4><p>可以选择只重定向错误消息, 将该文件描述符放在重定向符号前, 该值必须紧紧地放在重定向符号前.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al badfile 2&gt; <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure>
<h4 id="2-重定向错误和数据"><a href="#2-重定向错误和数据" class="headerlink" title="2. 重定向错误和数据"></a>2. 重定向错误和数据</h4><p>需要用两个重定向符号, 且在符号前面放上待重定向数据对应的文件描述符:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al <span class="hljs-built_in">test</span> test2 test3 badfile 2&gt; test6 1&gt; test7</span><br></code></pre></td></tr></table></figure>
<p>可以利用 <code>&amp;&gt;</code> 这个特殊的重定向符号, 把 STDOUT 和 STDERR 重定向到同一个文件.</p>
<p>为了避免错误信息散落在输出文件中, 相较于标准输出, bash shell 自动赋予了错误消息更高的优先级.</p>
<h2 id="15-2-在脚本中重定向输出"><a href="#15-2-在脚本中重定向输出" class="headerlink" title="15.2 在脚本中重定向输出"></a>15.2 在脚本中重定向输出</h2><p>有两种方法在脚本中重定向输出:</p>
<ul>
<li>临时重定向行输出</li>
<li>永久重定向脚本中的所有输出</li>
</ul>
<h3 id="15-2-1-临时重定向"><a href="#15-2-1-临时重定向" class="headerlink" title="15.2.1 临时重定向"></a>15.2.1 临时重定向</h3><p>在重定向到文件描述符时, 必须在文件描述符数字之前加一个 <code>&amp;</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is an error&quot;</span> &gt;&amp;2<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is an normal output&quot;</span><br></code></pre></td></tr></table></figure>
<p>默认情况下, Linxu 会将 STDERR 导向 STDOUT, 如果在运行脚本时重定向了 STDERR, 脚本中所有导向 STDERR 的文本都会被重定向.</p>
<h3 id="15-2-2-永久重定向"><a href="#15-2-2-永久重定向" class="headerlink" title="15.2.2 永久重定向"></a>15.2.2 永久重定向</h3><p>可以用 exec 命令告诉 shell 在执行脚本期间重定向某个特定的文件描述符:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">1</span>&gt;testout<br></code></pre></td></tr></table></figure>
<p>exec 命令会启动一个新 shell 并将 STDOUT 文件描述符重定向到文件. 这里实际上把 1 这个文件描述重新分配给了 testout 这个文件.</p>
<p>exec 在 man page 中的描述为: execute commands and open, close, or copy file descriptors.</p>
<h2 id="15-3-在脚本中重定向输入"><a href="#15-3-在脚本中重定向输入" class="headerlink" title="15.3 在脚本中重定向输入"></a>15.3 在脚本中重定向输入</h2><p>exec 命令允许你将 STDIN 重定向到 Linux 系统上的文件中:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">0</span>&lt; testfile<br></code></pre></td></tr></table></figure>
<p>如 :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">exec</span> 0&lt; testfile<br>count=0<br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line<br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Line #<span class="hljs-variable">$count</span>: line&quot;</span><br>    count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<h2 id="15-4-创建自己的重定向"><a href="#15-4-创建自己的重定向" class="headerlink" title="15.4 创建自己的重定向"></a>15.4 创建自己的重定向</h2><h3 id="15-4-1-创建输出文件描述符"><a href="#15-4-1-创建输出文件描述符" class="headerlink" title="15.4.1 创建输出文件描述符"></a>15.4.1 创建输出文件描述符</h3><p>可以用 exec 命令来给输出分配文件描述符.</p>
<p>一旦将另一个文件描述符分配给一个文件, 这个重定向就会一直有效, 直到你重新分配.</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">3</span>&gt;testout<br></code></pre></td></tr></table></figure>
<h3 id="15-4-2-重定向文件描述符"><a href="#15-4-2-重定向文件描述符" class="headerlink" title="15.4.2 重定向文件描述符"></a>15.4.2 重定向文件描述符</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">3</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>把文件描述符 3 指向文件描述符 1.</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">1</span>&gt;&amp;<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p>恢复.</p>
<h3 id="15-4-3-创建输入文件描述符"><a href="#15-4-3-创建输入文件描述符" class="headerlink" title="15.4.3 创建输入文件描述符"></a>15.4.3 创建输入文件描述符</h3><p>在重定向到文件之前, 先将 STDIN 文件描述符保存到另外一个文件描述符, 然后在读取完文件之后再将 STDIN 恢复到它原来的位置:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-built_in">exec</span> 6&lt;&amp;0<br><br><span class="hljs-built_in">exec</span> 0&lt; testfile<br><br>count=1<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line <br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Line #<span class="hljs-variable">$count</span>: <span class="hljs-variable">$line</span>&quot;</span><br>    count=[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">exec</span> 0&lt;&amp;6<br></code></pre></td></tr></table></figure>
<h3 id="15-4-4-创建读写文件描述符"><a href="#15-4-4-创建读写文件描述符" class="headerlink" title="15.4.4 创建读写文件描述符"></a>15.4.4 创建读写文件描述符</h3><p>可以打开单个文件描述符来作为输入和输出.</p>
<p>任何读或写都会从文件指针上次的位置开始, 比如你先用这个文件描述符输出了一行, 这时这个指针就指向这一行的末尾了, 如果你这个时候输入一段文本, 这个文本就会插入到这个指针所指的位置, 而不是文件的末尾.</p>
<h3 id="15-4-5-关闭文件描述符"><a href="#15-4-5-关闭文件描述符" class="headerlink" title="15.4.5 关闭文件描述符"></a>15.4.5 关闭文件描述符</h3><p>如果你创建了新的输入或输出文件描述符, shell 会在脚本退出时自动关闭它们.</p>
<p>在脚本结束前手动关闭文件描述符, 需要将它重定向到特殊符号 <code>&amp;-</code>:</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">exec <span class="hljs-number">3</span>&gt;<span class="hljs-meta">&amp;-</span><br></code></pre></td></tr></table></figure>
<p>在关闭文件描述符后, 如果你随后在脚本中打开了同一个文件, shell 会用一个新文件来替换已有的文件, 意思就是其内容会被覆盖.</p>
<h2 id="15-5-列出打开的文件描述符"><a href="#15-5-列出打开的文件描述符" class="headerlink" title="15.5 列出打开的文件描述符"></a>15.5 列出打开的文件描述符</h2><p>使用 <code>isof</code> 命令列出 Linux 系统打开的所有文件描述符.</p>
<h2 id="15-6-阻止命令输出"><a href="#15-6-阻止命令输出" class="headerlink" title="15.6 阻止命令输出"></a>15.6 阻止命令输出</h2><p>可以将 STDERR 的输出从定向到叫 null 文件的特殊文件.</p>
<p>shell 输出到 null 文件的任何数据都不会保存, 全部都会被丢弃.</p>
<p>在 Linux 系统上 null 文件的标准位置是 &#x2F;dev&#x2F;null.</p>
<p>也可以用 &#x2F;dev&#x2F;null 作为输入文件, 其能够快速清除现有文件中的数据.</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ cat <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span> &gt; testfile<br></code></pre></td></tr></table></figure>
<h2 id="15-7-创建临时文件"><a href="#15-7-创建临时文件" class="headerlink" title="15.7 创建临时文件"></a>15.7 创建临时文件</h2><p>Linux 使用 &#x2F;tmp 目录来存放不需要用就保存的文件, 大多数 Linux 发行版配置了系统在启动时自动删除 &#x2F;tmp 目录的所有文件.</p>
<p><code>mktemp</code> 命令可以在 <code>/tmp</code> 目录中创建一个唯一的临时文件, shell 会创建这个文件, 但不用默认的 umask 值. 它会将文件的读和写权限分配给文件的属主, 并将你设成文件的属主.</p>
<h3 id="15-7-1-创建本地临时文件"><a href="#15-7-1-创建本地临时文件" class="headerlink" title="15.7.1 创建本地临时文件"></a>15.7.1 创建本地临时文件</h3><p>要用 mktemp 命令在本地目录中创建一个唯一文件, 需要指定一个文件名模板, 模板可以包含任意文本文件名, 在文件名末尾加上 6 个 X 就行了, mktemp 命令会用 6 个字符码替换这 6 个 X, 从而保证文件名在目录中唯一.</p>
<p>将文件名保存在变量中:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">tempfile=<span class="hljs-constructor">$(<span class="hljs-params">mktemp</span> <span class="hljs-params">test</span>.XXXXXX)</span><br></code></pre></td></tr></table></figure>
<h3 id="15-7-2-在-x2F-tmp-目录创建临时文件"><a href="#15-7-2-在-x2F-tmp-目录创建临时文件" class="headerlink" title="15.7.2 在 &#x2F;tmp 目录创建临时文件"></a>15.7.2 在 &#x2F;tmp 目录创建临时文件</h3><p>使用 <code>-t</code> 选项, 其会强制 mktemp 命令来到系统的临时目录来创建该文件, 在使用这个特性时, mktemp 命令会返回用来创建临时文件时的全路径.</p>
<h3 id="15-7-3-创建临时目录"><a href="#15-7-3-创建临时目录" class="headerlink" title="15.7.3 创建临时目录"></a>15.7.3 创建临时目录</h3><p><code>-d</code> 选项告诉 mktemp 创建一个临时目录.</p>
<h2 id="15-8-记录消息"><a href="#15-8-记录消息" class="headerlink" title="15.8 记录消息"></a>15.8 记录消息</h2><p>使用特殊的 tee 命令, 可以将输出同时发送到显示器和日志文件.</p>
<p>它会将从 STDIN 过来的数据同时发送到两处, 一处是 STDOUT, 一处是 tee 命令行所指定的文件:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">tee</span> filename<br></code></pre></td></tr></table></figure>
<p>可以配合管道符 <code>|</code>.</p>
<p>如果想将数据追加到文件, 必须使用 <code>-a</code> 选项.</p>
<h1 id="第19章-初识-sed-和-gawk"><a href="#第19章-初识-sed-和-gawk" class="headerlink" title="第19章 初识 sed 和 gawk"></a>第19章 初识 sed 和 gawk</h1><h2 id="19-1-文本处理"><a href="#19-1-文本处理" class="headerlink" title="19.1 文本处理"></a>19.1 文本处理</h2><h3 id="19-1-1-sed-编辑器"><a href="#19-1-1-sed-编辑器" class="headerlink" title="19.1.1 sed 编辑器"></a>19.1.1 sed 编辑器</h3><p>sed 编辑器被称作流编辑器 (stream editor), 和交互式编辑器 (如 vim) 恰好相反.</p>
<p>sed 编辑器的操作:</p>
<ol>
<li>一次从输入中读取一行数据</li>
<li>根据所提供的编辑器命令匹配数据</li>
<li>按照命令修改流中的数据</li>
<li>将新的数据输出到 STDOUT</li>
</ol>
<p>命令格式:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">sed options <span class="hljs-keyword">script</span> <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure>
<p>可用选项:</p>
<ul>
<li><code>-e script</code>   在处理输入时，将 script 中指定的命令添加到已有的命令中</li>
<li><code>-f file</code>     在处理输入时，将 file 中指定的命令添加到已有的命令中</li>
<li><code>-n</code>          不产生命令输出，使用 print 命令来完成输出</li>
</ul>
<p>sed 编辑器并不会修改文本文件的数据，它只会将修改后的数据发送到 STDOUT.</p>
<p>替换命令, 如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is a test&quot;</span> | sed <span class="hljs-string">&#x27;s/test/big test/&#x27;</span></span> <br></code></pre></td></tr></table></figure>
<h4 id="执行多个命令"><a href="#执行多个命令" class="headerlink" title="执行多个命令"></a>执行多个命令</h4><p>执行多个命令时使用 <code>-e</code> 选项:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed -e <span class="hljs-string">&#x27;s/brown/green/; s/dog/cat/&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>命令用分号 <code>;</code> 隔开，且必须位于命令末尾，不能有空格.</p>
<h4 id="多行命令"><a href="#多行命令" class="headerlink" title="多行命令"></a>多行命令</h4><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed -e &#x27;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/brown/green/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/fox/elephant/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/dog/cat/<span class="hljs-string">&#x27; data1.txt</span></span><br></code></pre></td></tr></table></figure>
<h4 id="从文件中获取命令"><a href="#从文件中获取命令" class="headerlink" title="从文件中获取命令"></a>从文件中获取命令</h4><p>每个命令占一行，可以给文件添加后缀 <code>.sed</code></p>
<h3 id="19-1-2-gawk-程序"><a href="#19-1-2-gawk-程序" class="headerlink" title="19.1.2 gawk 程序"></a>19.1.2 gawk 程序</h3><p>在所有的发行版中都没有默认安装 gawk 程序。</p>
<p>gawk 是原始 awk 的 GNU 版本。</p>
<p>gawk 提供了一种编程语言。</p>
<p>基本格式:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">gawk <span class="hljs-keyword">option</span> program <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure>
<p>可用选项:</p>
<ul>
<li><code>-F FS</code>, 指定行中划分数据字段的字段分隔符</li>
<li><code>-f file</code>, 从指定的文件中读取程序</li>
<li><code>-v var=value</code>, 定义 gawk 程序中的一个变量及其默认值</li>
<li><code>-mf N</code>, 指定要处理文件中的最大字段数</li>
<li><code>-mr N</code>, 指定数据文件中的最大数据行数</li>
<li><code>-W keyword</code>, 指定 gawk 中兼容模式或警告等级</li>
</ul>
<p>gawk 的脚本用一对花括号来定义，必须把脚本命令放在一对花括号中 <code>&#123;&#125;</code>.</p>
<p>gawk 命令行假定脚本是单个文本字符串, 因此还需要把脚本放到单引号中:</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">$ gawk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Hello World&quot;</span>&#125;&#x27;<br></code></pre></td></tr></table></figure>
<p>gawk 会从 STDIN 等待输入数据。</p>
<p>gawk 会对数据中的每行文本执行程序.</p>
<p>使用 <code>Ctrl + D</code> 终止程序.</p>
<h4 id="使用数据字段变量"><a href="#使用数据字段变量" class="headerlink" title="使用数据字段变量"></a>使用数据字段变量</h4><p>gawk 会给一行中的每个数据元素分配一个变量, 默认为:</p>
<ul>
<li><code>$0</code>, 代表整个文本行</li>
<li><code>$1</code>, 代表文本行中的第1个数据字段</li>
<li><code>$2</code>, 代表文本行中的第2个数据字段</li>
<li><code>$n</code>, 代表文本行中的第n个数据字段<br>在文本行中，每个数据字段都是通过<mark>字段分隔符</mark>划分的。默认为任意的空白字符.</li>
</ul>
<h4 id="在程序脚本中使用多个命令"><a href="#在程序脚本中使用多个命令" class="headerlink" title="在程序脚本中使用多个命令"></a>在程序脚本中使用多个命令</h4><p>使用分号 <code>;</code> 分隔.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">$ gawk <span class="hljs-string">&#x27;&#123;<span class="hljs-subst">$4</span>=&quot;Christine&quot;; print <span class="hljs-subst">$0</span>&#125;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>一次一行:</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ gawk &#x27;&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">$<span class="hljs-number">4</span>=<span class="hljs-string">&quot;Christine</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">print $0&#125;&#x27;</span></span><br></code></pre></td></tr></table></figure>
<h4 id="从文件中读取程序"><a href="#从文件中读取程序" class="headerlink" title="从文件中读取程序"></a>从文件中读取程序</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> gawk <span class="hljs-operator">-F</span>: <span class="hljs-operator">-f</span> script2.gawk /etc/passwd<br></code></pre></td></tr></table></figure>
<p>脚本文件中一条命令一行，不需要分号，但需要一对花括号.</p>
<h4 id="在读取数据前运行脚本"><a href="#在读取数据前运行脚本" class="headerlink" title="在读取数据前运行脚本"></a>在读取数据前运行脚本</h4><p>gawk 允许指定程序脚本何时运行。</p>
<p><code>BEGIN</code> 关键词，让程序在读取数据前运行脚本 </p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ gawk <span class="hljs-symbol">&#x27;BEGIN</span> &#123;print <span class="hljs-string">&quot;Hello World&quot;</span>&#125;&#x27;<br></code></pre></td></tr></table></figure>
<h4 id="在处理数据后运行脚本"><a href="#在处理数据后运行脚本" class="headerlink" title="在处理数据后运行脚本"></a>在处理数据后运行脚本</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">$ gawk &#x27;<span class="hljs-type">END</span> &#123;print <span class="hljs-string">&quot;End of File&quot;</span>&#125;&#x27; <span class="hljs-class"><span class="hljs-keyword">data</span>.txt</span><br></code></pre></td></tr></table></figure>
<h2 id="19-2-sed-编辑器基础"><a href="#19-2-sed-编辑器基础" class="headerlink" title="19.2 sed 编辑器基础"></a>19.2 sed 编辑器基础</h2><h3 id="19-2-1-更多的替换选项"><a href="#19-2-1-更多的替换选项" class="headerlink" title="19.2.1 更多的替换选项"></a>19.2.1 更多的替换选项</h3><h4 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h4><p>替换命令在替换多行文本时能够正常工作，但默认情况下它只替换每行中出现的第一处.</p>
<p>四种替换标签 (substitution flag):</p>
<ul>
<li>数字，表明新文本将替换地挤出模式匹配的地方</li>
<li>g, 表明新文本将会替换所有匹配的文本</li>
<li>p, 表明输出修改过的行, 通常和 <code>-n</code> 选项一起用</li>
<li>w file, 将替换结果写到文件中<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ sed &#x27;s/<span class="hljs-keyword">test</span>/trial/w <span class="hljs-keyword">test</span>.txt&#x27; data.txt<br></code></pre></td></tr></table></figure>
这里的 <code>test.txt</code> 是指定的用来保存的文件.</li>
</ul>
<h4 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h4><p>sed 允许选择其他字符作为替换命令中的分隔符:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sed <span class="hljs-string">&#x27;s!/bin/bash!/bin/csh!&#x27;</span> <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure>
<p>这里用 <code>!</code> 作为分隔符.</p>
<h3 id="19-2-2-使用地址"><a href="#19-2-2-使用地址" class="headerlink" title="19.2.2 使用地址"></a>19.2.2 使用地址</h3><p>使用行寻址 (line addressing), 将命令作用于特定行或某些行.</p>
<p>两种形式:</p>
<ul>
<li>以数字形式表示行区间</li>
<li>用文本模式来过滤出行</li>
</ul>
<p>格式均为:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[address]</span>command<br></code></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">address &#123;<br>  comma<span class="hljs-symbol">nd1</span><br>  comma<span class="hljs-symbol">nd2</span><br>  comma<span class="hljs-symbol">nd3</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>sed 编辑器会将指定的每条命令作用到匹配指定地址的行上.</p>
<h4 id="数字形式的行寻址"><a href="#数字形式的行寻址" class="headerlink" title="数字形式的行寻址"></a>数字形式的行寻址</h4><p>可以是行号，也可以是区间:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2s/dog/cat/&#x27;</span> data.txt<br><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2,3s/dog/cat/&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>美元符 <code>$</code> 是特殊地址，表示最后一行.</p>
<h4 id="使用文本模式过滤器"><a href="#使用文本模式过滤器" class="headerlink" title="使用文本模式过滤器"></a>使用文本模式过滤器</h4><p>格式为:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/pattern/</span>command<br></code></pre></td></tr></table></figure>
<p>必须用正斜线 <code>/</code> 将指定的 <code>pattern</code> 封起来，sed 编辑器会将命令作用到包含指定文本模式的行上.</p>
<p>如:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sed <span class="hljs-string">&#x27;/Samantha/s/bash/csh/&#x27;</span> <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure>
<p>在前面的文本模式中可以使用正则表达式.</p>
<h4 id="命令组合"><a href="#命令组合" class="headerlink" title="命令组合"></a>命令组合</h4><p>在单行执行多条命令:</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed &#x27;2&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/fox/elephant/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/dog/cat/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; data.txt</span></span><br></code></pre></td></tr></table></figure>

<h3 id="19-2-3-删除行"><a href="#19-2-3-删除行" class="headerlink" title="19.2.3 删除行"></a>19.2.3 删除行</h3><p>删除命令 <code>d</code>, 它会删除匹配指定寻址模式的所有行。</p>
<p>删除所有行:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>指定行号:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;3d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>指定区间:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2.3d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>使用文本模式:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;/pattern/d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>使用两个文本模式删除某个区间，第一个文本模式会打开”删除”功能，第二个文本模式匹配结束后会关闭”删除”功能:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;/1/,/3/d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<h3 id="19-2-4-插入和附加文本"><a href="#19-2-4-插入和附加文本" class="headerlink" title="19.2.4 插入和附加文本"></a>19.2.4 插入和附加文本</h3><ul>
<li>插入 (insert) 命令 (i) 会在指定行前增加一个新行</li>
<li>附加 (append) 命令 (a) 会在指定行后增加一个新行<br>格式:<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;[address]command\ new_line_contents&#x27;</span><br></code></pre></td></tr></table></figure>
注意这里是反斜线.</li>
</ul>
<p>如:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;3i\ This is an insert line&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>这样写更清晰:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;3i\</span><br><span class="hljs-string">&gt; This is an insert line&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<h3 id="19-2-5-修改行"><a href="#19-2-5-修改行" class="headerlink" title="19.2.5 修改行"></a>19.2.5 修改行</h3><p>修改 (change) 命令允许修改数据流中整行文本的内容，其跟插入和附加命令的工作机制一样.</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ sed &#x27;<span class="hljs-number">3</span>c\<br>&gt; This <span class="hljs-keyword">is</span> a changed <span class="hljs-literal">line</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">text</span>&#x27; data.txt<br></code></pre></td></tr></table></figure>
<p>也可以用文本模式寻址:</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ sed &#x27;/pattern/c\<br>&gt; This <span class="hljs-keyword">is</span> a changed <span class="hljs-literal">line</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">text</span>&#x27; data.txt<br></code></pre></td></tr></table></figure>
<p>若用区间会出问题:</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ sed &#x27;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>\c<br>&gt; This <span class="hljs-keyword">is</span> a <span class="hljs-keyword">new</span> <span class="hljs-literal">line</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">text</span>&#x27; data.txt<br></code></pre></td></tr></table></figure>
<p>其会把 <code>2,3</code> 区间的行改为一行.</p>
<h3 id="19-2-6-转换命令"><a href="#19-2-6-转换命令" class="headerlink" title="19.2.6 转换命令"></a>19.2.6 转换命令</h3><p>转换 (transform) 命令 (y) 是唯一可以处理单个字符的 sed 编辑器命令。</p>
<p>格式:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[address]y<span class="hljs-regexp">/inchars/</span>outchars/<br></code></pre></td></tr></table></figure>
<p>不要把 <code>inchars</code> 和 <code>outchars</code> 看做一个单词，应为一个个字符，其映射为一一对应，个数不一致会报错:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;y/123/456&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>文件里面所有的 <code>1</code> 会被替换为 <code>4</code>.</p>
<h3 id="19-2-7-回顾打印"><a href="#19-2-7-回顾打印" class="headerlink" title="19.2.7 回顾打印"></a>19.2.7 回顾打印</h3><p>用于打印数据流中的信息:</p>
<ul>
<li>p命令用来打印文本行</li>
<li>等号 (&#x3D;) 用来打印行号</li>
<li>1 (小写的L) 用来列出行</li>
</ul>
<h4 id="打印行"><a href="#打印行" class="headerlink" title="打印行"></a>打印行</h4><p>打印指定行地址的行:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed -n <span class="hljs-string">&#x27;2,3p&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>打印包含文本模式匹配上的行:</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed -n &#x27;/pattern/&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">p</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/line/test/p</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; data.txt</span></span><br></code></pre></td></tr></table></figure>
<h4 id="打印行号"><a href="#打印行号" class="headerlink" title="打印行号"></a>打印行号</h4><p>使用 <code>=</code>:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> <span class="hljs-keyword">set</span> <span class="hljs-string">&#x27;=&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>sed 在实际文本出现之前打印出行号。</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ set -n &#x27;/number 4/&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">=</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">p</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; data.txt</span></span><br></code></pre></td></tr></table></figure>
<h4 id="列出行"><a href="#列出行" class="headerlink" title="列出行"></a>列出行</h4><p>列出 (list) 命令 (l) 可以打印数据流中的文本和不可打印的 ASCII 字符。</p>
<p>任何不可打印字符要么在其八进制值前加一个反斜线，要么使用 C 语言风格的命名法, 如 <code>\t</code>.</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span> data.txt<br>This  line  contains  tabs<br><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span> sed <span class="hljs-literal">-n</span> <span class="hljs-string">&#x27;l&#x27;</span> data.txt<br>This\tline\tcontains\ttabs<span class="hljs-variable">$</span><br></code></pre></td></tr></table></figure>
<h3 id="19-2-8-使用-sed-处理文件"><a href="#19-2-8-使用-sed-处理文件" class="headerlink" title="19.2.8 使用 sed 处理文件"></a>19.2.8 使用 sed 处理文件</h3><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2.3w test.txt&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<h4 id="从文件读取数据"><a href="#从文件读取数据" class="headerlink" title="从文件读取数据"></a>从文件读取数据</h4><p>读取 (read) 命令 (r) 允许将一个独立文件中的数据插入到数据流中。</p>
<p>格式:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[address]</span>r filename<br></code></pre></td></tr></table></figure>
<p>sed 编辑器会将文件中的文本插入到指定地址之后.</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed &#x27;/LIST/&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">r detail.<span class="hljs-property">txt</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">d</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; notice.std</span></span><br></code></pre></td></tr></table></figure>
<p>前面的文本模式对后面的命令都起效果.</p>
<h1 id="第20章-正则表达式"><a href="#第20章-正则表达式" class="headerlink" title="第20章 正则表达式"></a>第20章 正则表达式</h1><h2 id="20-1-什么是正则表达式"><a href="#20-1-什么是正则表达式" class="headerlink" title="20.1 什么是正则表达式"></a>20.1 什么是正则表达式</h2><h3 id="20-1-1-定义"><a href="#20-1-1-定义" class="headerlink" title="20.1.1 定义"></a>20.1.1 定义</h3><p>正则表达式是你所定义的模式模板 (pattern template), Linux 工具可以用它来过滤文本.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Shell/" class="category-chain-item">Shell</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Linux Command Line and Shell Scripting Bible Notes</div>
      <div>http://example.com/2022/07/17/Linux-Command-Line-and-Shell-Scripting-Bible-Notes/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年7月17日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/18/Linux-System-Programming/" title="Linux System Programming">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux System Programming</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/16/Sentences/" title="Sentences">
                        <span class="hidden-mobile">Sentences</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
