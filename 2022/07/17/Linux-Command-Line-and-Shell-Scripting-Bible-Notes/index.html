

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/wallhaven-j5kjgy_1920x1080.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="第六章 使用 Linux 环境变量6.7 数组变量环境变量有一个很酷的特性就是, 它们可作为数组使用. 要给某个环境变量设置多个值, 可以把值放在括号里, 值与值之间用空格分隔: 1$ mytest&#x3D;(one two three four five) 使用索引值引用: 1$ echo $&amp;#123;mytest[2]&amp;#125; 从 0 开始. 要显示整个数组变量, 可用星号作为通配符放在索引值的">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Command Line and Shell Scripting Bible Notes">
<meta property="og:url" content="http://example.com/2022/07/17/Linux-Command-Line-and-Shell-Scripting-Bible-Notes/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第六章 使用 Linux 环境变量6.7 数组变量环境变量有一个很酷的特性就是, 它们可作为数组使用. 要给某个环境变量设置多个值, 可以把值放在括号里, 值与值之间用空格分隔: 1$ mytest&#x3D;(one two three four five) 使用索引值引用: 1$ echo $&amp;#123;mytest[2]&amp;#125; 从 0 开始. 要显示整个数组变量, 可用星号作为通配符放在索引值的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/gawk_var.png">
<meta property="og:image" content="http://example.com/img/formatstring.png">
<meta property="og:image" content="http://example.com/img/mathfn.png">
<meta property="og:image" content="http://example.com/img/bitopr.png">
<meta property="og:image" content="http://example.com/img/strfn1.png">
<meta property="og:image" content="http://example.com/img/strfn2.png">
<meta property="og:image" content="http://example.com/img/timefn.png">
<meta property="article:published_time" content="2022-07-17T04:43:22.000Z">
<meta property="article:modified_time" content="2022-11-28T03:06:44.753Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/gawk_var.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Linux Command Line and Shell Scripting Bible Notes - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jie</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/SteinsGate_all.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Linux Command Line and Shell Scripting Bible Notes"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-07-17 12:43" pubdate>
          2022年7月17日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          25k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          210 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Linux Command Line and Shell Scripting Bible Notes</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第六章-使用-Linux-环境变量"><a href="#第六章-使用-Linux-环境变量" class="headerlink" title="第六章 使用 Linux 环境变量"></a>第六章 使用 Linux 环境变量</h1><h2 id="6-7-数组变量"><a href="#6-7-数组变量" class="headerlink" title="6.7 数组变量"></a>6.7 数组变量</h2><p>环境变量有一个很酷的特性就是, 它们可作为数组使用.</p>
<p>要给某个环境变量设置多个值, 可以把值放在括号里, 值与值之间用空格分隔:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ mytest=(<span class="hljs-literal">one</span> <span class="hljs-literal">two</span> <span class="hljs-literal">three</span> <span class="hljs-literal">four</span> <span class="hljs-literal">five</span>)<br></code></pre></td></tr></table></figure>
<p>使用索引值引用:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;mytest[2]&#125;</span></span><br></code></pre></td></tr></table></figure>
<p>从 0 开始.</p>
<p>要显示整个数组变量, 可用星号作为通配符放在索引值的位置:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;mytest[*]&#125;</span></span><br></code></pre></td></tr></table></figure>

<p>可以使用 unset 来删除数组中的某个值, 但其他元素的位置不变, 只是被删除的这个值的位置此时的值为空:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">unset</span> mytest[2]</span><br></code></pre></td></tr></table></figure>

<p>可以删掉整个数组:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">unset</span> mytest</span><br></code></pre></td></tr></table></figure>



<h1 id="第十一章-构建基本脚本"><a href="#第十一章-构建基本脚本" class="headerlink" title="第十一章 构建基本脚本"></a>第十一章 构建基本脚本</h1><h2 id="11-4-使用变量"><a href="#11-4-使用变量" class="headerlink" title="11.4 使用变量"></a>11.4 使用变量</h2><p>多个命令在同一行执行，使用分号隔开:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> ; <span class="hljs-built_in">who</span></span><br></code></pre></td></tr></table></figure>

<p>如果文本文件开头的最前面两个字符是<code>#!</code>，那么后面跟着的就是用来执行这个文件的程序路径.</p>
<p>shell 通过PATH环境变量来查找命令.</p>
<p>引用当前目录下的文件，可以使用shell中使用单点操作符:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./test1</span><br></code></pre></td></tr></table></figure>

<p>对于文件而言，全权限值为666, 对于目录而言，全权限值为777.</p>
<p>默认权限值为全权限值减去umask变量的值.</p>
<h3 id="11-4-2-用户变量"><a href="#11-4-2-用户变量" class="headerlink" title="11.4.2 用户变量"></a>11.4.2 用户变量</h3><p>在变量、等号和值之间不能出现空格.</p>
<p>shell 脚本会自动决定变量值的数据类型.</p>
<p>引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时不要使用美元符:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">value1</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">value2</span>=<span class="hljs-variable">$value1</span><br></code></pre></td></tr></table></figure>
<p>没有美元符，shell会将变量名解释成普通的文本字符串.</p>
<h3 id="11-4-3-命令替换"><a href="#11-4-3-命令替换" class="headerlink" title="11.4.3 命令替换"></a>11.4.3 命令替换</h3><p>命令替换允许你将shell命令的输出赋给变量, 有两个格式:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">反引号字符<span class="hljs-comment">(`)</span><br>$<span class="hljs-comment">()</span>格式<br></code></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">testing</span>=`date`<br><span class="hljs-attr">testing</span>=$(date)<br></code></pre></td></tr></table></figure>
<p>命令替换会创建一个子shell来运行对应的命令.</p>
<h2 id="11-5-重定向输入和输出"><a href="#11-5-重定向输入和输出" class="headerlink" title="11.5 重定向输入和输出"></a>11.5 重定向输入和输出</h2><h2 id="11-7-执行数学运算"><a href="#11-7-执行数学运算" class="headerlink" title="11.7 执行数学运算"></a>11.7 执行数学运算</h2><h3 id="11-7-1-expr命令"><a href="#11-7-1-expr命令" class="headerlink" title="11.7.1 expr命令"></a>11.7.1 expr命令</h3><p>expr命令允许在命令行上处理数学表达式:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">expr</span> 1 + 5</span><br></code></pre></td></tr></table></figure>
<p>对于那些容易被shell错误解释的字符，在它们传入expr命令之前，需要使用shell的转义字符将其标出来:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">expr</span> 1 \* 5</span><br></code></pre></td></tr></table></figure>
<h3 id="11-7-2-使用方括号"><a href="#11-7-2-使用方括号" class="headerlink" title="11.7.2 使用方括号"></a>11.7.2 使用方括号</h3><p>在bash中，在将一个数学运算结果赋给某个变量时，可以使用美元符和方括号($[ operation ])将数学表达式围起来:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>var1=<span class="hljs-variable">$[</span><span class="hljs-number">1</span> + <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure>
<p>不用担心shell会误解.</p>
<p>bash shell 数学运算符只支持整数运算.</p>
<p>z shell 提供了完整的浮点运算。</p>
<h3 id="11-7-3-浮点解决方案"><a href="#11-7-3-浮点解决方案" class="headerlink" title="11.7.3 浮点解决方案"></a>11.7.3 浮点解决方案</h3><p>使用bash内建的计算器bc.</p>
<p>可以在shell提示符下通过<code>bc</code>命令访问bash计算器.</p>
<p>浮点运算是由内建变量<code>scale</code>控制，用于设置你希望在计算结果中保留的小数位数.</p>
<p>使用<code>-q</code>命令行选项可以不显示bash计算器的欢迎信息.</p>
<h4 id="在脚本中使用bc"><a href="#在脚本中使用bc" class="headerlink" title="在脚本中使用bc"></a>在脚本中使用bc</h4><p>变量名似乎不能是大写字母.</p>
<p>利用命令替换, 基本格式如下:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">variable=<span class="hljs-constructor">$(<span class="hljs-params">echo</span> <span class="hljs-string">&quot;options; expression&quot;</span> | <span class="hljs-params">bc</span>)</span><br></code></pre></td></tr></table></figure>
<p>使用那联输入重定向(inline input redirection), 需指定一个文本标记来划分输入数据的开始和结尾，文本标记可以为任意字符串:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &lt;&lt; <span class="hljs-string">marker</span><br><span class="hljs-string">data</span><br><span class="hljs-string">marker</span><br></code></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">variable=$(bc &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">options</span><br><span class="hljs-string">statements</span><br><span class="hljs-string">expressions</span><br><span class="hljs-string">EOF</span><br>)<br></code></pre></td></tr></table></figure>
<p>在bash计算器中创建的变量只在bash计算其中有效，不能在shell脚本中使用.</p>
<p>计算幂函数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ bc<br>power=10^10<br></code></pre></td></tr></table></figure>
<p>开根号:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ bc<br>result=sqrt(10^10)<br></code></pre></td></tr></table></figure>



<h2 id="11-8-退出脚本"><a href="#11-8-退出脚本" class="headerlink" title="11.8 退出脚本"></a>11.8 退出脚本</h2><p>退出状态码(exit status)，一个0～255的整数值.</p>
<h3 id="11-8-1-查看退出状态码"><a href="#11-8-1-查看退出状态码" class="headerlink" title="11.8.1 查看退出状态码"></a>11.8.1 查看退出状态码</h3><p>变量<code>$?</code>来保存上个已执行命令的退出状态码.</p>
<p>成功结束的命令的退出状态码是0.</p>
<p>无效命令会返回一个exit status为127.</p>
<p>exit status为126表示用户没有执行命令的正确权限。</p>
<h3 id="11-8-2-exit命令"><a href="#11-8-2-exit命令" class="headerlink" title="11.8.2 exit命令"></a>11.8.2 exit命令</h3><p>指定exit status退出.</p>
<h1 id="第12章-使用结构化命令"><a href="#第12章-使用结构化命令" class="headerlink" title="第12章 使用结构化命令"></a>第12章 使用结构化命令</h1><h2 id="12-1-使用if-then语句"><a href="#12-1-使用if-then语句" class="headerlink" title="12.1 使用if-then语句"></a>12.1 使用if-then语句</h2><p>格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span> <br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>查看<code>if</code>后面<code>command</code>的exit status, 是0, 则执行.</p>
<p><code>then</code>部分可以有多条命令.</p>
<h2 id="12-2-if-then-else语句"><a href="#12-2-if-then-else语句" class="headerlink" title="12.2 if-then-else语句"></a>12.2 if-then-else语句</h2><p>格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">else</span> <br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">if</span><br></code></pre></td></tr></table></figure>
<p><code>else</code>部分也可以包含多条命令.</p>
<h2 id="12-3-嵌套if"><a href="#12-3-嵌套if" class="headerlink" title="12.3 嵌套if"></a>12.3 嵌套if</h2><p>使用嵌套的<code>if-then</code>语句.</p>
<p>使用<code>elif</code>语句:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span><br>   commands<br><span class="hljs-keyword">elif</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span> <br>   commands<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<h2 id="12-4-test-命令"><a href="#12-4-test-命令" class="headerlink" title="12.4 test 命令"></a>12.4 test 命令</h2><p>运用<code>test</code>命令通过<code>if-then</code>语句测试其他条件.</p>
<p>如果<code>test</code>命令中列出的条件成立，<code>test</code>命令就会退出并返回exit status 0.</p>
<p>格式:</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">test </span>condition<br></code></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> condition<br><span class="hljs-keyword">then</span><br>   commands<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>如果不写test命令的<code>condition</code>部分，它会以非零的退出状态码退出，并执行else语句快.</p>
<p>可以用test命令确定变量中是否有内容.</p>
<p>另一种测试方法，不需用test命令:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span><span class="hljs-meta"> [ condition ]</span><br><span class="hljs-attribute">then</span><br>   <span class="hljs-attribute">commands</span><br><span class="hljs-attribute">fi</span><br></code></pre></td></tr></table></figure>
<p>注意第一个方括号之后和第二个方括号之前必须加上一个空格.</p>
<p>test命令可以判断三类条件:</p>
<pre><code class="hljs">1. 数值比较
2. 字符串比较
3. 文件比较
</code></pre>
<h3 id="12-4-1-数值比较"><a href="#12-4-1-数值比较" class="headerlink" title="12.4.1 数值比较"></a>12.4.1 数值比较</h3><p>不能在test命令中使用浮点值。</p>
<h3 id="12-4-2-字符串比较"><a href="#12-4-2-字符串比较" class="headerlink" title="12.4.2 字符串比较"></a>12.4.2 字符串比较</h3><pre><code class="hljs">1. 比较时大于号和小于号必须转义。
2. 大于和小于顺序和sort命令采取的不同。比较使用的是ASCII顺序, 小写大于大写。sort命令使用的是本地英语，小写字母出现在大写字母之前.
</code></pre>
<p>使用<code>-n</code>和<code>-z</code>参数检查一个变量是否含有数据:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">if</span> [ -n <span class="hljs-variable">$var1</span> ]<br></code></pre></td></tr></table></figure>
<p>空的和未初始化的变量会对shell脚本测试造成灾难性的影响.</p>
<h3 id="12-4-3-文件比较"><a href="#12-4-3-文件比较" class="headerlink" title="12.4.3 文件比较"></a>12.4.3 文件比较</h3><p>测试Linux文件系统上文件和目录的状态.</p>
<p>还是使用参数比较.</p>
<h2 id="12-5-复合条件测试"><a href="#12-5-复合条件测试" class="headerlink" title="12.5 复合条件测试"></a>12.5 复合条件测试</h2><p>有两种布尔运算符可用:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">[ co<span class="hljs-symbol">ndition1</span> ] || [ co<span class="hljs-symbol">ndition2</span> ]<br>[ co<span class="hljs-symbol">ndition1</span> ] &amp;&amp; [ co<span class="hljs-symbol">ndition2</span> ]<br></code></pre></td></tr></table></figure>
<h2 id="12-6-if-then-的高级特性"><a href="#12-6-if-then-的高级特性" class="headerlink" title="12.6 if-then 的高级特性"></a>12.6 if-then 的高级特性</h2><p>bash shell 提供了两项可在 if-then 语句中使用的高级特性:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 用于数学表达式的双括号<br><span class="hljs-bullet">2.</span> 用于高级字符串处理功能的双方括号<br></code></pre></td></tr></table></figure>
<h3 id="12-6-1-使用双括号"><a href="#12-6-1-使用双括号" class="headerlink" title="12.6.1 使用双括号"></a>12.6.1 使用双括号</h3><p>格式:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(( expression ))<br></code></pre></td></tr></table></figure>
<p>不需要将双括号中表达式里的大于号转义。</p>
<h3 id="12-6-2-使用双方括号"><a href="#12-6-2-使用双方括号" class="headerlink" title="12.6.2 使用双方括号"></a>12.6.2 使用双方括号</h3><p>格式:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[ expression ]]</span><br></code></pre></td></tr></table></figure>
<p>这里的<code>expression</code>使用了test命令中的标准字符串比较，但它提供了模式匹配 pattern matching.</p>
<p>这里用双等号<code>==</code>其右侧为一个正则表达式.</p>
<h2 id="12-7-case-命令"><a href="#12-7-case-命令" class="headerlink" title="12.7 case 命令"></a>12.7 case 命令</h2><p>case 命令采用列表格式来检查单个变量的多个值。</p>
<p>格式：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">case <span class="hljs-keyword">variable</span> in <br>pattern1 | <span class="hljs-comment">pattern2) command1</span>;;<br>pattern3) command2;;<br><span class="hljs-comment">*) default command3;;</span><br>esac<br></code></pre></td></tr></table></figure>
<p>case 命令会将指定的变量与不同模式进行比较，如果变量和模式是匹配的，那么shell会执行该模式指定的命令.</p>
<h1 id="13-更多的结构化命令"><a href="#13-更多的结构化命令" class="headerlink" title="13 更多的结构化命令"></a>13 更多的结构化命令</h1><h2 id="13-1-for-命令"><a href="#13-1-for-命令" class="headerlink" title="13.1 for 命令"></a>13.1 for 命令</h2><p>格式:</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">for</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">in</span> list <br><span class="hljs-keyword">do</span><br>    commands<br>done<br></code></pre></td></tr></table></figure>
<h3 id="13-1-2-读取列表中的复杂值"><a href="#13-1-2-读取列表中的复杂值" class="headerlink" title="13.1.2 读取列表中的复杂值"></a>13.1.2 读取列表中的复杂值</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 使用转义字符来将单引号转义<br><span class="hljs-bullet">2.</span> 使用双引号来定义用到单引号的值<br></code></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> I don<span class="hljs-string">\&#x27;t</span> know <span class="hljs-literal">it</span> <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;this&#x27;ll&quot;</span> work<br></code></pre></td></tr></table></figure>
<p>在某个值的两边使用双引号时，shell并不会将双引号当成值的一部分.</p>
<h3 id="13-1-3-从变量读取列表"><a href="#13-1-3-从变量读取列表" class="headerlink" title="13.1.3 从变量读取列表"></a>13.1.3 从变量读取列表</h3><h3 id="13-1-4-从命令读取值"><a href="#13-1-4-从命令读取值" class="headerlink" title="13.1.4 从命令读取值"></a>13.1.4 从命令读取值</h3><h3 id="13-1-5-更改字段分隔符"><a href="#13-1-5-更改字段分隔符" class="headerlink" title="13.1.5 更改字段分隔符"></a>13.1.5 更改字段分隔符</h3><p>环境变量<code>IFS</code>, Internal Field Separator. 定义了bash shell 用作字段分隔符的一系列字符.</p>
<p>默认为:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">空格<br>制表符<br>换行符<br></code></pre></td></tr></table></figure>
<p>更改为只识别换行符:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IFS</span>=$<span class="hljs-string">&#x27;\n&#x27;</span><br></code></pre></td></tr></table></figure>
<p>在改变IFS之前保存原来的IFS值:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">IFS.<span class="hljs-attribute">OLD</span>=<span class="hljs-variable">$IFS</span><br><span class="hljs-attribute">IFS</span>=$&#x27;\n&#x27;<br><span class="hljs-built_in">..</span>.<br><span class="hljs-attribute">IFS</span>=IFS.OLD<br></code></pre></td></tr></table></figure>
<p>指定多个字符:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IFS</span>=$<span class="hljs-string">&#x27;\n&#x27;</span>:<span class="hljs-comment">;&quot;</span><br></code></pre></td></tr></table></figure>
<p>直接串起来.</p>
<h2 id="13-2-C语言风格的for命令"><a href="#13-2-C语言风格的for命令" class="headerlink" title="13.2 C语言风格的for命令"></a>13.2 C语言风格的for命令</h2><p>和C语言风格的类似，但有一些细微的不同, 基本格式:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">for <span class="hljs-comment">(( variable assignment ; condition ; iteration process )</span>)<br><span class="hljs-keyword">do</span><br>... <br><span class="hljs-keyword">do</span><span class="hljs-symbol">ne</span><br></code></pre></td></tr></table></figure>
<p>没有遵循bash shell标准的for命令:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 变量赋值可以有空格<br><span class="hljs-bullet">2.</span> 条件中变量不以美元符开头<br><span class="hljs-bullet">3.</span> 迭代过程的算式未用expr命令格式<br></code></pre></td></tr></table></figure>
<h2 id="13-3-while-命令"><a href="#13-3-while-命令" class="headerlink" title="13.3 while 命令"></a>13.3 while 命令</h2><p>格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">test</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">do</span><br>  other commmand<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<h2 id="13-3-2-定义多个测试命令"><a href="#13-3-2-定义多个测试命令" class="headerlink" title="13.3.2 定义多个测试命令"></a>13.3.2 定义多个测试命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span><br>       [ <span class="hljs-variable">$var1</span> -ge 0 ]<br></code></pre></td></tr></table></figure>
<p>只有最后一个测试命令的exit status用来决定退出.</p>
<p>每个测试命令都出现在单独的一行。</p>
<p>在每次迭代中所有的测试命令都会被执行, 包括测试命令失败的那一次迭代，其测试条件依然会全部执行.</p>
<h2 id="13-4-until-命令"><a href="#13-4-until-命令" class="headerlink" title="13.4 until 命令"></a>13.4 until 命令</h2><p>只有测试命令的exit status不为0, bash shell才会执行循环内的命令，其工作模式和while相反, 即测试条件成功时退出.</p>
<p>格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">until <span class="hljs-built_in">test</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">do</span><br>  other commands<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<h2 id="13-7-控制循环"><a href="#13-7-控制循环" class="headerlink" title="13.7 控制循环"></a>13.7 控制循环</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">break</span>, 终止某层循环<br><span class="hljs-keyword">continue</span>, 终止某次循环<br></code></pre></td></tr></table></figure>
<p>特殊用法:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">break</span> n<br></code></pre></td></tr></table></figure>
<p>n指定了要跳出的循环层级, 默认情况下n为1.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">continue</span> n<br></code></pre></td></tr></table></figure>
<h2 id="13-8-处理循环的输出"><a href="#13-8-处理循环的输出" class="headerlink" title="13.8 处理循环的输出"></a>13.8 处理循环的输出</h2><p>通过在done命令之后添加一个处理命令实现:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> /home/rich/*<br><span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> ]<br>  <span class="hljs-keyword">then</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a directory&quot;</span><br>  <span class="hljs-keyword">elif</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a file&quot;</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span> &gt; output.txt<br></code></pre></td></tr></table></figure>
<h2 id="13-9-实例"><a href="#13-9-实例" class="headerlink" title="13.9 实例"></a>13.9 实例</h2><h3 id="13-9-1-查找可执行文件"><a href="#13-9-1-查找可执行文件" class="headerlink" title="13.9.1 查找可执行文件"></a>13.9.1 查找可执行文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># finding files in the PATH</span><br><br>IFS=:<br><span class="hljs-keyword">for</span> folder <span class="hljs-keyword">in</span> <span class="hljs-variable">$PATH</span><br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$folder</span>:&quot;</span><br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-variable">$folder</span>/*<br>    <span class="hljs-keyword">do</span> <br>        <span class="hljs-keyword">if</span> [ -x <span class="hljs-variable">$file</span> ]<br>        <span class="hljs-keyword">then</span> <br>           <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;   <span class="hljs-variable">$file</span>&quot;</span><br>        <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<h3 id="13-9-2-创建多个用户账户"><a href="#13-9-2-创建多个用户账户" class="headerlink" title="13.9.2 创建多个用户账户"></a>13.9.2 创建多个用户账户</h3><p>把数据从文件中送入while命令, 在while命令尾部使用一个重定向符就可以了:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># process new user accounts</span><br><br>input=<span class="hljs-string">&quot;users.csv&quot;</span><br><span class="hljs-keyword">while</span> IFS=<span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-built_in">read</span> -r userid name<br><span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;adding <span class="hljs-variable">$userid</span>&quot;</span><br>  useradd -c <span class="hljs-string">&quot;<span class="hljs-variable">$name</span>&quot;</span> -m <span class="hljs-variable">$userid</span><br><span class="hljs-keyword">done</span> &lt; <span class="hljs-string">&quot;<span class="hljs-variable">$input</span>&quot;</span><br></code></pre></td></tr></table></figure>
<h1 id="第十四章-处理用户输入"><a href="#第十四章-处理用户输入" class="headerlink" title="第十四章 处理用户输入"></a>第十四章 处理用户输入</h1><h2 id="14-1-命令行参数"><a href="#14-1-命令行参数" class="headerlink" title="14.1 命令行参数"></a>14.1 命令行参数</h2><h3 id="14-1-1-读取参数"><a href="#14-1-1-读取参数" class="headerlink" title="14.1.1 读取参数"></a>14.1.1 读取参数</h3><p>positional parameter, 位置参数，一个特殊变量，由bash shell分配给输入到命令行的所有参数. 也就是 $0, $1 这些.</p>
<p>$0是程序名，$1是第一个参数，直到$9.</p>
<p>将文本字符串作为参数传递时，引号并非数据得一部分, 它们只是表明数据的起始位置.</p>
<p>在第九个变量之后，必须在变量数字周围加上花括号, 如${10}.</p>
<h3 id="14-1-2-读取脚本名"><a href="#14-1-2-读取脚本名" class="headerlink" title="14.1.2 读取脚本名"></a>14.1.2 读取脚本名</h3><p>当传给$0变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量$0就会使用整个路径.</p>
<p><code>basename</code>命令会返回不包含路径的脚本名.</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">name</span>=$(basename <span class="hljs-variable">$0</span>)<br></code></pre></td></tr></table></figure>
<h3 id="14-1-3-测试参数"><a href="#14-1-3-测试参数" class="headerlink" title="14.1.3 测试参数"></a>14.1.3 测试参数</h3><p>在使用参数前一定要检查其中是否存在数据。</p>
<h2 id="14-2-特殊参数变量"><a href="#14-2-特殊参数变量" class="headerlink" title="14.2 特殊参数变量"></a>14.2 特殊参数变量</h2><h3 id="14-2-1-参数统计"><a href="#14-2-1-参数统计" class="headerlink" title="14.2.1 参数统计"></a>14.2.1 参数统计</h3><p>特殊变量<code>$#</code>记录命令行参数的个数.</p>
<p>通过使用前测试参数的总数:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">if</span> [ <span class="hljs-symbol">$</span># -<span class="hljs-keyword">ne</span> <span class="hljs-number">2</span> ]<br></code></pre></td></tr></table></figure>
<p>同时，<code>$&#123;!#&#125;</code>表示最后一个命令行参数. 在花括号内不能使用美元符号，需将其替换为<code>!</code>.</p>
<h3 id="14-2-2-抓取所有的数据"><a href="#14-2-2-抓取所有的数据" class="headerlink" title="14.2.2 抓取所有的数据"></a>14.2.2 抓取所有的数据</h3><p><code>$*</code>变量会将命令行上提供的所有参数当作一个单词保存.</p>
<p><code>$@</code>变量会将命令行上提供的所有参数当作统一字符串中的多个独立的单词.</p>
<p>注意使用时添加双引号.</p>
<h2 id="14-3-移动变量"><a href="#14-3-移动变量" class="headerlink" title="14.3 移动变量"></a>14.3 移动变量</h2><p><code>shift</code>命令，将每个参数变量向左移动一个位置，$0不会改变.</p>
<p>给<code>shift</code>命令提供参数，可以一次移动多个位置.</p>
<h2 id="14-4-处理选项"><a href="#14-4-处理选项" class="headerlink" title="14.4 处理选项"></a>14.4 处理选项</h2><p>选项是跟在单破折号后面的单个字母，他能改变命令的行为。</p>
<h3 id="14-4-1-查找选项"><a href="#14-4-1-查找选项" class="headerlink" title="14.4.1 查找选项"></a>14.4.1 查找选项</h3><p>用<code>case</code>语句来判断某个参数是否为选项.</p>
<h4 id="分离选项和参数"><a href="#分离选项和参数" class="headerlink" title="分离选项和参数"></a>分离选项和参数</h4><p>shell会用双破折号(–)来表明选项列表结束，其后的参数会被当作参数处理而不是选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">  <br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># extracting command line options as parameters</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">echo</span> <br><span class="hljs-keyword">while</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span> <br>        -a) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -a option&quot;</span> ;; <br>        -b) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -b option&quot;</span> ;;<br>        -c) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -c option&quot;</span> ;;<br>        --) <span class="hljs-built_in">shift</span><br>            <span class="hljs-built_in">break</span> ;;<br>         *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> is not an option&quot;</span> ;;<br>     <span class="hljs-keyword">esac</span><br>     <span class="hljs-built_in">shift</span><br> <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>利用<code>shift</code>每调用一个选项就移除一个。</p>
<p>在Linux中，合并选项是一个很常见的做法。</p>
<h3 id="14-4-2-使用getopt命令"><a href="#14-4-2-使用getopt命令" class="headerlink" title="14.4.2 使用getopt命令"></a>14.4.2 使用getopt命令</h3><p>这个命令的作用在于 <mark>格式化命令行参数</mark>.<br>getopt命令可以识别命令行参数.</p>
<p>getopt命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式:</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">getopt optstring parameters</span><br></code></pre></td></tr></table></figure>
<p>在每个需要参数值的选项字母后面加一个冒号:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">getopt ab:<span class="hljs-built_in">cd</span> -a -b test1 -<span class="hljs-built_in">cd</span> test2 testt3</span><br></code></pre></td></tr></table></figure>
<p>这时, 命令行参数就被格式化为:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">a</span> -<span class="hljs-selector-tag">b</span> test1 -c -d -- test2 test3<br></code></pre></td></tr></table></figure>
<p><code>c</code> 和 <code>d</code> 是两个命令行选项, 所以把 <code>-cd</code> 变成了 <code>-c -d</code>.</p>
<p>因为 <code>-d</code> 没有参数, 所以后面会有 <code>--</code> 来分隔.</p>
<p>在这里的意思就是, <code>b</code> 这个选项需要参数.</p>
<h4 id="2-在脚本中使用-getopt"><a href="#2-在脚本中使用-getopt" class="headerlink" title="2. 在脚本中使用 getopt"></a>2. 在脚本中使用 getopt</h4><p><code>set</code> 命令能够处理 shell 中的各种变量</p>
<h3 id="14-4-3-使用更高级的-getopts"><a href="#14-4-3-使用更高级的-getopts" class="headerlink" title="14.4.3 使用更高级的 getopts"></a>14.4.3 使用更高级的 getopts</h3><p>getopts 内建于 bash shell, 比 getopt 多了一些扩展功能.</p>
<p>每次调用 getopts, 它一次只处理命令行上检测到的一个参数. 处理完所有参数后, 它会退出并返回一个大于 0 的推出状态码.</p>
<p>格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">getopts</span> optstring variabel<br></code></pre></td></tr></table></figure>
<p>要去掉错误信息的话, 可以在 optstring 之前加一个冒号. </p>
<p>getopts 命令会将当前参数保存在命令行中定义的 variable 中.</p>
<p>getopts 命令会用到两个环境变量:</p>
<ul>
<li>OPTARG : 会保存选项后跟的参数值</li>
<li>OPTIND : 保存参数列表中 getopts 正在处理的参数的位置, 毕竟这个函数一次只处理一个选项. 第一个选项的位置为 1</li>
</ul>
<p>getopts 命令解析命令行选项时会移除开头的单破折号, 因此在 case 中定义时不用单破折号.</p>
<p>getopts 命令可以在参数值之间加空格, 如 <code>&quot;test1 test2&quot;</code>, 也可以把选项字母和参数值放在一起使用, 而不加空格 <code>./test.sh -abtest1</code>.</p>
<p>getopts 还能将命令行上找到的所有未定义的选项统一输出成问号.</p>
<p>在 getopts 每处理一个选项, 其会把 OPTIND 环境变量值加一.</p>
<h2 id="14-5-将选项标准化"><a href="#14-5-将选项标准化" class="headerlink" title="14.5 将选项标准化"></a>14.5 将选项标准化</h2><p>Linux 命令行中的选项好多已经有了不成文的含义.</p>
<h2 id="14-6-获取用户输入"><a href="#14-6-获取用户输入" class="headerlink" title="14.6 获取用户输入"></a>14.6 获取用户输入</h2><h3 id="14-6-1-基本的读取"><a href="#14-6-1-基本的读取" class="headerlink" title="14.6.1 基本的读取"></a>14.6.1 基本的读取</h3><p>read 命令从标准输入或另一个文件描述符号中接受输入, 在收到输入后, read 命令会将数据放进一个变量.</p>
<p>例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Enter your name:&quot;</span><br><span class="hljs-built_in">read</span> name<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello <span class="hljs-variable">$name</span>, welcome to my program&quot;</span><br></code></pre></td></tr></table></figure>
<p>这里 <code>echo</code> 的 <code>-n</code> 选项表示不会在字符串末尾输出换行符.</p>
<p>这里, read 把读取的值存入 <code>name</code> 这个变量.</p>
<p>read 的 <code>-p</code> 选项, 允许在命令行直接指定提示符:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Please enter your age: &quot;</span> age<br></code></pre></td></tr></table></figure>
<p>这里 <code>Please enter your age: </code> 就和之前使用 <code>echo</code> 是一样的.</p>
<p>可以指定多个变量.</p>
<p>如果不指定变量, 值会被存在 <code>REPLY</code> 这个环境变量中.</p>
<h3 id="14-6-2-超时"><a href="#14-6-2-超时" class="headerlink" title="14.6.2 超时"></a>14.6.2 超时</h3><p>使用 <code>-t</code> 选项, 指定 read 命令等待输入的秒数, 当计时器过期后, read 命令会返回一个非零退出状态码.</p>
<p>使用 <code>-n</code> 选项, 可以让 read 命令在读取指定字符数后退出. 如 <code>read -n1</code> 表示接受单个字符</p>
<h3 id="14-6-3-隐藏方式读取"><a href="#14-6-3-隐藏方式读取" class="headerlink" title="14.6.3 隐藏方式读取"></a>14.6.3 隐藏方式读取</h3><p><code>-s</code> 选项, 避免在 read 命令中输入的数据出现在显示器上, 实际上, 数据会被显示, 只是 read 命令会将文本颜色设成跟背景色一样.</p>
<h3 id="14-6-4-从文件中读取"><a href="#14-6-4-从文件中读取" class="headerlink" title="14.6.4 从文件中读取"></a>14.6.4 从文件中读取</h3><p>每次调用 read 命令, 他都会从文件中读取一行文本, 当文件中再没有内容时, read 命令退出并返回非零状态码.</p>
<p>最常见的方法是对文件使用 cat 命令, 将结果通过管道直接传给含有 read 命令的 while 命令.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash    </span><br>count=1<br><span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span> | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line <br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Line <span class="hljs-variable">$count</span>: <span class="hljs-variable">$line</span>&quot;</span><br>    count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Finished processing the file&quot;</span><br></code></pre></td></tr></table></figure>
<h1 id="第15章-呈现数据"><a href="#第15章-呈现数据" class="headerlink" title="第15章 呈现数据"></a>第15章 呈现数据</h1><h2 id="15-1-理解输入和输出"><a href="#15-1-理解输入和输出" class="headerlink" title="15.1 理解输入和输出"></a>15.1 理解输入和输出</h2><h3 id="15-1-1-标准文件描述符"><a href="#15-1-1-标准文件描述符" class="headerlink" title="15.1.1 标准文件描述符"></a>15.1.1 标准文件描述符</h3><p>Linux 系统将每个对象当作文件处理.</p>
<p>Linux 用文件描述符 (file descriptor) 来标识每个文件对象.</p>
<p>每个进程一次最多可以有九个文件描述符, bash shell 保留了前三个文件描述符.</p>
<ul>
<li>0 SIDIN  标准输入</li>
<li>1 STDOUT 标准输出</li>
<li>2 STDERR 标准错误</li>
</ul>
<p>当命令生成错误消息时, shell 并未将错误消息重定向到输出重定向文件.</p>
<p>默认情况下, STDERR 文件描述符和 STDOUT 文件描述符指向同样的地方.</p>
<h3 id="15-1-2-重定向错误"><a href="#15-1-2-重定向错误" class="headerlink" title="15.1.2 重定向错误"></a>15.1.2 重定向错误</h3><h4 id="1-只重定向错误"><a href="#1-只重定向错误" class="headerlink" title="1. 只重定向错误"></a>1. 只重定向错误</h4><p>可以选择只重定向错误消息, 将该文件描述符放在重定向符号前, 该值必须紧紧地放在重定向符号前.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al badfile 2&gt; <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure>
<h4 id="2-重定向错误和数据"><a href="#2-重定向错误和数据" class="headerlink" title="2. 重定向错误和数据"></a>2. 重定向错误和数据</h4><p>需要用两个重定向符号, 且在符号前面放上待重定向数据对应的文件描述符:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al <span class="hljs-built_in">test</span> test2 test3 badfile 2&gt; test6 1&gt; test7</span><br></code></pre></td></tr></table></figure>
<p>可以利用 <code>&amp;&gt;</code> 这个特殊的重定向符号, 把 STDOUT 和 STDERR 重定向到同一个文件.</p>
<p>为了避免错误信息散落在输出文件中, 相较于标准输出, bash shell 自动赋予了错误消息更高的优先级.</p>
<h2 id="15-2-在脚本中重定向输出"><a href="#15-2-在脚本中重定向输出" class="headerlink" title="15.2 在脚本中重定向输出"></a>15.2 在脚本中重定向输出</h2><p>有两种方法在脚本中重定向输出:</p>
<ul>
<li>临时重定向行输出</li>
<li>永久重定向脚本中的所有输出</li>
</ul>
<h3 id="15-2-1-临时重定向"><a href="#15-2-1-临时重定向" class="headerlink" title="15.2.1 临时重定向"></a>15.2.1 临时重定向</h3><p>在重定向到文件描述符时, 必须在文件描述符数字之前加一个 <code>&amp;</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is an error&quot;</span> &gt;&amp;2<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is an normal output&quot;</span><br></code></pre></td></tr></table></figure>
<p>默认情况下, Linxu 会将 STDERR 导向 STDOUT, 如果在运行脚本时重定向了 STDERR, 脚本中所有导向 STDERR 的文本都会被重定向.</p>
<h3 id="15-2-2-永久重定向"><a href="#15-2-2-永久重定向" class="headerlink" title="15.2.2 永久重定向"></a>15.2.2 永久重定向</h3><p>可以用 exec 命令告诉 shell 在执行脚本期间重定向某个特定的文件描述符:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">1</span>&gt;testout<br></code></pre></td></tr></table></figure>
<p>exec 命令会启动一个新 shell 并将 STDOUT 文件描述符重定向到文件. 这里实际上把 1 这个文件描述重新分配给了 testout 这个文件.</p>
<p>exec 在 man page 中的描述为: execute commands and open, close, or copy file descriptors.</p>
<h2 id="15-3-在脚本中重定向输入"><a href="#15-3-在脚本中重定向输入" class="headerlink" title="15.3 在脚本中重定向输入"></a>15.3 在脚本中重定向输入</h2><p>exec 命令允许你将 STDIN 重定向到 Linux 系统上的文件中:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">0</span>&lt; testfile<br></code></pre></td></tr></table></figure>
<p>如 :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">exec</span> 0&lt; testfile<br>count=0<br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line<br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Line #<span class="hljs-variable">$count</span>: line&quot;</span><br>    count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<h2 id="15-4-创建自己的重定向"><a href="#15-4-创建自己的重定向" class="headerlink" title="15.4 创建自己的重定向"></a>15.4 创建自己的重定向</h2><h3 id="15-4-1-创建输出文件描述符"><a href="#15-4-1-创建输出文件描述符" class="headerlink" title="15.4.1 创建输出文件描述符"></a>15.4.1 创建输出文件描述符</h3><p>可以用 exec 命令来给输出分配文件描述符.</p>
<p>一旦将另一个文件描述符分配给一个文件, 这个重定向就会一直有效, 直到你重新分配.</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">3</span>&gt;testout<br></code></pre></td></tr></table></figure>
<h3 id="15-4-2-重定向文件描述符"><a href="#15-4-2-重定向文件描述符" class="headerlink" title="15.4.2 重定向文件描述符"></a>15.4.2 重定向文件描述符</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">3</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>把文件描述符 3 指向文件描述符 1.</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">1</span>&gt;&amp;<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p>恢复.</p>
<h3 id="15-4-3-创建输入文件描述符"><a href="#15-4-3-创建输入文件描述符" class="headerlink" title="15.4.3 创建输入文件描述符"></a>15.4.3 创建输入文件描述符</h3><p>在重定向到文件之前, 先将 STDIN 文件描述符保存到另外一个文件描述符, 然后在读取完文件之后再将 STDIN 恢复到它原来的位置:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-built_in">exec</span> 6&lt;&amp;0<br><br><span class="hljs-built_in">exec</span> 0&lt; testfile<br><br>count=1<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line <br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Line #<span class="hljs-variable">$count</span>: <span class="hljs-variable">$line</span>&quot;</span><br>    count=[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">exec</span> 0&lt;&amp;6<br></code></pre></td></tr></table></figure>
<h3 id="15-4-4-创建读写文件描述符"><a href="#15-4-4-创建读写文件描述符" class="headerlink" title="15.4.4 创建读写文件描述符"></a>15.4.4 创建读写文件描述符</h3><p>可以打开单个文件描述符来作为输入和输出.</p>
<p>任何读或写都会从文件指针上次的位置开始, 比如你先用这个文件描述符输出了一行, 这时这个指针就指向这一行的末尾了, 如果你这个时候输入一段文本, 这个文本就会插入到这个指针所指的位置, 而不是文件的末尾.</p>
<h3 id="15-4-5-关闭文件描述符"><a href="#15-4-5-关闭文件描述符" class="headerlink" title="15.4.5 关闭文件描述符"></a>15.4.5 关闭文件描述符</h3><p>如果你创建了新的输入或输出文件描述符, shell 会在脚本退出时自动关闭它们.</p>
<p>在脚本结束前手动关闭文件描述符, 需要将它重定向到特殊符号 <code>&amp;-</code>:</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">exec <span class="hljs-number">3</span>&gt;<span class="hljs-meta">&amp;-</span><br></code></pre></td></tr></table></figure>
<p>在关闭文件描述符后, 如果你随后在脚本中打开了同一个文件, shell 会用一个新文件来替换已有的文件, 意思就是其内容会被覆盖.</p>
<h2 id="15-5-列出打开的文件描述符"><a href="#15-5-列出打开的文件描述符" class="headerlink" title="15.5 列出打开的文件描述符"></a>15.5 列出打开的文件描述符</h2><p>使用 <code>isof</code> 命令列出 Linux 系统打开的所有文件描述符.</p>
<h2 id="15-6-阻止命令输出"><a href="#15-6-阻止命令输出" class="headerlink" title="15.6 阻止命令输出"></a>15.6 阻止命令输出</h2><p>可以将 STDERR 的输出从定向到叫 null 文件的特殊文件.</p>
<p>shell 输出到 null 文件的任何数据都不会保存, 全部都会被丢弃.</p>
<p>在 Linux 系统上 null 文件的标准位置是 &#x2F;dev&#x2F;null.</p>
<p>也可以用 &#x2F;dev&#x2F;null 作为输入文件, 其能够快速清除现有文件中的数据.</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ cat <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span> &gt; testfile<br></code></pre></td></tr></table></figure>
<h2 id="15-7-创建临时文件"><a href="#15-7-创建临时文件" class="headerlink" title="15.7 创建临时文件"></a>15.7 创建临时文件</h2><p>Linux 使用 &#x2F;tmp 目录来存放不需要用就保存的文件, 大多数 Linux 发行版配置了系统在启动时自动删除 &#x2F;tmp 目录的所有文件.</p>
<p><code>mktemp</code> 命令可以在 <code>/tmp</code> 目录中创建一个唯一的临时文件, shell 会创建这个文件, 但不用默认的 umask 值. 它会将文件的读和写权限分配给文件的属主, 并将你设成文件的属主.</p>
<h3 id="15-7-1-创建本地临时文件"><a href="#15-7-1-创建本地临时文件" class="headerlink" title="15.7.1 创建本地临时文件"></a>15.7.1 创建本地临时文件</h3><p>要用 mktemp 命令在本地目录中创建一个唯一文件, 需要指定一个文件名模板, 模板可以包含任意文本文件名, 在文件名末尾加上 6 个 X 就行了, mktemp 命令会用 6 个字符码替换这 6 个 X, 从而保证文件名在目录中唯一.</p>
<p>将文件名保存在变量中:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">tempfile=<span class="hljs-constructor">$(<span class="hljs-params">mktemp</span> <span class="hljs-params">test</span>.XXXXXX)</span><br></code></pre></td></tr></table></figure>
<h3 id="15-7-2-在-x2F-tmp-目录创建临时文件"><a href="#15-7-2-在-x2F-tmp-目录创建临时文件" class="headerlink" title="15.7.2 在 &#x2F;tmp 目录创建临时文件"></a>15.7.2 在 &#x2F;tmp 目录创建临时文件</h3><p>使用 <code>-t</code> 选项, 其会强制 mktemp 命令来到系统的临时目录来创建该文件, 在使用这个特性时, mktemp 命令会返回用来创建临时文件时的全路径.</p>
<h3 id="15-7-3-创建临时目录"><a href="#15-7-3-创建临时目录" class="headerlink" title="15.7.3 创建临时目录"></a>15.7.3 创建临时目录</h3><p><code>-d</code> 选项告诉 mktemp 创建一个临时目录.</p>
<h2 id="15-8-记录消息"><a href="#15-8-记录消息" class="headerlink" title="15.8 记录消息"></a>15.8 记录消息</h2><p>使用特殊的 tee 命令, 可以将输出同时发送到显示器和日志文件.</p>
<p>它会将从 STDIN 过来的数据同时发送到两处, 一处是 STDOUT, 一处是 tee 命令行所指定的文件:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">tee</span> filename<br></code></pre></td></tr></table></figure>
<p>可以配合管道符 <code>|</code>.</p>
<p>如果想将数据追加到文件, 必须使用 <code>-a</code> 选项.</p>
<h1 id="第16章-控制脚本"><a href="#第16章-控制脚本" class="headerlink" title="第16章 控制脚本"></a>第16章 控制脚本</h1><h2 id="16-1-处理信号"><a href="#16-1-处理信号" class="headerlink" title="16.1 处理信号"></a>16.1 处理信号</h2><h3 id="16-1-1-重温-Linux-信号"><a href="#16-1-1-重温-Linux-信号" class="headerlink" title="16.1.1 重温 Linux 信号"></a>16.1.1 重温 Linux 信号</h3><p>默认情况下, bash shell 会忽略收到的任何 SIGQUIT (3) 和 SIGTERM (15) 信号.</p>
<h3 id="16-1-2-生成信号"><a href="#16-1-2-生成信号" class="headerlink" title="16.1.2 生成信号"></a>16.1.2 生成信号</h3><h3 id="16-1-3-捕获信号"><a href="#16-1-3-捕获信号" class="headerlink" title="16.1.3 捕获信号"></a>16.1.3 捕获信号</h3><p>trap 命令允许你来指定 shell 及脚本要监看并从 shell 中拦截的 Linux 信号.</p>
<p>格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">trap</span> commands signals<br></code></pre></td></tr></table></figure>
<p>使用 trap 命令来忽略信号如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;echo &#x27;Sorry! I have trapped Ctrl+C&#x27;&quot;</span> SIGINT<br></code></pre></td></tr></table></figure>
<p>trap 命令会在每次检测到 SIGINIT 信号时显示一行文本, 并捕获这个信号, 其会阻止用户用 bash shell 的组合键 Ctrl+C 来停止程序. </p>
<h3 id="16-1-4-捕获脚本退出"><a href="#16-1-4-捕获脚本退出" class="headerlink" title="16.1.4 捕获脚本退出"></a>16.1.4 捕获脚本退出</h3><p>要捕获脚本的退出 (也就是脚本退出这个行为), 在 trap 命令后加上 EXIT 信号:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-built_in">trap</span>  <span class="hljs-string">&quot;echo Goodbye...&quot;</span> EXIT<br></code></pre></td></tr></table></figure>
<p>在脚本退出时, 会打印 <code>Goodbye...</code></p>
<h3 id="16-1-5-修改或移除捕获"><a href="#16-1-5-修改或移除捕获" class="headerlink" title="16.1.5 修改或移除捕获"></a>16.1.5 修改或移除捕获</h3><p>在脚本的不同地方进行捕获, 就还是用 trap 命令, 只是后面的选项是新的, 这时脚本要捕获的信号就被修改了.</p>
<p>可以删除已设置好的捕获, 在 trap 命令与希望恢复默认行为的信号列表之间加上两个破折号 (单个也行).</p>
<p>如要恢复, 即不再对 SIGINT 进行捕获:</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">trap <span class="hljs-comment">-- SIGINT</span><br></code></pre></td></tr></table></figure>
<h2 id="16-2-以后台模式运行脚本"><a href="#16-2-以后台模式运行脚本" class="headerlink" title="16.2 以后台模式运行脚本"></a>16.2 以后台模式运行脚本</h2><h3 id="16-2-1-后台运行脚本"><a href="#16-2-1-后台运行脚本" class="headerlink" title="16.2.1 后台运行脚本"></a>16.2.1 后台运行脚本</h3><p>在命令之后加上 <code>&amp;</code> 符号.</p>
<p>当后台进程运行时, 它仍然会使用终端显示器来显示 STDOUT 和 STDERR 消息.</p>
<p>最好是将后台运行的脚本的 STDOUT 和 STDERR 重定向.</p>
<h2 id="16-3-在非控制台下运行脚本"><a href="#16-3-在非控制台下运行脚本" class="headerlink" title="16.3 在非控制台下运行脚本"></a>16.3 在非控制台下运行脚本</h2><p>nohup 命令运行了另外一个命令来阻断所有发送给该进程的 SIGHUP 信号, 这会在退出终端会话时阻止进程退出.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> ./test.sh &amp;</span><br></code></pre></td></tr></table></figure>
<p>由于 nohup 命令会解除终端与进程的关联, 进程也就不再同 STDOUT 和 STDERR 联系在一起, 为了保存该命令产生的输出, nohup 命令会自动将 STDOUT 和 STDERR 的消息重定向到一个名为 nohuo.out 文件中.</p>
<h2 id="16-4-作业控制"><a href="#16-4-作业控制" class="headerlink" title="16.4 作业控制"></a>16.4 作业控制</h2><p>脚本用 $$ 变量来显示 Linux 系统分配给该脚本的 PID.</p>
<h2 id="16-6-定时控制脚本"><a href="#16-6-定时控制脚本" class="headerlink" title="16.6 定时控制脚本"></a>16.6 定时控制脚本</h2><p>在登录时运行的脚本应该放入 <code>$HOME/.bash_profile</code>.</p>
<p>每次启动一个新的 shell, bash shell 都会运行 <code>.bashrc</code> 文件.</p>
<p><code>.bashrc</code> 文件通常要执行两次, 一次是当你登入 bash shell, 另一次是当你启动一个 bash shell.</p>
<h1 id="第17章-创建函数"><a href="#第17章-创建函数" class="headerlink" title="第17章 创建函数"></a>第17章 创建函数</h1><h2 id="17-1-基本的脚本函数"><a href="#17-1-基本的脚本函数" class="headerlink" title="17.1 基本的脚本函数"></a>17.1 基本的脚本函数</h2><p><mark>函数</mark>是一个脚本代码块, 你可以为其命名并在代码中任何位置重用.</p>
<h3 id="17-1-1-创建函数"><a href="#17-1-1-创建函数" class="headerlink" title="17.1.1 创建函数"></a>17.1.1 创建函数</h3><p>有两种格式可以在 bash shell 脚本中创建函数:</p>
<p>第一种格式采用关键字 function:</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span> &#123;<br>    commands<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二种格式:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">name</span><span class="hljs-params">()</span></span> &#123;<br>    commands<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数名后的空括号表明正在定义一个函数.</p>
<h3 id="17-1-2-使用函数"><a href="#17-1-2-使用函数" class="headerlink" title="17.1.2 使用函数"></a>17.1.2 使用函数</h3><p>指定函数名.</p>
<p>如果在函数被定以前使用函数, 会收到一条错误信息.</p>
<p>如果重定义了函数, 新定义会覆盖原来函数的定义, 且不会产生任何错误信息.</p>
<h2 id="17-2-返回值"><a href="#17-2-返回值" class="headerlink" title="17.2 返回值"></a>17.2 返回值</h2><p>bash shell 会把函数当作一个小型脚本, 运行结束时会返回一个退出状态码.</p>
<h3 id="17-2-1-默认退出状态码"><a href="#17-2-1-默认退出状态码" class="headerlink" title="17.2.1 默认退出状态码"></a>17.2.1 默认退出状态码</h3><p>默认情况下, 函数的退出状态码是函数中最后一条命令返回的推出状态码.</p>
<p>使用函数的默认退出状态码是很危险的.</p>
<h3 id="17-2-2-使用-return-命令"><a href="#17-2-2-使用-return-命令" class="headerlink" title="17.2.2 使用 return 命令"></a>17.2.2 使用 return 命令</h3><p>bash shell 用 return 命令来退出函数并返回特定的退出状态码.</p>
<p>两个注意事项:</p>
<ul>
<li>函数一结束就取返回值</li>
<li>退出状态码必须是 0 ~ 255</li>
</ul>
<p>如果在使用 <code>$?</code> 变量提取函数返回值之前执行了其他命令, 函数的返回值就会丢失.</p>
<p>如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-keyword">function</span> db1 &#123;<br>    <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter a value: &quot;</span> value<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;doubling the value&quot;</span><br>    <span class="hljs-built_in">return</span> $[ <span class="hljs-variable">$value</span> * 2 ]<br>&#125;<br><br>db1<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The new value is $?&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="17-2-3-使用函数输出"><a href="#17-2-3-使用函数输出" class="headerlink" title="17.2.3 使用函数输出"></a>17.2.3 使用函数输出</h3><p>获得函数的输出, 并保存在变量中:</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">result</span>=<span class="hljs-string">`db1`</span><br></code></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span>=$(db1)<br></code></pre></td></tr></table></figure>
<p>获取输出, 和返回值不同.</p>
<h2 id="17-3-在函数中使用变量"><a href="#17-3-在函数中使用变量" class="headerlink" title="17.3 在函数中使用变量"></a>17.3 在函数中使用变量</h2><h3 id="17-3-1-向函数传递参数"><a href="#17-3-1-向函数传递参数" class="headerlink" title="17.3.1 向函数传递参数"></a>17.3.1 向函数传递参数</h3><p>同样还是用 <code>$#</code>, <code>$1</code> 这些特殊变量.</p>
<p>在脚本中指定函数时, 必须将参数和函数放在同一行:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">func1</span> <span class="hljs-variable">$value1</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>
<p>由于函数使用特殊参数环境变量作为自己的参数值, 因此它无法直接获取脚本在命令行中的参数值.</p>
<h3 id="17-3-2-在函数中处理变量"><a href="#17-3-2-在函数中处理变量" class="headerlink" title="17.3.2 在函数中处理变量"></a>17.3.2 在函数中处理变量</h3><p>函数中定义的变量与普通变量的作用域不同.</p>
<p>函数使用两种类型的变量:</p>
<ul>
<li>全局变量</li>
<li>局部变量</li>
</ul>
<h4 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1. 全局变量"></a>1. 全局变量</h4><p>全局变量是在 shell 脚本中任何地方都有效的变量.</p>
<p>默认情况下, 在脚本中定义的任何变量都是全局变量, 在函数外定义的变量可在函数内正常访问.</p>
<h4 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h4><p>无需在函数中使用全局变量, 函数内部使用的任何变量都可以被声明成局部变量, 使用 local 关键词:</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">local</span> <span class="hljs-keyword">temp</span><br></code></pre></td></tr></table></figure>
<p>也可在变量赋值语句中使用 local 关键字:</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">local</span> temp=$[ $value + <span class="hljs-number">5</span> ]<br></code></pre></td></tr></table></figure>
<p>local 关键词保证了变量只局限在该函数中.</p>
<h2 id="17-4-数组变量和函数"><a href="#17-4-数组变量和函数" class="headerlink" title="17.4 数组变量和函数"></a>17.4 数组变量和函数</h2><h3 id="17-4-1-向函数传递数组参数"><a href="#17-4-1-向函数传递数组参数" class="headerlink" title="17.4.1 向函数传递数组参数"></a>17.4.1 向函数传递数组参数</h3><h3 id="17-4-2-从函数返回数组"><a href="#17-4-2-从函数返回数组" class="headerlink" title="17.4.2 从函数返回数组"></a>17.4.2 从函数返回数组</h3><h2 id="17-5-函数递归"><a href="#17-5-函数递归" class="headerlink" title="17.5 函数递归"></a>17.5 函数递归</h2><p>函数可以调用自己来得到结果.</p>
<h2 id="17-6-创建库"><a href="#17-6-创建库" class="headerlink" title="17.6 创建库"></a>17.6 创建库</h2><p>bash shell 允许创建函数库文件, 然后在多个脚本中引用该库文件.</p>
<p>第一步是创建一个包含脚本中所需函数的共用库文件.</p>
<p>如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># my script function</span><br><br><span class="hljs-keyword">function</span> addem &#123;<br>    <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> + <span class="hljs-variable">$2</span> ]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第二步是在用这个函数的脚本中包含该库文件.</p>
<p>使用 source 命令, source 命令有个快捷的别名, 称做<mark>点操作符</mark> (dot operator):</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">. </span>./myfuncs<br></code></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ./myfuncs<br></code></pre></td></tr></table></figure>
<h2 id="17-7-在命令行上使用函数"><a href="#17-7-在命令行上使用函数" class="headerlink" title="17.7 在命令行上使用函数"></a>17.7 在命令行上使用函数</h2><p>一旦在 shell 中定义了函数, 就可以在整个系统中使用, 无需担心脚本是不是在 PATH 环境变量里.</p>
<h3 id="17-7-1-在命令行上创建函数"><a href="#17-7-1-在命令行上创建函数" class="headerlink" title="17.7.1 在命令行上创建函数"></a>17.7.1 在命令行上创建函数</h3><p>单行方式定义函数:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">function</span> divem &#123; <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> / <span class="hljs-variable">$2</span> ]; &#125;</span><br></code></pre></td></tr></table></figure>
<p>在命令行上定义函数时, 必须在每条命令之后加分号, 这样 shell 才知道在哪里是命令的起止.</p>
<p>多行方式定义:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">function</span> multem &#123;</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> * <span class="hljs-variable">$2</span> ]</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">&#125;</span><br></code></pre></td></tr></table></figure>
<p>在函数的尾部使用花括号, shell 就会知道你已经完成了函数的定义.</p>
<p>如果你起了一个和内建函数或另一个函数相同的名字, 函数将会覆盖原来的命令.</p>
<h3 id="17-7-2-在-bashrc-文件中定义函数"><a href="#17-7-2-在-bashrc-文件中定义函数" class="headerlink" title="17.7.2 在 .bashrc 文件中定义函数"></a>17.7.2 在 .bashrc 文件中定义函数</h3><p>在命令行上直接定义 shell 函数的明显缺点是退出 shell 时, 函数就消失了.</p>
<p>只要是在 shell 脚本中, 都可以用 source 命令来添加库文件.</p>
<h2 id="17-8-实例"><a href="#17-8-实例" class="headerlink" title="17.8 实例"></a>17.8 实例</h2><h3 id="17-8-1-下载及安装"><a href="#17-8-1-下载及安装" class="headerlink" title="17.8.1 下载及安装"></a>17.8.1 下载及安装</h3><h1 id="第18章-图形化桌面中的脚本编程"><a href="#第18章-图形化桌面中的脚本编程" class="headerlink" title="第18章 图形化桌面中的脚本编程"></a>第18章 图形化桌面中的脚本编程</h1><h2 id="18-1-创建文本菜单"><a href="#18-1-创建文本菜单" class="headerlink" title="18.1 创建文本菜单"></a>18.1 创建文本菜单</h2><p>创建交互式 shell 脚本最常用的方法是使用菜单.</p>
<p>通常菜单脚本会清空显示区域, 然后显示可用的选项列表.</p>
<p>shell 脚本菜单的核心是 case 命令.</p>
<h3 id="18-1-1-创建菜单布局"><a href="#18-1-1-创建菜单布局" class="headerlink" title="18.1.1 创建菜单布局"></a>18.1.1 创建菜单布局</h3><p>在创建菜单之前, 通常要先清空显示器上已有的内容, 这样就能在干净的环境中显示菜单.</p>
<p>在 echo 中使用非打印字符, 必须用 <code>-e</code> 选项:</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">clear</span><br><span class="hljs-keyword">echo</span> -e <span class="hljs-string">&quot;1.\tDisplay disk space&quot;</span><br></code></pre></td></tr></table></figure>
<p>创建菜单的最后一步是获取用户输入, 使用 read 命令.</p>
<h1 id="第19章-初识-sed-和-gawk"><a href="#第19章-初识-sed-和-gawk" class="headerlink" title="第19章 初识 sed 和 gawk"></a>第19章 初识 sed 和 gawk</h1><h2 id="19-1-文本处理"><a href="#19-1-文本处理" class="headerlink" title="19.1 文本处理"></a>19.1 文本处理</h2><h3 id="19-1-1-sed-编辑器"><a href="#19-1-1-sed-编辑器" class="headerlink" title="19.1.1 sed 编辑器"></a>19.1.1 sed 编辑器</h3><p>sed 编辑器被称作流编辑器 (stream editor), 和交互式编辑器 (如 vim) 恰好相反.</p>
<p>sed 编辑器的操作:</p>
<ol>
<li>一次从输入中读取一行数据</li>
<li>根据所提供的编辑器命令匹配数据</li>
<li>按照命令修改流中的数据</li>
<li>将新的数据输出到 STDOUT</li>
</ol>
<p>命令格式:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">sed options <span class="hljs-keyword">script</span> <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure>
<p>可用选项:</p>
<ul>
<li><code>-e script</code>   在处理输入时，将 script 中指定的命令添加到已有的命令中</li>
<li><code>-f file</code>     在处理输入时，将 file 中指定的命令添加到已有的命令中</li>
<li><code>-n</code>          不产生命令输出，使用 print 命令来完成输出</li>
</ul>
<p>sed 编辑器并不会修改文本文件的数据，它只会将修改后的数据发送到 STDOUT.</p>
<p>替换命令, 如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is a test&quot;</span> | sed <span class="hljs-string">&#x27;s/test/big test/&#x27;</span></span> <br></code></pre></td></tr></table></figure>
<h4 id="执行多个命令"><a href="#执行多个命令" class="headerlink" title="执行多个命令"></a>执行多个命令</h4><p>执行多个命令时使用 <code>-e</code> 选项:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed -e <span class="hljs-string">&#x27;s/brown/green/; s/dog/cat/&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>命令用分号 <code>;</code> 隔开，且必须位于命令末尾，不能有空格.</p>
<h4 id="多行命令"><a href="#多行命令" class="headerlink" title="多行命令"></a>多行命令</h4><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed -e &#x27;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/brown/green/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/fox/elephant/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/dog/cat/<span class="hljs-string">&#x27; data1.txt</span></span><br></code></pre></td></tr></table></figure>
<h4 id="从文件中获取命令"><a href="#从文件中获取命令" class="headerlink" title="从文件中获取命令"></a>从文件中获取命令</h4><p>每个命令占一行，可以给文件添加后缀 <code>.sed</code></p>
<h3 id="19-1-2-gawk-程序"><a href="#19-1-2-gawk-程序" class="headerlink" title="19.1.2 gawk 程序"></a>19.1.2 gawk 程序</h3><p>在所有的发行版中都没有默认安装 gawk 程序。</p>
<p>gawk 是原始 awk 的 GNU 版本。</p>
<p>gawk 提供了一种编程语言。</p>
<p>基本格式:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">gawk <span class="hljs-keyword">option</span> program <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure>
<p>可用选项:</p>
<ul>
<li><code>-F FS</code>, 指定行中划分数据字段的字段分隔符</li>
<li><code>-f file</code>, 从指定的文件中读取程序</li>
<li><code>-v var=value</code>, 定义 gawk 程序中的一个变量及其默认值</li>
<li><code>-mf N</code>, 指定要处理文件中的最大字段数</li>
<li><code>-mr N</code>, 指定数据文件中的最大数据行数</li>
<li><code>-W keyword</code>, 指定 gawk 中兼容模式或警告等级</li>
</ul>
<p>gawk 的脚本用一对花括号来定义，必须把脚本命令放在一对花括号中 <code>&#123;&#125;</code>.</p>
<p>gawk 命令行假定脚本是单个文本字符串, 因此还需要把脚本放到单引号中:</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">$ gawk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Hello World&quot;</span>&#125;&#x27;<br></code></pre></td></tr></table></figure>
<p>gawk 会从 STDIN 等待输入数据。</p>
<p>gawk 会对数据中的每行文本执行程序.</p>
<p>使用 <code>Ctrl + D</code> 终止程序.</p>
<h4 id="使用数据字段变量"><a href="#使用数据字段变量" class="headerlink" title="使用数据字段变量"></a>使用数据字段变量</h4><p>gawk 会给一行中的每个数据元素分配一个变量, 默认为:</p>
<ul>
<li><code>$0</code>, 代表整个文本行</li>
<li><code>$1</code>, 代表文本行中的第1个数据字段</li>
<li><code>$2</code>, 代表文本行中的第2个数据字段</li>
<li><code>$n</code>, 代表文本行中的第n个数据字段<br>在文本行中，每个数据字段都是通过<mark>字段分隔符</mark>划分的。默认为任意的空白字符.</li>
</ul>
<h4 id="在程序脚本中使用多个命令"><a href="#在程序脚本中使用多个命令" class="headerlink" title="在程序脚本中使用多个命令"></a>在程序脚本中使用多个命令</h4><p>使用分号 <code>;</code> 分隔.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">$ gawk <span class="hljs-string">&#x27;&#123;<span class="hljs-subst">$4</span>=&quot;Christine&quot;; print <span class="hljs-subst">$0</span>&#125;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>一次一行:</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ gawk &#x27;&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">$<span class="hljs-number">4</span>=<span class="hljs-string">&quot;Christine</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">print $0&#125;&#x27;</span></span><br></code></pre></td></tr></table></figure>
<h4 id="从文件中读取程序"><a href="#从文件中读取程序" class="headerlink" title="从文件中读取程序"></a>从文件中读取程序</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> gawk <span class="hljs-operator">-F</span>: <span class="hljs-operator">-f</span> script2.gawk /etc/passwd<br></code></pre></td></tr></table></figure>
<p>脚本文件中一条命令一行，不需要分号，但需要一对花括号.</p>
<h4 id="在读取数据前运行脚本"><a href="#在读取数据前运行脚本" class="headerlink" title="在读取数据前运行脚本"></a>在读取数据前运行脚本</h4><p>gawk 允许指定程序脚本何时运行。</p>
<p><code>BEGIN</code> 关键词，让程序在读取数据前运行脚本 </p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ gawk <span class="hljs-symbol">&#x27;BEGIN</span> &#123;print <span class="hljs-string">&quot;Hello World&quot;</span>&#125;&#x27;<br></code></pre></td></tr></table></figure>
<h4 id="在处理数据后运行脚本"><a href="#在处理数据后运行脚本" class="headerlink" title="在处理数据后运行脚本"></a>在处理数据后运行脚本</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">$ gawk &#x27;<span class="hljs-type">END</span> &#123;print <span class="hljs-string">&quot;End of File&quot;</span>&#125;&#x27; <span class="hljs-class"><span class="hljs-keyword">data</span>.txt</span><br></code></pre></td></tr></table></figure>
<h2 id="19-2-sed-编辑器基础"><a href="#19-2-sed-编辑器基础" class="headerlink" title="19.2 sed 编辑器基础"></a>19.2 sed 编辑器基础</h2><h3 id="19-2-1-更多的替换选项"><a href="#19-2-1-更多的替换选项" class="headerlink" title="19.2.1 更多的替换选项"></a>19.2.1 更多的替换选项</h3><h4 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h4><p>替换命令在替换多行文本时能够正常工作，但默认情况下它只替换每行中出现的第一处.</p>
<p>四种替换标签 (substitution flag):</p>
<ul>
<li>数字，表明新文本将替换地挤出模式匹配的地方</li>
<li>g, 表明新文本将会替换所有匹配的文本</li>
<li>p, 表明输出修改过的行, 通常和 <code>-n</code> 选项一起用</li>
<li>w file, 将替换结果写到文件中<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ sed &#x27;s/<span class="hljs-keyword">test</span>/trial/w <span class="hljs-keyword">test</span>.txt&#x27; data.txt<br></code></pre></td></tr></table></figure>
这里的 <code>test.txt</code> 是指定的用来保存的文件.</li>
</ul>
<h4 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h4><p>sed 允许选择其他字符作为替换命令中的分隔符:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sed <span class="hljs-string">&#x27;s!/bin/bash!/bin/csh!&#x27;</span> <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure>
<p>这里用 <code>!</code> 作为分隔符.</p>
<h3 id="19-2-2-使用地址"><a href="#19-2-2-使用地址" class="headerlink" title="19.2.2 使用地址"></a>19.2.2 使用地址</h3><p>使用行寻址 (line addressing), 将命令作用于特定行或某些行.</p>
<p>两种形式:</p>
<ul>
<li>以数字形式表示行区间</li>
<li>用文本模式来过滤出行</li>
</ul>
<p>格式均为:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[address]</span>command<br></code></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">address &#123;<br>  comma<span class="hljs-symbol">nd1</span><br>  comma<span class="hljs-symbol">nd2</span><br>  comma<span class="hljs-symbol">nd3</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>sed 编辑器会将指定的每条命令作用到匹配指定地址的行上.</p>
<h4 id="数字形式的行寻址"><a href="#数字形式的行寻址" class="headerlink" title="数字形式的行寻址"></a>数字形式的行寻址</h4><p>可以是行号，也可以是区间:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2s/dog/cat/&#x27;</span> data.txt<br><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2,3s/dog/cat/&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>美元符 <code>$</code> 是特殊地址，表示最后一行.</p>
<h4 id="使用文本模式过滤器"><a href="#使用文本模式过滤器" class="headerlink" title="使用文本模式过滤器"></a>使用文本模式过滤器</h4><p>格式为:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/pattern/</span>command<br></code></pre></td></tr></table></figure>
<p>必须用正斜线 <code>/</code> 将指定的 <code>pattern</code> 封起来，sed 编辑器会将命令作用到包含指定文本模式的行上.</p>
<p>如:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sed <span class="hljs-string">&#x27;/Samantha/s/bash/csh/&#x27;</span> <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure>
<p>在前面的文本模式中可以使用正则表达式.</p>
<h4 id="命令组合"><a href="#命令组合" class="headerlink" title="命令组合"></a>命令组合</h4><p>在单行执行多条命令:</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed &#x27;2&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/fox/elephant/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/dog/cat/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; data.txt</span></span><br></code></pre></td></tr></table></figure>

<h3 id="19-2-3-删除行"><a href="#19-2-3-删除行" class="headerlink" title="19.2.3 删除行"></a>19.2.3 删除行</h3><p>删除命令 <code>d</code>, 它会删除匹配指定寻址模式的所有行。</p>
<p>删除所有行:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>指定行号:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;3d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>指定区间:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2.3d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>使用文本模式:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;/pattern/d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>使用两个文本模式删除某个区间，第一个文本模式会打开”删除”功能，第二个文本模式匹配结束后会关闭”删除”功能:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;/1/,/3/d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<h3 id="19-2-4-插入和附加文本"><a href="#19-2-4-插入和附加文本" class="headerlink" title="19.2.4 插入和附加文本"></a>19.2.4 插入和附加文本</h3><ul>
<li>插入 (insert) 命令 (i) 会在指定行前增加一个新行</li>
<li>附加 (append) 命令 (a) 会在指定行后增加一个新行<br>格式:<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;[address]command\ new_line_contents&#x27;</span><br></code></pre></td></tr></table></figure>
注意这里是反斜线.</li>
</ul>
<p>如:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;3i\ This is an insert line&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>这样写更清晰:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;3i\</span><br><span class="hljs-string">&gt; This is an insert line&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<h3 id="19-2-5-修改行"><a href="#19-2-5-修改行" class="headerlink" title="19.2.5 修改行"></a>19.2.5 修改行</h3><p>修改 (change) 命令允许修改数据流中整行文本的内容，其跟插入和附加命令的工作机制一样.</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ sed &#x27;<span class="hljs-number">3</span>c\<br>&gt; This <span class="hljs-keyword">is</span> a changed <span class="hljs-literal">line</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">text</span>&#x27; data.txt<br></code></pre></td></tr></table></figure>
<p>也可以用文本模式寻址:</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ sed &#x27;/pattern/c\<br>&gt; This <span class="hljs-keyword">is</span> a changed <span class="hljs-literal">line</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">text</span>&#x27; data.txt<br></code></pre></td></tr></table></figure>
<p>若用区间会出问题:</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ sed &#x27;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>\c<br>&gt; This <span class="hljs-keyword">is</span> a <span class="hljs-keyword">new</span> <span class="hljs-literal">line</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">text</span>&#x27; data.txt<br></code></pre></td></tr></table></figure>
<p>其会把 <code>2,3</code> 区间的行改为一行.</p>
<h3 id="19-2-6-转换命令"><a href="#19-2-6-转换命令" class="headerlink" title="19.2.6 转换命令"></a>19.2.6 转换命令</h3><p>转换 (transform) 命令 (y) 是唯一可以处理单个字符的 sed 编辑器命令。</p>
<p>格式:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[address]y<span class="hljs-regexp">/inchars/</span>outchars/<br></code></pre></td></tr></table></figure>
<p>不要把 <code>inchars</code> 和 <code>outchars</code> 看做一个单词，应为一个个字符，其映射为一一对应，个数不一致会报错:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;y/123/456&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>文件里面所有的 <code>1</code> 会被替换为 <code>4</code>.</p>
<h3 id="19-2-7-回顾打印"><a href="#19-2-7-回顾打印" class="headerlink" title="19.2.7 回顾打印"></a>19.2.7 回顾打印</h3><p>用于打印数据流中的信息:</p>
<ul>
<li>p命令用来打印文本行</li>
<li>等号 (&#x3D;) 用来打印行号</li>
<li>1 (小写的L) 用来列出行</li>
</ul>
<h4 id="打印行"><a href="#打印行" class="headerlink" title="打印行"></a>打印行</h4><p>打印指定行地址的行:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed -n <span class="hljs-string">&#x27;2,3p&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>打印包含文本模式匹配上的行:</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed -n &#x27;/pattern/&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">p</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/line/test/p</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; data.txt</span></span><br></code></pre></td></tr></table></figure>
<h4 id="打印行号"><a href="#打印行号" class="headerlink" title="打印行号"></a>打印行号</h4><p>使用 <code>=</code>:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> <span class="hljs-keyword">set</span> <span class="hljs-string">&#x27;=&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>sed 在实际文本出现之前打印出行号。</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ set -n &#x27;/number 4/&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">=</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">p</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; data.txt</span></span><br></code></pre></td></tr></table></figure>
<h4 id="列出行"><a href="#列出行" class="headerlink" title="列出行"></a>列出行</h4><p>列出 (list) 命令 (l) 可以打印数据流中的文本和不可打印的 ASCII 字符。</p>
<p>任何不可打印字符要么在其八进制值前加一个反斜线，要么使用 C 语言风格的命名法, 如 <code>\t</code>.</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span> data.txt<br>This  line  contains  tabs<br><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span> sed <span class="hljs-literal">-n</span> <span class="hljs-string">&#x27;l&#x27;</span> data.txt<br>This\tline\tcontains\ttabs<span class="hljs-variable">$</span><br></code></pre></td></tr></table></figure>
<h3 id="19-2-8-使用-sed-处理文件"><a href="#19-2-8-使用-sed-处理文件" class="headerlink" title="19.2.8 使用 sed 处理文件"></a>19.2.8 使用 sed 处理文件</h3><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2.3w test.txt&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<h4 id="从文件读取数据"><a href="#从文件读取数据" class="headerlink" title="从文件读取数据"></a>从文件读取数据</h4><p>读取 (read) 命令 (r) 允许将一个独立文件中的数据插入到数据流中。</p>
<p>格式:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[address]</span>r filename<br></code></pre></td></tr></table></figure>
<p>sed 编辑器会将文件中的文本插入到指定地址之后.</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed &#x27;/LIST/&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">r detail.<span class="hljs-property">txt</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">d</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; notice.std</span></span><br></code></pre></td></tr></table></figure>
<p>前面的文本模式对后面的命令都起效果.</p>
<h1 id="第20章-正则表达式"><a href="#第20章-正则表达式" class="headerlink" title="第20章 正则表达式"></a>第20章 正则表达式</h1><h2 id="20-1-什么是正则表达式"><a href="#20-1-什么是正则表达式" class="headerlink" title="20.1 什么是正则表达式"></a>20.1 什么是正则表达式</h2><h3 id="20-1-1-定义"><a href="#20-1-1-定义" class="headerlink" title="20.1.1 定义"></a>20.1.1 定义</h3><p>正则表达式是你所定义的模式模板 (pattern template), Linux 工具可以用它来过滤文本.</p>
<h3 id="20-1-2-正则表达式的类型"><a href="#20-1-2-正则表达式的类型" class="headerlink" title="20.1.2 正则表达式的类型"></a>20.1.2 正则表达式的类型</h3><p>正则表达式引擎是一套底层软件, 负责解释正则表达式模式并使用这些模式进行文本匹配.</p>
<p>sed 编辑器只符合 BRE (Basic Regular Expression) 引擎规范的子集.</p>
<h2 id="gawk-程序用-ERE-Extended-Regular-Expression-引擎来处理它的正则表达式-20-2-定义-BRE-模式可使用的模式包括-20-2-2-特殊字符正则表达式识别的特殊字符包括-20-2-8-特殊的字符组BRE-的特殊的字符组-alpha-匹配任意字母字符-alnum-匹配匹配任意字母和数字字符-blank-匹配空格或制表符-digit-匹配-0-9-之间的数字-lower-匹配小写字母-print-匹配任意可打印字符-punct-匹配标点符号-space-匹配任意标点符号-upper-匹配大写字符-20-3-扩展正则表达式可使用的包括"><a href="#gawk-程序用-ERE-Extended-Regular-Expression-引擎来处理它的正则表达式-20-2-定义-BRE-模式可使用的模式包括-20-2-2-特殊字符正则表达式识别的特殊字符包括-20-2-8-特殊的字符组BRE-的特殊的字符组-alpha-匹配任意字母字符-alnum-匹配匹配任意字母和数字字符-blank-匹配空格或制表符-digit-匹配-0-9-之间的数字-lower-匹配小写字母-print-匹配任意可打印字符-punct-匹配标点符号-space-匹配任意标点符号-upper-匹配大写字符-20-3-扩展正则表达式可使用的包括" class="headerlink" title="gawk 程序用 ERE (Extended Regular Expression) 引擎来处理它的正则表达式.## 20.2 定义 BRE 模式可使用的模式包括:  - ^ $ . [] *### 20.2.2 特殊字符正则表达式识别的特殊字符包括:### 20.2.8 特殊的字符组BRE 的特殊的字符组:  - [[:alpha:]], 匹配任意字母字符  - [[:alnum:]], 匹配匹配任意字母和数字字符  - [[:blank:]], 匹配空格或制表符  - [[:digit:]], 匹配 0~9 之间的数字  - [[:lower:]], 匹配小写字母  - [[:print:]], 匹配任意可打印字符  - [[:punct:]], 匹配标点符号  - [[:space:]], 匹配任意标点符号  - [[:upper:]], 匹配大写字符## 20.3 扩展正则表达式可使用的包括:  - ? + {} | ()"></a>gawk 程序用 ERE (Extended Regular Expression) 引擎来处理它的正则表达式.<br>## 20.2 定义 BRE 模式<br>可使用的模式包括:<br>  - ^ $ . [] *<br>### 20.2.2 特殊字符<br>正则表达式识别的特殊字符包括:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">.*^<span class="hljs-variable">$&#123;</span>&#125;\+<span class="hljs-string">?|</span>()<br></code></pre></td></tr></table></figure><br>### 20.2.8 特殊的字符组<br>BRE 的特殊的字符组:<br>  - [[:alpha:]], 匹配任意字母字符<br>  - [[:alnum:]], 匹配匹配任意字母和数字字符<br>  - [[:blank:]], 匹配空格或制表符<br>  - [[:digit:]], 匹配 0~9 之间的数字<br>  - [[:lower:]], 匹配小写字母<br>  - [[:print:]], 匹配任意可打印字符<br>  - [[:punct:]], 匹配标点符号<br>  - [[:space:]], 匹配任意标点符号<br>  - [[:upper:]], 匹配大写字符<br>## 20.3 扩展正则表达式<br>可使用的包括:<br>  - ? + {} | ()</h2><h3 id="20-3-3-使用花括号"><a href="#20-3-3-使用花括号" class="headerlink" title="20.3.3 使用花括号"></a>20.3.3 使用花括号</h3><p>默认情况下 gawk 不会识别正则表达式间隔 (即指定范围), 需指定 <code>--re-interval</code> 命令行选项.</p>
<h1 id="第21章-sed-进阶"><a href="#第21章-sed-进阶" class="headerlink" title="第21章 sed 进阶"></a>第21章 sed 进阶</h1><h2 id="21-1-多行命令"><a href="#21-1-多行命令" class="headerlink" title="21.1 多行命令"></a>21.1 多行命令</h2><p>三个可用来处理多行文本的特殊命令:</p>
<ul>
<li>N : 将数据流中的下一行加进来创建一个多行组 (multiline group) 来处理</li>
<li>D : 删除多行组中的一行</li>
<li>P : 打印多行组中的一行</li>
</ul>
<h3 id="21-1-1-next-命令"><a href="#21-1-1-next-命令" class="headerlink" title="21.1.1 next 命令"></a>21.1.1 next 命令</h3><h4 id="单行的-next-命令"><a href="#单行的-next-命令" class="headerlink" title="单行的 next 命令"></a>单行的 next 命令</h4><p>小写的 <code>n</code>.</p>
<p>也就是说, 先找到一行, 然后在其下一行执行命令列表. 之后也是先找, 然后再到下一行执行.</p>
<h4 id="合并文本行"><a href="#合并文本行" class="headerlink" title="合并文本行"></a>合并文本行</h4><p>单行 next 命令会将数据流中的下一行文本行移动到 sed 编辑器的工作空间 (称为模式空间), 多行版本的 next 命令 (用大写 N) 会将下一文本行添加到模式空间中已有的文本后.</p>
<p>虽然文本还是用换行符分隔, 但 sed 编辑器现在会将两行文本当成一行来处理.</p>
<p>在处理完一个模式空间里的文本后, 下一个匹配的行是模式空间之外的行.</p>
<p>大概是这样, 有一个文件有四行文本:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">This is <span class="hljs-keyword">the</span> header <span class="hljs-built_in">line</span>.<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> data <span class="hljs-built_in">line</span>.<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> data <span class="hljs-built_in">line</span>.<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> <span class="hljs-built_in">line</span>.<br></code></pre></td></tr></table></figure>
<p>可以看作:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">This is <span class="hljs-keyword">the</span> header <span class="hljs-built_in">line</span>.\n<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> data <span class="hljs-built_in">line</span>.\n<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> data <span class="hljs-built_in">line</span>.\n<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> <span class="hljs-built_in">line</span>.\n<br></code></pre></td></tr></table></figure>
<p>命令为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed <span class="hljs-string">&#x27;/first/&#123; N; s/\n/ / &#125;&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>相当于是先变成这样:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">This is <span class="hljs-keyword">the</span> header <span class="hljs-built_in">line</span>.\n<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> data <span class="hljs-built_in">line</span>.\nThis is <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> data <span class="hljs-built_in">line</span>.\n<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> <span class="hljs-built_in">line</span>.\n<br></code></pre></td></tr></table></figure>
<p>然后再对 <code>first</code> 这一行, 将第一个 <code>\n</code> 转换成空格. 这就体现出合并.</p>
<p>要注意 <code>N</code> 命令处理最后一行时的问题, 因为是最后一行, 没有下一行可以合并到模式空间, <code>N</code> 命令会叫 sed 编辑器停止.</p>
<h3 id="21-1-2-多行删除命令"><a href="#21-1-2-多行删除命令" class="headerlink" title="21.1.2 多行删除命令"></a>21.1.2 多行删除命令</h3><p><code>d</code> 命令是删除一行, 而不是一段文本. 和 <code>N</code> 命令配合时, 会将模式空间中的都删掉.</p>
<p><code>D</code> 命令是多行删除命令, 其只删除模式空间中的第一行. 该命令会删除到换行符 (含换行符) 为止的所有字符.</p>
<h3 id="21-1-3-多行打印命令"><a href="#21-1-3-多行打印命令" class="headerlink" title="21.1.3 多行打印命令"></a>21.1.3 多行打印命令</h3><p><code>P</code> 命令是多行打印命令, 它只打印模式空间中的第一行. 这包括模式空间中直到换行符为止的所有的字符.</p>
<h2 id="21-2-保持空间"><a href="#21-2-保持空间" class="headerlink" title="21.2 保持空间"></a>21.2 保持空间</h2><p>模式空间 (pattern space) 是一块活跃的缓冲区.</p>
<p>sed 编辑器有另一块称作保持空间 (hold space) 的缓冲区域.</p>
<p>在处理 pattern space 中的某些行时, 可以用 hold space 来临时保存一些行.</p>
<p>有 5 条命令可用来操作 hold space:</p>
<ul>
<li><code>h</code>, 将 pattern space 复制到 hold space</li>
<li><code>H</code>, 将 pattern space 附加到 hold space</li>
<li><code>g</code>, 将 hold space 复制到 pattern space</li>
<li><code>G</code>, 将 hold space 附加到 pattern space</li>
<li><code>x</code>, 交换 pattern space 和 hold space 的内容</li>
</ul>
<p>通常, 在使用 h 或 H 命令将字符串移动到 hold space 后, 最终还要用 g, G 或 x 命令将保存的字符串移回模式空间.</p>
<p>复制到, 意思就是会替换掉原本的内容.</p>
<h2 id="21-3-排除命令"><a href="#21-3-排除命令" class="headerlink" title="21.3 排除命令"></a>21.3 排除命令</h2><p><code>!</code> 命令作为排除 (negate) 命令, 会让原本会其作用的命令起相反作用.</p>
<p>如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sed -n <span class="hljs-string">&#x27;/head/!p&#x27;</span> data2.txt<br></code></pre></td></tr></table></figure>
<p>会将不包含 <code>head</code> 单词的行打印出来.</p>
<p><code>$</code> 表示的是特殊地址.</p>
<p>另一个例子:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sed <span class="hljs-string">&#x27;$!N; ...&#x27;</span> data.txt<br></code></pre></td></tr></table></figure>
<p>会对除最后一行的其他行执行 <code>N</code> 命令.</p>
<p>打印并不会移动缓冲区中的内容.</p>
<h2 id="21-4-改变流"><a href="#21-4-改变流" class="headerlink" title="21.4 改变流"></a>21.4 改变流</h2><p>通常, sed 编辑器会从脚本的顶部开始, 一直执行到脚本的结尾 (D 命令除外, 它会强制 sed 编辑器返回到脚本的顶部, 而不读取新的行, 毕竟已经删除了一行了, 不可能对删除的行执行剩下的命令).</p>
<h3 id="21-4-1-分支"><a href="#21-4-1-分支" class="headerlink" title="21.4.1 分支"></a>21.4.1 分支</h3><p>分支 (branch) 命令 <code>b</code> 的格式:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[address]</span><span class="hljs-selector-tag">b</span> <span class="hljs-selector-attr">[label]</span><br></code></pre></td></tr></table></figure>
<p><code>address</code> 参数决定了哪些行的数据会触发分支命令. </p>
<p><code>label</code> 参数定义了要跳转的位置, 如果没有加 label 参数, 跳转命令会跳转到脚本的结尾.</p>
<p>也就是说, 可以让某些行跳过某些命令而不执行.</p>
<p>标号以冒号开始, 最多可以是 7 个字符的长度. 要指定标签, 将它加到 <code>b</code> 命令后即可.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sed <span class="hljs-string">&#x27;&#123;/first/b jump1 ; s/This is the/No jump on/</span><br><span class="hljs-string">&gt; :jump1</span><br><span class="hljs-string">&gt; s/This is the/Jump hero on/&#125;&#x27;</span> data2.txt<br></code></pre></td></tr></table></figure>

<p>达成循环效果:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This, is, a, test, to, remove, commas.&quot;</span> | sed -n <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">&gt; :start</span><br><span class="hljs-string">&gt; s/,//1p</span><br><span class="hljs-string">&gt; /,/b start</span><br><span class="hljs-string">&gt; &#125;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>注意要防止无限循环.</p>
<p>感觉和汇编的 <code>jmp</code> 指令类似.</p>
<h3 id="21-4-2-测试"><a href="#21-4-2-测试" class="headerlink" title="21.4.2 测试"></a>21.4.2 测试</h3><p>测试 (test) 命令 <code>t</code>, 也用来改变 sed 编辑器脚本的执行流程.</p>
<p><code>t</code> 命令根据替换命令的结果跳转到某个标签, 而不是根据地址进行跳转.</p>
<p>格式:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[address]</span>t <span class="hljs-selector-attr">[label]</span><br></code></pre></td></tr></table></figure>
<p>和分支命令一样, 在没有指定标签的情况下, 如果测试成功, sed 回调转到脚本的结尾.</p>
<p><code>t</code> 命令提供了对数据流中的文本执行基本的 <code>if-then</code> 命令的一个低成本办法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sed <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">&gt; s/first/matchd/</span><br><span class="hljs-string">&gt; t</span><br><span class="hljs-string">&gt; s/This is the/No match on/</span><br><span class="hljs-string">&gt; &#125;&#x27;</span> data2.txt<br></code></pre></td></tr></table></figure>
<p>这个例子为, 如果第一个替换执行了, 就不会执行第二个.</p>
<p>可以用测试命令来结束循环.</p>
<h2 id="21-5-模式代替"><a href="#21-5-模式代替" class="headerlink" title="21.5 模式代替"></a>21.5 模式代替</h2><h3 id="21-5-1-amp-符号"><a href="#21-5-1-amp-符号" class="headerlink" title="21.5.1 &amp; 符号"></a>21.5.1 &amp; 符号</h3><p><code>&amp;</code> 符号可以用来代替命令中的匹配的模式. </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The cat sleeps in his hat.&quot;</span> | sed <span class="hljs-string">&#x27;s/.at/&quot;&amp;&quot;/g&#x27;</span><br></code></pre></td></tr></table></figure>
<p>匹配到了 <code>cat</code>, 那么 <code>&amp;</code> 的值为 <code>cat</code>, 匹配到后面的 <code>hat</code>, 则 <code>&amp;</code> 的值为 <code>hat</code>.</p>
<h3 id="21-5-2-代替单独的单词"><a href="#21-5-2-代替单独的单词" class="headerlink" title="21.5.2 代替单独的单词"></a>21.5.2 代替单独的单词</h3><p>sed 编辑器用圆括号来定义替换模式中的子模式.</p>
<p>替代字符由反斜线和数字组成, 数字表明子模式的位置, 如 <code>\1</code>, <code>\2</code>.</p>
<p>在替换命令中使用圆括号时, 必须用转移字符将它们标示为分组字符而不是普通的圆括号, 这有点反常:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The System Administrator manual&quot;</span> | sed <span class="hljs-string">&#x27;</span><br><span class="hljs-string">&gt; s/\(System\) Administrator/\1 User/&#x27;</span><br></code></pre></td></tr></table></figure>
<p>正则表达式的 <code>*</code> 放在文本的后面.</p>
<h2 id="21-6-在脚本中使用-sed"><a href="#21-6-在脚本中使用-sed" class="headerlink" title="21.6 在脚本中使用 sed"></a>21.6 在脚本中使用 sed</h2><h3 id="21-6-1-使用包装脚本"><a href="#21-6-1-使用包装脚本" class="headerlink" title="21.6.1 使用包装脚本"></a>21.6.1 使用包装脚本</h3><p>在 shell 脚本中, 可以将普通的 shell 变量及参数和 sed 编辑器脚本一起使用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#! /bin/bash</span><br>sed -n <span class="hljs-string">&#x27;&#123; 1!G ; h ; $p&#125;&#x27;</span> <span class="hljs-variable">$1</span> <br></code></pre></td></tr></table></figure>
<p>这个把命令行的第一个参数 (这里可以是文件名) 当成 sed 的输入. 这里的 <code>$p</code> 的含义是, 只有最后一行才打印. <code>p</code> 是一个动作.</p>
<h3 id="21-6-2-重定向-sed-的输出"><a href="#21-6-2-重定向-sed-的输出" class="headerlink" title="21.6.2 重定向 sed 的输出"></a>21.6.2 重定向 sed 的输出</h3><p>默认情况下, sed 编辑器会将脚本的结果输出到 STDOUT 上, 可以在 shell 脚本中使用各种标准方法对 sed 编辑器的输出进行重定向.</p>
<p>如用 <code>$()</code> 重定向到变量中.</p>
<h2 id="21-7-创建-sed-实用工具"><a href="#21-7-创建-sed-实用工具" class="headerlink" title="21.7 创建 sed 实用工具"></a>21.7 创建 sed 实用工具</h2><h3 id="21-7-1-加倍行间距"><a href="#21-7-1-加倍行间距" class="headerlink" title="21.7.1 加倍行间距"></a>21.7.1 加倍行间距</h3><p>保持空间的默认值为一个空行.</p>
<h3 id="21-7-2-对可能含有空白行的文件加倍行间距"><a href="#21-7-2-对可能含有空白行的文件加倍行间距" class="headerlink" title="21.7.2 对可能含有空白行的文件加倍行间距"></a>21.7.2 对可能含有空白行的文件加倍行间距</h3><p>先删除所有的空白行, 然后用 <code>G</code> 命令在所有行后插入新的空白行.</p>
<h3 id="21-7-3-给文件中的行编号"><a href="#21-7-3-给文件中的行编号" class="headerlink" title="21.7.3 给文件中的行编号"></a>21.7.3 给文件中的行编号</h3><p>在获得等号的输出后, 可以通过管道将输出传给另一个 sed 编辑器脚本, 它会使用 <code>N</code> 命令来合并这两行, 还需要用替换命令将换行符更换成空格或制表符.</p>
<h3 id="21-7-4-打印末尾行"><a href="#21-7-4-打印末尾行" class="headerlink" title="21.7.4 打印末尾行"></a>21.7.4 打印末尾行</h3><p>创建滚动窗口. 通过循环使用 <code>N</code> 和 <code>D</code> 命令, 可以做到, 向模式空间的文本行块增加新行的同时删除旧行.</p>
<p><code>q</code> (quit) 退出命令会停止循环.</p>
<h3 id="21-7-5-删除行"><a href="#21-7-5-删除行" class="headerlink" title="21.7.5 删除行"></a>21.7.5 删除行</h3><p>选择性的删除数据中不需要的空白行.</p>
<p>区间地址, 如 <code>/./,/^$/</code> 两个 pattern 用 <code>,</code> 分隔, 区间的开始是 <code>/./</code> 匹配任意的一个字符, 结尾是 <code>/^$/</code> 匹配一个空行.</p>
<h1 id="第22章-gawk-进阶"><a href="#第22章-gawk-进阶" class="headerlink" title="第22章 gawk 进阶"></a>第22章 gawk 进阶</h1><p>gawk 同样不会直接修改文件.</p>
<h2 id="22-1-使用变量"><a href="#22-1-使用变量" class="headerlink" title="22.1 使用变量"></a>22.1 使用变量</h2><p>两种类型:</p>
<ul>
<li>内建变量</li>
<li>自定义变量</li>
</ul>
<h3 id="22-1-1-内建变量"><a href="#22-1-1-内建变量" class="headerlink" title="22.1.1 内建变量"></a>22.1.1 内建变量</h3><h4 id="字段和分割符变量"><a href="#字段和分割符变量" class="headerlink" title="字段和分割符变量"></a>字段和分割符变量</h4><p>数据字段变量. 使用 <code>$</code> 来引用, 如 <code>$1</code>.</p>
<p>默认情况下, 字段分割符是一个空白字符.</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIELDWIDTHS</td>
<td>由空格分隔的一列数字, 定义了每个数据字段确切宽度</td>
</tr>
<tr>
<td>FS</td>
<td>输入字段分隔符, 默认为空格</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符, 默认为换行符</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符号, 默认为空格</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符号, 默认为换行符</td>
</tr>
</tbody></table>
<p><code>F</code> 指 Field, 字段, 一行中的一部分 (不一定).<br><code>R</code> 指 Record, 记录, 指一行 (不一定).</p>
<p>Field 和 Record 都看你怎么去分割.<br>这里的 <code>O</code> 就是 Output.</p>
<p>一旦设置了 FIELDWIDTHS, gawk 就会忽略 FS 变量, 并根据提供的字段宽度来计算字段.</p>
<p>一旦设定了 FIELDWIDTHS 变量的值, 就不能再改变了.</p>
<p>示例程序:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">$ gawk <span class="hljs-string">&#x27;BEGIN&#123;FIELDWIDTHS=&quot;3 5 2 5&quot;&#125;&#123;print <span class="hljs-subst">$1</span>,<span class="hljs-subst">$2</span>,<span class="hljs-subst">$3</span>,<span class="hljs-subst">$4</span>&#125;&#x27;</span> datalb<br></code></pre></td></tr></table></figure>

<h4 id="数据变量"><a href="#数据变量" class="headerlink" title="数据变量"></a>数据变量</h4><p><img src="/../img/gawk_var.png" srcset="/img/loading.gif" lazyload alt="更多 gawk 内建变量"></p>
<p>gawk 并不会将程序脚本当成命令参数的一部分.</p>
<p>如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;BEGIN&#123;print ARGC,ARGV[0],ARGV[1]&#125;&#x27;</span> data1<br>2 gawk data1<br>$<br></code></pre></td></tr></table></figure>
<p><code>ARGC</code> 变量表明命令行上有两个参数, 这包括 gawk 命令和 data1 参数, 中间的 <code>BEGIN&#123;print ARGC,ARGV[1]&#125;</code> 不算. <code>ARGV</code> 数组从索引 0 开始, 代表的是命令 (即 gawk). 第一个数组值是 gawk 命令后的第一个命令行参数.</p>
<p>跟 shell 变量不同, 在脚本中引用 gawk 变量时, 变量名前不加美元符.</p>
<p><code>ENVIRON</code> (environment) 变量使用关联数组 (即字典) 来提取环境变量:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;</span><br><span class="hljs-string">&gt; BEGIN&#123;</span><br><span class="hljs-string">&gt; print ENVIRON[&quot;HOME&quot;]</span><br><span class="hljs-string">&gt; print ENVIRON[&quot;PATH&quot;]</span><br><span class="hljs-string">&gt; &#125;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>可以用这种方法来提取任何环境变量的值.</p>
<p><code>NF</code> (Number of Field) 变量可以让你在不知道具体位置的情况下指定记录中的最后一个数据字段:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;:&quot;; OFS=&quot;:&quot;&#125; &#123;print $1,$NF&#125;&#x27;</span> /etc/passwd<br></code></pre></td></tr></table></figure>

<p>注意 <code>FNR</code> 和 <code>NR</code> 的区别, <code>FNR</code> 表示当前数据文件中已处理的记录数, <code>NR</code> 变量含有已处理过的记录总数.</p>
<p>在 shell 脚本中使用 gawk 时, 应该将不同的 gawk 命令放到不同的行, 这样容易理解和阅读.</p>
<p>可将 gawk 脚本放到一个单独的文件中, 并用 <code>-f</code> 参数来在 shell 脚本中引用.</p>
<h3 id="22-1-2-自定义变量"><a href="#22-1-2-自定义变量" class="headerlink" title="22.1.2 自定义变量"></a>22.1.2 自定义变量</h3><p>变量名可以是任意数目的字母, 数字和下划线, 但不能以数字开头. 区分大小写.</p>
<h4 id="1-在脚本中给变量赋值"><a href="#1-在脚本中给变量赋值" class="headerlink" title="1. 在脚本中给变量赋值"></a>1. 在脚本中给变量赋值</h4><p>赋值语句可以包含数学算式来处理数字值.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;BEGIN&#123;x=4; x= x * 2 + 3; print x&#125;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>求余符号为 <code>%</code>, 幂运算为 <code>^</code> 或 <code>**</code></p>
<h4 id="2-在命令行上给变量赋值"><a href="#2-在命令行上给变量赋值" class="headerlink" title="2. 在命令行上给变量赋值"></a>2. 在命令行上给变量赋值</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">cat</span> script1<br>BEGIN&#123;FS=<span class="hljs-string">&quot;,&quot;</span>&#125;<br>&#123;<span class="hljs-built_in">print</span> <span class="hljs-variable">$n</span>&#125;<br>$ gawk -f script1 n=2 data1<br>data12<br>data22<br>data32<br></code></pre></td></tr></table></figure>
<p>此方法的缺点, 设置的变量值在代码的 <code>BEGIN</code> 部分不可用.</p>
<p>使用 <code>-v</code> 命令行参数解决. 其允许在 <code>BEGIN</code> 代码之前设置变量, 在命令行上, <code>-v</code> 命令行参数必须放在脚本代码之前:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk -v n=3 -f script2 data1<br></code></pre></td></tr></table></figure>
<h2 id="22-2-处理数组"><a href="#22-2-处理数组" class="headerlink" title="22.2 处理数组"></a>22.2 处理数组</h2><p>gawk 使用关联数组 (字典) 提供数组功能.</p>
<h3 id="22-2-1-定义数组变量"><a href="#22-2-1-定义数组变量" class="headerlink" title="22.2.1 定义数组变量"></a>22.2.1 定义数组变量</h3><p>格式:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">var[index] = element<br></code></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">capital[<span class="hljs-string">&quot;Illinois&quot;</span>] = <span class="hljs-string">&quot;Springfield&quot;</span><br>capital[<span class="hljs-string">&quot;Indiana&quot;</span>] = <span class="hljs-string">&quot;Indianapilis&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="22-2-2-遍历数组变量"><a href="#22-2-2-遍历数组变量" class="headerlink" title="22.2.2 遍历数组变量"></a>22.2.2 遍历数组变量</h3><p>关联数组变量的问题在于你可能无法知晓索引值:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">for</span> (var <span class="hljs-keyword">in</span> array)<br>&#123;<br>    statements<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个 <code>for</code> 语句会在每次循环时将关联数组 <code>array</code> 的下一个索引值赋给变量 <code>var</code>, 然后执行一遍 <code>statements</code>.</p>
<p>如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;BEGIN&#123;</span><br><span class="hljs-string">&gt; var[&quot;a&quot;] = 1</span><br><span class="hljs-string">&gt; var[&quot;g&quot;] = 2</span><br><span class="hljs-string">&gt; var[&quot;m&quot;] = 3</span><br><span class="hljs-string">&gt; var[&quot;u&quot;] = 4</span><br><span class="hljs-string">&gt; for (test in var)</span><br><span class="hljs-string">&gt; &#123;</span><br><span class="hljs-string">&gt;   print &quot;Index:&quot;,test,&quot; -Value:&quot;,var[test]</span><br><span class="hljs-string">&gt; &#125;</span><br><span class="hljs-string">&#125;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>顺序是随机的.</p>
<h3 id="22-2-3-删除数组变量"><a href="#22-2-3-删除数组变量" class="headerlink" title="22.2.3 删除数组变量"></a>22.2.3 删除数组变量</h3><p>需要用:</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">array</span>[<span class="hljs-keyword">index</span>]<br></code></pre></td></tr></table></figure>
<p>会删除索引和相关的数据元素值.</p>
<h2 id="22-3-使用模式"><a href="#22-3-使用模式" class="headerlink" title="22.3 使用模式"></a>22.3 使用模式</h2><h3 id="22-3-1-正则表达式"><a href="#22-3-1-正则表达式" class="headerlink" title="22.3.1 正则表达式"></a>22.3.1 正则表达式</h3><p>在使用正则表达式时, 正则表达式必须出现在它要控制的程序脚本的左花括号前.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;,&quot;&#125; /11/&#123;print $1&#125;&#x27;</span> data1<br>data11<br></code></pre></td></tr></table></figure>
<p>gawk 程序会用正则表达式对记录中所有的数据字段进行匹配, 包括字段分隔符.</p>
<h3 id="22-3-2-匹配操作符"><a href="#22-3-2-匹配操作符" class="headerlink" title="22.3.2 匹配操作符"></a>22.3.2 匹配操作符</h3><p>matching operator 允许将正则表达式限定在记录中的特定数据字段. 匹配操作符是 <code>~</code>.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-variable">$1</span> ~ /^data/<br></code></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk -F: <span class="hljs-string">&#x27;$1 ~ /rich/&#123;print $1,$NF&#125;&#x27;</span> /etc/passwd<br></code></pre></td></tr></table></figure>
<p>先在 <code>$1</code> (即第一个数据字段中) 查找文本 rich, 如果找到了这个模式, 它会打印该记录的第一个 ($1) 和最后一个数据字段 ($NF).</p>
<p>用 <code>!</code> 符号排除正则表达式的匹配:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$1</span> !~ <span class="hljs-regexp">/expression/</span><br></code></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk -F: <span class="hljs-string">&#x27;$1 !~ /rich/&#123;print $1,$NF&#125;&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="22-3-3-数学表达式"><a href="#22-3-3-数学表达式" class="headerlink" title="22.3.3 数学表达式"></a>22.3.3 数学表达式</h3><p>显示所有属于 root 用户组 (组 ID 为 0) 的系统用户:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk -F: <span class="hljs-string">&#x27;$4 == 0&#123;print $1&#125;&#x27;</span> /etc/passwd<br></code></pre></td></tr></table></figure>
<p><code>$4</code> 为记录的第四个字段.</p>
<p>可以使用任何常见的数学比较表达式, 如:</p>
<ul>
<li><code>x == y</code></li>
<li><code>x &lt;= y</code></li>
<li><code>x &lt; y</code></li>
<li><code>x &gt;= y</code></li>
<li><code>x &gt; y</code></li>
</ul>
<p>也可以对数据文本使用表达式, 但是必须完全匹配:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk -F, <span class="hljs-string">&#x27;$1 == &quot;data&quot;&#123;print $1&#125;&#x27;</span> data1<br></code></pre></td></tr></table></figure>
<h2 id="22-4-结构化命令"><a href="#22-4-结构化命令" class="headerlink" title="22.4 结构化命令"></a>22.4 结构化命令</h2><h3 id="22-4-1-if-语句"><a href="#22-4-1-if-语句" class="headerlink" title="22.4.1 if 语句"></a>22.4.1 if 语句</h3><p>格式:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">if</span> <span class="hljs-comment">(condition)</span><br>    stateme<span class="hljs-symbol">nt1</span><br></code></pre></td></tr></table></figure>
<p>如果要在 <code>if</code> 语句中执行多条语句, 就必须用花括号将它们括起来:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">&gt; if ($1 &gt; 20)</span><br><span class="hljs-string">&gt; &#123;</span><br><span class="hljs-string">&gt;   x = $1 * 2</span><br><span class="hljs-string">&gt;   print x</span><br><span class="hljs-string">&gt; &#125;</span><br><span class="hljs-string">&gt; &#125;&#x27;</span> data4<br></code></pre></td></tr></table></figure>
<p>gawk 的 <code>if</code> 语句也支持 <code>else</code> 子句.</p>
<p>可以在单行上使用 <code>else</code> 子句, 但必须在 <code>if</code> 语句部分之后使用分号:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">if</span> <span class="hljs-comment">(condition)</span> stateme<span class="hljs-symbol">nt1</span>; else stateme<span class="hljs-symbol">nt2</span><br></code></pre></td></tr></table></figure>
<h3 id="22-4-2-while-语句"><a href="#22-4-2-while-语句" class="headerlink" title="22.4.2 while 语句"></a>22.4.2 while 语句</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">while</span> (condition)<br>&#123;<br>    <span class="hljs-built_in">statements</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>gawk 编程语言支持在 <code>while</code> 循环中使用 <code>break</code> 语句和 <code>continue</code> 语句.</p>
<h3 id="22-4-3-do-while-语句"><a href="#22-4-3-do-while-语句" class="headerlink" title="22.4.3 do-while 语句"></a>22.4.3 do-while 语句</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">do</span><br>&#123;<br>    <span class="hljs-built_in">statements</span><br>&#125; <span class="hljs-keyword">while</span> (condition)<br></code></pre></td></tr></table></figure>
<p>这种格式保证了语句会在条件被求值之前至少执行一次.</p>
<h3 id="22-4-4-for-语句"><a href="#22-4-4-for-语句" class="headerlink" title="22.4.4 for 语句"></a>22.4.4 for 语句</h3><p>gawk 编程语言支持 C 风格的 for 循环:</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (variable assignment<span class="hljs-comment">; condition; iteration proces)</span><br></code></pre></td></tr></table></figure>
<p>也有 <code>i++</code>, <code>total += $1</code>.</p>
<h2 id="22-5-格式化打印"><a href="#22-5-格式化打印" class="headerlink" title="22.5 格式化打印"></a>22.5 格式化打印</h2><p><code>printf</code> 命令, 和 C 中用发一致:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;format string&quot;</span>, <span class="hljs-built_in">var1</span>, var2 ...<br></code></pre></td></tr></table></figure>
<p>格式化指定符格式:</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">%[modifier]<span class="hljs-keyword">control</span>-letter<br></code></pre></td></tr></table></figure>
<p>如:<br><img src="/../img/formatstring.png" srcset="/img/loading.gif" lazyload alt="format string"></p>
<p>三种修饰符进一步控制输出:</p>
<ul>
<li>width: 指定输出字段的最小宽度</li>
<li>prec: 指定浮点数中小数点后面位数, 或者文本字符串中显示的最大字符数</li>
<li><code>-</code> (减号): 指明采用左对齐</li>
</ul>
<p>使用起来仍然是 <code>%16.1f</code> 这种.</p>
<h2 id="22-6-内建函数"><a href="#22-6-内建函数" class="headerlink" title="22.6 内建函数"></a>22.6 内建函数</h2><h3 id="22-6-1-数学函数"><a href="#22-6-1-数学函数" class="headerlink" title="22.6.1 数学函数"></a>22.6.1 数学函数</h3><p><img src="/../img/mathfn.png" srcset="/img/loading.gif" lazyload alt="mathfn"></p>
<p><code>int()</code> 会生成一个值的整数部分, 其为该值与 0 之间最接近该值的整数.</p>
<p>产生 0~10 之间的随机整数值:</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">x</span> = <span class="hljs-function"><span class="hljs-title">int</span>(<span class="hljs-number">10</span> * <span class="hljs-title">rand</span>())</span><br></code></pre></td></tr></table></figure>
<p>除了标准数学函数外, gawk 还支持一些按位操作数据的函数:<br><img src="/../img/bitopr.png" srcset="/img/loading.gif" lazyload alt="bitopr"></p>
<h3 id="22-6-2-字符串函数"><a href="#22-6-2-字符串函数" class="headerlink" title="22.6.2 字符串函数"></a>22.6.2 字符串函数</h3><p><img src="/../img/strfn1.png" srcset="/img/loading.gif" lazyload alt="strfn"></p>
<p><img src="/../img/strfn2.png" srcset="/img/loading.gif" lazyload alt="strfn"></p>
<h3 id="22-6-3-时间函数"><a href="#22-6-3-时间函数" class="headerlink" title="22.6.3 时间函数"></a>22.6.3 时间函数</h3><p><img src="/../img/timefn.png" srcset="/img/loading.gif" lazyload alt="timefn"></p>
<h2 id="22-7-自定义函数"><a href="#22-7-自定义函数" class="headerlink" title="22.7 自定义函数"></a>22.7 自定义函数</h2><h3 id="22-7-1-定义函数"><a href="#22-7-1-定义函数" class="headerlink" title="22.7.1 定义函数"></a>22.7.1 定义函数</h3><p>使用 function 关键词:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gawk">function name([variables])<br>&#123;<br>    statements<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数还能用 <code>return</code> 语句返回值:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">return</span> value<br></code></pre></td></tr></table></figure>
<h3 id="22-7-2-使用自定义函数"><a href="#22-7-2-使用自定义函数" class="headerlink" title="22.7.2 使用自定义函数"></a>22.7.2 使用自定义函数</h3><p>在定义函数时, 它必须出现在所有代码块之前 (包括 BEGIN 代码块):</p>
<h3 id="22-7-3-创建函数库"><a href="#22-7-3-创建函数库" class="headerlink" title="22.7.3 创建函数库"></a>22.7.3 创建函数库</h3><p>创建一个含有 gawk 程序的文件, 然后在命令行上用 <code>-f</code> 参数指定库文件和程序文件.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk -f funclib -f script data<br></code></pre></td></tr></table></figure>
<h2 id="22-8-实例"><a href="#22-8-实例" class="headerlink" title="22.8 实例"></a>22.8 实例</h2><h1 id="第23章-使用其他-shell"><a href="#第23章-使用其他-shell" class="headerlink" title="第23章 使用其他 shell"></a>第23章 使用其他 shell</h1><h2 id="23-4-zsh-shell"><a href="#23-4-zsh-shell" class="headerlink" title="23.4 zsh shell"></a>23.4 zsh shell</h2><p>zsh 提供了一组核心内建命令, 并提供了添加额外命令模块 (command module) 的能力, 每个命令模块都为特定场景提供了另外一组内建命令.</p>
<h2 id="23-5-zsh-shell-的组成"><a href="#23-5-zsh-shell-的组成" class="headerlink" title="23.5 zsh shell 的组成"></a>23.5 zsh shell 的组成</h2><h1 id="第24章-编写简单的脚本实用工具"><a href="#第24章-编写简单的脚本实用工具" class="headerlink" title="第24章 编写简单的脚本实用工具"></a>第24章 编写简单的脚本实用工具</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Shell/" class="category-chain-item">Shell</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Linux Command Line and Shell Scripting Bible Notes</div>
      <div>http://example.com/2022/07/17/Linux-Command-Line-and-Shell-Scripting-Bible-Notes/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年7月17日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/18/Linux-System-Programming/" title="Linux System Programming">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux System Programming</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/15/Operating-Systems-Design-and-Implementation-Note/" title="Operating Systems Design and Implementation Note">
                        <span class="hidden-mobile">Operating Systems Design and Implementation Note</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'zKurisu/comments-utterances');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Jie</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Orkarin</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
