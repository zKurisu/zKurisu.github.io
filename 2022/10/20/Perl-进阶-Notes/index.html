

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/wallhaven-j5kjgy_1920x1080.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="第一章 简介申请 PAUSE 账户, 此链接 使用 use 指定版本时, 小数点之后需要有三个数字, 如: 1use 5.014; 也可以使用两个小数点的形式: 1use v5.14.2; or: 1use 5.14.2;  在线 Perl 社区 第二章 使用模块CPAN (Comprehensice Perl Archive Network). 有三个相关页面:  主页 搜索界面 MetaCPA">
<meta property="og:type" content="article">
<meta property="og:title" content="Perl-进阶-Notes">
<meta property="og:url" content="http://example.com/2022/10/20/Perl-%E8%BF%9B%E9%98%B6-Notes/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第一章 简介申请 PAUSE 账户, 此链接 使用 use 指定版本时, 小数点之后需要有三个数字, 如: 1use 5.014; 也可以使用两个小数点的形式: 1use v5.14.2; or: 1use 5.14.2;  在线 Perl 社区 第二章 使用模块CPAN (Comprehensice Perl Archive Network). 有三个相关页面:  主页 搜索界面 MetaCPA">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/Pod_mark.png">
<meta property="og:image" content="http://example.com/img/the_PeGS_structure_of_tv_horse.png">
<meta property="article:published_time" content="2022-10-20T03:02:45.000Z">
<meta property="article:modified_time" content="2022-12-02T14:41:29.243Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/Pod_mark.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Perl-进阶-Notes - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jie</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/SteinsGate_all.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Perl-进阶-Notes"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-20 11:02" pubdate>
          2022年10月20日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          32k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          264 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Perl-进阶-Notes</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="第一章 简介"></a>第一章 简介</h1><p>申请 PAUSE 账户, <a target="_blank" rel="noopener" href="https://pause.perl.org/pause/authenquery?ACTION=request_id">此链接</a></p>
<p>使用 <code>use</code> 指定版本时, 小数点之后需要有三个数字, 如:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> <span class="hljs-number">5.014</span>;<br></code></pre></td></tr></table></figure>
<p>也可以使用两个小数点的形式:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">14.2</span>;<br></code></pre></td></tr></table></figure>
<p>or:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> <span class="hljs-number">5.14</span>.<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://learn.perl.org/">在线 Perl 社区</a></p>
<h1 id="第二章-使用模块"><a href="#第二章-使用模块" class="headerlink" title="第二章 使用模块"></a>第二章 使用模块</h1><p>CPAN (Comprehensice Perl Archive Network). 有三个相关页面:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.cpan.org/">主页</a></li>
<li><a target="_blank" rel="noopener" href="http://search.cpan.org/">搜索界面</a></li>
<li><a target="_blank" rel="noopener" href="https://www.metacpan.org/">MetaCPAN</a></li>
</ul>
<h2 id="2-1-标准发行版"><a href="#2-1-标准发行版" class="headerlink" title="2.1 标准发行版"></a>2.1 标准发行版</h2><p>使用 <code>Module::CoreList</code> 模块可以查看不同 Perl 版本中自带的模块的信息.</p>
<p>Perl 安装时自带的模块被称为 “核心模块”, 或 “标准发行版”.</p>
<h2 id="2-2-探讨-CPAN"><a href="#2-2-探讨-CPAN" class="headerlink" title="2.2 探讨 CPAN"></a>2.2 探讨 CPAN</h2><p>介绍了很多网站, 具体看书.</p>
<h2 id="2-3-使用模块"><a href="#2-3-使用模块" class="headerlink" title="2.3 使用模块"></a>2.3 使用模块</h2><p>可以访问, <a target="_blank" rel="noopener" href="http://perldoc.perl.org/">此网站</a>, 以 HTML 格式或者 PDF 格式读取 Perl 一些版本的文档.</p>
<p>或者直接用 <code>perldoc</code> 命令直接查看.</p>
<h2 id="2-4-功能接口"><a href="#2-4-功能接口" class="headerlink" title="2.4 功能接口"></a>2.4 功能接口</h2><h3 id="选择需要导入的内容"><a href="#选择需要导入的内容" class="headerlink" title="选择需要导入的内容"></a>选择需要导入的内容</h3><p>在模块名之后指定一个子例程列表, 称导入列表:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Basename (<span class="hljs-string">&#x27;fileparse&#x27;</span>, <span class="hljs-string">&#x27;basename&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>更常见的写法:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Basename qe( fileparse basename );<br></code></pre></td></tr></table></figure>

<p>即使导入列表中仅有一项, 我们仍然倾向于将该项写入 <code>qw()</code> 列表, 使程序一致性更好并且易于维护.</p>
<p>在调用子例程时, 我们不需要在前面添加 “&amp;” 符号, 这是因为编译器已经通过 <code>use</code> 语句知道子例程的名称.</p>
<h2 id="2-5-面向对象的接口"><a href="#2-5-面向对象的接口" class="headerlink" title="2.5 面向对象的接口"></a>2.5 面向对象的接口</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Spec;<br><br><span class="hljs-keyword">my</span> $filespec = File::Spec-&gt;catfile( $homedir<span class="hljs-string">&#123;gilligan&#125;</span>, <span class="hljs-string">&#x27;web_docs&#x27;</span>, <span class="hljs-string">&#x27;photos&#x27;</span>, <span class="hljs-string">&#x27;USS_Minnow.gif&#x27;</span> );<br></code></pre></td></tr></table></figure>
<p>调用 <code>File::Spec</code> 的 <code>catfile</code> 类方法. 该方法为本地操作系统创建一个合适的路径, 并且返回单个字符串.</p>
<h3 id="2-5-1-一个更典型的面向对象模块-Math-BigInt"><a href="#2-5-1-一个更典型的面向对象模块-Math-BigInt" class="headerlink" title="2.5.1 一个更典型的面向对象模块: Math::BigInt"></a>2.5.1 一个更典型的面向对象模块: Math::BigInt</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Math::BigInt;<br><br><span class="hljs-keyword">my</span> $value = Math::BigInt-&gt;new(<span class="hljs-number">2</span>); <span class="hljs-comment"># start with 2</span><br>$value-&gt;bpow(<span class="hljs-number">1000</span>); <span class="hljs-comment"># take 2**1000</span><br><span class="hljs-keyword">print</span> $value-&gt;bstr, <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment"># print it out</span><br></code></pre></td></tr></table></figure>

<p><code>new</code> 关键词用来创建对象.</p>
<h3 id="2-5-2-更佳的模块输出"><a href="#2-5-2-更佳的模块输出" class="headerlink" title="2.5.2 更佳的模块输出"></a>2.5.2 更佳的模块输出</h3><p>使用 <code>Spreadsheet::WriteExcel</code> 模块.</p>
<h2 id="2-6-核心模块的内容"><a href="#2-6-核心模块的内容" class="headerlink" title="2.6 核心模块的内容"></a>2.6 核心模块的内容</h2><p>关于 <code>Module::CoreList</code> 模块, 见书.</p>
<h2 id="2-7-Perl-综合典藏网"><a href="#2-7-Perl-综合典藏网" class="headerlink" title="2.7 Perl 综合典藏网"></a>2.7 Perl 综合典藏网</h2><h2 id="2-8-通过-CPAN-安装模块"><a href="#2-8-通过-CPAN-安装模块" class="headerlink" title="2.8 通过 CPAN 安装模块"></a>2.8 通过 CPAN 安装模块</h2><p>使用 Perl 自带的 <code>cpan</code> 程序, 只需告诉 <code>cpan</code> 需要安装的模块的名称.</p>
<p>如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cpan Perl::Critic<br></code></pre></td></tr></table></figure>

<p>若不带参数, 会启动 CPAN.pm 中的交互 shell 模式:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cpan<br>&gt; install Perl::Tidy<br></code></pre></td></tr></table></figure>
<p>可使用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perldoc cpan<br></code></pre></td></tr></table></figure>
<p>查阅.</p>
<p>另一个 CPANPLUS 模块.</p>
<h3 id="2-8-1-CPANminux"><a href="#2-8-1-CPANminux" class="headerlink" title="2.8.1 CPANminux"></a>2.8.1 CPANminux</h3><p>cpanm 工具.</p>
<h3 id="2-8-2-手动安装模块"><a href="#2-8-2-手动安装模块" class="headerlink" title="2.8.2 手动安装模块"></a>2.8.2 手动安装模块</h3><p>如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ wget ...<br>$ tar -xzf ...<br>$ <span class="hljs-built_in">cd</span> ...<br></code></pre></td></tr></table></figure>

<p>如果找到一个名为 Makefile.PL 的文件, 就运行这一系列编译, 测试和最终安装源代码的命令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl Makefile.PL<br>$ make<br>$ make <span class="hljs-built_in">test</span><br>$ make install<br></code></pre></td></tr></table></figure>

<p>可通过配置 <code>INSTALL_BASE</code> 参数, 将该模块安装到其他路径. 可通过 <code>perl -V</code> 查看默认库目录等设定.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl Makefile.PL INSTALL_BASE=/User/home/Ginger<br></code></pre></td></tr></table></figure>

<p>为了使 Perl 能够在以上目录中查找所安装的模块, 可以设置 <code>PERL5LIB</code> 环境变量.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">export</span> PERL5LIB=/Users/home/Ginger<br></code></pre></td></tr></table></figure>

<p>也可以使用 <code>lib</code> 编译指令将模块的安装目录添加到模块的搜索路径中.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> lib <span class="hljs-string">qw(/Users/home/Ginger)</span>;<br></code></pre></td></tr></table></figure>

<p>如果在模块的安装目录下找到的是 Build.PL 文件而不是 Makefile.PL:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl Build.PL<br>$ perl Build<br>$ perl Build <span class="hljs-built_in">test</span><br>$ perl Build install<br></code></pre></td></tr></table></figure>
<p>使用的是 <code>install_base</code> 参数.</p>
<h2 id="2-9-适时设定路径"><a href="#2-9-适时设定路径" class="headerlink" title="2.9 适时设定路径"></a>2.9 适时设定路径</h2><p>Perl 会浏览 <code>@INC</code> (include) 数组中的目录元素以查找模块</p>
<p>在 <code>use</code> 执行前修改 <code>@INC</code> 数组的内容, 添加 <code>BEGIN</code> 块:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">BEGIN &#123; <span class="hljs-keyword">unshift</span> @INC, <span class="hljs-string">&#x27;/Users/gilligan/lib&#x27;</span>; &#125;<br><span class="hljs-keyword">use</span> Navigation::SearOfPants;<br></code></pre></td></tr></table></figure>
<p>可用 <code>lib</code> 代替:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> lib <span class="hljs-string">&#x27;/Users/gilligan/lib&#x27;</span>;<br><span class="hljs-keyword">use</span> Navigation::SearOfPants;<br></code></pre></td></tr></table></figure>
<p><code>lib</code> 编译指令获取一个或者多个参数, 并且将它们添加到 <code>@INC</code> 数组的起始部分.</p>
<p><code>use lib</code> 后面只是模块所在的目录的路径, 而不是模块的路径.</p>
<p><code>use lib</code> 在编译时运行.</p>
<p>FindBin 模块. 该模块查找脚本目录的完整路径, <code>$BIN</code> 变量是对应脚本所在目录的路径.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> FindBin <span class="hljs-string">qw( $Bin )</span>;<br></code></pre></td></tr></table></figure>
<h2 id="2-10-在程序外部设定路径"><a href="#2-10-在程序外部设定路径" class="headerlink" title="2.10 在程序外部设定路径"></a>2.10 在程序外部设定路径</h2><h3 id="2-10-1-使用-PERL5LIB-扩展-INC"><a href="#2-10-1-使用-PERL5LIB-扩展-INC" class="headerlink" title="2.10.1 使用 PERL5LIB 扩展 @INC"></a>2.10.1 使用 PERL5LIB 扩展 @INC</h3><p>PERL5LIB 变量能够在类 UNIX 系统中包含由冒号分割的多个目录.</p>
<h3 id="2-10-2-在命令行扩展-INC-目录"><a href="#2-10-2-在命令行扩展-INC-目录" class="headerlink" title="2.10.2 在命令行扩展 @INC 目录"></a>2.10.2 在命令行扩展 @INC 目录</h3><p>使用一个或多个 <code>-I</code> 选项直接调用 perl:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl -I/home/skipper/perl-lib <br></code></pre></td></tr></table></figure>
<h2 id="2-11-local-lib"><a href="#2-11-local-lib" class="headerlink" title="2.11 local: lib"></a>2.11 local: lib</h2><p>默认情况下, CPAN 工具将新模块安装到与 perl 相同的目录.</p>
<p><code>local::lib</code> 模块设定多种环境变量, 其影响 CPAN 客户端安装模块的位置和 Perl 程序查找所安装的模块的位置.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl -Mlocal::lib<br></code></pre></td></tr></table></figure>
<p>安装 <code>local::lib</code> 模块.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl Makefile.PL --bootstrap<br>$ make install<br></code></pre></td></tr></table></figure>
<p>可以在 CPAN 工具中使用 <code>-I</code> 选项来使用 <code>local::lib</code> 模块.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cpan -I Set::Crossproduct<br></code></pre></td></tr></table></figure>
<p>其会查找你是否有默认目录的写入权限, 如果没有, 则会自动启用 <code>local::lib</code> 模块.</p>
<p>若要明确使用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cpan --local-lib HTML::Parser<br></code></pre></td></tr></table></figure>
<p>在程序中使用 <code>local::lib</code> 模块, 程序就知道在何处查找我们安装的模块.</p>
<p>还可这样处理任何路径:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl -Mlocal::lib=<span class="hljs-string">&#x27;~/perlstuff&#x27;</span><br></code></pre></td></tr></table></figure>

<h1 id="第3章-中级基础"><a href="#第3章-中级基础" class="headerlink" title="第3章 中级基础"></a>第3章 中级基础</h1><h2 id="3-1-列表操作符"><a href="#3-1-列表操作符" class="headerlink" title="3.1 列表操作符"></a>3.1 列表操作符</h2><h3 id="3-1-1-使用-grep-表达式"><a href="#3-1-1-使用-grep-表达式" class="headerlink" title="3.1.1 使用 grep 表达式"></a>3.1.1 使用 grep 表达式</h3><p>可匹配正则表达式:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @end_in_4 = <span class="hljs-keyword">grep</span> <span class="hljs-regexp">/4$/</span>, @input_numbers;<br></code></pre></td></tr></table></figure>

<p>如果测试过于复杂, 就可以将其隐藏在一个子例程中:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @odd_digit_sum = <span class="hljs-keyword">grep</span> digit_sum_is_odd($_), @input_numbers;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">digit_sum_is_odd</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $input = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">my</span> @digits = <span class="hljs-keyword">split</span> <span class="hljs-regexp">//</span>, $input;<br>    <span class="hljs-keyword">my</span> $sum;<br>    $sum += $_ <span class="hljs-keyword">for</span> @ @digits;<br>    <span class="hljs-keyword">return</span> $sum % <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另一种写法为:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $test = <span class="hljs-keyword">grep</span> &#123; ... &#125; @list;<br></code></pre></td></tr></table></figure>

<p>这里的代码块实际上是一个匿名子例程.</p>
<p>能够引入作用域限于 “块” 的变量, 即使用 <code>my</code>.</p>
<h3 id="3-1-2-使用-map-转换列表"><a href="#3-1-2-使用-map-转换列表" class="headerlink" title="3.1.2 使用 map 转换列表"></a>3.1.2 使用 map 转换列表</h3><p>可以每个输入产生两个输出:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @result = <span class="hljs-keyword">map</span> &#123; $_, <span class="hljs-number">3</span> * $_ &#125; @input_numbers;<br></code></pre></td></tr></table></figure>
<p>可直接使用 map 表达式生成散列:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> %hash = <span class="hljs-keyword">map</span> &#123; $_, <span class="hljs-number">3</span> * $_ &#125; @input_numbers;<br></code></pre></td></tr></table></figure>
<p>可以为每个输入项生成不同的输出项:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @result = <span class="hljs-keyword">map</span> &#123; <span class="hljs-keyword">split</span> <span class="hljs-regexp">//</span> &#125; @input_numbers;<br></code></pre></td></tr></table></figure>
<p><code>split //</code> 就是直接把输入拆开.</p>
<p>如果一个特定调用的结果是空列表, map 表达式就将这个空结果连接到更大的列表中, 不为列表添加任何元素:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @result = <span class="hljs-keyword">map</span> &#123;<br>    <span class="hljs-keyword">my</span> @digits = <span class="hljs-keyword">split</span> <span class="hljs-regexp">//</span>, $_;<br>    <span class="hljs-keyword">if</span> ($digits[-<span class="hljs-number">1</span>] == <span class="hljs-number">4</span>) &#123;<br>        @digits;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        (  );   <span class="hljs-comment"># 返回的空列表</span><br>    &#125;<br>&#125; @input_numbers;<br></code></pre></td></tr></table></figure>

<p>能够用 map 表达式和 grep 表达式做的所有事情, 也能够使用显示的 foreach 循环完成.</p>
<h2 id="3-2-使用-eval-捕获错误"><a href="#3-2-使用-eval-捕获错误" class="headerlink" title="3.2 使用 eval 捕获错误"></a>3.2 使用 eval 捕获错误</h2><p>eval 表达式是 Perl 的首选异常机制.</p>
<p>最常见的是在 eval 语句块执行完之后立即检查 <code>$@</code>, 该特殊变量为空则意味着没有错误.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">eval</span> &#123; $average = $total / $count &#125;;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;continuing after error: $@&quot;</span> <span class="hljs-keyword">if</span> $@;<br><br><span class="hljs-keyword">eval</span> &#123; rescue_scheme_42() &#125;;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;continuing after error: $@&quot;</span> <span class="hljs-keyword">if</span> $@;<br></code></pre></td></tr></table></figure>
<p>eval 语句块后的分号是必须的, eval 是一个术语, 而不是控制结构.</p>
<p>块中的代码运行失败, 在标量上下文中返回 undef, 在列表上下文中返回空列表. 成功则有正常的返回值.</p>
<p>eval 不捕获警告, 语法错误, 和 perl 自己中断执行的错误.</p>
<h2 id="3-3-用-eval-语句块动态编译代码"><a href="#3-3-用-eval-语句块动态编译代码" class="headerlink" title="3.3 用 eval 语句块动态编译代码"></a>3.3 用 eval 语句块动态编译代码</h2><p>eval 语句块的第二种形式: 参数是字符串表达式而不是代码块. 在运行时通过字符串的方式编译和执行代码. 但是不建议对字符串使用 eval 语句块.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">eval</span> <span class="hljs-string">&#x27;$sum = 2 + 2&#x27;</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The sum is $sum\n&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>Perl 在词法上下文中执行 eval 语句块前后的代码, eval 语句块的结果即为最后一个表达式的值.</p>
<p>如果 eval 语句块不能够正确编译并且不能正确运行我们传递的 Perl 代码, 同样设置 <code>$@</code> 变量.</p>
<h2 id="3-4-使用-do-语句块"><a href="#3-4-使用-do-语句块" class="headerlink" title="3.4 使用 do 语句块"></a>3.4 使用 do 语句块</h2><p>do 语句执行的结果同样是最后一个表达式的值. do  语句可以把一组语句聚集为单个表达式.</p>
<p>如, 将:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $bowler;<br><span class="hljs-keyword">if</span> (...) &#123;<br>    $bowler = <span class="hljs-string">&#x27;Mary Ann&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">elsif</span> (...) &#123;<br>    $bowler = <span class="hljs-string">&#x27;Ginger&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    $bowler = <span class="hljs-string">&#x27;The Professor&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用 do 表达式写为:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $bowler = <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (...) &#123; <span class="hljs-string">&#x27;Mary Ann&#x27;</span> &#125;<br>    <span class="hljs-keyword">elsif</span> (...) &#123; <span class="hljs-string">&#x27;Ginger&#x27;</span> &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-string">&#x27;The Professor&#x27;</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>do 语句适合创建一个操作的作用域</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $file_contents = <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">local</span> $/;<br>    <span class="hljs-keyword">local</span> @ARGV = ( $filename );<br>    &lt;&gt;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同样可以向 do 语句块提供字符串的形式, 其会尝试通过该字符串名称加载, 编译文件:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">do</span> $filename;<br></code></pre></td></tr></table></figure>
<p>内置的 <code>require</code> 同样也可用于加载模块:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">require</span> List::Util;<br></code></pre></td></tr></table></figure>
<p><code>use</code> 语句实际上是一个 BEGIN 块中 <code>require</code> 语句和调用类导入的内容:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">BEGIN &#123;<br>    <span class="hljs-keyword">require</span> List::Util;<br>    List::Util-&gt;import(...);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>判断某个条件错误时执行某个操作使用 <code>unless</code> 比较合适.</p>
<p>从外部文件或 STDIN 获取输入时, 最好用 <code>chomp</code> 去除换行符.</p>
<h1 id="第4章-引用简介"><a href="#第4章-引用简介" class="headerlink" title="第4章 引用简介"></a>第4章 引用简介</h1><h2 id="4-1-在多个数组上完成相同的任务"><a href="#4-1-在多个数组上完成相同的任务" class="headerlink" title="4.1 在多个数组上完成相同的任务"></a>4.1 在多个数组上完成相同的任务</h2><p>Perl 的参数列表是 <code>@_</code> 数组. 传递参数同样通过括号.</p>
<h2 id="PeGS-Perl-图形结构"><a href="#PeGS-Perl-图形结构" class="headerlink" title="PeGS: Perl 图形结构"></a>PeGS: Perl 图形结构</h2><p>PeGS (Perl Graphical Structure). 是 Perl 数据结构的图形表示方式.</p>
<p>大多数 PeGS 图由两部分组成: 变量名称和该变量引用的数据.</p>
<h2 id="4-3-对数组取引用"><a href="#4-3-对数组取引用" class="headerlink" title="4.3 对数组取引用"></a>4.3 对数组取引用</h2><p>反斜线 <code>\</code> 用于 “取引用” 操作.</p>
<p>如, 放在数组名称之前 <code>\@skipper</code> 就得到该数组的引用. 和 C 中的指针有些区别, 引用指向整个数组, 而不是数组本身的第一个元素的地址.</p>
<p>引用能够作为数组或者散列的元素, 也能直接放入普通标量变量中:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $ref_to_skipper = \@skipper;<br></code></pre></td></tr></table></figure>

<p>引用同样是指向地址, 引用的数值形式是 <code>@skipper</code> 数组在内部数据结构中唯一的内存地址, 该地址在数据的生存在周期内部都不会改变.</p>
<p>若是直接向子例程传递参数, 实际上是将参数都复制了一遍, 而使用引用则避免了这里的消耗.</p>
<h2 id="4-4-对数组引用进行解引用操作"><a href="#4-4-对数组引用进行解引用操作" class="headerlink" title="4.4 对数组引用进行解引用操作"></a>4.4 对数组引用进行解引用操作</h2><p>解引用实际上就是取地址上的值.</p>
<p>可以将数组的任意引用放入大括号中, 用于替换数组名称, 最后以i一个访问原始数组的方法作为结束 (也就是用大括号 “{}” 来解引用):</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">@skipper<br>@&#123; $items &#125;<br></code></pre></td></tr></table></figure>
<p>以下两种方法都指向数组的第二个元素:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">$skipper[<span class="hljs-number">1</span>]<br>$&#123; $items &#125;[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h2 id="4-5-去除大括号"><a href="#4-5-去除大括号" class="headerlink" title="4.5 去除大括号"></a>4.5 去除大括号</h2><p>如果只是一个简单的标量值, 那么也可删除第一组大括号.</p>
<p>见书.</p>
<h2 id="4-6-修改数组"><a href="#4-6-修改数组" class="headerlink" title="4.6 修改数组"></a>4.6 修改数组</h2><p>修改解引用的数组就是修改原始数组.</p>
<h2 id="4-7-嵌套的数据结构"><a href="#4-7-嵌套的数据结构" class="headerlink" title="4.7 嵌套的数据结构"></a>4.7 嵌套的数据结构</h2><h2 id="4-8-用箭头简化嵌套元素的引用"><a href="#4-8-用箭头简化嵌套元素的引用" class="headerlink" title="4.8 用箭头简化嵌套元素的引用"></a>4.8 用箭头简化嵌套元素的引用</h2><p>在编写 <code>$&#123;DUMMY&#125;[$y]</code> 的任何地方, 都可以使用 <code>DUMMY-&gt;[$y]</code> 这种方式代替.(引用位于箭头之前)</p>
<p>通过在表达式后面用一个箭头和一个带方括号的下标定义数组引用, 就可以选取数组中一个特定的元素.</p>
<p>如:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$all_with_names[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<p>另一条规则: 如果箭头位于 “下标类的符号” 之间, 也可以删除这些箭头:</p>
<p>例如(含义为, 先解引用 all_with_names 这个数组的第三个元素, 再…):</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$all_with_names[<span class="hljs-number">2</span>]-&gt;[<span class="hljs-number">1</span>]-&gt;[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>
<p>可以表达为:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$all_tith_names[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>

<p>基本上是有几个 <code>[]</code> 就是几重数组.</p>
<h2 id="4-9-散列的引用"><a href="#4-9-散列的引用" class="headerlink" title="4.9 散列的引用"></a>4.9 散列的引用</h2><p>同样使用 <code>\</code> 反斜线作为 “取引用” 操作符.</p>
<p>同样有大括号, 箭头形式.</p>
<p>对于数组切片或散列切片, 没有带箭头 (-&gt;) 的快捷方式.</p>
<p>如:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> $crewmember (@crew) &#123;<br>    <span class="hljs-keyword">printf</span> $format, @$crewmember&#123;<span class="hljs-string">qw(name shirt hat position)</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-10-检查引用类型"><a href="#4-10-检查引用类型" class="headerlink" title="4.10 检查引用类型"></a>4.10 检查引用类型</h2><p>开始使用和传递引用时, 必须确保知道正在使用哪种类型的引用.</p>
<p>最简单的方式是使用 <code>ref</code> 函数.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Carp <span class="hljs-string">qw(croak)</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">show_hash</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $hash_ref = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">my</span> $ref_type = <span class="hljs-keyword">ref</span> $hash_ref;<br>    croak <span class="hljs-string">&quot;I expected a hash reference!&quot;</span>;<br>        <span class="hljs-keyword">unless</span> $ref_type eq <span class="hljs-string">&#x27;HASH&#x27;</span>;<br><br>        <span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> $key ( %$hash_ref ) &#123;<br>            ...<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ref</code> 的返回值是类型名, 如 <code>HASH</code>.</p>
<p>constant 变量感觉类似于 C 中的宏定义:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> constant <span class="hljs-string">HASH =&gt;</span> <span class="hljs-keyword">ref</span> &#123;&#125;    <br><br>croak <span class="hljs-string">&quot;I expected a hash reference!&quot;</span><br>    <span class="hljs-keyword">unless</span> d<br></code></pre></td></tr></table></figure>

<p>Scalar::Util 模块中的 <code>reftype</code> 函数也能完成 <code>ref</code> 函数的任务.</p>
<p>可以使用 eval 检查:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">croak <span class="hljs-string">&quot;I expected a hash reference !&quot;</span><br>    <span class="hljs-keyword">unless</span> <span class="hljs-keyword">eval</span> &#123; <span class="hljs-keyword">keys</span> %$ref_type; <span class="hljs-number">1</span> &#125;<br></code></pre></td></tr></table></figure>

<h1 id="第5章-引用和作用域"><a href="#第5章-引用和作用域" class="headerlink" title="第5章 引用和作用域"></a>第5章 引用和作用域</h1><p>能够像标量一样复制并且传递引用.</p>
<h2 id="5-1-关于数据引用的更多信息"><a href="#5-1-关于数据引用的更多信息" class="headerlink" title="5.1 关于数据引用的更多信息"></a>5.1 关于数据引用的更多信息</h2><p>Perl 通过一个叫做 “引用计数” 的机制追踪有多少中访问数据的方法.</p>
<p>有了初始名称, 引用计数就为 1.</p>
<p>可以随意添加和删除引用, 并且只要引用计数没有减少到 0. Perl 就将在内存中保存该数组.</p>
<p>销毁引用, 可以把 undef 赋给该变量:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$ref_to_skipper = <span class="hljs-keyword">undef</span>;<br></code></pre></td></tr></table></figure>

<p>特殊情况下, 保存在子例程的私有 (词法) 变量中的引用, 将会在子例程的结尾销毁.</p>
<p>仅当所有引用销毁时, Perl 才会回收数组占用的内存.</p>
<h2 id="5-2-如果它曾是变量名将会怎样"><a href="#5-2-如果它曾是变量名将会怎样" class="headerlink" title="5.2 如果它曾是变量名将会怎样"></a>5.2 如果它曾是变量名将会怎样</h2><h2 id="5-3-引用计数和嵌套数据结构"><a href="#5-3-引用计数和嵌套数据结构" class="headerlink" title="5.3 引用计数和嵌套数据结构"></a>5.3 引用计数和嵌套数据结构</h2><p>删除数据树顶端的节点通常就意味着删除该数据树包含的所有数据.</p>
<p>Perl 会保证, 如果我们仍然拥有一个指向数据的引用, 就将仍然拥有该数据.</p>
<h2 id="5-4-当引用计数出现问题时"><a href="#5-4-当引用计数出现问题时" class="headerlink" title="5.4 当引用计数出现问题时"></a>5.4 当引用计数出现问题时</h2><p>当数据结构中的一部分以循环的方式指向数据结构的其他部分时, 就会出现问题.</p>
<h2 id="5-5-直接创建匿名数组"><a href="#5-5-直接创建匿名数组" class="headerlink" title="5.5 直接创建匿名数组"></a>5.5 直接创建匿名数组</h2><p>使用方括号:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $ref_to_skipper_provisions = <br>    [ <span class="hljs-string">qw(blue_shirt hat jacket preserver sunscreen)</span> ];<br></code></pre></td></tr></table></figure>
<p>取方括号内的值 (在列表上下文中求值), 为这些元素创建一个新的匿名数组, 并且返回该数组的引用.</p>
<p>使用方括号匿名数组构造函数得到的结果是一个数组引用, 该引用适用于标量变量适用的所有场合.</p>
<p>创建更大的列表:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $ref_to_skipper_provisions = <br>    [ <span class="hljs-string">qw(blue_shirt hat jacket preserver sunscreen)</span> ];<br>    <span class="hljs-keyword">my</span> @skipper_with_name = (<span class="hljs-string">&#x27;The Skipper&#x27;</span>, $ref_to_skipper_provisions);<br></code></pre></td></tr></table></figure>

<p>使用匿名数组的好处在于不用记忆中间名称.</p>
<p>可以用空的匿名数组构造器函数表示空的匿名数组引用.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">[<span class="hljs-string">&#x27;Mrs. Howell&#x27;</span>, <br>  [  ]<br>],<br></code></pre></td></tr></table></figure>
<h2 id="5-6-创建匿名散列"><a href="#5-6-创建匿名散列" class="headerlink" title="5.6 创建匿名散列"></a>5.6 创建匿名散列</h2><p>大括号 <code>&#123;&#125;</code> 是匿名散列构造函数.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $ref_to_gilligan_info = &#123;<br>    <span class="hljs-string">name     =&gt;</span> <span class="hljs-string">&#x27;Gilligan&#x27;</span>,<br>    <span class="hljs-string">hat      =&gt;</span> <span class="hljs-string">&#x27;White&#x27;</span>,<br>    <span class="hljs-string">shirt    =&gt;</span> <span class="hljs-string">&#x27;Red&#x27;</span>,<br>    <span class="hljs-string">position =&gt;</span> <span class="hljs-string">&#x27;First Mate&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意, 当列表末尾的元素并非紧跟着右花括号, 方括号或小括号时, 可以以逗号结尾.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @crew = (<br>    &#123;<br>        <span class="hljs-string">name       =&gt;</span> <span class="hljs-string">&#x27;Gilligan&#x27;</span>,<br>        <span class="hljs-string">hat        =&gt;</span> <span class="hljs-string">&#x27;Gilligan&#x27;</span>,<br>        <span class="hljs-string">shirt      =&gt;</span> <span class="hljs-string">&#x27;Gilligan&#x27;</span>,<br>        <span class="hljs-string">position   =&gt;</span> <span class="hljs-string">&#x27;Gilligan&#x27;</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">name       =&gt;</span> <span class="hljs-string">&#x27;Skipper&#x27;</span>,<br>        <span class="hljs-string">hat        =&gt;</span> <span class="hljs-string">&#x27;Black&#x27;</span>,<br>        <span class="hljs-string">shirt      =&gt;</span> <span class="hljs-string">&#x27;Blue&#x27;</span>,<br>        <span class="hljs-string">position   =&gt;</span> <span class="hljs-string">&#x27;Captain&#x27;</span>,<br>    &#125;,<br>        )<br></code></pre></td></tr></table></figure>

<p>向编译器说明我们想要一个匿名散列构造函数, 就在左大括号之前放置一个加号:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">+&#123;...&#125;<br></code></pre></td></tr></table></figure>
<p>如果想得到一个代码块, 就在语句块开始处放置一个分号:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;; ...&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-7-自动带入"><a href="#5-7-自动带入" class="headerlink" title="5.7 自动带入"></a>5.7 自动带入</h2><h2 id="5-8-自动带入和散列"><a href="#5-8-自动带入和散列" class="headerlink" title="5.8 自动带入和散列"></a>5.8 自动带入和散列</h2><p>自动带入的一个便捷之处在于典型的数据压缩任务.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> %total_bytes;<br><span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>    <span class="hljs-keyword">my</span> ($source, $destination, $bytes) = <span class="hljs-keyword">split</span>;<br>    $total_bytes&#123;$source&#125;&#123;$destination&#125; += $bytes;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此处两个大括号间有隐式的箭头.</p>
<h1 id="第6章-操作复杂的数据结构"><a href="#第6章-操作复杂的数据结构" class="headerlink" title="第6章 操作复杂的数据结构"></a>第6章 操作复杂的数据结构</h1><h2 id="6-1-使用调试器查看复杂的数据"><a href="#6-1-使用调试器查看复杂的数据" class="headerlink" title="6.1 使用调试器查看复杂的数据"></a>6.1 使用调试器查看复杂的数据</h2><p>最简单的一种是在命令行条件下调用 perl 并带上 <code>-d</code> 参数.</p>
<p>每个新发布的调试器都与之前发布的调试器在工作方式上略有不同.</p>
<p>有任何问题都可以通过输入 <code>h</code> 或者查看 <code>perldebug</code> 文档.</p>
<p>调试器会在执行前显示每一行正在调试的代码.</p>
<p><code>s</code> 命令将单步执行程序.</p>
<p><code>x</code> 命令显示存储在列表中的所有值.</p>
<h2 id="6-2-使用-Data-Dumper-模块查看复杂的数据"><a href="#6-2-使用-Data-Dumper-模块查看复杂的数据" class="headerlink" title="6.2 使用 Data::Dumper 模块查看复杂的数据"></a>6.2 使用 Data::Dumper 模块查看复杂的数据</h2><p>Data::Dumper 将 Perl 的数据结构显示为 Perl 代码.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Data::Dumper;<br><br><span class="hljs-keyword">my</span> %total_bytes;<br><span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>    <span class="hljs-keyword">my</span> ($source, $destination, $bytes) = <span class="hljs-keyword">split</span>;<br>    $total_bytes&#123;$source&#125;&#123;$destination&#125; += $bytes;<br>&#125;<br><br><span class="hljs-keyword">print</span> Dumper(\%total_bytes);<br></code></pre></td></tr></table></figure>
<p>Data::Dumper 模块定义的 Dumper 子例程类似与调试器中的 <code>x</code> 命令. 其与 <code>x</code> 命令的区别在于, Dumper 生成的字符串是 Perl 代码.</p>
<h3 id="其他形式的转储程序"><a href="#其他形式的转储程序" class="headerlink" title="其他形式的转储程序"></a>其他形式的转储程序</h3><p>Data::Dump 模块有一个叫做 dump 的子例程, 与 Data::Dumper 模块的用法一致.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Data::Dump <span class="hljs-string">qw(dump)</span>;<br><span class="hljs-keyword">dump</span>( \%total_bytes );<br></code></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Data::Printer;<br>p( %total_bytes );<br></code></pre></td></tr></table></figure>

<p>Data::Printer 模块的 p 子例程不需要一个引用作为参数:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Data::Printer;<br><br>p( %total_bytes );<br></code></pre></td></tr></table></figure>

<h2 id="6-3-数据编组"><a href="#6-3-数据编组" class="headerlink" title="6.3 数据编组"></a>6.3 数据编组</h2><p>能够将 Data::Dumper 模块 Dumper 子进程的输出放入一个文件中, 然后另一个程序加载该文件.</p>
<h3 id="6-3-1-使用-Storable-模块对复杂数据排序"><a href="#6-3-1-使用-Storable-模块对复杂数据排序" class="headerlink" title="6.3.1 使用 Storable 模块对复杂数据排序"></a>6.3.1 使用 Storable 模块对复杂数据排序</h3><p>编组数据: 将复杂数据转换成一种能够作为字节流写入文件的一种形式.</p>
<p>Perl 的 Storable 模块更适合编组数据.</p>
<p>Storable 生成更短小并且易于处理的文件.</p>
<p>freeze 子例程返回一个二进制字符串, 该字符串用于表述所需要输出的数据结构:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Storable;<br><span class="hljs-keyword">my</span> @data1 = <span class="hljs-string">qw(one won)</span>;<br><span class="hljs-keyword">my</span> @data2 = <span class="hljs-string">qw(two too to)</span>;<br><span class="hljs-keyword">push</span> @data2, \@data1;<br><span class="hljs-keyword">push</span> @data1, \@data2;<br><span class="hljs-keyword">my</span> $frozen = freeze [\@data1, \@data2];<br></code></pre></td></tr></table></figure>

<h3 id="6-3-2-YAML-模块"><a href="#6-3-2-YAML-模块" class="headerlink" title="6.3.2 YAML 模块"></a>6.3.2 YAML 模块</h3><p>YAML (Yet Another Mark Language).</p>
<p>YAML 模块的工作方式与 Data::Dumper 模块相同.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl"> <span class="hljs-keyword">use</span> YAML;<br><br> <span class="hljs-keyword">my</span> %total_bytes;<br><br> <span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>     <span class="hljs-keyword">my</span> ($source, $destination, $bytes) = <span class="hljs-keyword">split</span>;<br>     $total_bytes&#123;$source&#125;&#123;$destination&#125; += $bytes;<br>&#125;<br><br><span class="hljs-keyword">print</span> Dump(\%total_bytes);<br></code></pre></td></tr></table></figure>

<h3 id="6-3-3-JSON-模块"><a href="#6-3-3-JSON-模块" class="headerlink" title="6.3.3 JSON 模块"></a>6.3.3 JSON 模块</h3><p>JSON (JavaScript Object Notation).</p>
<p>JSON 模块有很多中创建输出的方法, 其中就包括 <code>to_json</code>:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> JSON;<br><br><span class="hljs-keyword">print</span> to_json( \%total_bytes, &#123; <span class="hljs-string">pretty =&gt;</span> <span class="hljs-number">1</span> &#125; );<br></code></pre></td></tr></table></figure>
<p>这里的 <code>&#123; pretty =&gt; 1 &#125;</code> 是使用属性.</p>
<p>可以从一个文件, Web 请求或者来自其他程序的输出获取 JSON 文本:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> JSON;<br><br><span class="hljs-keyword">my</span> $hash_ref = from_json($json_string);<br></code></pre></td></tr></table></figure>

<h2 id="6-4-使用-map-和-grep-操作符"><a href="#6-4-使用-map-和-grep-操作符" class="headerlink" title="6.4 使用 map 和 grep 操作符"></a>6.4 使用 map 和 grep 操作符</h2><h2 id="6-5-应用一点间接方法"><a href="#6-5-应用一点间接方法" class="headerlink" title="6.5 应用一点间接方法"></a>6.5 应用一点间接方法</h2><h1 id="第7章-对子例程的引用"><a href="#第7章-对子例程的引用" class="headerlink" title="第7章 对子例程的引用"></a>第7章 对子例程的引用</h1><p>除了对标量, 数组和散列的引用, 也可以对一个子例程进行引用.k</p>
<h2 id="7-1-对命名子例程的引用"><a href="#7-1-对命名子例程的引用" class="headerlink" title="7.1 对命名子例程的引用"></a>7.1 对命名子例程的引用</h2><p>对子例程 <code>skipper_greets()</code> 取引用, 前导字符 “&amp;” 在这里是必须的, 但删除了其后的小括号.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $ref_to_greeter = \&amp;skipper_greets;<br></code></pre></td></tr></table></figure>
<p>解引用同样是加大括号:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&amp;&#123; $ref_to_greeter &#125;( <span class="hljs-string">&#x27;Gilligan&#x27;</span> )<br></code></pre></td></tr></table></figure>
<p>同样, 如果大括号里的值是简单的标量变量, 大括号可以删除:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&amp; $ref_to_greeter( <span class="hljs-string">&#x27;Gilligan&#x27;</span> )<br></code></pre></td></tr></table></figure>
<p>也可以转换成带箭头的形式:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$ref_to_greeter -&gt; ( <span class="hljs-string">&#x27;Gilligan&#x27;</span> )<br></code></pre></td></tr></table></figure>
<p>迭代调用所有子例程:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> %greet (\&amp;skipper_greets, \&amp;gilligan_greets) &#123;<br>    $greet-&gt;(<span class="hljs-string">&#x27;Professor&#x27;</span>);<br>&#125;    <br></code></pre></td></tr></table></figure>
<p>也就是说, 用子例程的引用的一个好处就是, 当子例程调用的参数相同时, 可以利用控制结构简化操作.</p>
<h2 id="7-2-匿名子例程"><a href="#7-2-匿名子例程" class="headerlink" title="7.2 匿名子例程"></a>7.2 匿名子例程</h2><p>匿名子例程看上去像是普通子例程, 只是在 sub 关键字和紧随的代码块之间没有名字, 最后有一个分号, 毕竟是一个赋值语句, 其返回一个子例程的引用:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $ginger = <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $person = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Ginger: (in a sultry voice) Well hello, $person!\n&quot;</span>;<br>&#125;;<br>$ginger-&gt;(<span class="hljs-string">&#x27;Skipper&#x27;</span>);<br></code></pre></td></tr></table></figure>
<h2 id="7-3-回调"><a href="#7-3-回调" class="headerlink" title="7.3 回调"></a>7.3 回调</h2><p>File::Find 模块导出的 find 子例程, 用来以可移植的方式遍历给定文件系统的层次结构. 传递给 find 子例程两个参数:  第一个是对子例程的引用. 该子例程会从给定的起始目录开始, 通过递归搜索的方法, 找到其下的每个文件或目录, 执行子例程引用下的操作, 第二个表示目录开始点的字符串:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Find;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">what_to_do</span> </span>&#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$File::Find::name found\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">my</span> @starting_directories = <span class="hljs-string">qw(.)</span>;<br><br>find(\&amp;what_to_do, @starting_directories);<br></code></pre></td></tr></table></figure>
<p>改用匿名子例程的方式:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Find;<br><br>find(<br>    <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123;<br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$File::Find:name found\n&quot;</span>;<br>    &#125;,<br>    @starting_directories,<br>);<br></code></pre></td></tr></table></figure>
<h2 id="7-4-闭包"><a href="#7-4-闭包" class="headerlink" title="7.4 闭包"></a>7.4 闭包</h2><p>还可以用 File::Find 来查找文件的一些其他属性.</p>
<p><code>$_</code> 中保存的是文件名, 而 <code>File::Find::name</code> 中保存的是相对于起始路径的文件名. 如, 若起始目录为 <code>/usr</code>, 查找的文件为 <code>/usr/bin/perl</code>, 那么 <code>$_</code> 中的值为 <code>perl</code> 而 <code>$File::Find::name</code> 的值为 <code>/bin/perl</code>.</p>
<p>能够访问声明时就存在的所有词法变量的子例程叫做闭包. (也就是说变量是在子例程外面声明的).</p>
<p>从闭包内部访问变量能够确保只要子例程引用存在, 访问的变量就存在.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Find;<br><br><span class="hljs-keyword">my</span> $callback;<br>&#123;<br>    <span class="hljs-keyword">my</span> $count = <span class="hljs-number">0</span>;<br>    $callback = <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">print</span> ++$count, <span class="hljs-string">&quot;: $File::Find::name\n&quot;</span> &#125;;<br>&#125;<br>find($callback, <span class="hljs-string">&#x27;.&#x27;</span>);<br></code></pre></td></tr></table></figure>

<h2 id="7-5-从一个子例程返回另一个子例程"><a href="#7-5-从一个子例程返回另一个子例程" class="headerlink" title="7.5 从一个子例程返回另一个子例程"></a>7.5 从一个子例程返回另一个子例程</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Find;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">create_find_callback_that_counts</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">print</span> ++$count, <span class="hljs-string">&quot;: $File::Find::name\n&quot;</span> &#125;;<br>&#125;<br><br><span class="hljs-keyword">my</span> $callback = create_find_callback_that_counts();<br>find($callback, <span class="hljs-string">&#x27;.&#x27;</span>);<br></code></pre></td></tr></table></figure>

<h2 id="7-6-作为输入参数的闭包变量"><a href="#7-6-作为输入参数的闭包变量" class="headerlink" title="7.6 作为输入参数的闭包变量"></a>7.6 作为输入参数的闭包变量</h2><p>闭包变量也同样可以用于为子例程提供初始变量或者持续输入.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Find;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">print_bigger_than</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $minimum_size = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$File::Find::name\n&quot;</span> <span class="hljs-keyword">if</span> -f <span class="hljs-keyword">and</span> -s &gt;= $minimum_size &#125;;<br>&#125;<br><br><span class="hljs-keyword">my</span> $bigger_than_1024 = print_bigger_than(<span class="hljs-number">1024</span>);<br>find($bigger_than_1024, <span class="hljs-string">&#x27;bin&#x27;</span>);<br></code></pre></td></tr></table></figure>
<h2 id="7-7-闭包变量作为静态局部变量"><a href="#7-7-闭包变量作为静态局部变量" class="headerlink" title="7.7 闭包变量作为静态局部变量"></a>7.7 闭包变量作为静态局部变量</h2><p>命名子例程也可以是闭包.</p>
<p>如:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br><span class="hljs-keyword">my</span> $count;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">count_one</span> </span>&#123; ++$count &#125;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">count_so_fat</span> </span>&#123; <span class="hljs-keyword">return</span> $count &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>子例程在作用域外仍将保持. 也就是说, 上面虽然是在一个代码块中, 外面的程序仍然能够使用这两个子例程.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br><span class="hljs-keyword">my</span> $countdown = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">count_down</span> </span>&#123; $countdown-- &#125;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">count_remaining</span> </span>&#123; $countdown &#125;<br>&#125;<br><br>count_down();<br>count_down();<br>count_down();<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;we&#x27;re down to &quot;</span>, count_remaining(), <span class="hljs-string">&quot; coconuts!\n&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>实测加上 BEGIN 结果也是一样的?</p>
<h3 id="state-变量"><a href="#state-变量" class="headerlink" title="state 变量"></a>state 变量</h3><p>Perl v5.10 版开始为子例程引入了另一种方法生成私有的, 持续的变量. (也就是说重复调用子例程时值不会丢失)</p>
<p>可以使用 <code>state</code> 语句在子例程内部声明变量.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">countdown</span> </span>&#123;<br>    <span class="hljs-keyword">state</span> $countdown = <span class="hljs-number">10</span>;<br>    $countdown--;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>state</code> 变量有一个限制, 仅能使用 state 语句初始化标量变量. 能够使用 state 语句声明任何类型的变量, 但是不能初始化它们.</p>
<h2 id="7-8-查询我们自己的身份"><a href="#7-8-查询我们自己的身份" class="headerlink" title="7.8 查询我们自己的身份"></a>7.8 查询我们自己的身份</h2><p>Perl v5.16 版引入 <code>__SUB__</code> 标记 (token), 返回一个指向当前子例程的引用.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $sub = <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123;<br>    <span class="hljs-keyword">state</span> $n = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">unless</span> $n &gt; -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">say</span> $n--;<br>    __SUB_<span class="hljs-number">_</span>-&gt;();<br>&#125;<br>$sub-&gt;();<br></code></pre></td></tr></table></figure>

<h3 id="7-8-1-令人着迷的子例程"><a href="#7-8-1-令人着迷的子例程" class="headerlink" title="7.8.1 令人着迷的子例程"></a>7.8.1 令人着迷的子例程</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @arry = ( \ <span class="hljs-string">&#x27;xyz&#x27;</span>, [<span class="hljs-string">qw(a b c)</span>], <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Buster&#x27;</span> &#125; );<br><br><span class="hljs-keyword">foreach</span> ( @array ) &#123;<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">ref</span> eq <span class="hljs-keyword">ref</span> \ <span class="hljs-string">&#x27;&#x27;</span>   ) &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&quot;Scalar $$_&quot;</span> &#125;<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">ref</span> eq <span class="hljs-keyword">ref</span> []     ) &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&quot;Array @$_&quot;</span> &#125;<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">ref</span> eq <span class="hljs-keyword">ref</span> <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123;&#125; ) &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&quot;Sub ???&quot;</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里每一个 <code>when</code> 中的第一个 <code>ref</code> 实际上是 <code>ref $_</code>.</p>
<h3 id="7-8-2-转储闭包"><a href="#7-8-2-转储闭包" class="headerlink" title="7.8.2 转储闭包"></a>7.8.2 转储闭包</h3><p>Data::Dump::Streamer 模块是增强版的 Data::Dumper 模块.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Data::Dump::Streamer;<br><br><span class="hljs-keyword">my</span> @luxuries = <span class="hljs-string">qw(Diamonds Furs Caviar)</span>;<br><br><span class="hljs-keyword">my</span> $hash = &#123;<br>    <span class="hljs-string">Gilligan           =&gt;</span> <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Howdy Skipper!&#x27;</span>     &#125;,<br>    <span class="hljs-string">Skipper            =&gt;</span> <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Gilligan!!!!&#x27;</span>       &#125;,<br>    <span class="hljs-string">&#x27;Mr. Howell&#x27;</span>       =&gt; <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Money money money!&#x27;</span> &#125;,<br>    <span class="hljs-string">Ginger             =&gt;</span> <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">say</span> $luxuries[<span class="hljs-keyword">rand</span> @luxuries] &#125;,<br>&#125;;<br><br>Dump $hash;<br></code></pre></td></tr></table></figure>

<h1 id="第8章-文件句柄引用"><a href="#第8章-文件句柄引用" class="headerlink" title="第8章 文件句柄引用"></a>第8章 文件句柄引用</h1><h2 id="8-1-旧方法"><a href="#8-1-旧方法" class="headerlink" title="8.1 旧方法"></a>8.1 旧方法</h2><h2 id="8-2-改进的方法"><a href="#8-2-改进的方法" class="headerlink" title="8.2 改进的方法"></a>8.2 改进的方法</h2><p>从 Perl v5.6 开始, <code>open</code> 命令能够以普通的标量变量形式创建一个文件句柄的引用, 前提是只要该标量变量的值未定义.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $log_fh;<br><span class="hljs-keyword">open</span> $log_fh, <span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;castaways.log&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Could not open castways.log: $!&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>同样, 在 <code>&lt;&gt;</code> 中:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">while</span> ( &lt;$log_fh&gt; ) &#123; ... &#125;<br></code></pre></td></tr></table></figure>
<h2 id="8-3-指向字符串的文件句柄"><a href="#8-3-指向字符串的文件句柄" class="headerlink" title="8.3 指向字符串的文件句柄"></a>8.3 指向字符串的文件句柄</h2><p>从 Perl v5.6 开始, 能够打开一个标量引用形式的文件句柄, 而不是一个文件, 该文件句柄要么从该字符串读取要么向该字符串写入.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $string_fh, <span class="hljs-string">&#x27;&gt;&#x27;</span>, \ <span class="hljs-keyword">my</span> $string;<br></code></pre></td></tr></table></figure>

<h3 id="逐行处理字符串"><a href="#逐行处理字符串" class="headerlink" title="逐行处理字符串"></a>逐行处理字符串</h3><h2 id="8-4-文件句柄集合"><a href="#8-4-文件句柄集合" class="headerlink" title="8.4 文件句柄集合"></a>8.4 文件句柄集合</h2><p>可以将文件句柄引用作为数组元素或者散列值存储.</p>
<p>当文件句柄超出其作用域时, 就会被自动关闭.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>    <span class="hljs-keyword">state</span> $fhs;<br><br>    <span class="hljs-keyword">my</span>($source, $destination, $bytes) = <span class="hljs-keyword">split</span>;<br><br>    <span class="hljs-keyword">unless</span> ( $fhs-&gt;&#123;$source&#125; ) &#123;<br>        <span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $fh, <span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, $source <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&#x27;...&#x27;</span>;<br>        $fhs-&gt;&#123;$source&#125; = $fh;<br>    &#125;<br><br>    <span class="hljs-keyword">say</span> &#123; $fhs-&gt;&#123;$source&#125; &#125; <span class="hljs-string">&quot;$destination $bytes&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="8-5-IO-Handle-模块和其他相应的模块"><a href="#8-5-IO-Handle-模块和其他相应的模块" class="headerlink" title="8.5 IO::Handle 模块和其他相应的模块"></a>8.5 IO::Handle 模块和其他相应的模块</h2><p>在幕后, Perl 实际上使用 IO::Handle 模块实现文件句柄操作.</p>
<p>文件句柄量实际上是 IO::Handle 模块的对象.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Handle;<br><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $fh, <span class="hljs-string">&#x27;&gt;&#x27;</span>, $filename <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&#x27;...&#x27;</span>;<br>$fh-&gt;<span class="hljs-keyword">print</span>( <span class="hljs-string">&#x27;Coconut headphones&#x27;</span> );<br>$fh-&gt;<span class="hljs-keyword">close</span>;<br></code></pre></td></tr></table></figure>
<p>自 Perl v5.14 之后, 不必显式加载 IO::Handle 模块.</p>
<p>IO::Handle 包对于输入, 输出操作而言是基础类, 因此它能够处理很多事情, 而不仅仅是文件.</p>
<h3 id="8-5-1-IO-File-模块"><a href="#8-5-1-IO-File-模块" class="headerlink" title="8.5.1 IO::File 模块"></a>8.5.1 IO::File 模块</h3><p>IO::File 模块是 IO::Handle 模块用于操作文件的子集, 该模块来自于 Perl 标准发行版.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $read_fh = IO::File-&gt;new( <span class="hljs-string">&#x27;castaways.log&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span> );<br><span class="hljs-keyword">my</span> $write_fh = IO::File-&gt;new( <span class="hljs-string">&#x27;castaways.log&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span> );<br></code></pre></td></tr></table></figure>
<p>其返回一个文件句柄.</p>
<p>打开匿名的临时文件:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $temp_fh = IO::File-&gt;new_tmpfile;<br></code></pre></td></tr></table></figure>

<p>可以显式调用 <code>close</code> 或 <code>undef</code> 命令操作文件句柄:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$temp_fh-&gt;<span class="hljs-keyword">close</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Could not close file: $!&quot;</span>;<br><br><span class="hljs-keyword">undef</span> $append_fh;<br></code></pre></td></tr></table></figure>

<p>如果将 <code>undef</code> 作为文件名, Perl v5.6 及后续版本能够打开一个匿名, 临时的文件:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $fh, <span class="hljs-string">&#x27;+&gt;&#x27;</span>, <span class="hljs-keyword">undef</span><br>  <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Could not open temp file: $!&quot;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="8-5-2-IO-Scalar-模块"><a href="#8-5-2-IO-Scalar-模块" class="headerlink" title="8.5.2 IO::Scalar 模块"></a>8.5.2 IO::Scalar 模块</h3><p>若 Perl 的版本不能创建标量引用形式的文件句柄. 就可以使用 IO::Scalar 模块. 该模块不是 Perl 标准发行版的模块.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Scalar;<br><br><span class="hljs-keyword">my</span> $string_log = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">my</span> $scalar_fh = IO::Scalar-&gt;new( \$string_log );<br><br><span class="hljs-keyword">print</span> $scalar_fh <span class="hljs-string">&quot;The Howells&#x27;s private beach club is closed\n&quot;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="8-5-3-IO-Tee-模块"><a href="#8-5-3-IO-Tee-模块" class="headerlink" title="8.5.3 IO::Tee 模块"></a>8.5.3 IO::Tee 模块</h3><p>其不是自带的模块.</p>
<p>将内容同时输出到多个地方, 使用 IO::Tea 模块.</p>
<p>当输出到达 IO::Tee 模块时, 它就能够同时流向两个 (甚至多个) 不同的管道.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Tee;<br><br><span class="hljs-keyword">my</span> $tee_fh = IO::Tee-&gt;new( $log_fh, $scalar_fh );<br><br><span class="hljs-keyword">print</span> $tee_fh <span class="hljs-string">&quot;The radio works in the middle of the ocean!\n&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>如果 IO::Tee 模块的第一个参数是 (随后的参数必须是输出文件句柄).</p>
<p>当 IO::Tee 模块从输入句柄读取一行数据时, 他就立即将该数据写入输出文件句柄.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Tee;<br><br><span class="hljs-keyword">my</span> $tee_fh = IO::Tee-&gt;new( $read_fh, $log_fh, $scalar_fh );<br><br><span class="hljs-keyword">my</span> $message = &lt;$tee_fh&gt;;  <span class="hljs-comment"># 这一句就是从输入句柄读取一行到 $message 这个变量中</span><br></code></pre></td></tr></table></figure>
<p><code>$read_fh</code> 可能连接到一个套接字, 标量变量或者外部命令的输出. </p>
<h3 id="8-5-4-IO-Pipe-模块"><a href="#8-5-4-IO-Pipe-模块" class="headerlink" title="8.5.4 IO::Pipe 模块"></a>8.5.4 IO::Pipe 模块</h3><p>与 Shell 中的管道类似, 符号 <code>|</code> 之后的 <code>$command</code> 将会记录来自命令的输出, 然后通过管道传入程序. 具体见 learning perl.</p>
<p>使用 IO::Pipe 模块, 其自动处理 fork 命令和 exec 命令, 返回一个文件句柄, 可以从该文件句柄读取命令的输出:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Pipe;<br><br><span class="hljs-keyword">my</span> $pipe = IO::Pipe-&gt;new;<br><br>$pipe-&gt;reader( <span class="hljs-string">&quot;$^X -V&quot;</span> );  <span class="hljs-comment"># $^X is the current perl executable</span><br><br><span class="hljs-keyword">while</span> ( &lt;$pipe&gt; ) &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Read: $_&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>命令就写在 <code>reader()</code> 中.</p>
<p>写入:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Pipe;<br><br><span class="hljs-keyword">my</span> $pipe = IO::Pipe-&gt;new;<br><br>$pipe-&gt;writer( $command );<br><br><span class="hljs-keyword">foreach</span> ( <span class="hljs-number">1</span> .. <span class="hljs-number">10</span> ) &#123;<br>    <span class="hljs-keyword">print</span> $pipe <span class="hljs-string">&quot;I can count to $_\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="8-5-5-IO-Null-模块和-IO-Interactive-模块"><a href="#8-5-5-IO-Null-模块和-IO-Interactive-模块" class="headerlink" title="8.5.5 IO::Null 模块和 IO::Interactive 模块"></a>8.5.5 IO::Null 模块和 IO::Interactive 模块</h3><p>使用 IO::Null 模块创建一个文件句柄用于丢弃所提供的内容, 如 <code>/dev/null</code>.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Null;<br><br><span class="hljs-keyword">my</span> $null_fn = IO::Null-&gt;new;<br><br>some_printing_thing( $null_fn, @args );<br></code></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Null;<br><br><span class="hljs-keyword">my</span> $debug_fn = $Debug ? *STDOUT : IO::Null-&gt;new;<br><br>$debug_fn-&gt;<span class="hljs-keyword">print</span>( <span class="hljs-string">&quot;Hey, the radio&#x27;s not working&quot;</span> );<br></code></pre></td></tr></table></figure>

<h2 id="8-6-目录句柄"><a href="#8-6-目录句柄" class="headerlink" title="8.6 目录句柄"></a>8.6 目录句柄</h2><p>与创建文件句柄引用的方式一致:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">opendir</span> <span class="hljs-keyword">my</span> $dh, <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Could not open directory: $!&quot;</span>;<br><br><span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> $file ( <span class="hljs-keyword">readdir</span>( $dh ) ) &#123;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Skipper, I found $file!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="目录句柄引用"><a href="#目录句柄引用" class="headerlink" title="目录句柄引用"></a>目录句柄引用</h3><p>自 v5.6 起, IO::Dir 模块就成为 Perl 标准发行版的一部分.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Dir;<br><br><span class="hljs-keyword">my</span> $dir_fh = IO::Dir-&gt;new( <span class="hljs-string">&#x27;.&#x27;</span> )<br>    <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Could not open dirhandle! $!&quot;</span>;<br></code></pre></td></tr></table></figure>

<h1 id="第9章-正则表达式引用"><a href="#第9章-正则表达式引用" class="headerlink" title="第9章 正则表达式引用"></a>第9章 正则表达式引用</h1><h2 id="9-1-正则表达式引用之前"><a href="#9-1-正则表达式引用之前" class="headerlink" title="9.1 正则表达式引用之前"></a>9.1 正则表达式引用之前</h2><p>用 eval 语句在匹配时捕获可能发生的错误:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;Enter a pattern: &#x27;</span>;<br><span class="hljs-keyword">chomp</span>( <span class="hljs-keyword">my</span> $pattern = &lt;STDIN&gt; );<br><br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Enter some lines:\n&quot;</span>;<br><span class="hljs-keyword">while</span>(&lt;STDIN&gt;) &#123;<br>    <span class="hljs-keyword">if</span>( <span class="hljs-keyword">eval</span> &#123; <span class="hljs-regexp">m/$pattern/</span> &#125; ) &#123;<br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Match: $_&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>($@) &#123;<br>        <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;There was a regex problem: $@\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在尝试使用一个模式之前, 编写一个子例程测试该模式:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">is_valid_pattern</span> </span>&#123;<br>    <span class="hljs-keyword">my</span>( $pattern ) = @_;<br>    <span class="hljs-keyword">local</span>( $@ );<br><br>    <span class="hljs-keyword">eval</span> &#123; <span class="hljs-string">&#x27;&#x27;</span> =~ <span class="hljs-regexp">/$pattern/</span> &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">defined</span> $@ ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但这样仍然不太好.</p>
<h2 id="9-2-预编译模式"><a href="#9-2-预编译模式" class="headerlink" title="9.2 预编译模式"></a>9.2 预编译模式</h2><p>Perl v5.5 引入一个新的引用机制: <code>qr//</code> 操作符. 这里的预编译应该是说其产生的引用会在预编译时展开.</p>
<p><code>qr</code> 是 regex quote.</p>
<p>提供一个编译完成的正则表达式的引用:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $regex = <span class="hljs-regexp">qr/Gilligan|Skipper/</span>;<br><span class="hljs-keyword">print</span> $regex;<br></code></pre></td></tr></table></figure>
<p>在 perlop 文档中可查看 “引号和类引号操作符”.</p>
<p>分隔符可换 (<code>qr//</code>, 改为 <code>qr()</code> 之类的).</p>
<p>可以添加 options :</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$rex = <span class="hljs-regexp">qr/my.STRING/is</span>;<br></code></pre></td></tr></table></figure>
<h3 id="9-2-1-正则表达式选项"><a href="#9-2-1-正则表达式选项" class="headerlink" title="9.2.1 正则表达式选项"></a>9.2.1 正则表达式选项</h3><p>特殊序列 <code>(?flags:pattern)</code> 允许在模式本身中指定修饰符 (也就是说不把标志写在末尾, 而是在正则表达式之中):</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">qr/(?mi:Gilligan$)/;<br></code></pre></td></tr></table></figure>
<p>分组;</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">qr/abc(?i:Gilligan)def/;<br></code></pre></td></tr></table></figure>
<p>能够在标记之前添加一个 “-“, 从一部分模式中移除修饰符:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">qr/abc(?-i:Gilligan)def/i;<br></code></pre></td></tr></table></figure>
<p>同时添加和移除:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">qr/abc(?<span class="hljs-keyword">x</span>-i:G i l l i g a n)def/i;<br></code></pre></td></tr></table></figure>
<h3 id="9-2-2-应用正则表达式引用"><a href="#9-2-2-应用正则表达式引用" class="headerlink" title="9.2.2 应用正则表达式引用"></a>9.2.2 应用正则表达式引用</h3><p>直接插入:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $regex = <span class="hljs-regexp">qr/Gilligan/</span>;<br>$string =~ <span class="hljs-regexp">m/$regex/</span>;<br>$string =~ <span class="hljs-regexp">s/$regex/Skipper/</span>;<br></code></pre></td></tr></table></figure>
<p>直接绑定:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$string =~ $regex;<br></code></pre></td></tr></table></figure>
<p>智能匹配:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$string ~~ $regex;<br></code></pre></td></tr></table></figure>

<h2 id="9-3-作为标量的正则表达式"><a href="#9-3-作为标量的正则表达式" class="headerlink" title="9.3 作为标量的正则表达式"></a>9.3 作为标量的正则表达式</h2><p>可将其存储在数组和散列中, 作为参数传递给子例程.</p>
<p>使用 List::Util 模块中的 <code>first</code> 函数:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10.1</span>;<br><span class="hljs-keyword">use</span> List::Util <span class="hljs-string">qw(first)</span>;<br><br><span class="hljs-keyword">my</span> %patterns = (<br>    <span class="hljs-string">Gilligan   =&gt;</span> qr/(?:Willie )?Gilligan/,<br>    <span class="hljs-string">&#x27;Mary Ann&#x27;</span> =&gt; <span class="hljs-regexp">qr/Mary Ann/</span>,<br>    <span class="hljs-string">Ginger     =&gt;</span> qr/Ginger/,<br>    <span class="hljs-string">Professor  =&gt;</span> qr/(?:The )?Professor/,<br>    <span class="hljs-string">Skipper    =&gt;</span> qr/Skipper/,<br>    <span class="hljs-string">&#x27;A Howell&#x27;</span> =&gt; <span class="hljs-regexp">qr/Mrs?. Howell/</span>,<br>);<br><br><span class="hljs-keyword">my</span> $name = <span class="hljs-string">&#x27;Ginger&#x27;</span>;<br><br><span class="hljs-keyword">my</span>( $match ) = first &#123; $name =~ $pattern&#123;$_&#125; &#125; <span class="hljs-keyword">keys</span> %patterns;<br><br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;Matched $match&quot;</span> <span class="hljs-keyword">if</span> $match;<br></code></pre></td></tr></table></figure>
<h2 id="9-4-建立正则表达式"><a href="#9-4-建立正则表达式" class="headerlink" title="9.4 建立正则表达式"></a>9.4 建立正则表达式</h2><p>将模式插入其他模式之中:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $howells    = <span class="hljs-regexp">qr/Thurston|Mrs/</span>;<br><span class="hljs-keyword">my</span> $tagalongs  = <span class="hljs-regexp">qr/Ginger|Mary Ann/</span>;<br><span class="hljs-keyword">my</span> $passengers = <span class="hljs-regexp">qr/$howells|$tagalongs/</span>;<br><span class="hljs-keyword">my</span> $crew       = <span class="hljs-regexp">qr/Gilligan|Skipper/</span>;<br><br><span class="hljs-keyword">my</span> $everyone   = <span class="hljs-regexp">qr/$crew|$passengers/</span>;<br></code></pre></td></tr></table></figure>
<h2 id="9-5-创建正则表达式的模块"><a href="#9-5-创建正则表达式的模块" class="headerlink" title="9.5 创建正则表达式的模块"></a>9.5 创建正则表达式的模块</h2><h3 id="9-5-1-使用常见的模式"><a href="#9-5-1-使用常见的模式" class="headerlink" title="9.5.1 使用常见的模式"></a>9.5.1 使用常见的模式</h3><p>能够直接使用 Regexp::Common 模块提供的某个模式.</p>
<p>该模块导出一个叫做 <code>$RE</code> 的散列引用, 它以我们所需要的正则表达式引用作为其值:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10.1</span>;<br><span class="hljs-keyword">use</span> Regexp::Common <span class="hljs-string">qw(URI)</span>;<br><br><span class="hljs-keyword">while</span>( &lt;&gt; ) &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-keyword">if</span> /$RE<span class="hljs-string">&#123;URL&#125;</span><span class="hljs-string">&#123;HTTP&#125;</span>/;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>若查找 IPv4 地址, 能够使用该模块的 net 工具衍生出的一个模式:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10.1</span>;<br><span class="hljs-keyword">use</span> Regexp::Common <span class="hljs-string">qw(net)</span>;<br><br><span class="hljs-keyword">while</span>( &lt;&gt; ) &#123;<br>    <span class="hljs-keyword">say</span> <span class="hljs-keyword">if</span> /$RE<span class="hljs-string">&#123;net&#125;</span><span class="hljs-string">&#123;IPv4&#125;</span>/;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>匹配数字:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10.1</span>;<br><span class="hljs-keyword">use</span> Regexp::Common <span class="hljs-string">qw(number)</span>;<br><br><span class="hljs-keyword">while</span>( &lt;&gt; ) &#123;<br>    <span class="hljs-keyword">say</span> <span class="hljs-keyword">if</span> /$RE<span class="hljs-string">&#123;num&#125;</span><span class="hljs-string">&#123;int&#125;</span>/;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可查询 perltie 文档, 查看关于 <code>tie</code> 的信息.</p>
<p>具体看书.</p>
<h3 id="9-5-2-组装正则表达式"><a href="#9-5-2-组装正则表达式" class="headerlink" title="9.5.2 组装正则表达式"></a>9.5.2 组装正则表达式</h3><p>Regexp::Assemble 模块可用于建立高效的则一匹配.</p>
<h1 id="第10章-实用的引用技巧"><a href="#第10章-实用的引用技巧" class="headerlink" title="第10章 实用的引用技巧"></a>第10章 实用的引用技巧</h1><p>注意 sort 函数对数字的排序, 其会按照字符串的顺序进行排序. 如, 任何以 3 开头的字符串都放置于 4 开头的字符串之前.</p>
<p>升序:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @numerically_ascending = <span class="hljs-keyword">sort</span> &#123; $a &lt;=&gt; $b &#125; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">32</span>, <span class="hljs-number">16</span>;<br></code></pre></td></tr></table></figure>
<p>降序:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @numerically_descending = <br>    <span class="hljs-keyword">reverse</span> <span class="hljs-keyword">sort</span> &#123; $a &lt;=&gt; $b &#125; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>;<br></code></pre></td></tr></table></figure>
<h2 id="10-2-用索引排序"><a href="#10-2-用索引排序" class="headerlink" title="10.2 用索引排序"></a>10.2 用索引排序</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @input = <span class="hljs-string">qw(Gilligan Skipper Professor Ginger Mary Ann)</span>;<br><span class="hljs-keyword">my</span> @sorted_positions = <br>    <span class="hljs-keyword">sort</span> &#123; $input[$a] cmp $input[$b] &#125; <span class="hljs-number">0</span> .. $#input;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;@sorted_positions\n&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>也就是说利用索引排序 (<code>$a</code> 和 <code>$b</code> 的值为数组的索引), 结果仍然是按照 ASCII 的顺序.</p>
<p><code>$#input</code> 表示数组的最有一个索引.</p>
<h2 id="10-3-更为高效的排序"><a href="#10-3-更为高效的排序" class="headerlink" title="10.3 更为高效的排序"></a>10.3 更为高效的排序</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @names_and_pineapples = <span class="hljs-keyword">map</span> &#123;<br>  [ $_, ask_monkey_about($_) ] <br>&#125; @castways;<br><br><span class="hljs-keyword">my</span> @sorted_names_and_pineapples = <span class="hljs-keyword">sort</span> &#123;<br>  $b-&gt;[<span class="hljs-number">1</span>] &lt;=&gt; $a-&gt;[<span class="hljs-number">1</span>];<br>&#125; @sorted_names_and_pineapples;<br></code></pre></td></tr></table></figure>
<h2 id="10-4-施瓦茨变换"><a href="#10-4-施瓦茨变换" class="headerlink" title="10.4 施瓦茨变换"></a>10.4 施瓦茨变换</h2><p>如这种结构:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @names = <br>    <span class="hljs-keyword">map</span> $_-&gt;[<span class="hljs-number">0</span>],<br>    <span class="hljs-keyword">sort</span> &#123; $b-&gt;[<span class="hljs-number">1</span>] &lt;=&gt; $a-&gt;[<span class="hljs-number">1</span>] &#125;<br>    <span class="hljs-keyword">map</span> [ $_, ask_monkey_about($_) ],<br>    @castways;<br></code></pre></td></tr></table></figure>
<p>基本语法结构:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @output_data = <br>  <span class="hljs-keyword">map</span>  &#123; EXTRACTION &#125;,<br>  <span class="hljs-keyword">sort</span> &#123; COMPARISON &#125;<br>  <span class="hljs-keyword">map</span>  [ CONSTRUCTION ],<br>  @input_data;<br></code></pre></td></tr></table></figure>
<h2 id="10-5-使用施瓦茨变换实线多级排序"><a href="#10-5-使用施瓦茨变换实线多级排序" class="headerlink" title="10.5 使用施瓦茨变换实线多级排序"></a>10.5 使用施瓦茨变换实线多级排序</h2><h2 id="10-6-递归定义的数据"><a href="#10-6-递归定义的数据" class="headerlink" title="10.6 递归定义的数据"></a>10.6 递归定义的数据</h2><p>如:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">factorial</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $n = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">if</span> ($n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> $n * factorial($n -<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="10-7-构建递归定义的数据"><a href="#10-7-构建递归定义的数据" class="headerlink" title="10.7 构建递归定义的数据"></a>10.7 构建递归定义的数据</h2><p>如:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $skipper_home = &#123;<br>    <span class="hljs-string">&#x27;.cshrc&#x27;</span>                      =&gt; <span class="hljs-keyword">undef</span>,<br>    <span class="hljs-string">&#x27;Please_rescue_us.pdf&#x27;</span>        =&gt; <span class="hljs-keyword">undef</span>,<br>    <span class="hljs-string">&#x27;Things_I_should_have_packed&#x27;</span> =&gt; <span class="hljs-keyword">undef</span>,<br><br>    <span class="hljs-string">bin =&gt;</span> &#123;<br>        <span class="hljs-string">navigate                   =&gt;</span> <span class="hljs-keyword">undef</span>,<br>        <span class="hljs-string">discipline_gilligan        =&gt;</span> <span class="hljs-keyword">undef</span>,<br>        <span class="hljs-string">eat                        =&gt;</span> <span class="hljs-keyword">undef</span>,<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>获取数据并形成结构:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">data_for_path</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $path = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">if</span> (-f $path <span class="hljs-keyword">or</span> -l $path) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">undef</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (-d $path) &#123;<br>        <span class="hljs-keyword">my</span> %directory;<br>        <span class="hljs-keyword">opendir</span> PATH, $path <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Cannot opendir $path: $!&quot;</span>;<br>        <span class="hljs-keyword">my</span> @names = <span class="hljs-keyword">readdir</span> PATH;<br>        <span class="hljs-keyword">closedir</span> PATH;<br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> $name (@names) &#123;<br>            <span class="hljs-keyword">next</span> <span class="hljs-keyword">if</span> $name eq <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">or</span> $name eq <span class="hljs-string">&#x27;..&#x27;</span>;<br>            $directory&#123;$name&#125; = data_for_path(<span class="hljs-string">&quot;$path/$name&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> \%directory;<br>    &#125;<br>    <span class="hljs-keyword">warn</span> <span class="hljs-string">&quot;$path is neither a file nor a directory\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">undef</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>检查结果:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Data::Dumper;<br><span class="hljs-keyword">print</span> Dumper(data_for_path(<span class="hljs-string">&#x27;.&#x27;</span>));<br></code></pre></td></tr></table></figure>
<h2 id="10-8-显示递归定义的数据"><a href="#10-8-显示递归定义的数据" class="headerlink" title="10.8 显示递归定义的数据"></a>10.8 显示递归定义的数据</h2><h2 id="10-9-避免递归"><a href="#10-9-避免递归" class="headerlink" title="10.9 避免递归"></a>10.9 避免递归</h2><p>使用迭代解决问题.</p>
<h1 id="第11章-构建更大型的程序"><a href="#第11章-构建更大型的程序" class="headerlink" title="第11章 构建更大型的程序"></a>第11章 构建更大型的程序</h1><h2 id="11-1-修改通用代码"><a href="#11-1-修改通用代码" class="headerlink" title="11.1 修改通用代码"></a>11.1 修改通用代码</h2><p>大多数用 <code>shift</code> 来获取参数.</p>
<h2 id="11-2-使用-eval-插入代码"><a href="#11-2-使用-eval-插入代码" class="headerlink" title="11.2 使用 eval 插入代码"></a>11.2 使用 eval 插入代码</h2><p>将代码放入如 <code>Navigation.pm</code> 的独立文件中, 该文件由所需的多个子例程组成. (<code>.pm</code> 即 Perl Module)</p>
<p>用硬编码 (即直接将数据写到源代码中), 用 <code>eval</code> 的字符串形式 (可以理解为字符串被当作代码编译):</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">load_common_subroutines</span> </span>&#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $more_fh, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;Navigation.pm&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Navigation.pm: $!&quot;</span>;<br>    <span class="hljs-keyword">undef</span> $/;<br>    <span class="hljs-keyword">my</span> $more_code = &lt;$more_fh&gt;;<br>    <span class="hljs-keyword">close</span> $more_fh;<br>    <span class="hljs-keyword">eval</span> $more_fh;<br>    <span class="hljs-keyword">die</span> $@ <span class="hljs-keyword">if</span> $@;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="11-3-使用-do-语句"><a href="#11-3-使用-do-语句" class="headerlink" title="11.3 使用 do 语句"></a>11.3 使用 do 语句</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">do</span> <span class="hljs-string">&#x27;Navigation.pm&#x27;</span>;<br><span class="hljs-keyword">die</span> $@ <span class="hljs-keyword">if</span> $@;<br></code></pre></td></tr></table></figure>
<p><code>do</code> 操作符的功能就像是把 <code>Navigation.pm</code> 的代码合并进当前程序中, 尽管导入的变量还在它自己的作用域语句块中. (即里面是它自己的作用域, 如 <code>my</code> 和 <code>use</code> 不会和主程序冲突);</p>
<h2 id="11-4-使用-require-语句"><a href="#11-4-使用-require-语句" class="headerlink" title="11.4 使用 require 语句"></a>11.4 使用 require 语句</h2><p><code>require</code> 可以追踪哪些文件已经导入, 然后仅导入一次.</p>
<p>特性:</p>
<ul>
<li>导入文件中的任何语法错误都将终止程序, 所以不再需要很多 <code>die $@ if $@</code></li>
<li>文件中的最后一个求值表达式必须返回一个真值</li>
</ul>
<p>因此, 大多数用于 <code>require</code> 导入的文件中, 最后一行代码总有一个 <code>1</code> (来确保最后的求值表达式为真).</p>
<h2 id="11-5-命名空间冲突的问题"><a href="#11-5-命名空间冲突的问题" class="headerlink" title="11.5 命名空间冲突的问题"></a>11.5 命名空间冲突的问题</h2><h2 id="11-6-使用包作为命名空间分隔符"><a href="#11-6-使用包作为命名空间分隔符" class="headerlink" title="11.6 使用包作为命名空间分隔符"></a>11.6 使用包作为命名空间分隔符</h2><p>用 <code>package</code> 命令. (用在模块中, 而不是你要调用模块的文件)</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> Navigation;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">turn_toward_heading</span> </span>&#123;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">turn_toward_port</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实际上是在这个模块中, 给大多数 (变量) 名称之前插入 <code>Navigation::</code> 前缀. 这样用 <code>require</code> 导入就可以避免命名冲突.</p>
<p>包名应当以一个大写字母开头.</p>
<p>包名也可以为由双冒号分割的多个名称, 如 <code>Minnow::Navigation</code>.</p>
<h2 id="11-7-Package-指令的作用域"><a href="#11-7-Package-指令的作用域" class="headerlink" title="11.7 Package 指令的作用域"></a>11.7 Package 指令的作用域</h2><p>所有 Perl 文件运行时就好象我们有一个 main 包定义在起始部分. 直到声明下一条包指令之前, 当前所有包指令仍然有效, 除非包指令在一个带大括号的作用域中. 在那种情况下, Perl 解释器会记住之前的包指令, 当带大括号的作用域结束时, 就还原之前的包指令:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> Navigation;<br><br>&#123;<br>    <span class="hljs-keyword">package</span> main;<br><br>    <span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">turn_toward_heading</span> </span>&#123; <span class="hljs-comment"># main::turn_toward_heading</span><br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">turn_toward_port</span> </span>&#123; <span class="hljs-comment"># Navigation::turn_toward_port</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>大多数库在文件的起始部分仅有一个包声明, 大多数程序把 <code>main</code> 包作为默认的包名.</p>
<p>不管当前包的定义如何, 一些名称总在 <code>main</code> 包中. (具体见书)</p>
<h2 id="11-8-包和专门词汇"><a href="#11-8-包和专门词汇" class="headerlink" title="11.8 包和专门词汇"></a>11.8 包和专门词汇</h2><p>通过 <code>my</code> 关键词引入的变量不使用当前包作为前缀, 因为包变量总是全局变量 (词法变量对于程序的一部分而言通常是临时的并且可访问的)</p>
<p><code>our</code> 关键词表明一个 package 中的变量前面可以不用加 package 名.</p>
<p>具体看:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perldoc -f our<br></code></pre></td></tr></table></figure>
<h3 id="包语句块"><a href="#包语句块" class="headerlink" title="包语句块"></a>包语句块</h3><p>可以使用语句块的语法:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> Navigation &#123;<br>    <span class="hljs-keyword">my</span> @homeport = ...<br><br>    ...<br>&#125;<br><br><span class="hljs-keyword">package</span> DropAnchor &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>新的包语法允许指定一个版本:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">12</span>;<br><br><span class="hljs-keyword">package</span> Navigation <span class="hljs-number">0</span>.<span class="hljs-number">01</span>;<br><br><span class="hljs-keyword">package</span> DropAnchor <span class="hljs-number">1.23</span> &#123; ... &#125;;<br></code></pre></td></tr></table></figure>


<h1 id="第12章-创建你自己的发行版"><a href="#第12章-创建你自己的发行版" class="headerlink" title="第12章 创建你自己的发行版"></a>第12章 创建你自己的发行版</h1><h2 id="12-1-Perl-模块的两个构建系统"><a href="#12-1-Perl-模块的两个构建系统" class="headerlink" title="12.1 Perl 模块的两个构建系统"></a>12.1 Perl 模块的两个构建系统</h2><p>Perl 有两种常见的发行版构建系统:</p>
<ul>
<li>ExtUtils::Makemaker, 基于 make 构建, 使用一个叫做 Makefile.PL 的文件来控制构建过程</li>
<li>Module::Build, 使用 Build.PL 文件</li>
</ul>
<h3 id="12-1-1-在-Makefile-PL-内部"><a href="#12-1-1-在-Makefile-PL-内部" class="headerlink" title="12.1.1 在 Makefile.PL 内部"></a>12.1.1 在 Makefile.PL 内部</h3><p>可在 ExtUtils::Makemaker 模块的文档中了解配置细节.</p>
<p><code>PREREQ_PM</code> 键的值，列吃了在运行代码时需要的以来模块及其版本号, 当在这里列出以来的模块时，CPAN 客户端都能够自动获取，构建并且安装它们.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">...<br><span class="hljs-string">PREREQ_PM =&gt;</span> &#123;<br>    <span class="hljs-string">&#x27;Test::More&#x27;</span> =&gt; <span class="hljs-number">0</span>,<br>&#125;,<br>...<br></code></pre></td></tr></table></figure>

<p>指定模块的版本:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> ExtUtils::Makemaker <span class="hljs-number">6.65</span>;<br></code></pre></td></tr></table></figure>

<p>另一个有用的设置 <code>EXE_FILES</code> 键, 在它对应的值里面列出发行版中包含的可安装程序:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> ExtUtils::Makemaker <span class="hljs-number">6.65</span>;<br><br>WriteMakefile(<br>    ...<br>    <span class="hljs-string">EXE_FILES =&gt;</span> [ <span class="hljs-string">qw( scripts/barnyard.pl )</span> ],<br>    ...<br><br>);<br>    <br></code></pre></td></tr></table></figure>
<h3 id="12-1-2-在-Build-PL-文件内部"><a href="#12-1-2-在-Build-PL-文件内部" class="headerlink" title="12.1.2 在 Build.PL 文件内部"></a>12.1.2 在 Build.PL 文件内部</h3><p>Module::Build::API 的文档解释了有效键的所有信息.</p>
<h2 id="12-2-我们的第一个发行版"><a href="#12-2-我们的第一个发行版" class="headerlink" title="12.2 我们的第一个发行版"></a>12.2 我们的第一个发行版</h2><h3 id="12-2-1-h2xs-工具"><a href="#12-2-1-h2xs-工具" class="headerlink" title="12.2.1 h2xs 工具"></a>12.2.1 h2xs 工具</h3><p>h2xs 用来将 C 语言的 <code>.h</code> 头文件转换成 <code>.xs</code> 文件，作为连接 C 和 Perl 的胶水语言.</p>
<p>使用 <code>-A</code> 和 <code>-X</code> 参数来关闭 <code>AUTOLOAD</code> 和 <code>XS</code> 特性. 使用 <code>-n</code> 开关设置模块名称:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ h2xs -AX -n Animal<br></code></pre></td></tr></table></figure>
<p>这将创建一系列文件.</p>
<h3 id="12-2-2-Module-Starter-模块"><a href="#12-2-2-Module-Starter-模块" class="headerlink" title="12.2.2 Module::Starter 模块"></a>12.2.2 Module::Starter 模块</h3><p>更加通用的做法是使用 Module::Starter 模块, 该模块并不包含在标准库中.</p>
<p>通过 module-starter 程序，可以设定我们的姓名和电子邮箱，这些信息将被插入相关文件合适的地方.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ module-starter --module=Animal --author=<span class="hljs-string">&quot;Gilligan&quot;</span> /<br>--email=gilligan@island.example.com --verbose<br></code></pre></td></tr></table></figure>

<p>默认情况下， module-starter 程序会创建一个带 Makefile.PL 的安装目录系统发行版. </p>
<p>如果享用 Module::Build 模块替代，使用 <code>--builder</code> 参数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ module-starter --builder=<span class="hljs-string">&quot;Module::Build&quot;</span> --module=Animal --author=<span class="hljs-string">&quot;Gilligan&quot;</span> /<br>--email=gilligan@island.example.com --verbose<br></code></pre></td></tr></table></figure>

<p>module-starter 的配置文件位于 <code>$HOME/.module-starter/config</code>, 也可以设置 <code>MODULE_STARTER_DIR</code> 环境变量来指定包含 config 的目录名称.</p>
<p>在配置文件内部，可以列出用冒号分割的所有参数名称和值:</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">author:</span> Willie Gilligan<br><span class="hljs-symbol">emain:</span> gilligan@island.example.com<br><span class="hljs-symbol">builder:</span> Module::Build<br><span class="hljs-symbol">verbose:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>之后只需要运行:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ module-starter --module=Animal<br></code></pre></td></tr></table></figure>
<p>就可以达到同样的效果.</p>
<h3 id="12-2-3-定制模板"><a href="#12-2-3-定制模板" class="headerlink" title="12.2.3 定制模板"></a>12.2.3 定制模板</h3><p>Module::Starter::Plugin 模块的文档展示了如何创建自己的插件.</p>
<p>对于真正复杂的模块创建，可以使用 Dist::Zilla 模块.</p>
<h2 id="12-3-在你的发行版内部"><a href="#12-3-在你的发行版内部" class="headerlink" title="12.3 在你的发行版内部"></a>12.3 在你的发行版内部</h2><p>运行构建脚本:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl Build.PL<br></code></pre></td></tr></table></figure>
<p><code>Build.PL</code> 会检查发行版，确保它所需要的所有文件是完整的，每个发行版将在 <code>MANIFEST</code> 文件记录检查的结果.</p>
<p>一旦 <code>Build.PL</code> 文件完成了检查，它将创建一个程序，其中包含 Perl 的设置，模块的路径和其他一些信息.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./Build<br></code></pre></td></tr></table></figure>
<p>其:</p>
<ol>
<li>从 lib 目录将模块文件复制到构建库 blib 目录中 , 这是构建系统用来保存所有准备安装文件的位置</li>
<li>Module::Build 模块将 Animal 模块内置的文档装换成 UNIX 系统中类似的手册页 (manpage), 然后放置到 <code>blib/libdoc</code> 目录中.</li>
</ol>
<p>测试命令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./Build <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>
<p>测试的脚本由之前 <code>module-starter</code> 命令创建于 <code>t</code> 目录中.</p>
<p>另一个测试参数 <code>disttest</code>, 用于发布发行版之前. 用来检查我们即将放入压缩包和发布的内容已经包含测试所需的所有信息:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./Build disttest<br></code></pre></td></tr></table></figure>
<p>过程: Build 会为它即将创建的压缩包文件创建一个子目录，将 MANIFEST 中列出的所有文件复制进去，切换到子目录的位置，然后再次执行测试.</p>
<p>真正准备好发布发行版时，执行 <code>dist</code> 参数，MAINIFFEST 文件中列出的所有文件都将被重新组织.</p>
<h3 id="12-3-1-META-文件"><a href="#12-3-1-META-文件" class="headerlink" title="12.3.1 META 文件"></a>12.3.1 META 文件</h3><p>客户端可以根据 <code>META.json</code> 和 <code>META.yml</code> 文件的信息判断它需要做什么事情.</p>
<p><code>_require</code> 字段列出安装环境需要满足的条件.</p>
<h3 id="12-3-2-添加额外的模块"><a href="#12-3-2-添加额外的模块" class="headerlink" title="12.3.2 添加额外的模块"></a>12.3.2 添加额外的模块</h3><p>一开始酒吧多个模块文件放入一个发行版中:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ module-starter --module=Animal,Cow,Horse,Mouse<br></code></pre></td></tr></table></figure>
<p>在创建发行版之后，还想往发行版中添加新的模块文件，使用 Module::Starter::AddModule 模块, 但这个模块需要安装好, 可以将 <code>module-starter</code> 的配置文件写为:</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">author:</span> Willie Gilligan<br><span class="hljs-symbol">emain:</span> gilligan@island.example.com<br><span class="hljs-symbol">builder:</span> Module::Build<br><span class="hljs-symbol">verbose:</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">plugins:</span> Module::Starter::AddModule<br></code></pre></td></tr></table></figure>
<p>用 <code>module-starter</code> 添加时需要用 <code>--dist</code> 参数指定添加到哪一个发行版，用 <code>--module</code> 参数指定要添加的模块:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ module-starter --module=Sheep --dist=Animal<br></code></pre></td></tr></table></figure>
<p>添加的模块也是一个新的模块，而不是 cpan 上已有的模块. 实际上就是添加模块的模板文件.</p>
<h2 id="12-4-模块内部"><a href="#12-4-模块内部" class="headerlink" title="12.4 模块内部"></a>12.4 模块内部</h2><p>Perl 有一个嵌入式的文档称为 Pod, 它是 Plain ol’Documentation 的简称. 可以在代码部分之间放置 Pod, 就是一些代码接着一些文档，再接着一些代码的格式.</p>
<p>可在 <code>perlpod</code> 和 <code>perlpodspec</code> 两个文档中参考 Pod 的文本格式规范.</p>
<h2 id="12-5-老式文档"><a href="#12-5-老式文档" class="headerlink" title="12.5 老式文档"></a>12.5 老式文档</h2><p>Perl 解析器会忽略文档部分.</p>
<p><code>perldoc</code> 程序会忽略代码部分.</p>
<p>可以直接用 <code>perldoc</code> 来阅读 Pod 文档部分:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perldoc lib/Animal.pm<br></code></pre></td></tr></table></figure>

<p>默认情况下，<code>perldoc</code> 借助 <code>nroff</code> 命令.</p>
<p>可以用 <code>pod2html</code> 程序将 Pod 转换成 HTML 格式:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ pod2html lib/Animal.pm<br></code></pre></td></tr></table></figure>

<h3 id="12-5-1-段落的-Pod-命令"><a href="#12-5-1-段落的-Pod-命令" class="headerlink" title="12.5.1 段落的 Pod 命令"></a>12.5.1 段落的 Pod 命令</h3><p><code>=headn</code> 指定一个标题.</p>
<p><code>=head1</code> 是一级标题.</p>
<p><code>=head2</code> 是二级标题.</p>
<p>需要返回代码模式时，就以 <code>=cut</code> 语句结束.</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">=head1 NAME<br><br>=head1 DESCRIPTION<br><br>=head2 Functions<br><br>=cut<br></code></pre></td></tr></table></figure>

<p>可以用 <code>=over n</code> 来创建列表, 列表的每个元素用 <code>=item</code> 来标记.</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">=over <span class="hljs-number">4</span><br><br>=item <span class="hljs-number">1</span>. Gilligan<br><br>=item <span class="hljs-number">2</span>. Skipper<br><br>=item <span class="hljs-number">3</span>. Ginger<br><br>=back<br></code></pre></td></tr></table></figure>
<p>使用 <code>*</code> 就会显示 <code>*</code>:</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">=over <span class="hljs-number">4</span><br><br>=item * Gilligan<br><br>=item * Skipper<br><br>=item * Ginger<br><br>=back<br></code></pre></td></tr></table></figure>

<h3 id="12-5-2-Pod-段落"><a href="#12-5-2-Pod-段落" class="headerlink" title="12.5.2 Pod 段落"></a>12.5.2 Pod 段落</h3><p>在文档中加入文本:</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">=head1 SYNOPSIS  <br><br>Quick summary of what the module does.<br><br>Perhaps a little <span class="hljs-built_in">code</span> snippet.<br><br>    use Animal;<br><br>    my $foo = Animal-&gt;new();<br></code></pre></td></tr></table></figure>

<h3 id="12-5-3-Pod-格式标记"><a href="#12-5-3-Pod-格式标记" class="headerlink" title="12.5.3 Pod 格式标记"></a>12.5.3 Pod 格式标记</h3><p><img src="/../img/Pod_mark.png" srcset="/img/loading.gif" lazyload></p>
<p>处理 UTF-8:</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">=encoding utf8<br><br>Gilligan ...<br></code></pre></td></tr></table></figure>

<h3 id="12-5-4-检查-Pod-格式"><a href="#12-5-4-检查-Pod-格式" class="headerlink" title="12.5.4 检查 Pod 格式"></a>12.5.4 检查 Pod 格式</h3><p>可以用 <code>podchecker</code> 来检查 Pod 文档的语法是否正确:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ podchecker lib/Animal.pm<br></code></pre></td></tr></table></figure>

<h2 id="12-6-模块中的代码"><a href="#12-6-模块中的代码" class="headerlink" title="12.6 模块中的代码"></a>12.6 模块中的代码</h2><p>按照惯例，Perl 模块使用包变量 <code>$VERSION</code> 来声明版本号.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">our</span> $VERSION = <span class="hljs-string">&#x27;0.01&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h2 id="12-7-模块构建的总结"><a href="#12-7-模块构建的总结" class="headerlink" title="12.7 模块构建的总结"></a>12.7 模块构建的总结</h2><p>见书.</p>
<h1 id="第13章-对象简介"><a href="#第13章-对象简介" class="headerlink" title="第13章 对象简介"></a>第13章 对象简介</h1><p>仅在程序的长度超过 N 行后 OOP (Object Oriented Programming) 的益处才能会显露出来.</p>
<p>可查阅 《Object Oriented Perl》一书.</p>
<p>Perl 的对象架构是在包，子例程和引用的概念上建立的.</p>
<h2 id="13-1-如果我们可以和动物对话……"><a href="#13-1-如果我们可以和动物对话……" class="headerlink" title="13.1 如果我们可以和动物对话……"></a>13.1 如果我们可以和动物对话……</h2><h2 id="13-2-介绍方法的调用箭头"><a href="#13-2-介绍方法的调用箭头" class="headerlink" title="13.2 介绍方法的调用箭头"></a>13.2 介绍方法的调用箭头</h2><p>类是一组拥有类似行为和特征的事物.</p>
<p>如:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Cow;<br><span class="hljs-keyword">use</span> Horse;<br><span class="hljs-keyword">use</span> Sheep;<br><br>Cow-&gt;speak;<br>Horse-&gt;speak;<br>Sheep-&gt;speak;<br></code></pre></td></tr></table></figure>

<p>可以将类名放入变量中使用:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $beast = <span class="hljs-string">&#x27;Cow&#x27;</span>;<br>$beast-&gt;speak;<br></code></pre></td></tr></table></figure>

<h2 id="13-3-方法调用的额外参数"><a href="#13-3-方法调用的额外参数" class="headerlink" title="13.3 方法调用的额外参数"></a>13.3 方法调用的额外参数</h2><p>两种形式:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">Class-&gt;method(@args);<br><br>Class::method(<span class="hljs-string">&#x27;Class&#x27;</span>, @args);<br></code></pre></td></tr></table></figure>
<h2 id="13-4-调用第二个方法进一步简化"><a href="#13-4-调用第二个方法进一步简化" class="headerlink" title="13.4 调用第二个方法进一步简化"></a>13.4 调用第二个方法进一步简化</h2><p>这里调用的 <code>sound</code> 方法返回一个常量文本:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sound</span> </span>&#123; <span class="hljs-string">&#x27;mooon&#x27;</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">speak</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $class = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;a $class goes &quot;</span>, $class-&gt;sound, <span class="hljs-string">&quot;!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用 “继承” 来共享方法的定义.</p>
<h2 id="13-5-关于-ISA-的几个注意事项"><a href="#13-5-关于-ISA-的几个注意事项" class="headerlink" title="13.5 关于 @ISA 的几个注意事项"></a>13.5 关于 <code>@ISA</code> 的几个注意事项</h2><p><code>@ISA</code> 的读法是 <code>is a</code>.</p>
<p>Perl 解释器在 <code>@ISA</code> 中的查找是递归的，深度优先，并且从左到右进行.</p>
<p>当当前类中没有调用的方法时，Perl 解释器就会在 <code>@ISA</code> 数组中的类中查找.</p>
<p>两种使用方法:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">@Class::ISA = <span class="hljs-string">qw(Animal)</span>;<br></code></pre></td></tr></table></figure>
<p>or:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> Cow;<br><span class="hljs-keyword">our</span> @ISA = <span class="hljs-string">qw(Animal)</span> ;<br></code></pre></td></tr></table></figure>

<p>可以使用编译提示符 <code>use parent</code>:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> <span class="hljs-number">5.101</span>;<br><span class="hljs-keyword">package</span> Cow;<br><span class="hljs-keyword">use</span> parent <span class="hljs-string">qw(Animal)</span>;<br></code></pre></td></tr></table></figure>
<h2 id="13-6-方法重写"><a href="#13-6-方法重写" class="headerlink" title="13.6 方法重写"></a>13.6 方法重写</h2><p>直接改写即可，调用方法时若是在本类中找到了，就不会去 parent 中找.</p>
<p>应当使用继承的方式重用代码，而不是用复制和粘贴.</p>
<h2 id="13-7-开始从不同的地方查找"><a href="#13-7-开始从不同的地方查找" class="headerlink" title="13.7 开始从不同的地方查找"></a>13.7 开始从不同的地方查找</h2><h2 id="13-8-使用-SUPER-的实现方法"><a href="#13-8-使用-SUPER-的实现方法" class="headerlink" title="13.8 使用 SUPER 的实现方法"></a>13.8 使用 SUPER 的实现方法</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> Mouse;<br><span class="hljs-keyword">use</span> parent <span class="hljs-string">qw(Animal)</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sound</span> </span>&#123; <span class="hljs-string">&#x27;squeak&#x27;</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">speak</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $class = <span class="hljs-keyword">shift</span>;<br>    $class-&gt;SUPER::speak;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;[but you can barely hear it!]\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>SUPER::speak</code> 意味着应当在当前包的 <code>@ISA</code> 中查找 speak 方法，如果找到多个，就调用第一个.</p>
<h2 id="13-9-要对-做些什么"><a href="#13-9-要对-做些什么" class="headerlink" title="13.9 要对 @_ 做些什么"></a>13.9 要对 <code>@_</code> 做些什么</h2><h2 id="13-10-我们在哪里"><a href="#13-10-我们在哪里" class="headerlink" title="13.10 我们在哪里"></a>13.10 我们在哪里</h2><p>如:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $beast = <span class="hljs-string">&#x27;Class&#x27;</span>;<br>$beast-&gt;method(@args);<br></code></pre></td></tr></table></figure>
<p>此时，Perl 隐式地将类名放置于参数列表之前:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">(<span class="hljs-string">&#x27;Class&#x27;</span>, @args)<br></code></pre></td></tr></table></figure>

<h1 id="第14章-测试简介"><a href="#第14章-测试简介" class="headerlink" title="第14章 测试简介"></a>第14章 测试简介</h1><h2 id="14-2-Perl-的测试流程"><a href="#14-2-Perl-的测试流程" class="headerlink" title="14.2 Perl 的测试流程"></a>14.2 Perl 的测试流程</h2><p>Perl 测试惯例是在 Perl 程序所在的文件夹中建立一个文件夹，叫做 “测试文件”.</p>
<h3 id="通用测试协议"><a href="#通用测试协议" class="headerlink" title="通用测试协议"></a>通用测试协议</h3><p>通用测试协议 – Test Anywhere Protocol, TAP. 就是规范测试的输出.</p>
<p>测试通过，输出 ok 和一个测试编码.</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ok</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>可以给测试附加一个标签，使我们知道通过了什么:</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-symbol">ok</span><span class="hljs-number"> 1 </span>- The boat motor works<br></code></pre></td></tr></table></figure>
<p>测试没有通过，输出 not ok:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">not</span> ok <span class="hljs-number">2</span> - The hull <span class="hljs-keyword">is</span> <span class="hljs-built_in">int</span>act<br></code></pre></td></tr></table></figure>

<p>现在 Perl 主要的测试模块: Test::More.</p>
<p>如使用 <code>ok</code> 子例程:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Test::More <span class="hljs-string">tests =&gt;</span> <span class="hljs-number">1</span>;<br><br>ok( try_motor(), <span class="hljs-string">&#x27;The boat motor works&#x27;</span> );<br></code></pre></td></tr></table></figure>
<p><code>tests =&gt; 1</code> 明确声明只有一个测试。</p>
<p>如果不知道测试数量，就在测试代码末尾使用 <code>done_testing</code>:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">ok( try_motor(), <span class="hljs-string">&#x27;The boat motor works&#x27;</span> );<br><br>done_testing();<br></code></pre></td></tr></table></figure>

<p><code>is</code> 子例程，我们传入所拥有的值，所期望的值，和测试标签:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">is( check_gas(), <span class="hljs-string">&#x27;Full&#x27;</span>, <span class="hljs-string">&#x27;The gas tank is full&#x27;</span> );<br></code></pre></td></tr></table></figure>
<p>还有 <code>isnt</code>, <code>like</code>, <code>unlike</code>, <code>is_deeply</code> 这些子例程.</p>
<h2 id="14-3-测试的艺术"><a href="#14-3-测试的艺术" class="headerlink" title="14.3 测试的艺术"></a>14.3 测试的艺术</h2><p>原则: 记住编程过程中曾经犯过的错误是很重要的.</p>
<h3 id="一个测试示例"><a href="#一个测试示例" class="headerlink" title="一个测试示例"></a>一个测试示例</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Test::More <span class="hljs-string">tests =&gt;</span> <span class="hljs-number">6</span>;<br><br>is( <span class="hljs-keyword">sqrt</span>(  <span class="hljs-number">0</span>),  <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;The square root of 0   is  0&#x27;</span> );<br>is( <span class="hljs-keyword">sqrt</span>(  <span class="hljs-number">1</span>),  <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;The square root of 1   is  1&#x27;</span> );<br>is( <span class="hljs-keyword">sqrt</span>( <span class="hljs-number">49</span>),  <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;The square root of 49  is  7&#x27;</span> );<br>is( <span class="hljs-keyword">sqrt</span>(<span class="hljs-number">100</span>), <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;The square root of 100 is 10&#x27;</span> );<br></code></pre></td></tr></table></figure>

<p>用 <code>eval</code> 捕获得到的结果:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br>$n = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">eval</span> &#123; <span class="hljs-keyword">sqrt</span>($n) &#125;;<br>ok( $@, <span class="hljs-string">&#x27;$@ is set after sqrt(-1)&#x27;</span> );<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="14-4-测试用具"><a href="#14-4-测试用具" class="headerlink" title="14.4 测试用具"></a>14.4 测试用具</h2><p>当我们运行测试的时候，调用了一个叫做测试用具的东西，它将查找所有测试程序, (以 <code>.t</code> 结尾的文件), 逐个运行它们，捕获输出，并提供结果的一个总体摘要.</p>
<p>Test::Harness 模块会搜集测试脚本，并运行它们，最后汇总结果.</p>
<h2 id="14-5-标准测试"><a href="#14-5-标准测试" class="headerlink" title="14.5 标准测试"></a>14.5 标准测试</h2><p>当使用module-starter(或者h2xs)程序创建我们自己的发行版时,就自动生成了一些初始测试脚本以及一些其他文件。按照惯例,测试文件位于t目录并以 .t扩展名结尾。</p>
<p>当运行测试程序时,构建程序将运行它在t目录中所查找到的每个测试文件:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl Build.PL<br>$ ./Build <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>

<p>有些人吧作者测试目录设置成 <code>xt</code>, 以便与代码测试目录 <code>t</code> 分开.</p>
<p>在这些测试做任何事情之前,它们会检查那些需要完成工作的相依赖模块。如果没有,就将跳过这些相应的测试。</p>
<h3 id="14-5-1-模块编译的检查"><a href="#14-5-1-模块编译的检查" class="headerlink" title="14.5.1 模块编译的检查"></a>14.5.1 模块编译的检查</h3><p>t&#x2F;00-load.t 文件,这是运行的第一个测试文件,因为默认测试顺序是按照字典顺序执行</p>
<p>使用 blib 模块，其会搜索周围的目录，包括父目录, 用于将 blib 添加到 <code>@INC</code> 数组中:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl -Mblib -T t/00-load.t<br></code></pre></td></tr></table></figure>
<p><code>-T</code> 参数是开启 “污染” 检查模式.</p>
<h3 id="14-5-2-模板测试"><a href="#14-5-2-模板测试" class="headerlink" title="14.5.2 模板测试"></a>14.5.2 模板测试</h3><p><code>t/boilerplate.t</code> 文件.</p>
<p>我们不用保留 <code>t/boilerplate.t</code> 文件，一旦我们替换了占位符文本，就可以删除这个文件了.</p>
<h3 id="14-5-3-测试-Pod"><a href="#14-5-3-测试-Pod" class="headerlink" title="14.5.3  测试 Pod"></a>14.5.3  测试 Pod</h3><p>标准的 Pod 测试只关心两件事: 我们的 Pod 没有任何格式错误和我们已经为每个子例程编写了文档.</p>
<p>这些测试都是可选的,并且只有在安装了Test::Pod模块和Test::Pod::Coverage模块后才会运行。这些测试会自动查找所有模块文件并逐个进行测试,因此我们不用修改这些测试脚本。</p>
<p>如果我们还没有给新添加的子例程编写相应的文档,Pod覆盖测试就会无法通过.</p>
<p>要修复这个Pod测试,我们需要使用我们自己的方法中的文档替换存根文档中的信息。</p>
<h2 id="14-6-添加第一个测试"><a href="#14-6-添加第一个测试" class="headerlink" title="14.6 添加第一个测试"></a>14.6 添加第一个测试</h2><p>添加自己的测试文件。</p>
<h1 id="第15章-带数据的对象"><a href="#第15章-带数据的对象" class="headerlink" title="第15章 带数据的对象"></a>第15章 带数据的对象</h1><h2 id="15-1-马属于马类，各从其类是吗"><a href="#15-1-马属于马类，各从其类是吗" class="headerlink" title="15.1 马属于马类，各从其类是吗"></a>15.1 马属于马类，各从其类是吗</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> Animal;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">speak</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $class = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;a $class goes &quot;</span>, $class-&gt;sound, <span class="hljs-string">&quot;!\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">package</span> Horse;<br>@ISA = <span class="hljs-string">qw(Animal)</span>;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sound</span> </span>&#123; <span class="hljs-string">&#x27;heigh&#x27;</span> &#125;<br></code></pre></td></tr></table></figure>

<p>一个实例会有关联的属性，称为实例变量 (或叫成员变量).</p>
<p>在 Perl 中，实例必须是一个内置类型的引用.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#! perl</span><br><span class="hljs-comment"># scripts/horse.pl</span><br><br><span class="hljs-keyword">my</span> $name = <span class="hljs-string">&#x27;Mr. Ed&#x27;</span>;<br><span class="hljs-keyword">my</span> $tv_horse = \$name;<br><br><span class="hljs-keyword">bless</span> $tv_horse, <span class="hljs-string">&#x27;Horse&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>可以在 <code>perldoc -f bless</code> 中查看 <code>bless</code> 的用法.</p>
<p>这里将 <code>$tv_horse</code> 变为 <code>Horse</code> 的对象. (就是给 <code>tv_horse</code> 附加上 <code>Horse</code> 这个包名)</p>
<p><img src="/../img/the_PeGS_structure_of_tv_horse.png" srcset="/img/loading.gif" lazyload></p>
<p>此时 <code>tv_horse</code> 是 <code>Horse</code> 类的一个实例，但是这个引用并没有什么改变，依旧可以用传统的解引用操作符.</p>
<h2 id="15-2-调用实例方法"><a href="#15-2-调用实例方法" class="headerlink" title="15.2 调用实例方法"></a>15.2 调用实例方法</h2><p>Perl 从被 bless 过的实例变量中取出类的名称，然后用它来定位和调用方法.</p>
<p>bless 的目的就是把一个类和这个引用关联起来，让 Perl 解释器能找到适当的方法.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># scripts/horses.pl, as before</span><br><span class="hljs-keyword">my</span> $name = <span class="hljs-string">&#x27;Mr. Ed&#x27;</span>;<br><span class="hljs-keyword">my</span> $tv_horse = \$name;<br><br><span class="hljs-keyword">bless</span> $tv_horse, <span class="hljs-string">&#x27;Horse&#x27;</span>;<br><br><span class="hljs-keyword">my</span> $noise = $tv_horse-&gt;sound;<br></code></pre></td></tr></table></figure>
<p>Perl 会直接查找 Horse::Sound, 做中生成的方法调用为:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">Horse::sound($tv_horse)<br></code></pre></td></tr></table></figure>
<p>相当于 <code>$tv_horse-&gt;sound</code> 会传入一个默认参数.</p>
<h2 id="15-3-访问实例数据"><a href="#15-3-访问实例数据" class="headerlink" title="15.3 访问实例数据"></a>15.3 访问实例数据</h2><p>一个常见的方法，就是用过 <code>shift</code> 语句，将默认数组的第一个参数，传递给实例方法一个叫 <code>$self</code> 的标量.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">name</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $self = <span class="hljs-keyword">shift</span>;<br>    $$<span class="hljs-keyword">shift</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="15-4-如何构建-Horse-的实例"><a href="#15-4-如何构建-Horse-的实例" class="headerlink" title="15.4 如何构建 Horse 的实例"></a>15.4 如何构建 Horse 的实例</h2><p>让 Horse 类自动构建一个新的 Horse 实例:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> Horse;<br><span class="hljs-keyword">use</span> parent <span class="hljs-string">qw(Animal)</span>;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sound</span> </span>&#123; <span class="hljs-string">&#x27;neigh&#x27;</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">name</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $self = <span class="hljs-keyword">shift</span>;<br>    $$self;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">named</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $class = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">my</span> $name = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">bless</span> \$name, $class;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>bless</code> 会返回 <code>\$name</code>.</p>
<p>使用 <code>named</code> a方法构建一个实例，而不必直接生成引用:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># my $name = &#x27;Mr. Ed&#x27;;</span><br><span class="hljs-comment"># my $tv_horse = \$name;</span><br><span class="hljs-keyword">my</span> $tv_horse = Horse-&gt;named(<span class="hljs-string">&#x27;Mr. Ed&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>这里的第一个参数是默认参数 ‘Horse’.</p>
<p><code>named</code> 就是一个构造函数.</p>
<p>大多数人使用一个叫做 <code>new</code> 的构造函数.</p>
<h2 id="15-5-继承构造函数"><a href="#15-5-继承构造函数" class="headerlink" title="15.5 继承构造函数"></a>15.5 继承构造函数</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> Animal;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">name</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $self = <span class="hljs-keyword">shift</span>;<br>    $$self;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">named</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $class = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">my</span> $name = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">bless</span> \$name, $class;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在一个实例上调用 <code>speak</code> 方法:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $tv_horse = Horse-&gt;named(<span class="hljs-string">&#x27;Mr. Ed&#x27;</span>);<br>$tv_horse-&gt;speak;<br></code></pre></td></tr></table></figure>
<p>得到的值为:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">a Horse=<span class="hljs-keyword">SCALAR</span>(0xaca42ac) gose <span class="hljs-comment">neigh!</span><br></code></pre></td></tr></table></figure>
<h2 id="15-6-编写能够使用类或实例作为参数的方法"><a href="#15-6-编写能够使用类或实例作为参数的方法" class="headerlink" title="15.6 编写能够使用类或实例作为参数的方法"></a>15.6 编写能够使用类或实例作为参数的方法</h2><p>需要判断方法是类还是实例上调用的.</p>
<p>类使用的方法默认参数是类名，而实例使用的方法默认参数是实例名.</p>
<p>最简单的方法是使用 <code>ref</code> 操作符. 如果 <code>ref</code> 作用于一个 <code>bless</code> 引用，就返回一个字符串 (类名). 如果作用于一个字符串，就返回 <code>undef</code> (像一个类名).</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># in lib/Animal.pm</span><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">name</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $either = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">ref</span> $either<br>        ? $$either              <span class="hljs-comment"># it&#x27;s an instance. return name</span><br>        : <span class="hljs-string">&quot;an unnamed $either&quot;</span>; <span class="hljs-comment"># it&#x27;s a class, return generic</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="15-7-为方法添加参数"><a href="#15-7-为方法添加参数" class="headerlink" title="15.7 为方法添加参数"></a>15.7 为方法添加参数</h2><p>为 Animal 类添加一个 eat 方法:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> Animal;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">named</span> </span>&#123;<br>    <span class="hljs-keyword">my</span>( $class, $name ) = @_;<br>    <span class="hljs-keyword">bless</span> \$name, $class;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">name</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $either = <span class="hljs-keyword">shift</span>;<br>    <br>    <span class="hljs-keyword">ref</span> $either<br>      ? $either<br>      : <span class="hljs-string">&quot;an unnamed $either&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">speak</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $either = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">print</span> $either-&gt;name, <span class="hljs-string">&#x27; goes &#x27;</span>, $either-&gt;sound, <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">eat</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $either = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">my</span> $food = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">print</span> $either-&gt;name, <span class="hljs-string">&quot; eats $food.\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>类调用的方法一般用 <code>$self</code>, 实例调用的方法一般用 <code>$either</code>.</p>
<p>使用:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $tv_horse = Horse-&gt;named(<span class="hljs-string">&#x27;Mr. Ed&#x27;</span>);<br>$tv_horse-&gt;eat(<span class="hljs-string">&#x27;hay&#x27;</span>);<br>Sheep-&gt;eat(<span class="hljs-string">&#x27;grass&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>第一个调用相当于:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">Animal::eat($tv_horse, <span class="hljs-string">&#x27;hey&#x27;</span>);<br></code></pre></td></tr></table></figure>

<h2 id="15-8-更有趣的实例"><a href="#15-8-更有趣的实例" class="headerlink" title="15.8 更有趣的实例"></a>15.8 更有趣的实例</h2><p>将散列的键作为成员变量，相应的值就是对应数据项的值.</p>
<p>如:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $lost = <span class="hljs-keyword">bless</span> &#123; <span class="hljs-string">Name =&gt;</span> <span class="hljs-string">&#x27;Bo&#x27;</span>, <span class="hljs-string">Color =&gt;</span> <span class="hljs-string">&#x27;white&#x27;</span> &#125;, <span class="hljs-string">&#x27;Sheep&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h2 id="15-9-一匹不同颜色的马"><a href="#15-9-一匹不同颜色的马" class="headerlink" title="15.9 一匹不同颜色的马"></a>15.9 一匹不同颜色的马</h2><p>获取和设置颜色:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># in Animal</span><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">color</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $self = <span class="hljs-keyword">shift</span>;<br>    $self-&gt;&#123;Color&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">set_color</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $self = <span class="hljs-keyword">shift</span>;<br>    $self-&gt;&#123;Color&#125; = <span class="hljs-keyword">shift</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="15-10-收回存款"><a href="#15-10-收回存款" class="headerlink" title="15.10 收回存款"></a>15.10 收回存款</h2><p>setter 的返回值考虑:</p>
<ul>
<li>更新后的参数</li>
<li>之前的值</li>
<li>对象自身</li>
<li>成功&#x2F;失败代码</li>
</ul>
<p>避免当调用为空上下文时，存储前一项的值, 用 <code>wantarray</code>, 在 <code>perldoc -f wantarray</code> 中查看用法.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Perl/" class="category-chain-item">Perl</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Perl-进阶-Notes</div>
      <div>http://example.com/2022/10/20/Perl-进阶-Notes/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月20日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/20/%E5%85%B3%E4%BA%8E-Perl-%E7%9A%84-File::Spec-%E6%A8%A1%E5%9D%97/" title="关于-Perl-的-File::Spec-模块">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">关于-Perl-的-File::Spec-模块</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/19/%E6%90%AD%E5%BB%BA%E9%A5%A5%E8%8D%92%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="搭建饥荒服务器">
                        <span class="hidden-mobile">搭建饥荒服务器</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'zKurisu/comments-utterances');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Jie</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Orkarin</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
