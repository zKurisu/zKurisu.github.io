

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/wallhaven-j5kjgy_1920x1080.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="1 Lua 语言入门1.1 程序段程序段 (Chunk), 一组命令或表达式组成的序列. -i 参数, 在执行完指定的程序段后进入交互模式: 1$ lua -i prog  调用函数 dofile 可以加载一个文件: 12$ lua&gt; dofile(&quot;lib1.lua&quot;) 就加载了 lib1.lua 文件. 1.2 一些词法规范“下划线+大写字母” 组成的标识符通常被 L">
<meta property="og:type" content="article">
<meta property="og:title" content="Lua-程序设计-Notes">
<meta property="og:url" content="http://example.com/2022/12/29/Lua-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Notes/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 Lua 语言入门1.1 程序段程序段 (Chunk), 一组命令或表达式组成的序列. -i 参数, 在执行完指定的程序段后进入交互模式: 1$ lua -i prog  调用函数 dofile 可以加载一个文件: 12$ lua&gt; dofile(&quot;lib1.lua&quot;) 就加载了 lib1.lua 文件. 1.2 一些词法规范“下划线+大写字母” 组成的标识符通常被 L">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/lua_ope_priority.png">
<meta property="og:image" content="http://example.com/img/lua_escape_characters.png">
<meta property="og:image" content="http://example.com/img/lua_args_of_io_read.png">
<meta property="article:published_time" content="2022-12-29T01:05:03.000Z">
<meta property="article:modified_time" content="2022-12-30T13:54:57.303Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/lua_ope_priority.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Lua-程序设计-Notes - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jie</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/SteinsGate_all.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Lua-程序设计-Notes"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-12-29 09:05" pubdate>
          2022年12月29日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          161 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Lua-程序设计-Notes</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="1-Lua-语言入门"><a href="#1-Lua-语言入门" class="headerlink" title="1 Lua 语言入门"></a>1 Lua 语言入门</h1><h2 id="1-1-程序段"><a href="#1-1-程序段" class="headerlink" title="1.1 程序段"></a>1.1 程序段</h2><p>程序段 (Chunk), 一组命令或表达式组成的序列.</p>
<p><code>-i</code> 参数, 在执行完指定的程序段后进入交互模式:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ lua -i prog<br></code></pre></td></tr></table></figure>

<p>调用函数 <code>dofile</code> 可以加载一个文件:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ lua<br>&gt; dofile(<span class="hljs-string">&quot;lib1.lua&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>就加载了 <code>lib1.lua</code> 文件.</p>
<h2 id="1-2-一些词法规范"><a href="#1-2-一些词法规范" class="headerlink" title="1.2 一些词法规范"></a>1.2 一些词法规范</h2><p><mark>“下划线+大写字母”</mark> 组成的标识符通常被 Lua 语言用作特殊用途.</p>
<p>Lua 对大小写敏感.</p>
<p><code>--</code> 为单行注释.</p>
<p>长注释为:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--[[</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">]]</span><br></code></pre></td></tr></table></figure>

<p>Lua 中连续语句之间的分隔符并不是必需的, 如果有需要的话可以使用分号来进行分隔, 以下等同:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">a = <span class="hljs-number">1</span><br>b = a * <span class="hljs-number">2</span><br><br>a = <span class="hljs-number">1</span>;<br>b = a * <span class="hljs-number">2</span>;<br><br>a = <span class="hljs-number">1</span>; b = a * <span class="hljs-number">2</span><br><br>a = <span class="hljs-number">1</span> b = a * <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h2 id="1-3-全局变量"><a href="#1-3-全局变量" class="headerlink" title="1.3 全局变量"></a>1.3 全局变量</h2><p>全局变量无需声明即可使用.</p>
<p>使用未初始化的全局变量不会报错, 得到 <code>nil</code>.</p>
<p>把 <code>nil</code> 赋值给全局变量, Lua 会回收该全局变量.</p>
<p>Lua 不区分未初始化变量和被赋值为 <code>nil</code> 的变量.</p>
<h2 id="1-4-类型和值"><a href="#1-4-类型和值" class="headerlink" title="1.4 类型和值"></a>1.4 类型和值</h2><p>基本类型有:</p>
<ul>
<li>nil</li>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>userdata</li>
<li>function</li>
<li>thread</li>
<li>table</li>
</ul>
<p>使用 <code>type</code> 函数查看:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">type</span>(<span class="hljs-literal">nil</span>)   <span class="hljs-comment">--&gt; nil</span><br></code></pre></td></tr></table></figure>

<p><code>userdata</code> 类型允许把任意的 C 语言数据保存在 Lua 语言变量中.</p>
<h3 id="1-4-1-nil"><a href="#1-4-1-nil" class="headerlink" title="1.4.1 nil"></a>1.4.1 nil</h3><p><code>nil</code> 表示无效值.</p>
<h3 id="1-4-2-Boolean"><a href="#1-4-2-Boolean" class="headerlink" title="1.4.2 Boolean"></a>1.4.2 Boolean</h3><p>具有两个值:</p>
<ul>
<li>true</li>
<li>false</li>
</ul>
<p>可用逻辑运算符:</p>
<ul>
<li><code>and</code>, 如果它的第一个操作数为 <code>false</code>, 则返回第一个操作数, 否则返回第二个操作数</li>
<li><code>or</code>, 如果它的第一个操作数不为 <code>false</code>, 则返回第一个操作数, 否则返回第二个操作数</li>
<li><code>not</code>, 永远返回 Boolean 类型的值</li>
</ul>
<h2 id="1-5-独立解释器"><a href="#1-5-独立解释器" class="headerlink" title="1.5 独立解释器"></a>1.5 独立解释器</h2><p>在脚本开头添加:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">#! /usr/<span class="hljs-keyword">local</span>/bin/lua<br></code></pre></td></tr></table></figure>
<p>不需要显式调用 Lua 语言解释器也可以直接运行 Lua 脚本.</p>
<p><code>-e</code> 参数允许在命令行输入代码:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ lua -e <span class="hljs-string">&quot;print(&#x27;Hello World&#x27;)&quot;</span><br></code></pre></td></tr></table></figure>

<p><code>-l</code> 参数用来加载库.</p>
<p>解释器在处理参数前, 会查找名为 <code>LUA_INIT_5_3</code> 或 <code>LUA_INIT</code> 的环境变量</p>
<ul>
<li>如果变量内容为 <code>@filename</code> 则会运行相应文件</li>
<li>如果变量存在但是不以 <code>@</code> 开头, 解释器就会认为其包含 Lua 代码, 并会对其进行解释执行</li>
</ul>
<p>编译器在运行代码前会创建一个名为 <code>arg</code> 的表, 其中存储了所有的命令行参数, 索引 <code>0</code> 保存脚本名, 索引 <code>1</code> 保存第一个参数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ lua script a b c<br></code></pre></td></tr></table></figure>

<h1 id="2-八皇后问题-eight-queen-puzzle"><a href="#2-八皇后问题-eight-queen-puzzle" class="headerlink" title="2 八皇后问题 (eight-queen puzzle)"></a>2 八皇后问题 (eight-queen puzzle)</h1><p>其目标是把 8 个皇后合理地摆放在棋盘上, 让每个皇后之间都不能相互攻击.</p>
<h1 id="3-数值"><a href="#3-数值" class="headerlink" title="3 数值"></a>3 数值</h1><p>从 Lua 5.3 版本开始, Lua 语言为数值格式提供了两种选择:</p>
<ul>
<li>被称为 <code>integer</code> 的 64 位整型</li>
<li>被称为 <code>float</code> 的双精度浮点类型</li>
</ul>
<h2 id="3-1-数值常量"><a href="#3-1-数值常量" class="headerlink" title="3.1 数值常量"></a>3.1 数值常量</h2><p>具有十进制小数或者指数的数值会被当作浮点型值.</p>
<p>整型值和浮点型值的类型都是 <code>number</code>.</p>
<p>当需要区分整型值和浮点型值时, 使用函数 <code>math.type</code>.</p>
<p><code>//</code> floor 除法运算符, 会将得到的商向负无穷取整, 从而保证结果是一个整数. 这样可以遵循一个规则: 如果操作数都是整型值, 那么结果就是整型值, 否则就是浮点型值.</p>
<h2 id="3-3-关系运算"><a href="#3-3-关系运算" class="headerlink" title="3.3 关系运算"></a>3.3 关系运算</h2><ul>
<li><code>&lt;</code></li>
<li><code>&gt;</code></li>
<li><code>&lt;=</code></li>
<li><code>&gt;=</code></li>
<li><code>==</code></li>
<li><code>~=</code>, 不等测试</li>
</ul>
<h2 id="3-4-数学库"><a href="#3-4-数学库" class="headerlink" title="3.4 数学库"></a>3.4 数学库</h2><p>标准数学库 <code>math</code>.</p>
<p>所有三角函数都以弧度为单位, 并通过函数 <code>deg</code> 和 <code>rad</code> 进行角度和弧度的转换.</p>
<p><code>math.random</code> 用于生成伪随机数.</p>
<p><code>randomseed</code> 用于设置伪随机数发生器的种子, 通常调用 <code>math.randomseed(os.time())</code></p>
<h3 id="3-4-2-取整函数"><a href="#3-4-2-取整函数" class="headerlink" title="3.4.2 取整函数"></a>3.4.2 取整函数</h3><p>三个取整函数:</p>
<ul>
<li><code>floor</code>, 向负无穷取整</li>
<li><code>ceil</code>, 向正无穷取整</li>
<li><code>modf</code>, 向零取整, 除了返回取整后的值以外, 还会返回小数部分作为第二个结果</li>
</ul>
<h2 id="3-5-表示范围"><a href="#3-5-表示范围" class="headerlink" title="3.5 表示范围"></a>3.5 表示范围</h2><p>最小值和最大值:</p>
<ul>
<li><code>math.mininteger</code></li>
<li><code>math.maxinteger</code></li>
</ul>
<h2 id="3-6-惯例"><a href="#3-6-惯例" class="headerlink" title="3.6 惯例"></a>3.6 惯例</h2><p>通过增加 <code>0.0</code> 的方法将整型值强制转换为浮点型值:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ lua<br>&gt; -3 + 0.0  --&gt; -3.0 <br></code></pre></td></tr></table></figure>

<h2 id="3-7-运算符优先级"><a href="#3-7-运算符优先级" class="headerlink" title="3.7 运算符优先级"></a>3.7 运算符优先级</h2><p><img src="/../img/lua_ope_priority.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4 字符串"></a>4 字符串</h1><p>Lua 语言中的字符串是一串字节组成的序列.</p>
<p>字符使用 8 个比特位来存储.</p>
<p>Lua 语言的字符串是不可变值 (immutable value), 不能像 C 语言中那样直接修改某个字符串中的某个字符. 但可以通过创建一个新字符串的方式来达到修改的目的:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">a = <span class="hljs-string">&quot;one string&quot;</span><br>b = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">gsub</span>(a, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;another&quot;</span>)<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br></code></pre></td></tr></table></figure>

<p>获取字符串长度, 使用 <code>#</code> 长度操作符:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">a = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-built_in">print</span>(#a)<br><span class="hljs-built_in">print</span>(#<span class="hljs-string">&quot;good bye&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>返回字符串占用的字节数.</p>
<p>连接操作符 <code>..</code></p>
<h2 id="4-1-字符串常量"><a href="#4-1-字符串常量" class="headerlink" title="4.1 字符串常量"></a>4.1 字符串常量</h2><p>双引号和单引号是等价的.</p>
<p>支持 C 语言风格的转义字符:</p>
<p><img src="/../img/lua_escape_characters.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="4-2-长字符串-x2F-多行字符串"><a href="#4-2-长字符串-x2F-多行字符串" class="headerlink" title="4.2 长字符串&#x2F;多行字符串"></a>4.2 长字符串&#x2F;多行字符串</h2><p>使用一对双方括号来声明长字符串&#x2F;多行字符串常量:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua">page = <span class="hljs-string">[[</span><br><span class="hljs-string">&lt;heml&gt;</span><br><span class="hljs-string">&lt;head&gt;</span><br><span class="hljs-string">  &lt;title&gt;An HTML Page&lt;/title&gt;</span><br><span class="hljs-string">&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">  &lt;a hred=&quot;http://www.lua.org&quot;&gt;Lua&lt;/a&gt;</span><br><span class="hljs-string">&lt;/body&gt;</span><br><span class="hljs-string">&lt;/html&gt;</span><br><span class="hljs-string">]]</span><br><br><span class="hljs-built_in">write</span>(page)<br></code></pre></td></tr></table></figure>

<p>字符串中遇到 <code>a=b[c[i]]</code> 的处理方法, 左方括号变为 <code>[===[</code>, 即在两个左方括号之间加上任意数量的等号, 这样只有遇到了包含相同数量等号的两个右方括号时才会结束. 该方法对注释同样有效.</p>
<h2 id="4-3-强制类型转换"><a href="#4-3-强制类型转换" class="headerlink" title="4.3 强制类型转换"></a>4.3 强制类型转换</h2><p>最好不依赖自动转换.</p>
<p>使用 <code>tonumber()</code>, <code>tostring()</code> 等函数.</p>
<h2 id="4-4-字符串标准库"><a href="#4-4-字符串标准库" class="headerlink" title="4.4 字符串标准库"></a>4.4 字符串标准库</h2><p>如:</p>
<ul>
<li><code>string.len()</code></li>
<li><code>string.rep()</code>, 重复</li>
<li><code>string.reverse()</code></li>
<li><code>string.lower()</code></li>
<li><code>string.upper()</code></li>
<li><code>string.sub()</code>, 不会改变原有字符串的值, 指挥返回一个新字符串</li>
<li><code>string.char()</code></li>
<li><code>string.byte()</code></li>
<li><code>string.format()</code></li>
<li><code>string.find(&quot;hello world&quot;, &quot;wor&quot;)</code>, 返回模式的开始和结束位置</li>
<li><code>string.gsub()</code></li>
</ul>
<p>如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ lua<br>&gt; string.format(<span class="hljs-string">&quot;x = %d  y = %d&quot;</span>, 10, 20)<br></code></pre></td></tr></table></figure>

<p>可用冒号操作符 <code>:</code> 直接调用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ lua<br>&gt; string.sub(s,i,j)<br>&gt; -- 等价于<br>&gt; s:sub(i,j)<br></code></pre></td></tr></table></figure>

<h2 id="4-5-Unicode-编码"><a href="#4-5-Unicode-编码" class="headerlink" title="4.5 Unicode 编码"></a>4.5 Unicode 编码</h2><h1 id="5-表-table"><a href="#5-表-table" class="headerlink" title="5 表 (table)"></a>5 表 (table)</h1><p>表 (table) 是 Lua 语言中最主要 (事实上也是唯一的) 数据结构.</p>
<p>调用函数 <code>math.sin</code> 对于 Lua 语言来说, 其实际含义是: 以字符串 “sin” 为键检索表 math.</p>
<h2 id="5-1-表索引"><a href="#5-1-表索引" class="headerlink" title="5.1 表索引"></a>5.1 表索引</h2><p>同一个表中存储的值可以具有不同的类型索引, 并可以按需增长以容纳新的元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ lua<br>&gt; a = &#123;&#125;<br>&gt; <span class="hljs-keyword">for</span> i = 1, 1000 <span class="hljs-keyword">do</span> a[i] = i*2 end<br>&gt; a[9]<br>&gt; a[<span class="hljs-string">&quot;x&quot;</span>] = 10<br></code></pre></td></tr></table></figure>

<p>可以把表当结构体使用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ lua<br>&gt; a.x = 10<br>&gt; -- 等价于<br>&gt; a[<span class="hljs-string">&quot;x&quot;</span>] = 10<br></code></pre></td></tr></table></figure>

<h2 id="5-2-表构造器"><a href="#5-2-表构造器" class="headerlink" title="5.2 表构造器"></a>5.2 表构造器</h2><p>Table Constructor, 用来创建和初始化表的表达式.</p>
<p>空构造器: <code>&#123;&#125;</code></p>
<p>初始化列表式:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">days = &#123;<span class="hljs-string">&quot;Sunday&quot;</span>, <span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>, <span class="hljs-string">&quot;Wednesday&quot;</span>, <span class="hljs-string">&quot;Thursday&quot;</span>, <span class="hljs-string">&quot;Friday&quot;</span>, <span class="hljs-string">&quot;Saturday&quot;</span>&#125;<br><br><span class="hljs-built_in">print</span>(days[<span class="hljs-number">4</span>]) <span class="hljs-comment">--&gt; Wednesday</span><br></code></pre></td></tr></table></figure>

<p>初始化记录式 (record-like) 表:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">a = &#123;x = <span class="hljs-number">10</span>, y = <span class="hljs-number">20</span>&#125;<br></code></pre></td></tr></table></figure>

<p>无论使用哪种方式创建表, 都可以随时增加或删除表元素.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">w = &#123;x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, label = <span class="hljs-string">&quot;console&quot;</span>&#125;<br>w.x = <span class="hljs-literal">nil</span>   <span class="hljs-comment">-- 删除</span><br>w[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;another field&quot;</span> 把键 <span class="hljs-number">1</span> 增加到表 <span class="hljs-string">&#x27;w&#x27;</span> 中<br></code></pre></td></tr></table></figure>

<p>混用:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">polyline = &#123;color=<span class="hljs-string">&quot;blue&quot;</span>,<br>            thickness=<span class="hljs-number">2</span>,<br>            npoints=<span class="hljs-number">4</span>,<br>            &#123;x=<span class="hljs-number">0</span>,   y=<span class="hljs-number">0</span>&#125;,     <span class="hljs-comment">-- polyline[1]</span><br>            &#123;x=<span class="hljs-number">-10</span>, y=<span class="hljs-number">0</span>&#125;,     <span class="hljs-comment">-- polyline[2]</span><br>            &#123;x=<span class="hljs-number">-10</span>, y=<span class="hljs-number">1</span>&#125;,     <span class="hljs-comment">-- polyline[3]</span><br>            &#123;x=<span class="hljs-number">0</span>,   y=<span class="hljs-number">1</span>&#125;,     <span class="hljs-comment">-- polyline[4]</span><br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>更加通用的构造器, 通过方括号括起来的表达式显式指定每一个索引:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">opnames = &#123;[<span class="hljs-string">&quot;+&quot;</span>] = <span class="hljs-string">&quot;add&quot;</span>, [<span class="hljs-string">&quot;-&quot;</span>] = <span class="hljs-string">&quot;sub&quot;</span>,<br>           [<span class="hljs-string">&quot;*&quot;</span>] = <span class="hljs-string">&quot;mul&quot;</span>, [<span class="hljs-string">&quot;/&quot;</span>] = <span class="hljs-string">&quot;div&quot;</span>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-3-数组-列表和序列"><a href="#5-3-数组-列表和序列" class="headerlink" title="5.3 数组, 列表和序列"></a>5.3 数组, 列表和序列</h2><p>使用整型作为索引的表, 不需要预先声明表的大小:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">a = &#123;&#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span> <span class="hljs-keyword">do</span><br>    a[i] l= <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>Lua 中, 数组的索引从 1 开始.</p>
<p>通常, 把<mark>列表的长度</mark>保存在表中某个非数值类型的字段中, 由于历史原因, 这个键通常是 “n”.</p>
<p>可以用 <code>nil</code> 值来标记列表的结束.</p>
<p><code>#</code> 操作符也可以获取列表长度.</p>
<p>对于 Lua 语言而言, 一个为 <code>nil</code> 的字段和一个不存在的元素没有区别:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">a = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br></code></pre></td></tr></table></figure>
<p>长度为 3 而不是 5.</p>
<p>处理存在空洞的列表时, 应该将列表的长度显式地保存起来.</p>
<h2 id="5-4-遍历表"><a href="#5-4-遍历表" class="headerlink" title="5.4 遍历表"></a>5.4 遍历表</h2><p><code>pairs</code> 迭代器, 可得到表中的键值对:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">t = &#123;<span class="hljs-number">10</span>, <span class="hljs-built_in">print</span>, x = <span class="hljs-number">12</span>, k = <span class="hljs-string">&quot;hi&quot;</span>&#125;<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">print</span>(k, v)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>受限于表在 Lua 语言中的底层实现机制, 遍历过程中<mark>元素的出现顺序可能是随机的</mark>.</p>
<p>对于列表 (上面的不算是列表) 可使用 <code>ipairs</code> 迭代器, 可以保证按照顺序.</p>
<p><code>for</code> 循环遍历:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">t = &#123;<span class="hljs-number">10</span>, <span class="hljs-built_in">print</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;hi&quot;</span>&#125;<br><span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>, #t <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(k, t[k])<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h2 id="5-5-安全访问"><a href="#5-5-安全访问" class="headerlink" title="5.5 安全访问"></a>5.5 安全访问</h2><p>Lua 没有安全访问操作符.</p>
<p><code>a or &#123;&#125;</code> 当 <code>a</code> 为 <code>nil</code> 时其结果是一个空表, 对于表达式 <code>(a or &#123;&#125;).b</code>, 当 <code>a</code> 为 <code>nil</code> 时其结果也同样是 <code>nil</code>.</p>
<h2 id="5-6-表标准库"><a href="#5-6-表标准库" class="headerlink" title="5.6 表标准库"></a>5.6 表标准库</h2><h3 id="table-insert"><a href="#table-insert" class="headerlink" title="table.insert"></a>table.insert</h3><p>向序列指定位置插入一个元素, 不指定位置时在序列的最后插入:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">t = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(t,<span class="hljs-number">1</span>,<span class="hljs-number">15</span>)<br><span class="hljs-comment">-- t 变为 [15,10,20,30]</span><br></code></pre></td></tr></table></figure>
<p>另一个例子:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">t = &#123;&#125;<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">lines</span>() <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(t, line)<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">print</span>(#t)<br></code></pre></td></tr></table></figure>

<h3 id="table-remove"><a href="#table-remove" class="headerlink" title="table.remove"></a>table.remove</h3><p>删除并返回序列指定位置的元素, 然后将其后的元素向前豫东填充删除元素后造成的空洞.</p>
<p>不指定位置则删除最后一个.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">table</span>.<span class="hljs-built_in">remove</span>(t,<span class="hljs-number">1</span>)<br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">remove</span>(t)<br></code></pre></td></tr></table></figure>

<h3 id="table-move"><a href="#table-move" class="headerlink" title="table.move"></a>table.move</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">table</span>.move(a,f,e,t)<br></code></pre></td></tr></table></figure>
<p>将表 <code>a</code> 中从索引 f 到 e 的元素移动到位置 t 上:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">table</span>.move(a, <span class="hljs-number">1</span>, #a, <span class="hljs-number">2</span>)<br>a[<span class="hljs-number">1</span>] = newElement<br><span class="hljs-built_in">table</span>.move(a, <span class="hljs-number">2</span>, #a, <span class="hljs-number">1</span>)<br>a[#a] = <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure>

<p><code>table.move</code> 还支持使用一个表作为可选参数, 即将第一个表中的元素移动到第二个表中.</p>
<h1 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h1><p>无论哪种情况, 函数调用时都需要使用一对圆括号把参数列表括起来.</p>
<p><mark>例外</mark> 当函数只有一个参数且该参数是字符串常量或表构造器:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Hello World&quot;</span><br><span class="hljs-built_in">dofile</span> <span class="hljs-string">&#x27;a.lua&#x27;</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">[[a multi-line</span><br><span class="hljs-string">    message]]</span><br>f&#123;x=<span class="hljs-number">10</span>, y=<span class="hljs-number">20</span>&#125;<br><span class="hljs-built_in">type</span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>Lua 为面向对象提供的特殊语法, 冒号操作符 <code>:</code></p>
<p>如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">o:foo(x)    <span class="hljs-comment">-- 调用对象 o 的 foo 方法  </span><br></code></pre></td></tr></table></figure>

<p>Lua 语言标准库中所有的函数都是使用 C 语言编写的.</p>
<p><mark>函数语法格式</mark> :</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(a)</span></span><br>    <span class="hljs-keyword">local</span> sum = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, #a <span class="hljs-keyword">do</span><br>        sum = sum + a[i]<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> sum<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>参数的行为<mark>与局部变量的行为完全一致</mark>, 相当于一个用函数调用时传入的值进行初始化的局部变量.</p>
<p>调用函数时使用的参数个数可以与定义函数时使用的参数不一致.</p>
<p>Lua 语言会通过抛弃多余参数和将不足的参数设为 <code>nil</code> 的方式来调整参数的个数.</p>
<p><mark>默认参数</mark>:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incCount</span><span class="hljs-params">(n)</span></span><br>    n = n <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><br>    globalCounter = globalCounter + n<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>这里 <code>n</code> 的默认值相当于就是 1.</p>
<h2 id="6-1-多返回值"><a href="#6-1-多返回值" class="headerlink" title="6.1 多返回值"></a>6.1 多返回值</h2><p>Lua 允许一个函数返回多个结果.</p>
<p>在 <code>return</code> 后列出所有要返回的值即可:</p>
<p>如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maximum</span><span class="hljs-params">(a)</span></span><br>    <span class="hljs-keyword">local</span> mi = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">local</span> m = aa[mi]<br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, #a <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> a[i] &gt; m <span class="hljs-keyword">then</span><br>            mi = i; m = a[i]<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> m, mi <br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(maximum(&#123;<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">23</span>,<span class="hljs-number">12</span>,<span class="hljs-number">5</span>&#125;))<br></code></pre></td></tr></table></figure>

<p>在多重赋值中, 如果一个函数没有返回值或者返回值个数不够多, 那么 Lua 语言会用 <code>nil</code> 来补充缺失的值:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">x,y,z = foo()   <span class="hljs-comment">-- x=&quot;a&quot;, y=&quot;b&quot;, z=nil</span><br></code></pre></td></tr></table></figure>
<p><mark>注意</mark>, 只有当函数调用是一系列表达式中的最后一个表达式时才能返回多值结果, 否则只能返回一个结果.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span> <span class="hljs-keyword">end</span><br><br>x,y = foo(), <span class="hljs-number">20</span>     <span class="hljs-comment">-- x=&quot;a&quot;, y=20</span><br></code></pre></td></tr></table></figure>

<p>当一个函数调用是另一个函数调用的最后一个实参时, 第一个函数的所有返回值都会被作为实参传给第二个函数.</p>
<p>将函数调用用用一对圆括号括起来可以强制其只返回一个结果:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>((foo()))<br></code></pre></td></tr></table></figure>

<h2 id="6-2-可变长参数函数"><a href="#6-2-可变长参数函数" class="headerlink" title="6.2 可变长参数函数"></a>6.2 可变长参数函数</h2><p>如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-keyword">local</span> s = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>&#123;...&#125; <span class="hljs-keyword">do</span><br>        s = s + v<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> s<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>))<br></code></pre></td></tr></table></figure>
<p><code>...</code> 表示该函数的参数是可变长的.</p>
<p>当函数要访问这些参数时仍需用到 <code>...</code></p>
<p>表达式 <code>&#123;...&#125;</code> (被称为可变长参数表达式 vararg expression) 的结果是一个由所有可变长参数组成的列表.</p>
<p>可用变长参数来模拟 Lua 中普通的参数传递机制:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-keyword">local</span> a, b, c = ...<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>格式化输出的函数 <code>string.format</code>. 输出文本函数 <code>io.write</code></p>
<p>具有可变长参数的函数也可以具有任意数量的固定参数:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(fmt, ...)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(fmt, ...))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p><code>table.pack</code> 函数, 保存所有参数, 然后将其放在一个表中返回, 这个表中还有一个保存了参数个数的额外字段 “n”.</p>
<p>判断可变长参数中是否包含无效的 <code>nil</code>:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nonils</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-keyword">local</span> <span class="hljs-built_in">arg</span> = <span class="hljs-built_in">table</span>.pack(...)<br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-built_in">arg</span>.n <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">arg</span>[i] == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<h3 id="使用-select-函数遍历"><a href="#使用-select-函数遍历" class="headerlink" title="使用 select 函数遍历"></a>使用 select 函数遍历</h3><p>函数 <code>select</code> 总是具有一个固定的参数 <code>selector</code>, 以及数量可变的参数, 如果 <code>selector</code> 是数值 n, 那么函数 select 则返回第 n 个参数后的所有参数, 否则, <code>selector</code> 应该是字符串 <code>#</code>, 以便函数 <code>select</code> 返回额外参数的总数:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">select</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>))     <span class="hljs-comment">--&gt; a b c</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">select</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>))     <span class="hljs-comment">--&gt; b c</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">select</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>))     <span class="hljs-comment">--&gt; c</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">select</span>(<span class="hljs-string">&quot;#&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>))     <span class="hljs-comment">--&gt; 3</span><br></code></pre></td></tr></table></figure>

<p>遍历如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-keyword">local</span> s = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-built_in">select</span>(<span class="hljs-string">&quot;#&quot;</span>, ...) <span class="hljs-keyword">do</span><br>        s = s + <span class="hljs-built_in">select</span>(i, ...)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> s<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h2 id="6-3-函数-table-unpack"><a href="#6-3-函数-table-unpack" class="headerlink" title="6.3 函数 table.unpack"></a>6.3 函数 table.unpack</h2><p>其参数是一个数组, 返回值为数组内的所有元素.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;)<br>a,b = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;<br></code></pre></td></tr></table></figure>

<p>通过数组 a 传入可变的参数来调用函数 f:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">f(<span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>(a))<br></code></pre></td></tr></table></figure>

<p>两个等价形式:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;ll&quot;</span>))<br></code></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">f = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span><br>a = &#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;ll&quot;</span>&#125;<br><br><span class="hljs-built_in">print</span>(f(<span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>(a)))<br></code></pre></td></tr></table></figure>

<p>可以显示地限制返回元素的范围</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>(&#123;<span class="hljs-string">&quot;Sun&quot;</span>, <span class="hljs-string">&quot;Mon&quot;</span>, <span class="hljs-string">&quot;Tue&quot;</span>, <span class="hljs-string">&quot;Wed&quot;</span>&#125;, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure>

<h2 id="6-4-正确的尾调用"><a href="#6-4-正确的尾调用" class="headerlink" title="6.4 正确的尾调用"></a>6.4 正确的尾调用</h2><p>当一个函数的最后一个动作是调用另一个函数而没有进行其他工作时, 就形成了 <mark>尾调用 (tail call)</mark> </p>
<p>如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span></span><br>    x = x + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> g(x) <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>当 g 返回时, 程序的执行路径会直接返回到调用 f 的位置. 不会再调用栈中保存有关调用函数的任何信息.</p>
<p>在进行尾调用时不使用任何额外的栈空间，称这种实现为<mark>尾调用消除 (tail-call elimination)</mark></p>
<p>由于尾调用不会使用栈空间, 所以一个程序中能够嵌套的尾调用的数量是无限的. (不会发生栈溢出)</p>
<h1 id="7-输入输出"><a href="#7-输入输出" class="headerlink" title="7 输入输出"></a>7 输入输出</h1><p>Lua 只提供了 ISO C 语言标准支持的功能, 即基本的文件操作等.</p>
<h2 id="7-1-简单-I-x2F-O-模型"><a href="#7-1-简单-I-x2F-O-模型" class="headerlink" title="7.1 简单 I&#x2F;O 模型"></a>7.1 简单 I&#x2F;O 模型</h2><p>I&#x2F;O 操作通过:</p>
<ul>
<li>当前输入流 (current input stream), 初始化为标准输入 stdin</li>
<li>当前输出流 (current output stream), 初始化为标准输出 stdout</li>
</ul>
<p>实现.</p>
<h3 id="函数-io-input-和-io-output"><a href="#函数-io-input-和-io-output" class="headerlink" title="函数 io.input 和 io.output"></a>函数 io.input 和 io.output</h3><p>函数 <code>io.input</code> 和函数 <code>io.output</code> 可以用于改变当前的输入输出流.</p>
<p>如: <code>io.input(filename)</code> 会以只读模式打开指定文件, 并将文件设置为当前输入流.</p>
<h3 id="函数-io-write-和-io-read"><a href="#函数-io-write-和-io-read" class="headerlink" title="函数 io.write 和 io.read"></a>函数 io.write 和 io.read</h3><p><code>io.write</code> 读取任意数量的字符串 (或者数字) 并将其写入当前输出流.</p>
<p><mark>作为原则</mark>, 应该只在 “用后即弃” 的代码或调试代码中使用函数 <code>print</code>, 当需要完全控制输出时, 应该使用函数 <code>io.write</code>.</p>
<p>函数 <code>io.write</code> 允许对输出进行重定向. 函数 <code>print</code> 只能使用标准输出, 其可以自动为其参数调用 <code>tostring</code>.</p>
<p><code>io.read</code> 可以从当前输入流中读取字符串, 其参数有:</p>
<p><img src="/../img/lua_args_of_io_read.png" srcset="/img/loading.gif" lazyload></p>
<p>如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> count = <span class="hljs-number">1</span>, <span class="hljs-built_in">math</span>.<span class="hljs-built_in">huge</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> line = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;L&quot;</span>)<br>    <span class="hljs-keyword">if</span> line == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">break</span> <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;%6d  &quot;</span>, count), line)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>使用 <code>io.lines</code> 迭代器, 逐行迭代一个文件:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> count = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">lines</span>() <span class="hljs-keyword">do</span><br>    count = count + <span class="hljs-number">1</span><br>    <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;%6d  &quot;</span>, count), line, <span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure>

<p><code>io.read(0)</code> 是一个特例, 它常用于测试是否到达了文件末尾, 如果仍然有数据可供读取, 它会返回一个空字符串, 否则, 则返回 nil.</p>
<p>调用 <code>read</code> 时可以指定多个选项, 函数会根据每个参数返回相应的结果, 如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> n1, n2, n3 = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> n1 <span class="hljs-keyword">then</span> <span class="hljs-keyword">break</span> <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">math</span>.<span class="hljs-built_in">max</span>(n1, n2, n3))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h2 id="7-2-完整-I-x2F-O-模型"><a href="#7-2-完整-I-x2F-O-模型" class="headerlink" title="7.2 完整 I&#x2F;O 模型"></a>7.2 完整 I&#x2F;O 模型</h2><h3 id="io-open"><a href="#io-open" class="headerlink" title="io.open"></a>io.open</h3><p>两个参数:</p>
<ul>
<li>待打开的文件名</li>
<li>模式, 包括: 只读的 <code>r</code>, 只写的 <code>w</code>, 追加的 <code>a</code>, 打开二进制文件的 <code>b</code></li>
</ul>
<p><mark>检查错误</mark>, 使用 <code>assert</code> 函数:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> f = <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(filename, mode))<br></code></pre></td></tr></table></figure>

<p>错误信息会作为函数 <code>assert</code> 的第二个参数被传入, 之后函数 <code>assert</code> 会将错误信息展示出来.</p>
<p>在打开文件后, 可以使用方法 <code>read</code> 和 <code>write</code> 从流中读取和向流中写入, 需要 <mark>使用冒号运算符</mark>  将它们当作流对象的方法来调用:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> f = <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;r&quot;</span>))<br><span class="hljs-keyword">local</span> t = f:<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;a&quot;</span>)<br>f:<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></table></figure>

<p><mark>三个预定义的 C 语言流的句柄</mark>:</p>
<ul>
<li><code>io.stdin</code></li>
<li><code>io.stdout</code></li>
<li><code>io.stderr</code></li>
</ul>
<p>混用 I&#x2F;O 模型:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> temp = ioo.<span class="hljs-built_in">input</span>()<br><span class="hljs-built_in">io</span>.<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;newinput&quot;</span>)<br><span class="hljs-built_in">io</span>.<span class="hljs-built_in">input</span>():<span class="hljs-built_in">close</span>()<br><span class="hljs-built_in">io</span>.<span class="hljs-built_in">input</span>(temp)<br></code></pre></td></tr></table></figure>

<p><mark>注意</mark>:</p>
<ul>
<li><code>io.read(args)</code> 实际上是 <code>io.input():read(args)</code> 的简写</li>
<li><code>io.write(args)</code> 实际上是 <code>io.input():write(args)</code> 的简写</li>
</ul>
<h2 id="7-3-其他文件操作"><a href="#7-3-其他文件操作" class="headerlink" title="7.3 其他文件操作"></a>7.3 其他文件操作</h2><h3 id="io-tmpfile"><a href="#io-tmpfile" class="headerlink" title="io.tmpfile"></a>io.tmpfile</h3><p>返回一个操作临时文件的句柄, 其以读&#x2F;写模式打开.</p>
<h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><h3 id="setvbuf"><a href="#setvbuf" class="headerlink" title="setvbuf"></a>setvbuf</h3><h3 id="seek"><a href="#seek" class="headerlink" title="seek"></a>seek</h3><h3 id="whence"><a href="#whence" class="headerlink" title="whence"></a>whence</h3><h3 id="os-rename"><a href="#os-rename" class="headerlink" title="os.rename"></a>os.rename</h3><h3 id="os-remove"><a href="#os-remove" class="headerlink" title="os.remove"></a>os.remove</h3><h2 id="7-4-其他系统调用"><a href="#7-4-其他系统调用" class="headerlink" title="7.4 其他系统调用"></a>7.4 其他系统调用</h2><h3 id="os-exit"><a href="#os-exit" class="headerlink" title="os.exit"></a>os.exit</h3><h3 id="os-getenv"><a href="#os-getenv" class="headerlink" title="os.getenv"></a>os.getenv</h3><h3 id="7-4-1-运行系统命令"><a href="#7-4-1-运行系统命令" class="headerlink" title="7.4.1 运行系统命令"></a>7.4.1 运行系统命令</h3><h4 id="os-execute"><a href="#os-execute" class="headerlink" title="os.execute"></a>os.execute</h4><p>等价于 C 语言中的函数 system.</p>
<h4 id="io-pipen"><a href="#io-pipen" class="headerlink" title="io.pipen"></a>io.pipen</h4><h1 id="8-补充知识"><a href="#8-补充知识" class="headerlink" title="8 补充知识"></a>8 补充知识</h1><h2 id="8-1-局部变量和代码块"><a href="#8-1-局部变量和代码块" class="headerlink" title="8.1 局部变量和代码块"></a>8.1 局部变量和代码块</h2><p>Lua 语言中的变量在<mark>默认情况下是全局变量</mark>, 所有的局部变量在使用前必须声明.</p>
<p>局部变量的生效范围仅限于声明它的代码块.</p>
<p>在 <mark>交互模式</mark> 中, 每一行代码就是一个代码段. 可以用 <code>do-end</code> 语句显式声明整个代码块:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> x1, x2<br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> a2 = <span class="hljs-number">2</span>*a<br>    <span class="hljs-keyword">local</span> d = (b^<span class="hljs-number">2</span> - <span class="hljs-number">4</span>*a*c)^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)<br>    x1 = (-b + d)/a2<br>    x2 = (-b - d)/a2<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">print</span>(x1, x2)<br></code></pre></td></tr></table></figure>

<p><mark>尽可能使用局部变量</mark>是一种良好的编程风格.</p>
<p>Lua 语言的发行版中有一个<mark>用于全局变量检查的模块</mark> <code>strict.lua</code>, 如果试图在一个函数中对不存在的全局变量赋值或者使用不存在的全局变量, 将会抛出异常.</p>
<h2 id="8-2-控制结构"><a href="#8-2-控制结构" class="headerlink" title="8.2 控制结构"></a>8.2 控制结构</h2><p>所有的控制结构语法上都有一个显式的终结符: <code>end</code></p>
<p><mark>注意</mark>, Lua 语言将所有不是 <code>false</code> 和 <code>nil</code> 的值当作真.</p>
<h3 id="8-2-1-if-then-else"><a href="#8-2-1-if-then-else" class="headerlink" title="8.2.1 if then else"></a>8.2.1 if then else</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> op == <span class="hljs-string">&quot;+&quot;</span> <span class="hljs-keyword">then</span><br>    r = a + b<br><span class="hljs-keyword">elseif</span> op == <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-keyword">then</span><br>    r = a - b<br><span class="hljs-keyword">elseif</span> op == <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-keyword">then</span><br>    r = a*b<br><span class="hljs-keyword">elseif</span> op == <span class="hljs-string">&quot;/&quot;</span> <span class="hljs-keyword">then</span><br>    r = a/b<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;invalid operation&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p><code>then</code> 表达式可以作为条件表达式的终止标记.</p>
<p><code>error</code> 函数用于报错.</p>
<p>Lua 不支持 <code>switch</code> 语句.</p>
<h3 id="8-2-2-while"><a href="#8-2-2-while" class="headerlink" title="8.2.2 while"></a>8.2.2 while</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> i = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> a[i] <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(a[i])<br>    i = i + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h3 id="8-2-3-repeat"><a href="#8-2-3-repeat" class="headerlink" title="8.2.3 repeat"></a>8.2.3 repeat</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> line <br><span class="hljs-keyword">repeat</span><br>    line = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()<br><span class="hljs-keyword">until</span> line ~= <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">print</span>(line)<br></code></pre></td></tr></table></figure>
<h3 id="8-2-4-数值型-for"><a href="#8-2-4-数值型-for" class="headerlink" title="8.2.4 数值型 for"></a>8.2.4 数值型 for</h3><p>两种类型的 <code>for</code> 语句:</p>
<ul>
<li>数值型 (numerical)</li>
<li>泛型 (generic)</li>
</ul>
<p>数值型如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> var = exp1, exp2, exp3 <span class="hljs-keyword">do</span><br>    something<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p><code>var</code> 的值从 <code>exp1</code> 变化到 <code>exp2</code>, <code>exp3</code> 是步长 (step) 可选, 默认为 1.</p>
<p>不设上限, 使用 <code>math.huge</code>:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-built_in">math</span>.<span class="hljs-built_in">huge</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0.3</span>*i^<span class="hljs-number">3</span> - <span class="hljs-number">20</span>*i^<span class="hljs-number">2</span> - <span class="hljs-number">500</span> &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">print</span>(i)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>这里的控制变量 <code>i</code> 是局部变量.</p>
<p><mark>注意</mark>, 不要改变控制变量的值, 随意改变控制变量的值可能产生不可预知的结果.</p>
<h3 id="8-2-5-泛型-for"><a href="#8-2-5-泛型-for" class="headerlink" title="8.2.5 泛型 for"></a>8.2.5 泛型 for</h3><p>泛型 <code>for</code> 遍历迭代函数返回的所有值. (如 <code>pairs</code>, <code>ipairs</code>, <code>io.lines</code>)</p>
<p>泛型 <code>for</code> 可以使用多个变量, 这些变量在每次循环时都会更新, <mark>当第一个变量变为 <code>nil</code> 时</mark> 循环终止.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">t = &#123;<span class="hljs-number">10</span>, <span class="hljs-built_in">print</span>, x = <span class="hljs-number">12</span>, k = <span class="hljs-string">&quot;hi&quot;</span>&#125;<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">print</span>(k, v)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h2 id="8-3-break-return-和-goto"><a href="#8-3-break-return-和-goto" class="headerlink" title="8.3 break, return 和 goto"></a>8.3 break, return 和 goto</h2><p>所有函数的最后都有一个隐含的 <code>return</code>.</p>
<p><code>goto</code> 的标签形式如 <code>::name::</code>. (复杂语法用于醒目标识)</p>
<p><code>goto</code> 不能跳转到函数外, 也不能跳转到局部变量的作用域.</p>
<p><mark>局部变量的作用域终止于</mark>声明变量的代码块中的最后一个有效 (non-void) 语句处, 标签被认为是无效 (void) 语句.</p>
<h1 id="9-闭包"><a href="#9-闭包" class="headerlink" title="9 闭包"></a>9 闭包</h1><p>一个概念, Lua 的函数是遵循 <mark>词法定界 (lexicalscoping) 的第一类值 (first-classvalue)</mark> </p>
<p><mark>第一类值</mark> 指 Lua 中的函数与其他常见的类型的值具有同等权限:</p>
<ul>
<li>可以将函数保存在变量或表中</li>
<li>可以将函数作为参数传递给其他函数</li>
<li>可以将函数作为其他函数的返回值</li>
</ul>
<p><mark>词法定界</mark> 指 Lua 中的函数可以访问包含其自身的外部函数中的变量. 如函数 B 包含函数 A, 那么函数 A 可以访问函数 B 的所有局部变量.</p>
<h2 id="9-1-第一类值"><a href="#9-1-第一类值" class="headerlink" title="9.1 第一类值"></a>9.1 第一类值</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">a = &#123;p = <span class="hljs-built_in">print</span>&#125;     <span class="hljs-comment">-- &#x27;a.p&#x27; 指向 &#x27;print&#x27; 函数</span><br>a.p(<span class="hljs-string">&quot;Hello World&quot;</span>)  <span class="hljs-comment">-- Hello World</span><br></code></pre></td></tr></table></figure>

<p>函数的定义可以由:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>写成:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">foo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p><mark>注意</mark>, 在 Lua 中所有函数都是匿名的 (anonynous), 即没有名字, 当讨论函数名如 <code>print</code> 时, 实际上指的是保存该函数的变量.</p>
<p><mark>高阶函数</mark>, 以另一个函数作为参数, 如 <code>sort</code>:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">table</span>.<span class="hljs-built_in">sort</span>(network, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a,b)</span></span> <span class="hljs-keyword">return</span> (a.name &gt; b.name) <span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure>

<h2 id="9-2-非全局函数"><a href="#9-2-非全局函数" class="headerlink" title="9.2 非全局函数"></a>9.2 非全局函数</h2><p>表字段中存储函数, 有很多中写法:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">lib = &#123;&#125;<br>lib.foo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x,y)</span></span> <span class="hljs-keyword">return</span> x + y <span class="hljs-keyword">end</span><br>lib.goo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x,y)</span></span> <span class="hljs-keyword">return</span> x - y <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">lib = &#123;<br>    foo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x,y)</span></span> <span class="hljs-keyword">return</span> x + y <span class="hljs-keyword">end</span>,<br>    goo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x,y)</span></span> <span class="hljs-keyword">return</span> x - y <span class="hljs-keyword">end</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">lib = &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lib.foo</span> <span class="hljs-params">(x,y)</span></span> <span class="hljs-keyword">return</span> x + y <span class="hljs-keyword">end</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lib.goo</span> <span class="hljs-params">(x,y)</span></span> <span class="hljs-keyword">return</span> x - y <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p><mark>当把一个函数存储到局部变量时</mark>, 就得到了一个局部函数 (local function).</p>
<p>定义局部函数:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(params)</span></span><br>    body<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>其展开为:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> f; f = functino (params)<br>    body<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h2 id="9-3-词法定界"><a href="#9-3-词法定界" class="headerlink" title="9.3 词法定界"></a>9.3 词法定界</h2><p><mark>闭包 (closure)</mark>. 即一个持有外部环境变量的函数就是闭包.</p>
<p>由于函数可以被保存在普通变量中, 因此 Lua 语言中可以轻松地重定义函数:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">do</span> <br>    <span class="hljs-keyword">local</span> oldSin = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br>    <span class="hljs-keyword">local</span> k = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">pi</span> / <span class="hljs-number">180</span><br>    <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span></span><br>        <span class="hljs-keyword">return</span> oldSin(x * k)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h1 id="10-模式匹配"><a href="#10-模式匹配" class="headerlink" title="10 模式匹配"></a>10 模式匹配</h1><h2 id="10-1-模式匹配相关函数"><a href="#10-1-模式匹配相关函数" class="headerlink" title="10.1 模式匹配相关函数"></a>10.1 模式匹配相关函数</h2><p>字符串标准库提供的 4 个函数:</p>
<ul>
<li><code>find</code></li>
<li><code>gsub</code> (global substitute)</li>
<li><code>match</code></li>
<li><code>gmatch</code> (global match)</li>
</ul>
<h3 id="10-1-1-string-find"><a href="#10-1-1-string-find" class="headerlink" title="10.1.1 string.find"></a>10.1.1 string.find</h3><p>两个参数:</p>
<ul>
<li>字符串</li>
<li>要匹配的值</li>
</ul>
<p>两个可选参数:</p>
<ul>
<li>第三个, 整数, 从那里开始的索引</li>
<li>第四个, 布尔值, 是否进行简单搜索</li>
</ul>
<p>匹配成功返回两个值:</p>
<ul>
<li>模式开始位置的索引</li>
<li>模式结束位置的索引</li>
</ul>
<p>没找到任何匹配, 返回 <code>nil</code>.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">s = <span class="hljs-string">&quot;hello world&quot;</span><br>i, j = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(s, <span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="10-1-2-string-match"><a href="#10-1-2-string-match" class="headerlink" title="10.1.2 string.match"></a>10.1.2 string.match</h3><p>和 <code>string.find</code> 类似, 但是返回字符串.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">match</span>(<span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-string">&quot;hellow&quot;</span>))    <span class="hljs-comment">--&gt; hello</span><br></code></pre></td></tr></table></figure>
<h3 id="10-1-3-string-gsub"><a href="#10-1-3-string-gsub" class="headerlink" title="10.1.3 string.gsub"></a>10.1.3 string.gsub</h3><p>3 个必选参数:</p>
<ul>
<li>目标字符串</li>
<li>模式</li>
<li>替换字符串</li>
</ul>
<p>1 个可选参数:</p>
<ul>
<li>替换次数</li>
</ul>
<p>两个返回值:</p>
<ul>
<li>替换后的字符串</li>
<li>替换的次数</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">s = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">gsub</span>(<span class="hljs-string">&quot;Lua is cute&quot;</span>, <span class="hljs-string">&quot;cute&quot;</span>, <span class="hljs-string">&quot;great&quot;</span>)<br><span class="hljs-built_in">print</span>(s)    <span class="hljs-comment">--&gt; Lua is great</span><br></code></pre></td></tr></table></figure>

<h3 id="10-1-4-string-gmatch"><a href="#10-1-4-string-gmatch" class="headerlink" title="10.1.4 string.gmatch"></a>10.1.4 string.gmatch</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">s = <span class="hljs-string">&quot;some string&quot;</span><br>words = &#123;&#125;<br><span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">string</span>.<span class="hljs-built_in">gmatch</span>(s, <span class="hljs-string">&quot;%a+&quot;</span>) <span class="hljs-keyword">do</span><br>    words[#words + <span class="hljs-number">1</span>] = w<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h1 id="12-日期和时间"><a href="#12-日期和时间" class="headerlink" title="12 日期和时间"></a>12 日期和时间</h1><p>Lua 标准库提供了两个用于操作日期和时间的函数. 和 C 标准库中提供相同的功能.</p>
<h1 id="14-数据结构"><a href="#14-数据结构" class="headerlink" title="14 数据结构"></a>14 数据结构</h1><p>Lua 中的表并不是一种数据结构, 它们是其他数据结构的基础.</p>
<h2 id="14-1-数组"><a href="#14-1-数组" class="headerlink" title="14.1 数组"></a>14.1 数组</h2><p>如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> a = &#123;&#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span> <span class="hljs-keyword">do</span><br>    a[i] = <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">squares = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>&#125;<br></code></pre></td></tr></table></figure>

<p>这里其实可以把第一个索引值改为 <code>0</code>, 但是这样的话 <code>#</code> 以及其他标准库会出问题. </p>
<h1 id="16-编译-执行和错误"><a href="#16-编译-执行和错误" class="headerlink" title="16 编译, 执行和错误"></a>16 编译, 执行和错误</h1><p>虽然 Lua 是解释型语言 (interpreted language), 但其总是在运行代码前先预编译 (precompile) 源码为中间代码.</p>
<h2 id="16-1-编译"><a href="#16-1-编译" class="headerlink" title="16.1 编译"></a>16.1 编译</h2><p><code>dofile</code> 是一个辅助函数, <code>loadfile</code> 完成核心工作, 其从文件中加载 Lua 代码段, 然它不会运行代码, 只是编译, 将编译后的代码段作为一个函数返回.</p>
<p>可以认为:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dofile</span><span class="hljs-params">(filename)</span></span><br>    <span class="hljs-keyword">local</span> f = <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">loadfile</span>(filename))<br>    <span class="hljs-keyword">return</span> f()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>如果需要 <mark>多次运行同一个文件</mark> , 只需调用一次 loadfile 函数后再多次调用它的返回结果即可. (只编译了一次, 开销小)</p>
<p><code>load</code> 函数, 从一个字符串或函数中读取代码段:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">f = <span class="hljs-built_in">load</span>(<span class="hljs-string">&quot;i = i + 1&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>之后, 变量 <code>f</code> 就会变成一个被调用时执行 <code>i = i + 1</code> 的函数:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">i = <span class="hljs-number">0</span><br>f(); <span class="hljs-built_in">print</span>(i)   <span class="hljs-comment">--&gt; 1</span><br>f(); <span class="hljs-built_in">print</span>(i)   <span class="hljs-comment">--&gt; 2</span><br></code></pre></td></tr></table></figure>
<p>不让其变为函数, 直接运行, 则利用其返回值:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">load</span>(i = i + <span class="hljs-number">1</span>)()<br><span class="hljs-comment">-- 最好写为</span><br><span class="hljs-built_in">assert</span>(<span class="hljs-built_in">load</span>(s))()<br></code></pre></td></tr></table></figure>

<p><mark><code>load</code> 函数总是在全局环境中编译代码段</mark> 如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">i = <span class="hljs-number">32</span><br><span class="hljs-keyword">local</span> i = <span class="hljs-number">0</span><br>f = <span class="hljs-built_in">load</span>(<span class="hljs-string">&quot;i = i + 1; print(i)&quot;</span>)<br>g = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> i = i + <span class="hljs-number">1</span>; <span class="hljs-built_in">print</span>(i) <span class="hljs-keyword">end</span><br>f()     <span class="hljs-comment">--&gt; 33</span><br>g()     <span class="hljs-comment">--&gt; 1</span><br></code></pre></td></tr></table></figure>

<p><code>load</code> 函数典型用法是执行外部代码 (用户输入的代码):</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;enter your expression&quot;</span><br><span class="hljs-keyword">local</span> line = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()<br><span class="hljs-keyword">local</span> func = <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">load</span>(<span class="hljs-string">&quot;return &quot;</span> .. line))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;the value of your expression is &quot;</span> .. func())<br></code></pre></td></tr></table></figure>

<p>以下 <code>load</code> 使用和 <code>loadfile</code> 等价:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">f = <span class="hljs-built_in">load</span>(<span class="hljs-built_in">io</span>.<span class="hljs-built_in">lines</span>(filename, <span class="hljs-number">1024</span>))<br></code></pre></td></tr></table></figure>

<p>Lua 将所有独立的代码段当作匿名可编程参数的函数体, 如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">load</span>(<span class="hljs-string">&quot;a=1&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(...)</span></span> a - <span class="hljs-number">1</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p><code>load</code> 和 <code>loadfile</code> 从来不引发错误, 当有错误发生时, 它们会返回 <code>nil</code> 及错误信息. 它们只是将程序段编译为一种中间形式, 然后将结果作为匿名函数返回.</p>
<p><mark>实际上 Lua 中函数定义</mark> 是在运行时而不是在编译时发生的一种赋值操作.</p>
<h2 id="16-2-预编译的代码"><a href="#16-2-预编译的代码" class="headerlink" title="16.2 预编译的代码"></a>16.2 预编译的代码</h2><p>生成预编译文件 (即二进制文件):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ luac -o prog.lc prog.lua<br></code></pre></td></tr></table></figure>
<p>执行:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ lua prog.lc<br></code></pre></td></tr></table></figure>
<p>几乎在 Lua 中所有能够使用源码的地方都可以使用预编译代码.</p>
<p><code>luac</code> 的 <code>-l</code> 选项会列出编译器为指定代码段生成的操作码.</p>
<p>预编译形式的代码 <mark>不一定比源代码更小</mark> , 但是却加载得快.</p>
<p>预编译形式的代码的另一个好处: 避免由于意外而修改源码.</p>
<h2 id="16-3-错误"><a href="#16-3-错误" class="headerlink" title="16.3 错误"></a>16.3 错误</h2><p>显式调用 <code>error</code> 函数并传入一个错误信息作为参数来引发一个错误:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;enter a number:&quot;</span><br>n = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;n&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> n <span class="hljs-keyword">then</span> <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;invalid input&quot;</span>) <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>也可用 <code>assert</code> 函数完成, 其检查第一个参数是否为真, 如果为真则返回该参数, 如果为假则引发第二个参数设置的错误信息:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;enter a number:&quot;</span><br>n = <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*n&quot;</span>), <span class="hljs-string">&quot;invalid input&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>当一个函数发现某种意外的情况, 在进行异常处理 (exception handling) 时可以采取两种基本方法:</p>
<ul>
<li>返回错误代码, 如 <code>nil</code> 或 <code>false</code></li>
<li>调用 <code>error</code> 引发错误</li>
</ul>
<p><mark>原则</mark>: 容易避免的异常应该引发错误, 否则应该返回错误码.</p>
<h2 id="16-4-错误处理和异常"><a href="#16-4-错误处理和异常" class="headerlink" title="16.4 错误处理和异常"></a>16.4 错误处理和异常</h2><p>处理错误, 使用 <code>pcall</code> 函数 (protected call) 来封装代码.</p>
<p>执行一段 Lua 代码并捕获 (try-catch) 执行中发生的所有错误, 首先将这段代码封装到一个函数中, 这个函数通常是一个匿名函数, 之后通过 <code>pcall</code> 来调用这个函数:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> ok, meg = <span class="hljs-built_in">pcall</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span><br><br>    ...<br><br>    <span class="hljs-keyword">if</span> unexpected_condition <span class="hljs-keyword">then</span> <span class="hljs-built_in">error</span>() <span class="hljs-keyword">end</span><br>    some code <br>    <span class="hljs-built_in">print</span>(a[i])<br><br>    ...<br><br>    <span class="hljs-keyword">end</span>)<br><br><span class="hljs-keyword">if</span> ok <span class="hljs-keyword">then</span> <br>    regular code<br><span class="hljs-keyword">else</span> <br>    <span class="hljs-built_in">error</span>-handing code<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p><code>pcall</code> 会以一种保护模式 (protected mode) 来调用它的第1个参数, 以便捕获该函数执行中的错误. 无论错误是否有错误发生, <code>pcall</code> 都不会引发错误. </p>
<ul>
<li>没有错误, 返会 <code>true</code> 以及被调用函数的所有返回值</li>
<li>错误, 返回 <code>false</code> 及错误信息</li>
</ul>
<h2 id="16-5-错误信息和栈回溯"><a href="#16-5-错误信息和栈回溯" class="headerlink" title="16.5 错误信息和栈回溯"></a>16.5 错误信息和栈回溯</h2><p><code>error</code> 还有第 2 个可选参数 <code>level</code>.</p>
<p>当 <code>pcall</code> 返回错误信息时, 部分的调用栈已经被破坏了 (从 <code>pcall</code> 到出错之处的部分), 如果希望得到一个有意义的栈回溯, 那么就必须在函数 <code>pcall</code> 返回前先将调用栈构造好, 即使用 <code>xpcall</code> 函数.</p>
<p><code>xpcall</code> 和 <code>pcall</code> 类似, 但其第二个参数是一个消息处理函数 (message handler function)</p>
<p>当错误发生时, Lua 会在调用栈展开 (stack unwind) 前调用这个消息处理函数, 以便消息处理函数能够使用调试库来获取有关错误的更多信息.</p>
<p>两个常用的消息处理函数:</p>
<ul>
<li><code>debug.debug</code>, 提供一个 Lua 提示符让用户来检查错误发生原因</li>
<li><code>debug.traceback</code>, 使用调用栈来构造详细的错误信息</li>
</ul>
<h1 id="17-模块和包"><a href="#17-模块和包" class="headerlink" title="17 模块和包"></a>17 模块和包</h1><p><mark>从用户观点来看</mark>, 一个模块 (module) 就是一些代码 (要么是 Lua, 要么是 C), 这些代码可以通过函数 <code>require</code> 加载, 然后创建和返回一个表, 这个表就像是某种命名空间, 其中定义的内容是模块中导出的东西, 比如函数和常量.</p>
<p>如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> m = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-built_in">print</span>(m.<span class="hljs-built_in">sin</span>(<span class="hljs-number">3.14</span>))<br></code></pre></td></tr></table></figure>

<p>独立解释器会使用跟如下代码等价的方式 <mark>提前加载所有标准库</mark> </p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">math</span> = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-built_in">string</span> = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;string&quot;</span><br>...<br></code></pre></td></tr></table></figure>

<h2 id="17-1-函数-require"><a href="#17-1-函数-require" class="headerlink" title="17.1 函数 require"></a>17.1 函数 <code>require</code></h2><p>首先, <code>require</code> 函数在表 <code>package.loaded</code> 中检查模块是否已被加载:</p>
<ul>
<li>如果模块已经被加载, 函数 <code>require</code> 就返回相应的值。</li>
<li>如果模块未被加载, 函数 <code>require</code> 则搜索具有指定模块名的 Lua 文件, 搜索路径由变量 <code>package.path</code> 指定. <ul>
<li>找到了, 就用 <code>loadfile</code> 加载, 返回一个称为<mark>加载器</mark>的函数</li>
<li>没找到, 搜索相应名称的 C 标准库, (路径由 <code>package.cpath</code> 指定) 找到则使用底层函数 <code>package.loadlib</code> 进行加载, 这个底层函数会查找名为 <code>luaopen_modname</code> 的函数并返回</li>
</ul>
</li>
</ul>
<p><mark>为了最终加载模块</mark> , <code>require</code> 函数带着两个参数调用加载函数 (大多数模块会忽略):</p>
<ul>
<li>模块名</li>
<li>加载函数所在文件的名称</li>
</ul>
<p>如果加载函数有返回值, 那么函数 <code>require</code> 会返回这个值, 然后保存在表 <code>package.loaded</code> 中.</p>
<p>如果加载函数没有返回值且表中的 <code>package.loaded[@rep&#123;modname&#125;]</code> 为空, 函数 <code>require</code> 就假设模块的返回值是 <code>true</code>.</p>
<h3 id="17-1-1-模块重命名"><a href="#17-1-1-模块重命名" class="headerlink" title="17.1.1 模块重命名"></a>17.1.1 模块重命名</h3><p>对于 Lua 语言模块: 写该 <code>.lua</code> 文件的文件名即可.</p>
<p>对于 C 标准库的二进制目标代码中 <code>luaopen_*</code> 函数的名称, 使用 <mark>连字符技巧</mark> (见书, 不是很懂) </p>
<h3 id="17-1-2-搜索路径"><a href="#17-1-2-搜索路径" class="headerlink" title="17.1.2 搜索路径"></a>17.1.2 搜索路径</h3><p><code>require</code> 使用的路径是一组模板, 将 <code>?</code> 替换为文件名来查找, 会一个一个尝试, 模板之间用 <code>;</code> 分隔, 如一组模板为:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">?;?.lua;c:\windows\?;/usr/<span class="hljs-keyword">local</span>/lua/?/?.lua<br></code></pre></td></tr></table></figure>

<p>该值存储在 <code>package.path</code> 变量中.</p>
<p>则 <code>require &quot;sql&quot;</code> 会尝试打开:</p>
<ul>
<li><code>sql</code></li>
<li><code>sql.lua</code></li>
<li><code>c:\windows\sql</code></li>
<li><code>/usr/local/lua/sql/sql.lua</code></li>
</ul>
<p>当 <code>package</code> 模块被初始化后, 它就把变量 <code>package.path</code> 设置成环境变量 <code>LUA_PATH_5_3</code> 的值, 未定义则尝试 <code>LUA_PATH</code>. 都未定义则使用一个编译时定义的默认路径.</p>
<p>在使用一个环境变量的值时, Lua 会将其中所有的 <code>;;</code> 替换成默认路径, 例: <code>LUA_PATH_5_3=&#39;mydir/?.lua;;&#39;</code>, 则最终路径就会是模板 <code>mydir/?.lua</code> 后跟默认路径.</p>
<p>搜索 C 标准库类似. 变量为 <code>package.cpath</code>, 环境变量为 <code>LUA_CPATH_5_3</code> 或 <code>LUA_CPATH</code></p>
<h3 id="17-1-3-搜索器"><a href="#17-1-3-搜索器" class="headerlink" title="17.1.3 搜索器"></a>17.1.3 搜索器</h3><h2 id="17-2-Lua-语言中编写模块的基本方法"><a href="#17-2-Lua-语言中编写模块的基本方法" class="headerlink" title="17.2 Lua 语言中编写模块的基本方法"></a>17.2 Lua 语言中编写模块的基本方法</h2><p><mark>创建模块的最简单方法是</mark> 创建一个表并将所有需要导出的函数放入其中, 最后返回这个表. 如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> M = &#123;&#125;    <span class="hljs-comment">-- 模块</span><br><br><span class="hljs-comment">-- 创建一个新的复数</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">new</span><span class="hljs-params">(r, i)</span></span><br>    <span class="hljs-keyword">return</span> &#123;r=r, i=i&#125;<br><span class="hljs-keyword">end</span><br><br>M.new = new     <span class="hljs-comment">-- 把 &#x27;new&#x27; 加到模块中</span><br><br><span class="hljs-comment">-- constant &#x27;i&#x27;</span><br>M.i = new(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.add</span><span class="hljs-params">(c1, c2)</span></span><br>    <span class="hljs-keyword">return</span> new(c1.r + c2.r, c1.i + c2.i)<br><span class="hljs-keyword">end</span><br><br>...<br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure>

<p>不使用 <code>return M</code> 的方式:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> M = &#123;&#125;<br><span class="hljs-built_in">package</span>.<span class="hljs-built_in">loaded</span>[...] = M<br></code></pre></td></tr></table></figure>
<p><code>require</code> 会把模块的名称作为第一个参数传给加载函数, 因此这里的 <code>...</code> 为模块名.</p>
<p>如果一个模块没有返回值, 那么 <code>require</code> 会返回 <code>package.loaded[modname]</code> 的当前值.</p>
<p><mark>另一种编写模块的方法</mark> : 把所有的函数定义为局部变量, 然后再最后返回表:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(c1, c2)</span></span><br>    <span class="hljs-keyword">return</span> new(c1.r + c2.r, c1.i + c2.i)<br><span class="hljs-keyword">end</span><br><br>...<br><br><span class="hljs-keyword">return</span> &#123;<br>    new = new,<br>    add = add,<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="17-3-子模块和包"><a href="#17-3-子模块和包" class="headerlink" title="17.3 子模块和包"></a>17.3 子模块和包</h2><p>Lua 支持具有层次结构的模块名, <mark>通过点</mark>来分隔名称中的层次.</p>
<p>当搜索一个定义子模块的文件时, <code>require</code> 会将点转换为另一个字符, 通常就是操作系统的目录分隔符.</p>
<h1 id="20-元表和元方法"><a href="#20-元表和元方法" class="headerlink" title="20 元表和元方法"></a>20 元表和元方法</h1><p><mark>元表</mark> 是一个表, 其内容是 <mark>元方法 (metamethod)</mark>如 <code>__add</code>, <code>__sub</code>, 弄成表应该是方便查询. 可以修改一个值某个操作 (加法减法之类) 的行为, 如: <code>a</code> 和 <code>b</code> 都是表, 可以通过元表定义如何计算 <code>a + b</code></p>
<p>当 Lua 语言试图将两个表相加, 它会先检查两者之一<mark>是否有元表 (metatable)</mark> 且该元表中是否有 <code>__add</code> 字段 (两个下划线). 如果 Lua 找到了该字段, 就调用该字段对应的值, 即 <mark>元方法 (metamethod)</mark> (一个函数).</p>
<p>元表只能给出预先定义的操作集合的行为, 其不支持继承.</p>
<p>Lua 中的每一个值都可以有元表.</p>
<p>用 <code>getmetatable</code> 来获取元表.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">t = &#123;&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getmetatable</span>(t))  <span class="hljs-comment">--&gt; nil</span><br></code></pre></td></tr></table></figure>

<p>可以使用函数 <code>setmetatable</code> 来设置或修改任意表的元表:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">t1 = &#123;&#125;<br><span class="hljs-built_in">setmetatable</span>(t, t1)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getmetatable</span>(t) == t1)    <span class="hljs-comment">--&gt; true</span><br></code></pre></td></tr></table></figure>

<p>Lua 中只能为表设置元表. 如果要为其他类型的值设置元表, 必须通过 C 代码或调试库完成.</p>
<p>一个表可以成为任意值的元表.</p>
<h2 id="20-1-算术运算相关的元方法"><a href="#20-1-算术运算相关的元方法" class="headerlink" title="20.1 算术运算相关的元方法"></a>20.1 算术运算相关的元方法</h2><p>示例:</p>
<p><code>set</code> 是一个类型的表 </p>
<p><code>local mt = &#123;&#125;</code> 是一个元表</p>
<p><code>setmetatable(set, mt)</code> 设置 <code>set</code> 的元表为 <code>mt</code>.</p>
<p><code>Set.union</code> 定义了 <code>set</code> 这种类型表的相加操作</p>
<p><code>mt.__add = Set.union</code> 设置元表的元方法.</p>
<p>之后 <code>set</code> 相加时如 <code>set1 + set2</code> 就会自动调用 <code>mt.__add</code> 即 <code>Set.union</code> 函数</p>
<p>每种算术运算符都有一个对应的元方法, 位操作也有元方法:</p>
<ul>
<li><code>__sub</code></li>
<li><code>__div</code></li>
<li><code>__idiv</code></li>
<li><code>__unm</code></li>
<li><code>__mod</code></li>
<li><code>__pow</code></li>
<li><code>__band</code></li>
<li><code>__bor</code></li>
<li><code>__bxor</code></li>
<li><code>__bnot</code></li>
<li><code>__shl</code></li>
<li><code>__shr</code></li>
<li><code>__concat</code><br>等.</li>
</ul>
<p><mark>Lua 查找元方法的步骤</mark> :</p>
<ul>
<li>如果第一个值有元表且元表中存在所需的元方法, 那么 Lua 就使用这个元方法, 与第二个值无关</li>
<li>如果第二个值有元表且元表中存在所需的元方法, 那么 Lua 就使用这个元方法</li>
<li>都没有则抛出异常</li>
</ul>
<h2 id="20-2-关系运算相关的元方法"><a href="#20-2-关系运算相关的元方法" class="headerlink" title="20.2 关系运算相关的元方法"></a>20.2 关系运算相关的元方法</h2><p>元表还允许指定关系运算符的含义, 其中的元方法包括:</p>
<ul>
<li><code>__eq</code> 等于</li>
<li><code>__lt</code> 小于</li>
<li><code>__le</code> 小于等于</li>
</ul>
<p>其他三个关系运算符没有单独的元方法, 因为 Lua 会将 <code>a~=b</code> 转换为 <code>not (a==b)</code>, <code>a&gt;b</code> 转换为 <code>b&lt;a</code>, <code>a&gt;=b</code> 转换为 <code>b&lt;=a</code>.</p>
<p>实现 <code>__eq</code>, <code>__le</code> 和 <code>__lt</code> 示例:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua">mt.<span class="hljs-built_in">__eq</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span></span><br>    <span class="hljs-keyword">return</span> a &lt;=b <span class="hljs-keyword">and</span> b &lt;= a<br><span class="hljs-keyword">end</span><br><br>mt.<span class="hljs-built_in">__le</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span></span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(a) <span class="hljs-keyword">do</span> <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> b[k] <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br>mt.<span class="hljs-built_in">__lt</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span></span><br>    <span class="hljs-keyword">return</span> a &lt;= b <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> (b &lt;= a)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h2 id="20-3-库定义相关的元方法"><a href="#20-3-库定义相关的元方法" class="headerlink" title="20.3 库定义相关的元方法"></a>20.3 库定义相关的元方法</h2><p>Lua 虚拟机会检测一个操作中涉及的值是否有存在对应元方法的元表, 由于元表是一个普通表, 所以任何人都可以使用它们.</p>
<p>当对值进行格式化时, 函数 <code>tostring</code> 会首先检查值是否有一个元方法 <code>__tostring</code>, 如果有, 就调用这个元方法, 将对象作为参数传给该函数, 然后把元方法的返回值作为函数 <code>tostring</code> 的返回值.</p>
<p>函数 <code>setmetatable</code> 和 <code>getmetatable</code> 用元方法来保护元表, 使用户既不能看到也不能修改元表. 需要在元表中设置 <code>__metatable</code> 字段, 则:</p>
<ul>
<li><code>getmetatable</code> 会返回这个字段的值</li>
<li><code>setmetatable</code> 会引发错误</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">mt.<span class="hljs-built_in">__metatable</span> = <span class="hljs-string">&quot;not your business&quot;</span><br></code></pre></td></tr></table></figure>

<p>当一个对象拥有 <code>__pairs</code> 元方法时, <code>pair</code> 会调用这个元方法来完成遍历.</p>
<h2 id="20-4-表相关元方法"><a href="#20-4-表相关元方法" class="headerlink" title="20.4 表相关元方法"></a>20.4 表相关元方法</h2><h3 id="20-4-1-index-元方法"><a href="#20-4-1-index-元方法" class="headerlink" title="20.4.1 __index 元方法"></a>20.4.1 <code>__index</code> 元方法</h3><p>当访问一个表中不存在的字段时会引发解释器查找一个名为 <code>__index</code> 的元方法, 如果没有这个元方法, 那么想一般情况下一样, 结果就是 <code>nil</code>, 否则, 则有这个元方法来提供最终结果.</p>
<h3 id="20-4-2-newindex-元方法"><a href="#20-4-2-newindex-元方法" class="headerlink" title="20.4.2 __newindex 元方法"></a>20.4.2 <code>__newindex</code> 元方法</h3><p>与 <code>__index</code> 类似, 但其为当对一个表中不存在的索引赋值时, 解释器就会查找 <code>__newindex</code> 元方法. 如果这个元方法存在, 那么解释器就调用它而不执行赋值.</p>
<h3 id="20-4-3-具有默认值的表"><a href="#20-4-3-具有默认值的表" class="headerlink" title="20.4.3 具有默认值的表"></a>20.4.3 具有默认值的表</h3><p>一个普通表中所有字段的默认值都是 <code>nil</code>. 可通过元表修改, 如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDefault</span> <span class="hljs-params">(t, d)</span></span><br>    <span class="hljs-keyword">local</span> mt = &#123;<span class="hljs-built_in">__index</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> d <span class="hljs-keyword">end</span>&#125;<br>    <span class="hljs-built_in">setmetatable</span>(t, mt)<br><span class="hljs-keyword">end</span><br><br>tab = &#123;x=<span class="hljs-number">10</span>, y=<span class="hljs-number">20</span>&#125;<br></code></pre></td></tr></table></figure>
<p>这个例子利用 <code>__index</code> 设置默认值, 这里传入的表 <code>t</code> 的默认值就是 <code>d</code>.</p>
<h3 id="20-4-4-跟踪对表的访问"><a href="#20-4-4-跟踪对表的访问" class="headerlink" title="20.4.4 跟踪对表的访问"></a>20.4.4 跟踪对表的访问</h3><p>由于 <code>__index</code> 和 <code>__newindex</code> 元方法都是在表中的索引不存在时才有用, 因此, <mark>捕获对一个表所有访问的唯一方式是</mark> 保持表是空的.</p>
<p>如果要监控对一个表的所有访问, 需要为真正的表<mark>创建一个代理 (proxy)</mark>. 这个代理是一个空的表, 具有用于跟踪所有访问并将访问重定向到原来的表的元方法.</p>
<p>见书.</p>
<h3 id="20-4-5-只读的表"><a href="#20-4-5-只读的表" class="headerlink" title="20.4.5 只读的表"></a>20.4.5 只读的表</h3><p>见书</p>
<h1 id="22-环境-Environment"><a href="#22-环境-Environment" class="headerlink" title="22 环境 (Environment)"></a>22 环境 (Environment)</h1><p>可以认为, Lua 把所有全局变量保存在一个<mark>称为全局环境 (global environment) 的普通表中</mark>.</p>
<p>Lua 将全局环境自身保存在全局变量 <code>_G</code> 中 (<code>_G._G</code> 与 <code>_G</code> 等价).</p>
<p>输出全局环境中全部全局变量名称:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span> (<span class="hljs-built_in">_G</span>) <span class="hljs-keyword">do</span> <span class="hljs-built_in">print</span>(n) <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h2 id="22-1-具有动态名称的全局变量"><a href="#22-1-具有动态名称的全局变量" class="headerlink" title="22.1 具有动态名称的全局变量"></a>22.1 具有动态名称的全局变量</h2><p>获取全局表中的值:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">value = <span class="hljs-built_in">_G</span>[varname]<br></code></pre></td></tr></table></figure>
<h2 id="22-2-全局变量的声明"><a href="#22-2-全局变量的声明" class="headerlink" title="22.2 全局变量的声明"></a>22.2 全局变量的声明</h2><p>Lua 中的全局变量不需要声明就可以使用.</p>
<p>检测所有对全局表中不存在键的访问:</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Lua/" class="category-chain-item">Lua</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Lua-程序设计-Notes</div>
      <div>http://example.com/2022/12/29/Lua-程序设计-Notes/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年12月29日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/12/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E9%BE%99%E4%B9%A6-Notes/" title="编译原理-龙书-Notes">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">编译原理-龙书-Notes</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/27/MySQL-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-Notes/" title="MySQL 必知必会 Notes">
                        <span class="hidden-mobile">MySQL 必知必会 Notes</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'zKurisu/comments-utterances');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Jie</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Orkarin</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
