

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="第6章 Linux 文件与目录管理6.4 文件与目录的默认权限与隐藏权限6.4.3 文件特殊权限: SUID, SGID, SBITSet UID当 s 这个标志出现在文件拥有者的 x 权限上时，此时被称为 Set UID,简称 SUID 的特殊权限. SUID 的限制与功能:  SUID 权限仅对二进制程序有效 执行者对于该程序要具有 x 的可执行权限  本权限仅在执行该程序的过程中有效 执行者">
<meta property="og:type" content="article">
<meta property="og:title" content="鸟哥的 Linux 私房菜 Notes">
<meta property="og:url" content="http://example.com/2022/08/24/%E9%B8%9F%E5%93%A5%E7%9A%84-Linux-%E7%A7%81%E6%88%BF%E8%8F%9C-Notes/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第6章 Linux 文件与目录管理6.4 文件与目录的默认权限与隐藏权限6.4.3 文件特殊权限: SUID, SGID, SBITSet UID当 s 这个标志出现在文件拥有者的 x 权限上时，此时被称为 Set UID,简称 SUID 的特殊权限. SUID 的限制与功能:  SUID 权限仅对二进制程序有效 执行者对于该程序要具有 x 的可执行权限  本权限仅在执行该程序的过程中有效 执行者">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/compress_cmd.png">
<meta property="article:published_time" content="2022-08-24T00:27:28.000Z">
<meta property="article:modified_time" content="2022-10-04T00:14:02.875Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/compress_cmd.png">
  
  
  
  <title>鸟哥的 Linux 私房菜 Notes - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jie</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/SteinsGate_all.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="鸟哥的 Linux 私房菜 Notes"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-24 08:27" pubdate>
          2022年8月24日 早上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          171 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">鸟哥的 Linux 私房菜 Notes</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第6章-Linux-文件与目录管理"><a href="#第6章-Linux-文件与目录管理" class="headerlink" title="第6章 Linux 文件与目录管理"></a>第6章 Linux 文件与目录管理</h1><h2 id="6-4-文件与目录的默认权限与隐藏权限"><a href="#6-4-文件与目录的默认权限与隐藏权限" class="headerlink" title="6.4 文件与目录的默认权限与隐藏权限"></a>6.4 文件与目录的默认权限与隐藏权限</h2><h3 id="6-4-3-文件特殊权限-SUID-SGID-SBIT"><a href="#6-4-3-文件特殊权限-SUID-SGID-SBIT" class="headerlink" title="6.4.3 文件特殊权限: SUID, SGID, SBIT"></a>6.4.3 文件特殊权限: SUID, SGID, SBIT</h3><h4 id="Set-UID"><a href="#Set-UID" class="headerlink" title="Set UID"></a>Set UID</h4><p>当 s 这个标志出现在文件拥有者的 x 权限上时，此时被称为 Set UID,简称 SUID 的特殊权限.</p>
<p>SUID 的限制与功能:</p>
<ul>
<li>SUID 权限仅对二进制程序有效</li>
<li>执行者对于该程序要具有 x 的可执行权限 </li>
<li>本权限仅在执行该程序的过程中有效</li>
<li>执行者将具有该程序拥有者的权限</li>
</ul>
<p>SUID 不能用在 shell 脚本上面，shell 脚本只是将很多的二进制文件调用执行而已.</p>
<h4 id="Set-GID"><a href="#Set-GID" class="headerlink" title="Set GID"></a>Set GID</h4><p>当 s 在用户组的 x 时则称为 Set GID (SGID), 可用 <code>ls</code> 命令查看:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l <br></code></pre></td></tr></table></figure>
<p>与 SUID 不同, SGID 可以针对文件或目录来设置。</p>
<p>如果是对文件，SGID 有如下的功能:</p>
<ul>
<li>SGID 对二进制程序有用</li>
<li>程序执行者对于该程序来说，需具备 x 的权限</li>
<li>执行者在执行的过程中将会获得该程序用户组的支持</li>
</ul>
<p>如果是对目录:</p>
<ul>
<li>用户若对于此目录有 r 与 x 的权限时，该用户能够进入此目录</li>
<li>用户在此目录下的有效用户组 (effective group) 将会变成该目录的用户组</li>
<li>若用户在此目录下具有 w 的权限，则用户建立的新文件，该新文件的用户组与此目录的用户组相同</li>
</ul>
<h4 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h4><p>目前只针对目录有效:</p>
<ul>
<li>当用户对于此目录具有 w, x 权限，即具有写入的权利</li>
<li>当用户在该目录下建立文件或目录时，仅有自己与 root 才有权限删除该文件</li>
</ul>
<h4 id="SUID-x2F-SGID-x2F-SBIT-权限设置"><a href="#SUID-x2F-SGID-x2F-SBIT-权限设置" class="headerlink" title="SUID&#x2F;SGID&#x2F;SBIT 权限设置"></a>SUID&#x2F;SGID&#x2F;SBIT 权限设置</h4><ul>
<li>4 为 SUID</li>
<li>2 为 SGID</li>
<li>1 为 SBIT<br>如: <code>chmod 4755 filename</code>.</li>
</ul>
<h1 id="第8章-文件与文件系统的压缩"><a href="#第8章-文件与文件系统的压缩" class="headerlink" title="第8章 文件与文件系统的压缩"></a>第8章 文件与文件系统的压缩</h1><p>在 Linux 下, 扩展名没有什么特殊意义.</p>
<p>很多 email 都有容量大约 25MB 每封信的限制.</p>
<h2 id="8-2-Linux-系统常见的压缩指令"><a href="#8-2-Linux-系统常见的压缩指令" class="headerlink" title="8.2 Linux 系统常见的压缩指令"></a>8.2 Linux 系统常见的压缩指令</h2><p><img src="/../img/compress_cmd.png" srcset="/img/loading.gif" lazyload alt="compress command"></p>
<p>tar 可以将很多文件 “打包” 成为一个文件.</p>
<p>单纯的 tat 只是用来打包. 现在的版本有了压缩功能.</p>
<h3 id="8-2-1-gzip-zcat-x2F-zmore-x2F-zless-x2F-zgrep"><a href="#8-2-1-gzip-zcat-x2F-zmore-x2F-zless-x2F-zgrep" class="headerlink" title="8.2.1 gzip, zcat&#x2F;zmore&#x2F;zless&#x2F;zgrep"></a>8.2.1 gzip, zcat&#x2F;zmore&#x2F;zless&#x2F;zgrep</h3><p>gzip 为了取代 compress.</p>
<p>压缩:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gzip -v 文件<br></code></pre></td></tr></table></figure>

<p>解压缩:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gzip -d 文件<br></code></pre></td></tr></table></figure>

<p>查看压缩文件的原始内容:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ zcat 文件名.gz<br></code></pre></td></tr></table></figure>
<p>还有 <code>zmore</code>, <code>zless</code>, <code>zgrep</code> 等.</p>
<p><code>-c</code> 选项和重定向搭配:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gzip -c service &gt; service.gz<br></code></pre></td></tr></table></figure>

<p><code>znew</code> 可以把 compress 命令形成的 <code>.Z</code> 文件转化成 <code>gzip</code> 格式.</p>
<h3 id="8-2-2-bzip2-bzcat-x2F-bzmore-x2F-bzless-x2F-bzgrep"><a href="#8-2-2-bzip2-bzcat-x2F-bzmore-x2F-bzless-x2F-bzgrep" class="headerlink" title="8.2.2 bzip2, bzcat&#x2F;bzmore&#x2F;bzless&#x2F;bzgrep"></a>8.2.2 bzip2, bzcat&#x2F;bzmore&#x2F;bzless&#x2F;bzgrep</h3><p>bzip2 为了取代 gzip 并提供更佳的压缩比.</p>
<p>其用法几乎和 gzip 相同.</p>
<h3 id="8-2-3-xz-xzcat-x2F-xzmore-x2F-xzless-x2F-xzgrep"><a href="#8-2-3-xz-xzcat-x2F-xzmore-x2F-xzless-x2F-xzgrep" class="headerlink" title="8.2.3 xz, xzcat&#x2F;xzmore&#x2F;xzless&#x2F;xzgrep"></a>8.2.3 xz, xzcat&#x2F;xzmore&#x2F;xzless&#x2F;xzgrep</h3><p>压缩比更高.</p>
<p>其用法和 bzip2&#x2F;xz 一样.</p>
<h2 id="8-3-打包指令-tar"><a href="#8-3-打包指令-tar" class="headerlink" title="8.3 打包指令: tar"></a>8.3 打包指令: tar</h2><p>将多个文件或目录包成一个大文件的功能, 被称为打包指令.</p>
<p>tar 并不会主动产生建立的文件名.</p>
<p><code>-f</code> 后面跟文件名. 一般将 <code>-f</code> 选项从其他选项中独立出来.</p>
<p>如压缩:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ tar -jcv -f filename.tar.bz2 +要被压缩的文件或目录<br></code></pre></td></tr></table></figure>
<p>查询:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ tar -jtv -f filename.tar.bz2<br></code></pre></td></tr></table></figure>
<p>解压:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ tar -jxv -f filename.tar.bz2 -C 想要在哪个目录解压<br></code></pre></td></tr></table></figure>
<p>有时加上 <code>-p</code> 保留原本文件的权限和属性.</p>
<p>拿掉根目录的原因是防止覆盖.</p>
<p>可以只解开 <code>.tar</code> 中的单一文件.</p>
<p>使用 <code>--exclude=</code> 参数可以不包括某个文件或目录.</p>
<p>可以仅备份比某个时间更新的文件.</p>
<h1 id="第13章-Linux-账号管理与-ACL-权限设置"><a href="#第13章-Linux-账号管理与-ACL-权限设置" class="headerlink" title="第13章 Linux 账号管理与 ACL 权限设置"></a>第13章 Linux 账号管理与 ACL 权限设置</h1><h2 id="13-1-Linux-的账号与用户组"><a href="#13-1-Linux-的账号与用户组" class="headerlink" title="13.1 Linux 的账号与用户组"></a>13.1 Linux 的账号与用户组</h2><h3 id="13-1-1-用户标识符-UID-与-GID"><a href="#13-1-1-用户标识符-UID-与-GID" class="headerlink" title="13.1.1 用户标识符: UID 与 GID"></a>13.1.1 用户标识符: UID 与 GID</h3><p>账号的 ID 与 账号的对应在 <code>/etc/passwd</code> 中。</p>
<p>每个登录的用户至少都会获取两个 ID, 一个是用户 ID (User ID, UID), 一个是用户组 ID (Group ID, GID).</p>
<h3 id="13-1-2-用户账号"><a href="#13-1-2-用户账号" class="headerlink" title="13.1.2 用户账号"></a>13.1.2 用户账号</h3><p>输入账号和密码后，系统的处理:</p>
<ol>
<li>先查找 <code>/etc/passwd</code> 里面是否有你输入的账号，如果有，则将账号对应的 UID 和 GID (在 <code>/etc/group</code> 中) 读出, 并将家目录与 Shell 设置也读出.</li>
<li>再来核对密码表。这时 Linux 会进入 <code>/etc/shadow</code> 里面找出对应的账号与 UID.</li>
<li>如果一切正常，则进入 shell 管理阶段。</li>
</ol>
<p>对 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 的详细说明可见 <code>man 5 passwd</code> 和 <code>man 5 shadow</code>.</p>
<h4 id="etc-passwd-文件结构"><a href="#etc-passwd-文件结构" class="headerlink" title="/etc/passwd 文件结构"></a><code>/etc/passwd</code> 文件结构</h4><p>有七部分内容，用 <code>:</code> 隔开:</p>
<ol>
<li>账号名称</li>
<li>密码</li>
<li>UID</li>
<li>GID</li>
<li>用户信息说明栏</li>
<li>家目录, 当账户登录时就会进入的目录</li>
<li>shell</li>
</ol>
<h4 id="etc-shadow-文件结构"><a href="#etc-shadow-文件结构" class="headerlink" title="/etc/shadow 文件结构"></a><code>/etc/shadow</code> 文件结构</h4><p>同样以 <code>:</code> 分隔，共有九个字段:</p>
<ol>
<li>账户名称</li>
<li>密码</li>
<li>最近修改密码的日期, 其计算的天数从 1971-1-1 开始</li>
<li>密码不可被修改的天数</li>
<li>密码需要重新修改的天数</li>
<li>密码需要修改期限前的警告天数</li>
<li>密码过期后的账号宽限时间</li>
<li>账号失效日期</li>
<li>保留</li>
</ol>
<p>root 密码忘记的解决办法:</p>
<ul>
<li>重新启动后进入单人维护模式</li>
<li>以 Live CD 启动后挂载根目录去修改 <code>/etc/shadow</code></li>
</ul>
<p>查看 shadow 是使用哪种加密的机制:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">authconfig --<span class="hljs-built_in">test</span> |grep hasing</span><br></code></pre></td></tr></table></figure>
<h3 id="13-1-3-关于用户组-有效与初始用户组-groups-newgr"><a href="#13-1-3-关于用户组-有效与初始用户组-groups-newgr" class="headerlink" title="13.1.3 关于用户组: 有效与初始用户组, groups, newgr"></a>13.1.3 关于用户组: 有效与初始用户组, groups, newgr</h3><p>两个文件 <code>/etc/group</code> 和 <code>/etc/gshadow</code>.</p>
<h4 id="etc-group-文件结构"><a href="#etc-group-文件结构" class="headerlink" title="/etc/group 文件结构"></a><code>/etc/group</code> 文件结构</h4><ol>
<li>组名</li>
<li>用户组密码</li>
<li>GID</li>
<li>此用户组主持的账号名称</li>
</ol>
<h4 id="有效用户组-effective-group-和初始用户组-initial-group"><a href="#有效用户组-effective-group-和初始用户组-initial-group" class="headerlink" title="有效用户组 (effective group) 和初始用户组 (initial group)"></a>有效用户组 (effective group) 和初始用户组 (initial group)</h4><p>初始用户组 (<code>/etc/passwd</code> 中的第4字段) 在用户一登录就会主动获取，不需要在 <code>/etc/group</code> 的第四个字段内写入该账号。</p>
<p>通常有效用户组的作用就是新建文件, 一个账号新建的文件，其所属用户组为有效用户组.</p>
<p>通过 <code>groups</code> 命令查看，第一个输出即为有效用户组，后面的为用户所属的其他用户组.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">groups</span></span><br></code></pre></td></tr></table></figure>
<h4 id="newgrp-有效用户组的切换"><a href="#newgrp-有效用户组的切换" class="headerlink" title="newgrp: 有效用户组的切换"></a>newgrp: 有效用户组的切换</h4><p>你想要切换的用户组必须是你已经有支持的用户组。</p>
<p>这个命令可以修改目前用户的有效用户组，而且使用另一个 shell 提供此功能。用户的环境设置不会有影响，但是其用户组权限会重新计算。</p>
<h4 id="etc-gshadow-文件结构"><a href="#etc-gshadow-文件结构" class="headerlink" title="/etc/gshadow 文件结构"></a><code>/etc/gshadow</code> 文件结构</h4><ol>
<li>组名</li>
<li>密码栏</li>
<li>用户组管理员账号</li>
<li>有加入该用户组支持的所属账号<br>gshadow 的最大功能是建立用户组管理员。</li>
</ol>
<h2 id="13-2-账号管理"><a href="#13-2-账号管理" class="headerlink" title="13.2 账号管理"></a>13.2 账号管理</h2><h3 id="13-2-1-新增与删除用户-useradd-相关配置文件，passwd-usermod-userdel"><a href="#13-2-1-新增与删除用户-useradd-相关配置文件，passwd-usermod-userdel" class="headerlink" title="13.2.1 新增与删除用户: useradd, 相关配置文件，passwd, usermod, userdel"></a>13.2.1 新增与删除用户: useradd, 相关配置文件，passwd, usermod, userdel</h3><h4 id="useradd-参考文件"><a href="#useradd-参考文件" class="headerlink" title="useradd 参考文件"></a>useradd 参考文件</h4><p>useradd 的默认值查看:</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># useradd -D</span><br></code></pre></td></tr></table></figure>
<p>其内容位于 <code>/etc/default/useradd</code></p>
<h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># passwd</span><br></code></pre></td></tr></table></figure>
<p>后面不接账号就是修改自己的密码。</p>
<p>利用 standard input 建立用户的密码:</p>
<h4 id="change"><a href="#change" class="headerlink" title="change"></a>change</h4><p>显示纤细的密码参数:</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># change -l 账号名</span><br></code></pre></td></tr></table></figure>
<h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>对账号设置进行调整.</p>
<h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>删除用户的相关数据。</p>
<h3 id="13-2-2-用户功能"><a href="#13-2-2-用户功能" class="headerlink" title="13.2.2 用户功能"></a>13.2.2 用户功能</h3><h4 id="chsh"><a href="#chsh" class="headerlink" title="chsh"></a>chsh</h4><p>change shell 的简写。<br>选项及参数:</p>
<ul>
<li><code>-l</code>, 列出目前系统上可用的 shell</li>
<li><code>-s</code>, 设置修改自己的 shell<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;abc543cc&quot;</span> | passwd --stdin vbird2</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-4-用户身份切换"><a href="#13-4-用户身份切换" class="headerlink" title="13.4 用户身份切换"></a>13.4 用户身份切换</h2><h3 id="13-4-1-su"><a href="#13-4-1-su" class="headerlink" title="13.4.1 su"></a>13.4.1 su</h3><p>单纯使用 <code>su -</code> 代表使用 <code>login-shell</code> 的变量文件读取方式登录系统, 若使用者名称没有加上去, 则代表切换为 root 的身份.</p>
<p>若要完整地切换到新用户的环境, 必须要使用 <code>su - username</code> 或 <code>su -l username</code>, 才会连同 PATH, USER, MAIL 等变量都转换成新用户的环境.</p>
<h3 id="13-4-2-sudo"><a href="#13-4-2-sudo" class="headerlink" title="13.4.2 sudo"></a>13.4.2 sudo</h3><p>仅有 <code>/etc/sudoers</code> 文件下的用户才能使用 <code>sudo</code>.</p>
<h1 id="第14章-磁盘配额-Quota-与高级文件系统管理"><a href="#第14章-磁盘配额-Quota-与高级文件系统管理" class="headerlink" title="第14章 磁盘配额 (Quota) 与高级文件系统管理"></a>第14章 磁盘配额 (Quota) 与高级文件系统管理</h1><h2 id="14-1-磁盘配额-Quota-的应用与实践"><a href="#14-1-磁盘配额-Quota-的应用与实践" class="headerlink" title="14.1 磁盘配额 (Quota) 的应用与实践"></a>14.1 磁盘配额 (Quota) 的应用与实践</h2><p>Quota 用于限制用户对磁盘的使用容量.</p>
<h3 id="14-1-1-什么是磁盘配额"><a href="#14-1-1-什么是磁盘配额" class="headerlink" title="14.1.1 什么是磁盘配额"></a>14.1.1 什么是磁盘配额</h3><h4 id="磁盘配额的一般用途"><a href="#磁盘配额的一般用途" class="headerlink" title="磁盘配额的一般用途"></a>磁盘配额的一般用途</h4><ul>
<li>针对网站服务器</li>
<li>针对邮件服务器</li>
<li>针对文件服务器</li>
<li>限制某一用户组所能使用的最大磁盘配额</li>
<li>限制某一用户所能使用的最大磁盘配额</li>
<li>限制某一目录 (directory) 的最大磁盘配额</li>
</ul>
<p><code>du</code> 命令会计算目录的磁盘使用率.</p>
<h4 id="磁盘配额的使用限制"><a href="#磁盘配额的使用限制" class="headerlink" title="磁盘配额的使用限制"></a>磁盘配额的使用限制</h4><ul>
<li>ext 文件系统仅能针对整个文件系统, xfs 可以使用 project 模式来设计不同目录的磁盘配额</li>
<li>内核必须支持磁盘配额</li>
<li>只对一般身份用户有效</li>
<li>若启用 SELinux, 非所有目录均可设置磁盘配额, 其会加强某些特殊的权限控制，默认情况下仅能针对 &#x2F;home 进行设置</li>
</ul>
<p>磁盘配额可以管理 block 和 inode, 限制 inode 的使用量即管理用户可以建立的文件数量.</p>
<p>hard 和 soft 限制:</p>
<ul>
<li>hard, 不能超过</li>
<li>soft, 有 grace time<br>hard 值一般高于 soft 值。 默认的 soft 值为 7 天.</li>
</ul>
<h3 id="14-1-2-一个-xfs-文件系统的磁盘配额实践范例"><a href="#14-1-2-一个-xfs-文件系统的磁盘配额实践范例" class="headerlink" title="14.1.2 一个 xfs 文件系统的磁盘配额实践范例"></a>14.1.2 一个 xfs 文件系统的磁盘配额实践范例</h3><h3 id="14-1-3-实践磁盘配额流程-1-：文件系统的支持与查看"><a href="#14-1-3-实践磁盘配额流程-1-：文件系统的支持与查看" class="headerlink" title="14.1.3 实践磁盘配额流程 -1 ：文件系统的支持与查看"></a>14.1.3 实践磁盘配额流程 -1 ：文件系统的支持与查看</h3><p>不要在根目录下进行磁盘配额设置.</p>
<h1 id="第15章-计划任务-crontab"><a href="#第15章-计划任务-crontab" class="headerlink" title="第15章 计划任务(crontab)"></a>第15章 计划任务(crontab)</h1><h2 id="15-1-什么是计划任务"><a href="#15-1-什么是计划任务" class="headerlink" title="15.1 什么是计划任务"></a>15.1 什么是计划任务</h2><h3 id="15-1-1-Linux-计划任务的种类-at-cron"><a href="#15-1-1-Linux-计划任务的种类-at-cron" class="headerlink" title="15.1.1 Linux 计划任务的种类: at, cron"></a>15.1.1 Linux 计划任务的种类: at, cron</h3><ul>
<li>at, 处理仅执行一次就结束的任务，即突发性任务, 需 atd 服务</li>
<li>cron, 所设置的任务会循环的执行，即例行任务，每隔一段时间就执行，需 crond 服务</li>
</ul>
<h2 id="15-2-仅执行一次的计划任务"><a href="#15-2-仅执行一次的计划任务" class="headerlink" title="15.2 仅执行一次的计划任务"></a>15.2 仅执行一次的计划任务</h2><h3 id="15-2-1-atd-的启动和-at-的运行方式"><a href="#15-2-1-atd-的启动和-at-的运行方式" class="headerlink" title="15.2.1 atd 的启动和 at 的运行方式"></a>15.2.1 atd 的启动和 at 的运行方式</h3><p>在 Ubuntu 下安装 atd 服务:</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">sudo apt update<br>sudo apt <span class="hljs-keyword">install </span><span class="hljs-built_in">at</span><br></code></pre></td></tr></table></figure>
<p>手动启动:</p>
<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl restart atd<br>sudo <span class="hljs-params">system</span>ctl enable atd<br>sudo <span class="hljs-params">system</span>ctl status atd<br></code></pre></td></tr></table></figure>
<h4 id="at-的运行方式"><a href="#at-的运行方式" class="headerlink" title="at 的运行方式"></a>at 的运行方式</h4><p>使用 <code>at</code> 命令来产生所要运行的任务，并以文本文件的方式写入 <code>/var/spool/at</code> 目录内等待 atd 服务的执行。</p>
<p>可以利用 <code>/etc/at.allow</code> 和 <code>/etc/at.deny</code> 两个文件实现对 at 的限制。</p>
<p>添加后的工作情况为:</p>
<ol>
<li>先找寻 <code>/etc/at.allow</code> 文件，写在这个文件的用户才能使用 at</li>
<li>如果 <code>/etc/at.allow</code> 文件不存在，则找寻 <code>/etc/at.deny</code> 文件，写在 <code>/etc/at.deny</code> 中的用户不能使用 at</li>
<li>如果两个文件都不存在，那么只有 root 用户可以使用 at 命令</li>
</ol>
<p>不希望某些用户使用 at，就将那个用户的账号写入 <code>/etc/at.deny</code>, 一个账号写一行。</p>
<h3 id="15-2-2-实际运行单一计划任务"><a href="#15-2-2-实际运行单一计划任务" class="headerlink" title="15.2.2 实际运行单一计划任务"></a>15.2.2 实际运行单一计划任务</h3><p>使用:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">at <span class="hljs-selector-attr">[-mldv]</span> <span class="hljs-selector-tag">TIME</span><br></code></pre></td></tr></table></figure>
<p>at 命令的选项和参数:</p>
<ul>
<li>-m : 应该是 mail, 当 at 的任务完成后，即便没有输出信息，也会发送 email 通知</li>
<li>-l : 应该是 list, <code>at -l</code> 相当于 <code>atq</code>, 列出目前系统上所有该使用者的 at 计划</li>
<li>-d : 应该是 delete, <code>at -d</code> 相当于 <code>atrm</code>, 可以取消一个在 <code>at</code> 计划中的任务</li>
<li>-c : 应该是 code, 可以列出后面接的该项任务的实际命令内容</li>
</ul>
<p>最重要的是 <code>TIME</code> 参数, 其格式为:</p>
<ul>
<li>HH:MM</li>
<li>HH:MM YYYY-MM-DD</li>
<li>HH:MM[am|pm] [Mouth] [Date]</li>
<li>HH:MM[am|pm] + number [minutes|hours|days|weeks]<br>可以有 <code>now + ...</code> 方式。</li>
</ul>
<p>使用 at 时会进入 at shell 的环境执行命令，所以命令最好用绝对路径。</p>
<p>at 的执行和终端环境无关，如果要显示 Hello:</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;Hello&quot;</span> &gt; <span class="hljs-regexp">/dev/</span>tty1<br></code></pre></td></tr></table></figure>
<p>即通过终端设备处理.</p>
<p>由于 at 计划任务的使用，系统会将该项 at 任务独立出你的 bash 环境，直接交给系统的 atd 程序来接管。</p>
<h4 id="at-任务的管理"><a href="#at-任务的管理" class="headerlink" title="at 任务的管理"></a>at 任务的管理</h4><p>使用 <code>atq</code> 查询，<code>atrm</code> 删除。</p>
<h4 id="batch-系统有空时才执行后台任务"><a href="#batch-系统有空时才执行后台任务" class="headerlink" title="batch: 系统有空时才执行后台任务"></a>batch: 系统有空时才执行后台任务</h4><p>batch 命令也是调用 at 来执行。</p>
<p>它是在 CPU 任务负载小于 0.8 时才执行你的任务。</p>
<p>任务负载，即 CPU 在单一时间点所负责的任务数量, 而不是 CPU 的使用率。</p>
<p>CPU 的任务负载大，代表 CPU 必须要在不同的任务之间执行频繁的任务切换。</p>
<p>不论是 crontab 还是 at, 其最小单位都是分钟，即它们的任务都是”每分钟检查一次”来处理。</p>
<h2 id="15-3-循环执行的计划任务"><a href="#15-3-循环执行的计划任务" class="headerlink" title="15.3 循环执行的计划任务"></a>15.3 循环执行的计划任务</h2><h3 id="15-3-1-用户的设置"><a href="#15-3-1-用户的设置" class="headerlink" title="15.3.1 用户的设置"></a>15.3.1 用户的设置</h3><p>建立循环任务需使用 <code>crontab</code> 这个命令。</p>
<p>配置文件有:</p>
<ul>
<li><code>/etc/cron.allow</code></li>
<li><code>/etc/cron.deny</code><br>前者的优先级同样高于后者。</li>
</ul>
<p>使用 <code>crontab</code> 建立计划任务之后，该项任务会被记录到 <code>/var/spool/cron/dmtsai</code> 中。<code>cron</code> 每执行一项任务都会被记录到 <code>/var/log/cron</code> 这个日志文件中。</p>
<p>语法:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">crontab [-u username] [-l|<span class="hljs-type">-e</span>|<span class="hljs-type">-r</span>]<br></code></pre></td></tr></table></figure>
<p>选项和参数:</p>
<ul>
<li>-u : 只有 root 才能执行这个任务，或者帮其他使用者建立&#x2F;删除 crontab 任务</li>
<li>-e : edit, 编辑 crontab 任务内容</li>
<li>-l : list, 查看 crontab 任务内容</li>
<li>-r : remove, 删除所有的 crontab 任务内容，若仅删除一项，使用 <code>-e</code> 选项<br>每项任务(即每行)都有六个字段:</li>
<li>分钟, 0~59</li>
<li>小时, 0~23</li>
<li>日期, 1~31</li>
<li>月份, 1~12</li>
<li>周, 0~7</li>
<li>命令<br>几个特殊字符:</li>
<li><code>*</code>, 任何时候</li>
<li><code>,</code>, 分隔时段</li>
<li><code>-</code>, 一段时间</li>
<li><code>/n</code>, 每隔 n 个单位</li>
</ul>
<h3 id="15-3-2-系统的配置文件"><a href="#15-3-2-系统的配置文件" class="headerlink" title="15.3.2 系统的配置文件"></a>15.3.2 系统的配置文件</h3><p><code>crontab -e</code> 这个 crontab 是 <code>/usr/bin/crontab</code> 这个可执行文件。</p>
<p><code>/etc/crontab</code> 是一个文本文件。</p>
<p>cron 会每分钟去读取一次 <code>/etc/crontab</code> 和 <code>/var/spool/cron</code> 文件。</p>
<p>由于 cron 是读取到内存当中，所以在修改完 <code>/etc/crontab</code> 这个文件后，可能不会立即执行，这个时候需要重启 crond 服务: <code>sudo systemctl restart crond</code>.</p>
<h3 id="15-3-3-一些注意事项"><a href="#15-3-3-一些注意事项" class="headerlink" title="15.3.3 一些注意事项"></a>15.3.3 一些注意事项</h3><h2 id="15-4-可唤醒停机期间的工作任务"><a href="#15-4-可唤醒停机期间的工作任务" class="headerlink" title="15.4 可唤醒停机期间的工作任务"></a>15.4 可唤醒停机期间的工作任务</h2><p><code>anacron</code> 命令，执行时间到了但却没有执行的计划任务。也就是说, 过了 crontab 需要执行任务的时间, 但是由于各种原因 crontab 并没有执行, anacron 就会检测到这类没有被执行的任务, 并执行.</p>
<h3 id="15-4-1-什么是-anacron"><a href="#15-4-1-什么是-anacron" class="headerlink" title="15.4.1 什么是 anacron"></a>15.4.1 什么是 anacron</h3><p>anacron 也是每小时被 crond 执行一次，然后 anacron 再去检测相关的计划任务有没有被执行，如果有超过期限的任务在，就执行该任务，执行完毕或无需执行任何任务时，anacron 就停止。</p>
<h1 id="第16章-进程管理与-SELinux-初探"><a href="#第16章-进程管理与-SELinux-初探" class="headerlink" title="第16章 进程管理与 SELinux 初探"></a>第16章 进程管理与 SELinux 初探</h1><p>Linux  得程序通常称为 fork-and-exec 的流程。</p>
<p>进程都会借由父进程以复制 (fork) 的方式产生一个一模一样的子进程，然后被复制出来的子进程再以 exec 的方式执行实际要执行的进程，最终就成为一个子进程。</p>
<p>常驻在内存当中的进程通常都是负责一些系统所提供的功能以服务用户的各项任务，因此这些常驻程序就被称为: 服务 (daemon).</p>
<h2 id="16-1-2-Linux-的多人多任务环境"><a href="#16-1-2-Linux-的多人多任务环境" class="headerlink" title="16.1.2 Linux 的多人多任务环境"></a>16.1.2 Linux 的多人多任务环境</h2><p>在 Linux 下执行一个命令时，系统会将相关的权限、属性、进程代码与数据等均加载到内存，并基于这些进程一个进程标识符(PID), 最终该命令可以执行的任务则与这个 PID 的权限有关。</p>
<h3 id="多重登录环境的七个基本终端界面"><a href="#多重登录环境的七个基本终端界面" class="headerlink" title="多重登录环境的七个基本终端界面"></a>多重登录环境的七个基本终端界面</h3><p>Linux 会默认启动六个终端登录环境的进程。</p>
<h2 id="16-2-任务管理-job-control"><a href="#16-2-任务管理-job-control" class="headerlink" title="16.2 任务管理 (job control)"></a>16.2 任务管理 (job control)</h2><h3 id="16-2-1-什么是任务管理"><a href="#16-2-1-什么是任务管理" class="headerlink" title="16.2.1 什么是任务管理"></a>16.2.1 什么是任务管理</h3><p>放入后台的任务是不可以用 <code>ctrl + c</code> 终止的。</p>
<h3 id="16-2-2-job-control-的管理"><a href="#16-2-2-job-control-的管理" class="headerlink" title="16.2.2 job control 的管理"></a>16.2.2 job control 的管理</h3><p>bash 只能够管理自己的任务而不能管理其他 bash 的任务。</p>
<p>在命令后加上 <code>&amp;</code> 代表将该命令丢到后台中，此时 bash 会给予这个命令一个任务号码 (job number).</p>
<p>利用数据流重定向处理输出信息:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ tar -zpcvf <span class="hljs-regexp">/tmp/</span>tec.tar.gz <span class="hljs-regexp">/etc &gt; /</span>tmp/log.txt <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> &amp;<br></code></pre></td></tr></table></figure>
<h4 id="将目前任务丢到后台中暂停-–-ctrl-z"><a href="#将目前任务丢到后台中暂停-–-ctrl-z" class="headerlink" title="将目前任务丢到后台中暂停 – ctrl + z"></a>将目前任务丢到后台中暂停 – ctrl + z</h4><p>默认情况下，使用 [ctrl+z] 丢到后台的程序都是暂停状态。</p>
<h4 id="查看目前后台任务状态"><a href="#查看目前后台任务状态" class="headerlink" title="查看目前后台任务状态"></a>查看目前后台任务状态</h4><p>使用 <code>jobs</code> 命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">jobs</span> [-lrs]</span><br></code></pre></td></tr></table></figure>
<p>几个参数:</p>
<ul>
<li>-l : 除了列出 job number 与命令串外，同时列出 PID 号码</li>
<li>-r : 仅列出正在后台 run 的任务</li>
<li>-s : 仅列出正在后台 stop 的任务<br>使用 <code>jobs -l</code> 后，观察 <code>+</code> <code>-</code> 号，其中 <code>+</code> 代表默认的使用任务，也就是说仅输入 <code>fg</code> 就会被拿到前台中来处理.</li>
</ul>
<h4 id="将后台任务拿到前台处理：-fg"><a href="#将后台任务拿到前台处理：-fg" class="headerlink" title="将后台任务拿到前台处理： fg"></a>将后台任务拿到前台处理： fg</h4><p>fg 即 foreground.</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">fg %</span>jobnumber<br></code></pre></td></tr></table></figure>
<p><code>jobnumber</code> 是任务号码，前面的 <code>%</code> 可有可无。</p>
<h4 id="让任务在后台下的状态变成运行中-bg"><a href="#让任务在后台下的状态变成运行中-bg" class="headerlink" title="让任务在后台下的状态变成运行中: bg"></a>让任务在后台下的状态变成运行中: bg</h4><p>让 <code>Stopped</code> 的任务变为 <code>Running</code>.</p>
<h4 id="管理后台当中的任务：kill"><a href="#管理后台当中的任务：kill" class="headerlink" title="管理后台当中的任务：kill"></a>管理后台当中的任务：kill</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">kill</span> <span class="hljs-literal">-signal</span> %jobnumber<br><span class="hljs-variable">$</span> <span class="hljs-built_in">kill</span> <span class="hljs-literal">-l</span><br></code></pre></td></tr></table></figure>
<p>选项和参数:</p>
<ul>
<li>-l : 列出目前 kill 能够使用的信号 (signal) 有哪些</li>
<li>signal : 代表给予后面接的那个任务什么样的指示，可以用 <code>man 7 signal</code> 查询</li>
<li>-1 : 重新读取一次参数的配置文件</li>
<li>-2 : 代表由键盘输入 [ctrl]-c 同样的操作</li>
<li>-9 : 立即强制删除一个任务</li>
<li>-15 : 以正常方式终止一项任务</li>
</ul>
<h3 id="16-2-3-脱机管理问题"><a href="#16-2-3-脱机管理问题" class="headerlink" title="16.2.3 脱机管理问题"></a>16.2.3 脱机管理问题</h3><p>任务管理中的后台是 bash 的后台，而不是系统的后台。</p>
<p>使用 <code>nohup</code> 命令, 其可以在脱机或注销系统后，还能够让任务继续执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> [命令与参数] &lt;== 在终端前台中的任务</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> [命令与参数] &lt;== 在终端后台中的任务</span><br></code></pre></td></tr></table></figure>
<p><code>nohug</code> 命令并不支持 bash 的内置命令。</p>
<p>使用 <code>nohug</code> 的信息输出会被重定向到 <code>~/nohup.out</code></p>
<h2 id="16-3-进程管理"><a href="#16-3-进程管理" class="headerlink" title="16.3 进程管理"></a>16.3 进程管理</h2><h3 id="16-3-1-查看进程"><a href="#16-3-1-查看进程" class="headerlink" title="16.3.1 查看进程"></a>16.3.1 查看进程</h3><p><code>ps</code> 命令的两个常用选项:</p>
<ul>
<li><code>ps -l</code> : 查看自己 bash 的进程</li>
<li><code>ps aux</code> : 查看所有系统运行的进程</li>
</ul>
<p>一般来说 <code>ps aux</code> 会按照 PID 的顺序来排序显示。</p>
<p>如果你发现某个进程的 CMD 后面接上了 <defunct> 时，就代表该进程是僵尸进程。</p>
<h4 id="top-动态查看进程的变化"><a href="#top-动态查看进程的变化" class="headerlink" title="top : 动态查看进程的变化"></a>top : 动态查看进程的变化</h4><p>使用方式:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">$ <span class="hljs-built_in">top</span> [-d数字] | <span class="hljs-type">top</span> [-bnp]<br></code></pre></td></tr></table></figure>
<p>参数和选项:</p>
<ul>
<li><code>-d</code> : 后面接秒数，就是整个进程界面更新的秒数。默认是5秒</li>
<li><code>-b</code> : 以批量的方式执行 top, 通常搭配数据流重定向来将批量的结果输出为文件</li>
<li><code>-n</code> : 与 <code>-b</code> 搭配，表示执行几次 top 的输出结果</li>
<li><code>-p</code> : 指定某个 PID 来执行查看监测<br><code>top</code> 默认使用 CPU 使用率作为排序依据，可换。</li>
</ul>
<h4 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ pstree <span class="hljs-comment">[-A|U]</span> <span class="hljs-comment">[-up]</span><br></code></pre></td></tr></table></figure>
<p>选项与参数:</p>
<ul>
<li>-A : 各进程树之间的连接以 ASCII 的方式 </li>
<li>-U : 各进程树之间的连接以 Unicode 的方式 </li>
<li>-p : 同时列出每个进程的 PID</li>
<li>-A : 同时列出每个进程的所属账号名称</li>
</ul>
<h3 id="16-3-2-进程的管理"><a href="#16-3-2-进程的管理" class="headerlink" title="16.3.2 进程的管理"></a>16.3.2 进程的管理</h3><p>进程的管理是通过给予该进程一个信号 (signal) 去告知该进程你想要让它做什么。</p>
<p>主要信号的代号、名称及内容:</p>
<ul>
<li>1 SIGHUP 启动被终止的进程，可让该 PID 重新读取自己的配置文件</li>
<li>2 SIGINT 相当于键盘输入 [ctrl]-c 来终止一个进程</li>
<li>9 SIGKILL 强制中断一个进程的执行</li>
<li>15 SIGTERM 以正常方式结束进程的方式终止进程</li>
<li>19 SIGSTOP 相当于键盘输入 [ctrl]-z 来暂停一个进程<br>使用:<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">kill</span> <span class="hljs-literal">-signal</span> PID<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="通过命令的内容来终止进程-–-killall"><a href="#通过命令的内容来终止进程-–-killall" class="headerlink" title="通过命令的内容来终止进程 – killall"></a>通过命令的内容来终止进程 – killall</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ killall <span class="hljs-comment">[-iIe]</span> <span class="hljs-comment">[-signal]</span> <span class="hljs-comment">[command name]</span><br></code></pre></td></tr></table></figure>
<p>参数:</p>
<ul>
<li><code>-i</code> : interactive, 在删除时会出现提示字符</li>
<li><code>-I</code> : 忽略大小写</li>
<li><code>-e</code> : exact, 表示接完整命令，但不能超过 15 个字符, 如 <code>/bin.bash</code> 是完整的，<code>bash</code> 不算完整</li>
</ul>
<p>其可以将系统当中所有以某个命令启动的进程全部删除。</p>
<h3 id="16-3-3-关于进程的执行顺序"><a href="#16-3-3-关于进程的执行顺序" class="headerlink" title="16.3.3 关于进程的执行顺序"></a>16.3.3 关于进程的执行顺序</h3><p>需考虑进程的优先级 (priority) 和 CPU 调度。</p>
<h4 id="Priority-和-Nice-值"><a href="#Priority-和-Nice-值" class="headerlink" title="Priority 和 Nice 值"></a>Priority 和 Nice 值</h4><p>Linux 给予进程一个优先级 (Priority, PRI), PRI 值越低代表越优先.</p>
<p>如果要调整进程的优先级，就要通过 nice 值，即 NI.</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">PRI <span class="hljs-comment">(new)</span> = PRI <span class="hljs-comment">(old)</span> + <span class="hljs-symbol">NI</span><br></code></pre></td></tr></table></figure>
<p>注意项:</p>
<ul>
<li>nice 值可调整范围为 -20 ~ 19</li>
<li>root 可随意调整自己或它人的进程的 nice 值，且范围为 -20 ~ 19</li>
<li>一般用户仅可调整自己进程的 nice 值，且范围为 0 ~ 19</li>
<li>一般用户仅可将 nice 值调高</li>
</ul>
<h4 id="nice-新执行的命令即给予-nice-值"><a href="#nice-新执行的命令即给予-nice-值" class="headerlink" title="nice : 新执行的命令即给予 nice 值"></a>nice : 新执行的命令即给予 nice 值</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nice</span> [-n 数字] <span class="hljs-built_in">command</span></span><br></code></pre></td></tr></table></figure>
<h4 id="renice-已存在的进程的-nice-重新调整"><a href="#renice-已存在的进程的-nice-重新调整" class="headerlink" title="renice : 已存在的进程的 nice 重新调整"></a>renice : 已存在的进程的 nice 重新调整</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ renice [<span class="hljs-built_in">number</span>] PID<br></code></pre></td></tr></table></figure>
<h3 id="16-3-4-查看系统资源信息"><a href="#16-3-4-查看系统资源信息" class="headerlink" title="16.3.4 查看系统资源信息"></a>16.3.4 查看系统资源信息</h3><ul>
<li>free，查看内存使用情况</li>
<li>uname, 查看系统与内核相关信息</li>
<li>uptime，查看系统启动时间与任务负载</li>
<li>netstat，追踪网络或 socket 文件</li>
<li>dmesg, 分析内核产生的信息</li>
<li>vmstat, 检测系统资源变化</li>
</ul>
<h2 id="16-4-特殊文件与进程"><a href="#16-4-特殊文件与进程" class="headerlink" title="16.4 特殊文件与进程"></a>16.4 特殊文件与进程</h2><h3 id="16-4-1-具有-SUID-x2F-SGID-权限的命令执行状态"><a href="#16-4-1-具有-SUID-x2F-SGID-权限的命令执行状态" class="headerlink" title="16.4.1 具有 SUID&#x2F;SGID 权限的命令执行状态"></a>16.4.1 具有 SUID&#x2F;SGID 权限的命令执行状态</h3><p>SUID 特点:</p>
<ul>
<li>SUID 权限仅对二进制程序有效</li>
<li>执行这对于该程序需要具有 x 的可执行权限</li>
<li>本权限仅在执行该程序的过程中有效 (run-time)</li>
<li>执行者将具有该程序拥有者的权限<br>查询整个系统的 SUID&#x2F;SGID 的文件:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ <span class="hljs-keyword">find</span> <span class="hljs-regexp">/ -perm /</span><span class="hljs-number">6000</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="16-4-2-proc-代表的含义"><a href="#16-4-2-proc-代表的含义" class="headerlink" title="16.4.2 /proc/* 代表的含义"></a>16.4.2 <code>/proc/*</code> 代表的含义</h3><p>进程都是在内存中的，而内存中的数据又都是写入到 <code>/proc/*</code> 这个目录下的. 主机上面的各个进程的 PID 都以目录的形式存在于 <code>/proc</code> 中。</p>
<p><code>/proc</code> 目录下的文件，相关的文件对应相关的内容。</p>
<h3 id="16-4-3-查询已使用文件或已执行进程使用的文件"><a href="#16-4-3-查询已使用文件或已执行进程使用的文件" class="headerlink" title="16.4.3 查询已使用文件或已执行进程使用的文件"></a>16.4.3 查询已使用文件或已执行进程使用的文件</h3><h4 id="fuser-借由文件-或文件系统-找出正在使用该文件的进程"><a href="#fuser-借由文件-或文件系统-找出正在使用该文件的进程" class="headerlink" title="fuser: 借由文件 (或文件系统) 找出正在使用该文件的进程"></a>fuser: 借由文件 (或文件系统) 找出正在使用该文件的进程</h4><h4 id="lsof-列出被进程所使用的文件名称"><a href="#lsof-列出被进程所使用的文件名称" class="headerlink" title="lsof: 列出被进程所使用的文件名称"></a>lsof: 列出被进程所使用的文件名称</h4><h4 id="pidof-找出某个正在执行的进程的-PID"><a href="#pidof-找出某个正在执行的进程的-PID" class="headerlink" title="pidof: 找出某个正在执行的进程的 PID"></a>pidof: 找出某个正在执行的进程的 PID</h4><h3 id="16-5-SELinux-初探"><a href="#16-5-SELinux-初探" class="headerlink" title="16.5 SELinux 初探"></a>16.5 SELinux 初探</h3><h4 id="16-5-1-什么是-SELinux"><a href="#16-5-1-什么是-SELinux" class="headerlink" title="16.5.1 什么是 SELinux"></a>16.5.1 什么是 SELinux</h4><p>SELinux 是 Security Enhanced Linux 的缩写 </p>
<h4 id="当初设计的目标：-避免资源误用"><a href="#当初设计的目标：-避免资源误用" class="headerlink" title="当初设计的目标： 避免资源误用"></a>当初设计的目标： 避免资源误用</h4><p>SELinux 是整合到内核的一个模块，更多内容可参考 <a target="_blank" rel="noopener" href="https://www.nsa.gov/what-we-do/research/selinux">链接</a></p>
<p>SELinux 是在进行进程，文件等详细权限配置时依据的一个内核模块。</p>
<h4 id="传统的文件权限与帐号的关系-自主访问控制"><a href="#传统的文件权限与帐号的关系-自主访问控制" class="headerlink" title="传统的文件权限与帐号的关系: 自主访问控制"></a>传统的文件权限与帐号的关系: 自主访问控制</h4><p>各种权限设置对 root 是无效的.</p>
<p>DAC, Discretionary Access Control, 自主访问控制, 即，当某个进程想要对文件进行读写时，系统就会根据进程的拥有者和用户组，对比文件的权限，只有通过权限检查，才可以读写文件的方式.</p>
<h4 id="以策略规则制定进程读取特定文件-强制访问控制-MAC"><a href="#以策略规则制定进程读取特定文件-强制访问控制-MAC" class="headerlink" title="以策略规则制定进程读取特定文件: 强制访问控制 (MAC)"></a>以策略规则制定进程读取特定文件: 强制访问控制 (MAC)</h4><p>MAC, Mandatory Access Control, 强制访问控制。用户的权限根据进程而定，root 所获取的权限也不一定是 root.</p>
<p>默认情况下，httpd 这个进程仅能在 <code>/var/www/</code> 这个目录下读取文件.</p>
<h4 id="16-5-2-SELinux-的运行模式"><a href="#16-5-2-SELinux-的运行模式" class="headerlink" title="16.5.2 SELinux 的运行模式"></a>16.5.2 SELinux 的运行模式</h4><ul>
<li>主体 (subject), SELinux 主要管理的就是进程</li>
<li>目标 (Object), 主体进程能否读写的目标资源一般就是文件系统.</li>
<li>策略 (Policy), 这些策略内还会有详细的规则 (rule) 来指定不同的服务是否开放某些资源的读写</li>
</ul>
<p>SELinux 的重点是保护进程读取文件系统的权限.</p>
<h1 id="第17章-认识系统服务-daemon"><a href="#第17章-认识系统服务-daemon" class="headerlink" title="第17章 认识系统服务(daemon)"></a>第17章 认识系统服务(daemon)</h1><h2 id="17-1-什么是-daemon-与服务-service"><a href="#17-1-什么是-daemon-与服务-service" class="headerlink" title="17.1 什么是 daemon 与服务(service)"></a>17.1 什么是 daemon 与服务(service)</h2><p>系统为了某些功能必须提供一些服务，这个服务就叫做 service, 完成 service 的程序叫 daemon. 也就是说, daemon 是程序，service 是功能。</p>
<p>服务的名称建立之后，在Linux 中使用时，通常在服务的名称后面加上一个 ‘d’, 这个 ‘d’ 代表的就是 daemon 的意思。</p>
<h3 id="17-1-1-早期-System-V-的-init-管理操作中-daemon-的主要分类-Optional"><a href="#17-1-1-早期-System-V-的-init-管理操作中-daemon-的主要分类-Optional" class="headerlink" title="17.1.1 早期 System V 的 init 管理操作中 daemon 的主要分类(Optional)"></a>17.1.1 早期 System V 的 init 管理操作中 daemon 的主要分类(Optional)</h3><h4 id="服务的启动、关闭与查看等方式"><a href="#服务的启动、关闭与查看等方式" class="headerlink" title="服务的启动、关闭与查看等方式"></a>服务的启动、关闭与查看等方式</h4><p>所有的服务启动脚本放置于 <code>/etc/init.d</code> 目录。</p>
<p>处理方式:</p>
<ul>
<li>启动: <code>/etc/init.d/daemon start</code></li>
<li>关闭: <code>/etc/init.d/daemon stop</code></li>
<li>重新启动: <code>/etc/init.d/daemon restart</code></li>
<li>查看状态: <code>/etc/init.d/daemon status</code></li>
</ul>
<h4 id="服务启动的分类"><a href="#服务启动的分类" class="headerlink" title="服务启动的分类"></a>服务启动的分类</h4><h4 id="服务的依赖性问题"><a href="#服务的依赖性问题" class="headerlink" title="服务的依赖性问题"></a>服务的依赖性问题</h4><h4 id="运行级别的分类"><a href="#运行级别的分类" class="headerlink" title="运行级别的分类"></a>运行级别的分类</h4><p>基本上 Linux 提供了7个运行级别, 分别是 0、1、2、3、4、5、6.</p>
<p>链接文件名(SXXdaemon)的功能为: S 为启动该服务，XX 是数字, 为启动顺序.</p>
<h4 id="制定运行级别默认要启动的服务"><a href="#制定运行级别默认要启动的服务" class="headerlink" title="制定运行级别默认要启动的服务"></a>制定运行级别默认要启动的服务</h4><p>通过以下命令操作:</p>
<ul>
<li>默认要启动: chkconfig daemon on</li>
<li>默认不启动: chkconfig daemon off </li>
<li>查看默认为启动与否: chkconfig –list daemon</li>
</ul>
<h4 id="运行级别的切换操作"><a href="#运行级别的切换操作" class="headerlink" title="运行级别的切换操作"></a>运行级别的切换操作</h4><p>从命令行界面 (runlevel3) 切换到图形界面 (runlevel5), 只需用 <code>init 5</code> 即可。</p>
<p>这里的命令行界面就是 tty 界面。Ubuntu 上也可行。</p>
<h3 id="17-1-2-systemd-使用的-unit-分类"><a href="#17-1-2-systemd-使用的-unit-分类" class="headerlink" title="17.1.2 systemd 使用的 unit 分类"></a>17.1.2 systemd 使用的 unit 分类</h3><p>旧的 init 启动脚本是”一项一项任务依序启动”的模式，速度较慢。</p>
<p>systemd 让所有服务同时启动。</p>
<p>systemd 可以兼容 init 的启动脚本，旧的 init 的启动脚本能够通过 systemd 来管理。</p>
<p>全部的 systemd 都用 systemctl 这个管理程序进行管理，而 systemctl 支持的语法有限制。</p>
<p>如果某个服务启动是管理员手动执行(即直接输入 daemon)，而不是使用 systemctl, 那么 systemd 将无法检测到该服务，无法进一步管理。</p>
<h4 id="systemd-的配置文件放置目录"><a href="#systemd-的配置文件放置目录" class="headerlink" title="systemd 的配置文件放置目录"></a>systemd 的配置文件放置目录</h4><p>systemd 将过去 daemon 执行脚本通通称为一个服务单位(unit), 每种服务单位用功能区分.</p>
<p>配置文件所在目录:</p>
<ul>
<li><code>/usr/lib/systemd/system</code>: 每个服务最主要的启动脚本设置</li>
<li><code>/run/systemd/system</code>: 系统执行过程中产生的服务脚本，其脚本的优先级高于 <code>/usr/lib/systemd/system</code> 中</li>
<li><code>/etc/systemed/system</code>: 管理员根据主机系统的需求建立的执行脚本，其优先级比 <code>/run/systemd/system</code> 高</li>
</ul>
<h4 id="systemd-的-unit-类型分类说明"><a href="#systemd-的-unit-类型分类说明" class="headerlink" title="systemd 的 unit 类型分类说明"></a>systemd 的 unit 类型分类说明</h4><p>通过扩展名判断。</p>
<h2 id="17-2-通过-systemctl-管理服务"><a href="#17-2-通过-systemctl-管理服务" class="headerlink" title="17.2 通过 systemctl 管理服务"></a>17.2 通过 systemctl 管理服务</h2><p>systemd 只有 systemctl 这个命令来处理。</p>
<h3 id="17-2-1-通过-systemctl-管理单一服务-service-unit-的启动-x2F-开机启动与查看状态"><a href="#17-2-1-通过-systemctl-管理单一服务-service-unit-的启动-x2F-开机启动与查看状态" class="headerlink" title="17.2.1 通过 systemctl 管理单一服务 (service unit) 的启动&#x2F;开机启动与查看状态"></a>17.2.1 通过 systemctl 管理单一服务 (service unit) 的启动&#x2F;开机启动与查看状态</h3><p>服务的启动一般有两个阶段:</p>
<ul>
<li>开机时要不要启动</li>
<li>现在要不要启动</li>
</ul>
<p>systemctl 命令语法:</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ systemctl <span class="hljs-comment">[command]</span> <span class="hljs-comment">[unit]</span><br></code></pre></td></tr></table></figure>
<p><code>[command]</code> 主要有:</p>
<ul>
<li>start </li>
<li>stop</li>
<li>restart</li>
<li>enable, 设置下次开机时，后面的 unit 会被启动</li>
<li>disable</li>
<li>status</li>
<li>is-active</li>
<li>is-enable</li>
</ul>
<p>不应该使用 <code>kill</code> 的方式来关闭一个正常的服务。</p>
<h1 id="第18章-认识与分析日志文件"><a href="#第18章-认识与分析日志文件" class="headerlink" title="第18章 认识与分析日志文件"></a>第18章 认识与分析日志文件</h1><h2 id="18-1-什么是日志文件"><a href="#18-1-什么是日志文件" class="headerlink" title="18.1 什么是日志文件"></a>18.1 什么是日志文件</h2><p>就是记录系统活动信息的几个文件.</p>
<h4 id="Linux-常见的日志文件名"><a href="#Linux-常见的日志文件名" class="headerlink" title="Linux 常见的日志文件名"></a>Linux 常见的日志文件名</h4><p>日志文件的权限通常是设置为仅有 root 能够读取.</p>
<p>常见的日志文件有:</p>
<ul>
<li>&#x2F;var&#x2F;log&#x2F;boot.log : 只会存储本次开机的信息</li>
<li>&#x2F;var&#x2F;log&#x2F;cron </li>
<li>&#x2F;var&#x2F;log&#x2F;dmesg</li>
<li>&#x2F;var&#x2F;log&#x2F;lastlog</li>
<li>&#x2F;var&#x2F;log&#x2F;maillog</li>
<li>&#x2F;var&#x2F;log&#x2F;messages</li>
<li>&#x2F;var&#x2F;log&#x2F;secure</li>
<li>&#x2F;var&#x2F;log&#x2F;wtmp, &#x2F;var&#x2F;log&#x2F;failing, 记录正确登录系统者的账户信息与错误登录时所使用的账户信息</li>
<li>&#x2F;var&#x2F;log&#x2F;httpd&#x2F;<em>, &#x2F;var&#x2F;log&#x2F;samba&#x2F;</em></li>
</ul>
<h4 id="日志文件所需相关服务-daemon-与程序"><a href="#日志文件所需相关服务-daemon-与程序" class="headerlink" title="日志文件所需相关服务 (daemon) 与程序"></a>日志文件所需相关服务 (daemon) 与程序</h4><p>日志文件的产生一般有两种方式:</p>
<ul>
<li>由软件开发商自行定义写入的日志文件与相关格式, 如 WWW 软件 apache</li>
<li>另 Linux 发行版提供的日志文件管理服务来统一管理</li>
</ul>
<p>可以使用 logrotate 工具来自动化处理日志文件容量与更新. 其将就的日志文件更改名字，然后建立一个空的日志文件，新的日志文件重新开始记录，旧的记录在保存一段时间之后可以自动删除.</p>
<p>针对日志文件所需的功能，需要的服务与程序有:</p>
<ul>
<li>systemd-journald.service, 最主要的信息记录者，由 systemd 提供</li>
<li>rsyslog.service, 主要收集登录系统与网络等服务的信息</li>
<li>logrotate, 日志文件的轮循功能</li>
</ul>
<p>systemd 有自己的日志文件管理服务 – systemd-journald.service. 其记录主要放在内存中。可以通过 <code>journalctl</code> 以及 <code>systemctl status unit.service</code> 来查看各个不同服务的日志文件.</p>
<h3 id="18-1-2-日志文件内容的一般格式"><a href="#18-1-2-日志文件内容的一般格式" class="headerlink" title="18.1.2 日志文件内容的一般格式"></a>18.1.2 日志文件内容的一般格式</h3><p>一般来说，系统产生的信息并记录下来的内容，都会记录这些重要内容:</p>
<ul>
<li>事件发生的日期与时间</li>
<li>发生此事件的主机名 </li>
<li>启动此事件的服务名称或命令与函数名称</li>
<li>该信息的实际内容<br>这些信息的详细度是可以更改的.</li>
</ul>
<h2 id="18-2-rsyslog-service-记录日志文件的服务"><a href="#18-2-rsyslog-service-记录日志文件的服务" class="headerlink" title="18.2 rsyslog.service: 记录日志文件的服务"></a>18.2 rsyslog.service: 记录日志文件的服务</h2><h3 id="18-2-1-rsyslog-service-的配置文件-x2F-etc-x2F-rsyslog-conf"><a href="#18-2-1-rsyslog-service-的配置文件-x2F-etc-x2F-rsyslog-conf" class="headerlink" title="18.2.1 rsyslog.service 的配置文件: &#x2F;etc&#x2F;rsyslog.conf"></a>18.2.1 rsyslog.service 的配置文件: &#x2F;etc&#x2F;rsyslog.conf</h3><p>这个文件规定了:</p>
<ul>
<li>什么服务</li>
<li>什么等级信息</li>
<li>需要被记录在哪里 (设备或文件)</li>
</ul>
<h4 id="服务名称"><a href="#服务名称" class="headerlink" title="服务名称"></a>服务名称</h4><p>rsyslogd 主要还是通过 Linux 内核提供的 syslog 相关规范来设置数据的分类.</p>
<p>每种服务所产生的数据量差异是很大的.</p>
<p>Linux 内核的 syslog 支持的服务类型主要有: (可使用 man 3 syslog 查看)</p>
<ul>
<li>0, kern</li>
<li>1, user</li>
<li>2, mail</li>
<li><ol start="3">
<li>daemon</li>
</ol>
</li>
<li>4, auth</li>
<li>5, syslog</li>
<li>6, lpr</li>
<li>7, news</li>
<li>8, uucp</li>
<li>9, cron</li>
<li>10 authpriv</li>
<li>11 ftp</li>
<li>16 ～ 23, local0 ～ local7</li>
</ul>
<h4 id="信息等级"><a href="#信息等级" class="headerlink" title="信息等级"></a>信息等级</h4><p>基本上，Linux 内核的 syslog 将信息分为 8 个主要的信息等级，根据 syslog.h 的定义，信息名称与数值的对应如下:</p>
<ul>
<li>7 debug</li>
<li>6 info</li>
<li>5 notice</li>
<li>4 warning (warn)</li>
<li>3 err (error)</li>
<li>2 crit</li>
<li>1 alert</li>
<li>0 emerg (panic)</li>
</ul>
<p>等级越靠近 0 则代表系统出现致命问题.</p>
<p>在信息等级之前还有 <code>[.=!]</code> 链接符号:</p>
<ul>
<li><code>.</code> 代表”比后面还要严重的等级(含该等级)都被记录下来”</li>
<li><code>.=</code> 代表所需要的等级就是后面接的等级</li>
<li><code>.!</code> 代表不等于，就是除了该等级外的其他等级都记录</li>
</ul>
<h4 id="信息记录的文件名或设备或主机"><a href="#信息记录的文件名或设备或主机" class="headerlink" title="信息记录的文件名或设备或主机"></a>信息记录的文件名或设备或主机</h4><p>常见的放置处:</p>
<ul>
<li>文件的绝对路径</li>
<li>打印机或其他</li>
<li>用户名称</li>
<li>远程主机</li>
<li><code>*</code> 代表目前在线的所有人</li>
</ul>
<h4 id="服务，daemon-与函数名称"><a href="#服务，daemon-与函数名称" class="headerlink" title="服务，daemon 与函数名称"></a>服务，daemon 与函数名称</h4><p>daemon 是软件.</p>
<p>service 通常是启动 daemon 的脚本设置.</p>
<h3 id="18-2-2-日志文件的安全性设置"><a href="#18-2-2-日志文件的安全性设置" class="headerlink" title="18.2.2 日志文件的安全性设置"></a>18.2.2 日志文件的安全性设置</h3><p>rsyslogd 的日志文件只要被编辑过就无法继续记录.</p>
<p>可以使用 <code>chattr</code> 增加属性来让日志文件仅能被增加而不能被删除.</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">chattr +a /<span class="hljs-keyword">var</span>/<span class="hljs-built_in">log</span>/admin.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure>
<h3 id="18-2-3-日志文件服务器的设置"><a href="#18-2-3-日志文件服务器的设置" class="headerlink" title="18.2.3 日志文件服务器的设置"></a>18.2.3 日志文件服务器的设置</h3><h2 id="18-3-日志文件的论循-logrotate"><a href="#18-3-日志文件的论循-logrotate" class="headerlink" title="18.3 日志文件的论循 (logrotate)"></a>18.3 日志文件的论循 (logrotate)</h2><h2 id="19-1-Linux-的启动流程分析"><a href="#19-1-Linux-的启动流程分析" class="headerlink" title="19.1 Linux 的启动流程分析"></a>19.1 Linux 的启动流程分析</h2><h3 id="19-1-1-启动流程一览"><a href="#19-1-1-启动流程一览" class="headerlink" title="19.1.1 启动流程一览"></a>19.1.1 启动流程一览</h3><p>Boot loader 可以指定使用哪个内核文件来启动，并实际加载到内核中解压缩与执行。此时内核就能够开始在内存中活动，并检测所有硬件信息与加载适当的驱动程序来使整台主机开始运行，等到内核检测硬件与加载驱动程序完毕后，操作系统便开始运行.</p>
<h3 id="19-1-2-BIOS-boot-loader-与-kernel-加载"><a href="#19-1-2-BIOS-boot-loader-与-kernel-加载" class="headerlink" title="19.1.2 BIOS, boot loader 与 kernel 加载"></a>19.1.2 BIOS, boot loader 与 kernel 加载</h3><p>BIOS, 无论传统 BIOS 还是 UEFI BIOS 都会被简称为 BIOS.</p>
<p>在个人计算机架构下，启动整个系统首先就要让系统去加载 BIOS (Basic Input Output System), 并通过 BIOS 程序去加载 CMOS 信息，并且借由 CMOS 内的设置取得主机的各项硬件配置. 在取得这些信息后，BIOS 会进行启动自我检测 (Power-on Self Test, POST), 然后开始执行硬件检测的初始化，并设置 PnP 设备，之后再定义出可启动的设备顺序，接下来就会开始进行设备的数据读取.</p>
<p>Boot loader 位于启动设备的第一个扇区中。</p>
<h4 id="boot-loader-的功能"><a href="#boot-loader-的功能" class="headerlink" title="boot loader 的功能"></a>boot loader 的功能</h4><p>loader 的主要功能是识别操作系统的文件格式.</p>
<p>由于不同操作系统的文件格式不一致，因此每种操作系统都有自己的 boot loader.</p>
<p>通常操作系统默认都会安装一份 loader 到它根目录所在文件系统的 boot sector 上.</p>
<p>boot loader 主要的功能如下:</p>
<ul>
<li>提供选项：用户可以选择不同的启动选项, 这也是多重引导的重要功能</li>
<li>加载内核文件: 直接指向可启动的程序区域来启动操作系统</li>
<li>转交其他 loader: 将启动管理功能转交给其他 loader 负责</li>
</ul>
<p>内核文件一般被放置在 <code>/boot</code> 里，并去名为 <code>/boot/vmlinuz</code>.</p>
<p>Linux 内核可以通过动态加载内核模块，这些模块放置在 <code>/lib/modules</code> 目录内。</p>
<p>由于模块放置到磁盘根目录内，因此启动的过程中内核必须要挂在根目录，这样才能够读取内核模块提供的加载驱动程序功能.</p>
<p>一般来说，Linux 发行版都会将非必要的功能且可以编译成为模块的内核功能，编译成为模块.</p>
<p>虚拟文件系统 (Initial RAM Filesystem) 一般使用的文件名为 <code>/boot/initrd</code> 或 <code>/boot/initramfs</code>, 这个文件可以通过 boot loader 来加载到内存中，然后这个文件会被解压缩并且在内存中模拟成一个根目录.</p>
<h3 id="19-1-3-第一个程序-systemd-及使用-default-target-进入启动程序分析"><a href="#19-1-3-第一个程序-systemd-及使用-default-target-进入启动程序分析" class="headerlink" title="19.1.3 第一个程序 systemd 及使用 default.target 进入启动程序分析"></a>19.1.3 第一个程序 systemd 及使用 default.target 进入启动程序分析</h3><p>systemd 最主要的功能就是准备软件执行的环境，包括系统的主机名，网络设置，语言设置，文件系统格式及其他服务的启动等.</p>
<p>要知道系统服务的启用流程，最简单的方法就是:</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-dependencies</span> <span class="hljs-string">graphical</span>.<span class="hljs-string">target</span><br></code></pre></td></tr></table></figure>
<h3 id="19-1-4-systemd-执行-sysinit-target-初始化系统，basic-target-准备系统"><a href="#19-1-4-systemd-执行-sysinit-target-初始化系统，basic-target-准备系统" class="headerlink" title="19.1.4 systemd 执行 sysinit.target 初始化系统，basic.target 准备系统"></a>19.1.4 systemd 执行 sysinit.target 初始化系统，basic.target 准备系统</h3><h3 id="19-1-5-systemd-启动-multi-user-target-下的服务"><a href="#19-1-5-systemd-启动-multi-user-target-下的服务" class="headerlink" title="19.1.5 systemd 启动 multi-user.target 下的服务"></a>19.1.5 systemd 启动 multi-user.target 下的服务</h3><p>各种主机服务以及提供服务器功能的网络服务的启动，大多附属与 <code>multi-user.target</code>.</p>
<p>一般服务的启动脚本设置都放在下面的目录内:</p>
<ul>
<li><code>/usr/lib/systemd/system</code> , 系统默认的服务启动脚本设置</li>
<li><code>/etc/systemd/system</code> , 管理员自己开发与设置的脚本设置</li>
</ul>
<p>将服务放到 <code>/etc/systemed/system/multi-user.target.want</code> 下就可以在启动时启动它.</p>
<p>当系统完成启动后，还想要系统额外执行某些程序的话，可以将程序命令或脚本的绝对路径名称写入到 <code>/etc/rc.d/rc.local</code> 这个文件下。 当 <code>rc.local</code> 具有可执行权限时才会被执行。</p>
<h4 id="提供-tty-界面与登录服务"><a href="#提供-tty-界面与登录服务" class="headerlink" title="提供 tty 界面与登录服务"></a>提供 tty 界面与登录服务</h4><p><code>multi-user.target</code> 下面的 <code>getty.target</code> 操作界面选项是提供 tty 界面。</p>
<p>用户登录服务也是在 <code>multi-user.target</code> 下。</p>
<h3 id="19-1-6-systemd-启动-graphical-target-下面的服务"><a href="#19-1-6-systemd-启动-graphical-target-下面的服务" class="headerlink" title="19.1.6 systemd 启动 graphical.target 下面的服务"></a>19.1.6 systemd 启动 graphical.target 下面的服务</h3><p>如果 <code>default.target</code> 是 <code>multi-user.target</code>，这个步骤就不会执行.</p>
<h3 id="19-1-7-启动过程会用到的主要配置文件"><a href="#19-1-7-启动过程会用到的主要配置文件" class="headerlink" title="19.1.7 启动过程会用到的主要配置文件"></a>19.1.7 启动过程会用到的主要配置文件</h3><p>几个常见的比较重要的配置文件:</p>
<h4 id="关于模块-etc-modprobe-d-conf-及-etc-modules-load-d-conf"><a href="#关于模块-etc-modprobe-d-conf-及-etc-modules-load-d-conf" class="headerlink" title="关于模块: /etc/modprobe.d/*.conf 及 /etc/modules-load,d/*.conf"></a>关于模块: <code>/etc/modprobe.d/*.conf</code> 及 <code>/etc/modules-load,d/*.conf</code></h4><ul>
<li><code>/etc/modprobe.d/*.conf</code> 是可以加上模块参数的位置</li>
<li><code>/etc/modules-load.d/*.conf</code> 是单纯加载模块的位置</li>
</ul>
<p><code>systemctl restart systemd-modules-load.service</code> 可重新加载模块.</p>
<h2 id="19-2-内核与内核模块"><a href="#19-2-内核与内核模块" class="headerlink" title="19.2 内核与内核模块"></a>19.2 内核与内核模块</h2><p>在整个启动的过程当中，是否能够成功驱动我们的主机的硬件设备是内核 (kernel) 的工作。</p>
<p>内核一般为压缩文件，因此在使用内核之前，就的要将它解压缩后，才能加载到内存当中.</p>
<p>内核与模块的存放位置:</p>
<ul>
<li>内核: <code>/boot/vmlinuz</code> 或 <code>/boot/vmlinuz-version</code></li>
<li>内核解压缩所需的 RAM Disk: <code>/boot/inistramfs</code> 或 <code>/boot/inistramfs-version</code></li>
<li>内核模块: <code>/lib/modules/version/kernel</code> 或 <code>/lib/modules/$(uname -r)/kernel</code></li>
<li>内核源代码: <code>/usr/src/linux</code> 或 <code>/usr/src/kernels</code> (默认不安装)</li>
</ul>
<p>添加新硬件支持:</p>
<ul>
<li>重新编译内核，并加入最新的硬件驱动程序源代码</li>
<li>将该硬件的驱动程序编译成为模块，在启动时加载该模块</li>
</ul>
<h3 id="19-2-1-内核模块与依赖性"><a href="#19-2-1-内核模块与依赖性" class="headerlink" title="19.2.1 内核模块与依赖性"></a>19.2.1 内核模块与依赖性</h3><p>检查 <code>/lib/modules/$(uname -r)/modules.dep</code> 这个文件，其记录了内核支持的模块的各项依赖性.</p>
<p>使用 <code>depmod</code> 命令之后，该程序会跑到模块标准放置目录 <code>/lib/modules/$(uname -r)/kernel</code>，并一句相关目录的定义将全部的模块读取出来分析，最终将分析的结果写入 <code>modules.dep</code> 文件中.</p>
<h4 id="19-2-2-查看内核模块"><a href="#19-2-2-查看内核模块" class="headerlink" title="19.2.2 查看内核模块"></a>19.2.2 查看内核模块</h4><p>使用 <code>lsmod</code> 命令可以查看目前内核加载了多少模块.</p>
<p>显示的内容包括:</p>
<ul>
<li>模块名称 (Module)</li>
<li>模块的大小 (Size)</li>
<li>次模块是否被其他模块所使用 (Used by)</li>
</ul>
<p>使用 <code>modinfo</code> 命令，可以查看在内核中的模块，也可以查看某个模块文件.</p>
<h3 id="19-2-3-内核模块的加载与删除"><a href="#19-2-3-内核模块的加载与删除" class="headerlink" title="19.2.3 内核模块的加载与删除"></a>19.2.3 内核模块的加载与删除</h3><p>使用 <code>modprobe</code> 这个命令来加载模块，<code>modprobe</code> 会主动查找 <code>modules.dep</code> 的内容，先解决了模块的依赖性后，才决定需要加载的模块有哪些. 其可加载也可删除.</p>
<p><code>insmod</code> 需要提供完整文件名的模块。</p>
<p>内核模块一定是 <code>.ko</code> 结尾的。</p>
<h3 id="19-2-4-内核模块的额外参数设置-etc-modprobe-d-conf"><a href="#19-2-4-内核模块的额外参数设置-etc-modprobe-d-conf" class="headerlink" title="19.2.4 内核模块的额外参数设置: /etc/modprobe.d/*.conf"></a>19.2.4 内核模块的额外参数设置: <code>/etc/modprobe.d/*.conf</code></h3><h2 id="19-3-Boot-Loader-Grub2"><a href="#19-3-Boot-Loader-Grub2" class="headerlink" title="19.3 Boot Loader: Grub2"></a>19.3 Boot Loader: Grub2</h2><h3 id="19-3-1-boot-loader-的两个-stage"><a href="#19-3-1-boot-loader-的两个-stage" class="headerlink" title="19.3.1 boot loader 的两个 stage"></a>19.3.1 boot loader 的两个 stage</h3><p>在 BIOS 读完信息后，接下来就是回到第一个启动设备的 MBR 去读取 boot loader.</p>
<p>Linux 将 boot loader 的程序代码执行与设置值加载分成两个阶段 (stage):</p>
<ul>
<li>Stage 1: 执行 boot loader 主程序, 这个主程序必须被安装在启动区，即 MBR 或启动扇区 (boot sector)</li>
<li>Stage 2: 主程序加载配置文件，通过 boot loader 加载所有配置文件与相关的环境参数文件, 一般来说，配置文件都在 <code>/boot</code> 下<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls -l <span class="hljs-regexp">/boot/g</span>rub2<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="19-3-2-grub2-的配置文件-x2F-boot-x2F-grub2-x2F-grub-cfg-初探"><a href="#19-3-2-grub2-的配置文件-x2F-boot-x2F-grub2-x2F-grub-cfg-初探" class="headerlink" title="19.3.2 grub2 的配置文件 &#x2F;boot&#x2F;grub2&#x2F;grub.cfg 初探"></a>19.3.2 grub2 的配置文件 &#x2F;boot&#x2F;grub2&#x2F;grub.cfg 初探</h3><p>grub2 的优点:</p>
<ul>
<li>识别与支持较多文件系统，并且可以使用 grub2 的主程序直接在文件系统中查找内核文件</li>
<li>启动时可以自行编辑与修改启动设置选项，类似 bash 的命令模式</li>
<li>可以动态查找配置文件，而不需要在修改配置文件后重新安装 grub2</li>
</ul>
<h4 id="磁盘与分区在-grub2-中的代号"><a href="#磁盘与分区在-grub2-中的代号" class="headerlink" title="磁盘与分区在 grub2 中的代号"></a>磁盘与分区在 grub2 中的代号</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(hd0,1)</span>     <span class="hljs-attr"># 一般的默认语法，由 grub2</span> 自动判断分区格式<br><span class="hljs-comment">(hd0,msdos1)</span>    <span class="hljs-attr"># 此磁盘的分区为传统的 MBR 模式</span><br><span class="hljs-attr">(hd0</span>,gpt<span class="hljs-number">1</span>)      <span class="hljs-attr"># 此磁盘的分区为 GPT 模式</span><br></code></pre></td></tr></table></figure>
<p>注意点:</p>
<ul>
<li>以查找顺序作为硬盘的编号 </li>
<li>第一个查找到的硬盘为 0 号，第二个为 1 号</li>
<li>每快硬盘的第一个分区代号为 1<br>由于 BIOS 可以调整磁盘的启动顺序，所以 <code>hdn</code> 的 <code>n</code> 会变.</li>
</ul>
<h3 id="19-3-3-grub2-配置文件维护-etc-default-grub-与-etc-grub-d"><a href="#19-3-3-grub2-配置文件维护-etc-default-grub-与-etc-grub-d" class="headerlink" title="19.3.3 grub2 配置文件维护 /etc/default/grub 与 /etc/grub.d"></a>19.3.3 grub2 配置文件维护 <code>/etc/default/grub</code> 与 <code>/etc/grub.d</code></h3><h3 id="19-3-4-instramfs-的重要性与建立新-initramfs-文件"><a href="#19-3-4-instramfs-的重要性与建立新-initramfs-文件" class="headerlink" title="19.3.4 instramfs 的重要性与建立新 initramfs 文件"></a>19.3.4 instramfs 的重要性与建立新 initramfs 文件</h3><p>initramfs 内所包含的模块大多是与启动过程有关，而主要以文件系统及硬盘模块为主.</p>
<p>一般来说，需要 initramfs 的时刻为:</p>
<ul>
<li>根目录所在磁盘为 SATA, USB 或 SCSI 等接口设备</li>
<li>根目录所在文件系统为 LVM, RAID 等特殊格式</li>
<li>根目录所在文件系统为非传统 Linux 支持的文件系统</li>
<li>其他必须要内核加载时提供的模块</li>
</ul>
<h3 id="19-3-5-测试与安装-grub2"><a href="#19-3-5-测试与安装-grub2" class="headerlink" title="19.3.5 测试与安装 grub2"></a>19.3.5 测试与安装 grub2</h3><h3 id="19-3-6-启动钱的额外功能修改"><a href="#19-3-6-启动钱的额外功能修改" class="headerlink" title="19.3.6 启动钱的额外功能修改"></a>19.3.6 启动钱的额外功能修改</h3><p>选项部分的画面就是 menuentry 后面的文字.</p>
<h3 id="19-3-7-关于启动画面与终端画面的图形显示方式"><a href="#19-3-7-关于启动画面与终端画面的图形显示方式" class="headerlink" title="19.3.7 关于启动画面与终端画面的图形显示方式"></a>19.3.7 关于启动画面与终端画面的图形显示方式</h3><h2 id="19-4-启动过程的问题解决"><a href="#19-4-启动过程的问题解决" class="headerlink" title="19.4 启动过程的问题解决"></a>19.4 启动过程的问题解决</h2><p>Linux 无法顺利启动时，可进入 rescue 模式去处理.</p>
<h3 id="19-4-1-忘记-root-密码的解决之道"><a href="#19-4-1-忘记-root-密码的解决之道" class="headerlink" title="19.4.1 忘记 root 密码的解决之道"></a>19.4.1 忘记 root 密码的解决之道</h3><h3 id="19-4-2-直接启动就以-root-执行-bash-的方法"><a href="#19-4-2-直接启动就以-root-执行-bash-的方法" class="headerlink" title="19.4.2 直接启动就以 root 执行 bash 的方法"></a>19.4.2 直接启动就以 root 执行 bash 的方法</h3><h1 id="第20章-基础系统设置与备份策略"><a href="#第20章-基础系统设置与备份策略" class="headerlink" title="第20章 基础系统设置与备份策略"></a>第20章 基础系统设置与备份策略</h1><h2 id="20-1-系统基本设置"><a href="#20-1-系统基本设置" class="headerlink" title="20.1 系统基本设置"></a>20.1 系统基本设置</h2><p>使用 <code>hwclock</code> 是将正确时间写入 BIOS 时间记录.</p>
<p>使用 <code>ntpdate</code> 手动校时：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ntpdate s2m<span class="hljs-selector-class">.time</span><span class="hljs-selector-class">.edu</span>.cn<br></code></pre></td></tr></table></figure>
<p><code>s2m.time.edu.cn</code> 是北京大学提供的时间服务器.</p>
<h3 id="20-1-3-语系设置"><a href="#20-1-3-语系设置" class="headerlink" title="20.1.3 语系设置"></a>20.1.3 语系设置</h3><p><code>/etc/locale.conf</code> 是语系的配置文件，可以用 <code>localectl</code> 来查看目前的系统语系:</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">localectl</span><br></code></pre></td></tr></table></figure>
<h3 id="20-1-4-防火墙建议设置"><a href="#20-1-4-防火墙建议设置" class="headerlink" title="20.1.4 防火墙建议设置"></a>20.1.4 防火墙建议设置</h3><p>防火墙是一种网络数据的过滤方式，它可以根据你服务器启动的服务来设置是否开放，也能够针对对你信任的用户开放.</p>
<p>相关设置项目:</p>
<ul>
<li>服务</li>
<li>端口</li>
<li>富规则 (rich rule)</li>
<li>接口 : 就是这个区域主要是针对那一个网卡来做规范, 如 eth0</li>
</ul>
<h2 id="20-2-服务器硬件数据的收集"><a href="#20-2-服务器硬件数据的收集" class="headerlink" title="20.2 服务器硬件数据的收集"></a>20.2 服务器硬件数据的收集</h2><h3 id="20-2-1-使用-dmidecode-查看硬件设备"><a href="#20-2-1-使用-dmidecode-查看硬件设备" class="headerlink" title="20.2.1 使用 dmidecode 查看硬件设备"></a>20.2.1 使用 dmidecode 查看硬件设备</h3><p>dmidecode 可用于查看 CPU 型号，主板型号与内存相关的型号等.</p>
<p>语法:</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">dmidecode</span> -t <span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure>
<p>选项:</p>
<ul>
<li>1 : 详细的系统信息，含主板的型号与硬件的基础信息等</li>
<li>4 : CPU 的相关信息，包括倍频，外频，内核数，内核线程数等</li>
<li>9 : 系统的相关插槽格式，包括 PCI, PCI-E 等的插槽规格说明</li>
<li>17 : 每一个内存插槽的规格，若有内存, 则列出该内存的容量与型号</li>
</ul>
<h3 id="20-2-2-硬件资源的收集与分析"><a href="#20-2-2-硬件资源的收集与分析" class="headerlink" title="20.2.2 硬件资源的收集与分析"></a>20.2.2 硬件资源的收集与分析</h3><p>内核所检测到的各项硬件设备，会被记录在 <code>/proc</code> 和 <code>/sys</code> 当中.</p>
<p><code>lspci</code>, <code>lsusb</code>, <code>iostat</code> 命令.</p>
<p><code>lspci</code> 的所有数据都是从 <code>/proc/bus/pci</code> 目录中获取。</p>
<p>在线更新对应文件:</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">update-pciids</span><br></code></pre></td></tr></table></figure>
<p><code>lostat</code> 可用 <code>sudo pacman -S sysstat</code> 来安装.</p>
<h3 id="20-2-3-了解磁盘的健康状态"><a href="#20-2-3-了解磁盘的健康状态" class="headerlink" title="20.2.3 了解磁盘的健康状态"></a>20.2.3 了解磁盘的健康状态</h3><p>smartd 服务, SMART 是 Self-Monitoring, Analysis and Reporting Technology System 的缩写.</p>
<p>需要被检测的磁盘支持 SMART 协议.</p>
<p>smartd 提供一个命令 <code>smartctl</code>.</p>
<h2 id="20-3-备份要点"><a href="#20-3-备份要点" class="headerlink" title="20.3 备份要点"></a>20.3 备份要点</h2><h3 id="20-3-1-备份数据的考虑"><a href="#20-3-1-备份数据的考虑" class="headerlink" title="20.3.1 备份数据的考虑"></a>20.3.1 备份数据的考虑</h3><h3 id="20-3-2-哪些-Linux-数据具有备份的意义"><a href="#20-3-2-哪些-Linux-数据具有备份的意义" class="headerlink" title="20.3.2 哪些 Linux 数据具有备份的意义"></a>20.3.2 哪些 Linux 数据具有备份的意义</h3><p>通常粗分为两大类:</p>
<ul>
<li>系统基本设置信息</li>
<li>类似网络服务的内容数据</li>
</ul>
<h4 id="操作系统本身需要备份的文件"><a href="#操作系统本身需要备份的文件" class="headerlink" title="操作系统本身需要备份的文件"></a>操作系统本身需要备份的文件</h4><p>主要跟 <mark>帐号与系统配置文件</mark> 有关, 包括 <code>/etc/passwd</code>, <code>/etc/shadow</code>, <code>/etc/group</code>, <code>/etc/gshadow</code> 以及 <code>/home</code> 下的用户家目录，一般将 <code>/etc</code> 目录备份下来，几乎所有的配置文件都可以被保存.</p>
<p>用户的邮件，<code>/var/spool/mail</code> 内容也需要备份.</p>
<ul>
<li><code>/etc/</code> 整个目录</li>
<li><code>/home/</code> 整个目录</li>
<li><code>/var/spool/mail/</code></li>
<li><code>/var/spool/&#123;at/cron&#125;/</code></li>
<li><code>/boot/</code></li>
<li><code>/root/</code></li>
<li><code>/usr/local/</code> 或 <code>/opt</code></li>
</ul>
<h4 id="网络服务的数据库方面"><a href="#网络服务的数据库方面" class="headerlink" title="网络服务的数据库方面"></a>网络服务的数据库方面</h4><ul>
<li>软件本身的配置文件, 如 <code>/etc/</code> 整个目录，<code>/usr/local</code> 整个目录</li>
<li>软件服务提供的数据，以 WWW 为例: <code>/var/www</code> 整个目录或 <code>/srv/www</code> 整个目录</li>
</ul>
<h4 id="推荐备份的目录"><a href="#推荐备份的目录" class="headerlink" title="推荐备份的目录"></a>推荐备份的目录</h4><ul>
<li><code>/etc/</code></li>
<li><code>/home/</code></li>
<li><code>/root/</code></li>
<li><code>/var/spool/mail/</code>, <code>/var/spool/cron/</code>, <code>/var/spool/at/</code></li>
<li><code>/var/lib/</code></li>
</ul>
<h4 id="不需要备份的目录"><a href="#不需要备份的目录" class="headerlink" title="不需要备份的目录"></a>不需要备份的目录</h4><ul>
<li>&#x2F;dev</li>
<li>&#x2F;proc, &#x2F;sys, &#x2F;run</li>
<li>&#x2F;mnt, &#x2F;media</li>
<li>&#x2F;tmp</li>
</ul>
<h2 id="20-4-备份的种类，频率与工具的选择"><a href="#20-4-备份的种类，频率与工具的选择" class="headerlink" title="20.4 备份的种类，频率与工具的选择"></a>20.4 备份的种类，频率与工具的选择</h2><h3 id="20-4-1-完备备份之累积备份-incremental-backup"><a href="#20-4-1-完备备份之累积备份-incremental-backup" class="headerlink" title="20.4.1 完备备份之累积备份 (incremental backup)"></a>20.4.1 完备备份之累积备份 (incremental backup)</h3><p>即将根目录 (&#x2F;) 整个系统都备份下来.</p>
<p>累计备份指在系统进行完第一次完整备份后，经过一段时间的运行，比较系统与备份文件之间的差异，仅备份有差异的文件.</p>
<h4 id="累积备份使用的备份软件"><a href="#累积备份使用的备份软件" class="headerlink" title="累积备份使用的备份软件"></a>累积备份使用的备份软件</h4><p>常见的有 dd, cpio, xfsdump&#x2F;sfsrestore 等.</p>
<p>dd 可以直接读取磁盘的扇区而不理会文件系统，缺点是速度较慢. 其需要使用额外的脚本程序处理.</p>
<p>xfsdump 可直接进行累积备份</p>
<p>tar 命令也可用于备份. 常配合 date 命令</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">tar -jpcvf mysql.`date +<span class="hljs-built_in">%Y</span>-<span class="hljs-built_in">%m</span>-<span class="hljs-built_in">%d</span>`.tar.bz2 /var/lib/mysql<br></code></pre></td></tr></table></figure>

<p>可将备份用脚本配合 crontab 去执行.</p>
<h3 id="20-4-2-完整备份之差异备份-Differential-backup"><a href="#20-4-2-完整备份之差异备份-Differential-backup" class="headerlink" title="20.4.2 完整备份之差异备份 (Differential backup)"></a>20.4.2 完整备份之差异备份 (Differential backup)</h3><h2 id="20-5-鸟哥的备份策略"><a href="#20-5-鸟哥的备份策略" class="headerlink" title="20.5 鸟哥的备份策略"></a>20.5 鸟哥的备份策略</h2><h1 id="第23章-X-Window-设置介绍"><a href="#第23章-X-Window-设置介绍" class="headerlink" title="第23章 X Window 设置介绍"></a>第23章 X Window 设置介绍</h1><p>Linux 上的图形用户界面模式称为 X Window System. 其对于 Linux 来说只是一个软件。</p>
<h2 id="23-1-什么是-X-Window-System"><a href="#23-1-什么是-X-Window-System" class="headerlink" title="23.1 什么是 X Window System"></a>23.1 什么是 X Window System</h2><p>名称由来, X 在英文顺序的 W(indow) 后面，有下一代的新窗口之意。因此叫做 X Window System.</p>
<h3 id="23-1-1-X-Window-System-的发展简史"><a href="#23-1-1-X-Window-System-的发展简史" class="headerlink" title="23.1.1 X Window System 的发展简史"></a>23.1.1 X Window System 的发展简史</h3><p>在 UNIX-like 上面的图形用户接口(GUI)被称为 X 或 X11.</p>
<h3 id="23-1-2-主要组件-X-Server-x2F-X-Client-x2F-Window-Manager-Display-Manager"><a href="#23-1-2-主要组件-X-Server-x2F-X-Client-x2F-Window-Manager-Display-Manager" class="headerlink" title="23.1.2 主要组件: X Server&#x2F;X Client&#x2F;Window Manager?Display Manager"></a>23.1.2 主要组件: X Server&#x2F;X Client&#x2F;Window Manager?Display Manager</h3><p>X Window System 是基于网络架构的GUI. 意思就是 X Client 从网络上获取需求，X Server 来呈现(即绘制图像)。需要网络提供数据。</p>
<p>基本可以分成 X Server 和 X Client 两个组件。</p>
<p>X Server 管理硬件，X Client 是应用程序。</p>
<p>具体内容:</p>
<ul>
<li>X Server, 负责硬件管理、屏幕绘制与提供字体功能。其管理的设备包括: 键盘、鼠标、手写板、显示器、屏幕分辨率与色彩深度、显卡(包括驱动程序)与显示字体等。<br>X Window System 是软件，有自己的配置文件，其设置与 Linux 不一定相同。</li>
</ul>
<p>每台客户端主机都需要安装 X Server, 而服务器则是提供 X Client 软件，以提供客户端绘图所需要的数据。</p>
<ul>
<li>X Client, 负责 X Server 要求的事件的处理. 其主要工作为处理来自 X Server 的操作，将该操作处理为绘图数据，再将这些绘图数据传回给 X Server. 每个 X Client 并不知道其他 X Client 的存在。</li>
</ul>
<p><mark>X Window Manager</mark>: 特殊的 X Client, 负责管理所有的 X Client 软件。</p>
<p><mark>Display Manager</mark>: 提供登录需求。如 GNOME 的 gdm(GNOME Display Manager).</p>
<h3 id="23-1-3-X-Window-System-的启动流程"><a href="#23-1-3-X-Window-System-的启动流程" class="headerlink" title="23.1.3 X Window System 的启动流程"></a>23.1.3 X Window System 的启动流程</h3><p>要启动 X Window System, 首先要启动管理硬件和绘图的 X Server, 然后才加载 X Client.</p>
<p>可在命令行输入 <code>startx</code> 来启动 X 窗口。</p>
<p>startx 是一个 shell 脚本，会主动帮忙用户建立他们的 X 所需要引用的配置文件。</p>
<p>语法:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ startx [X <span class="hljs-built_in">Client</span> 参数] -- [X <span class="hljs-built_in">Server</span> 参数]<br></code></pre></td></tr></table></figure>
<p>startx 最重要的任务是找到用户或是系统默认的 X Server 与 X Client 的配置文件。用户能通过外接参数来修改配置文件的内容。      </p>
<p>实际上启动 X 的是 xinit 这个程序，startx 仅找出设置值。</p>
<p>xinit 的语法:</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">xinit [<span class="hljs-keyword">client</span> option] -- [<span class="hljs-keyword">server</span> or <span class="hljs-keyword">display</span> option]<br></code></pre></td></tr></table></figure>

<p>默认情况下，输入 <code>startx</code> 等于 <code>xinit /etc/X11/xinit/xinitrc -- /etc/X11/xinit/xserverrc</code></p>
<p>xinit 主要在启动 X Server 和加载 X Client, 但这个 xinit 所需要的参数是由 startx 帮忙查找。</p>
<p>X 启动的时候可以指定启动的接口。</p>
<p>在 X Window System 的环境下，称 6000 端口为第 0 个显示接口，即 hostname:0. 通常写为 <code>:0</code></p>
<h3 id="23-1-4-X-启动流程测试"><a href="#23-1-4-X-启动流程测试" class="headerlink" title="23.1.4 X 启动流程测试"></a>23.1.4 X 启动流程测试</h3><h1 id="第24章-Linux-内核编译与管理"><a href="#第24章-Linux-内核编译与管理" class="headerlink" title="第24章 Linux 内核编译与管理"></a>第24章 Linux 内核编译与管理</h1><p>内核控制主机的所有硬件并提供系统所有的功能.</p>
<p>内核 (kernel) 是整个操作系统的最底层, 它负责整个硬件的驱动, 以及提供各种系统所需的内核功能, 包括防火墙功能, 是否支持 LVM 或磁盘配额等文件系统功能.</p>
<p>想要让计算机完成的工作, 都需要通过内核的帮助. 想要让计算机完成的工作, 都必须要有内核支持才可以.</p>
<p>内核本质上就是一个文件, 其包含了驱动主机各项硬件的检测程序与驱动模块.</p>
<p>这个内核文件通常被命名为 <code>vmlinuz-xxx</code>, 有时也不一定, 因为一台主机上面可以拥有多个内核文件, 只是启动的时候仅能选择一个来加载.</p>
<p>什么是内核模块 (kernel module) ? 也就是 Linux 的模块化设置, 由于硬件更新快, 需要不断添加. 将类似驱动的东西独立出内核, 编译成模块, 然后内核可以在系统正常运行的过程当中加载这个模块, 这样就能在不需要修改内核的前提下, 只需要编译出适当的模块, 并加载它.</p>
<p>模块放在 <code>/lib/modules/(uname -r)/kernel</code> 中.</p>
<h3 id="24-1-2-更新内核的目的"><a href="#24-1-2-更新内核的目的" class="headerlink" title="24.1.2 更新内核的目的"></a>24.1.2 更新内核的目的</h3><p>除了 BIOS (或 UEFI) 之外, 内核是操作系统最早被加载到内存的东西, 它包含了所有可以让硬件和软件工作的信息.</p>
<p>可重新编译内核来去除掉很多用不到的功能.</p>
<p>内核的主要工作就是管理硬件.</p>
<p>获取最新稳定版内核代码:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.kernel.org/">内核官网</a></li>
<li><a target="_blank" rel="noopener" href="http://centos.ustc.edu.cn/linux-kernel/">中科大镜像站</a></li>
<li><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/kernel/">清华大学镜像站</a></li>
</ul>
<h4 id="保存原本设置-利用-patch-升级内核源代码"><a href="#保存原本设置-利用-patch-升级内核源代码" class="headerlink" title="保存原本设置: 利用 patch 升级内核源代码"></a>保存原本设置: 利用 patch 升级内核源代码</h4><p>每次内核发布时, 除了发布完整的内核压缩文件之外, 也会发布该版本与前一版本的差异性 patch 文件. 每个内核的 patch 仅有针对前一版的内核来分析.</p>
<h3 id="24-1-5-内核源代码的解压缩-安装-查看"><a href="#24-1-5-内核源代码的解压缩-安装-查看" class="headerlink" title="24.1.5 内核源代码的解压缩, 安装, 查看"></a>24.1.5 内核源代码的解压缩, 安装, 查看</h3><p>Linux 内核文件一般建议放在 <code>/usr/src/kernels/</code> 下.</p>
<p>其中的 <code>Documentation</code> 目录下有说明.</p>
<h2 id="24-2-内核编译前的预处理与内核功能选择"><a href="#24-2-内核编译前的预处理与内核功能选择" class="headerlink" title="24.2 内核编译前的预处理与内核功能选择"></a>24.2 内核编译前的预处理与内核功能选择</h2><p>整个内核编译的重要工作就是选择你想要的功能.</p>
<h3 id="24-2-1-硬件环境查看与内核功能要求"><a href="#24-2-1-硬件环境查看与内核功能要求" class="headerlink" title="24.2.1 硬件环境查看与内核功能要求"></a>24.2.1 硬件环境查看与内核功能要求</h3><h3 id="24-2-2-保持干净源代码-make-mrproper"><a href="#24-2-2-保持干净源代码-make-mrproper" class="headerlink" title="24.2.2 保持干净源代码: make mrproper"></a>24.2.2 保持干净源代码: make mrproper</h3><p>处理掉编译过程的目标文件 (<code>*.o</code>) 以及配置文件.</p>
<p>进入内核所在目录后:</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make mrproper</span><br></code></pre></td></tr></table></figure>
<p>其会将内核功能选择文件也删除, 因此一般在内核编译之前进行这个操作.</p>
<p>删除目标文件之类的编译过程产生的中间文件:</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make clean</span> <br></code></pre></td></tr></table></figure>
<h3 id="24-2-3-开始选择内核功能"><a href="#24-2-3-开始选择内核功能" class="headerlink" title="24.2.3 开始选择内核功能"></a>24.2.3 开始选择内核功能</h3><p>内核功能的选择, 最终会在如 <code>/usr/src/kernels/linux-3.10.89/</code> 下面产生一个名为 <code>.config</code> 的隐藏文件, 这个文件就是 <code>/boot/config-xxx</code> 文件.</p>
<h4 id="常见的建立方法"><a href="#常见的建立方法" class="headerlink" title="常见的建立方法"></a>常见的建立方法</h4><p>几条命令, 具体见书</p>
<p>关于整个内核功能选择的建议:</p>
<ul>
<li>肯定内核一定要的功能, 直接编译到内核中 </li>
<li>可能在未来会用到, 那么尽量编译成模块</li>
<li>不知道功能, 保留默认值或将它编译成为模块</li>
</ul>
<h3 id="24-2-4-内核功能详细选项选择"><a href="#24-2-4-内核功能详细选项选择" class="headerlink" title="24.2.4 内核功能详细选项选择"></a>24.2.4 内核功能详细选项选择</h3><p>具体看书.</p>
<h2 id="24-3-内核的编译与安装"><a href="#24-3-内核的编译与安装" class="headerlink" title="24.3 内核的编译与安装"></a>24.3 内核的编译与安装</h2><p>我的 Archlinux 的内核源代码位于 <code>/lib/modules/5.19.12-arch1-1/kernel</code> 规则为: <code>/lib/modules/$(uname -r)/build</code> 及 <code>/lib/modules/$(uname -r)/source</code> 这两个链接文件.</p>
<p>除了 make 和 gcc 外, kernel-devel 这个软件也要安装.</p>
<p>需要了解到: 内核, 内核模块, 驱动程序模块, 内核源代码与头文件的相关性.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux/" class="category-chain-item">Linux</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>鸟哥的 Linux 私房菜 Notes</div>
      <div>http://example.com/2022/08/24/鸟哥的-Linux-私房菜-Notes/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月24日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/24/Python-%E7%9A%84-logging-%E5%BA%93/" title="Python 的 logging 库">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Python 的 logging 库</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/23/Ubuntu-%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%B7%B2%E5%BC%80%E5%90%AF%E7%9A%84%E6%9C%8D%E5%8A%A1/" title="Ubuntu 下查看已开启的服务">
                        <span class="hidden-mobile">Ubuntu 下查看已开启的服务</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
