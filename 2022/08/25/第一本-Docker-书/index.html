

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/wallhaven-j5kjgy_1920x1080.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="第1章 简介容器(container) 和 管理程序虚拟化(hypervisor virtualization) 不同:  HV, 通过中间层将一台或多台独立的机器虚拟运行于物理硬件之上 Container, 直接运行在操作系统内核之上的用户空间  容器只能运行与底层宿主机相同或相似的操作系统。 Docker 是为改变容器的复杂性。 1.1 Docker 简介Docker 是一个能够把开发的应用程">
<meta property="og:type" content="article">
<meta property="og:title" content="第一本 Docker 书">
<meta property="og:url" content="http://example.com/2022/08/25/%E7%AC%AC%E4%B8%80%E6%9C%AC-Docker-%E4%B9%A6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第1章 简介容器(container) 和 管理程序虚拟化(hypervisor virtualization) 不同:  HV, 通过中间层将一台或多台独立的机器虚拟运行于物理硬件之上 Container, 直接运行在操作系统内核之上的用户空间  容器只能运行与底层宿主机相同或相似的操作系统。 Docker 是为改变容器的复杂性。 1.1 Docker 简介Docker 是一个能够把开发的应用程">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-25T02:17:54.000Z">
<meta property="article:modified_time" content="2024-03-06T09:28:59.538Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>第一本 Docker 书 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jie</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/SteinsGate_all.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="第一本 Docker 书"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-25 10:17" pubdate>
          2022年8月25日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          151 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">第一本 Docker 书</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第1章-简介"><a href="#第1章-简介" class="headerlink" title="第1章 简介"></a>第1章 简介</h1><p>容器(container) 和 管理程序虚拟化(hypervisor virtualization) 不同:</p>
<ul>
<li>HV, 通过中间层将一台或多台独立的机器虚拟运行于物理硬件之上</li>
<li>Container, 直接运行在操作系统内核之上的用户空间</li>
</ul>
<p>容器只能运行与底层宿主机相同或相似的操作系统。</p>
<p>Docker 是为改变容器的复杂性。</p>
<h2 id="1-1-Docker-简介"><a href="#1-1-Docker-简介" class="headerlink" title="1.1 Docker 简介"></a>1.1 Docker 简介</h2><p>Docker 是一个能够把开发的应用程序自动部署到容器的开源引擎。所以说是和容器相关联。</p>
<p>Docker 在虚拟化的容器执行环境中增加了一个应用程序部署引擎。</p>
<h3 id="1-1-1-提供一个简单、轻量的建模方式"><a href="#1-1-1-提供一个简单、轻量的建模方式" class="headerlink" title="1.1.1 提供一个简单、轻量的建模方式"></a>1.1.1 提供一个简单、轻量的建模方式</h3><p>Docker 依赖于”写时复制”模型。</p>
<h3 id="1-1-2-职责的逻辑分离"><a href="#1-1-2-职责的逻辑分离" class="headerlink" title="1.1.2 职责的逻辑分离"></a>1.1.2 职责的逻辑分离</h3><h3 id="1-1-3-快速、高效的开发生命周期"><a href="#1-1-3-快速、高效的开发生命周期" class="headerlink" title="1.1.3 快速、高效的开发生命周期"></a>1.1.3 快速、高效的开发生命周期</h3><h3 id="1-1-4-鼓励使用面向服务的架构"><a href="#1-1-4-鼓励使用面向服务的架构" class="headerlink" title="1.1.4 鼓励使用面向服务的架构"></a>1.1.4 鼓励使用面向服务的架构</h3><h2 id="1-2-Docker-组件"><a href="#1-2-Docker-组件" class="headerlink" title="1.2 Docker 组件"></a>1.2 Docker 组件</h2><p>核心组件:</p>
<ul>
<li>Docker 客户端和服务器，也称为 Docker 引擎</li>
<li>Docker 镜像</li>
<li>Registry</li>
<li>Docker 容器</li>
</ul>
<h3 id="1-2-1-Docker-客户端和服务器"><a href="#1-2-1-Docker-客户端和服务器" class="headerlink" title="1.2.1 Docker 客户端和服务器"></a>1.2.1 Docker 客户端和服务器</h3><p>Docker 是一个客户端&#x2F;服务器(C&#x2F;S)架构的程序。</p>
<p>Docker 提供了一个命令行工具 docker 以及一整套 RESTFUL API 来与守护进程交互。</p>
<h3 id="1-2-2-Docker-镜像"><a href="#1-2-2-Docker-镜像" class="headerlink" title="1.2.2 Docker 镜像"></a>1.2.2 Docker 镜像</h3><p>用户基于镜像来运行自己的容器。</p>
<p>可以把镜像当做容器的”源代码”.</p>
<h3 id="1-2-3-Registry"><a href="#1-2-3-Registry" class="headerlink" title="1.2.3 Registry"></a>1.2.3 Registry</h3><p>Docker 用 Registry 来保存用户构建的镜像。</p>
<p>Registry 分为公有和私有两种。</p>
<p>可在 Docker Hub 上保存自己的私有镜像。</p>
<h3 id="1-2-4-容器"><a href="#1-2-4-容器" class="headerlink" title="1.2.4 容器"></a>1.2.4 容器</h3><p>Docker 可以帮用户构建和部署容器，用户只需要把自己的应用程序或服务打包放进容器即可。</p>
<p>Docker 容器是:</p>
<ul>
<li>一个镜像格式</li>
<li>一系列标准的操作</li>
<li>一个执行环境</li>
</ul>
<p>Docker 借鉴了集装箱的概念，集装箱运输货物，Docker 运输软件。Docker 是运输工, 对容器进行操作。</p>
<p>每个容器都包含一个软件镜像，也就是容器的”货物”.</p>
<p>所有容器都按照相同的方式将内容”装载”进去，</p>
<h2 id="1-3-能用-Docker-做什么"><a href="#1-3-能用-Docker-做什么" class="headerlink" title="1.3 能用 Docker 做什么"></a>1.3 能用 Docker 做什么</h2><p>容器可以为各种测试提供很好的沙盒环境.</p>
<h2 id="1-4-Docker-与配置管理"><a href="#1-4-Docker-与配置管理" class="headerlink" title="1.4 Docker 与配置管理"></a>1.4 Docker 与配置管理</h2><p>Docker 很轻量: 镜像是分层的，可以对其进行迅速的迭代.</p>
<p>Docker 一个显著特点就是，对不同的宿主机、应用程序和服务，可能会表现出不同的特性与架构。</p>
<h2 id="1-5-Docker-的技术组件"><a href="#1-5-Docker-的技术组件" class="headerlink" title="1.5 Docker 的技术组件"></a>1.5 Docker 的技术组件</h2><h1 id="第2章-安装-Docker"><a href="#第2章-安装-Docker" class="headerlink" title="第2章 安装 Docker"></a>第2章 安装 Docker</h1><h2 id="2-1-安装-Docker-的先决条件"><a href="#2-1-安装-Docker-的先决条件" class="headerlink" title="2.1 安装 Docker 的先决条件"></a>2.1 安装 Docker 的先决条件</h2><h2 id="2-2-在-Ubuntu-和-Debian-中安装-Docker"><a href="#2-2-在-Ubuntu-和-Debian-中安装-Docker" class="headerlink" title="2.2 在 Ubuntu 和 Debian 中安装 Docker"></a>2.2 在 Ubuntu 和 Debian 中安装 Docker</h2><h3 id="2-2-1-检查前提条件"><a href="#2-2-1-检查前提条件" class="headerlink" title="2.2.1 检查前提条件"></a>2.2.1 检查前提条件</h3><h4 id="1-内核"><a href="#1-内核" class="headerlink" title="1. 内核"></a>1. 内核</h4><p>使用:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">uname</span> -a</span><br></code></pre></td></tr></table></figure>
<p>若下载新内核，可使用命令加载新内核:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo <span class="hljs-built_in">update-grub</span><br><span class="hljs-variable">$</span> reboot<br></code></pre></td></tr></table></figure>
<h4 id="2-检查-Device-Mapper"><a href="#2-检查-Device-Mapper" class="headerlink" title="2. 检查 Device Mapper"></a>2. 检查 Device Mapper</h4><p>使用 Device Mapper 作为存储驱动。</p>
<p>Device Mapper 支持”自动精简配置”(thin-provisioning)的概念，可以在一种文件系统中存储多台虚拟设备(Docker镜像中的层).</p>
<p>确认是否安装:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ ls -l <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/misc/</span>device-mapper<br></code></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ sudo <span class="hljs-keyword">grep</span> device-mapper <span class="hljs-regexp">/proc/</span>devices<br></code></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo modprobe dm_mod<br></code></pre></td></tr></table></figure>
<h3 id="2-2-2-安装-Docker"><a href="#2-2-2-安装-Docker" class="headerlink" title="2.2.2 安装 Docker"></a>2.2.2 安装 Docker</h3><p>到<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/">官网</a>查看.</p>
<h3 id="2-2-3-Docker-与-UFW"><a href="#2-2-3-Docker-与-UFW" class="headerlink" title="2.2.3 Docker 与 UFW"></a>2.2.3 Docker 与 UFW</h3><p>UWF 即 Uncomplicated Firewall.</p>
<p>Docker 使用一个网桥来管理容器中的网络。</p>
<p>默认情况下，UFW 会丢弃所有转发的数据包，因此需要在 UFW 中启用数据包的转发.</p>
<p>修改 <code>/etc/default/ufw</code> 文件:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DEFAULT_FORWARD_POLICY</span>=<span class="hljs-string">&quot;DROP&quot;</span><br></code></pre></td></tr></table></figure>
<p>改为:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DEFAULT_FORWARD_POLICY</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span><br></code></pre></td></tr></table></figure>
<p>重新加载:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo ufw reload<br></code></pre></td></tr></table></figure>
<h2 id="2-9-Docker-守护进程"><a href="#2-9-Docker-守护进程" class="headerlink" title="2.9 Docker 守护进程"></a>2.9 Docker 守护进程</h2><p>用户可以使用 <code>docker daemon</code> 命令控制 Docker 守护进程。</p>
<p>守护进程监听 <code>/var/run/docker.sock</code> 这个 UNIX套接字文件，来获取来自客户端的 Docker 请求。</p>
<h3 id="2-9-1-配置-Docker-守护进程"><a href="#2-9-1-配置-Docker-守护进程" class="headerlink" title="2.9.1 配置 Docker 守护进程"></a>2.9.1 配置 Docker 守护进程</h3><p>用 <code>-H</code> 标志调整守护进程绑定监听接口的方式, 可以使用 <code>-H</code> 标志指定不同的网络接口和端口配置:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker daemon -H tcp:<span class="hljs-regexp">//</span><span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">2375</span><br></code></pre></td></tr></table></figure>
<p>使用 <code>-D</code> 参数来输出 Docker 守护进程的详细信息:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker daemon -D<br></code></pre></td></tr></table></figure>
<h2 id="2-10-升级-Docker"><a href="#2-10-升级-Docker" class="headerlink" title="2.10 升级 Docker"></a>2.10 升级 Docker</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo apt-<span class="hljs-built_in">get</span> update<br>$ sudo apt-<span class="hljs-built_in">get</span> install docker-engine<br></code></pre></td></tr></table></figure>
<h2 id="2-11-Docker-用户界面"><a href="#2-11-Docker-用户界面" class="headerlink" title="2.11 Docker 用户界面"></a>2.11 Docker 用户界面</h2><h1 id="第3章-Docker-入门"><a href="#第3章-Docker-入门" class="headerlink" title="第3章 Docker 入门"></a>第3章 Docker 入门</h1><h2 id="3-1-确保-Docker-已经就绪"><a href="#3-1-确保-Docker-已经就绪" class="headerlink" title="3.1 确保 Docker 已经就绪"></a>3.1 确保 Docker 已经就绪</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ sudo docker <span class="hljs-meta">info</span><br></code></pre></td></tr></table></figure>
<h2 id="3-2-运行我们的第一个容器"><a href="#3-2-运行我们的第一个容器" class="headerlink" title="3.2 运行我们的第一个容器"></a>3.2 运行我们的第一个容器</h2><p><code>docker run</code> 命令提供了 Docker 容器的创建到启动的功能。</p>
<p>可以使用 <code>docker help run</code> 获取命令列表。</p>
<p>使用 <code>man</code> 页, <code>man docker-run</code></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -i -t ubuntu <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure>
<p><code>-i</code> 参数保证容器中 STDIN 是开启的。</p>
<p><code>-t</code> 参数告诉 Docker 为要创建的容器分配一个伪 tty 终端.</p>
<p><code>ubuntu</code> 是用来告诉 Docker 基于什么镜像来创建容器，<code>ubuntu</code> 镜像是一个常备镜像，也可以称为”基础”(base) 镜像，由 Docker 公司提供，保存在 Docker Hub Registry 上。</p>
<p>Docker 会检查本地是否存在 <code>ubuntu</code> 镜像，如果没有，Docker 就会连接官方维护的 Docker Hub Registry, 查看 Docker Hub 中是否存在该镜像，Docker 一旦找到该镜像，就会下载到本地。</p>
<p>随后，Docker 在文件系统内部用这个镜像创建了一个新容器，该容器拥有自己的网络、IP地址，以及一个用来和宿主机进行通信的桥接网络接口。</p>
<p><code>/bin/bash</code> 是我们告诉 Docker 在容器中运行的命令。</p>
<h2 id="3-3-使用第一个容器"><a href="#3-3-使用第一个容器" class="headerlink" title="3.3 使用第一个容器"></a>3.3 使用第一个容器</h2><p>我进入的界面为:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@895508d7a56f</span><span class="hljs-symbol">:/</span><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure>
<p>这里 <code>root</code> 为 root 账户，<code>895508d7a56f</code> 为容器 ID(即主机名). 其为一个完整的 Ubuntu 系统。</p>
<p>获取主机名:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@895508d7a56f</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># hostname</span><br></code></pre></td></tr></table></figure>
<p>查看容器的网络配置:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@895508d7a56f</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># ip a</span><br></code></pre></td></tr></table></figure>

<p>使用 <code>exit</code> 命令可以退出容器。</p>
<p><code>docker ps -a</code> 查看当前系统中容器的列表。</p>
<p><code>docker ps -l</code> 列出最后一个运行的容器。</p>
<p>有三种方式可以唯一指定容器:</p>
<ul>
<li>短 UUID</li>
<li>长 UUID</li>
<li>名称</li>
</ul>
<h2 id="3-4-容器命名"><a href="#3-4-容器命名" class="headerlink" title="3.4 容器命名"></a>3.4 容器命名</h2><p>Docker 会为我们创建的每一个容器自动生成一个随机的名称。</p>
<p>使用 <code>--name</code> 标志来指定名称:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ sudo doker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name bob_the_container -i -t ubuntu /bin/bash</span><br></code></pre></td></tr></table></figure>
<p>一个合法的名称只能包括 <code>[a-zA-Z0-9.-]</code></p>
<p>很多 Docker 命令中，都可以用容器的名称来替代容器 ID.</p>
<p>容器的命名是唯一的。</p>
<p>用 <code>docker rm</code> 可删掉容器。</p>
<h2 id="3-5-重新启动已经停止的容器"><a href="#3-5-重新启动已经停止的容器" class="headerlink" title="3.5 重新启动已经停止的容器"></a>3.5 重新启动已经停止的容器</h2><p>启动停止的容器:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">start</span> bob_the_container <span class="hljs-comment"># 也可以使用容器 ID</span><br></code></pre></td></tr></table></figure>
<p>重新启动用 <code>docker restart</code></p>
<p>使用 <code>docker create</code> 创建一个容器但不运行它.</p>
<h2 id="3-6-附着到容器上"><a href="#3-6-附着到容器上" class="headerlink" title="3.6 附着到容器上"></a>3.6 附着到容器上</h2><p>Docker 容器重新启动的时候，会沿用 <code>docker run</code> 命令时指定的参数来运行。</p>
<p>也可以用 <code>docker attach</code> 命令重新附着到该容器的会话上:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ sudo docker attach bob_the_container<br></code></pre></td></tr></table></figure>
<h2 id="3-7-创建守护式容器"><a href="#3-7-创建守护式容器" class="headerlink" title="3.7 创建守护式容器"></a>3.7 创建守护式容器</h2><p>除交互式运行的容器(interactive container) 还有守护式容器(daemonized container), 其没有交互式会话。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run --name daemon_dave -d ubuntu <span class="hljs-regexp">/bin/</span>sh -c <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span><br></code></pre></td></tr></table></figure>
<p>使用 <code>-d</code> 参数，即放入后台运行。</p>
<h2 id="3-8-容器内部都在干些什么"><a href="#3-8-容器内部都在干些什么" class="headerlink" title="3.8 容器内部都在干些什么"></a>3.8 容器内部都在干些什么</h2><p>使用 <code>docker logs</code> 获取容器的日志.</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker logs daemon_dave<br></code></pre></td></tr></table></figure>
<p>可加入 <code>-f</code> 选项:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker logs <span class="hljs-operator">-f</span> daemon_dave<br></code></pre></td></tr></table></figure>
<p>获取最后十行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker logs --<span class="hljs-built_in">tail</span> 10 daemon_dave</span><br></code></pre></td></tr></table></figure>
<p>加上时间戳:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker logs -ft daemon_dave<br></code></pre></td></tr></table></figure>
<h2 id="3-9-Docker-日志驱动"><a href="#3-9-Docker-日志驱动" class="headerlink" title="3.9 Docker 日志驱动"></a>3.9 Docker 日志驱动</h2><p>使用 <code>--log-drive</code> 选项:</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ sudo docker run <span class="hljs-params">--log-driver=</span><span class="hljs-string">&quot;syslog&quot;</span> <span class="hljs-params">--name</span> daemon_dwayne -d ubuntu <span class="hljs-string">/bash/sh</span> -c <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span><br></code></pre></td></tr></table></figure>
<p>使用 <code>syslog</code> 时会警用 <code>docker logs</code> 命令，并将所有容器的日志输出都重定向到 <code>Syslog</code>.</p>
<p>若使用 <code>none</code> 则禁用日志。</p>
<h2 id="3-10-查看容器内的进程"><a href="#3-10-查看容器内的进程" class="headerlink" title="3.10 查看容器内的进程"></a>3.10 查看容器内的进程</h2><p>使用 <code>docker top</code> 命令:</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">$ sudo docker <span class="hljs-built_in">top</span> daemon_dave<br></code></pre></td></tr></table></figure>
<h2 id="3-11-Docker-统计信息"><a href="#3-11-Docker-统计信息" class="headerlink" title="3.11 Docker 统计信息"></a>3.11 Docker 统计信息</h2><p><code>docker stats</code> 显示一个或多个容器的统计信息:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker stats daemon_dave daemon_kate daemon_clare<br></code></pre></td></tr></table></figure>
<h2 id="3-12-在容器内部运行进程"><a href="#3-12-在容器内部运行进程" class="headerlink" title="3.12 在容器内部运行进程"></a>3.12 在容器内部运行进程</h2><p>可以再容器内运行的进程有两种类型:</p>
<ul>
<li>后台任务</li>
<li>交互式任务</li>
</ul>
<p>使用 <code>docker exec</code> 命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker <span class="hljs-built_in">exec</span> -d daemon_dave <span class="hljs-built_in">touch</span> /etc/new_config_file</span><br></code></pre></td></tr></table></figure>
<p>就是对一个正在运行的容器使用。</p>
<h2 id="3-13-停止守护式容器"><a href="#3-13-停止守护式容器" class="headerlink" title="3.13 停止守护式容器"></a>3.13 停止守护式容器</h2><p>使用 <code>docker stop</code> 命令:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ sudo docker stop daemon_dave<br></code></pre></td></tr></table></figure>
<p>交互式可以通过 <code>exit</code></p>
<p>想要快速停止某个容器，使用 <code>docker kill</code>:</p>
<p>显示最后 x 个容器:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-n</span> x<br></code></pre></td></tr></table></figure>
<h2 id="3-14-自动重启容器"><a href="#3-14-自动重启容器" class="headerlink" title="3.14 自动重启容器"></a>3.14 自动重启容器</h2><p>使用 <code>--restart</code> 标志，磨人的行为是 Docker 不会重启容器。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-built_in">run</span> <span class="hljs-attribute">--restart</span>=always --name <br></code></pre></td></tr></table></figure>
<p>另一个 <code>on-failure</code> 参数，即在退出状态码为非 0 值时重启，且可指定重启次数:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">--restart</span>=<span class="hljs-literal">on</span>-failure:<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<h2 id="3-15-深入容器"><a href="#3-15-深入容器" class="headerlink" title="3.15 深入容器"></a>3.15 深入容器</h2><p><code>docker inspect</code> 获取更多容器信息:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker inspect daemon_dave<br></code></pre></td></tr></table></figure>
<p>使用 <code>-f</code> 或 <code>--format</code> 标志选定查看结果:</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">$ sudo docker inspect --format=&#x27;</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">.State.Running</span> &#125;&#125;</span><span class="language-xml">&#x27; daemon_dave</span><br></code></pre></td></tr></table></figure>
<p>可指定多个容器.</p>
<h2 id="3-16-删除容器"><a href="#3-16-删除容器" class="headerlink" title="3.16 删除容器"></a>3.16 删除容器</h2><p>使用 <code>docker rm</code> 命令:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">rm</span> <span class="hljs-number">80430</span>f8d0921<br></code></pre></td></tr></table></figure>
<p>可传递 <code>-f</code> 参数。</p>
<p>删除所有容器:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">rm</span> `sudo docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span>`<br></code></pre></td></tr></table></figure>
<h1 id="第4章-使用-Docker-镜像和仓库"><a href="#第4章-使用-Docker-镜像和仓库" class="headerlink" title="第4章 使用 Docker 镜像和仓库"></a>第4章 使用 Docker 镜像和仓库</h1><h2 id="4-1-什么是-Docker-镜像"><a href="#4-1-什么是-Docker-镜像" class="headerlink" title="4.1 什么是 Docker 镜像"></a>4.1 什么是 Docker 镜像</h2><p>Docker 镜像是由文件系统叠加而成。</p>
<p>最低端是一个引导文件系统 bootfs.</p>
<p>当一个容器启动后，它会被移到内存中，而引导文件系统则会被卸载(unmount).</p>
<p>Docker 镜像的第二层是 root 文件系统 rootfs, 其位于引导文件系统之上。</p>
<p>Docker 利用联合加载技术(union mount), 即一次同时加载多个文件系统，但是在外面看起来只能看到一个文件系统。</p>
<p>联合加载会将各层文件系统叠加到一起，这样最终的文件系统会包含所有底层的文件和目录。</p>
<p>Docker 将这样的文件系统称为镜像。一个镜像可以放到另一个镜像的顶部。位于下面的镜像称为父镜像(parent image), 最底层的镜像称为基础镜像(base image).</p>
<p>当从一个镜像启动容器时，Docker 会在该镜像最顶层加载一个读写文件系统，我们在 Docke 中运行的程序就是在这个读写层中执行。</p>
<p>每个只读镜像层都是只读，并且以后永远不会变化。</p>
<p>写时复制(copy on write)机制，想修改一个文件，这个文件首先会从该读写层下面的只读层复制到该读写层，该文件的只读版本依然存在，但是被读写层中的该文件副本所隐藏。</p>
<h2 id="4-2-列出镜像"><a href="#4-2-列出镜像" class="headerlink" title="4.2 列出镜像"></a>4.2 列出镜像</h2><p>列出主机上可用的镜像, 使用 <code>docker images</code>:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker images<br></code></pre></td></tr></table></figure>
<p>本地镜像都保存在 Docker 宿主机的 <code>/ver/lib/docker</code> 目录下.</p>
<p>镜像从仓库下载，镜像保存在仓库中，仓库存在于 Registry 中。</p>
<p>每个镜像仓库都可以存放很多镜像.</p>
<p>使用 <code>docker pull</code> 命令来拉取仓库中的镜像。</p>
<p>可以通过在仓库名后面加上一个冒号和标签名来指定该仓库中的某一镜像:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ sudo docker <span class="hljs-built_in">run</span> -t -i <span class="hljs-comment">--name new_container ubuntu:12.04 /bin/bash</span><br></code></pre></td></tr></table></figure>
<p>一个镜像可以有多个标签。</p>
<p>Docker Hub 中有两种类型的仓库:</p>
<ul>
<li>用户仓库(user repository), 都是由 Docker 用户创建的, 其命名由用户名和仓库名两部分组成</li>
<li>顶层仓库(top-level repository), 由 Docker 内部的人来管理, 其命名只包含仓库名</li>
</ul>
<h2 id="4-3-拉取镜像"><a href="#4-3-拉取镜像" class="headerlink" title="4.3 拉取镜像"></a>4.3 拉取镜像</h2><p>如:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker pull <span class="hljs-symbol">fedora:</span><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>
<h2 id="4-4-查找镜像"><a href="#4-4-查找镜像" class="headerlink" title="4.4 查找镜像"></a>4.4 查找镜像</h2><p>使用 <code>docker search</code> 命令来查找所有 Docker Hub 上公共的可用镜像。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker search puppet<br></code></pre></td></tr></table></figure>
<h2 id="4-5-构建镜像"><a href="#4-5-构建镜像" class="headerlink" title="4.5 构建镜像"></a>4.5 构建镜像</h2><p>两种方法:</p>
<ul>
<li>docker commit</li>
<li>docker build 和 Dockerfile 文件<br>使用 <code>Dockerfile</code> 更加灵活.</li>
</ul>
<h3 id="4-5-1-创建-Docker-Hub"><a href="#4-5-1-创建-Docker-Hub" class="headerlink" title="4.5.1 创建 Docker Hub"></a>4.5.1 创建 Docker Hub</h3><p>登录到 Docker Hub, 使用 <code>docker login</code> 命令:<br><code>$ sudo docker login</code><br>用户的个人认证信息会被保存在 <code>$HOME/.docker/config.json</code> 中。</p>
<h3 id="4-5-2-用-Docker-的-commit-命令创建镜像"><a href="#4-5-2-用-Docker-的-commit-命令创建镜像" class="headerlink" title="4.5.2 用 Docker 的 commit 命令创建镜像"></a>4.5.2 用 Docker 的 commit 命令创建镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker commit 4aab3ce3cb76 jamtur01/apache2</span><br></code></pre></td></tr></table></figure>
<p><code>4aab3ce3cb76</code> 是容器的 ID, <code>jamtur01</code> 是目标镜像仓库, <code>apache2</code> 是镜像名.</p>
<p><code>docker commit</code> 提交的只是创建容器的镜像与容器的当前状态之间有差异的部分。</p>
<p>可以在提交镜像时指定更多的数据(包括标签):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker commit -m<span class="hljs-string">&quot;A new custom image&quot;</span> -a<span class="hljs-string">&quot;James Turnbull&quot;</span> 4aab3ce3cb76 jamtur01/apache2:webserver</span><br></code></pre></td></tr></table></figure>
<p><code>-m</code> 选项是创建镜像的提交信息。</p>
<p><code>-a</code> 选项是该镜像的作者信息。</p>
<p><code>webserver</code> 是标签名。</p>
<p>可以使用 <code>docker inspect</code> 命令来查看新创建的镜像的详细信息:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker inspect jamtur01/apache2:webserver</span><br></code></pre></td></tr></table></figure>
<h3 id="4-5-3-用-Dockerfile-构建镜像"><a href="#4-5-3-用-Dockerfile-构建镜像" class="headerlink" title="4.5.3 用 Dockerfile 构建镜像"></a>4.5.3 用 Dockerfile 构建镜像</h3><p>一般不推荐使用 <code>docker commit</code> 来构建镜像。</p>
<p>Dockerfile 使用基本的基于 DSL(Domain Specific Language) 语法的指令来构建一个 Docker 镜像。</p>
<h4 id="第一个-Dockerfile"><a href="#第一个-Dockerfile" class="headerlink" title="第一个 Dockerfile"></a>第一个 Dockerfile</h4><p>创建的用来保存 Dockerfile 的目录称为构建环境(build environment), Docker 则称此环境为上下文(context)或构建上下文(build context),</p>
<p>Docker 会在构建镜像时将构建上下文和该上下文中的文件和目录上传到 Docker 守护进程。</p>
<p>例子:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Version: 0.0.1</span><br><span class="hljs-keyword">FROM</span> ubuntu:14.04<br>MAINTAINER james Turnbull <span class="hljs-string">&quot;james@example.com&quot;</span><br><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> update &amp;&amp; apt-<span class="hljs-built_in">get</span> install -y nginx<br><span class="hljs-built_in">RUN</span> echo <span class="hljs-string">&#x27;Hi, I am in your container&#x27;</span> \<br>    &gt;/usr/share/nginx/html/index.html<br>EXPOSE 80<br></code></pre></td></tr></table></figure>
<p>Dockerfile 由指令和参数构成。</p>
<p>每条指令，如 <code>FROM</code>, 都必须为大写字母, 而且后面要跟随一个参数.</p>
<p>每条指令都会创建一个新的镜像层并对镜像进行提交。</p>
<p>运行流程:</p>
<ul>
<li>Docker从基础镜像运行一个容器。<br>  -执行一条指令，对容器做出修改。<br>  -执行类似docker commit的操作，提交一个新的镜像层。<br>  -Docker再基于刚提交的镜像运行一个新容器。<br>  -执行Dockerfile中的下一条指令，直到所有指令都执行完毕</li>
</ul>
<p>Dockerfile 中的注释是 <code>#</code> 开头的行.</p>
<p><code>MAINTAINER</code> 指令告诉 Docker 该镜像的作者是谁，以及作者的电子邮件地址。</p>
<p><code>RUN</code> 指令会在当前镜像中运行指定的命令. 每条 <code>RUN</code> 指令都会创建一个新的镜像层。</p>
<p>默认情况下，<code>RUN</code> 指令会在 shell 里使用 <code>/bin/sh -c</code> 来执行。</p>
<p>若在不支持 shell 的平台上，使用 <code>exec</code> 格式的 <code>RUN</code> 指令:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">RUN</span> [<span class="hljs-string">&quot;appt-get&quot;</span>, <span class="hljs-string">&quot; install&quot;</span>, <span class="hljs-string">&quot;-y&quot;</span>, <span class="hljs-string">&quot;nginx&quot;</span>]<br></code></pre></td></tr></table></figure>
<p>这里的 <code>-y</code> 参数是 <code>yes</code> 的意思。</p>
<p><code>EXPOSE</code> 指令，告诉 Docker 该容器内的应用程序将会使用容器的指定端口。</p>
<p>可以指定多个 <code>EXPOSE</code> 指令来向外部公开多个端口。</p>
<h3 id="4-5-4-基于-Dockerfile-构建新镜像"><a href="#4-5-4-基于-Dockerfile-构建新镜像" class="headerlink" title="4.5.4 基于 Dockerfile 构建新镜像"></a>4.5.4 基于 Dockerfile 构建新镜像</h3><p>执行 <code>docker build</code> 命令时，Dockerfile 中的所有指令都会被执行并且提交，并且在该命令成功结束后返回一个新镜像。</p>
<p>使用 <code>-t</code> 选项为新镜像设置仓库和名称以及标签:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo docker build -t=<span class="hljs-string">&quot;jamtur01/static_web:v1&quot;</span> .<br></code></pre></td></tr></table></figure>
<p>如果没有制定任何标签，Docker 将会自动为镜像设置一个 <code>latest</code> 标签.</p>
<p>最后一个 <code>.</code> 告诉 Docker 到本地目录中找 Dockerfile 文件，也可指定一个 Git 仓库的源地址来指定 Dockerfile 的位置.</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo docker build -t=<span class="hljs-string">&quot;jamtur01/static_web:v1&quot;</span> git<span class="hljs-variable">@github</span>.<span class="hljs-symbol">com:</span>jamtur01/docker-static_web<br></code></pre></td></tr></table></figure>
<p><code>-f</code> 参数指定文件:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ sudo docker build -t=<span class="hljs-string">&quot;jamtur01/static_web&quot;</span> -f path<span class="hljs-regexp">/to/</span><span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure>
<p>构建目录中的 <code>.dockerignore</code> 类似于 <code>.gitignore</code></p>
<h3 id="4-5-5-指令失败时会怎样"><a href="#4-5-5-指令失败时会怎样" class="headerlink" title="4.5.5 指令失败时会怎样"></a>4.5.5 指令失败时会怎样</h3><h3 id="4-5-6-Dockerfile-和构建缓存"><a href="#4-5-6-Dockerfile-和构建缓存" class="headerlink" title="4.5.6 Dockerfile 和构建缓存"></a>4.5.6 Dockerfile 和构建缓存</h3><p>它会将之前的镜像层看做缓存，意思是第二次 <code>docker build</code> 时，会接着从上次结束时运行。</p>
<p>忽略缓存功能，使用 <code>docker build --no-cache</code></p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> sudo docker build --<span class="hljs-keyword">no</span>-cache -t=<span class="hljs-string">&quot;jamtur01/static_web&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="4-5-7-基于构建缓存的-Dockerfile-模板"><a href="#4-5-7-基于构建缓存的-Dockerfile-模板" class="headerlink" title="4.5.7 基于构建缓存的 Dockerfile 模板"></a>4.5.7 基于构建缓存的 Dockerfile 模板</h3><p>一般在 Dockerfile 文件顶部使用相同的指令集模板:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FROM</span> ubuntu:<span class="hljs-number">14</span>.<span class="hljs-number">04</span><br><span class="hljs-attribute">MAINTAINER</span> James Turnbull <span class="hljs-string">&quot;james@example.com&quot;</span><br><span class="hljs-attribute">ENV</span> REFRESHED_AT <span class="hljs-number">2014</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span><br><span class="hljs-attribute">RUN</span> apt-get -qq update<br></code></pre></td></tr></table></figure>
<p><code>ENV</code> 指令用于在镜像中设置环境变量。</p>
<p>模板实际上就是自己常用的配置。</p>
<h3 id="4-5-8-查看新镜像"><a href="#4-5-8-查看新镜像" class="headerlink" title="4.5.8 查看新镜像"></a>4.5.8 查看新镜像</h3><p>深入探求镜像是如何被构建出来的，使用 <code>docker history</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">history</span> <span class="hljs-number">22</span>d47c8cb6e5<br></code></pre></td></tr></table></figure>
<h3 id="4-5-9-从新镜像启动容器"><a href="#4-5-9-从新镜像启动容器" class="headerlink" title="4.5.9 从新镜像启动容器"></a>4.5.9 从新镜像启动容器</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -p 80 --name static_web jamtur01/static_web nginx -g <span class="hljs-string">&quot;daemon off;&quot;</span></span><br></code></pre></td></tr></table></figure>
<p><code>-d</code> 选项告诉 Docker 以分离(detached)的方式在后台运行。</p>
<p><code>-p</code> 选项，用来控制 Docker 在运行时应该公开哪些网络端口给外部(宿主机).</p>
<p>Docker 可以通过两种方法来在宿主机上分配端口:</p>
<ul>
<li>Docker 可以在宿主机上随机选择一个位于 32768~61000 的比较大的端口号来映射到容器的 80 端口上</li>
<li>可以在 Docker 宿主机中指定一个具体的端口号来映射到容器中的 80 端口上</li>
</ul>
<p><code>docker run</code> 命令会在 Docker 宿主机上随即打开一个端口，连接到容器中的 80 端口上。</p>
<p>可用 <code>docker ps</code> 命令查看容器的端口分配情况:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-l</span><br></code></pre></td></tr></table></figure>
<p>也可通过 <code>docker port</code> 命令来查看容器的端口映射情况:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker port <span class="hljs-number">6751</span>b94bb5c0 <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>

<p>使用 <code>-p</code> 选项指定容器中的端口映射到 Docker 宿主机的某一特定端口上:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ sudo docker <span class="hljs-built_in">run</span> -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> <span class="hljs-comment">--name static_web</span><br></code></pre></td></tr></table></figure>
<p>前者是宿主机端口，后者是容器端口。 </p>
<p>将端口绑定限制在特定的网络接口(即IP地址)上:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -p 127.0.0.1:80:80 --name static_web jamtur01/static_web nginx -g <span class="hljs-string">&quot;daemon off;&quot;</span></span><br></code></pre></td></tr></table></figure>
<p>其将容器内的 80 端口绑定到本地宿主机的 127.0.0.1 这个 IP 的 80 端口上. 不指定如 80 就是随机端口。</p>
<p>使用 <code>-P</code> 参数将 Dockerfile 中通过 <code>EXPOSE</code> 指令指定的端口公开:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -P --name static_web jamtur01/static_web nginx -g <span class="hljs-string">&quot;daemon off;&quot;</span></span><br></code></pre></td></tr></table></figure>
<p>并绑定到随机端口。</p>
<p>有了这个端口号，就可以使用本地宿主机的 IP 地址连接到运行中的容器.</p>
<h3 id="4-5-10-Dockerfile-指令"><a href="#4-5-10-Dockerfile-指令" class="headerlink" title="4.5.10 Dockerfile 指令"></a>4.5.10 Dockerfile 指令</h3><p>[清单](<a target="_blank" rel="noopener" href="http://docs.docker.com/">http://docs.docker.com/</a> reference &#x2F;builder&#x2F;)</p>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>用于指定一个容器启动时要运行的命令.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">CMD <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>]</span><br></code></pre></td></tr></table></figure>
<p>后面为参数.</p>
<p>这是存储在一个数组结构中.</p>
<p><code>docker run</code> 命令后若指定要运行的命令, 会覆盖 Dockerfile 中的 CMD 指令.</p>
<p>在 Dockerfile 中只能指定一条 CMD 命令.</p>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p><code>docker run</code> 命令行中指定的任何参数都会被当做参数再次传递给 <code>ENTRYPOINT</code> 指令中指定的命令.</p>
<p>如:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTERYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/usr/sbin/ nginx&quot;</span>]</span><br></code></pre></td></tr></table></figure>
<p>然后:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker build <span class="hljs-attribute">-t</span>=<span class="hljs-string">&quot;jamtur01/static_web&quot;</span><br>$ sudo docker <span class="hljs-built_in">run</span> -t -i jamtur01/static_web -g <span class="hljs-string">&quot;daemon off;&quot;</span><br></code></pre></td></tr></table></figure>
<p>其中 <code>-g &quot;daemon off;&quot;</code> 就会传递给 <code>ENTEYPOINT</code></p>
<p>可用 <code>docker run</code> 的 <code>--entrypoint</code> 选项来覆盖 <code>ENTRYPOINT</code> 指令.</p>
<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>用来从镜像创建一个容器时,在容器内部设置一个工作目录,<code>ENTRYPOINT</code> 和 <code>/</code> 或 <code>CMD</code> 指定的程序会在这个目录下执行.</p>
<p>可以设置不同的工作目录:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /opt/webapp/db</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> bundle install</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /opt/webapp</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;rackup&quot;</span>]</span><br></code></pre></td></tr></table></figure>

<p>可以通过 <code>-w</code> 选项在运行时设置工作目录:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ sudo docker <span class="hljs-keyword">run</span> -ti -w /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span> ubuntu <span class="hljs-keyword">pwd</span><br></code></pre></td></tr></table></figure>
<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>用于设置环境变量:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ENV RVM_PATH <span class="hljs-regexp">/home/</span>rvm/<br></code></pre></td></tr></table></figure>
<p>也可通过 <code>docker run</code> 命令的 <code>-e</code> 参数来传递环境变量:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -ti -e <span class="hljs-string">&quot;WEB_PORT=8000&quot;</span> ubuntu <span class="hljs-built_in">env</span></span><br></code></pre></td></tr></table></figure>
<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>指定该镜像以什么样的用户去执行:</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">USER</span> <span class="hljs-title">nginx</span><br></code></pre></td></tr></table></figure>
<p>可以指定用户名或 UID 以及组或 GID:</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">USER</span> <span class="hljs-title">user</span><br><span class="hljs-keyword">USER</span> <span class="hljs-title">user</span>:<span class="hljs-keyword">group</span><br><span class="hljs-title">USER</span> uid<br><span class="hljs-keyword">USER</span> <span class="hljs-title">uid</span>:gid<br><span class="hljs-keyword">USER</span> <span class="hljs-title">user</span>:gid<br><span class="hljs-keyword">USER</span> <span class="hljs-title">uid</span>:group<br></code></pre></td></tr></table></figure>
<p>默认用户为 root, 可以用 <code>docker run</code> 的 <code>-u</code> 选项覆盖.</p>
<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>在没有在 <code>docker run</code> 时使用 <code>-v</code> 选项时, 创建一个隐藏数据卷.</p>
<h5 id="什么是隐藏数据卷"><a href="#什么是隐藏数据卷" class="headerlink" title="什么是隐藏数据卷"></a>什么是隐藏数据卷</h5><p>也就是没有指定宿主机上面的某一个目录, 因此自动在 <code>/var/lib/docker/volumes</code> 目录下自动创建的一个卷.</p>
<h5 id="VOLUME-的作用"><a href="#VOLUME-的作用" class="headerlink" title="VOLUME 的作用"></a>VOLUME 的作用</h5><p>比如我们在 Dockerfile 中写 <code>VOLUME [ &quot;/Blog&quot; ]</code>, 并且在 run 的时候没有添加 <code>-v</code> 选项, 那么在容器创建后, 会生成 <code>/Blog</code> 这个目录, 以及在 <code>/var/lib/docker/volumes</code> 下生成一个卷, 这两个相互映射.<br>用来向基于镜像创建的容器添加卷, 一个卷是可以存在于一个或者多个容器内的特定的目录.</p>
<p>特点:</p>
<ul>
<li>卷可以在容器间共享和重用</li>
<li>一个容器可以不是必须和其他容器共享卷</li>
<li>对卷的修改是立时生效的</li>
<li>对卷的修改不会对更新镜像产生影响</li>
<li>卷会一直存在知道没有任何容器再使用它.</li>
</ul>
<p>卷功能可以让我们将内容添加到镜像而不提交.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">VOLUME <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/opt/project&quot;</span>]</span><br></code></pre></td></tr></table></figure>
<p>为基于此镜像创建的任何容器创建一个名为 <code>/opt/project</code> 的挂载点.</p>
<p><code>docker cp</code> 允许从容器复制文件和复制文件到容器上.</p>
<p>指定多个卷:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">VOLUME <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/opt/project&quot;</span>, <span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure>

<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>用来将构建环境下的文件和目录复制到镜像中.</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADD</span> software.lic /<span class="hljs-meta">opt</span>/application/software.lic<br></code></pre></td></tr></table></figure>
<p>前者为原文件位置,后者为目的文件位置.</p>
<p>源文件位置也可以是 URL.</p>
<p>Docker 通过目的地址参数末尾的字符来判断文件源是目录还是文件:</p>
<ul>
<li>目的地址以 <code>/</code> 结尾, 则为目录</li>
<li>不以, 则为文件</li>
</ul>
<p>如果将压缩文件指定为源文件,会将其解压:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ADD latest.tar.gz <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/wordpress/</span><br></code></pre></td></tr></table></figure>

<p>目前 Docker 还不支持以 URL 方式指定的源文件位置中使用归档文件.</p>
<p><code>ADD</code> 指令会使构建缓存无效.</p>
<h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>类似于 <code>ADD</code>, 但 <code>COPY</code> 只关心在构建上下文中复制本地文件,而不会 extraction 和 decompression.</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span> conf.d<span class="hljs-regexp">/ /</span>etc<span class="hljs-regexp">/apache2/</span><br></code></pre></td></tr></table></figure>
<p>文件源路径必须是一个与当前构建环境相对的文件或者目录, 本地文件都放到和 Dockerfile 同一个目录下,不能复制该目录之外的任何文件.</p>
<h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>用于为 Docker 镜像添加元数据. 元数据以键值对的形式展现:</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">LABEL version<span class="hljs-operator">=</span><span class="hljs-string">&quot;1.0&quot;</span><br>LAVEL location<span class="hljs-operator">=</span><span class="hljs-string">&quot;New York&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;Data Center&quot;</span> role<span class="hljs-operator">=</span><span class="hljs-string">&quot;Web Server&quot;</span><br></code></pre></td></tr></table></figure>
<p>推荐将所有元数据都放到一条 LABEL 指令中.</p>
<p>然后通过  <code>docker inspect</code> 命令来查看 Docker 镜像中的标签信息.</p>
<h4 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h4><p>用来设置停止容器时发送什么系统调用给容器. 这个信号必须是内核系统调用表中合法的数或者 SIGNAME 格式中的信号名称.</p>
<h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p>用来定义可以在 <code>docker build</code> 命令运行时传递给构建运行时的变量, 只需在构建时使用 <code>--build-arg</code> 参数, 用户只能在构建时指定在 Dockerfile 文件中定义过的参数:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ARG</span> build<br><span class="hljs-keyword">ARG</span> webapp_user=<span class="hljs-keyword">user</span><br></code></pre></td></tr></table></figure>
<p>第二条指定了默认值:</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ sudo docker <span class="hljs-keyword">build </span>--<span class="hljs-keyword">build-arg </span><span class="hljs-keyword">build=1234 </span>-t <span class="hljs-keyword">jamtur01/webapp</span><br></code></pre></td></tr></table></figure>
<p>不要使用 <code>ARG</code> 来传递证书或者密钥.      </p>
<p>Docker 预定义了一组 ARG 变量:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">HTTP<span class="hljs-emphasis">_PROXY</span><br><span class="hljs-emphasis">http_proxy</span><br><span class="hljs-emphasis">HTTPS_PROXY</span><br><span class="hljs-emphasis">https_proxy</span><br><span class="hljs-emphasis">ftp_proxy</span><br><span class="hljs-emphasis">FTP_PROXY</span><br><span class="hljs-emphasis">NO_PROXY</span><br><span class="hljs-emphasis">no_</span>proxy<br></code></pre></td></tr></table></figure>
<h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p>为镜像添加触发器(trigger). 当一个镜像被用作其他镜像的基础镜像时, 该镜像中的触发器将会被执行.</p>
<p>触发器会在构建过程中插入新指令, 我们可以认为这些指令是紧跟在 FROM 之后指定的:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ONBUILD</span> <span class="hljs-keyword">ADD</span><span class="language-bash"> . /app/arc</span><br><span class="hljs-keyword">ONBUILD</span> <span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app/src &amp;&amp; make</span><br></code></pre></td></tr></table></figure>
<p><code>ONBUILD</code> 指令可以在镜像上运行 <code>docker inspect</code> 查看.</p>
<p><code>ONBUILD</code> 触发器会按照父镜像中指定的顺序执行, 并且只能被继承一次.</p>
<p>有部分指令不能用在 <code>ONBUILD</code> 中, 防止递归调用.</p>
<h2 id="4-6-将镜像推送到-Docker-Hub"><a href="#4-6-将镜像推送到-Docker-Hub" class="headerlink" title="4.6 将镜像推送到 Docker Hub"></a>4.6 将镜像推送到 Docker Hub</h2><p>使用 <code>docker push</code> 命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker push jamtur01/static_web</span><br></code></pre></td></tr></table></figure>
<p>应该要先登录, 用 <code>docker login</code></p>
<h3 id="自动构建-Automated-Builds"><a href="#自动构建-Automated-Builds" class="headerlink" title="自动构建(Automated Builds)"></a>自动构建(Automated Builds)</h3><p>将 Github 或 BitBucket 中含有 Dockerfile 文件的仓库连接到 Docker Hub 即可. 具体参考书籍.</p>
<h2 id="4-7-删除镜像"><a href="#4-7-删除镜像" class="headerlink" title="4.7 删除镜像"></a>4.7 删除镜像</h2><p>使用 <code>docker rmi</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker rmi jamtur01/static_web</span><br></code></pre></td></tr></table></figure>
<p>每一个 <code>Deleted:</code> 行都代表一个镜像层被删除.</p>
<h2 id="4-8-运行自己的-Docker-Registry"><a href="#4-8-运行自己的-Docker-Registry" class="headerlink" title="4.8 运行自己的 Docker Registry"></a>4.8 运行自己的 Docker Registry</h2><p>Registry 就相当于 repository.</p>
<h3 id="4-8-1-从容器运行-Registry"><a href="#4-8-1-从容器运行-Registry" class="headerlink" title="4.8.1 从容器运行 Registry"></a>4.8.1 从容器运行 Registry</h3><p>从容器安装一个 Registry:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-built_in">run</span> -p 5000:5000 registry:2<br></code></pre></td></tr></table></figure>
<p>启动一个运行 Registry 应用 2.0 版本的容器.</p>
<h3 id="4-8-2-测试新-Registry"><a href="#4-8-2-测试新-Registry" class="headerlink" title="4.8.2 测试新 Registry"></a>4.8.2 测试新 Registry</h3><p>先通过 <code>docker images</code> 找到镜像 ID:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker images jamtur01/static_web</span><br></code></pre></td></tr></table></figure>
<p>然后用 Registry 给镜像打上标签:</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ sudo docker <span class="hljs-keyword">tag</span> <span class="hljs-title">22d47c8cb6e5</span><br></code></pre></td></tr></table></figure>
<p>最后通过 <code>docker push</code> 将其推送到 Registry 中, 为了指定新的 Registry 的地址, 需要在镜像名前加上主机名和端口前缀:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ sudo docker <span class="hljs-keyword">push</span> docker.example.com:<span class="hljs-number">5000</span><span class="hljs-regexp">/jamtur01/</span>static_web<br></code></pre></td></tr></table></figure>
<p>使用其构建新容器:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -t -i docker.example.com:5000/jamtur01/static_web</span><br></code></pre></td></tr></table></figure>
<h2 id="4-9-其他可选的-Registry-服务"><a href="#4-9-其他可选的-Registry-服务" class="headerlink" title="4.9 其他可选的 Registry 服务"></a>4.9 其他可选的 Registry 服务</h2><h1 id="第5章-在测试中使用-Docker"><a href="#第5章-在测试中使用-Docker" class="headerlink" title="第5章 在测试中使用 Docker"></a>第5章 在测试中使用 Docker</h1><h2 id="5-1-使用-Docker-测试静态网站"><a href="#5-1-使用-Docker-测试静态网站" class="headerlink" title="5.1 使用 Docker 测试静态网站"></a>5.1 使用 Docker 测试静态网站</h2><p>将 Docker 作为本地 Web 开发环境是 Docker 的一个最简单的应用场景。</p>
<p>要想保持 Docker 容器的活跃状态，需要其中运行的进程不能中断，默认情况下，Nginx 会以守护进程的方式启动，这会导致容器只是短暂运行，在守护进程被 fork 后，发起守护进程的原始进程就会退出，这时容器就停止运行了.</p>
<h3 id="5-1-2-构建-Sample-网站和-Nginx-镜像"><a href="#5-1-2-构建-Sample-网站和-Nginx-镜像" class="headerlink" title="5.1.2 构建 Sample 网站和 Nginx 镜像"></a>5.1.2 构建 Sample 网站和 Nginx 镜像</h3><h3 id="5-1-3-从-Sample-网站和-Nginx-镜像构建容器"><a href="#5-1-3-从-Sample-网站和-Nginx-镜像构建容器" class="headerlink" title="5.1.3 从 Sample 网站和 Nginx 镜像构建容器"></a>5.1.3 从 Sample 网站和 Nginx 镜像构建容器</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -d -p <span class="hljs-number">80</span> --name website -v <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/website:/</span>var<span class="hljs-regexp">/www/</span>html<span class="hljs-regexp">/website jamtur01/</span>nginx nginx<br></code></pre></td></tr></table></figure>
<p>这里的 <code>-v</code> 选项允许我们将宿主机的目录作为卷，挂载到容器里。</p>
<p>两个目录用 <code>:</code> 分隔，前者为宿主机目录，后者为容器目录，如果容器目录不存在，Docker 会自动创建一个。</p>
<p>可以通过在目录后面加上 <code>rw</code> 或 <code>ro</code> 来指定容器内目录的读写状态:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -d -p <span class="hljs-number">80</span> --name website -v <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/website:/</span>var<span class="hljs-regexp">/www/</span>html<span class="hljs-regexp">/website:ro jamtur01/</span>nginx nginx<br></code></pre></td></tr></table></figure>
<h4 id="卷的概念"><a href="#卷的概念" class="headerlink" title="卷的概念"></a>卷的概念</h4><p>卷是在一个或者多个容器内被选定的目录，可以绕过分层的联合文件系统，为 Docker 提供持久数据或者共享数据。</p>
<p>对卷的修改会立即生效，并绕过镜像，当提交或者创建镜像时，卷不被包含在镜像里。</p>
<p>卷是从宿主机而来。</p>
<h3 id="5-1-4-修改网站"><a href="#5-1-4-修改网站" class="headerlink" title="5.1.4 修改网站"></a>5.1.4 修改网站</h3><p>直接修改本地宿主机的 website 目录下的 index.html 文件, 也就是卷内的文件:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ vim <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/website/i</span>ndex.html<br></code></pre></td></tr></table></figure>
<h2 id="5-2-使用-Docker-构建并测试-Web-应用程序"><a href="#5-2-使用-Docker-构建并测试-Web-应用程序" class="headerlink" title="5.2 使用 Docker 构建并测试 Web 应用程序"></a>5.2 使用 Docker 构建并测试 Web 应用程序</h2><p>Sinatra 是一个基于 Ruby 的 Web 应用框架，它包含一个 Web 应用库，以及简单的领域专用语言 (DSL) 来构建 Web 应用。</p>
<p>Sinatra 非常适合用来创建一个小型的示例应用进行测试。</p>
<h3 id="5-2-1-构建-Sinatra-应用程序"><a href="#5-2-1-构建-Sinatra-应用程序" class="headerlink" title="5.2.1 构建 Sinatra 应用程序"></a>5.2.1 构建 Sinatra 应用程序</h3><h3 id="5-2-4-将-Sinatra-应用程序连接到-Redis-容器"><a href="#5-2-4-将-Sinatra-应用程序连接到-Redis-容器" class="headerlink" title="5.2.4 将 Sinatra 应用程序连接到 Redis 容器"></a>5.2.4 将 Sinatra 应用程序连接到 Redis 容器</h3><p>两种比较现实的连接 Docker 容器的方法是:</p>
<ul>
<li>Docker Networking, Docker 1.9 及更新版本推荐使用</li>
<li>Docker link, Docker 1.9 之前版本推荐使用</li>
</ul>
<p>Docker Networking 和 Docker link 的区别:</p>
<ul>
<li>Docker Networking 可以将容器连接到不同宿主机上的容器</li>
<li>通过 Docker Networking 连接的容器可以在无需更新连接的情况下，对停止、启动或者重启容器。</li>
<li>使用 Docker Networking, 不必事先创建容器再去连接它。同样不必关心容器的运行顺序。</li>
</ul>
<h3 id="5-2-5-Docker-内部连网"><a href="#5-2-5-Docker-内部连网" class="headerlink" title="5.2.5 Docker 内部连网"></a>5.2.5 Docker 内部连网</h3><p>在安装 Docker 时，会创建一个新的网络接口，名字是 docker0.</p>
<p>每个 Docker 容器都会在这个接口上分配一个 IP 地址。</p>
<p>启动 IPv6, 在运行 Docker 守护进程时加上 <code>--ipv6</code> 标志.</p>
<p>接口本身的地址是这个 Docker 网络的网关地址，也是所有 Docker 容器的网关地址。</p>
<p>Docker 会默认使用 172.17.x.x 作为子网地址，除非被占用，Docker 就会在 172.16~172.30 这个范围内尝试创建子网.</p>
<p>Docker 每创建一个容器就会创建一组互联的网络接口，其中一端作为容器里的 eth0 接口，而另一端统一命名为 vethec6a 这种名字，作为宿主机的一个端口.</p>
<p>通过把每个 veth* 接口绑定到 docker0 网桥，Docker 创建了一个虚拟子网，这个子网由宿主机和所有的 Docker 容器共享。</p>
<p>从容器内跟踪路由:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"># apt-<span class="hljs-built_in">get</span> -yqq <span class="hljs-keyword">update</span> &amp;&amp; apt-<span class="hljs-built_in">get</span> install -yqq traceroute<br># traceroute google.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure>

<p>查看宿主机的 IPTables NAT 配置:</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">$ sudo iptables -<span class="hljs-built_in">t</span> nat -L -<span class="hljs-built_in">n</span><br></code></pre></td></tr></table></figure>

<p>Docker 默认会把公开的端口绑定到所有的网络接口上。</p>
<p>如果重启容器，Docker 会改变容器的 IP 地址.</p>
<h3 id="5-2-6-Docker-Networking"><a href="#5-2-6-Docker-Networking" class="headerlink" title="5.2.6 Docker Networking"></a>5.2.6 Docker Networking</h3><p>容器之间的连接用网络创建，被称为 Docker Networking.</p>
<p>Docker Networking 允许用户创建自己的网络，容器可以通过这个网上互相通信.</p>
<p>使用 Docker Networking 需先创建一个网络，然后在这个网络下启动容器:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker network create app<br></code></pre></td></tr></table></figure>
<p><code>create</code> 后接名称.</p>
<p>查看新创建的网络:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ sudo docker network <span class="hljs-keyword">inspect</span> <span class="hljs-keyword">app</span><br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/networking/get-started-overlay/">Docker 多宿主机网络文档</a></p>
<p>列出当前系统中的所有网络:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker network <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure>
<p>删除一个 Docker 网络:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker network <span class="hljs-built_in">rm</span><br></code></pre></td></tr></table></figure>
<p>添加容器:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-built_in">run</span> -d <span class="hljs-attribute">--net</span>==app --name db jamtur01/redis<br></code></pre></td></tr></table></figure>
<p><code>--net</code> 标志指定了新容器将会在哪个网络中运行。</p>
<p>Docker 会感知所有在这个网络下运行的容器，并且通过 <code>/etc/hosts</code> 文件将这些容器的地址保存到本地 DNS 中。</p>
<p><code>app</code> 网络内部的任何主机都可以使用 <code>hostname.app</code> 形式来被解析。</p>
<p>在宿主机下如:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ ping <span class="hljs-keyword">db</span>.<span class="hljs-keyword">app</span><br></code></pre></td></tr></table></figure>
<h4 id="将已有容器连接到-Docker-网络"><a href="#将已有容器连接到-Docker-网络" class="headerlink" title="将已有容器连接到 Docker 网络"></a>将已有容器连接到 Docker 网络</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ sudo docker network connect app db2<br></code></pre></td></tr></table></figure>
<p>这里 <code>app</code> 为网络名称，<code>db2</code> 为容器名称.</p>
<h4 id="断开一个容器与指定网络的链接"><a href="#断开一个容器与指定网络的链接" class="headerlink" title="断开一个容器与指定网络的链接"></a>断开一个容器与指定网络的链接</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ sudo docker network disconnect app db2<br></code></pre></td></tr></table></figure>
<p>一个容器可以同时隶属多个 Docker Networking.</p>
<h4 id="通过-Docker-link-连接容器"><a href="#通过-Docker-link-连接容器" class="headerlink" title="通过 Docker link 连接容器"></a>通过 Docker link 连接容器</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -p <span class="hljs-number">4567</span> --name webapp --link redis:db -t -i -v <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/webapp_redis:/</span>opt<span class="hljs-regexp">/webapp jamtur01/</span>sinatra <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure>
<p><code>--link</code> 标志，用于创建两个容器间的客户-服务链接。其需要两个参数，前者是要链接的容器的名称，后一个是这个链接的别名。这里 <code>webapp</code> 是客户，<code>redis</code> 是”服务”.</p>
<p>通过把容器链接在一起，可以让客户容器直接访问任意服务容器的公开端口.</p>
<p>只有使用 <code>--link</code> 标志链接到这个容器的容器才能连接到这个端口。</p>
<p>可以把多个容器链接在一起:</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ sudo docker run -p 4567 <span class="hljs-params">--name</span> webapp2 <span class="hljs-params">--link</span> redis<span class="hljs-function">:db</span> <span class="hljs-string">...</span><br>$ sudo docker run -p 4567 <span class="hljs-params">--name</span> webapp3 <span class="hljs-params">--link</span> redis<span class="hljs-function">:db</span> <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure>
<p>在运行容器时指定 <code>--add-host</code> 选项，可以在 <code>/etc/hosts</code> 文件中添加相应的记录:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-built_in">run</span> -p 4567 <span class="hljs-attribute">--add-host</span>=docker:10.0.0.1 <span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure>
<p>在容器中可以用 <code>env</code> 命令查看新创建的环境变量的信息.</p>
<h3 id="5-2-7-使用容器连接来通信"><a href="#5-2-7-使用容器连接来通信" class="headerlink" title="5.2.7 使用容器连接来通信"></a>5.2.7 使用容器连接来通信</h3><h2 id="5-3-Docker-用于持续集成"><a href="#5-3-Docker-用于持续集成" class="headerlink" title="5.3 Docker 用于持续集成"></a>5.3 Docker 用于持续集成</h2><p>即在多开发者的持续集成测试场景中使用 Docker.</p>
<h1 id="第6章-使用-Docker-构建服务"><a href="#第6章-使用-Docker-构建服务" class="headerlink" title="第6章 使用 Docker 构建服务"></a>第6章 使用 Docker 构建服务</h1><h2 id="6-1-构建第一个应用"><a href="#6-1-构建第一个应用" class="headerlink" title="6.1 构建第一个应用"></a>6.1 构建第一个应用</h2><h3 id="6-1-1-JekyII-基础镜像"><a href="#6-1-1-JekyII-基础镜像" class="headerlink" title="6.1.1 JekyII 基础镜像"></a>6.1.1 JekyII 基础镜像</h3><h3 id="6-1-2-构建-Jekyll-基础镜像"><a href="#6-1-2-构建-Jekyll-基础镜像" class="headerlink" title="6.1.2 构建 Jekyll 基础镜像"></a>6.1.2 构建 Jekyll 基础镜像</h3><h3 id="6-1-5-启动-Jekyll-网站"><a href="#6-1-5-启动-Jekyll-网站" class="headerlink" title="6.1.5 启动 Jekyll 网站"></a>6.1.5 启动 Jekyll 网站</h3><p>启动一个叫做 <code>james_blog</code> 的新容器, 把本地的 james_blog 目录作为 <code>/data/</code> 卷挂载到容器里:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -v <span class="hljs-regexp">/home/</span>james<span class="hljs-regexp">/james_blog:/</span>data/ \<br>--name james_blog jamtur01/jekyll<br></code></pre></td></tr></table></figure>
<p>卷在 Docker 宿主机的 <code>/var/lib/docker/volumes</code> 目录中, 可以通过 <code>docker inspect</code> 命令查看某个卷的具体位置.</p>
<p>如果想在另一个容器里使用 <code>/var/www/html/</code> 卷里编译好的网站, 可以建立一个新的链接到这个卷的容器:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ sudo docker <span class="hljs-built_in">run</span> -d -P <span class="hljs-comment">--volumes-from jemes_blog jamtur01/apache 091570cc2267</span><br></code></pre></td></tr></table></figure>
<p><code>--volumes-from</code> 标志, 把指定容器里的所有卷都加入新创建的容器里.</p>
<p>卷 这个概念感觉实际上就是挂载, 你在 Docker 里面修改了这个 卷 里的内容, 宿主机上面的目录也会更新.</p>
<h3 id="6-1-7-备份-Jekyll-卷"><a href="#6-1-7-备份-Jekyll-卷" class="headerlink" title="6.1.7 备份 Jekyll 卷"></a>6.1.7 备份 Jekyll 卷</h3><p>如:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> --<span class="hljs-built_in">rm</span> --volumes-from james_blog \</span><br><span class="language-bash">-v $(<span class="hljs-built_in">pwd</span>):/backup ubuntu \</span><br><span class="language-bash">tar cvf /backup/james_blog_backup.tar /var/www/html</span><br></code></pre></td></tr></table></figure>
<p>上面命令的解释为, <code>--rm</code> 参数表明会在容器的进程运行完毕后, 自动删除容器, <code>--volumes-from james_blog</code> 指定从哪个容器中获取 volumes, <code>-v $(pwd):/backup</code> 将当前目录 (即用来存备份文件的目录) 挂载到容器中的 <code>/backup</code> 目录下, <code>ubuntu</code> 是 image 的名称, <code>tar cvf /backup/james_blog_backup.tar /var/www/html</code> 是将 <code>/var/www/html</code> 打包为 <code>/backup/james_blog_backup.tar</code> 文件.</p>
<h3 id="6-1-8-扩展-Jekyll-示例网站"><a href="#6-1-8-扩展-Jekyll-示例网站" class="headerlink" title="6.1.8 扩展 Jekyll 示例网站"></a>6.1.8 扩展 Jekyll 示例网站</h3><h2 id="6-2-使用-Docker-构建一个-Java-应用服务"><a href="#6-2-使用-Docker-构建一个-Java-应用服务" class="headerlink" title="6.2 使用 Docker 构建一个 Java 应用服务"></a>6.2 使用 Docker 构建一个 Java 应用服务</h2><h3 id="6-2-1-WAR-文件的获取程序"><a href="#6-2-1-WAR-文件的获取程序" class="headerlink" title="6.2.1 WAR 文件的获取程序"></a>6.2.1 WAR 文件的获取程序</h3><h2 id="6-3-多容器的应用栈"><a href="#6-3-多容器的应用栈" class="headerlink" title="6.3 多容器的应用栈"></a>6.3 多容器的应用栈</h2><p><code>docker run</code> 中的 <code>-h</code> 标志, 用于指定容器的主机名. </p>
<h2 id="6-4-不使用-SSH-管理-Docker-容器"><a href="#6-4-不使用-SSH-管理-Docker-容器" class="headerlink" title="6.4 不使用 SSH 管理 Docker 容器"></a>6.4 不使用 SSH 管理 Docker 容器</h2><p>传统上讲, 通过 SSH 登入运行环境或者虚拟机来管理服务.</p>
<p>在 Docker 里, 大部分容器都只运行一个进程, 所以不能使用这种访问方法.</p>
<p>需要登入容器时, 可以使用 <code>nsenter</code> 工具.</p>
<p>nsenter 可以进入一个已经存在的容器的 shell, 即便这个容器没有运行 SSH 或任何类似目的的守护进程. 可以通过 Docker 容器安装 nsenter:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -v <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin:/</span>target jpetazzo/nsenter<br></code></pre></td></tr></table></figure>
<p>具体见书.</p>
<h1 id="第7章-Docker-编配和服务发现"><a href="#第7章-Docker-编配和服务发现" class="headerlink" title="第7章 Docker 编配和服务发现"></a>第7章 Docker 编配和服务发现</h1><p>Docker Compose 是 Docker 的编配工具.</p>
<h2 id="7-1-Docker-Compose"><a href="#7-1-Docker-Compose" class="headerlink" title="7.1 Docker Compose"></a>7.1 Docker Compose</h2><p>使用 Docker Compose, 可以用一个 YAML 文件定义一组要启动的容器, 以及容器运行时的属性. Docker Compose 称这些容器为 “服务”.</p>
<h3 id="7-1-1-安装-Docker-Compose"><a href="#7-1-1-安装-Docker-Compose" class="headerlink" title="7.1.1 安装 Docker Compose"></a>7.1.1 安装 Docker Compose</h3><p>三种方法:</p>
<ul>
<li>直接安装</li>
<li>Docker Toolbox</li>
<li>Python Pip</li>
</ul>
<p>如:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo pip <span class="hljs-keyword">install</span> -U docker-compose<br></code></pre></td></tr></table></figure>

<p>具体见书.</p>
<h3 id="7-1-2-获取示例应用"><a href="#7-1-2-获取示例应用" class="headerlink" title="7.1.2 获取示例应用"></a>7.1.2 获取示例应用</h3><h3 id="7-1-3-docker-compose-yml-文件"><a href="#7-1-3-docker-compose-yml-文件" class="headerlink" title="7.1.3 docker-compose.yml 文件"></a>7.1.3 docker-compose.yml 文件</h3><p>执行 <code>docker-compose up</code> 命令, Compose 会启动这些容器, 使用指定的参数来执行, 并将所有日志输出合并到一起. </p>
<p>示例 <code>docker-compose.yml</code> 文件:</p>
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">web</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">jamtur01/composeapp</span><br>    <span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">python app.py</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">.:/composeapp</span><br>    <span class="hljs-attribute">links</span><span class="hljs-punctuation">:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attribute">redis</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">redis</span><br></code></pre></td></tr></table></figure>

<p><code>links</code> 指定了要连接到服务的其他服务.</p>
<p>可以在 Docker Compose 官网查看 docker-compose.yml 所有可用指令列表. <a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/">位置</a></p>
<h3 id="7-1-4-运行-Compose"><a href="#7-1-4-运行-Compose" class="headerlink" title="7.1.4 运行 Compose"></a>7.1.4 运行 Compose</h3><p>创建并启动服务:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker-compose up<br></code></pre></td></tr></table></figure>

<p>为了保证服务是唯一的, Compose 将 docker-compose.yml 文件中指定的服务名称加上目录名作为前缀, 并分别使用数字作为后缀.</p>
<p>Compose 之后接管了每个服务输出的日志, 输出的日志每一行都使用缩短的服务名称最为前缀, 并交替输出在一起.</p>
<p>服务和 Compose 交替运行, 这意味着, 如果使用 <code>Ctrl+C</code> 来停止 Compose 运行, 也会停止运行的服务.</p>
<p>可以在运行 <code>Compose</code> 时指定 <code>-d</code> 标志, 其将以守护进程来运行服务.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker-compose up -d<br></code></pre></td></tr></table></figure>
<h3 id="7-1-5-使用-Compose"><a href="#7-1-5-使用-Compose" class="headerlink" title="7.1.5 使用 Compose"></a>7.1.5 使用 Compose</h3><p>可以用 <code>docker-compose ps</code> 命令来查看服务的运行状态:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker-copose ps<br></code></pre></td></tr></table></figure>
<p>使用 <code>docker-compose help +命令</code> 来查看相关用法. </p>
<p><code>docker-compose stop</code> 可以停止正在运行的服务.</p>
<p><code>docker-compose kill</code> 强制杀死服务.</p>
<p>使用 <code>docker-compose start</code> 命令重启.</p>
<p><code>docker-compose rm</code> 来删除这些服务.</p>
<h2 id="7-3-Docker-Swarm"><a href="#7-3-Docker-Swarm" class="headerlink" title="7.3 Docker Swarm"></a>7.3 Docker Swarm</h2><p>Docker Swarm 是一个原生的 Docker 集群管理工具.</p>
<p>Swarm 将一组 Docker 主机作为一个虚拟的 Docker 主机来管理.</p>
<h3 id="7-3-1-安装-Swarm"><a href="#7-3-1-安装-Swarm" class="headerlink" title="7.3.1 安装 Swarm"></a>7.3.1 安装 Swarm</h3><p>拉取 Docker 公司提供的 <code>swarm</code> 镜像即可:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker pull swarm<br></code></pre></td></tr></table></figure>
<p>运行 Swarm 的所有 Docker 节点都必须运行统一个版本的 Docker.</p>
<h3 id="7-3-2-创建-Swarm-集群"><a href="#7-3-2-创建-Swarm-集群" class="headerlink" title="7.3.2 创建 Swarm 集群"></a>7.3.2 创建 Swarm 集群</h3><p>集群中的每台主机上都运行着一个 <mark> Swarm 节点代理</mark> , 每个代理都将改主机上的相关 Docker 守护进程注册到集群中.</p>
<p>和节点代理相对的是 Swarm 的管理者, 用于对集群进行管理.</p>
<p>通过集群发现后端 (discovery backend, 如 Docker Hub) 来实现集群注册. 默认为 Docker Hub.</p>
<p>在 Docker Hub 中注册一个集群, 然后返回一个集群 ID, 之后使用这个集群 ID 向集群添加额外的节点.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run --<span class="hljs-built_in">rm</span> swarm create<br></code></pre></td></tr></table></figure>
<p>此命令会返回一个 字符串, 即集群 ID.</p>
<p>运行 Swarm 代理:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">smoker $ docker run -d swarm <span class="hljs-built_in">join</span> --addr=10.0.0.125:2375 \<br> token://b811b0bc438sifjvajhfiakfidjcbaj83hai<br></code></pre></td></tr></table></figure>
<p>使用 <code>join</code> 并用 <code>--addr</code> 传递本机 IP 地址.</p>
<p><code>token://b811b0bc438sifjvajhfiakfidjcbaj83hai</code> 这一串就是指定2集群 ID.</p>
<p>查看代理节点的列表:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run --<span class="hljs-built_in">rm</span> swarm list token://b811b0bc438sifjvajhfiakfidjcbaj83hai<br></code></pre></td></tr></table></figure>
<p>可在任意安装了 Docker 的主机上执行.</p>
<p>创建 Swarm 集群管理者:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run -d -p 2380:2375 swarm manage token://b811b0bc438sifjvajhfiakfidjcbaj83hai<br></code></pre></td></tr></table></figure>



                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Docker/" class="category-chain-item">Docker</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>第一本 Docker 书</div>
      <div>http://example.com/2022/08/25/第一本-Docker-书/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月25日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/25/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2%20Web%20%E5%AE%89%E5%85%A8/" title="白帽子讲 Web 安全">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">白帽子讲 Web 安全</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/25/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/" title="网络是怎样连接的">
                        <span class="hidden-mobile">网络是怎样连接的</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'zKurisu/comments-utterances');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Jie</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Orkarin</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
