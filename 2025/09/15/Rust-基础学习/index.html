

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/wallhaven-j5kjgy_1920x1080.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jie">
  <meta name="keywords" content="">
  
    <meta name="description" content="通过例子学 Rust 中文版 Hello World定义函数的语法: 123fn main() &amp;#123;    ...&amp;#125;  在 Rust 中, ! 是 “宏” 的标识符, 如: 1println!(&quot;Hello World!&quot;); println! 就是一个宏. 123fn main() &amp;#123;    println!(&quot;Hello World!&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust-基础学习">
<meta property="og:url" content="http://example.com/2025/09/15/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="通过例子学 Rust 中文版 Hello World定义函数的语法: 123fn main() &amp;#123;    ...&amp;#125;  在 Rust 中, ! 是 “宏” 的标识符, 如: 1println!(&quot;Hello World!&quot;); println! 就是一个宏. 123fn main() &amp;#123;    println!(&quot;Hello World!&amp;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-15T01:13:37.000Z">
<meta property="article:modified_time" content="2025-09-18T06:05:04.535Z">
<meta property="article:author" content="Jie">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Rust-基础学习 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jie</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/SteinsGate_all.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Rust-基础学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-09-15 09:13" pubdate>
          2025年9月15日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          61k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          512 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Rust-基础学习</h1>
            
            
              <div class="markdown-body">
                
                <p><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/rust-by-example/">通过例子学 Rust 中文版</a></p>
<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>定义函数的语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Rust 中, <code>!</code> 是 “宏” 的标识符, 如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br></code></pre></td></tr></table></figure>
<p><code>println!</code> 就是一个宏.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>单行注释 <code>//</code>.</p>
<p>块注释 <code>/**/</code>.</p>
<p>便于生成文档的注释:</p>
<ul>
<li><code>///</code></li>
<li><code>//!</code></li>
</ul>
<p>Rust 中用 <code>let</code> 声明变量.</p>
<p>如:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">fn <span class="hljs-title">mian</span>()</span> &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;<br>    println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>变量插值的形式为 <code>&#123;&#125;</code>.</p>
<h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><p>打印操作由 <code>std::fmt</code> 中的宏来处理. 如:</p>
<ul>
<li><code>format!</code>, 功能和 <code>sprintf</code> 类似, 将格式化文本写到字符串</li>
<li><code>print!</code>, 与 <code>format!</code> 类似, 将文本输出到控制台 (<code>io::stdout</code>)</li>
<li><code>println!</code>, 与 <code>print!</code> 类似, 但自动追加换行符</li>
<li><code>eprint!</code>, 与 <code>print!</code> 类似, 但输出到标准输出 (<code>io::stderr</code>)</li>
<li><code>eprintln!</code>, 与 <code>eprint!</code> 类似, 追加换行符</li>
</ul>
<p>比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;number:&gt;width$&#125;&quot;</span>, number=<span class="hljs-number">1</span>, width=<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Rust 是静态类型且类型安全的语言, 即:</p>
<ul>
<li>每个变量或值的类型在编译时就已经确定</li>
<li>声明变量时要明确类型或让编译器推断</li>
<li>不同类型之间通常不能隐式转换</li>
</ul>
<p>Rust 中的 primitive types 可分为两大类:</p>
<ul>
<li>Scalar types, 单一值</li>
<li>Compound Types, 组合值</li>
</ul>
<h2 id="Scalar-types"><a href="#Scalar-types" class="headerlink" title="Scalar types"></a>Scalar types</h2><p>有 4 种基本的 scalar type:</p>
<ul>
<li>Integer, 如有符号或无符号整数值: <code>i32</code>, <code>u8</code> (“i” 指 integer, “u” 指 unsigned, “32” 指 32 位)</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>: <span class="hljs-type">u8</span> = <span class="hljs-number">255</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: <span class="hljs-type">isize</span> = -<span class="hljs-number">100</span> <span class="hljs-comment">// 依赖平台，通常是 32 或 64 位</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Float, 带小数点的数组, 如 <code>f32</code>, <code>f64</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">pi</span>: <span class="hljs-type">f64</span> = <span class="hljs-number">3.141592</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">gravity</span>: <span class="hljs-type">f32</span> = <span class="hljs-number">9.8</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>Boolean, 类型名 <code>bool</code>, 只有 <code>true</code> 或 <code>false</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">is_rust_fun</span>: <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">is_raining</span>: <span class="hljs-type">bool</span> = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>Character, 类型名 <code>char</code>, 表示单个 Unicode 字符, 用单引号包裹 <code>a</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: <span class="hljs-type">char</span> = <span class="hljs-string">&#x27;R&#x27;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">heart</span>: <span class="hljs-type">char</span> = <span class="hljs-string">&#x27;❤&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>数字的类型说明有两种写法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a_float</span>: <span class="hljs-type">f64</span> = <span class="hljs-number">1.0</span>;  <span class="hljs-comment">// 常规说明</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">an_integer</span>   = <span class="hljs-number">5i32</span>; <span class="hljs-comment">// 后缀说明</span><br></code></pre></td></tr></table></figure>


<h2 id="Compound-Types"><a href="#Compound-Types" class="headerlink" title="Compound Types"></a>Compound Types</h2><p>Conpound types, 组合值, 类型有:</p>
<ul>
<li>Tuple, 固定数量的多个不同类型的值组成一个整体, 用 <code>()</code> 包裹</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">person</span>: (<span class="hljs-type">String</span>, <span class="hljs-type">u32</span>) = (<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Alice&quot;</span>), <span class="hljs-number">30</span>);<br><span class="hljs-comment">// 或者不写类型，让编译器推断：</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">point</span> = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 类型是 (i32, i32)</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = point.<span class="hljs-number">0</span>; <span class="hljs-comment">// 第一个元素</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = point.<span class="hljs-number">1</span>; <span class="hljs-comment">// 第二个元素</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Array, 固定长度, 相同类型元素的集合, 用 <code>[]</code> 包裹</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">numbers</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">// 或简写为（类型可推断）：</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">nums</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = numbers[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 所有元素可以初始化成相同的值</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">ys</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">500</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">500</span>];<br><br><span class="hljs-title function_ invoke__">analyze_slice</span>(&amp;ys[<span class="hljs-number">1</span> .. <span class="hljs-number">4</span>]); <span class="hljs-comment">// 传递一部分数组值</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Struct, 用户自定义的复合类型</li>
<li>Enum, 表示一个值可能是多个不同类型&#x2F;情况中的一种</li>
</ul>
<h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>在很多情况下, 都不需要显式写类型, 编译器会根据上下文推断:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">42</span>;          <span class="hljs-comment">// 编译器推断为 i32</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">3.14</span>;        <span class="hljs-comment">// 推断为 f64</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">flag</span> = <span class="hljs-literal">true</span>;     <span class="hljs-comment">// 推断为 bool</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-string">&quot;Rust&quot;</span>;   <span class="hljs-comment">// 推断为 &amp;str（字符串字面量类型）</span><br></code></pre></td></tr></table></figure>

<h2 id="其他常见类型"><a href="#其他常见类型" class="headerlink" title="其他常见类型"></a>其他常见类型</h2><p>Rust 的 <code>std</code> 标准库中, 提供了大量类型, 函数, 模块和 trait. 常用的标准库类型有:</p>
<ul>
<li><code>String</code>, 可变的堆分配 <code>UTF-8</code> 字符串</li>
<li><code>Vec&lt;T&gt;</code>, 动态数组</li>
<li><code>Option&lt;T&gt;</code>, 表示有值 (<code>Some(T)</code>) 或无值 (<code>None</code>)</li>
<li><code>Result&lt;T, E&gt;</code>, 表示可能成功 (<code>Ok(T)</code>) 或失败 (<code>Err(E)</code>)</li>
<li><code>Box&lt;T&gt;</code>, 指向堆上数据的指针，用于堆分配和所有权管理</li>
</ul>
<p>对于字符串字面量, 类型是 <code>&amp;&#39;static str</code>, 表明其为不可变的字符串切片. 下面是对这个类型的解释:</p>
<ul>
<li><code>&amp;</code> 表示这是一个 reference, 仅借用</li>
<li><code>&#39;static</code> 表示引用的生命周期是 <code>&#39;static</code>, 在程序运行期间都有效</li>
<li><code>str</code> 表示是一个字符串切片, 是指向一段 UTF-8 编码的字符数据的视图</li>
</ul>
<p>比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, Rust!&quot;</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>这里的 <code>&quot;Hello, Rust!&quot;</code> 就是一个字符串字面量, 是硬编码到程序中的一个不可变的 UTF-8 字符串</li>
<li>一般情况下编译器能自己推断</li>
</ul>
<h1 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a>变量绑定</h1><p>使用 <code>let</code> 将一个 “值” 绑定到 “变量”:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">an_integer</span> = <span class="hljs-number">1u32</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a_boolean</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">unit</span> = ();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">copied_integer</span> = an_integer;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>默认情况下这些变量是不可变的, 除非加上 <code>mut</code> 关键字:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_immutable_binding</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">mutable_binding</span> = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Before mutation: &#123;&#125;&quot;</span>, mutable_binding);<br><br>    <span class="hljs-comment">// 正确代码</span><br>    mutable_binding += <span class="hljs-number">1</span>;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;After mutation: &#123;&#125;&quot;</span>, mutable_binding);<br><br>    <span class="hljs-comment">// 错误！</span><br>    _immutable_binding += <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 改正 ^ 将此行注释掉</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Rust 中函数定义的格式为:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">FuncName</span>(arg1: type1, arg2: type2, ...) <span class="hljs-punctuation">-&gt;</span> ReturnType &#123;<br>    <span class="hljs-comment">// Body</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">greet</span>(name: <span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello &#123;&#125;&quot;</span>, name);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">greet</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;orkarin&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>函数返回可以是显式或隐式:</p>
<ul>
<li>显式返回, 指使用 <code>return</code> 关键字提前返回</li>
<li>隐式返回, 是函数块的最后一个语句的结果</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">max</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    b<br>&#125;<br></code></pre></td></tr></table></figure>

<p>返回多个值时使用元组:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>) &#123;<br>    (a + b, a * b)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (sum, product) = <span class="hljs-title function_ invoke__">calculate</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Sum: &#123;&#125;, Product: &#123;&#125;&quot;</span>, sum, product);<br>    <span class="hljs-comment">// 输出：Sum: 7, Product: 12</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><p><code>struct</code> (“structure”, 结构体), 用于组织多个相关的值, 定义一个新类型.</p>
<p>Rust 支持多种不同的结构体, 常见的有 3 中:</p>
<ol>
<li>Named-Field Struct</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u32</span>,<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>每个字段有名字, 可以通过名字访问: <code>person.name</code></li>
</ul>
<ol start="2">
<li>Tuple struct</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li>字段没有名字, 通过位置访问, 如 <code>point.0</code>, <code>point.1</code></li>
</ul>
<ol start="3">
<li>Unit-like struct</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Empty</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>没有字段, 仅用于标记类型</li>
</ul>
<h2 id="可选字段"><a href="#可选字段" class="headerlink" title="可选字段"></a>可选字段</h2><p>设置字段为 <code>Option&lt;T&gt;</code> 类型, 说明是可选字段:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Config</span> &#123;<br>    timeout: <span class="hljs-type">u32</span>,<br>    retries: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt;,<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="Name-field-struct-初始化"><a href="#Name-field-struct-初始化" class="headerlink" title="Name-field struct 初始化"></a>Name-field struct 初始化</h3><p>通过 <code>StructName &#123; field1: value1, field2: value2, ... &#125;</code> 的语法来初始化.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u32</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Person &#123;<br>        name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;orkarin&quot;</span>),<br>        age: <span class="hljs-number">22</span>,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Name: &#123;&#125;, age: &#123;&#125;&quot;</span>, p.name, p.age);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也可以省略字段名, 但需要变量名与字段名相同:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Bob&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-number">25</span>;<br><br>    <span class="hljs-comment">// 注意：字段名和变量名相同，可以简写</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Person &#123; name, age &#125;;  <span class="hljs-comment">// 等价于 Person &#123; name: name, age: age &#125;</span><br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Name: &#123;&#125;, Age: &#123;&#125;&quot;</span>, p.name, p.age);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Tuple-struct-初始化"><a href="#Tuple-struct-初始化" class="headerlink" title="Tuple-struct 初始化"></a>Tuple-struct 初始化</h3><p>通过位置索引传值:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-title function_ invoke__">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;X: &#123;&#125;, Y: &#123;&#125;&quot;</span>, p.<span class="hljs-number">0</span>, p.<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="为某个类型实现方法"><a href="#为某个类型实现方法" class="headerlink" title="为某个类型实现方法"></a>为某个类型实现方法</h2><p>需要用 <code>impl TypeName</code> 语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dog</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bark</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; says: wof!&quot;</span>, <span class="hljs-keyword">self</span>.name);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = Dog &#123;<br>        name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Jecky&quot;</span>),<br>    &#125;<br>    d.<span class="hljs-title function_ invoke__">bark</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>&amp;self</code> 是 <code>self: &amp;Self</code> 的语法糖</li>
<li><code>Self</code> 指代当前类型</li>
</ul>
<h3 id="定义初始化方法"><a href="#定义初始化方法" class="headerlink" title="定义初始化方法"></a>定义初始化方法</h3><p>定义 <code>fn new(...) -&gt; Self &#123; ... &#125;</code> 的方法来当作 “构造函数” 使用 (rust 中没有 “构造函数” 的概念, 这里也不一定是 <code>new</code>, 只是一种命名约定):</p>
<ul>
<li><code>Self</code> 指当前类型的一个实例</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u32</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Person &#123; name, age &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>解构, 指获取 struct 中各字段的值:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123; x: (<span class="hljs-type">u32</span>, <span class="hljs-type">u32</span>), y: <span class="hljs-type">u32</span> &#125;<br><br>    <span class="hljs-comment">// 解构结构体的成员</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">foo</span> = Foo &#123; x: (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), y: <span class="hljs-number">3</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">Foo</span> &#123; x: (a, b), y &#125; = foo;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a = &#123;&#125;, b = &#123;&#125;,  y = &#123;&#125; &quot;</span>, a, b, y);<br><br>    <span class="hljs-comment">// 可以解构结构体并重命名变量，成员顺序并不重要</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">Foo</span> &#123; y: i, x: j &#125; = foo;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i = &#123;:?&#125;, j = &#123;:?&#125;&quot;</span>, i, j);<br><br>    <span class="hljs-comment">// 也可以忽略某些变量</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">Foo</span> &#123; y, .. &#125; = foo;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;y = &#123;&#125;&quot;</span>, y);<br><br>    <span class="hljs-comment">// 这将得到一个错误：模式中没有提及 `x` 字段</span><br>    <span class="hljs-comment">// let Foo &#123; y &#125; = foo;</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h1><p>Rust 中的 enum (enumeration) 不是普通的 “枚举”, 包含了很多高级抽象.</p>
<p><code>enum</code> 是一种自定义数据结构, 允许定义一个类型, 该类型可以是多个不同可能值 (variants) 中的某一个.</p>
<p>定义 <code>enum</code> 的语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">EnumName</span> &#123;<br>    var1,<br>    var2,<br>    <span class="hljs-title function_ invoke__">var3</span>(type1, type2), <span class="hljs-comment">// 可以携带数据</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>enum</code> 通常配合 <code>match</code> 语句使用.</p>
<h2 id="不携带数据的示例"><a href="#不携带数据的示例" class="headerlink" title="不携带数据的示例"></a>不携带数据的示例</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;<br>    Up,<br>    Down,<br>    Left,<br>    Right<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">dir</span> = Direction::Up;<br>    <span class="hljs-keyword">match</span> dir &#123;<br>        Direction::Up =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Up&quot;</span>),<br>        Direction::Down =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Down&quot;</span>),<br>        Direction::Left =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Left&quot;</span>),<br>        Direction::Right =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Right&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="携带数据的示例"><a href="#携带数据的示例" class="headerlink" title="携带数据的示例"></a>携带数据的示例</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Quit,       <span class="hljs-comment">// 无数据</span><br>    Move &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> &#125;, <span class="hljs-comment">// 匿名结构体</span><br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>), <span class="hljs-comment">// 元组结构体</span><br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>) <span class="hljs-comment">// 元组结构体</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>这些携带数据的类型都称 enum variant</li>
</ul>
<p>示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Quit,<br>    Move &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> &#125;,<br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">process_message</span>(msg: Message) &#123;<br>    <span class="hljs-keyword">match</span> msg &#123;<br>        Message::Quit =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;退出程序&quot;</span>),<br>        Message::Move &#123; x, y &#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;移动到 x=&#123;&#125;, y=&#123;&#125;&quot;</span>, x, y),<br>        Message::<span class="hljs-title function_ invoke__">Write</span>(text) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;打印消息: &#123;&#125;&quot;</span>, text),<br>        Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;改变颜色为 RGB(&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;</span>, r, g, b),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">messages</span> = [<br>        Message::Quit,<br>        Message::Move &#123; x: <span class="hljs-number">10</span>, y: <span class="hljs-number">20</span> &#125;,<br>        Message::<span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello Rust&quot;</span>)),<br>        Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>    ];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">msg</span> <span class="hljs-keyword">in</span> messages &#123;<br>        <span class="hljs-title function_ invoke__">process_message</span>(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="C-风格用法"><a href="#C-风格用法" class="headerlink" title="C 风格用法"></a>C 风格用法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 该属性用于隐藏对未使用代码的警告。</span><br><span class="hljs-meta">#![allow(dead_code)]</span><br><br><span class="hljs-comment">// 拥有隐式辨别值（implicit discriminator，从 0 开始）的 enum</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Number</span> &#123;<br>    Zero,<br>    One,<br>    Two,<br>&#125;<br><br><span class="hljs-comment">// 拥有显式辨别值（explicit discriminator）的 enum</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red = <span class="hljs-number">0xff0000</span>,<br>    Green = <span class="hljs-number">0x00ff00</span>,<br>    Blue = <span class="hljs-number">0x0000ff</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// `enum` 可以转成整型。</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;zero is &#123;&#125;&quot;</span>, Number::Zero <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;one is &#123;&#125;&quot;</span>, Number::One <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;roses are #&#123;:06x&#125;&quot;</span>, Color::Red <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;violets are #&#123;:06x&#125;&quot;</span>, Color::Blue <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h1><p>泛型, 用于处理任意类型的参数, 可以在函数定义, struct 定义, enum 定义, <code>impl</code> 等中使用泛型.</p>
<p>泛型参数的使用尖括号和大驼峰命名, 比如 <code>&lt;Aaa, Bbb, ...&gt;</code>. 一般用 <code>&lt;T&gt;</code> 来表示.</p>
<p>任何使用了泛型类型参数表示的类型都是 “泛型”, 其他的类型称 “具体类型”.</p>
<h2 id="Generic-Functions"><a href="#Generic-Functions" class="headerlink" title="Generic Functions"></a>Generic Functions</h2><p>定义泛型函数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largest</span>&lt;T: <span class="hljs-built_in">PartialOrd</span>&gt;(a: T, b: T) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        b<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-title function_ invoke__">largest</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-title function_ invoke__">largest</span>(<span class="hljs-number">3.14</span>, <span class="hljs-number">2.71</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> = <span class="hljs-title function_ invoke__">largest</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Largest one: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, x, y, z);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>&lt;T: PartialOrd&gt;</code> 的语法指定一个 Trait Bound, 表示 <code>T</code> 需要实现了 <code>PartialOrd</code> 才能用于这个函数</li>
</ul>
<h2 id="Generic-Structs"><a href="#Generic-Structs" class="headerlink" title="Generic Structs"></a>Generic Structs</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    value: T,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">int_box</span> = <span class="hljs-type">Box</span> &#123; value: <span class="hljs-number">42</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_box</span> = <span class="hljs-type">Box</span> &#123; value: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>) &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;整型盒子: &#123;&#125;, 字符串盒子: &#123;&#125;&quot;</span>, int_box.value, str_box.value);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Generic-enums"><a href="#Generic-enums" class="headerlink" title="Generic enums"></a>Generic enums</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Generic-impl"><a href="#Generic-impl" class="headerlink" title="Generic impl"></a>Generic impl</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>; <span class="hljs-comment">// 具体类型 `S`</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GenericVal</span>&lt;T&gt;(T,); <span class="hljs-comment">// 泛型类型 `GenericVal`</span><br><br><span class="hljs-comment">// GenericVal 的 `impl`，此处我们显式地指定了类型参数：</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">GenericVal</span>&lt;<span class="hljs-type">f32</span>&gt; &#123;&#125; <span class="hljs-comment">// 指定 `f32` 类型</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">GenericVal</span>&lt;S&gt; &#123;&#125; <span class="hljs-comment">// 指定为上面定义的 `S`</span><br><br><span class="hljs-comment">// `&lt;T&gt;` 必须在类型之前写出来，以使类型 `T` 代表泛型。</span><br><span class="hljs-keyword">impl</span> &lt;T&gt; GenericVal&lt;T&gt; &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="Generic-Traits"><a href="#Generic-Traits" class="headerlink" title="Generic Traits"></a>Generic Traits</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Printable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print</span>(&amp;<span class="hljs-keyword">self</span>, value: T);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Printer</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Printable</span>&lt;<span class="hljs-type">i32</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Printer</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print</span>(&amp;<span class="hljs-keyword">self</span>, value: <span class="hljs-type">i32</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;整型值: &#123;&#125;&quot;</span>, value);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Printable</span>&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Printer</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print</span>(&amp;<span class="hljs-keyword">self</span>, value: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;字符串值: &#123;&#125;&quot;</span>, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Generic-Constrains"><a href="#Generic-Constrains" class="headerlink" title="Generic Constrains"></a>Generic Constrains</h2><p>Generic Constrains, 泛型约束, 用于确保传入的参数类型具有某种 trait, 比如:</p>
<ul>
<li>是否能打印? (是否实现了 <code>Display</code> 或 <code>Debug</code>)</li>
<li>是否能比较? (是否实现了 <code>PartialEq</code> 或 <code>PartialOrd</code>)</li>
<li>是否能克隆? (是否实现了 <code>Clone</code>)</li>
</ul>
<p>Rust 提供两种写法来为泛型添加约束:</p>
<ul>
<li>直接在泛型参数后写约束 (内联约束), 如 <code>fn foo&lt;T: Display&gt;(x: T)</code></li>
<li>使用 <code>where</code> 子句, 将约束与函数签名分开写, 如 <code>fn foo&lt;T&gt;(x: T) where T: Display</code></li>
</ul>
<p>若有多个约束, 用 <code>where</code> 子句更清晰:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">compare_and_print</span>&lt;T, U&gt;(a: T, b: U)<br><span class="hljs-keyword">where</span><br>    T: std::fmt::Display + <span class="hljs-built_in">PartialOrd</span>,<br>    U: std::fmt::<span class="hljs-built_in">Debug</span>,<br>&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a = &#123;&#125;, b = &#123;:?&#125;&quot;</span>, a, b);<br>    <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有时让 trait 不包含任何功能, 此时的约束称 “空约束”:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cardinal</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BlueJay</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Turkey</span>;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Red</span> &#123;&#125;<br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Blue</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Red</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Cardinal</span> &#123;&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Blue</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">BlueJay</span> &#123;&#125;<br><br><span class="hljs-comment">// 这些函数只对实现了相应的 trait 的类型有效。</span><br><span class="hljs-comment">// 事实上这些 trait 内部是空的，但这没有关系。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">red</span>&lt;T: Red&gt;(_: &amp;T)   <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> &#123; <span class="hljs-string">&quot;red&quot;</span> &#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">blue</span>&lt;T: Blue&gt;(_: &amp;T) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> &#123; <span class="hljs-string">&quot;blue&quot;</span> &#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cardinal</span> = Cardinal;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">blue_jay</span> = BlueJay;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_turkey</span>   = Turkey;<br><br>    <span class="hljs-comment">// 由于约束，`red()` 不能作用于 blue_jay （蓝松鸟），反过来也一样。</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;A cardinal is &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">red</span>(&amp;cardinal));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;A blue jay is &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">blue</span>(&amp;blue_jay));<br>    <span class="hljs-comment">//println!(&quot;A turkey is &#123;&#125;&quot;, red(&amp;_turkey));</span><br>    <span class="hljs-comment">// ^ 试一试：去掉此行注释。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><p>如果一个泛型类型包含其他泛型:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 容器 `C` 就包含了 `A` 和 `B` 类型。鉴于此，必须指出 `A` 和 `B` 显得很麻烦。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">difference</span>&lt;A, B, C&gt;(container: &amp;C) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> <span class="hljs-keyword">where</span><br>    C: Contains&lt;A, B&gt; &#123;<br>    container.<span class="hljs-title function_ invoke__">last</span>() - container.<span class="hljs-title function_ invoke__">first</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以通过在 <code>trait</code> 中定义内部可使用的泛型, 从而能简写:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// `A` 和 `B` 在 trait 里面通过 `type` 关键字来定义。</span><br><span class="hljs-comment">// （注意：此处的 `type` 不同于为类型取别名时的 `type`）。</span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Contains</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">A</span>;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">B</span>;<br><br>    <span class="hljs-comment">// 这种语法能够泛型地表示这些新类型。</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>, _: &amp;<span class="hljs-keyword">Self</span>::A, _: &amp;<span class="hljs-keyword">Self</span>::B) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>;<br>&#125;<br><span class="hljs-comment">// 不使用关联类型</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">difference</span>&lt;A, B, C&gt;(container: &amp;C) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> <span class="hljs-keyword">where</span><br>    C: Contains&lt;A, B&gt; &#123; ... &#125;<br><br><span class="hljs-comment">// 使用关联类型</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">difference</span>&lt;C: Contains&gt;(container: &amp;C) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure>

<h1 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h1><p>Trait (“特质”, “特性”), 在 Rust 中用于定义一组方法&#x2F;函数的签名, 描述某个类型应该具有哪些方法, 但不提供具体实现.</p>
<p>Trait 从字面上理解, 表示某个类型所具备的 “能力”, 比如:</p>
<ul>
<li>一个类型是否可以打印自己? $\rightarrow$ 实现了 <code>Displaytrait</code> (自己定义的一个 <code>trait</code>)</li>
<li>一个类型是否可以比较大小? $\rightarrow$ 实现了 <code>PartialEq/Ordtrait</code></li>
</ul>
<p>定义一个 <code>trait</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Speak</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">speak</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="为某个类型实现-trait"><a href="#为某个类型实现-trait" class="headerlink" title="为某个类型实现 trait"></a>为某个类型实现 trait</h2><p>需要用 <code>impl ... for ...</code> 语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">TraitName</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">TypeName</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cat</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::<span class="hljs-built_in">Debug</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;Cat(name = &#123;&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.name)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Cat &#123;<br>        name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Mimi&quot;</span>),<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="派生"><a href="#派生" class="headerlink" title="派生"></a>派生</h2><p>派生, 指用 <code>#[derive]</code> 属性, 提供编译器能自动实现的基本 <code>trait</code>, 比如:</p>
<ul>
<li><code>Eq</code>, <code>PartialEq</code>, <code>Ord</code>, <code>PartialOrd</code></li>
<li><code>Clone</code>, 用于从 <code>&amp;T</code> 创建副本 <code>T</code></li>
<li><code>Copy</code>, 使类型具有 <code>copy semantics</code></li>
<li><code>Hash</code>, 从 <code>&amp;T</code> 计算哈希值</li>
<li><code>Default</code>, 创建数据类型的一个空实例</li>
<li><code>Debug</code>, 使用 <code>&#123;:?&#125;</code> 来格式化一个值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// `Inches`，可以打印的元组结构体</span><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Inches</span>(<span class="hljs-type">i32</span>);<br></code></pre></td></tr></table></figure>

<h2 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h2><p>如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;(Read more...)&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h1><p>Attribute (“属性”), 指附加在代码元素 (如 <code>struct</code>, 函数, 模块等) 上的元信息或指令, 其告诉 Rust 编译器, 这部分需要做特殊处理.</p>
<p>添加 Attribute 的语法如下, 通常写在被修饰对象的上方或左侧:</p>
<p>当 attribute 作用于整个 crate 时, 语法为 <code>#![crate_attribute]</code>, 作用于 mod 或 item 时为 <code>#[item_attribute]</code>.</p>
<p>Attribute 可以接受参数, 语法形式有:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[attribute_name = <span class="hljs-string">&quot;value&quot;</span>]</span><br><span class="hljs-meta">#[attribute_name(key = <span class="hljs-string">&quot;value&quot;</span>)]</span><br><span class="hljs-meta">#[attribute_name(value)]</span><br></code></pre></td></tr></table></figure>

<p>Attribute 分三类:</p>
<ul>
<li>标准属性, 由 Rust 语言提供, 如 <code>#[derive]</code>, <code>#[allow]</code>, <code>#[cfg]</code></li>
<li>过程宏属性, 由第三方库提供, 如 <code>#[tokio::main]</code>, <code>#[route(GET, &quot;/)]</code></li>
</ul>
<p>常见的属性有:</p>
<ul>
<li><code>#[derive(Trait_name)]</code>, 为结构体自动生成某个 trait 的实现</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u32</span>,<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="dead-code"><a href="#dead-code" class="headerlink" title="dead_code"></a><code>dead_code</code></h2><p>编译器提供了 <code>dead_code</code> lint, 会对未使用的函数产生警告, 可以用 <code>allow</code> 属性来警用这个 lint:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[allow(dead_code)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">unused_function</span>() &#123;&#125;<br></code></pre></td></tr></table></figure>

<h2 id="crate"><a href="#crate" class="headerlink" title="crate"></a>crate</h2><p><code>crate_type</code> 属性告知编译器 crate 是一个二进制可执行文件还是一个库. <code>crate_name</code> 用于设定 <code>crate</code> 的名称.</p>
<p>但使用 cargo 时这两个属性不会起作用:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 这个 crate 是一个库文件</span><br><span class="hljs-meta">#![crate_type = <span class="hljs-string">&quot;lib&quot;</span>]</span><br><span class="hljs-comment">// 库的名称为 “rary”</span><br><span class="hljs-meta">#![crate_name = <span class="hljs-string">&quot;rary&quot;</span>]</span><br></code></pre></td></tr></table></figure>

<p>此时不需要给 <code>rustc</code> 加上 <code>--crate-type</code> 标记:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ rustc lib.rs<br>$ <span class="hljs-built_in">ls</span> lib*<br>library.rlib<br></code></pre></td></tr></table></figure>

<h2 id="cfg"><a href="#cfg" class="headerlink" title="cfg"></a>cfg</h2><p>条件编译通过两种方式实现:</p>
<ul>
<li><code>cfg</code> attribute, <code>#[cfg(...)]</code></li>
<li><code>cfg!</code> 宏, 在布尔表达式中使用 <code>cfg!(...)</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 这个函数仅当目标系统是 Linux 的时候才会编译</span><br><span class="hljs-meta">#[cfg(target_os = <span class="hljs-string">&quot;linux&quot;</span>)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">are_you_on_linux</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;You are running linux!&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 而这个函数仅当目标系统 **不是** Linux 时才会编译</span><br><span class="hljs-meta">#[cfg(not(target_os = <span class="hljs-string">&quot;linux&quot;</span>))]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">are_you_on_linux</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;You are *not* running linux!&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">are_you_on_linux</span>();<br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Are you sure?&quot;</span>);<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">cfg!</span>(target_os = <span class="hljs-string">&quot;linux&quot;</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Yes. It&#x27;s definitely linux!&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Yes. It&#x27;s definitely *not* linux!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Ownership-borrowing-和-mutability"><a href="#Ownership-borrowing-和-mutability" class="headerlink" title="Ownership, borrowing 和 mutability"></a>Ownership, borrowing 和 mutability</h1><p>Ownership 指, Rust 中的所有值都有一个 owner (一个变量), 当 owner 离开作用域时, 值会被自动释放.</p>
<p>Borrowing 指, 可以用过 reference (<code>&amp;T</code> 或 <code>&amp;mut T</code>) 来借用一个值, 而不用获取其所有权.</p>
<p>Mutability 指, 默认情况下, Rust 中的变量和引用都是 immutable (不可变的), 除非显式使用 <code>mut</code> 关键字.</p>
<h2 id="mut-关键字"><a href="#mut-关键字" class="headerlink" title="mut 关键字"></a>mut 关键字</h2><p><code>mut</code> 让变量变为 mutable, 其本质是, 表示可以重新绑定这个变量指向的值.</p>
<p>默认情况下, 修改变量会报错:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">10</span>;<br>    x = <span class="hljs-number">20</span>; <span class="hljs-comment">// ❌ 编译错误！不能修改不可变变量</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用 <code>mut</code> 后可更改:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = <span class="hljs-number">10</span>; <span class="hljs-comment">// 使用 mut 声明 x 是可变的</span><br>    x = <span class="hljs-number">20</span>;         <span class="hljs-comment">// ✅ 可以修改</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x = &#123;&#125;&quot;</span>, x); <span class="hljs-comment">// 输出：x = 20</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>在 Rust 中, 通常不会直接传递变量的所有权, 而是通过 reference 来借用某个值, 从而在不获取所有权的情况下访问和操作.</p>
<p>Reference 分两种:</p>
<ul>
<li>Immutable reference, <code>&amp;T</code>, 可以读取值但不能修改<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span> = &amp;x; <span class="hljs-comment">// r 是一个不可变引用，指向 x</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r = &#123;&#125;&quot;</span>, r); <span class="hljs-comment">// ✅ 可以读取</span><br>    <span class="hljs-comment">// r = 20; // ❌ 错误！不能通过不可变引用修改值</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>Mutable reference, <code>&amp;mut T</code>, 可以读取和修改但有严格限制. 构建 mutable reference 需要满足几个条件:<ul>
<li>变量本身是 <code>mut</code> 的</li>
<li>只能同时有一个可变引用</li>
<li>不能同时有可变引用和不可变引用</li>
</ul>
</li>
</ul>
<p>不可变引用可以创建多个.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = <span class="hljs-number">10</span>;     <span class="hljs-comment">// 变量必须是 mut 的</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span> = &amp;<span class="hljs-keyword">mut</span> x;     <span class="hljs-comment">// r 是一个可变引用</span><br>    *r = <span class="hljs-number">20</span>;            <span class="hljs-comment">// 通过解引用修改值</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x = &#123;&#125;&quot;</span>, x); <span class="hljs-comment">// 输出：x = 20</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h2><p>可以用 <code>std::mem::drop</code> 来显式地提前终止一个值的所有权 (会自动调用析构逻辑), 从而释放它占用的资源:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::mem;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    mem::<span class="hljs-title function_ invoke__">drop</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Rust 中, 每个类型可以选择性实现 <code>Drop</code> trait:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Drop</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ToDrop</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">ToDrop</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;ToDrop is being dropped&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = ToDrop;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Made a ToDrop!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="所有权转移"><a href="#所有权转移" class="headerlink" title="所有权转移"></a>所有权转移</h2><p>Rust 中, 任何时候, 一个值只能有一个 owner.</p>
<p>如果一个类型没有实现 <code>Copy</code> trait 则在下面操作时都会发生所有权转移 (<code>move</code>), 导致原变量不再有效:</p>
<ul>
<li>把一个值赋给另一个变量 (如 <code>let a = b;</code>)</li>
<li>把值作为参数传给函数 (如 <code>foo(x)</code>)</li>
<li>把值放如集合 (如 <code>vec.push(x)</code>)</li>
<li>把值作为返回值返回</li>
</ul>
<p>比如:</p>
<ul>
<li><code>String</code></li>
<li><code>Vec&lt;T&gt;</code></li>
<li><code>Box&lt;T&gt;</code></li>
<li><code>struct</code></li>
<li><code>enum</code></li>
<li>闭包</li>
<li>文件句柄, 网络连接, 锁等资源类型</li>
</ul>
<p>变量赋值时的所有权转移:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;  <span class="hljs-comment">// 所有权从 s1 转移到了 s2</span><br><br><span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;, s1); // ❌ 编译错误！s1 不再有效</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s2); <span class="hljs-comment">// ✅ 只有 s2 可用</span><br></code></pre></td></tr></table></figure>

<p>将值传给函数时的所有权转移:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_ownership</span>(s: <span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>&#125; <span class="hljs-comment">// s 离开作用域，drop 被调用，内存释放</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-title function_ invoke__">take_ownership</span>(s); <span class="hljs-comment">// 所有权从 main 中的 s 移动到了函数参数 s</span><br><br>    <span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;, s); // ❌ 编译错误！s 的所有权已经转移走</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>把值放入集合时的所有权转移:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>v.<span class="hljs-title function_ invoke__">push</span>(s); <span class="hljs-comment">// 所有权从 s 移动到了 Vec 中</span><br><br><span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;, s); // ❌ 编译错误！s 已经被移动进 Vec</span><br></code></pre></td></tr></table></figure>

<h2 id="不发生所有权转移"><a href="#不发生所有权转移" class="headerlink" title="不发生所有权转移"></a>不发生所有权转移</h2><p>如果类型实现了 <code>Copy</code> trait, 比如:</p>
<ul>
<li>所有整数类型: <code>i32</code>, <code>u8</code> …</li>
<li>布尔类型: <code>bool</code></li>
<li>浮点数: <code>f32</code>, <code>f64</code></li>
<li>字符: <code>char</code></li>
<li>某些固定大小的数组, 如 <code>[i32; 2]</code></li>
</ul>
<p>此时发生拷贝, 而非所有权转移. 比如;</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x; <span class="hljs-comment">// 拷贝，不是 move</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y); <span class="hljs-comment">// ✅ x 依然有效</span><br></code></pre></td></tr></table></figure>

<p>借用时也不会发生所有权转移:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&amp;s); <span class="hljs-comment">// 传递引用，不是所有权</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;字符串 &#x27;&#123;&#125;&#x27; 的长度是 &#123;&#125;&quot;</span>, s, len); <span class="hljs-comment">// ✅ s 依然有效</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="可变性改变"><a href="#可变性改变" class="headerlink" title="可变性改变"></a>可变性改变</h2><p>在所有权转移时, 数据的可变性可能发生改变:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">immutable_box</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5u32</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;immutable_box contains &#123;&#125;&quot;</span>, immutable_box);<br><br>    <span class="hljs-comment">// 可变性错误</span><br>    <span class="hljs-comment">//*immutable_box = 4;</span><br><br>    <span class="hljs-comment">// *移动* box，改变所有权（和可变性）</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">mutable_box</span> = immutable_box;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;mutable_box contains &#123;&#125;&quot;</span>, mutable_box);<br><br>    <span class="hljs-comment">// 修改 box 的内容</span><br>    *mutable_box = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;mutable_box now contains &#123;&#125;&quot;</span>, mutable_box);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ref-模式"><a href="#ref-模式" class="headerlink" title="ref 模式"></a>ref 模式</h2><p>在通过 <code>let</code> 绑定来进行模式匹配或解构时, <code>ref</code> 关键字用来创建结构体&#x2F;元组的字段的引用, 可用于只移动部分变量:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-meta">#[derive(Debug)]</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>        name: <span class="hljs-type">String</span>,<br>        age: <span class="hljs-type">u8</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">person</span> = Person &#123;<br>        name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Alice&quot;</span>),<br>        age: <span class="hljs-number">20</span>,<br>    &#125;;<br><br>    <span class="hljs-comment">// `name` 从 person 中移走，但 `age` 只是引用</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">Person</span> &#123; name, <span class="hljs-keyword">ref</span> age &#125; = person;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The person&#x27;s age is &#123;&#125;&quot;</span>, age);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The person&#x27;s name is &#123;&#125;&quot;</span>, name);<br><br>    <span class="hljs-comment">// 报错！部分移动值的借用：`person` 部分借用产生</span><br>    <span class="hljs-comment">//println!(&quot;The person struct is &#123;:?&#125;&quot;, person);</span><br><br>    <span class="hljs-comment">// `person` 不能使用，但 `person.age` 因为没有被移动而可以继续使用</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The person&#x27;s age from person struct is &#123;&#125;&quot;</span>, person.age);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>详细示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone, Copy)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> &#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-string">&#x27;Q&#x27;</span>;<br><br>    <span class="hljs-comment">// 赋值语句中左边的 `ref` 关键字等价于右边的 `&amp;` 符号。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ref</span> ref_c1 = c;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ref_c2</span> = &amp;c;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;ref_c1 equals ref_c2: &#123;&#125;&quot;</span>, *ref_c1 == *ref_c2);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">point</span> = Point &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> &#125;;<br><br>    <span class="hljs-comment">// 在解构一个结构体时 `ref` 同样有效。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_copy_of_x</span> = &#123;<br>        <span class="hljs-comment">// `ref_to_x` 是一个指向 `point` 的 `x` 字段的引用。</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">Point</span> &#123; x: <span class="hljs-keyword">ref</span> ref_to_x, y: _ &#125; = point;<br><br>        <span class="hljs-comment">// 返回一个 `point` 的 `x` 字段的拷贝。</span><br>        *ref_to_x<br>    &#125;;<br><br>    <span class="hljs-comment">// `point` 的可变拷贝</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">mutable_point</span> = point;<br><br>    &#123;<br>        <span class="hljs-comment">// `ref` 可以与 `mut` 结合以创建可变引用。</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">Point</span> &#123; x: _, y: <span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> mut_ref_to_y &#125; = mutable_point;<br><br>        <span class="hljs-comment">// 通过可变引用来改变 `mutable_point` 的字段 `y`。</span><br>        *mut_ref_to_y = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;point is (&#123;&#125;, &#123;&#125;)&quot;</span>, point.x, point.y);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;mutable_point is (&#123;&#125;, &#123;&#125;)&quot;</span>, mutable_point.x, mutable_point.y);<br><br>    <span class="hljs-comment">// 包含一个指针的可变元组</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">mutable_tuple</span> = (<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5u32</span>), <span class="hljs-number">3u32</span>);<br>    <br>    &#123;<br>        <span class="hljs-comment">// 解构 `mutable_tuple` 来改变 `last` 的值。</span><br>        <span class="hljs-keyword">let</span> (_, <span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> last) = mutable_tuple;<br>        *last = <span class="hljs-number">2u32</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;tuple is &#123;:?&#125;&quot;</span>, mutable_tuple);<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="Debug-输出"><a href="#Debug-输出" class="headerlink" title="Debug 输出"></a>Debug 输出</h1><p>实现了 <code>std::fmt</code> 中的 <code>fmt::Debug</code> trait 的类型可以用 <code>&#123;:?&#125;</code> 标记来格式化 debug 输出:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age:  <span class="hljs-type">u8</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Person &#123;<br>        name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;orkarin&quot;</span>),<br>        age: <span class="hljs-number">22</span>,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Debug print: &#123;:?&#125;&quot;</span>, p);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">Debug print: Person &#123; name: <span class="hljs-string">&quot;orkarin&quot;</span>, age: <span class="hljs-number">22</span> &#125;<br></code></pre></td></tr></table></figure>

<p>可以用 <code>&#123;:#?&#125;</code> 输出 “美化打印”.</p>
<h1 id="Display-输出"><a href="#Display-输出" class="headerlink" title="Display 输出"></a>Display 输出</h1><p>可以实现 <code>fmt::Display</code> trait 来自定义 <code>&#123;&#125;</code> 的输出效果:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-comment">// （使用 `use`）导入 `fmt` 模块使 `fmt::Display` 可用</span><br><span class="hljs-keyword">use</span> std::fmt;<br><br><span class="hljs-comment">// 定义一个结构体，咱们会为它实现 `fmt::Display`。以下是个简单的元组结构体</span><br><span class="hljs-comment">// `Structure`，包含一个 `i32` 元素。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Structure</span>(<span class="hljs-type">i32</span>);<br><br><span class="hljs-comment">// 为了使用 `&#123;&#125;` 标记，必须手动为类型实现 `fmt::Display` trait。</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title class_">Structure</span> &#123;<br>    <span class="hljs-comment">// 这个 trait 要求 `fmt` 使用与下面的函数完全一致的函数签名</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>        <span class="hljs-comment">// 仅将 self 的第一个元素写入到给定的输出流 `f`。返回 `fmt:Result`，此</span><br>        <span class="hljs-comment">// 结果表明操作成功或失败。注意 `write!` 的用法和 `println!` 很相似。</span><br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h2><p>Rust 中的 <code>if</code> 是一个表达式, 有返回值, 可以赋值给变量:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5</span> &#123;<br>        <span class="hljs-string">&quot;Greater than 5&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-string">&quot;Less than 5&quot;</span><br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>条件不需要用 <code>()</code> 包裹, 当然也可以加上</li>
</ul>
<p>注意所有分支必须返回同一类型.</p>
<h2 id="loop-无限循环"><a href="#loop-无限循环" class="headerlink" title="loop 无限循环"></a>loop 无限循环</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mu</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        count += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> count == <span class="hljs-number">5</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;count = &#123;&#125;&quot;</span>, count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>loop</code> 必须用 <code>break</code> 才能退出</li>
<li>可以有返回值, 如 <code>let val = loop &#123; break 42; &#125;</code></li>
</ul>
<p>嵌套 <code>loop</code> 时, 必须通过 <code>label</code> 来注明:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unreachable_code)]</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-symbol">&#x27;outer</span>: <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Entered the outer loop&quot;</span>);<br><br>        <span class="hljs-symbol">&#x27;inner</span>: <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Entered the inner loop&quot;</span>);<br><br>            <span class="hljs-comment">// 这只是中断内部的循环</span><br>            <span class="hljs-comment">//break;</span><br><br>            <span class="hljs-comment">// 这会中断外层循环</span><br>            <span class="hljs-keyword">break</span> <span class="hljs-symbol">&#x27;outer</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;This point will never be reached&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Exited the outer loop&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="while-条件循环"><a href="#while-条件循环" class="headerlink" title="while 条件循环"></a>while 条件循环</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> x &lt; <span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x = &#123;&#125;&quot;</span>, x);<br>        x += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">5</span> &#123;  <span class="hljs-comment">// 0, 1, 2, 3, 4</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i = &#123;&#125;&quot;</span>, i);<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;arr &#123;  <span class="hljs-comment">// 借用数组元素</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;item = &#123;&#125;&quot;</span>, item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="match-模式匹配"><a href="#match-模式匹配" class="headerlink" title="match 模式匹配"></a>match 模式匹配</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">match</span> x &#123;<br>        <span class="hljs-number">1</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;一&quot;</span>),<br>        <span class="hljs-number">2</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;二&quot;</span>),<br>        <span class="hljs-number">3</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;三&quot;</span>),<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;其他&quot;</span>), <span class="hljs-comment">// _ 是通配符，匹配所有其他情况</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意, <code>match</code> 分支需要包含所有情况.</p>
<p>可以加上 <code>guard</code> (if 条件判断) 来过滤分支:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pair</span> = (<span class="hljs-number">2</span>, -<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 试一试 ^ 将不同的值赋给 `pair`</span><br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Tell me about &#123;:?&#125;&quot;</span>, pair);<br>    <span class="hljs-keyword">match</span> pair &#123;<br>        (x, y) <span class="hljs-keyword">if</span> x == y =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;These are twins&quot;</span>),<br>        <span class="hljs-comment">// ^ `if` 条件部分是一个卫语句</span><br>        (x, y) <span class="hljs-keyword">if</span> x + y == <span class="hljs-number">0</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Antimatter, kaboom!&quot;</span>),<br>        (x, _) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The first one is odd&quot;</span>),<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;No correlation...&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>如果间接访问一个变量, 则在后续分支中无法访问到, 可以用 <code>match</code> 中提供的 <code>@</code> 符号来绑定:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// `age` 函数，返回一个 `u32` 值。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">age</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-number">15</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Tell me what type of person you are&quot;</span>);<br><br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">age</span>() &#123;<br>        <span class="hljs-number">0</span>             =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;I haven&#x27;t celebrated my first birthday yet&quot;</span>),<br>        <span class="hljs-comment">// 可以直接匹配（`match`） 1 ..= 12，但那样的话孩子会是几岁？</span><br>        <span class="hljs-comment">// 相反，在 1 ..= 12 分支中绑定匹配值到 `n` 。现在年龄就可以读取了。</span><br>        n @ <span class="hljs-number">1</span>  ..= <span class="hljs-number">12</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;I&#x27;m a child of age &#123;:?&#125;&quot;</span>, n),<br>        n @ <span class="hljs-number">13</span> ..= <span class="hljs-number">19</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;I&#x27;m a teen of age &#123;:?&#125;&quot;</span>, n),<br>        <span class="hljs-comment">// 不符合上面的范围。返回结果。</span><br>        n             =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;I&#x27;m an old person of age &#123;:?&#125;&quot;</span>, n),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="括号使用规范"><a href="#括号使用规范" class="headerlink" title="括号使用规范"></a>括号使用规范</h1><h2 id=""><a href="#" class="headerlink" title="()"></a><code>()</code></h2><p>函数调用必须用 <code>()</code>, 如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">greet</span>(name: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, &#123;&#125;!&quot;</span>, name);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">greet</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>if</code>, <code>while</code>, <code>loop</code> 中的条件表达式可以不加括号:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5</span> &#123; ... &#125;           <span class="hljs-comment">// ✅ 推荐，更常见</span><br><span class="hljs-title function_ invoke__">if</span> (x &gt; <span class="hljs-number">5</span>) &amp;&amp; (y &lt; <span class="hljs-number">10</span>) &#123; &#125; <span class="hljs-comment">// ✅ 也可以加括号，提高可读性</span><br></code></pre></td></tr></table></figure>

<p>元组需要用 <code>()</code> 包裹.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="{}"></a><code>&#123;&#125;</code></h2><p>代码块如 <code>if</code>, <code>else</code>, <code>loop</code>, <code>match</code>, <code>函数</code>, <code>impl</code> 等, 必须用 <code>&#123;&#125;</code> 包裹.</p>
<p>结构体需要用 <code>&#123;&#125;</code> 包裹.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title="[]"></a><code>[]</code></h2><p>数组用 <code>[]</code> 包裹.</p>
<h1 id="Mod"><a href="#Mod" class="headerlink" title="Mod"></a>Mod</h1><p>Rust 中代码用 mod 来组织, 类似于一个命名空间, 可以控制可见性, 避免名称冲突等.</p>
<p>Mod 是 item 的集合, item 可以是: 函数, 结构体, trait, <code>impl</code> 块以及其他模块.</p>
<p>定义语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> my_module &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello from my_module!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    my_module::<span class="hljs-title function_ invoke__">hello</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>默认情况下, 模块内部的函数是 <code>private</code>, 如果想从外部访问, 需要标记为 <code>pub</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> my_module &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello from my_module!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    my_module::<span class="hljs-title function_ invoke__">hello</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>模块内部需要用 <code>::</code> 符号来访问, 可以用 <code>use</code> 来引入路径, 让调用更简洁:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> my_module &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">greet</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">use</span> my_module::greet;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">greet</span>(); <span class="hljs-comment">// 直接调用，不用写 my_module::greet()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="结构体的可见性"><a href="#结构体的可见性" class="headerlink" title="结构体的可见性"></a>结构体的可见性</h2><p>Mod 中结构体的字段默认拥有 private 的可见性, 也可以通过 <code>pub</code> 修饰使外部模块能访问:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> my &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OpenBox</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">pub</span> contents: T,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="super-和-self"><a href="#super-和-self" class="headerlink" title="super 和 self"></a>super 和 self</h2><p>在 Mod 中, <code>super</code> 指代父级, <code>self</code> 指代当前模块:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called `function()`&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">mod</span> cool &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called `cool::function()`&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">mod</span> my &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called `my::function()`&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">mod</span> cool &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called `my::cool::function()`&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">indirect_call</span>() &#123;<br>        <span class="hljs-comment">// 让我们从这个作用域中访问所有名为 `function` 的函数！</span><br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;called `my::indirect_call()`, that\n&gt; &quot;</span>);<br>        <br>        <span class="hljs-comment">// `self` 关键字表示当前的模块作用域——在这个例子是 `my`。</span><br>        <span class="hljs-comment">// 调用 `self::function()` 和直接调用 `function()` 都得到相同的结果，</span><br>        <span class="hljs-comment">// 因为他们表示相同的函数。</span><br>        self::<span class="hljs-title function_ invoke__">function</span>();<br>        <span class="hljs-title function_ invoke__">function</span>();<br>        <br>        <span class="hljs-comment">// 我们也可以使用 `self` 来访问 `my` 内部的另一个模块：</span><br>        self::cool::<span class="hljs-title function_ invoke__">function</span>();<br>        <br>        <span class="hljs-comment">// `super` 关键字表示父作用域（在 `my` 模块外面）。</span><br>        super::<span class="hljs-title function_ invoke__">function</span>();<br>        <br>        <span class="hljs-comment">// 这将在 *crate* 作用域内绑定 `cool::function` 。</span><br>        <span class="hljs-comment">// 在这个例子中，crate 作用域是最外面的作用域。</span><br>        &#123;<br>            <span class="hljs-keyword">use</span> crate::cool::function <span class="hljs-keyword">as</span> root_function;<br>            <span class="hljs-title function_ invoke__">root_function</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    my::<span class="hljs-title function_ invoke__">indirect_call</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="文件分层"><a href="#文件分层" class="headerlink" title="文件分层"></a>文件分层</h2><p>可以将 <code>Mod</code> 与 <code>main</code> 分开放置, 同 Perl, Python 模块化类似.</p>
<p>假设当前目录结构为:</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">$ tree .<br>.<br>|<span class="hljs-string">-- my</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">-- inaccessible.rs</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">-- mod.rs</span><br><span class="hljs-string"></span>|<span class="hljs-string">   `-- nested.rs</span><br><span class="hljs-string">`-- split.rs</span><br></code></pre></td></tr></table></figure>

<p><code>split.rs</code> 文件的内容为:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> my;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called `function()`&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    my::<span class="hljs-title function_ invoke__">function</span>();<br><br>    <span class="hljs-title function_ invoke__">function</span>();<br><br>    my::<span class="hljs-title function_ invoke__">indirect_access</span>();<br><br>    my::nested::<span class="hljs-title function_ invoke__">function</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>mod my;</code> 会查找名为 <code>my.rs</code> 或 <code>my/mod.rs</code> 文件, 并导入到当前作用域的 Mod <code>my</code> 中</li>
</ul>
<h1 id="use-声明"><a href="#use-声明" class="headerlink" title="use 声明"></a>use 声明</h1><p><code>use</code> 声明用于引入一个路径, 从而更简洁地访问模块, 函数, enum 等, 不用每次都写完整路径, 类似 <code>C++</code> 中的 <code>using</code>.</p>
<p>基本语法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> path::name;<br></code></pre></td></tr></table></figure>

<p>可以引入多个项:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> path::&#123;name1,name2&#125;;<br></code></pre></td></tr></table></figure>

<p>引入全部:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> path::*<br></code></pre></td></tr></table></figure>

<p>也可以把一个路径绑定到一个新名字:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> deeply::nested::function <span class="hljs-keyword">as</span> other_function;<br></code></pre></td></tr></table></figure>


<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>Rust 中有两种常量:</p>
<ul>
<li><code>const</code>, 不可改变</li>
<li><code>static</code>, 具有 <code>static</code> 生命周期</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> LANGUAGE: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Rust&quot;</span>;<br><span class="hljs-keyword">const</span>  THRESHOLD: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><p>Rust 不提供原生类型间隐式的类型转换, 但可以用 <code>as</code> 关键字进行显式类型转换.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">decimal</span> = <span class="hljs-number">65.4321f32</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">integer</span> = decimal <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">character</span> = integer <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>;<br></code></pre></td></tr></table></figure>

<p>这种转换由编译器直接处理, 可能会丢失精度, 一般用于内置基本类型之间的转换.</p>
<h1 id="Trait-类型转换"><a href="#Trait-类型转换" class="headerlink" title="Trait 类型转换"></a>Trait 类型转换</h1><p>这种类型转换通过实现 <code>trait</code> 完成, 由自己实现, 可以在任意类型之间进行逻辑转换.</p>
<h2 id="From-和-Into-trait"><a href="#From-和-Into-trait" class="headerlink" title="From 和 Into trait"></a>From 和 Into trait</h2><p><code>From</code> trait 定义 “怎么根据另一种类型生成自己”, 比如把 <code>str</code> 转换成 <code>String</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">my_str</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">my_string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(my_str);<br></code></pre></td></tr></table></figure>

<p>为自己的类型定义 <code>From</code> trait:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::convert::<span class="hljs-built_in">From</span>;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Number</span> &#123;<br>    value: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">i32</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Number</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(item: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Number &#123; value: item &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = Number::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-number">30</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;My number is &#123;:?&#125;&quot;</span>, num);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Into</code> trait 把 <code>From</code> 倒过来, 如果为一个类型实现了 <code>From</code>, 就会同时得到 <code>Into</code> 的实现 (不用自己实现了), 此时只要注意指明要转换的类型:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::convert::<span class="hljs-built_in">From</span>;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Number</span> &#123;<br>    value: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">i32</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Number</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(item: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Number &#123; value: item &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">int</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">// 试试删除类型说明</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>: Number = int.<span class="hljs-title function_ invoke__">into</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;My number is &#123;:?&#125;&quot;</span>, num);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p>可以用 <code>type</code> 语句给已有类型取新的名字, 类型的名字需要遵循驼峰命名法 (如 <code>CamelCase</code>), 否则编译器会给出警告:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">NanoSecond</span> = <span class="hljs-type">u64</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Inch</span> = <span class="hljs-type">u64</span>;<br></code></pre></td></tr></table></figure>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>Rust 中的闭包 (closure), 也叫 lambda 表达式, 是一类能够捕获周围作用域中变量的函数, 比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">|val| val + x<br></code></pre></td></tr></table></figure>

<p>当闭包被定义时, 编译器或隐式创建一个匿名类型的结构体, 用于存储闭包捕获的变量.</p>
<p>调用一个闭包和调用一个函数完全相同, 调用闭包时, 输入和返回类型可自动推导, 输入变量名需指明.</p>
<p>闭包的其他语法特点:</p>
<ul>
<li>声明时用 <code>||</code> 代替 <code>()</code> 将参数括起来</li>
<li><code>&#123;&#125;</code> 对于单个表达式可选, 其他情况下必须加上</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 通过闭包和函数分别实现自增。</span><br>    <span class="hljs-comment">// 译注：下面这行是使用函数的实现</span><br>    <span class="hljs-keyword">fn</span>  <span class="hljs-title function_">function</span>            (i: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123; i + <span class="hljs-number">1</span> &#125;<br><br>    <span class="hljs-comment">// 闭包是匿名的，这里我们将它们绑定到引用。</span><br>    <span class="hljs-comment">// 类型标注和函数的一样，不过类型标注和使用 `&#123;&#125;` 来围住函数体都是可选的。</span><br>    <span class="hljs-comment">// 这些匿名函数（nameless function）被赋值给合适地命名的变量。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">closure_annotated</span> = |i: <span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123; i + <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">closure_inferred</span>  = |i     |          i + <span class="hljs-number">1</span>  ;<br><br>    <span class="hljs-comment">// 译注：将闭包绑定到引用的说法可能不准。</span><br>    <span class="hljs-comment">// 据[语言参考](https://doc.rust-lang.org/beta/reference/types.html#closure-types)</span><br>    <span class="hljs-comment">// 闭包表达式产生的类型就是 “闭包类型”，不属于引用类型，而且确实无法对上面两个</span><br>    <span class="hljs-comment">// `closure_xxx` 变量解引用。</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 调用函数和闭包。</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;function: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">function</span>(i));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;closure_annotated: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">closure_annotated</span>(i));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;closure_inferred: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">closure_inferred</span>(i));<br><br>    <span class="hljs-comment">// 没有参数的闭包，返回一个 `i32` 类型。</span><br>    <span class="hljs-comment">// 返回类型是自动推导的。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">one</span> = || <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;closure returning one: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">one</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h2><p>在竖线 <code>|</code> 之前使用 <code>move</code> 会强制闭包取得被捕获变量的所有权:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// `Vec` 在语义上是不可复制的。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">haystack</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">contains</span> = <span class="hljs-keyword">move</span> |needle| haystack.<span class="hljs-title function_ invoke__">contains</span>(needle);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">contains</span>(&amp;<span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">contains</span>(&amp;<span class="hljs-number">4</span>));<br><br>    <span class="hljs-comment">//println!(&quot;There&#x27;re &#123;&#125; elements in vec&quot;, haystack.len());</span><br>    <span class="hljs-comment">// ^ 取消上面一行的注释将导致编译时错误，因为借用检查不允许在变量被移动走</span><br>    <span class="hljs-comment">// 之后继续使用它。</span><br><br>    <span class="hljs-comment">// 在闭包的签名中删除 `move` 会导致闭包以不可变方式借用 `haystack`，因此之后</span><br>    <span class="hljs-comment">// `haystack` 仍然可用，取消上面的注释也不会导致错误。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="作为输入参数"><a href="#作为输入参数" class="headerlink" title="作为输入参数"></a>作为输入参数</h2><p>把闭包作为输入参数时, 需要用 <code>trait</code> 来制定其类型:</p>
<ul>
<li><code>Fn</code>, 表示捕获方式通过引用 (<code>&amp;T</code>, 不可变引用) 的闭包</li>
<li><code>FnMut</code>, 表示捕获方式为通过可变引用 (<code>&amp;mut T</code>, 可变引用) 的闭包</li>
<li><code>FnOnce</code>, 表示捕获方式为通过值 (<code>T</code>, 拿到变量的所有权) 的闭包 (通常只能调用一次, 因为环境被消耗了)<br>(受限制程度递减)</li>
</ul>
<p>对于可复制的类型且没有 <code>mut</code> 修饰, 则通过 “引用” 捕获; 对于可复制的类型且用 <code>mut</code> 修饰, 则通过可变引用捕获; 对于一个不可复制的类型, 就会捕获 “值”.</p>
<p>比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">apply</span>&lt;F&gt;(f: F)<br><span class="hljs-keyword">where</span><br>    F: <span class="hljs-title function_ invoke__">FnOnce</span>()<br>&#123;<br>    <span class="hljs-title function_ invoke__">f</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>类型说明为 <code>FnOnce</code> 时, 闭包可能会采取 <code>&amp;T</code>, <code>&amp;mut T</code> 或 <code>T</code> 中的一种捕获方式</li>
</ul>
<h1 id="crate-1"><a href="#crate-1" class="headerlink" title="crate"></a>crate</h1><p>crate (“包, 包装箱”) 是 Rust 的一个编译单元, 比如 <code>rustc some_file.rs</code>, 这里的 <code>some_file.rs</code> 会被当作 crate 文件. 如果 <code>some_file.rs</code> 内包含 <code>mod</code> 声明, 那么模块文件的内容会在编译之前插入 crate 文件的相应声明处.</p>
<p>crate 可以被编译为二进制可执行文件或库文件, 默认情况下 <code>rustc</code> 将 crate 编译为二进制可执行文件, 也可以用 <code>--crate-type</code> 选项重载.</p>
<h2 id="编译得到库文件"><a href="#编译得到库文件" class="headerlink" title="编译得到库文件"></a>编译得到库文件</h2><p>假设有一个文件 <code>rary.rs</code>, 内容为:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">public_function</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called rary&#x27;s `public_function()`&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">private_function</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called rary&#x27;s `private_function()`&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">indirect_access</span>() &#123;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;called rary&#x27;s `indirect_access()`, that\n&gt; &quot;</span>);<br><br>    <span class="hljs-title function_ invoke__">private_function</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ rustc --crate-type=lib rary.rs<br>$ <span class="hljs-built_in">ls</span> lib*<br>library.rlib<br></code></pre></td></tr></table></figure>

<h2 id="使用库文件"><a href="#使用库文件" class="headerlink" title="使用库文件"></a>使用库文件</h2><p>用 <code>rustc</code> 的 <code>--extern</code> 选项:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># library.rlib 是已编译好的库的路径，这里假设它在同一目录下：</span><br>$ rustc executable.rs --extern rary=library.rlib --edition=2018 &amp;&amp; ./executable <br></code></pre></td></tr></table></figure>

<h1 id="cargo"><a href="#cargo" class="headerlink" title="cargo"></a>cargo</h1><p><code>cargo</code> 是官方的 Rust 包管理器, 可以用于管理依赖以及测试.</p>
<p>用 <code>cargo</code> 创建项目:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cargo new foo<br>$ tree<br>foo<br>├── Cargo.toml<br>└── src<br>    └── main.rs<br></code></pre></td></tr></table></figure>
<ul>
<li><code>main.rs</code> 是项目的入口文件</li>
<li><code>Cargo.toml</code> 是项目的配置文件, 内容如下:</li>
</ul>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;foo&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">authors</span> = [<span class="hljs-string">&quot;mark&quot;</span>]<br><br><span class="hljs-section">[dependencies]</span><br></code></pre></td></tr></table></figure>
<p><code>name</code> 是项目名称, 在发布 crate 时, <code>crate.io</code> 将此字段标明为名称, 也是编译输出的二进制可执行文件的名称.</p>
<p><code>authors</code> 是发布 <code>crate</code> 时的作者列表.</p>
<p><code>dependencies</code> section 用于添加依赖, 比如:</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">clap</span> = <span class="hljs-string">&quot;2.27.1&quot;</span><br></code></pre></td></tr></table></figure>

<p>然后再文件中写上 <code>extern crate clap</code>.</p>
<p>依赖可以是不同来源:</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">clap</span> = <span class="hljs-string">&quot;2.27.1&quot;</span> <span class="hljs-comment"># 来自 crates.io</span><br><span class="hljs-attr">rand</span> = &#123; git = <span class="hljs-string">&quot;https://github.com/rust-lang-nursery/rand&quot;</span> &#125; <span class="hljs-comment"># 来自网上的仓库</span><br><span class="hljs-attr">bar</span> = &#123; path = <span class="hljs-string">&quot;../bar&quot;</span> &#125; <span class="hljs-comment"># 来自本地文件系统的路径</span><br></code></pre></td></tr></table></figure>

<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo build<br></code></pre></td></tr></table></figure>

<p>可执行文件会生成在 <code>target/debug/</code> 目录下.</p>
<p>其会在项目根目录创建 <code>Cargo.lock</code> 文件, 其会记录项目实际使用的以来以及其版本.</p>
<h2 id="构建并运行"><a href="#构建并运行" class="headerlink" title="构建并运行"></a>构建并运行</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo run<br></code></pre></td></tr></table></figure>

<h2 id="检查代码但不运行"><a href="#检查代码但不运行" class="headerlink" title="检查代码但不运行"></a>检查代码但不运行</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo check<br></code></pre></td></tr></table></figure>

<h2 id="项目发布"><a href="#项目发布" class="headerlink" title="项目发布"></a>项目发布</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo build --release<br></code></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>将测试代码放在 <code>tests/</code> 目录中:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">foo<br>├── Cargo<span class="hljs-selector-class">.toml</span><br>├── <span class="hljs-attribute">src</span><br>│   └── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.rs</span><br>└── tests<br>    ├── my_test<span class="hljs-selector-class">.rs</span><br>    └── my_other_test.rs<br></code></pre></td></tr></table></figure>

<p>之后可以用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>
<p>来运行所有测试.</p>
<p>或者运行匹配的测试:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo <span class="hljs-built_in">test</span> test_foo<br></code></pre></td></tr></table></figure>

<h1 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h1><p>RAII, Resource Acquisition Is Initialization, 资源获取即初始化, 表明任何对象在离开作用域时, 其析构函数就会被调用, 释放它占用的资源. 这样能防止资源泄漏, 如 memory leak.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// raii.rs</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">create_box</span>() &#123;<br>    <span class="hljs-comment">// 在堆上分配一个整型数据</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_box1</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3i32</span>);<br><br>    <span class="hljs-comment">// `_box1` 在这里被销毁，内存得到释放</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 在堆上分配一个整型数据</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_box2</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5i32</span>);<br><br>    <span class="hljs-comment">// 嵌套作用域：</span><br>    &#123;<br>        <span class="hljs-comment">// 在堆上分配一个整型数据</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_box3</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">4i32</span>);<br><br>        <span class="hljs-comment">// `_box3` 在这里被销毁，内存得到释放</span><br>    &#125;<br><br>    <span class="hljs-comment">// 创建一大堆 box（只是因为好玩）。</span><br>    <span class="hljs-comment">// 完全不需要手动释放内存！</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0u32</span>..<span class="hljs-number">1_000</span> &#123;<br>        <span class="hljs-title function_ invoke__">create_box</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// `_box2` 在这里被销毁，内存得到释放</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="生命周期和作用域"><a href="#生命周期和作用域" class="headerlink" title="生命周期和作用域"></a>生命周期和作用域</h1><p>生命周期 (lifetime) 和作用域 (scope) 都与值的存活时间有关, 但本质不同.</p>
<p>编译器用生命周期来确保借用是否有效, 表示引用的有效范围, 保证引用的安全性. 用 <code>&amp;</code> 借用一个变量, 该借用就拥有一个生命周期, 在出借者 (lender) 被销毁前结束.</p>
<p>作用域指变量在代码中的可见范围, 用于控制变量的可见性和内存释放时机.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 下面使用连线来标注各个变量的创建和销毁，从而显示出生命周期。</span><br><span class="hljs-comment">// `i` 的生命周期最长，因为它的作用域完全覆盖了 `borrow1` 和</span><br><span class="hljs-comment">// `borrow2` 的。`borrow1` 和 `borrow2` 的周期没有关联，</span><br><span class="hljs-comment">// 因为它们各不相交。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// Lifetime for `i` starts. ────────────────┐</span><br>    <span class="hljs-comment">//                                                     │</span><br>    &#123; <span class="hljs-comment">//                                                   │</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">borrow1</span> = &amp;i; <span class="hljs-comment">// `borrow1` lifetime starts. ──┐│</span><br>        <span class="hljs-comment">//                                                ││</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;borrow1: &#123;&#125;&quot;</span>, borrow1); <span class="hljs-comment">//              ││</span><br>    &#125; <span class="hljs-comment">// `borrow1 ends. ──────────────────────────────────┘│</span><br>    <span class="hljs-comment">//                                                     │</span><br>    <span class="hljs-comment">//                                                     │</span><br>    &#123; <span class="hljs-comment">//                                                   │</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">borrow2</span> = &amp;i; <span class="hljs-comment">// `borrow2` lifetime starts. ──┐│</span><br>        <span class="hljs-comment">//                                                ││</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;borrow2: &#123;&#125;&quot;</span>, borrow2); <span class="hljs-comment">//              ││</span><br>    &#125; <span class="hljs-comment">// `borrow2` ends. ─────────────────────────────────┘│</span><br>    <span class="hljs-comment">//                                                     │</span><br>&#125;   <span class="hljs-comment">// Lifetime ends. ─────────────────────────────────────┘</span><br><br></code></pre></td></tr></table></figure>

<h2 id="显式标注生命周期"><a href="#显式标注生命周期" class="headerlink" title="显式标注生命周期"></a>显式标注生命周期</h2><p>当 Rust 无法自动推断引用关系时, 需要手动告诉编译器 “引用的有效时间应该持续多久”, 也就是用显式生命周期标注 (explicit lifetime annotations).</p>
<p>一个 Rust 规则, 当函数返回引用 (如 <code>&amp;str</code>) 并且这个引用来自函数的参数 (也是引用), 此时必须显式标注生命周期来告诉编译器, 返回的引用与哪个输入引用寿命相同, 否则编译器不知道:</p>
<ul>
<li>引用的有效期需要与谁一致</li>
</ul>
<p>在结构体等定义中若出现引用也要显式标注生命周期.</p>
<p>语法是, 在函数签名, 结构体定义等地方. 类似泛型, 给出 <code>&#39;a</code>, <code>&#39;b</code> 这样的标记:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">foo&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;<br><span class="hljs-comment">// `foo` 带有生命周期参数 `&#x27;a` 和 `&#x27;b`</span><br></code></pre></td></tr></table></figure>

<p>比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// `print_refs` 接受两个 `i32` 的引用，它们有不同的生命周期 `&#x27;a` 和 `&#x27;b`。</span><br><span class="hljs-comment">// 这两个生命周期都必须至少要和 `print_refs` 函数一样长。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_refs</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>, y: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x is &#123;&#125; and y is &#123;&#125;&quot;</span>, x, y);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于带上生命周期标注的函数签名, 会有一些限制:</p>
<ul>
<li>任何引用都必须拥有标注好的生命周期</li>
<li>任何被返回的引用都必须和某个输入量相同的生命周期或静态类型 (static)</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 一个拥有生命周期 `&#x27;a` 的输入引用，其中 `&#x27;a` 的存活时间</span><br><span class="hljs-comment">// 至少与函数的一样长。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_one</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;`print_one`: x is &#123;&#125;&quot;</span>, x);<br>&#125;<br><br><span class="hljs-comment">// 可变引用同样也可能拥有生命周期。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_one</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>) &#123;<br>    *x += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 拥有不同生命周期的多个元素。对下面这种情形，两者即使拥有</span><br><span class="hljs-comment">// 相同的生命周期 `&#x27;a` 也没问题，但对一些更复杂的情形，可能</span><br><span class="hljs-comment">// 就需要不同的生命周期了。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_multi</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>, y: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;`print_multi`: x is &#123;&#125;, y is &#123;&#125;&quot;</span>, x, y);<br>&#125;<br><br><span class="hljs-comment">// 返回传递进来的引用也是可行的。</span><br><span class="hljs-comment">// 但必须返回正确的生命周期。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">pass_x</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>, _: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span> &#123; x &#125;<br><br><span class="hljs-comment">//fn invalid_output&lt;&#x27;a&gt;() -&gt; &amp;&#x27;a String &#123; &amp;String::from(&quot;foo&quot;) &#125;</span><br><span class="hljs-comment">// 上面代码是无效的：`&#x27;a` 存活的时间必须比函数的长。</span><br><span class="hljs-comment">// 这里的 `&amp;String::from(&quot;foo&quot;)` 将会创建一个 `String` 类型，然后对它取引用。</span><br><span class="hljs-comment">// 数据在离开作用域时删掉，返回一个指向无效数据的引用。</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">9</span>;<br><br>    <span class="hljs-title function_ invoke__">print_one</span>(&amp;x);<br>    <span class="hljs-title function_ invoke__">print_multi</span>(&amp;x, &amp;y);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> = <span class="hljs-title function_ invoke__">pass_x</span>(&amp;x, &amp;y);<br>    <span class="hljs-title function_ invoke__">print_one</span>(z);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">t</span> = <span class="hljs-number">3</span>;<br>    <span class="hljs-title function_ invoke__">add_one</span>(&amp;<span class="hljs-keyword">mut</span> t);<br>    <span class="hljs-title function_ invoke__">print_one</span>(&amp;t);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结构体, 方法, <code>trait</code>, <code>impl</code> 等的标注方法与函数一样.</p>
<p><code>&#39;static</code> 生命周期可能是最长的, 它会在整个程序运行的时期中存在. 有两种方式可以使变量又有 <code>&#39;static</code> 生命周期, 它们都把数据保存在可执行文件的只读内存区:</p>
<ul>
<li>使用 <code>static</code> 来声明常量</li>
<li>产生 <code>&amp;&#39;static str</code> 类型的 <code>string</code> 字面量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 产生一个拥有 `&#x27;static` 生命周期的常量。</span><br><span class="hljs-keyword">static</span> NUM: <span class="hljs-type">i32</span> = <span class="hljs-number">18</span>;<br><br><span class="hljs-comment">// 产生一个 `string` 字面量并打印它：</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">static_string</span> = <span class="hljs-string">&quot;I&#x27;m in read-only memory&quot;</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;static_string: &#123;&#125;&quot;</span>, static_string);<br></code></pre></td></tr></table></figure>

<h2 id="对泛型进行生命周期约束"><a href="#对泛型进行生命周期约束" class="headerlink" title="对泛型进行生命周期约束"></a>对泛型进行生命周期约束</h2><p>比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 这里接受一个指向 `T` 的引用，其中 `T` 实现了 `Debug` trait，并且在 `T` 中的</span><br><span class="hljs-comment">// 所有*引用*都必须比 `&#x27;a&#x27;` 存活时间更长。另外，`&#x27;a` 也要比函数活得更长。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_ref</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;(t: &amp;<span class="hljs-symbol">&#x27;a</span> T) <span class="hljs-keyword">where</span><br>    T: <span class="hljs-built_in">Debug</span> + <span class="hljs-symbol">&#x27;a</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;`print_ref`: t is &#123;:?&#125;&quot;</span>, t);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>一个较长的生命周期可以强制转成一个较短的生命周期:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 在这里，Rust 推导了一个尽可能短的生命周期。</span><br><span class="hljs-comment">// 然后这两个引用都被强制转成这个生命周期。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">multiply</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(first: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>, second: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    first * second<br>&#125;<br><br><span class="hljs-comment">// `&lt;&#x27;a: &#x27;b, &#x27;b&gt;` 读作生命周期 `&#x27;a` 至少和 `&#x27;b` 一样长。</span><br><span class="hljs-comment">// 在这里我们我们接受了一个 `&amp;&#x27;a i32` 类型并返回一个 `&amp;&#x27;b i32` 类型，这是</span><br><span class="hljs-comment">// 强制转换得到的结果。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">choose_first</span>&lt;<span class="hljs-symbol">&#x27;a</span>: <span class="hljs-symbol">&#x27;b</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(first: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>, _: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">i32</span> &#123;<br>    first<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// 较长的生命周期</span><br><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// 较短的生命周期</span><br><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The product is &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">multiply</span>(&amp;first, &amp;second));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; is the first&quot;</span>, <span class="hljs-title function_ invoke__">choose_first</span>(&amp;first, &amp;second));<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="返回-Trait"><a href="#返回-Trait" class="headerlink" title="返回 Trait"></a>返回 Trait</h1><p>Rust 编译器需要知道每个函数的返回类型需要多少空间, 也就是说需要是一个具体的类型.</p>
<p>如果函数返回一个 trait, 但不知道是哪个类型实现的 trait, 就不能得知内存量, 比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sheep</span> &#123;&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cow</span> &#123;&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 实例方法签名</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">noise</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现 `Sheep` 的 `Animal` trait。</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Sheep</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">noise</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> &#123;<br>        <span class="hljs-string">&quot;baaaaah!&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现 `Cow` 的 `Animal` trait。</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Cow</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">noise</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> &#123;<br>        <span class="hljs-string">&quot;moooooo!&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个方法是, 返回一个 <code>Box</code> 对象, 即一个堆内存的引用, 引用的大小是静态已知的, 因此可以返回.</p>
<p>如果函数返回指向堆的 trait 指针, 需要使用 <code>dyn</code> 关键字编写返回类型, 比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 返回一些实现 Animal 的结构体，但是在编译时我们不知道哪个结构体。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">random_animal</span>(random_number: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Animal&gt; &#123;<br>    <span class="hljs-keyword">if</span> random_number &lt; <span class="hljs-number">0.5</span> &#123;<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Sheep &#123;&#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Cow &#123;&#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Iterator-trait"><a href="#Iterator-trait" class="headerlink" title="Iterator trait"></a>Iterator trait</h1><p><code>Iterator</code> trait 用来对集合类型实现迭代器, 其只需要定义 <code>next</code> 方法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fibonacci</span> &#123;<br>    curr: <span class="hljs-type">u32</span>,<br>    next: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-comment">// 为 `Fibonacci`（斐波那契）实现 `Iterator`。</span><br><span class="hljs-comment">// `Iterator` trait 只需定义一个能返回 `next`（下一个）元素的方法。</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Fibonacci</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">u32</span>;<br>    <br>    <span class="hljs-comment">// 我们在这里使用 `.curr` 和 `.next` 来定义数列（sequence）。</span><br>    <span class="hljs-comment">// 返回类型为 `Option&lt;T&gt;`：</span><br>    <span class="hljs-comment">//     * 当 `Iterator` 结束时，返回 `None`。</span><br>    <span class="hljs-comment">//     * 其他情况，返回被 `Some` 包裹（wrap）的下一个值。</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">new_next</span> = <span class="hljs-keyword">self</span>.curr + <span class="hljs-keyword">self</span>.next;<br><br>        <span class="hljs-keyword">self</span>.curr = <span class="hljs-keyword">self</span>.next;<br>        <span class="hljs-keyword">self</span>.next = new_next;<br><br>        <span class="hljs-comment">// 既然斐波那契数列不存在终点，那么 `Iterator` 将不可能</span><br>        <span class="hljs-comment">// 返回 `None`，而总是返回 `Some`。</span><br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">self</span>.curr)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 返回一个斐波那契数列生成器</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fibonacci</span>() <span class="hljs-punctuation">-&gt;</span> Fibonacci &#123;<br>    Fibonacci &#123; curr: <span class="hljs-number">1</span>, next: <span class="hljs-number">1</span> &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// `0..3` 是一个 `Iterator`，会产生：0、1 和 2。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sequence</span> = <span class="hljs-number">0</span>..<span class="hljs-number">3</span>;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Four consecutive `next` calls on 0..3&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt; &#123;:?&#125;&quot;</span>, sequence.<span class="hljs-title function_ invoke__">next</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt; &#123;:?&#125;&quot;</span>, sequence.<span class="hljs-title function_ invoke__">next</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt; &#123;:?&#125;&quot;</span>, sequence.<span class="hljs-title function_ invoke__">next</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt; &#123;:?&#125;&quot;</span>, sequence.<span class="hljs-title function_ invoke__">next</span>());<br><br>    <span class="hljs-comment">// `for` 遍历 `Iterator` 直到返回 `None`，</span><br>    <span class="hljs-comment">// 并且每个 `Some` 值都被解包（unwrap），然后绑定给一个变量（这里是 `i`）。       </span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Iterate through 0..3 using `for`&quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">3</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt; &#123;&#125;&quot;</span>, i);<br>    &#125;<br><br>    <span class="hljs-comment">// `take(n)` 方法提取 `Iterator` 的前 `n` 项。</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The first four terms of the Fibonacci sequence are: &quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-title function_ invoke__">fibonacci</span>().<span class="hljs-title function_ invoke__">take</span>(<span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt; &#123;&#125;&quot;</span>, i);<br>    &#125;<br><br>    <span class="hljs-comment">// `skip(n)` 方法移除前 `n` 项，从而缩短了 `Iterator` 。</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The next four terms of the Fibonacci sequence are: &quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-title function_ invoke__">fibonacci</span>().<span class="hljs-title function_ invoke__">skip</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_ invoke__">take</span>(<span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt; &#123;&#125;&quot;</span>, i);<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">array</span> = [<span class="hljs-number">1u32</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>];<br><br>    <span class="hljs-comment">// `iter` 方法对数组/slice 产生一个 `Iterator`。</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Iterate the following array &#123;:?&#125;&quot;</span>, &amp;array);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> array.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt; &#123;&#125;&quot;</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="返回-impl-trait"><a href="#返回-impl-trait" class="headerlink" title="返回 impl trait"></a>返回 impl trait</h1><p>返回 <code>impl trait</code> 指返回实现了该 trait 的具体类型, 因此编译器能够确定其大小:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">speak</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dog</span>;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">speak</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Woof!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ✅ 使用 impl Trait 作为返回类型</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_animal</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Animal</span> &#123;<br>    Dog <span class="hljs-comment">// 返回的具体类型是 Dog，但它实现了 Animal</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Copy-和-Clone-trait"><a href="#Copy-和-Clone-trait" class="headerlink" title="Copy 和 Clone trait"></a>Copy 和 Clone trait</h1><p><code>Copy</code> trait 是一个标记 trait, 没有方法需要实现. 如果一个类型实现了 <code>Copy</code>, 当它被赋值, 传参, 作为函数返回值时, Rust 会自动对其进行拷贝, 而不会移动所有权. 这里的拷贝过程通常按 <code>bit</code> 复制.</p>
<p>而 <code>Clone</code> trait 定义了一个方法 <code>fn clone(&amp;self) -&gt; Self</code>, 需要显式调用以创建当前值的一个副本, 通常涉及到深拷贝. 几乎所有类型都实现了 <code>Clone</code>, 比如:</p>
<ul>
<li><code>String</code></li>
<li><code>Vec&lt;T&gt;</code></li>
<li>大多集合类型</li>
<li>基本类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1.<span class="hljs-title function_ invoke__">clone</span>(); <span class="hljs-comment">// ✅ 显式克隆，深拷贝堆上的数据</span><br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2); <span class="hljs-comment">// s1 依然有效！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="父-trait"><a href="#父-trait" class="headerlink" title="父 trait"></a>父 trait</h1><p>Rust 没有 “继承”, 但可以将一个 <code>trait</code> 定义为另一个 <code>trait</code> 的超集, 如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">name</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><br><span class="hljs-comment">// Person 是 Student 的父 trait。</span><br><span class="hljs-comment">// 实现 Student 需要你也 impl 了 Person。</span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Student</span>: Person &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">university</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Programmer</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fav_language</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><br><span class="hljs-comment">// CompSciStudent (computer science student，计算机科学的学生) 是 Programmer 和 Student 两者的子类。</span><br><span class="hljs-comment">// 实现 CompSciStudent 需要你同时 impl 了两个父 trait。</span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">CompSciStudent</span>: Programmer + Student &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">git_username</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">comp_sci_student_greeting</span>(student: &amp;<span class="hljs-keyword">dyn</span> CompSciStudent) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-built_in">format!</span>(<br>        <span class="hljs-string">&quot;My name is &#123;&#125; and I attend &#123;&#125;. My favorite language is &#123;&#125;. My Git username is &#123;&#125;&quot;</span>,<br>        student.<span class="hljs-title function_ invoke__">name</span>(),<br>        student.<span class="hljs-title function_ invoke__">university</span>(),<br>        student.<span class="hljs-title function_ invoke__">fav_language</span>(),<br>        student.<span class="hljs-title function_ invoke__">git_username</span>()<br>    )<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure>

<h1 id="消除重叠-trait"><a href="#消除重叠-trait" class="headerlink" title="消除重叠 trait"></a>消除重叠 trait</h1><p>当多个 <code>trait</code> 都定义有相同的方法时, 此时 Rust 不知道类型调用的是哪个方法, 需要用到 Fully Qualified Syntax, 如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">UsernameWidget</span> &#123;<br>    <span class="hljs-comment">// 从这个 widget 中获取选定的用户名</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">AgeWidget</span> &#123;<br>    <span class="hljs-comment">// 从这个 widget 中获取选定的年龄</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span>;<br>&#125;<br><br><span class="hljs-comment">// 同时具有 UsernameWidget 和 AgeWidget 的表单</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Form</span> &#123;<br>    username: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u8</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">UsernameWidget</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Form</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">self</span>.username.<span class="hljs-title function_ invoke__">clone</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">AgeWidget</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Form</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123;<br>        <span class="hljs-keyword">self</span>.age<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">form</span> = Form&#123;<br>        username: <span class="hljs-string">&quot;rustacean&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>(),<br>        age: <span class="hljs-number">28</span>,<br>    &#125;;<br><br>    <span class="hljs-comment">// 如果取消注释此行，则会收到一条错误消息，提示 “multiple `get` found”（找到了多个`get`）。</span><br>    <span class="hljs-comment">// 因为毕竟有多个名为 `get` 的方法。</span><br>    <span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;, form.get());</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">username</span> = &lt;Form <span class="hljs-keyword">as</span> UsernameWidget&gt;::<span class="hljs-title function_ invoke__">get</span>(&amp;form);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;rustacean&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>(), username);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = &lt;Form <span class="hljs-keyword">as</span> AgeWidget&gt;::<span class="hljs-title function_ invoke__">get</span>(&amp;form);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">28</span>, age);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p>宏不会产生函数调用, 而是展开成源码, 并和程序的其他部分一起被编译.</p>
<p>Rust 中与 C 和其他语言不同的一点在于, 其宏会展开为抽象语法树 (AST, abstract syntax tree), 而不是像字符串处理那样直接替换成源码.</p>
<h2 id="创建宏"><a href="#创建宏" class="headerlink" title="创建宏"></a>创建宏</h2><p>宏通过 <code>macro_rules!</code> 宏来创建:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 这是一个简单的宏，名为 `say_hello`。</span><br><span class="hljs-built_in">macro_rules!</span> say_hello &#123;<br>    <span class="hljs-comment">// `()` 表示此宏不接受任何参数。</span><br>    () =&gt; (<br>        <span class="hljs-comment">// 此宏将会展开成这个代码块里面的内容。</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    )<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 这个调用将会展开成 `println(&quot;Hello&quot;);`!</span><br>    say_hello!()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于宏而言, 参数括号用 <code>()</code> 或 <code>&#123;&#125;</code> 的都可以.</p>
<h2 id="指示符"><a href="#指示符" class="headerlink" title="指示符"></a>指示符</h2><p>宏的参数使用美元符号 <code>$</code> 作为前缀, 并用一个指示符 (<code>designator</code>) 来标注类型, 如:</p>
<ul>
<li><code>block</code></li>
<li><code>expr</code>, 表达式</li>
<li><code>ident</code>, 变量名或函数名</li>
<li><code>item</code></li>
<li><code>literal</code>, 字面常量</li>
<li><code>pat</code>, “pattern” 模式</li>
<li><code>stmt</code>, “statement” 语句</li>
<li><code>tt</code>, “token tree” 标记树</li>
<li><code>ty</code>, “type” 类型</li>
<li><code>vis</code>, “visible” 可见性描述符</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> create_function &#123;<br>    ($func_name:ident) =&gt; (<br>        <span class="hljs-keyword">fn</span> $<span class="hljs-title function_ invoke__">func_name</span>() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;You call &#123;:?&#125;()&quot;</span>, <span class="hljs-built_in">stringify!</span>($func_name))<br>        &#125;<br>    )<br>&#125;<br><br>create_function!(foo);<br>create_function!(bar);<br></code></pre></td></tr></table></figure>

<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>一个宏可以通过重载来接受不同的参数组合, 比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> test &#123;<br>    ($left:expr; and $right:expr) =&gt; (<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; and &#123;:?&#125; is &#123;:?&#125;&quot;</span>,<br>            <span class="hljs-title function_ invoke__">stringify</span>($left),<br>            <span class="hljs-title function_ invoke__">stringify</span>($right),<br>            $left &amp;&amp; $right)<br>    )<br><br>    ($left:expr; or $right:expr) =&gt; (<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125; or &#123;:?&#125; is &#123;:?&#125;&quot;</span>,<br>            <span class="hljs-title function_ invoke__">stringify</span>($left),<br>            <span class="hljs-title function_ invoke__">stringify</span>($right),<br>            $left || $right)<br>    )<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    test!(<span class="hljs-number">1i32</span> + <span class="hljs-number">1</span> == <span class="hljs-number">2i32</span>; and <span class="hljs-number">2i32</span> * <span class="hljs-number">2</span> == <span class="hljs-number">4i32</span>);<br>    test!(<span class="hljs-literal">true</span>; or <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>stringify!</code> 宏用于将代码片段转换为字符串字面量, 比如 <code>stringify(1 + 1 == 2)</code></li>
<li><code>; and </code> 和 <code>; or </code> 都不是 Rust 关键字或者语法, 只是模式匹配 (字符串匹配而已)</li>
<li>宏定义中的参数不需要用逗号隔开</li>
</ul>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><p>宏在参数列表中, 可以用 <code>+</code> 表示一个参数可能出现一次或多次, 用 <code>*</code> 表示参数可能出现零次或多次:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> find_min &#123;<br>    ($x:expr) =&gt; ($x);<br>    ($x:expr, $($y:expr),+) =&gt; (<br>        std::cmp::<span class="hljs-title function_ invoke__">min</span>($x, find_min!($($y),+))<br>    )<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, find_min!(<span class="hljs-number">1u32</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, find_min!(<span class="hljs-number">1u32</span> + <span class="hljs-number">2</span> , <span class="hljs-number">2u32</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, find_min!(<span class="hljs-number">5u32</span>, <span class="hljs-number">2u32</span> * <span class="hljs-number">3</span>, <span class="hljs-number">4u32</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>$(...)</code> 是 token 匹配组</li>
<li><code>,+</code>:<ul>
<li>这里的 <code>,</code> 指定分隔符, 只能有一个 token, 因此不能写为 <code>,,</code>, <code>,,,</code> 这种</li>
<li><code>+</code> 是重复限定符</li>
</ul>
</li>
</ul>
<h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><p>可以在宏内部定义微型语言:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> calculate &#123;<br>    (eval $e:expr) =&gt; &#123;&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">val</span>: <span class="hljs-type">usize</span> = $e; <span class="hljs-comment">// 强制类型为整型</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; = &#123;&#125;&quot;</span>, <span class="hljs-built_in">stringify!</span>&#123;$e&#125;, val);<br>    &#125;&#125;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    calculate! &#123;<br>        eval <span class="hljs-number">1</span> + <span class="hljs-number">2</span> <span class="hljs-comment">// 看到了吧，`eval` 可并不是 Rust 的关键字！</span><br>    &#125;<br><br>    calculate! &#123;<br>        <span class="hljs-title function_ invoke__">eval</span> (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) * (<span class="hljs-number">3</span> / <span class="hljs-number">4</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>这里的 <code>&#123;&#123; &#125;&#125;</code> 表示内部内容是一个 Rust block, </li>
<li></li>
</ul>
<h2 id="可变参数接口"><a href="#可变参数接口" class="headerlink" title="可变参数接口"></a>可变参数接口</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> calculate &#123;<br>    <span class="hljs-comment">// 单个 `eval` 的模式</span><br>    (eval $e:expr) =&gt; &#123;&#123;<br>        &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">val</span>: <span class="hljs-type">usize</span> = $e; <span class="hljs-comment">// Force types to be integers</span><br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; = &#123;&#125;&quot;</span>, <span class="hljs-built_in">stringify!</span>&#123;$e&#125;, val);<br>        &#125;<br>    &#125;&#125;;<br><br>    <span class="hljs-comment">// 递归地拆解多重的 `eval`</span><br>    (eval $e:expr, $(eval $es:expr),+) =&gt; &#123;&#123;<br>        calculate! &#123; eval $e &#125;<br>        calculate! &#123; $(eval $es),+ &#125;<br>    &#125;&#125;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    calculate! &#123; <span class="hljs-comment">// 妈妈快看，可变参数的 `calculate!`！</span><br>        eval <span class="hljs-number">1</span> + <span class="hljs-number">2</span>,<br>        eval <span class="hljs-number">3</span> + <span class="hljs-number">4</span>,<br>        <span class="hljs-title function_ invoke__">eval</span> (<span class="hljs-number">2</span> * <span class="hljs-number">3</span>) + <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Rust 有多种错误处理方式:</p>
<ul>
<li>显式的 <code>panic</code>, 用于测试, 以及处理不可恢复的错误</li>
<li><code>Option</code> 类型, 值可选或缺少值时</li>
<li><code>Result</code>, 由调用者处理错误</li>
</ul>
<h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><p><code>panic!</code> 宏会打印一个错误消息并退出:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">give_princess</span>(gift: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-keyword">if</span> gift == <span class="hljs-string">&quot;snake&quot;</span> &#123; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;AAAaaaaaa!!&quot;</span>); &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">give_princess</span>(<span class="hljs-string">&quot;teddy bear&quot;</span>);<br>    <span class="hljs-title function_ invoke__">give_princess</span>(<span class="hljs-string">&quot;snake&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Option-和-unwrap"><a href="#Option-和-unwrap" class="headerlink" title="Option 和 unwrap"></a>Option 和 unwrap</h2><p><code>std</code> 标准库中有 <code>Option&lt;T&gt;</code> 的枚举类型, 用于有 “不存在” 的可能性的情况, 其表现为下面两个之一:</p>
<ul>
<li><code>Some(T)</code>, 找到一个属于 <code>T</code> 类型的元素</li>
<li><code>None</code>, 找不到相应元素</li>
</ul>
<p>这些选项可以用 <code>match</code> 显式处理或者用 <code>unwrap</code> 隐式处理:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 平民（commoner）们见多识广，收到什么礼物都能应对。</span><br><span class="hljs-comment">// 所有礼物都显式地使用 `match` 来处理。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">give_commoner</span>(gift: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">str</span>&gt;) &#123;<br>    <span class="hljs-comment">// 指出每种情况下的做法。</span><br>    <span class="hljs-keyword">match</span> gift &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;snake&quot;</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Yuck! I&#x27;m throwing that snake in a fire.&quot;</span>),<br>        <span class="hljs-title function_ invoke__">Some</span>(inner)   =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;? How nice.&quot;</span>, inner),<br>        <span class="hljs-literal">None</span>          =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;No gift? Oh well.&quot;</span>),<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 养在深闺人未识的公主见到蛇就会 `panic`（恐慌）。</span><br><span class="hljs-comment">// 这里所有的礼物都使用 `unwrap` 隐式地处理。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">give_princess</span>(gift: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">str</span>&gt;) &#123;<br>    <span class="hljs-comment">// `unwrap` 在接收到 `None` 时将返回 `panic`。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">inside</span> = gift.<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">if</span> inside == <span class="hljs-string">&quot;snake&quot;</span> &#123; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;AAAaaaaa!!!!&quot;</span>); &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;I love &#123;&#125;s!!!!!&quot;</span>, inside);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">food</span>  = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;chicken&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">snake</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;snake&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">void</span>  = <span class="hljs-literal">None</span>;<br><br>    <span class="hljs-title function_ invoke__">give_commoner</span>(food);<br>    <span class="hljs-title function_ invoke__">give_commoner</span>(snake);<br>    <span class="hljs-title function_ invoke__">give_commoner</span>(void);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bird</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;robin&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">nothing</span> = <span class="hljs-literal">None</span>;<br><br>    <span class="hljs-title function_ invoke__">give_princess</span>(bird);<br>    <span class="hljs-title function_ invoke__">give_princess</span>(nothing);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>unwrap</code> 是 <code>Option&lt;T&gt;</code> 的一个方法, 其尝试取出 <code>T</code>, 如果 <code>Option</code> 是 <code>Some(value)</code>, 则返回 <code>value</code>; 如果 <code>Option</code> 是 <code>None</code>, 则触发 <code>panic</code></li>
</ul>
<h3 id="用-运算符提取-Option"><a href="#用-运算符提取-Option" class="headerlink" title="用 ? 运算符提取 Option"></a>用 <code>?</code> 运算符提取 Option</h3><p>可以用 <code>?</code> 运算符解开 <code>Option</code>:</p>
<ul>
<li>假设 <code>x</code> 是 <code>Option</code></li>
<li>如果 <code>x</code> 是 <code>Some</code>, 那么 <code>x?</code> 返回底层值</li>
<li>如果 <code>x</code> 是 <code>None</code>, 那么 <code>x?</code> 会宗旨函数且返回 <code>None</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">next_birthday</span>(current_age: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u8</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-comment">// 如果 `current_age` 是 `None`，这将返回 `None`。</span><br>    <span class="hljs-comment">// 如果 `current_age` 是 `Some`，内部的 `u8` 将赋值给 `next_age`。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">next_age</span>: <span class="hljs-type">u8</span> = current_age?;<br>    <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;Next year I will be &#123;&#125;&quot;</span>, next_age))<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="map-combinator"><a href="#map-combinator" class="headerlink" title="map combinator"></a>map combinator</h3><p><code>Option</code> 有一个内置方法 <code>map()</code> 来处理:</p>
<ul>
<li><code>Some -&gt; Some</code></li>
<li><code>None -&gt; None</code></li>
</ul>
<p>的映射处理, 比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">cook</span>(chopped: <span class="hljs-type">Option</span>&lt;Chopped&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Cooked&gt; &#123;<br>    chopped.<span class="hljs-title function_ invoke__">map</span>(|<span class="hljs-title function_ invoke__">Chopped</span>(food)| <span class="hljs-title function_ invoke__">Cooked</span>(food))<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>map</code> 接受一个 closure, closure 的参数是 <code>Option</code> 提取出的 <code>Some(T)</code>, 输出是另一个 <code>Some(T)</code></li>
</ul>
<h3 id="and-then-combinator"><a href="#and-then-combinator" class="headerlink" title="and_then combinator"></a><code>and_then</code> combinator</h3><p>如果一个函数返回 <code>Option</code>, 则能用 <code>and_then</code> 提取出 <code>Some(T)</code> 中的 <code>T</code> 并传递给指定函数, 比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">have_ingredients</span>(food: Food) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Food&gt; &#123;<br>    <span class="hljs-keyword">match</span> food &#123;<br>        Food::Sushi =&gt; <span class="hljs-literal">None</span>,<br>        _           =&gt; <span class="hljs-title function_ invoke__">Some</span>(food),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">have_recipe</span>(food: Food) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Food&gt; &#123;<br>    <span class="hljs-keyword">match</span> food &#123;<br>        Food::CordonBleu =&gt; <span class="hljs-literal">None</span>,<br>        _                =&gt; <span class="hljs-title function_ invoke__">Some</span>(food),<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_ invoke__">have_ingredients</span>(food).<span class="hljs-title function_ invoke__">and_then</span>(have_recipe)<br></code></pre></td></tr></table></figure>

<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p><code>Result</code> 是 <code>Option</code> 类型更丰富的版本, 描述可能的错误.</p>
<p><code>Result&lt;T, E&gt;</code> 类型拥有两个取值:</p>
<ul>
<li><code>Ok(value)</code>, 表示操作成功, 并包装操作返回的 <code>value</code> (<code>T</code> 泛型)</li>
<li><code>Err(why)</code>, 表示操作失败, 并包装 <code>why</code> (<code>E</code> 泛型)</li>
</ul>
<p>比如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">MathError</span> &#123;<br>    DivisionByZero,<br>    NegativeLogarithm,<br>    NegativeSquareRoot,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">MathResult</span> = <span class="hljs-type">Result</span>&lt;<span class="hljs-type">f64</span>, MathError&gt;;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">div</span>(x: <span class="hljs-type">f64</span>, y: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> MathResult &#123;<br>    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0.0</span> &#123;<br>        <span class="hljs-comment">// 此操作将会失败，那么（与其让程序崩溃）不如把失败的原因包装在</span><br>        <span class="hljs-comment">// `Err` 中并返回</span><br>        <span class="hljs-title function_ invoke__">Err</span>(MathError::DivisionByZero)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 此操作是有效的，返回包装在 `Ok` 中的结果</span><br>        <span class="hljs-title function_ invoke__">Ok</span>(x / y)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Result</code> 也有 <code>unwrap()</code> 方法用于解析. 也有 <code>map</code> 和 <code>and_then</code> 方法.</p>
<h1 id="标准库类型"><a href="#标准库类型" class="headerlink" title="标准库类型"></a>标准库类型</h1><p>标准库中定义了许多在原生类型基础上扩充的自定义类型, 如:</p>
<ul>
<li><code>String</code>, 可增长的字符串, 如 <code>&quot;hello world&quot;</code></li>
<li><code>vector</code>, 可增长的向量, 如 <code>[1, 2, 3]</code></li>
<li><code>Option</code>, 可能不存在, 如 <code>Option&lt;i32&gt;</code></li>
<li><code>Result</code>, 可能出错, 如 <code>Result&lt;i32, i32&gt;</code></li>
<li><code>Box</code>, 堆分配的指针, 如 <code>Box&lt;i32&gt;</code></li>
</ul>
<h2 id="Box-栈和堆"><a href="#Box-栈和堆" class="headerlink" title="Box, 栈和堆"></a>Box, 栈和堆</h2><p>在 Rust 中, 所有值默认都是栈分配的.</p>
<p>通过创建 <code>Box&lt;T&gt;</code>, 可以把值 boxed 来使它在堆上分配.</p>
<p><code>box</code>  (<code>Box&lt;T&gt;</code> 的实例) 是一个智能指针, 指向堆分配的 <code>T</code> 类型的值. 当 box 离开作用域时, 会调用析构函数释放内存.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::mem;<br><br><span class="hljs-meta">#[allow(dead_code)]</span><br><span class="hljs-meta">#[derive(Debug, Clone, Copy)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">f64</span>,<br>    y: <span class="hljs-type">f64</span>,<br>&#125;<br><br><span class="hljs-meta">#[allow(dead_code)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    p1: Point,<br>    p2: Point,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">origin</span>() <span class="hljs-punctuation">-&gt;</span> Point &#123;<br>    Point &#123; x: <span class="hljs-number">0.0</span>, y: <span class="hljs-number">0.0</span> &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">boxed_origin</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;Point&gt; &#123;<br>    <span class="hljs-comment">// 在堆上分配这个点（point），并返回一个指向它的指针</span><br>    <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Point &#123; x: <span class="hljs-number">0.0</span>, y: <span class="hljs-number">0.0</span> &#125;)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// （所有的类型标注都不是必需的）</span><br>    <span class="hljs-comment">// 栈分配的变量</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">point</span>: Point = <span class="hljs-title function_ invoke__">origin</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rectangle</span>: Rectangle = Rectangle &#123;<br>        p1: <span class="hljs-title function_ invoke__">origin</span>(),<br>        p2: Point &#123; x: <span class="hljs-number">3.0</span>, y: <span class="hljs-number">4.0</span> &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 堆分配的 rectangle（矩形）</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">boxed_rectangle</span>: <span class="hljs-type">Box</span>&lt;Rectangle&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Rectangle &#123;<br>        p1: <span class="hljs-title function_ invoke__">origin</span>(),<br>        p2: <span class="hljs-title function_ invoke__">origin</span>()<br>    &#125;);<br><br>    <span class="hljs-comment">// 函数的输出可以装箱</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">boxed_point</span>: <span class="hljs-type">Box</span>&lt;Point&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">origin</span>());<br><br>    <span class="hljs-comment">// 两层装箱</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">box_in_a_box</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-type">Box</span>&lt;Point&gt;&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">boxed_origin</span>());<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Point occupies &#123;&#125; bytes in the stack&quot;</span>,<br>             mem::<span class="hljs-title function_ invoke__">size_of_val</span>(&amp;point));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Rectangle occupies &#123;&#125; bytes in the stack&quot;</span>,<br>             mem::<span class="hljs-title function_ invoke__">size_of_val</span>(&amp;rectangle));<br><br>    <span class="hljs-comment">// box 的宽度就是指针宽度</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Boxed point occupies &#123;&#125; bytes in the stack&quot;</span>,<br>             mem::<span class="hljs-title function_ invoke__">size_of_val</span>(&amp;boxed_point));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Boxed rectangle occupies &#123;&#125; bytes in the stack&quot;</span>,<br>             mem::<span class="hljs-title function_ invoke__">size_of_val</span>(&amp;boxed_rectangle));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Boxed box occupies &#123;&#125; bytes in the stack&quot;</span>,<br>             mem::<span class="hljs-title function_ invoke__">size_of_val</span>(&amp;box_in_a_box));<br><br>    <span class="hljs-comment">// 将包含在 `boxed_point` 中的数据复制到 `unboxed_point`</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">unboxed_point</span>: Point = *boxed_point;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Unboxed point occupies &#123;&#125; bytes in the stack&quot;</span>,<br>             mem::<span class="hljs-title function_ invoke__">size_of_val</span>(&amp;unboxed_point));<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector 是大小可变的数组, 其大小在编译时是未知的, 可以随时扩大或缩小.</p>
<p>一个 vector 用 3 个东西表示:</p>
<ul>
<li>一个指向数据的指针, 分配在堆上</li>
<li>vector 的长度</li>
<li>vector 的容量, 指需要为 vector 保留的内存, 只要 <code>vector</code> 的长度小于容量则可以随意增长, 超过了砸需要重新分配更大的容量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 迭代器可以被收集到 vector 中</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">collected_iterator</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = (<span class="hljs-number">0</span>..<span class="hljs-number">10</span>).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Collected (0..10) into: &#123;:?&#125;&quot;</span>, collected_iterator);<br><br>    <span class="hljs-comment">// `vec!` 宏可用来初始化一个 vector</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">xs</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1i32</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Initial vector: &#123;:?&#125;&quot;</span>, xs);<br><br>    <span class="hljs-comment">// 在 vector 的尾部插入一个新的元素</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Push 4 into the vector&quot;</span>);<br>    xs.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Vector: &#123;:?&#125;&quot;</span>, xs);<br><br>    <span class="hljs-comment">// 报错！不可变 vector 不可增长</span><br>    collected_iterator.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 改正 ^ 将此行注释掉</span><br><br>    <span class="hljs-comment">// `len` 方法获得一个 vector 的当前大小</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Vector size: &#123;&#125;&quot;</span>, xs.<span class="hljs-title function_ invoke__">len</span>());<br><br>    <span class="hljs-comment">// 下标使用中括号表示（从 0 开始）</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Second element: &#123;&#125;&quot;</span>, xs[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// `pop` 移除 vector 的最后一个元素并将它返回</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Pop last element: &#123;:?&#125;&quot;</span>, xs.<span class="hljs-title function_ invoke__">pop</span>());<br><br>    <span class="hljs-comment">// 超出下标范围将抛出一个 panic</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Fourth element: &#123;&#125;&quot;</span>, xs[<span class="hljs-number">3</span>]);<br>    <span class="hljs-comment">// 改正 ^ 注释掉此行</span><br><br>    <span class="hljs-comment">// 迭代一个 `Vector` 很容易</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Contents of xs:&quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> xs.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt; &#123;&#125;&quot;</span>, x);<br>    &#125;<br><br>    <span class="hljs-comment">// 可以在迭代 `Vector` 的同时，使用独立变量（`i`）来记录迭代次数</span><br>    <span class="hljs-title function_ invoke__">for</span> (i, x) <span class="hljs-keyword">in</span> xs.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;In position &#123;&#125; we have value &#123;&#125;&quot;</span>, i, x);<br>    &#125;<br><br>    <span class="hljs-comment">// 多亏了 `iter_mut`，可变的 `Vector` 在迭代的同时，其中每个值都能被修改</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> xs.<span class="hljs-title function_ invoke__">iter_mut</span>() &#123;<br>        *x *= <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Updated vector: &#123;:?&#125;&quot;</span>, xs);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>Rust 中有两种字符串类型:</p>
<ul>
<li><code>String</code>, 本质是 <code>Vec&lt;u8&gt;</code>, 堆分配, 可增长</li>
<li><code>&amp;str</code>, 本质是 <code>&amp;[u8]</code>, 是一个指向 UTF-8 序列的切片</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// （所有的类型标注都不是必需的）</span><br>    <span class="hljs-comment">// 一个对只读内存中分配的字符串的引用</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pangram</span>: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;the quick brown fox jumps over the lazy dog&quot;</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Pangram: &#123;&#125;&quot;</span>, pangram);<br><br>    <span class="hljs-comment">// 逆序迭代单词，这里并没有分配新的字符串</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Words in reverse&quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">word</span> <span class="hljs-keyword">in</span> pangram.<span class="hljs-title function_ invoke__">split_whitespace</span>().<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt; &#123;&#125;&quot;</span>, word);<br>    &#125;<br><br>    <span class="hljs-comment">// 复制字符到一个 vector，排序并移除重复值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">chars</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">char</span>&gt; = pangram.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    chars.<span class="hljs-title function_ invoke__">sort</span>();<br>    chars.<span class="hljs-title function_ invoke__">dedup</span>();<br><br>    <span class="hljs-comment">// 创建一个空的且可增长的 `String`</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">c</span> <span class="hljs-keyword">in</span> chars &#123;<br>        <span class="hljs-comment">// 在字符串的尾部插入一个字符</span><br>        string.<span class="hljs-title function_ invoke__">push</span>(c);<br>        <span class="hljs-comment">// 在字符串尾部插入一个字符串</span><br>        string.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;, &quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 这个缩短的字符串是原字符串的一个切片，所以没有执行新的分配操作</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">chars_to_trim</span>: &amp;[<span class="hljs-type">char</span>] = &amp;[<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">trimmed_str</span>: &amp;<span class="hljs-type">str</span> = string.<span class="hljs-title function_ invoke__">trim_matches</span>(chars_to_trim);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Used characters: &#123;&#125;&quot;</span>, trimmed_str);<br><br>    <span class="hljs-comment">// 堆分配一个字符串</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">alice</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;I like dogs&quot;</span>);<br>    <span class="hljs-comment">// 分配新内存并存储修改过的字符串</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bob</span>: <span class="hljs-type">String</span> = alice.<span class="hljs-title function_ invoke__">replace</span>(<span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Alice says: &#123;&#125;&quot;</span>, alice);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Bob says: &#123;&#125;&quot;</span>, bob);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><code>HashMap</code> 存储键值对, 只要是实现了 <code>Eq</code>, <code>Hash</code> trait 的类型, 都能作为 <code>key</code>, 比如布尔型, 整型, 字符串 . <code>HashMap</code> 也是可增长的.</p>
<p>注意 <code>f32</code> 和 <code>f64</code> 没有实现 <code>Hash</code>, 因为浮点精度误差容易导致错误.</p>
<p>对于集合类 (collection class), 如果它们包含的类型分别实现了 <code>Eq</code> 和 <code>Hash</code>, 那么这些集合类型也就实现了 <code>Eq</code> 和 <code>Hash</code>.</p>
<p>对于自定义的类型, 通常不需要手动实现 <code>Eq</code> 和 <code>Hash</code>, 利用 <code>derive</code> 属性让编译器推断即可: <code>#[derive(PartialEq, Eq, Hash)]</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">call</span>(number: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">match</span> number &#123;<br>        <span class="hljs-string">&quot;798-1364&quot;</span> =&gt; <span class="hljs-string">&quot;We&#x27;re sorry, the call cannot be completed as dialed. </span><br><span class="hljs-string">            Please hang up and try again.&quot;</span>,<br>        <span class="hljs-string">&quot;645-7689&quot;</span> =&gt; <span class="hljs-string">&quot;Hello, this is Mr. Awesome&#x27;s Pizza. My name is Fred.</span><br><span class="hljs-string">            What can I get for you today?&quot;</span>,<br>        _ =&gt; <span class="hljs-string">&quot;Hi! Who is this again?&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">contacts</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br>    contacts.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Daniel&quot;</span>, <span class="hljs-string">&quot;798-1364&quot;</span>);<br>    contacts.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Ashley&quot;</span>, <span class="hljs-string">&quot;645-7689&quot;</span>);<br>    contacts.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Katie&quot;</span>, <span class="hljs-string">&quot;435-8291&quot;</span>);<br>    contacts.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Robert&quot;</span>, <span class="hljs-string">&quot;956-1745&quot;</span>);<br><br>    <span class="hljs-comment">// 接受一个引用并返回 Option&lt;&amp;V&gt;</span><br>    <span class="hljs-keyword">match</span> contacts.<span class="hljs-title function_ invoke__">get</span>(&amp;<span class="hljs-string">&quot;Daniel&quot;</span>) &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(&amp;number) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Calling Daniel: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">call</span>(number)),<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Don&#x27;t have Daniel&#x27;s number.&quot;</span>),<br>    &#125;<br><br>    <span class="hljs-comment">// 如果被插入的值为新内容，那么 `HashMap::insert()` 返回 `None`，</span><br>    <span class="hljs-comment">// 否则返回 `Some(value)`</span><br>    contacts.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Daniel&quot;</span>, <span class="hljs-string">&quot;164-6743&quot;</span>);<br><br>    <span class="hljs-keyword">match</span> contacts.<span class="hljs-title function_ invoke__">get</span>(&amp;<span class="hljs-string">&quot;Ashley&quot;</span>) &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(&amp;number) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Calling Ashley: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">call</span>(number)),<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Don&#x27;t have Ashley&#x27;s number.&quot;</span>),<br>    &#125;<br><br>    contacts.<span class="hljs-title function_ invoke__">remove</span>(&amp;(<span class="hljs-string">&quot;Ashley&quot;</span>)); <br><br>    <span class="hljs-comment">// `HashMap::iter()` 返回一个迭代器，该迭代器以任意顺序举出</span><br>    <span class="hljs-comment">// (&amp;&#x27;a key, &amp;&#x27;a value) 对。</span><br>    <span class="hljs-title function_ invoke__">for</span> (contact, &amp;number) <span class="hljs-keyword">in</span> contacts.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Calling &#123;&#125;: &#123;&#125;&quot;</span>, contact, <span class="hljs-title function_ invoke__">call</span>(number)); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p><code>HashSet&lt;T&gt;</code> 实际上是 <code>HashMap&lt;T, ()&gt;</code> 的封装, 此时只关注 key 而非 value.</p>
<p><code>HashSet</code> 能保证不会出现重复的元素. 这是任何 <code>set</code> 集合类型的规定.</p>
<p><code>set</code> 有 4 种基本操作, 均返回一个迭代器:</p>
<ul>
<li><code>union</code>, 并集, 获得两个集合中的所有元素 (不含重复值)</li>
<li><code>difference</code>, 差集, 获取属于第一个集合而不属于第二集合的所有元素</li>
<li><code>intersection</code>, 交集, 获取同时属于两个集合的所有元素</li>
<li><code>symmetric_difference</code>, 对称差, 获取所有只属于其中一个集合, 而不同时属于两个集合的所有元素</li>
</ul>
<p>具体例子见 “通过例子学 Rust”.</p>
<h2 id="Reference-Counting"><a href="#Reference-Counting" class="headerlink" title="Reference Counting"></a>Reference Counting</h2><p><code>Rc</code>, Reference counting, 引用计数, 用于需要多个所有权的情况.</p>
<p><code>Rc&lt;T&gt;</code> 本质上是一种智能指针, 允许在单线程环境下 (也只能用于单线程), 多个变量共享同一份数据的所有权 (默认情况下, Rust 只允许每个值有一个所有者). 其内部记录一个引用计数器 (reference count)&lt; 记录当前有多少个 Rc 指针指向同一块数据.</p>
<p>只有当所有 Rc 被丢弃, 数据才会析构.</p>
<p><code>Rc&lt;T&gt;</code> 包裹一个类型为 <code>T</code> 的数据, 存放在 heap 上, 当 clone 一个 <code>Rc&lt;T&gt;</code> 时, 其不会深拷贝数据, 只会增加引用计数.</p>
<p>当 <code>Rc&lt;T&gt;</code> 离开作用域时, 引用数减一; 计数归零时, 数据被自动释放.</p>
<p>示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 创建一个 Rc，数据是 String 类型，值为 &quot;hello&quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">shared_data</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello, Rc!&quot;</span>));<br><br>    &#123;<br>        <span class="hljs-comment">// 克隆 Rc，引用计数 +1（现在为 2）</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">rc1</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;shared_data);<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rc1: &#123;&#125;, 引用计数 = &#123;&#125;&quot;</span>, rc1, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;shared_data)); <span class="hljs-comment">// 2</span><br>    &#125; <span class="hljs-comment">// rc1 离开作用域，引用计数 -1（回到 1）</span><br><br>    <span class="hljs-comment">// shared_data 仍然有效</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;shared_data: &#123;&#125;, 引用计数 = &#123;&#125;&quot;</span>, shared_data, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;shared_data)); <span class="hljs-comment">// 1</span><br><br>&#125; <span class="hljs-comment">// shared_data 离开作用域，引用计数归零，数据释放</span><br></code></pre></td></tr></table></figure>

<h2 id="Atomic-Reference-Counted"><a href="#Atomic-Reference-Counted" class="headerlink" title="Atomic Reference Counted"></a>Atomic Reference Counted</h2><p>Arc, Atomic Reference Counted, 共享引用计数, 用于线程之间的所有权共享.</p>
<p>同样通过 <code>clone</code> 创建新的引用指针, 同时增加引用计数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Arc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 这个变量声明用来指定其值的地方。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">apple</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;the same apple&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;<br>        <span class="hljs-comment">// 这里没有数值说明，因为它是一个指向内存堆中引用的指针。</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">apple</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;apple);<br><br>        thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-comment">// 由于使用了Arc，线程可以使用分配在 `Arc` 变量指针位置的值来生成。</span><br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, apple);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>move || &#123;&#125;</code> 表示, 强制 closure 获取外部变量的所有权, 不然在这里进入下一个循环时, <code>apple</code> 的值就丢失了</li>
</ul>
<h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><p>rust 用 <code>std::thread::spawn</code> 函数创建一个线程, 其参数是一个 <code>FnOnce</code> 的 closure (通过值捕获变量, 会获取所有权):</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">static</span> NTHREADS: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 这是主（`main`）线程</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 提供一个 vector 来存放所创建的子线程（children）。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">children</span> = <span class="hljs-built_in">vec!</span>[];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..NTHREADS &#123;<br>        <span class="hljs-comment">// 启动（spin up）另一个线程</span><br>        children.<span class="hljs-title function_ invoke__">push</span>(thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;this is thread number &#123;&#125;&quot;</span>, i)<br>        &#125;));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">child</span> <span class="hljs-keyword">in</span> children &#123;<br>        <span class="hljs-comment">// 等待线程结束。返回一个结果。</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = child.<span class="hljs-title function_ invoke__">join</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>Rust 为线程之间的通信提供了异步的 <code>channel</code>, 允许两个端点之间信息的单向流动:</p>
<ul>
<li><code>Sender</code> 是发送端</li>
<li><code>Receiver</code> 是接收端</li>
</ul>
<p>例子见 “通过例子学 Rust”.</p>
<h1 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h1><p><code>Path</code> 结构体表示底层文件系统的文件路径, 分两种:</p>
<ul>
<li><code>posix::Path</code></li>
<li><code>windows::Path</code></li>
</ul>
<p>需注意 <code>Path</code> 内部通过 <code>Vec&lt;u8&gt;</code> 存储而非 <code>UTF-8</code> 字符串.</p>
<p>示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::path::Path;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 从 `&amp;&#x27;static str` 创建一个 `Path`</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = Path::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;.&quot;</span>);<br><br>    <span class="hljs-comment">// `display` 方法返回一个可显示（showable）的结构体</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">display</span> = path.<span class="hljs-title function_ invoke__">display</span>();<br><br>    <span class="hljs-comment">// `join` 使用操作系统特定的分隔符来合并路径到一个字节容器，并返回新的路径</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">new_path</span> = path.<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><br>    <span class="hljs-comment">// 将路径转换成一个字符串切片</span><br>    <span class="hljs-keyword">match</span> new_path.<span class="hljs-title function_ invoke__">to_str</span>() &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;new path is not a valid UTF-8 sequence&quot;</span>),<br>        <span class="hljs-title function_ invoke__">Some</span>(s) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;new path is &#123;&#125;&quot;</span>, s),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="File-I-x2F-O"><a href="#File-I-x2F-O" class="headerlink" title="File I&#x2F;O"></a>File I&#x2F;O</h1><p><code>File</code> 结构体表示一个被打开的文件, 包裹一个文件描述符.</p>
<p><code>File</code> 的所有方法都返回: <code>io::Result&lt;T&gt;</code> 类型, 一个 <code>Result&lt;T, io::Error&gt;</code> 的别名.</p>
<h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p><code>open</code> 以只读打开一个文件:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::prelude::*;<br><span class="hljs-keyword">use</span> std::path::Path;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 创建指向所需的文件的路径</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = Path::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">display</span> = path.<span class="hljs-title function_ invoke__">display</span>();<br><br>    <span class="hljs-comment">// 以只读方式打开路径，返回 `io::Result&lt;File&gt;`</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">file</span> = <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">open</span>(&amp;path) &#123;<br>        <span class="hljs-comment">// `io::Error` 的 `description` 方法返回一个描述错误的字符串。</span><br>        <span class="hljs-title function_ invoke__">Err</span>(why) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;couldn&#x27;t open &#123;&#125;: &#123;:?&#125;&quot;</span>, display, why),<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>    &#125;;<br><br>    <span class="hljs-comment">// 读取文件内容到一个字符串，返回 `io::Result&lt;usize&gt;`</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">match</span> file.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s) &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(why) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;couldn&#x27;t read &#123;&#125;: &#123;:?&#125;&quot;</span>, display, why),<br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125; contains:\n&#123;&#125;&quot;</span>, display, s),<br>    &#125;<br><br>    <span class="hljs-comment">// `file` 离开作用域，并且 `hello.txt` 文件将被关闭。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p><code>create</code> 以只写方式打开文件, 如果文件存在则清除内容, 否则创建新文件:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> LOREM_IPSUM: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> =<br><span class="hljs-string">&quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod</span><br><span class="hljs-string">tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,</span><br><span class="hljs-string">quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo</span><br><span class="hljs-string">consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse</span><br><span class="hljs-string">cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non</span><br><span class="hljs-string">proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span><br><span class="hljs-string">&quot;</span>;<br><br><span class="hljs-keyword">use</span> std::io::prelude::*;<br><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::path::Path;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = Path::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;out/lorem_ipsum.txt&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">display</span> = path.<span class="hljs-title function_ invoke__">display</span>();<br><br>    <span class="hljs-comment">// 以只写模式打开文件，返回 `io::Result&lt;File&gt;`</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">file</span> = <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">create</span>(&amp;path) &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(why) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;couldn&#x27;t create &#123;&#125;: &#123;:?&#125;&quot;</span>, display, why),<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>    &#125;;<br><br>    <span class="hljs-comment">// 将 `LOREM_IPSUM` 字符串写进 `file`，返回 `io::Result&lt;()&gt;`</span><br>    <span class="hljs-keyword">match</span> file.<span class="hljs-title function_ invoke__">write_all</span>(LOREM_IPSUM.<span class="hljs-title function_ invoke__">as_bytes</span>()) &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(why) =&gt; &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;couldn&#x27;t write to &#123;&#125;: &#123;:?&#125;&quot;</span>, display, why)<br>        &#125;,<br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;successfully wrote to &#123;&#125;&quot;</span>, display),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="CMD-Args"><a href="#CMD-Args" class="headerlink" title="CMD Args"></a>CMD Args</h1><p>命令行参数用 <code>std::env::args</code> 来接收, 其返回一个迭代器, 每个参数是一个字符串:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::env;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">args</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><br>    <span class="hljs-comment">// 第一个参数是调用本程序的路径</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;My path is &#123;&#125;.&quot;</span>, args[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-comment">// 其余的参数是被传递给程序的命令行参数。</span><br>    <span class="hljs-comment">// 请这样调用程序：</span><br>    <span class="hljs-comment">//   $ ./args arg1 arg2</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;I got &#123;:?&#125; arguments: &#123;:?&#125;.&quot;</span>, args.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>, &amp;args[<span class="hljs-number">1</span>..]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h1><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>测试单元都会放在名为 <code>tests</code>, 带 <code>#[cfg(test)]</code> 属性的 Mod 中, 测试函数需要加上 <code>#[test]</code> 属性.</p>
<ul>
<li><code>#[cfg(test)]</code> 表示, 只有当编译目标是 test 时, 才编译包含此属性的代码</li>
<li><code>#[test]</code> 会让 <code>cargo test</code> 等测试运行器识别并运行</li>
</ul>
<p>测试函数中如果发生 <code>panic</code>, 则测试失败, 通常使用:</p>
<ul>
<li><code>assert!(exporession)</code>, 如果表达式为 <code>false</code> 则 <code>panic</code></li>
<li><code>assert_eq!(left, right)</code>, <code>assert_ne!(left, right)</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    a + b<br>&#125;<br><br><span class="hljs-comment">// 这个加法函数写得很差，本例中我们会使它失败。</span><br><span class="hljs-meta">#[allow(dead_code)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">bad_add</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    a - b<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-comment">// 注意这个惯用法：在 tests 模块中，从外部作用域导入所有名字。</span><br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_add</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-number">3</span>);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_bad_add</span>() &#123;<br>        <span class="hljs-comment">// 这个断言会导致测试失败。注意私有的函数也可以被测试！</span><br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">bad_add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-number">3</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>之后可以用 <code>cargo test</code> 运行测试.</p>
<h3 id="panic-测试"><a href="#panic-测试" class="headerlink" title="panic 测试"></a>panic 测试</h3><p>有时需要测试一个函数是否能正确 <code>panic</code>, 此时要加上 <code>#[should_panic]</code> 属性, 可以用 <code>expected = </code> 参数来制定期望的报错信息:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">divide_non_zero_result</span>(a: <span class="hljs-type">u32</span>, b: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Divide-by-zero error&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Divide result is zero&quot;</span>);<br>    &#125;<br>    a / b<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_divide</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">divide_non_zero_result</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>), <span class="hljs-number">5</span>);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[should_panic]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_any_panic</span>() &#123;<br>        <span class="hljs-title function_ invoke__">divide_non_zero_result</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[should_panic(expected = <span class="hljs-string">&quot;Divide result is zero&quot;</span>)]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_specific_panic</span>() &#123;<br>        <span class="hljs-title function_ invoke__">divide_non_zero_result</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="忽略测试"><a href="#忽略测试" class="headerlink" title="忽略测试"></a>忽略测试</h3><p>可以加上 <code>#[ignore]</code> 以排除部分测试, 且用 <code>cargo test -- --ignored</code> 来运行.</p>
<h2 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h2><p>Rust 源码中的注释用 <code>markdown</code> 编写, 如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">divide_non_zero_result</span>(a: <span class="hljs-type">u32</span>, b: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Divide-by-zero error&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Divide result is zero&quot;</span>);<br>    &#125;<br>    a / b<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_divide</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">divide_non_zero_result</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>), <span class="hljs-number">5</span>);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[should_panic]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_any_panic</span>() &#123;<br>        <span class="hljs-title function_ invoke__">divide_non_zero_result</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[should_panic(expected = <span class="hljs-string">&quot;Divide result is zero&quot;</span>)]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_specific_panic</span>() &#123;<br>        <span class="hljs-title function_ invoke__">divide_non_zero_result</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以在 <code>cargo test</code> 中检查注释中 markdown 的语法正确性.</p>
<h1 id="Cow"><a href="#Cow" class="headerlink" title="Cow"></a>Cow</h1><p>Cow, Copy on Write, 写时复制, 核心是: 读共享, 写时才复制.</p>
<p>假如有这个场景: 有一份数据 (比如一个字符串, 一份文档), 多个地方 (变量, 线程, 结构体) 都在 “读取” 这份数据, 一开始, 这些地方都共享一份数据, 不进行复制, 节省内存和开销, 一旦有某个地方想要修改数据, 系统才真正复制一份新的数据.</p>
<p>在 Rust 中, 其定义在 <code>std::borrow::Cow&lt;&#39;a, T&gt;</code>, 是一个 enum 类型, 表示一个智能指针:</p>
<ul>
<li><code>&#39;a</code> 是一个生命周期</li>
<li><code>T</code> 泛型, 一般要求实现 <code>ToOwned</code> trait, 即可以复制</li>
</ul>
<p>该 enum 类型的简化定义如下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Cow</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;<br><span class="hljs-keyword">where</span><br>    T: <span class="hljs-built_in">ToOwned</span>,<br>&#123;<br>    <span class="hljs-title function_ invoke__">Borrowed</span>(&amp;<span class="hljs-symbol">&#x27;a</span> T),    <span class="hljs-comment">// 借用的数据，不拥有</span><br>    <span class="hljs-title function_ invoke__">Owned</span>(T::Owned),    <span class="hljs-comment">// 拥有的数据，比如 String，而不是 &amp;str</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>传入一个 <code>Cow</code> 数据, 如果该数据被修改了, 则返回 <code>Owned</code> (进行了复制), 如果没有修改, 则返回 <code>Borrowed</code> (没有进行复制).</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Cow;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">abs_all</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(input: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Cow&lt;<span class="hljs-symbol">&#x27;b</span>, [<span class="hljs-type">i32</span>]&gt;) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Cow&lt;<span class="hljs-symbol">&#x27;b</span>, [<span class="hljs-type">i32</span>]&gt; &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..input.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = input[i];<br>        <span class="hljs-keyword">if</span> v &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// Clones into a vector if not already owned.</span><br>            input.<span class="hljs-title function_ invoke__">to_mut</span>()[i] = -v;<br>        &#125;<br>    &#125;<br>    input<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reference_mutation</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>&gt; &#123;<br>        <span class="hljs-comment">// Clone occurs because `input` needs to be mutated.</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = [-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = Cow::<span class="hljs-title function_ invoke__">from</span>(&amp;slice[..]);<br>        <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">abs_all</span>(&amp;<span class="hljs-keyword">mut</span> input) &#123;<br>            Cow::<span class="hljs-title function_ invoke__">Owned</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(()),<br>            _ =&gt; <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;Expected owned value&quot;</span>),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reference_no_mutation</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>&gt; &#123;<br>        <span class="hljs-comment">// No clone occurs because `input` doesn&#x27;t need to be mutated.</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = Cow::<span class="hljs-title function_ invoke__">from</span>(&amp;slice[..]);<br>        <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">abs_all</span>(&amp;<span class="hljs-keyword">mut</span> input) &#123;<br>            <span class="hljs-comment">// TODO</span><br>            Cow::<span class="hljs-title function_ invoke__">Borrowed</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(()),<br>            _ =&gt; <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;Expected borrowed value&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">owned_no_mutation</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>&gt; &#123;<br>        <span class="hljs-comment">// We can also pass `slice` without `&amp;` so Cow owns it directly. In this</span><br>        <span class="hljs-comment">// case no mutation occurs and thus also no clone, but the result is</span><br>        <span class="hljs-comment">// still owned because it was never borrowed or mutated.</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = Cow::<span class="hljs-title function_ invoke__">from</span>(slice);<br>        <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">abs_all</span>(&amp;<span class="hljs-keyword">mut</span> input) &#123;<br>            <span class="hljs-comment">// TODO</span><br>            Cow::<span class="hljs-title function_ invoke__">Owned</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(()),<br>            _ =&gt; <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;Result should be owned&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">owned_mutation</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>&gt; &#123;<br>        <span class="hljs-comment">// Of course this is also the case if a mutation does occur. In this</span><br>        <span class="hljs-comment">// case the call to `to_mut()` returns a reference to the same data as</span><br>        <span class="hljs-comment">// before.</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = <span class="hljs-built_in">vec!</span>[-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = Cow::<span class="hljs-title function_ invoke__">from</span>(slice);<br>        <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">abs_all</span>(&amp;<span class="hljs-keyword">mut</span> input) &#123;<br>            <span class="hljs-comment">// TODO</span><br>            Cow::<span class="hljs-title function_ invoke__">Owned</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(()),<br>            _ =&gt; <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;Result should be owned&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>let mut input = Cow::from(&amp;slice)</code>, 此时 <code>input</code> 是 <code>Cow::Borrowed&lt;Vec&lt;i32&gt;&gt;</code>, 当调用 <code>to_mut</code> 时, 转换为 <code>Cow::Owned&lt;Vec&lt;i32&gt;&gt;</code></li>
<li><code>let mut input = Cow::from(slice)</code>, 此时 <code>input</code> 已经是 <code>Cow::Owned&lt;Vec&lt;i32&gt;&gt;</code>, 不管调不调用 <code>to_mut</code> 都一样</li>
</ul>
<h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p><code>std::sync::Mutex</code> 提供一个互斥锁 (mutual exclusion), 用于跨线程安全修改数据, 防止数据竞争.</p>
<p>创建一个线程间共享的计数器:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建 10 个线程, 并分别将计数器加一:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;counter);<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = count.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>        *num += <span class="hljs-number">1</span>;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>lock()</code> 返回一个 <code>MutexGuard</code>, 其实现了 <code>DerefMut</code>, 可以修改内部数据</li>
<li><code>unwrap()</code> 用于处理可能返回 <code>Err</code> 的情况</li>
<li>这里会尝试获取这个 <code>Mutex</code> 的锁, 阻塞直到拿到锁为止</li>
</ul>
<h1 id="mpsc"><a href="#mpsc" class="headerlink" title="mpsc"></a>mpsc</h1><p><code>std::sync::mpsc</code> 模块是 Rust 标准库中实现 “Multiple Producers, Single Consumer” 的线程间通信问题. 其核心是一个同步或异步的消息传输通道, 用于在线程之间安全接收和发送数据.</p>
<p>其允许:</p>
<ul>
<li>在一个线程中发送数据</li>
<li>在另一个线程中接收数据</li>
</ul>
<p>该模块提供两个核心类型:</p>
<ul>
<li><code>Sender&lt;T&gt;</code>, 用于发送数据的句柄, 可 clone (得到多个生产者)</li>
<li><code>Receiver&lt;T&gt;</code>, 用于接收数据的句柄, 只有一个</li>
</ul>
<p>示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 创建一个通道</span><br>    <span class="hljs-comment">// `tx` 是 Sender，用于发送数据</span><br>    <span class="hljs-comment">// `rx` 是 Receiver，用于接收数据</span><br>    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-comment">// 创建一个新线程，作为生产者</span><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">val</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello from the thread!&quot;</span>);<br>        tx.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">// 发送数据到通道</span><br>        <span class="hljs-comment">// 注意：val 的所有权被移动进了通道，主线程不能再使用它</span><br>    &#125;);<br><br>    <span class="hljs-comment">// 主线程作为消费者，接收数据</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">received</span> = rx.<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">// 阻塞直到收到数据</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Received: &#123;&#125;&quot;</span>, received);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>多个生产者的示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">3</span> &#123;<br>        <span class="hljs-comment">// 克隆 Sender，使得每个线程都有自己的发送端</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">tx_clone</span> = tx.<span class="hljs-title function_ invoke__">clone</span>();<br><br>        thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">msg</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;Message from thread &#123;&#125;&quot;</span>, i);<br>            tx_clone.<span class="hljs-title function_ invoke__">send</span>(msg).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 注意：必须在所有 Sender 被 drop 后才能安全地结束接收</span><br>    <span class="hljs-comment">// 为了让主线程能收到所有消息，我们在这里 drop 原始的 tx（可选，但推荐）</span><br>    <span class="hljs-title function_ invoke__">drop</span>(tx);<br><br>    <span class="hljs-comment">// 接收所有消息</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">received</span> <span class="hljs-keyword">in</span> rx &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, received);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>







                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Rust/" class="category-chain-item">Rust</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Rust-基础学习</div>
      <div>http://example.com/2025/09/15/Rust-基础学习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jie</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年9月15日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/09/16/Rust-%E6%8A%80%E5%B7%A7%E7%A7%AF%E7%B4%AF/" title="Rust-技巧积累">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Rust-技巧积累</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/09/14/2025-%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-Notes/" title="2025-秋冬季开源操作系统训练营-Notes">
                        <span class="hidden-mobile">2025-秋冬季开源操作系统训练营-Notes</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'zKurisu/comments-utterances');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Jie</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Orkarin</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
