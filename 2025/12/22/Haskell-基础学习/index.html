

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/wallhaven-j5kjgy_1920x1080.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jie">
  <meta name="keywords" content="">
  
    <meta name="description" content="Haskell bookW3Cschool Haskell 教程Haskell 趣学指南 介绍Haskell 是一门通用的纯函数式编程语言. 其诞生于 1987 年的 “Haskell 报告”, 命名源自数学家 Haskell Curry, 旨在为函数式编程提供一个标准化的研究和实践平台. 像 C, C++, Python 这些编程语言是 “命令式编程语言”, 随着命令的执行, 计算机的状态随之发">
<meta property="og:type" content="article">
<meta property="og:title" content="Haskell-基础学习">
<meta property="og:url" content="http://example.com/2025/12/22/Haskell-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Haskell bookW3Cschool Haskell 教程Haskell 趣学指南 介绍Haskell 是一门通用的纯函数式编程语言. 其诞生于 1987 年的 “Haskell 报告”, 命名源自数学家 Haskell Curry, 旨在为函数式编程提供一个标准化的研究和实践平台. 像 C, C++, Python 这些编程语言是 “命令式编程语言”, 随着命令的执行, 计算机的状态随之发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/haskell-install-lsp.png">
<meta property="article:published_time" content="2025-12-22T13:17:09.000Z">
<meta property="article:modified_time" content="2026-01-12T10:26:34.684Z">
<meta property="article:author" content="Jie">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/haskell-install-lsp.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Haskell-基础学习 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<!-- hexo injector head_end start --><style>.typst-app {
  margin: 0;
  --typst-dom-scale: 1;
  /* --typst-dom-scale: 1.5; */
  margin: 5px;
}

.typst-dom-page {
  width: calc(var(--data-page-width, 100%) * var(--typst-dom-scale));
  height: calc(var(--data-page-height) * var(--typst-dom-scale));
  --data-text-width: calc(1px * var(--typst-dom-scale));
  --data-text-height: calc(1px * var(--typst-dom-scale));
}

.typst-back-canvas {
  position: absolute;
  z-index: -1;
  width: calc(var(--data-page-width, 100%) * var(--typst-dom-scale));
  height: calc(var(--data-page-height) * var(--typst-dom-scale));
  pointer-events: none;
}

.typst-svg-page {
  position: absolute;
  z-index: 0;
  width: calc(var(--data-page-width, 100%) * var(--typst-dom-scale));
  height: calc(var(--data-page-height) * var(--typst-dom-scale));
}

.typst-html-semantics {
  position: absolute;
  z-index: 2;
  width: calc(var(--data-page-width, 100%) * var(--typst-dom-scale));
  height: calc(var(--data-page-height) * var(--typst-dom-scale));
  color: transparent;
  font-family: monospace;
  white-space: pre;
  opacity: 0.62;
}

.typst-html-semantics span {
  color: transparent;
  font-family: monospace;
  transform-origin: left top;
  position: absolute;
  display: inline-block;
  left: 0;
  top: 0;
}

.typst-content-hint {
  position: absolute;
  display: inline-block;
  width: 1px;
  height: 1px;
  overflow: hidden;
}

.typst-html-semantics a {
  position: absolute;
  display: inline-block;
}

/* set transparent itself */
.typst-content-group {
  pointer-events: visible;
}

.typst-html-semantics span::-moz-selection {
  color: transparent;
  background: #7db9de;
}

.typst-html-semantics span::selection {
  color: transparent;
  background: #7db9de;
}

.typst-html-semantics *::-moz-selection {
  color: transparent;
  background: transparent;
}

.typst-html-semantics *::selection {
  color: transparent;
  background: transparent;
}

.typst-content-fallback {
  color: transparent;
  background: transparent;
}

.pseudo-link,
.typst-text {
  pointer-events: none;
}

.tsel span,
.tsel {
  left: 0;
  position: fixed;
  text-align: justify;
  white-space: pre;
  width: 100%;
  height: 100%;
  text-align-last: justify;
  color: transparent;
}
.tsel span::-moz-selection,
.tsel::-moz-selection {
  color: transparent;
  background: #7db9dea0;
}
.tsel span::selection,
.tsel::selection {
  color: transparent;
  background: #7db9dea0;
}
.pseudo-link {
  fill: transparent;
  cursor: pointer;
  pointer-events: all;
}
svg {
  fill: none;
}

.outline_glyph path,
path.outline_glyph {
  fill: var(--glyph_fill);
  stroke: var(--glyph_stroke);
}

.outline_glyph path,
path.outline_glyph {
  transition: 0.2s fill stroke;
}
.hover .typst-text {
  --glyph_fill: #66bab7;
  --glyph_stroke: #66bab7;
}

.typst-jump-ripple,
.typst-debug-react-ripple {
  width: 0;
  height: 0;
  background-color: transparent;
  position: absolute;
  border-radius: 50%;
}
.typst-jump-ripple {
  border: 1px solid #66bab7;
}
.typst-debug-react-ripple {
  border: 1px solid #cb1b45;
}
@keyframes typst-jump-ripple-effect {
  to {
    width: 10vw;
    height: 10vw;
    opacity: 0.01;
    margin: -5vw;
  }
}
@keyframes typst-debug-react-ripple-effect {
  to {
    width: 3vw;
    height: 3vw;
    opacity: 0.01;
    margin: -1.5vw;
  }
}
</style>
<script>/// https://segmentfault.com/a/1190000016574288
(function () {
  var ie = !!(window.attachEvent && !window.opera);
  var wk = /webkit\/(\d+)/i.test(navigator.userAgent) && RegExp.$1 < 525;
  var fn = [];
  var run = function () {
    for (var i = 0; i < fn.length; i++) fn[i]();
  };
  var d = document;
  d.ready = function (f) {
    if (!ie && !wk && d.addEventListener) return d.addEventListener('DOMContentLoaded', f, false);
    if (fn.push(f) > 1) return;
    if (ie)
      (function () {
        try {
          d.documentElement.doScroll('left');
          run();
        } catch (err) {
          setTimeout(arguments.callee, 0);
        }
      })();
    else if (wk)
      var t = setInterval(function () {
        if (/^(loaded|complete)$/.test(d.readyState)) clearInterval(t), run();
      }, 0);
  };
})();
</script>
<script type="module" src="/typst/typst-main.js"></script><script src="/typst/svg-utils.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jie</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/SteinsGate_all.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Haskell-基础学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-12-22 21:17" pubdate>
          2025年12月22日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          86k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          721 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Haskell-基础学习</h1>
            
            
              <div class="markdown-body">
                
                <p><a target="_blank" rel="noopener" href="https://haskellbook.com/">Haskell book</a><br><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/hsriti/r6w1aozt.html">W3Cschool Haskell 教程</a><br><a target="_blank" rel="noopener" href="https://learnyouahaskell.mno2.org/zh-cn">Haskell 趣学指南</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Haskell 是一门通用的纯函数式编程语言. 其诞生于 1987 年的 “Haskell 报告”, 命名源自数学家 Haskell Curry, 旨在为函数式编程提供一个标准化的研究和实践平台.</p>
<p>像 C, C++, Python 这些编程语言是 “命令式编程语言”, 随着命令的执行, 计算机的状态随之发生改变.</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在 Archlinux 上, Haskell 相关工具链可以安装如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo pacman -S ghc cabal-install<br></code></pre></td></tr></table></figure>
<ul>
<li><code>ghc</code> 是 Haskell 编译器, 包含 GHCi</li>
<li><code>cabal</code> 是 Haskell 的包管理器, 用于安装第三方库和应用程序</li>
</ul>
<p>验证安装:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghc --version   <span class="hljs-comment"># 查看 GHC 版本（如 9.6.3）</span><br>cabal --version <span class="hljs-comment"># 查看 Cabal 版本（如 3.10.2.0）</span><br>ghci --version  <span class="hljs-comment"># 查看 GHCi 版本（通常与 GHC 一致）</span><br></code></pre></td></tr></table></figure>

<p>初始化 cabal:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 初始化 Cabal 用户环境（如果首次使用）</span><br>cabal update<br><br><span class="hljs-comment"># 查看 Cabal 配置</span><br>cabal user-config init<br></code></pre></td></tr></table></figure>

<h2 id="安装-LSP"><a href="#安装-LSP" class="headerlink" title="安装 LSP"></a>安装 LSP</h2><p>先安装 <code>ghcup</code> (Glasgow Haskell Compiler UPdater), 一个用于管理 Haskell 工具链的命令行工具:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo pacman -S ghcup-hs-bin<br></code></pre></td></tr></table></figure>

<p>用 <code>ghcup</code> 来安装 lsp:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghcup install hls latest<br></code></pre></td></tr></table></figure>

<p>如果你用的 nvim, 则用 <code>mason</code> 装 <code>haskell-language-server</code> 即可.</p>
<p><img src="/../img/haskell-install-lsp.png" srcset="/img/loading.gif" lazyload></p>
<p>使用时, 需要在项目根目录添加 <code>hie.yaml</code> 文件, 内容如下:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cradle:</span><br>  <span class="hljs-attr">stack:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;./&quot;</span><br><br><span class="hljs-comment"># 或者如果是 Cabal 项目</span><br><span class="hljs-attr">cradle:</span><br>  <span class="hljs-attr">cabal:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;./&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="安装-ghc"><a href="#安装-ghc" class="headerlink" title="安装 ghc"></a>安装 ghc</h2><p>可以用 <code>ghcup</code> 来安装和管理:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghcup install ghc<br></code></pre></td></tr></table></figure>

<p>注意要添加 <code>~/.ghcup/bin</code> 到 <code>PATH</code> 中.</p>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><p>Haskell 是惰性的, 意思是: 函数在真正需要结果以前不会被求值.</p>
<p>比如有一个 <code>list</code>: <code>xs = [1,2,3,4,5,6,7,8]</code>, 还有一个函数 <code>doubleMe</code>, 其可以将一个 list 中的所有元素都乘以 <code>2</code>, 并返回一个新的 List. 若是在命令式语言中, 把一个 list 乘以 8, 需要执行 <code>doubleMe(doubleMe(doubleMe(xs)))</code>, 会立即遍历三遍. 而在惰性语言中, 调用 <code>doubleMe</code> 时并不会立即求值.</p>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><p>ADT (Algebraic Data Type, 代数数据类型) 指通过组合简单类型来构造复杂类型. “Algebraic” 一词就体现在类型可以通过类似数学运算 (如 “乘积”, “求和”) 的规则组合而成. 核心思想就是用 “组合” 构造复杂类型.</p>
<p>ADT 通过两种基本操作: “积类型” 和 “和类型” 来将基础类型 (如 <code>Int</code>, <code>String</code>) 组合成更复杂的类型, 从而精确描述数据的结构.</p>
<h3 id="积类型"><a href="#积类型" class="headerlink" title="积类型"></a>积类型</h3><p>积类型 (Product Type), 表示 “同时拥有多个值”, 对应数学中的笛卡尔积 (Cartesian Product).</p>
<p>在函数式语言中, 积类型的典型实现就是 Tuple (元组) 或 Record (记录). 比如:</p>
<ul>
<li>元组 <code>(Int, String)</code> 表示一个值由 “一个整数” 和 “一个字符串” 组成</li>
<li>声明一种 record: <code>data Person = Person &#123; name :: String, age :: Int &#125;</code></li>
</ul>
<h3 id="和类型"><a href="#和类型" class="headerlink" title="和类型"></a>和类型</h3><p>和类型 (Sum Type), 表示 “多个可能值中的一个”, 对应数学中的不相交并集 (Disjoint Union).</p>
<p>在函数式语言中, 和类型的典型实现是 Enumeration (枚举) 或 Variant (变体, 带数据的枚举). 比如:</p>
<ul>
<li>简单枚举: <code>data Color = Red | Green | Blue deriving (Enum)</code>, 每个实例只能是 <code>Red</code>, <code>Green</code>, <code>Blue</code> 中的一个</li>
<li>带数据的变体: 每个实例只能是以下三种情况之一, 比如 <code>Circle r</code> 表示携带一个 <code>Float</code> 类型半径的圆:<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Shape</span> = <span class="hljs-type">Circle</span> <span class="hljs-type">Float</span></span><br>           | <span class="hljs-type">Rectangle</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span><br>           | <span class="hljs-type">Triangle</span>  <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="Hoogle"><a href="#Hoogle" class="headerlink" title="Hoogle"></a>Hoogle</h1><p>Hoogle 是一个 Haskell 专用的搜索引擎, 主要用于查找函数, 类型签名, 模块等信息.</p>
<p>可以通过 <a target="_blank" rel="noopener" href="https://hoogle.haskell.org/">https://hoogle.haskell.org</a> 在线访问.</p>
<p>也可以安装离线工具, 生成本地数据库:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装 Hoogle</span><br>cabal install hoogle<br><br><span class="hljs-comment"># 生成标准库索引</span><br>hoogle generate<br><br><span class="hljs-comment"># 启动本地服务器（默认端口 8080）</span><br>hoogle server<br></code></pre></td></tr></table></figure>

<h1 id="GHCi"><a href="#GHCi" class="headerlink" title="GHCi"></a>GHCi</h1><p>GHCi, Glasgow Haskell Compiler Interactive, 是 Haskell 官方的交互式编程环境, 用于快速测试代码片段, 调试等.</p>
<p>比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ghci<br>GHCi, version 9.6.3: https://www.haskell.org/ghc/  :? <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span><br>Prelude&gt; 1 + 2<br>3<br>Prelude&gt; map (*2) [1,2,3]<br>[2,4,6]<br>Prelude&gt; :t map  -- 查看类型<br>map :: (a -&gt; b) -&gt; [a] -&gt; [b]<br>Prelude&gt; :quit  -- 退出<br></code></pre></td></tr></table></figure>

<p>GHCi 这类交互模式通常称为 REPL, Read-Eval-Print Loop, 是交互式编程环境的核心工作模式. 几乎所有编程语言都有对应的 REPL 工具, 只是名称和用法略有不同. 比如 Haskell 使用的就是 GHCi (Glasgow Haskell Compiler Interactive).</p>
<h2 id="Help-信息"><a href="#Help-信息" class="headerlink" title="Help 信息"></a>Help 信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :?<br></code></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :h<br>ghci&gt; :<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure>



<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :quit<br>Leaving GHCi.<br></code></pre></td></tr></table></figure>

<h2 id="设置-prompt"><a href="#设置-prompt" class="headerlink" title="设置 prompt"></a>设置 prompt</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :<span class="hljs-built_in">set</span> prompt <span class="hljs-string">&quot;hello&gt;&quot;</span><br>hello&gt;<br></code></pre></td></tr></table></figure>

<h2 id="检查表达式类别"><a href="#检查表达式类别" class="headerlink" title="检查表达式类别"></a>检查表达式类别</h2><p>用 <code>:type</code> 或 <code>:t</code> 指令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-string">&#x27;a&#x27;</span> :: Char<br>ghci&gt; :t True   <br>True :: Bool   <br>ghci&gt; :t <span class="hljs-string">&quot;HELLO!&quot;</span>   <br><span class="hljs-string">&quot;HELLO!&quot;</span> :: [Char]<br></code></pre></td></tr></table></figure>

<p>注意, 查看中缀函数的类型时, 需要用 <code>()</code>  括起来, 比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t (==)   <br>(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool<br></code></pre></td></tr></table></figure>


<h1 id="All-You-Need-is-Lambda"><a href="#All-You-Need-is-Lambda" class="headerlink" title="All You Need is Lambda"></a>All You Need is Lambda</h1><p>这部分内容源自 “Haskell Programming from first principles” 这本书, 这里主要对相关概念做一些铺垫 (你可以选择跳过这一节).</p>
<p>函数式编程的本质是: programs are a combination of expressions. 函数也是一类 expression (将一组输入映射到一组输出).</p>
<p>在 Haskell 中, 函数是 first-class, 意思是: 可以把函数当作值来传递, 一个函数可以作为另一个函数的参数.</p>
<p>Haskell 是 pure functional language, 这里的 “pure” 也可以叫做 “referential transparency”, 表示: 对同一个函数而言, 相同的输入会得到相同的输出.</p>
<h2 id="Lambda-calculus"><a href="#Lambda-calculus" class="headerlink" title="Lambda calculus"></a>Lambda calculus</h2><p>Lambda calculus (“Lambda” 可以看作是一个函数名, “calculus” 表示这是一种计算方法) 是一个形式化系统 (formal system), 用于通过变量绑定和替换来表达计算.</p>
<p>“形式化系统” 是指一种使用纯粹符号进行推理和计算的数学框架. 可以理解为一个完全由规则和符号构成的游戏.</p>
<p>Lambda calculus 有三个基本的组件 (也称 Lambda terms):</p>
<ul>
<li>Expressions</li>
<li>Variables</li>
<li>Abstractions</li>
</ul>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;expression&gt;</span> ::= &lt;name&gt;                    (变量)<br>               | λ<span class="hljs-attribute">&lt;name&gt;</span>.<span class="hljs-attribute">&lt;expression&gt;</span>      (抽象/函数定义)<br>               | <span class="hljs-attribute">&lt;expression&gt;</span> <span class="hljs-attribute">&lt;expression&gt;</span> (应用/函数调用)<br></code></pre></td></tr></table></figure>

<p>Expressions 是另外两个组件的超集: expressions 既可以是变量, 也可以是抽象或这些东西的组合.</p>
<p>Abstraction 就是指函数, 其由 head 和 body 组成:</p>
<ul>
<li>Head: 包含一个 $\lambda$ 后跟一个变量名</li>
<li>Body: 另一个 expression</li>
</ul>
<p>比如:<br>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x . x<br>\end{aligned}<br>}<br>$$</p>
<ul>
<li>$\lambda x$ 是 head</li>
<li>$x$ 是 body</li>
<li><code>.</code> 将两部分分开</li>
</ul>
<h2 id="Beta-规约"><a href="#Beta-规约" class="headerlink" title="Beta 规约"></a>Beta 规约</h2><p>用输入表达式替换函数体内所有绑定变量的实例, 并消除函数头部的过程称 beta 规约.</p>
<p>比如:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x . x<br>\end{aligned}<br>}<br>$$</p>
<p>假如输入表达式是 <code>2</code>:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>(\lambda x . x) 2<br>\end{aligned}<br>}<br>$$</p>
<p>Beta 规约后就是: <code>2</code> (用 <code>2</code> 替换 body 内的 <code>x</code> 得到 $\lambda x . 2$, 再去掉 head 就得到结果 <code>2</code>).</p>
<p>消除头部告诉你函数已被应用到输入表达式.</p>
<p>假如输入表达式是函数 $\lambda y . y$, 则规约如下:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>(\lambda x . x) (\lambda y . y) \newline~ \newline<br>\lambda y . y<br>\end{aligned}<br>}<br>$$</p>
<p>这里引入一个新语法 <code>[x := z]</code>, 表示用 <code>z</code> 替换所有 body 中的 <code>x</code>, 因此上述规约过程可以写为:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>(\lambda x . x) (\lambda y . y) \newline~ \newline<br>[x :&#x3D; (\lambda y . y)] \newline~ \newline<br>\lambda y . y<br>\end{aligned}<br>}<br>$$</p>
<p>再看一个例子, 需要注意 lambda calculus 是左结合的:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>(\lambda x . x)(\lambda y . y)z \newline~ \newline<br>((\lambda x . x) (\lambda y . y)) z \newline~ \newline<br>[x :&#x3D; (\lambda y . y)] \newline~ \newline<br>(\lambda y . y) z \newline~ \newline<br>[y :&#x3D; z] \newline~ \newline<br>z<br>\end{aligned}<br>}<br>$$</p>
<p>Beta 规约会在没有更多 head 或者没有参数可以应用函数时停止.</p>
<p>需要注意, lambda calculus 每次只处理一个参数, <code>zz</code> 表示两个参数, <code>z(z)</code> 表示两个参数, <code>(zz)</code> 表示一个参数. 也要注意参数的处理是从左到右的, 比如 <code>ab</code>, 先处理 <code>a</code>, 再处理 <code>b</code>.</p>
<h2 id="Alpha-Equivalent"><a href="#Alpha-Equivalent" class="headerlink" title="Alpha Equivalent"></a>Alpha Equivalent</h2><p>Alpha Equivalent 指: 参数名字不重要, 只要结构相同就是同一个函数. </p>
<p>比如:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x . x \equiv \lambda y . y \equiv \lambda z . z<br>\end{aligned}<br>}<br>$$</p>
<h2 id="Free-Variable"><a href="#Free-Variable" class="headerlink" title="Free Variable"></a>Free Variable</h2><p>函数头部会告诉我们在应用函数时要替换哪些变量, 这些变量也称 “绑定变量”, 与输入表达式绑定在一起.</p>
<p>若函数主体中有头部中未命名的变量, 则称为 “自由变量”, 比如:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x . xy<br>\end{aligned}<br>}<br>$$</p>
<ul>
<li><code>x</code> 是绑定变量, 在 head 中有命名</li>
<li><code>y</code> 自由变量, 无法规约</li>
</ul>
<h2 id="Multiple-Arguments"><a href="#Multiple-Arguments" class="headerlink" title="Multiple Arguments"></a>Multiple Arguments</h2><p>每个 lambda 只能绑定一个参数并且只能接受一个参数. 如果需要多个参数, 需要写成多个嵌套的头部, 这样在消除一个头部时, 可以继续下一个. 这种转换过程称 currying.</p>
<p>比如, 下面 lambda calculus:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x y . x y<br>\end{aligned}<br>}<br>$$</p>
<p>本质上是下面的简化写法:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x . (\lambda y . x y)<br>\end{aligned}<br>}<br>$$</p>
<p>规约示例:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x y . x y \newline~ \newline<br>(\lambda x y . x y) 1\ 2 \newline~ \newline<br>(\lambda x (\lambda y) . x y)1\ 2 \newline~ \newline<br>[x :&#x3D; 1] \newline~ \newline<br>((\lambda y). 1 y) 2 \newline~ \newline<br>[y :&#x3D; 2] \newline~ \newline<br>1\ 2<br>\end{aligned}<br>}<br>$$</p>
<h2 id="Beta-normal-form"><a href="#Beta-normal-form" class="headerlink" title="Beta normal form"></a>Beta normal form</h2><p>如果一个 lambda 不能继续进行 beta 规约 (应用 lambda 到参数) 时, 称其得到了一个完全求值的表达式, 这种形式也称 <code>beta normal form</code>.</p>
<p>比如:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(10 + 2)</span> * <span class="hljs-number">100</span> / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这个表达式已经没有任何参数了, 不能继续用一个 lambda 进行 beta 规约, 此时它处于 <code>beta normal form</code>.</li>
</ul>
<h2 id="Combinators"><a href="#Combinators" class="headerlink" title="Combinators"></a>Combinators</h2><p>如果一个 lambda 不包含自由变量, 则称其为 “Combinator (组合子)”.</p>
<p>比如下面例子是 combinators:</p>
<ul>
<li>$\lambda x . x$</li>
<li>$\lambda xy . x$</li>
<li>$\lambda x y z . x z (y z)$</li>
</ul>
<p>所有 body 中的变量都在 head 中声明过.</p>
<p>以下例子不是 combinators:</p>
<ul>
<li>$\lambda y . x$</li>
<li>$\lambda x . x z$</li>
</ul>
<h2 id="Divergence"><a href="#Divergence" class="headerlink" title="Divergence"></a>Divergence</h2><p>Divergence 意味着规约过程永不停止, 始终有可规约的 lambda 项.</p>
<p>比如下面例子:</p>
<ul>
<li>$(\lambda x . xx) (\lambda x . xx)$</li>
<li>$([x :&#x3D; (\lambda x . xx)] xx)$</li>
<li>$(\lambda x . xx) (\lambda x . xx)$</li>
</ul>
<!-- # Hello Haskell -->
<!-- 第一个 hello world 程序, 将下面代码保存到 `test.hs` 中: -->
<!---->
<!-- ```haskell -->
<!-- sayHello :: String -> IO () -->
<!-- sayHello x = putStrLn ("Hello, " ++ x ++ "!") -->
<!-- ``` -->
<!-- - `::` 之后的 `String -> IO ()` 是一个类型 -->
<!---->
<!-- 启用 `ghci` 并加载该文件: -->
<!-- ```sh -->
<!-- $ ghci -->
<!-- GHCi, version 9.6.6: https://www.haskell.org/ghc/  :? for help -->
<!-- ghci> :load test.hs -->
<!-- [1 of 2] Compiling Main             ( test.hs, interpreted ) -->
<!-- Ok, one module loaded. -->
<!-- ghci> sayHello "Jie" -->
<!-- Hello, Jie! -->
<!-- ``` -->
<!---->
<!-- ## Expressions -->
<!-- Haskell 中的一切都是 expression 或者 declaration. -->
<!---->
<!-- Expressions 可以是 values, combinations of values, or functions applied to values. 每个 expression 都会得到一个结果. -->
<!---->
<!-- 比如下面这些都是 expressions: -->
<!-- ``` -->
<!-- 1 -->
<!-- 1 + 1 -->
<!-- "Icarus" -->
<!-- ``` -->
<!---->
<!-- 当一个 expression 不能继续求值时, 就称其到达了 "Normal form", 比如 `1 + 1` 的 normal form 是 `2`. -->
<!---->
<!-- ## Functions -->
<!-- Haskell 中的 Functions 都是 curried function, 将一个接收多个参数的函数转化为嵌套的形式, 每一层处理一个参数. -->
<!---->
<!-- 在源文件中定义函数与 GHCi 中定义会有一些区别. 比如在源文件中: -->
<!---->
<!-- ```haskell -->
<!-- triple x = x * 3 -->
<!-- ``` -->
<!-- - `triple` 是函数名, Haskell 是大小写敏感的, 函数命名通常用小写字母开头 -->
<!-- - `x` 是参数 -->
<!-- - `=` 分割函数 body 部分 -->
<!-- - `x * 3` 是函数 body -->
<!---->
<!-- 在 GHCi 中定义时, 需要加上 `let` 关键字: -->
<!---->
<!-- ```haskell -->
<!-- let triple x = x * 3 -->
<!-- ``` -->
<!---->
<!-- 调用示例: -->
<!-- ```sh -->
<!-- Prelude> triple 2 -->
<!-- 6 -->
<!-- ``` -->
<!---->
<!-- 调用等价于下面规约过程: -->
<!---->
<!-- ``` -->
<!--  triple            2 -->
<!-- (triple x = x * 3) 2 -->
<!-- (triple 2 = 2 * 3) -->
<!-- 2 * 3 -->
<!-- 6 -->
<!-- ``` -->
<!---->

<h2 id="Church-encoding"><a href="#Church-encoding" class="headerlink" title="Church encoding"></a>Church encoding</h2><p>Church encoding 并没有在书上列出, 我只是补充在这里.</p>
<p>Church encoding 是一种在纯 lambda 演算法 (pure lambda calculus) 中表示数据和操作的方法, 由逻辑学家 Alonzo Church 在 1930 年代提出.</p>
<p>核心思想是: 数据即行为. 不用内置数据 (如整数, 布尔值), 而是用函数来表示数据, 该函数描述了 “如何使用这个数据”.</p>
<p>比如用 Church encoding 表示 booleans:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-literal">true</span>  = λ<span class="hljs-keyword">a</span>. λb. <span class="hljs-keyword">a</span>    <span class="hljs-comment">-- 选择第一个参数</span><br><span class="hljs-literal">false</span> = λ<span class="hljs-keyword">a</span>. λb. b    <span class="hljs-comment">-- 选择第二个参数</span><br></code></pre></td></tr></table></figure>

<p>Church encoding 表示自然数, 将自然数 <code>n</code> 编码为: 将一个函数应用 <code>n</code> 次:</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">0</span> <span class="hljs-operator">=</span> λf. λ<span class="hljs-keyword">x</span>. <span class="hljs-keyword">x</span><br><span class="hljs-number">1</span> <span class="hljs-operator">=</span> λf. λ<span class="hljs-keyword">x</span>. f <span class="hljs-keyword">x</span><br><span class="hljs-number">2</span> <span class="hljs-operator">=</span> λf. λ<span class="hljs-keyword">x</span>. f (f <span class="hljs-keyword">x</span>)<br><span class="hljs-number">3</span> <span class="hljs-operator">=</span> λf. λ<span class="hljs-keyword">x</span>. f (f (f <span class="hljs-keyword">x</span>))<br>...<br>n <span class="hljs-operator">=</span> λf. λ<span class="hljs-keyword">x</span>. fⁿ <span class="hljs-keyword">x</span>   -- f 复合 n 次作用于 <span class="hljs-keyword">x</span><br></code></pre></td></tr></table></figure>

<p>Church pair:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">pair = λ<span class="hljs-selector-tag">a</span>. λ<span class="hljs-selector-tag">b</span>. λf. f <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span>     -- 把 <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> 交给 f 处理<br><br>fst = λ<span class="hljs-selector-tag">p</span>. <span class="hljs-selector-tag">p</span> (λ<span class="hljs-selector-tag">a</span>. λ<span class="hljs-selector-tag">b</span>. a)      -- 传入 <span class="hljs-string">&quot;取左&quot;</span> 的函数<br>snd = λ<span class="hljs-selector-tag">p</span>. <span class="hljs-selector-tag">p</span> (λ<span class="hljs-selector-tag">a</span>. λ<span class="hljs-selector-tag">b</span>. b)      -- 传入 <span class="hljs-string">&quot;取右&quot;</span> 的函数<br></code></pre></td></tr></table></figure>

<p>Church list, 如 <code>[a, b, c]</code> 被编码为其右折叠:</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">list <span class="hljs-operator">=</span> λ<span class="hljs-keyword">c</span>. λn. <span class="hljs-keyword">c</span> a (<span class="hljs-keyword">c</span> b (<span class="hljs-keyword">c</span> <span class="hljs-keyword">c</span> n))<br></code></pre></td></tr></table></figure>
<ul>
<li><code>c</code> 相当于是 <code>cons</code> 操作</li>
<li><code>n</code> 相当于是空列表 <code>nil</code></li>
</ul>
<p>这等价于: <code>foldr c n [a, b, c]</code>.</p>
<p>Church 把数据类型编码为一种操作的表示:</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>Church 编码的本质</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值</td>
<td>选择器（选左 or 选右）</td>
</tr>
<tr>
<td>自然数</td>
<td>迭代器（重复应用函数 n 次）</td>
</tr>
<tr>
<td>对（Pair）</td>
<td>消息处理器（接收一个处理函数）</td>
</tr>
<tr>
<td>列表</td>
<td>折叠器（fold）</td>
</tr>
</tbody></table>
<h1 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h1><p>如下:</p>
<ul>
<li><code>&amp;&amp;</code> 表示 “与”</li>
<li><code>||</code> 表示 “或”</li>
<li><code>not</code> 表示 “非”, 这里与其他语言不太一样, 不是 <code>!</code></li>
<li><code>==</code> 表示相等</li>
<li><code>/=</code> 表示不相等</li>
</ul>
<h1 id="简单函数"><a href="#简单函数" class="headerlink" title="简单函数"></a>简单函数</h1><p>Haskell 中 <code>*</code> (乘法运算符) 本质也是一个函数, 两个参数把它夹在中间, 这被称为”中缀函数”. 其他大多数不能被参数夹在中间的函数称 “前缀函数”.</p>
<p>在大多数命令式编程语言中的函数调用形式通常是函数名, 括号, 以及由逗号分隔的参数表, 如: <code>hello(arg1, arg2)</code>; 而在 haskell 中, 函数的调用形式是函数名, 空格, 空格分隔的参数表, 比如: <code>hello arg1 arg2</code>.</p>
<p>几个 haskell 中的简单函数示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; succ 8<br>9<br></code></pre></td></tr></table></figure>
<ul>
<li><code>succ</code>, “successor”, 返回一个数的后继, 比如这里的 <code>8</code> 后继就是 <code>9</code></li>
</ul>
<p>接受两个参数的函数, 如 <code>min</code> 和 <code>max</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; min 9 10<br>9<br>ghci&gt; max 3.4 3.2<br>3.4<br></code></pre></td></tr></table></figure>

<p>在 Haskell 中, 函数调用有高权限, 比如下面两句是等价的:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; succ 9 + max 5 4 + 1<br>16<br>ghci&gt; (succ 9) + (max 5 4) + 1<br>16<br></code></pre></td></tr></table></figure>

<p>很多时候需要用 <code>()</code> 来改变优先级, 避免出现不符合预期的结果, 比如要取 <code>9*10</code> 的后继, 不能写为 <code>succ 9*10</code> (这个的结果是先取 <code>9</code> 的后继 <code>10</code>, 再乘以 <code>10</code>), 应该写为 <code>succ (9*10)</code>.</p>
<p>如果一个函数有两个参数, 可以用 ` 将其括起来, 然后用中缀函数的形式来调用, 比如 <code>div</code> 函数是两个整数相除得到商, 可以写为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; div 92 10<br>9<br>ghci&gt; 92 `div` 10<br>9<br></code></pre></td></tr></table></figure>

<p>需要注意, 在命令式编程中, 函数调用必须要加括号, 比如 <code>foo()</code>, <code>bar(1)</code>. 而在 haskell 中, 函数调用必须加括号, 比如 <code>bar (bar 3)</code>.</p>
<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">doubleMe</span> x = x + x<br></code></pre></td></tr></table></figure>
<p>先函数名, 然后是空格分隔的参数列表, 然后用 <code>=</code> 分隔函数签名和函数体.</p>
<ul>
<li><code>doubleMe</code> 是函数名</li>
<li><code> x</code> 是空格分隔的参数列表</li>
<li><code>=</code> 是分隔符</li>
<li><code>x + x</code> 是函数体</li>
</ul>
<p>调用示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; doubleMe 10<br>20<br></code></pre></td></tr></table></figure>

<p>两个参数的函数声明示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">doubleUs</span> x y = x*<span class="hljs-number">2</span> + y*<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>或者利用先前定义的函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">doubleUs</span> x y = doubleMe x + doubleMe y<br></code></pre></td></tr></table></figure>

<p>但其实要注意, haskell 中的函数定义是没有顺序的.</p>
<h2 id="常见谓词函数"><a href="#常见谓词函数" class="headerlink" title="常见谓词函数"></a>常见谓词函数</h2><p><code>odd</code> 判断一个数是否为奇数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; odd 9<br>True<br>ghci&gt; odd 10<br>False<br></code></pre></td></tr></table></figure>

<p><code>even</code> 判断一个数是否为偶数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; even 1<br>False<br>ghci&gt; even 2<br>True<br></code></pre></td></tr></table></figure>

<h1 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h1><p>在 haskell 中, <code>if</code> 语句的 <code>else</code> 部分是不可省略的, 因为它要求每个函数和表达式都要返回一个结果, 而 <code>if</code> 语句也是一个表达式, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">doubleSmallNumber</span> x = (<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">then</span> x <span class="hljs-keyword">else</span> x*<span class="hljs-number">2</span>) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>函数名中可以包含单引号 <code>&#39;</code>, 通常用来区分一个稍经修改, 但差别不大的函数, 比如下面的定义也是合法的:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">conanO&#x27;Brien</span> = <span class="hljs-string">&quot;It&#x27;s a-me, Conan O&#x27;Brien&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>没有参数的函数通常称 “定义”</li>
<li>首字母大写通常是不允许的</li>
</ul>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>Haskell 中的 <code>List</code> 是一种单类型的数据结构, 只能存储多个相同类型的元素, 比如一组数字或一组字符串:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">lostNumbers</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">23</span>,<span class="hljs-number">48</span>]<br></code></pre></td></tr></table></figure>
<ul>
<li>List 用 <code>[]</code> 括号包裹</li>
<li>元素用 <code>,</code> 分隔</li>
</ul>
<p>字符串实际上是一组字符的 List 的语法糖, 比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; str = <span class="hljs-string">&quot;hello&quot;</span><br>ghci&gt; str<span class="hljs-string">&#x27; = [&#x27;</span>h<span class="hljs-string">&#x27;, &#x27;</span>e<span class="hljs-string">&#x27;, &#x27;</span>l<span class="hljs-string">&#x27;, &#x27;</span>l<span class="hljs-string">&#x27;, &#x27;</span>o<span class="hljs-string">&#x27;]</span><br><span class="hljs-string">ghci&gt; str</span><br><span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-string">ghci&gt; str&#x27;</span><br><span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="List-合并"><a href="#List-合并" class="headerlink" title="List 合并"></a>List 合并</h2><p>两个 List 的合并可以用 <code>++</code> 运算符, 比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [1,2,3,4] ++ [5,6,7,8]<br>[1,2,3,4,5,6,7,8]<br>ghci&gt; <span class="hljs-string">&quot;hello&quot;</span> ++ <span class="hljs-string">&quot; &quot;</span> ++ <span class="hljs-string">&quot;world&quot;</span><br><span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>

<p>可以用 <code>:</code> 运算符向 List 前端插入一个元素, 比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt;  <span class="hljs-string">&#x27;A&#x27;</span>:<span class="hljs-string">&quot; SMALL CAT&quot;</span><br><span class="hljs-string">&quot;A SMALL CAT&quot;</span><br>ghci&gt; 1:[2,3,4,5]<br>[1,2,3,4,5]<br></code></pre></td></tr></table></figure>

<p>本质上, <code>[1,2,3]</code> 是 <code>1:2:3:[]</code> 的语法糖:</p>
<ul>
<li><code>[]</code> 是空 list</li>
<li><code>3:[]</code> 得到 <code>[3]</code></li>
<li><code>2:[3]</code> 得到 <code>[2,3]</code></li>
<li><code>1:[2,3]</code> 得到 <code>[1,2,3]</code></li>
</ul>
<h2 id="索引取元素"><a href="#索引取元素" class="headerlink" title="索引取元素"></a>索引取元素</h2><p>用 <code>!!</code> 运算符来按照索引取得 <code>List</code> 中的元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-string">&quot;Jie Orkarin&quot;</span> !! 4<br><span class="hljs-string">&#x27;O&#x27;</span><br>ghci&gt; [0,1,2,3,4] !! 3<br>3<br></code></pre></td></tr></table></figure>
<ul>
<li>注意 List 越界会报错</li>
</ul>
<h2 id="List-嵌套"><a href="#List-嵌套" class="headerlink" title="List 嵌套"></a>List 嵌套</h2><p>嵌套的 List 就是多维数组, 比如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">ghci&gt; a = <span class="hljs-string">[[1,2,3]]</span><br>ghci&gt; [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]:a<br><span class="hljs-string">[[4,5,6,7,8],[1,2,3]]</span><br></code></pre></td></tr></table></figure>
<ul>
<li>注意就算是嵌套也需要是相同类别的元素</li>
</ul>
<h2 id="List-之间的比较"><a href="#List-之间的比较" class="headerlink" title="List 之间的比较"></a>List 之间的比较</h2><p>Haskell list 的比较规则是按照 “Lexicographic Order”, 就和在字典里查单词一样的逻辑:</p>
<ul>
<li>从左到右逐个元素比较</li>
<li>一旦发现一对不相等的元素, 就根据这对元素的大小来决定整个列表的大小</li>
<li>如果前面的所有元素都相等, 则较长的列表更大</li>
</ul>
<p>比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [3,2,1] &gt; [2,1,0]<br>True<br></code></pre></td></tr></table></figure>
<ul>
<li>第一个元素对就不等</li>
<li><code>3 &gt; 2</code>, 因此整体是 <code>[3,2,1] &gt; [2,1,0]</code></li>
</ul>
<p>其他例子:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [3,2,1] &gt; [2,10,100]<br>True<br>ghci&gt; [3,4,2] &gt; [3,4]<br>True<br>ghci&gt; [3,4,2] &gt; [4,2]<br>True<br></code></pre></td></tr></table></figure>

<h2 id="返回特定位置的元素"><a href="#返回特定位置的元素" class="headerlink" title="返回特定位置的元素"></a>返回特定位置的元素</h2><p>如 <code>head</code> 返回 List 的头部, 即首个元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">head</span> [5,4,3,2,1]<br>5<br></code></pre></td></tr></table></figure>

<p><code>tail</code> 返回 List 的尾部, 注意是去除头部元素之后的所有元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">tail</span> [5,4,3,2,1]<br>[4,3,2,1]<br></code></pre></td></tr></table></figure>

<p><code>last</code> 返回最后一个元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; last [5,4,3,2,1]<br>1<br></code></pre></td></tr></table></figure>

<p><code>init</code> 返回除去最后一个元素的部分:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; init [5,4,3,2,1]<br>[5,4,3,2]<br></code></pre></td></tr></table></figure>

<p>需要注意这几个函数作用在空 list 上时会报错.</p>
<h2 id="返回长度"><a href="#返回长度" class="headerlink" title="返回长度"></a>返回长度</h2><p><code>length</code> 函数返回一个 list 的长度:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; length [5,4,3,2,1]<br>5<br></code></pre></td></tr></table></figure>

<h2 id="是否为空"><a href="#是否为空" class="headerlink" title="是否为空"></a>是否为空</h2><p><code>null</code> 函数检查一个 List 是否为空:</p>
<ul>
<li>如果是空, 则返回 <code>True</code></li>
<li>如果不为空, 则返回 <code>False</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; null [1,2,3]<br>False<br>ghci&gt; null []<br>True<br></code></pre></td></tr></table></figure>

<h2 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h2><p><code>reverse</code> 函数将一个 List 反转:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; reverse [5,4,3,2,1]<br>[1,2,3,4,5]<br></code></pre></td></tr></table></figure>

<h2 id="返回前-n-个元素"><a href="#返回前-n-个元素" class="headerlink" title="返回前 n 个元素"></a>返回前 n 个元素</h2><p><code>take</code> 返回一个 List 的前几个元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; take 3 [5,4,3,2,1]<br>[5,4,3]<br>ghci&gt; take 5 [1,2]<br>[1,2]<br>ghci&gt; take 0 [5,4,3]<br>[]<br></code></pre></td></tr></table></figure>
<ul>
<li>取 <code>n</code> 大于 list 长度, 则返回整个 list</li>
<li>取 <code>n</code> 为 <code>0</code>, 则返回空 list</li>
</ul>
<h2 id="删除前-n-个元素"><a href="#删除前-n-个元素" class="headerlink" title="删除前 n 个元素"></a>删除前 n 个元素</h2><p><code>drop</code> 和 <code>take</code> 类似, 只不过是删除一个 List 中的前 <code>n</code> 个元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; drop 3 [8,4,2,1,5,6]<br>[1,5,6]<br>ghci&gt; drop 0 [1,2,3,4]<br>[1,2,3,4]<br>ghci&gt; drop 100 [1,2,3,4]<br>[]<br></code></pre></td></tr></table></figure>

<h2 id="最大最小元素"><a href="#最大最小元素" class="headerlink" title="最大最小元素"></a>最大最小元素</h2><p><code>maximum</code> 返回一个 list 中的最大元素, <code>minimum</code> 返回最小的:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; minimum [8,4,2,1,5,6]<br>1<br>ghci&gt; maximum [1,9,2,3,4]<br>9<br></code></pre></td></tr></table></figure>

<h2 id="元素之和-x2F-积"><a href="#元素之和-x2F-积" class="headerlink" title="元素之和&#x2F;积"></a>元素之和&#x2F;积</h2><p><code>sum</code> 返回一个 list 中所有元素的和:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">sum</span> [5,2,1,6,3,2,5,7]<br>31<br></code></pre></td></tr></table></figure>

<p><code>product</code> 返回一个 list 中所有元素的积:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; product [6,2,1,2]<br>24<br></code></pre></td></tr></table></figure>

<h2 id="元素是否存在"><a href="#元素是否存在" class="headerlink" title="元素是否存在"></a>元素是否存在</h2><p><code>elem</code> 函数判断一个元素是否包含于一个 List 中, 通常用中缀函数的形式调用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; 4 `elem` [1,2,3,4]<br>True<br>ghci&gt; 4 `elem` [5,6,7,8]<br>False<br></code></pre></td></tr></table></figure>

<h2 id="区间构造"><a href="#区间构造" class="headerlink" title="区间构造"></a>区间构造</h2><p>用 <code>..</code> 运算符, 比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [1..20]<br>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]<br>ghci&gt; [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;z&#x27;</span>]<br><span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br></code></pre></td></tr></table></figure>

<p>允许指定一个步长, 如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [2,4..20]<br>[2,4,6,8,10,12,14,16,18,20]<br>ghci&gt; [3,6..20]<br>[3,6,9,12,15,18]<br></code></pre></td></tr></table></figure>

<p>尽量不在这种构造中使用浮点数.</p>
<p>如果不指定上界, 则会产生一个无限长的 list, 由于 Haskell 是惰性的, 它不会对其求值, 因此是可行的.</p>
<p>如果要取 <code>24</code> 个 <code>13</code> 的倍数, 可以这样写:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; take 24 [13, 26..]<br></code></pre></td></tr></table></figure>

<p><code>cycle</code> 函数接受一个 list 作为参数, 然后循环产生一个无限 list, 因此一般需要配合 <code>take</code> 等函数来划定结束的范围:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; take 10 (cycle [1,2,3])<br>[1,2,3,1,2,3,1,2,3,1]<br></code></pre></td></tr></table></figure>

<p><code>repeat</code> 函数接受一个值作为参数, 并返回一个只包含该值的无限 List, 通常也配合 <code>take</code> 使用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; take 10 (repeat 5)<br>[5,5,5,5,5,5,5,5,5,5]<br></code></pre></td></tr></table></figure>

<h2 id="List-comprehension"><a href="#List-comprehension" class="headerlink" title="List comprehension"></a>List comprehension</h2><p>List comprehension (列表推导式) 是一种简洁的创建列表的语法. 其灵感来自数学中的 set comprehension, 比如:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>X &#x3D; \{2 \cdot x | x \in N, x \le 10\}<br>\end{aligned}<br>}<br>$$</p>
<ul>
<li>$2 \cdot x$ 是输出函数, <code>x</code> 是变量</li>
<li><code>N</code> 是输入集合, $x \le 10$ 是选择范围</li>
</ul>
<p>在 Haskell 中, 可以写为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [x*2 | x &lt;- [1..10]]<br>[2,4,6,8,10,12,14,16,18,20]<br></code></pre></td></tr></table></figure>
<ul>
<li><code>|</code> 之前的是 “输出函数”</li>
<li><code>x &lt;- [1..10]</code> 是 <code>x</code> 的取值范围</li>
</ul>
<p>可以添加限制条件, 条件与取值范围之间用 <code>,</code> 分隔:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [x*2 | x &lt;- [1..10], x*2 &gt;= 12]<br></code></pre></td></tr></table></figure>
<ul>
<li>从 list 中筛选符合限制条件的操作也称为 “filtering”</li>
</ul>
<p>也可以从多个 <code>list</code> 中构建:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]   <br>[16,20,22,40,50,55,80,100,110]  <br></code></pre></td></tr></table></figure>

<p>用这个语法创建一个 <code>length</code> 函数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">length<span class="hljs-string">&#x27; = sum [1 | _ &lt;- xs]</span><br></code></pre></td></tr></table></figure>

<h1 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h1><p>Tuple 中的元素可以是多种类型, 需要注意, tuple 的长度信息比较重要, 比如常说 “二元组 (两个元素的 tuple)”, “三元组 (三个元素的 tuple)”.</p>
<p>比如:</p>
<ul>
<li><code>[(1,2), (8,11), (4,5)]</code> 是合法的, 但 <code>[(1,2), (8,11,5), (4,5)]</code> 是非法的, 因为 “二元组” 和 “三元组” 是不同的类别, 报错可能如下:</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Couldn&#x27;t</span> match expected <span class="hljs-class"><span class="hljs-keyword">type</span> `(<span class="hljs-title">t</span>, <span class="hljs-title">t1</span>)&#x27;   </span><br><span class="hljs-title">against</span> inferred <span class="hljs-class"><span class="hljs-keyword">type</span> `(<span class="hljs-title">t2</span>, <span class="hljs-title">t3</span>, <span class="hljs-title">t4</span>)&#x27;   </span><br><span class="hljs-type">In</span> the expression: (<span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>)   <br><span class="hljs-type">In</span> the expression: [(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)]   <br><span class="hljs-type">In</span> the definition <span class="hljs-keyword">of</span> `it&#x27;: it = [(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)]<br></code></pre></td></tr></table></figure>

<p><code>(1,2)</code> 和 <code>(&quot;one&quot;, 2)</code> 也是不同的类别, 如: <code>[(1,2), (&quot;one&quot;,2)]</code> 就会报错.</p>
<h2 id="二元组操作"><a href="#二元组操作" class="headerlink" title="二元组操作"></a>二元组操作</h2><p>对于 “二元组”, 有几个常用函数:</p>
<ul>
<li><code>fst</code>, 即 “first”, 返回一个序对的首项:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; fst (8,11)<br>8<br></code></pre></td></tr></table></figure>

<ul>
<li><code>snd</code>, 即 “second”, 返回一个序对的尾项</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; snd (8,11)<br>11<br></code></pre></td></tr></table></figure>

<ul>
<li><code>zip</code> 可以用来生成一组 Pair (二元组) 的 List。 其取两个 List, 然后将它们交叉配对</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; zip [1,2,3,4,5] [5,5,5,5,5]<br>[(1,5),(2,5),(3,5),(4,5),(5,5)]<br>ghci&gt; zip [1 .. 5] [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>]   <br>[(1,<span class="hljs-string">&quot;one&quot;</span>),(2,<span class="hljs-string">&quot;two&quot;</span>),(3,<span class="hljs-string">&quot;three&quot;</span>),(4,<span class="hljs-string">&quot;four&quot;</span>),(5,<span class="hljs-string">&quot;five&quot;</span>)]<br></code></pre></td></tr></table></figure>

<p>如果参数中的两个 list 长度不同, 则会从中间断开, 匹配短的那个:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; zip [5,3,2,6,2,7,2,5,4,6,6] [<span class="hljs-string">&quot;im&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;turtle&quot;</span>]   <br>[(5,<span class="hljs-string">&quot;im&quot;</span>),(3,<span class="hljs-string">&quot;a&quot;</span>),(2,<span class="hljs-string">&quot;turtle&quot;</span>)]<br></code></pre></td></tr></table></figure>

<h2 id="Tuple-比较"><a href="#Tuple-比较" class="headerlink" title="Tuple 比较"></a>Tuple 比较</h2><p>与 list 类似, 但要注意只有相同长度的 tuple 能进行比较.</p>
<h1 id="类型和类型类"><a href="#类型和类型类" class="headerlink" title="类型和类型类"></a>类型和类型类</h1><p>Haskell 中万物都有类型, 能够在编译期间捕获类型相关错误.</p>
<p>Haskell 也支持类型推导, 避免为每个函数或表达式都显示标明其类型.</p>
<p>类型是每个表达式都有的某种标签, 它标明了这一表达式所属的范畴. 例如, 表达式 <code>True</code> 是 <code>boolean</code> 型, “hello” 是个字符串等.</p>
<p>比如在 <code>ghci</code> 中用 <code>:t</code> 检测表达式类型:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t <span class="hljs-string">&#x27;a&#x27;</span>   <br><span class="hljs-string">&#x27;a&#x27;</span> :: Char   <br>ghci&gt; :t True   <br>True :: Bool   <br>ghci&gt; :t <span class="hljs-string">&quot;HELLO!&quot;</span>   <br><span class="hljs-string">&quot;HELLO!&quot;</span> :: [Char]   <br>ghci&gt; :t (True, <span class="hljs-string">&#x27;a&#x27;</span>)   <br>(True, <span class="hljs-string">&#x27;a&#x27;</span>) :: (Bool, Char)   <br>ghci&gt; :t 4 == 5   <br>4 == 5 :: Bool<br></code></pre></td></tr></table></figure>
<ul>
<li><code>:t</code> 的输出为 “表达式” 后跟 “::” 以及类型</li>
<li><code>::</code> 读作 “它的类型为”</li>
<li>凡是明确的类型, 其首字母必定为大写</li>
<li><code>[Char]</code> 理解为一组字符 List</li>
<li>每个 Tuple 根据其内部元素的类型构成一个独立的类型, 比如 <code>(True, &#39;a&#39;)</code> 的类型是 <code>(Bool,Char)</code>; <code>(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)</code> 的类型为 <code>(Char,Char,Char)</code></li>
</ul>
<p>函数也有类别, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">removeNonUppercase</span> :: [<span class="hljs-type">Char</span>] -&gt; [<span class="hljs-type">Char</span>]   <br><span class="hljs-title">removeNonUppercase</span> st = [ c | c &lt;- st, c `elem` [&#x27;<span class="hljs-type">A&#x27;</span>..&#x27;<span class="hljs-type">Z&#x27;</span>]]<br></code></pre></td></tr></table></figure>
<ul>
<li><code>[Char] -&gt; [Char]</code> 表示从一个字符串映射到另一个字符串</li>
</ul>
<p>对于有多个参数的函数, 类型需要写为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">addThree</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>   <br><span class="hljs-title">addThree</span> x y z = x + y + z<br></code></pre></td></tr></table></figure>
<ul>
<li>各参数之间用 <code>-&gt;</code> 分隔, 最后一个是返回值的类型</li>
</ul>
<h2 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h2><ul>
<li><code>Int</code>, 整数. 有上限和下限, 对 32 位的机器通常是 <code>-214748364~214748364</code></li>
<li><code>Integer</code>, 也是整数. 但是无界, 可以表示很大的数, 但是效率不如 <code>Int</code></li>
<li><code>Float</code>, 单精度浮点数. </li>
<li><code>Double</code>, 双精度浮点数.</li>
<li><code>Bool</code>, 布尔值.</li>
<li><code>Char</code>, 表示一个字符. 一个字符由单引号括起, 一组字符的 List 为字符串</li>
<li><code>Tuple</code>, 元组. 其具体的类型由长度和元素类型决定</li>
</ul>
<h2 id="类型变量"><a href="#类型变量" class="headerlink" title="类型变量"></a>类型变量</h2><p>比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t <span class="hljs-built_in">head</span>   <br><span class="hljs-built_in">head</span> :: [a] -&gt; a<br></code></pre></td></tr></table></figure>
<ul>
<li>这里的 <code>a</code> 是小写, 不是具体的类型, 其类似其他语言中的 “泛型 (generic)”, 在 Haskell 中称为 “类型变量” 且更加强大</li>
</ul>
<p>在 Haskell 中, 使用到类型变量的函数被称为 “多态函数”, 类型变量约定俗成使用单个字符, 比如 <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> …</p>
<h2 id="类型类"><a href="#类型类" class="headerlink" title="类型类"></a>类型类</h2><p>类型类 (Typeclass), 类似于其他语言中的 Interface, 其描述了一组类型必须实现的操作, 而不关心具体实现.</p>
<p>一个函数类型声明示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t (==)   <br>(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool<br></code></pre></td></tr></table></figure>
<ul>
<li><code>=&gt;</code> 符号左边的称 “类型约束”, 这里 <code>a</code> 的类型为 <code>Eq</code></li>
</ul>
<p><code>Eq</code> 类提供了判断相等性的接口, 只要是可以比较的类型都属于 <code>Eq</code> 类:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; 5 == 5    <br>True    <br>ghci&gt; 5 /= 5    <br>False    <br>ghci&gt; <span class="hljs-string">&#x27;a&#x27;</span> == <span class="hljs-string">&#x27;a&#x27;</span>    <br>True    <br>ghci&gt; <span class="hljs-string">&quot;Ho Ho&quot;</span> == <span class="hljs-string">&quot;Ho Ho&quot;</span>    <br>True    <br>ghci&gt; 3.432 == 3.432    <br>True<br></code></pre></td></tr></table></figure>

<h3 id="几个基本的类型类"><a href="#几个基本的类型类" class="headerlink" title="几个基本的类型类"></a>几个基本的类型类</h3><ul>
<li><code>Eq</code>, 包含可判断相关性的类型. 提供了 <code>==</code> 和 <code>/=</code> 的函数实现</li>
<li><code>Ord</code>, 包含可比较大小的类型. 提供了 <code>&gt;</code>, <code>&lt;</code> 等用于比较大小的函数. <code>compare</code> 函数取两个 <code>Ord</code> 类中相同类型的值作为参数, 返回比较结果. 这个结果是如下三种类型之一: <code>GT</code>, <code>LT</code>, <code>EQ</code>. 一个类型若要成为 <code>Ord</code> 的成员, 必须先加入 <code>Eq</code> 家族<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-string">&quot;Abrakadabra&quot;</span> &lt; <span class="hljs-string">&quot;Zebra&quot;</span>   <br>True   <br>ghci&gt; <span class="hljs-string">&quot;Abrakadabra&quot;</span> `compare` <span class="hljs-string">&quot;Zebra&quot;</span>   <br>LT   <br>ghci&gt; 5 &gt;= 2   <br>True   <br>ghci&gt; 5 `compare` 3   <br>GT<br></code></pre></td></tr></table></figure></li>
<li><code>Show</code>, 包含可用字符串表示的类型. 常用 <code>show</code> 函数来操作 <code>Show</code> 类型类, 其可以取任一 <code>Show</code> 的成员类型并将其转为字符串<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; show 3   <br><span class="hljs-string">&quot;3&quot;</span>   <br>ghci&gt; show 5.334   <br><span class="hljs-string">&quot;5.334&quot;</span>   <br>ghci&gt; show True   <br><span class="hljs-string">&quot;True&quot;</span><br></code></pre></td></tr></table></figure></li>
<li><code>Read</code>, 包含可以把字符串转为对应类型值的类型. 常用 <code>read</code> 函数来转换<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;True&quot;</span> || False   <br>True   <br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;8.2&quot;</span> + 3.8   <br>12.0   <br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;5&quot;</span> - 2   <br>3   <br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;[1,2,3,4]&quot;</span> ++ [3]   <br>[1,2,3,4,3]<br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;5&quot;</span> :: Int   <br>5   <br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;5&quot;</span> :: Float   <br>5.0   <br>ghci&gt; (<span class="hljs-built_in">read</span> <span class="hljs-string">&quot;5&quot;</span> :: Float) * 4   <br>20.0   <br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;[1,2,3,4]&quot;</span> :: [Int]   <br>[1,2,3,4]   <br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;(3, &#x27;a&#x27;)&quot;</span> :: (Int, Char)   <br>(3, <span class="hljs-string">&#x27;a&#x27;</span>)<br></code></pre></td></tr></table></figure>
注意 <code>::</code> 这里的类型注解是必须的, 虽然编译器可以辨认大部分表达式的类型, 但是遇到 <code>read &quot;5&quot;</code> 这种, 它会搞不清楚其为 <code>Int</code> 还是 <code>Float</code>, 只有在运算时 haskell 才会明确其类型.</li>
<li><code>Enum</code>, 包含可枚举的类型, 有 <code>()</code>, <code>Bool</code>, <code>Char</code>, <code>Ordering</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code> 和 <code>Double</code>:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;e&#x27;</span>]   <br><span class="hljs-string">&quot;abcde&quot;</span>   <br>ghci&gt; [LT .. GT]   <br>[LT,EQ,GT]   <br>ghci&gt; [3 .. 5]   <br>[3,4,5]   <br>ghci&gt; succ <span class="hljs-string">&#x27;B&#x27;</span>   <br><span class="hljs-string">&#x27;C&#x27;</span><br></code></pre></td></tr></table></figure></li>
<li><code>Bounded</code>, 包含有上限和下限的类型:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; minBound :: Int   <br>-2147483648   <br>ghci&gt; maxBound :: Char   <br><span class="hljs-string">&#x27;\1114111&#x27;</span>   <br>ghci&gt; maxBound :: Bool   <br>True   <br>ghci&gt; minBound :: Bool   <br>False<br>ghci&gt; maxBound :: (Bool, Int, Char)   <br>(True,2147483647,<span class="hljs-string">&#x27;\1114111&#x27;</span>)<br></code></pre></td></tr></table></figure></li>
<li><code>Num</code>, 包含具有数字特征的类型:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t 20   <br>20 :: (Num t) =&gt; t<br>ghci&gt; :t (*)   <br>(*) :: (Num a) =&gt; a -&gt; a -&gt; a<br></code></pre></td></tr></table></figure></li>
<li><code>Integral</code>, 同样包含具有数字特征的类型. <code>Num</code> 包含所有的数字, 含实数和整数. 而 <code>Integral</code> 仅包含整数, 其成员类型有 <code>Int</code> 和 <code>Integer</code></li>
<li><code>Floating</code>, 仅包含浮点类型 <code>Float</code> 和 <code>Double</code></li>
</ul>
<h1 id="再探-Haskell-函数"><a href="#再探-Haskell-函数" class="headerlink" title="再探 Haskell 函数"></a>再探 Haskell 函数</h1><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>Haskell 函数的模式匹配, 可以让不同的参数对应不同的函数体, 语法示例如下:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">sayMe</span> :: (<span class="hljs-type">Integral</span> a) =&gt; a -&gt; <span class="hljs-type">String</span>   <br><span class="hljs-title">sayMe</span> <span class="hljs-number">1</span> = <span class="hljs-string">&quot;One!&quot;</span>   <br><span class="hljs-title">sayMe</span> <span class="hljs-number">2</span> = <span class="hljs-string">&quot;Two!&quot;</span>   <br><span class="hljs-title">sayMe</span> <span class="hljs-number">3</span> = <span class="hljs-string">&quot;Three!&quot;</span>   <br><span class="hljs-title">sayMe</span> <span class="hljs-number">4</span> = <span class="hljs-string">&quot;Four!&quot;</span>   <br><span class="hljs-title">sayMe</span> <span class="hljs-number">5</span> = <span class="hljs-string">&quot;Five!&quot;</span>   <br><span class="hljs-title">sayMe</span> x = <span class="hljs-string">&quot;Not between 1 and 5&quot;</span> <br></code></pre></td></tr></table></figure>
<ul>
<li>如果参数是 <code>1</code>, 则应用函数体 <code>One!</code></li>
<li>如果参数是 <code>2</code>, 则应用函数体 <code>Two!</code></li>
<li>…</li>
<li><code>x</code> 匹配剩余参数</li>
</ul>
<p>在调用 <code>sayMe</code> 时, 模式会从上到下挨个检查, 一旦有匹配, 则应用对应的函数体.</p>
<p>另一个示例, 阶乘函数, 这里也是递归函数的写法:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">factorial</span> :: (<span class="hljs-type">Integral</span> a) =&gt; a -&gt; a<br><span class="hljs-title">factorial</span> <span class="hljs-number">1</span> = <span class="hljs-number">0</span><br><span class="hljs-title">factorial</span> n = n * factorial (n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>向量相加示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">addVectors</span> :: (<span class="hljs-type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)   <br><span class="hljs-title">addVectors</span> (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)<br></code></pre></td></tr></table></figure>

<p>利用模式匹配 list 元素:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">head&#x27;</span> :: [a] -&gt; a   <br><span class="hljs-title">head&#x27;</span> [] = error <span class="hljs-string">&quot;Can&#x27;t call head on an empty list, dummy!&quot;</span>   <br><span class="hljs-title">head&#x27;</span> (x:_) = x<br></code></pre></td></tr></table></figure>
<ul>
<li>此时 <code>x</code> 匹配 List 的首个元素</li>
</ul>
<p>另一个例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">tell</span> :: (<span class="hljs-type">Show</span> a) =&gt; [a] -&gt; <span class="hljs-type">String</span>   <br><span class="hljs-title">tell</span> [] = <span class="hljs-string">&quot;The list is empty&quot;</span>   <br><span class="hljs-title">tell</span> (x:[]) = <span class="hljs-string">&quot;The list has one element: &quot;</span> ++ show x   <br><span class="hljs-title">tell</span> (x:y:[]) = <span class="hljs-string">&quot;The list has two elements: &quot;</span> ++ show x ++ <span class="hljs-string">&quot; and &quot;</span> ++ show y   <br><span class="hljs-title">tell</span> (x:y:_) = <span class="hljs-string">&quot;This list is long. The first two elements are: &quot;</span> ++ show x ++ <span class="hljs-string">&quot; and &quot;</span> ++ show y <br></code></pre></td></tr></table></figure>

<p>递归实现一个 <code>length</code> 函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">length&#x27;</span> :: (<span class="hljs-type">Num</span> b) =&gt; [a] -&gt; b   <br><span class="hljs-title">length&#x27;</span> [] = <span class="hljs-number">0</span>   <br><span class="hljs-title">length&#x27;</span> (_:xs) = <span class="hljs-number">1</span> + length&#x27; xs  <br></code></pre></td></tr></table></figure>

<p>递归实现一个 <code>sum</code> 函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">sum&#x27;</span> :: (<span class="hljs-type">Num</span> a) =&gt; [a] -&gt; a   <br><span class="hljs-title">sum&#x27;</span> [] = <span class="hljs-number">0</span>   <br><span class="hljs-title">sum&#x27;</span> (x:xs) = x + sum&#x27; xs <br></code></pre></td></tr></table></figure>

<p><code>as 模式</code> 语法, 在对 list 进行模式分割前面添加 <code>name@</code>, 可以用来引用分割前的 list, 例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">capital</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>   <br><span class="hljs-title">capital</span> <span class="hljs-string">&quot;&quot;</span> = <span class="hljs-string">&quot;Empty string, whoops!&quot;</span>   <br><span class="hljs-title">capital</span> all@(x:xs) = <span class="hljs-string">&quot;The first letter of &quot;</span> ++ all ++ <span class="hljs-string">&quot; is &quot;</span> ++ [x] <br></code></pre></td></tr></table></figure>

<p>调用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; capital <span class="hljs-string">&quot;Dracula&quot;</span><br><span class="hljs-string">&quot;The first letter of Dracula is D&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h2><p><code>Guard</code> 通过检查一个值的某项属性是否为真, 来对应一个函数体.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">bmiTell</span> :: (<span class="hljs-type">RealFloat</span> a) =&gt; a -&gt; <span class="hljs-type">String</span>  <br><span class="hljs-title">bmiTell</span> bmi  <br>    | bmi &lt;= <span class="hljs-number">18.5</span> = <span class="hljs-string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>  <br>    | bmi &lt;= <span class="hljs-number">25.0</span> = <span class="hljs-string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>  <br>    | bmi &lt;= <span class="hljs-number">30.0</span> = <span class="hljs-string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>  <br>    | otherwise   = <span class="hljs-string">&quot;You&#x27;re a whale, congratulations!&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>guard</code> 由 “函数名和参数” 之后的 “竖线加上布尔表达式” 组成, 如果为真, 则使用对应的函数体; 如果为假, 则送到下一个 <code>guard</code> 处</li>
<li>通常 <code>guard</code> 另起一行并缩进 (可以写在一行但是可读性差)</li>
<li>最后一个 <code>guard</code> 类似模式匹配中的 “匹配一切”, 布尔表达式始终为 <code>True</code> 即可</li>
</ul>
<p>实现一个简单的 <code>max</code> 函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">max&#x27;</span> :: (<span class="hljs-type">Ord</span> a) =&gt; a -&gt; a -&gt; a  <br><span class="hljs-title">max&#x27;</span> a b   <br>    | a &gt; b     = a  <br>    | otherwise = b<br></code></pre></td></tr></table></figure>

<p>一个 <code>compare</code> 函数的简单实现:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">myCompare</span> :: (<span class="hljs-type">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="hljs-type">Ordering</span>  <br><span class="hljs-title">a</span> `myCompare` b  <br>    | a &gt; b     = <span class="hljs-type">GT</span>  <br>    | a == b    = <span class="hljs-type">EQ</span>  <br>    | otherwise = <span class="hljs-type">LT</span><br></code></pre></td></tr></table></figure>

<h2 id="where-关键字"><a href="#where-关键字" class="headerlink" title="where 关键字"></a>where 关键字</h2><p><code>where</code> 绑定可以用来定义多个名字和函数. 这些名字对每个 <code>guard</code> 以及整个函数都是可见的:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">bmiTell</span> :: (<span class="hljs-type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="hljs-type">String</span>  <br><span class="hljs-title">bmiTell</span> weight height  <br>    | bmi &lt;= skinny = <span class="hljs-string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>  <br>    | bmi &lt;= normal = <span class="hljs-string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>  <br>    | bmi &lt;= fat    = <span class="hljs-string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>  <br>    | otherwise     = <span class="hljs-string">&quot;You&#x27;re a whale, congratulations!&quot;</span>  <br>    <span class="hljs-keyword">where</span> bmi = weight / height ^ <span class="hljs-number">2</span>  <br>          skinny = <span class="hljs-number">18.5</span>  <br>          normal = <span class="hljs-number">25.0</span>  <br>          fat = <span class="hljs-number">30.0</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>where</code> 通常也另起一行</li>
</ul>
<p>也可以利用模式匹配来简化写法:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell">...<br><span class="hljs-title">where</span> bmi = weight / height ^ <span class="hljs-number">2</span>  <br>      (skinny, normal, fat) = (<span class="hljs-number">18.5</span>, <span class="hljs-number">25.0</span>, <span class="hljs-number">30.0</span>)<br></code></pre></td></tr></table></figure>

<p>另一个例子模式匹配的例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">initials</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>  <br><span class="hljs-title">initials</span> firstname lastname = [f] ++ <span class="hljs-string">&quot;. &quot;</span> ++ [l] ++ <span class="hljs-string">&quot;.&quot;</span>  <br>    <span class="hljs-keyword">where</span> (f:_) = firstname  <br>          (l:_) = lastname<br></code></pre></td></tr></table></figure>

<p>在 <code>where</code> 中定义函数的例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">calcBmis</span> :: (<span class="hljs-type">RealFloat</span> a) =&gt; [(a, a)] -&gt; [a]  <br><span class="hljs-title">calcBmis</span> xs = [bmi w h | (w, h) &lt;- xs] <br>    <span class="hljs-keyword">where</span> bmi weight height = weight / height ^ <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h2 id="let-关键字"><a href="#let-关键字" class="headerlink" title="let 关键字"></a>let 关键字</h2><p><code>let</code> 绑定与 <code>where</code> 绑定类似. <code>where</code> 绑定是在函数底部定义名字, 对包括所有 <code>guard</code> 在内的整个函数可见. 而 <code>let</code> 绑定则是一个表达式, 允许在任何位置定义局部变量, 对不同的 <code>guard</code> 不可见.</p>
<p>一个根据半径和高度求圆柱体表面积的函数示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">cylinder</span> :: (<span class="hljs-type">RealFloat</span> a) =&gt; a -&gt; a -&gt; a  <br><span class="hljs-title">cylinder</span> r h = <br>    <span class="hljs-keyword">let</span> sideArea = <span class="hljs-number">2</span> * pi * r * h  <br>        topArea = pi * r ^<span class="hljs-number">2</span>  <br>    <span class="hljs-keyword">in</span>  sideArea + <span class="hljs-number">2</span> * topArea<br></code></pre></td></tr></table></figure>
<ul>
<li>语法为 <code>let [bindings] in [expressions]</code></li>
<li>在 <code>let</code> 中绑定的名字仅对 <code>in</code> 部分可见</li>
</ul>
<p>需要注意 <code>let</code> 本身是一个表达式:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; 4 * (<span class="hljs-built_in">let</span> a = 9 <span class="hljs-keyword">in</span> a + 1) + 2  <br>42<br></code></pre></td></tr></table></figure>

<p>用 <code>let</code> 定义局部函数的示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [<span class="hljs-built_in">let</span> square x = x * x <span class="hljs-keyword">in</span> (square 5, square 3, square 2)]  <br>[(25,9,4)]<br></code></pre></td></tr></table></figure>

<p>如果要在一行内定义多个名字, 则需要用 <code>;</code> 分隔:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; (<span class="hljs-built_in">let</span> a = 100; b = 200; c = 300 <span class="hljs-keyword">in</span> a*b*c, <span class="hljs-built_in">let</span> foo=<span class="hljs-string">&quot;Hey &quot;</span>; bar = <span class="hljs-string">&quot;there!&quot;</span> <span class="hljs-keyword">in</span> foo ++ bar)  <br>(6000000,<span class="hljs-string">&quot;Hey there!&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>在 <code>let</code> 中使用模式匹配:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; (<span class="hljs-built_in">let</span> (a,b,c) = (1,2,3) <span class="hljs-keyword">in</span> a+b+c) * 100  <br>600<br></code></pre></td></tr></table></figure>

<p>在 List Comprehension 中使用 <code>let</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a]  <br>calcBmis xs = [bmi | (w, h) &lt;- xs, <span class="hljs-built_in">let</span> bmi = w / h ^ 2]<br></code></pre></td></tr></table></figure>
<ul>
<li>这里忽略了 <code>in</code>, 因为名字的可见性已经预先定义好了</li>
</ul>
<p>如果在 <code>ghci</code> 中使用 <code>let</code> 也能忽略 <code>in</code>, 此时的名字是整个交互中可见</p>
<h2 id="case-表达式"><a href="#case-表达式" class="headerlink" title="case 表达式"></a>case 表达式</h2><p><code>case</code> 表达式类似命令式编程语言中的 <code>case</code> 语句, 通过变量值来选择对应的代码块. 模式匹配本质上就是 <code>case</code> 语句的语法糖.</p>
<p>下面两端代码等价:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">head&#x27;</span> :: [a] -&gt; a  <br><span class="hljs-title">head&#x27;</span> [] = error <span class="hljs-string">&quot;No head for empty lists!&quot;</span>  <br><span class="hljs-title">head&#x27;</span> (x:_) = x<br></code></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">head&#x27;</span> :: [a] -&gt; a  <br><span class="hljs-title">head&#x27;</span> xs = <span class="hljs-keyword">case</span> xs <span class="hljs-keyword">of</span> [] -&gt; error <span class="hljs-string">&quot;No head for empty lists!&quot;</span>  <br>                      (x:_) -&gt; x<br></code></pre></td></tr></table></figure>

<p>case 表达式的语法:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">case</span> expression <span class="hljs-keyword">of</span> pattern -&gt; result  <br>                   pattern -&gt; result  <br>                   pattern -&gt; result  <br>                   ...<br></code></pre></td></tr></table></figure>
<ul>
<li>若第一个模式匹配, 则执行第一个 block 的代码; 否则继续比对下一个模式; 如果到最后都没有匹配, 则产生运行时错误</li>
</ul>
<p>由于它是个表达式, 因此能写在任意地方:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">case</span> expression <span class="hljs-keyword">of</span> pattern -&gt; result  <br>                   pattern -&gt; result  <br>                   pattern -&gt; result  <br>                   ...<br></code></pre></td></tr></table></figure>

<h1 id="Haskell-递归"><a href="#Haskell-递归" class="headerlink" title="Haskell 递归"></a>Haskell 递归</h1><p>递归就是指函数在定义或实现中调用自身的方式. 在数学定义中非常常见, 比如斐波那契数列, 其先定义了两个非递归的数 <code>F(0) = 0, F(1) = 1</code>, 表示数列前两个数为 <code>0</code> 和 <code>1</code>, 接着定义: <code>F(N) = F(N-1) + F(N-2)</code>, 表示斐波那契数是数列前两个数字之和.</p>
<p>在递归定义中声明的非递归值也可以称作 “边界条件”, 便于停止递归.</p>
<p>示例, 求一个列表内元素的最大值:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">maximum&#x27;</span> :: (<span class="hljs-type">Ord</span> a) =&gt; [a] -&gt; a<br><span class="hljs-title">maximum&#x27;</span> []  = error <span class="hljs-string">&quot;maximum of empty list&quot;</span><br><span class="hljs-title">maximum&#x27;</span> [x] = x<br><span class="hljs-title">maximum&#x27;</span> (x:xs) = max x (maximum&#x27; xs)<br></code></pre></td></tr></table></figure>

<p>实现 <code>replicate</code> 函数, 取一个 <code>Integral</code> 值和一个元素做参数, 返回一个包含多个重复元素的 List, 如 <code>replicate 3 5</code> 返回 <code>[5,5,5]</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">replicate&#x27;</span> :: (<span class="hljs-type">Num</span> i, <span class="hljs-type">Ord</span> i) =&gt; i -&gt; a -&gt; [a]   <br><span class="hljs-title">replicate&#x27;</span> n x   <br>    | n &lt;= <span class="hljs-number">0</span>    = []   <br>    | otherwise = x:replicate&#x27; (n-<span class="hljs-number">1</span>) x<br></code></pre></td></tr></table></figure>

<p>实现 <code>take</code> 函数, 从 List 中取一定数量的元素, 如 <code>take 3 [5,4,3,2,1]</code> 得到 <code>[5,4,3]</code>. 若要取零或负数个的话就会得到一个空 List; 若从空 list 中取值, 也是得到空 List:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">take&#x27;</span> :: (<span class="hljs-type">Num</span> i, <span class="hljs-type">Ord</span> i) =&gt; i -&gt; [a] -&gt; [a]   <br><span class="hljs-title">take&#x27;</span> n _   <br>    | n&lt;=<span class="hljs-number">0</span>   = []   <br><span class="hljs-title">take&#x27;</span> _ []     = []   <br><span class="hljs-title">take&#x27;</span> n (x:xs) = x : take&#x27; (n-<span class="hljs-number">1</span>) xs<br></code></pre></td></tr></table></figure>

<p>快速排序的实现示例, 边界条件是, 遇到空 list 则返回空 list. 算法定义: 选数组头部作为 pivot, 将整个数组分为两部分, 小于 pivot 的部分放在 pivot 之前, 大于 pivot 的部分放在 pivot 之后:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">quicksort</span> :: (<span class="hljs-type">Ord</span> a) =&gt; [a] -&gt; [a]   <br><span class="hljs-title">quicksort</span> [] = []   <br><span class="hljs-title">quicksort</span> (x:xs) =   <br>  <span class="hljs-keyword">let</span> smallerSorted = quicksort [a | a&lt;-xs, a&lt;=x]  <br>       biggerSorted = quicksort [a | a&lt;-xs, a &gt; x]   <br>  <span class="hljs-keyword">in</span> smallerSorted ++ [x] ++ biggerSorted<br></code></pre></td></tr></table></figure>
<p>(注意这个并不是业界最优的 quicksort 实现方式)</p>
<h1 id="Haskell-高阶函数"><a href="#Haskell-高阶函数" class="headerlink" title="Haskell 高阶函数"></a>Haskell 高阶函数</h1><p>Haskell 中的函数可以作为参数和返回值传递, 这样的函数被称为 “高阶函数”.</p>
<h2 id="柯里函数"><a href="#柯里函数" class="headerlink" title="柯里函数"></a>柯里函数</h2><p>本质上, Haskell 的所有函数都只有一个参数. 所有多个参数的函数都是 “Curried function”.</p>
<p>比如对于 <code>max 4 5</code>, Haskell 实际的计算过程是 (max 4) 5, <code>(max 4)</code> 会返回一个新函数, 这个新函数可以理解为:</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">maxWith<span class="hljs-number">4</span> <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> if <span class="hljs-keyword">x</span> &gt; <span class="hljs-number">4</span> then <span class="hljs-keyword">x</span> else <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>再把这个新函数应用到参数 <code>5</code>.</p>
<p>下面两种写法是等价的:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">max</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>(max <span class="hljs-number">4</span>) <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>从另一个角度来观察, 查看 <code>max</code> 函数的类型: <code>max :: (Ord a) =&gt; a -&gt; a -&gt; a</code>, 也可以写作: <code>max :: (Ord a) a -&gt; (a -&gt; a)</code>. 读作: <code>max</code> 取一个参数 <code>a</code>, 并返回一个函数, 这个函数取一个 <code>a</code> 类型的参数, 返回一个 <code>a</code>.</p>
<p>这也是为什么 Haskell 用箭头来分隔参数和返回值.</p>
<p>另一个例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">multThree</span> :: (<span class="hljs-type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; a <br><span class="hljs-title">multThree</span> x y z = x * y * z<br></code></pre></td></tr></table></figure>

<p>如果执行 <code>mulThree 3 5 9</code>, 其等价于 <code>((mulTree 3) 5) 9</code>. 执行流程如下:</p>
<ol>
<li>把参数 <code>3</code> 传给 <code>mulTree</code>, 返回一个新函数 <code>mulTreeWithThree x = 3 * x</code></li>
<li>把参数 <code>5</code> 传给新函数, 返回一个新函数 <code>mulTreeWithFifteen x = 5 * mulTreeWithThree x</code>, 等价于 <code>mulTreeWithFifteen x = 5 * 3 * x</code></li>
<li>把参数 <code>9</code> 传给 <code>mulTreeWithFifteen</code> 得到结果 <code>5 * 3 * 9</code></li>
</ol>
<p>Haskell 这种返回函数的方式, 可以很便利地创建新函数, 比如 <code>compare</code> 函数的类型为 <code>(Ord a) =&gt; a -&gt; a -&gt; Ordering</code>, 假如只传入一个参数 <code>100</code>, 有 <code>compare 100</code>, 此时仍然会返回一个函数, 类型是 <code>(Num a, Ord a) =&gt; a -&gt; Ordering</code>. 注意这里由于参数 <code>a</code> 是一个 <code>Num</code>, 所以多了一个类型约束.</p>
<p>示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">compareWithHundred</span> :: (<span class="hljs-type">Num</span> a，<span class="hljs-type">Ord</span> a) =&gt; a -&gt; <span class="hljs-type">Ordering</span> <br><span class="hljs-title">compareWithHundred</span> x = compare <span class="hljs-number">100</span> x<br></code></pre></td></tr></table></figure>

<p>等价于:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">compareWithHundred</span> :: (<span class="hljs-type">Num</span> a，<span class="hljs-type">Ord</span> a) =&gt; a -&gt; <span class="hljs-type">Ordering</span> <br><span class="hljs-title">compareWithHundred</span> = compare <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这种调用方式也称 “不全调用”</li>
</ul>
<p>也可以对中缀函数进行不全调用, 比如 <code>/</code> 的类型是: <code>(/) :: Fractional a =&gt; a -&gt; a -&gt; a</code>. 不全调用示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">divideByTen</span> :: (<span class="hljs-type">Floating</span> a) =&gt; a -&gt; a <br><span class="hljs-title">divideByTen</span> = (/<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li>注意用括号括起来, 返回的函数接收的参数填补到缺失的那一端, 比如这里的分子</li>
</ul>
<p>调用 <code>divideByTen 200</code> 就是 <code>(/10) 200</code>, 等价于 <code>200 / 10</code>.</p>
<p>检查字符是否为大写的函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">isUpperAlphanum</span> :: <span class="hljs-type">Char</span> -&gt; <span class="hljs-type">Bool</span> <br><span class="hljs-title">isUpperAlphanum</span> = (`elem` [&#x27;<span class="hljs-type">A&#x27;</span>..&#x27;<span class="hljs-type">Z&#x27;</span>])<br></code></pre></td></tr></table></figure>

<p>取一个函数, 并调用两次的例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">applyTwice</span> :: (a -&gt; a) -&gt; a -&gt; a   <br><span class="hljs-title">applyTwice</span> f x = f (f x)<br></code></pre></td></tr></table></figure>
<ul>
<li>这里 <code>(a -&gt; a)</code> 的括号并不是必须的, 只是便于观察, 这里表示一个函数, 接受一个 <code>a</code> 类型并返回一个 <code>a</code> 类型</li>
</ul>
<p>调用示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; applyTwice (+3) 10   <br>16   <br>ghci&gt; applyTwice (++ <span class="hljs-string">&quot; HAHA&quot;</span>) <span class="hljs-string">&quot;HEY&quot;</span>   <br><span class="hljs-string">&quot;HEY HAHA HAHA&quot;</span>   <br>ghci&gt; applyTwice (<span class="hljs-string">&quot;HAHA &quot;</span> ++) <span class="hljs-string">&quot;HEY&quot;</span>   <br><span class="hljs-string">&quot;HAHA HAHA HEY&quot;</span>   <br>ghci&gt; applyTwice (multThree 2 2) 9   <br>144   <br>ghci&gt; applyTwice (3:) [1]   <br>[3,3,1]<br></code></pre></td></tr></table></figure>

<p>实现标准库的 <code>zipWith</code>, 其接受一个函数和两个 List, 让函数接受相对应的元素作为参数, 把两个 List 交到一起:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">zipWith&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]   <br><span class="hljs-title">zipWith&#x27;</span> _ [] _ = []   <br><span class="hljs-title">zipWith&#x27;</span> _ _ [] = []   <br><span class="hljs-title">zipWith&#x27;</span> f (x:xs) (y:ys) = f x y : zipWith&#x27; f xs ys<br></code></pre></td></tr></table></figure>

<p>调用示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">ghci</span>&gt; zipWith&#x27; (+) [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]   <br>[<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]   <br><span class="hljs-title">ghci</span>&gt; zipWith&#x27; max [<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] [<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]   <br>[<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]   <br><span class="hljs-title">ghci</span>&gt; zipWith&#x27; (++) [<span class="hljs-string">&quot;foo &quot;</span>，<span class="hljs-string">&quot;bar &quot;</span>，<span class="hljs-string">&quot;baz &quot;</span>] [<span class="hljs-string">&quot;fighters&quot;</span>，<span class="hljs-string">&quot;hoppers&quot;</span>，<span class="hljs-string">&quot;aldrin&quot;</span>]   <br>[<span class="hljs-string">&quot;foo fighters&quot;</span>,<span class="hljs-string">&quot;bar hoppers&quot;</span>,<span class="hljs-string">&quot;baz aldrin&quot;</span>]   <br><span class="hljs-title">ghci</span>&gt; zipWith&#x27; (*) (replicate <span class="hljs-number">5</span> <span class="hljs-number">2</span>) [<span class="hljs-number">1</span>..]   <br>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>]   <br><span class="hljs-title">ghci</span>&gt; zipWith&#x27; (zipWith&#x27; (*)) [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]] [[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]]   <br>[[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">12</span>]]<br></code></pre></td></tr></table></figure>

<p>实现标准库的 <code>flip</code> 函数, 取一个函数作为参数, 并返回一个相似的函数, 只是参数位置颠倒了:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">flip&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)<br><span class="hljs-title">flip&#x27;</span> f = g<br>    <span class="hljs-keyword">where</span> g x y = f y x<br></code></pre></td></tr></table></figure>

<p>可以写成更简单的形式:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">flip&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c   <br><span class="hljs-title">flip&#x27;</span> f y x = f x y<br></code></pre></td></tr></table></figure>

<h2 id="map-和-filter"><a href="#map-和-filter" class="headerlink" title="map 和 filter"></a>map 和 filter</h2><h3 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h3><p><code>map</code> 取一个函数和 <code>List</code> 做参数, 遍历该 <code>List</code> 的每个元素来调用该函数产生一个新的 <code>List</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]   <br><span class="hljs-title">map</span> _ [] = []   <br><span class="hljs-title">map</span> f (x:xs) = f x : map f xs<br></code></pre></td></tr></table></figure>

<p>调用示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; map (+3) [1,5,3,1,6]   <br>[4,8,6,4,9]   <br>ghci&gt; map (++ <span class="hljs-string">&quot;!&quot;</span>) [<span class="hljs-string">&quot;BIFF&quot;</span>，<span class="hljs-string">&quot;BANG&quot;</span>，<span class="hljs-string">&quot;POW&quot;</span>]   <br>[<span class="hljs-string">&quot;BIFF!&quot;</span>,<span class="hljs-string">&quot;BANG!&quot;</span>,<span class="hljs-string">&quot;POW!&quot;</span>]   <br>ghci&gt; map (replicate 3) [3..6]   <br>[[3,3,3],[4,4,4],[5,5,5],[6,6,6]]   <br>ghci&gt; map (map (^2)) [[1,2],[3,4,5,6],[7,8]]   <br>[[1,4],[9,16,25,36],[49,64]]   <br>ghci&gt; map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]   <br>[1,3,6,2,2]<br></code></pre></td></tr></table></figure>

<p>这些调用其实都能用 list comprehension 来替代, 比如 <code>map (+3) [1,5,3,1,6]</code> 与 <code>[x+3 | x &lt;- [1,5,3,1,6]]</code> 完全等价.</p>
<p>假如传递给 <code>map</code> 的是二元函数, 则每次计算都会得到一个一元函数, 比如 <code>map (*) [0..]</code> 的结果大概就是 <code>[(0*),(1*),(2*)..]</code>.</p>
<h3 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h3><p><code>filter</code> 函数取一个布尔函数和一个 List, 返回该 List 中所有符合该布尔条件的元素:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">filter</span> :: (a -&gt; <span class="hljs-type">Bool</span>) -&gt; [a] -&gt; [a]   <br><span class="hljs-title">filter</span> _ [] = []   <br><span class="hljs-title">filter</span> p (x:xs)    <br>    | p x       = x : filter p xs   <br>    | otherwise = filter p xs<br></code></pre></td></tr></table></figure>

<p>调用示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; filter (&gt;3) [1,5,3,2,1,6,4,3,2,1]   <br>[5,6,4]   <br>ghci&gt; filter (==3) [1,2,3,4,5]   <br>[3]   <br>ghci&gt; filter even [1..10]   <br>[2,4,6,8,10]   <br>ghci&gt; <span class="hljs-built_in">let</span> notNull x = not (null x) <span class="hljs-keyword">in</span> filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]   <br>[[1,2,3],[3,4,5],[2,2]]   <br>ghci&gt; filter (`elem` [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;z&#x27;</span>]) <span class="hljs-string">&quot;u LaUgH aT mE BeCaUsE I aM diFfeRent&quot;</span>   <br><span class="hljs-string">&quot;uagameasadifeent&quot;</span>   <br>ghci&gt; filter (`elem` [<span class="hljs-string">&#x27;A&#x27;</span>..<span class="hljs-string">&#x27;Z&#x27;</span>]) <span class="hljs-string">&quot;i lauGh At You BecAuse u r aLL the Same&quot;</span>   <br><span class="hljs-string">&quot;GAYBALLS&quot;</span><br></code></pre></td></tr></table></figure>

<p>这些同样可以用 list comprehension 来实现.</p>
<p><code>takeWhile</code> 函数, 取一个限制条件和 List 作为参数, 从头开始遍历这一 List, 并回传符合限制条件的元素, 一旦遇到不符合条件的元素, 就停止, 比如取出 <code>&quot;elephants know how to party&quot;</code> 中的首个单词, 可以写:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; takeWhile (/=<span class="hljs-string">&quot; &quot;</span>) <span class="hljs-string">&quot;elephants know how to party&quot;</span><br>elephants<br></code></pre></td></tr></table></figure>

<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p><code>Lambda</code> 就是匿名函数, 语法为:</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\args</span> -&gt; body<br></code></pre></td></tr></table></figure>
<ul>
<li>用 <code>\</code> 开头, 后面跟空格分隔的参数列表</li>
<li><code>-&gt;</code> 之后是函数体</li>
</ul>
<p>比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">numLongChains</span> :: <span class="hljs-type">Int</span>  <br><span class="hljs-title">numLongChains</span> = length (filter (\xs -&gt; length xs &gt; <span class="hljs-number">15</span>) (map chain [<span class="hljs-number">1</span>..<span class="hljs-number">100</span>]))<br></code></pre></td></tr></table></figure>

<p><code>Lambda</code> 是一个表达式, 因此可以任意传递, 这里 <code>(\xs -&gt; length xs &gt; 15)</code> 回传一个函数, 用来判断一个列表的长度是否大于 <code>15</code>.</p>
<p>大多时候都是直接用 curried function 或不全调用, 而非 lambda, 比如 <code>map (+3) [1,6,3,2]</code> 与 <code>map (\x -&gt; x + 3) [1,6,3,2]</code> 是等价的.</p>
<p>多个参数的 <code>lambda</code> 示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; zipWith (\a b -&gt; (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]  <br>[153.0,61.5,31.0,15.75,6.6]<br></code></pre></td></tr></table></figure>

<p>(一般情况下, <code>lambda</code> 函数都使用括号包裹的)</p>
<p>由于柯里化, 下面两个函数是等价的:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">addThree</span> :: (<span class="hljs-type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; a  <br><span class="hljs-title">addThree</span> x y z = x + y + z<br></code></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">addThree</span> :: (<span class="hljs-type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; a  <br><span class="hljs-title">addThree</span> = \x -&gt; \y -&gt; \z -&gt; x + y + z<br></code></pre></td></tr></table></figure>

<p>用 <code>lambda</code> 重写一个最易读的 <code>flip</code> 实现:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">flip</span> :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)<br><span class="hljs-title">flip</span> f = \x y -&gt; f y x<br></code></pre></td></tr></table></figure>

<h2 id="关键字-fold"><a href="#关键字-fold" class="headerlink" title="关键字 fold"></a>关键字 fold</h2><p><code>fold</code> 函数用来将一个列表 (或其他递归数据结构) “压缩” 成一个单一的值, 其参数取:</p>
<ul>
<li>一个二元函数</li>
<li>一个初始值 (累加值)</li>
<li>一个需要折叠的 List</li>
</ul>
<p>二元函数的参数是累加值和 List 的首项, 并且返回新的累加值.</p>
<p>所有遍历 List 中元素并据此返回一个值 (这个值也可以是 List) 的操作都可以交给 <code>fold</code> 来实现.</p>
<h3 id="foldl"><a href="#foldl" class="headerlink" title="foldl"></a>foldl</h3><p><code>foldl</code> 函数 (fold left), 从 List 的左端开始折叠, 用初始值和 List 的头部调用二元函数, 得到一个新的累加值, 然后用新的累加值和 List 的下一个元素调用二元函数, 直到遍历整个 List. <code>foldl</code> 函数的类型为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t foldl :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b<br></code></pre></td></tr></table></figure>
<ul>
<li><code>t a</code> 可以是 List 等可折叠的数据结构</li>
</ul>
<p>用 <code>foldl</code> 来实现 <code>sum</code> 的示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">sum&#x27;&#x27;</span> :: (<span class="hljs-type">Num</span> a) =&gt; [a] -&gt; a<br><span class="hljs-title">sum&#x27;&#x27;</span> = foldl (+) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这里借助了柯里化和部分调用, <code>foldl (+) 0</code> 会返回一个 <code>[a] -&gt; a</code> 类型的函数</li>
</ul>
<p>用 <code>foldl</code> 来实现 <code>elem</code> 的示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">elem&#x27;</span> :: (<span class="hljs-type">Eq</span> a) =&gt; a -&gt; [a] -&gt; <span class="hljs-type">Bool</span><br><span class="hljs-title">elem&#x27;</span> e xs = foldl (\acc x -&gt; acc || (x == e)) <span class="hljs-type">False</span> xs<br></code></pre></td></tr></table></figure>

<p>用 <code>foldl</code> 来实现 <code>map</code> 的示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">map&#x27;</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]  <br><span class="hljs-title">map&#x27;</span> f xs = foldl (\acc x -&gt; acc ++ [f x]) [] xs<br></code></pre></td></tr></table></figure>

<h3 id="foldr"><a href="#foldr" class="headerlink" title="foldr"></a>foldr</h3><p><code>foldr</code> 函数 (fold right), 从 List 的右端开始折叠, 其余与 <code>foldl</code> 类似.</p>
<p>用 <code>foldr</code> 实现 <code>map</code> 的示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">map&#x27;</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]  <br><span class="hljs-title">map&#x27;</span> f xs = foldr (\x acc -&gt; f x : acc) [] xs<br></code></pre></td></tr></table></figure>

<p>一个理解 <code>foldr</code> 操作的例子, 假设有二元函数 <code>f</code>, 起始值为 <code>z</code>, 从右折叠 <code>[3,4,5,6]</code>, 实际的执行就等价于:</p>
<ul>
<li><code>f 3 (f 4 (f 5 (f 6 z)))</code></li>
</ul>
<h3 id="foldl1-和-foldr1"><a href="#foldl1-和-foldr1" class="headerlink" title="foldl1 和 foldr1"></a>foldl1 和 foldr1</h3><p><code>foldl1</code> 和 <code>foldr1</code> 的行为与 <code>foldl</code> 和 <code>foldr</code> 类似, 只不过不需要提供初始值, 其假定 List 的首个 (或末尾) 元素作为起始值, 并从旁边的元素开始折叠.</p>
<p>比如 <code>sum</code> 函数可以实现为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">sum&#x27;</span> :: (<span class="hljs-type">Num</span> a) =&gt; [a] -&gt; a<br><span class="hljs-title">sum&#x27;</span> = foldl1 (+)<br></code></pre></td></tr></table></figure>
<ul>
<li>但这个要求待折叠的 list 中至少要有一个元素, 不然会产生运行时错误</li>
</ul>
<p>用 <code>fold</code> 函数实现常见库函数的例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">maximum&#x27;</span> :: (<span class="hljs-type">Ord</span> a) =&gt; [a] -&gt; a  <br><span class="hljs-title">maximum&#x27;</span> = foldr1 (\x acc -&gt; <span class="hljs-keyword">if</span> x &gt; acc <span class="hljs-keyword">then</span> x <span class="hljs-keyword">else</span> acc)  <br><br><span class="hljs-title">reverse&#x27;</span> :: [a] -&gt; [a]  <br><span class="hljs-title">reverse&#x27;</span> = foldl (\acc x -&gt; x : acc) []  <br><br><span class="hljs-title">product&#x27;</span> :: (<span class="hljs-type">Num</span> a) =&gt; [a] -&gt; a  <br><span class="hljs-title">product&#x27;</span> = foldr1 (*)  <br><br><span class="hljs-title">filter&#x27;</span> :: (a -&gt; <span class="hljs-type">Bool</span>) -&gt; [a] -&gt; [a]  <br><span class="hljs-title">filter&#x27;</span> p = foldr (\x acc -&gt; <span class="hljs-keyword">if</span> p x <span class="hljs-keyword">then</span> x : acc <span class="hljs-keyword">else</span> acc) []  <br><br><span class="hljs-title">head&#x27;</span> :: [a] -&gt; a  <br><span class="hljs-title">head&#x27;</span> = foldr1 (\x _ -&gt; x)  <br><br><span class="hljs-title">last&#x27;</span> :: [a] -&gt; a  <br><span class="hljs-title">last&#x27;</span> = foldl1 (\_ x -&gt; x)<br></code></pre></td></tr></table></figure>

<h3 id="scanl-scanr-scanl1-和-scanr1"><a href="#scanl-scanr-scanl1-和-scanr1" class="headerlink" title="scanl, scanr, scanl1 和 scanr1"></a>scanl, scanr, scanl1 和 scanr1</h3><p><code>scanl</code> 和 <code>scanr</code> 与 <code>foldl</code> 和 <code>foldr</code> 类似, 只不过它们会记录下累加值的所有状态到一个 List:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">ghci</span>&gt; scanl (+) <span class="hljs-number">0</span> [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]  <br>[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>]  <br><span class="hljs-title">ghci</span>&gt; scanr (+) <span class="hljs-number">0</span> [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]  <br>[<span class="hljs-number">11</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]  <br><span class="hljs-title">ghci</span>&gt; scanl1 (\acc x -&gt; <span class="hljs-keyword">if</span> x &gt; acc <span class="hljs-keyword">then</span> x <span class="hljs-keyword">else</span> acc) [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]  <br>[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>]  <br><span class="hljs-title">ghci</span>&gt; scanl (flip (:)) [] [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]  <br>[[],[<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<br></code></pre></td></tr></table></figure>

<h2 id="有-的函数调用"><a href="#有-的函数调用" class="headerlink" title="有 $ 的函数调用"></a>有 $ 的函数调用</h2><p><code>$</code> 函数, 称作函数调用符:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell">($) :: (a -&gt; b) -&gt; a -&gt; b  <br><span class="hljs-title">f</span> $ x = f x<br></code></pre></td></tr></table></figure>

<p>普通的函数调用符有最高的优先级, 而 <code>$</code> 的优先级最低.</p>
<p>用空格的函数调用符是左结合的, 如 <code>f a b c</code> 与 <code>((f a) b) c</code> 等价.</p>
<p>而 <code>$</code> 是右结合的, 可以用来较少代码中的括号数量, 比如有表达式: <code>sum (map sqrt [1..130])</code></p>
<p>用 <code>$</code> 可以改写为: <code>sum $ map sqrt [1..130]</code>.</p>
<p>另一个例子, 可以把 <code>sqrt (3 + 4 + 9)</code> 改写为 <code>sqrt $ 3 + 4 + 9</code>.</p>
<p>除了减少括号外, <code>$</code> 还可以把数据当作函数来使用, 如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; map ($ 3) [(4+),(10*),(^2),sqrt]  <br>[7.0,30.0,9.0,1.7320508075688772]<br></code></pre></td></tr></table></figure>

<h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><p>函数组合 (复合函数), 在数学上可以这样定义: 给定两个函数:</p>
<ul>
<li>$f: B \rightarrow C$</li>
<li>$g: A \rightarrow B$</li>
</ul>
<p>它们的组合是一个新函数, 记为:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>(f \odot g) (x) &#x3D; f(g(x))<br>\end{aligned}<br>}<br>$$<br>(先应用 <code>g</code>, 再把结果传给 <code>f</code>)</p>
<p>在 Haskell 中, 利用 <code>.</code> 函数来进行函数组合, <code>.</code> 函数的定义为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c  <br><span class="hljs-title">f</span> . g = \x -&gt; f (g x)<br></code></pre></td></tr></table></figure>

<p>需要注意这里的类型声明:</p>
<ul>
<li><code>f</code> 的类型是 <code>b -&gt; c</code></li>
<li><code>g</code> 的类型是 <code>a -&gt; b</code></li>
</ul>
<p><code>f</code> 的输入参数必须与 <code>g</code> 的返回类型相同. 所得到的组合函数的输入类型与 <code>g</code> 相同, 输出类型与 <code>f</code> 相同.</p>
<p>函数组合的主要作用就是生成新函数, 比如要将一个数字 List 全部转换为负数, 可以考虑先取绝对值, 然后全部取负数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; map (\x -&gt; negate (abs x)) [5,-3,-6,7,-3,2,-19,24]  <br>[-5,-3,-6,-7,-3,-2,-19,-24]<br></code></pre></td></tr></table></figure>

<p>可以用函数组合改写为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; map (negate . abs) [5,-3,-6,7,-3,2,-19,24]  <br>[-5,-3,-6,-7,-3,-2,-19,-24]<br></code></pre></td></tr></table></figure>

<p>又比如组合多个函数, <code>f (g (z x))</code> 与 <code>(f . g . z) x</code> 等价, 因此有:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; map (\xs -&gt; negate (<span class="hljs-built_in">sum</span> (<span class="hljs-built_in">tail</span> xs))) [[1..5],[3..6],[1..7]]  <br>[-14,-15,-27]<br></code></pre></td></tr></table></figure>

<p>改为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; map (negate . <span class="hljs-built_in">sum</span> . <span class="hljs-built_in">tail</span>) [[1..5],[3..6],[1..7]]  <br>[-14,-15,-27]<br></code></pre></td></tr></table></figure>

<p>如果包含多个参数的函数, 则可以用不全调用使得每个函数都只剩下一个参数, 比如 <code>sum (replicate 5 (max 6 8))</code> 可以重写为 <code>(sum . replicate 5 . max 6) 8</code>.</p>
<p>如果想去掉括号, 通常在最接近参数的函数之后加上 <code>$</code> 即可, 比如 <code>replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))</code> 可以重写为: <code>replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]</code>.</p>
<p>函数组合还用于定义 point free style 的函数, 如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">sum&#x27;</span> :: (<span class="hljs-type">Num</span> a) =&gt; [a] -&gt; a     <br><span class="hljs-title">sum&#x27;</span> xs = foldl (+) <span class="hljs-number">0</span> xs<br></code></pre></td></tr></table></figure>
<p>等号两端都有个 <code>xs</code>, 由于 currying, 可以省掉两端的 <code>xs</code>, 因为 <code>foldl (+) 0</code> 会返回一个取一个 List 作为参数的函数, 因此可以改为为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">sum&#x27;</span> :: (<span class="hljs-type">Num</span> a) =&gt; [a] -&gt; a     <br><span class="hljs-title">sum&#x27;</span> = foldl (+) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这就是 point free style</li>
</ul>
<p>对于下面的函数, 则不能直接去掉两端的 <code>x</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">fn</span> x = ceiling (negate (tan (cos (max <span class="hljs-number">50</span> x))))<br></code></pre></td></tr></table></figure>

<p>此时可以借助函数组合, 重写为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">fn</span> = ceiling . negate . tan . cos . max <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure>

<h1 id="Haskell-模块"><a href="#Haskell-模块" class="headerlink" title="Haskell 模块"></a>Haskell 模块</h1><p>Haskell 中的模块是含有一组相关的函数, 类型和类型类的组合. Haskell 程序的本质便是从主模块中引用其他模块并调用其中的函数来执行操作.</p>
<p>之前学习到的函数, 类型, 都来自 <code>Prelude</code> 模块, 它会默认装载.</p>
<p>在 Haskell 中, 用 <code>import</code> 关键字来装载一个模块, 这会把模块中所有名称引入全局的命名空间. 装载需要位于函数调用之前, 通常放在代码的顶部.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> Data.List   <br><br><span class="hljs-title">numUniques</span> :: (<span class="hljs-type">Eq</span> a) =&gt; [a] -&gt; <span class="hljs-type">Int</span>   <br><span class="hljs-title">numUniques</span> = length . nub<br></code></pre></td></tr></table></figure>
<ul>
<li><code>nub</code> 函数可以筛掉一个 List 中的所有重复元素</li>
</ul>
<p>若在 <code>ghci</code> 中装载模块, 需要用 <code>:m</code> 命令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :m Data.List<br>ghci&gt; :m Data.List Data.Map Data.Set<br></code></pre></td></tr></table></figure>

<p>如果只想引入部分函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> Data.List (<span class="hljs-title">num</span>, <span class="hljs-title">sort</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li>函数之间用 <code>,</code> 分隔</li>
</ul>
<p>引入除去某些函数之外的部分, 可以添加 <code>hiding</code> 关键字:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> Data.List <span class="hljs-keyword">hiding</span> (<span class="hljs-title">hub</span>)<br></code></pre></td></tr></table></figure>

<p>不直接导入到全局的命名空间, 而是通过完整路径调用, 需要添加 <code>qualified</code> 关键字:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.Map<br></code></pre></td></tr></table></figure>

<p>为模块添加别名, 用 <code>as</code> 关键字:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.Map <span class="hljs-keyword">as</span> M<br></code></pre></td></tr></table></figure>

<h2 id="Data-List"><a href="#Data-List" class="headerlink" title="Data.List"></a>Data.List</h2><p><code>Data.List</code> 提供了一组处理 <code>List</code> 的函数, 比如 <code>map</code>, <code>filter</code> 就来自这个模块, 由 <code>Prelude</code> 默认导出.</p>
<h3 id="intersperse"><a href="#intersperse" class="headerlink" title="intersperse"></a>intersperse</h3><p><code>intersperse</code> 取一个元素与 List 作为参数, 并将该元素置于 List 中每对元素的中间:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; intersperse <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-string">&quot;MONKEY&quot;</span>   <br><span class="hljs-string">&quot;M.O.N.K.E.Y&quot;</span>   <br>ghci&gt; intersperse 0 [1,2,3,4,5,6]   <br>[1,0,2,0,3,0,4,0,5,0,6]<br></code></pre></td></tr></table></figure>

<h3 id="intercalate"><a href="#intercalate" class="headerlink" title="intercalate"></a>intercalate</h3><p><code>intercalate</code> 取两个 List 作参数, 将第一个 List 交叉插入第二个 List 中间, 并返回一个 List:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; intercalate <span class="hljs-string">&quot; &quot;</span> [<span class="hljs-string">&quot;hey&quot;</span>,<span class="hljs-string">&quot;there&quot;</span>,<span class="hljs-string">&quot;guys&quot;</span>]   <br><span class="hljs-string">&quot;hey there guys&quot;</span>   <br>ghci&gt; intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]]   <br>[1,2,3,0,0,0,4,5,6,0,0,0,7,8,9]<br></code></pre></td></tr></table></figure>

<h3 id="transpose"><a href="#transpose" class="headerlink" title="transpose"></a>transpose</h3><p><code>transpose</code> 反转一个二维 List (2D 矩阵):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; transpose [[1,2,3],[4,5,6],[7,8,9]]   <br>[[1,4,7],[2,5,8],[3,6,9]]   <br>ghci&gt; transpose [<span class="hljs-string">&quot;hey&quot;</span>,<span class="hljs-string">&quot;there&quot;</span>,<span class="hljs-string">&quot;guys&quot;</span>]   <br>[<span class="hljs-string">&quot;htg&quot;</span>,<span class="hljs-string">&quot;ehu&quot;</span>,<span class="hljs-string">&quot;yey&quot;</span>,<span class="hljs-string">&quot;rs&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>]<br></code></pre></td></tr></table></figure>

<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p><code>concat</code> 把一组 List 连接为一个 List:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; concat [<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;car&quot;</span>]   <br><span class="hljs-string">&quot;foobarcar&quot;</span>   <br>ghci&gt; concat [[3,4,5],[2,3,4],[2,1,1]]   <br>[3,4,5,2,3,4,2,1,1]<br></code></pre></td></tr></table></figure>
<ul>
<li>相当于移除一级嵌套</li>
</ul>
<h3 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap"></a>concatMap</h3><p><code>concatMap</code> 先对 List 做 map 操作, 之后再 <code>concat</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; concatMap (replicate 4) [1..3]   <br>[1,1,1,1,2,2,2,2,3,3,3,3]<br></code></pre></td></tr></table></figure>

<h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><p><code>and</code> 取一组布尔值 List 作参数, 只有其中所有值全为 <code>True</code> 才会返回 <code>True</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; and $ map (&gt;4) [5,6,7,8]   <br>True   <br>ghci&gt; and $ map (==4) [4,4,4,3,4]   <br>False<br></code></pre></td></tr></table></figure>

<h3 id="or"><a href="#or" class="headerlink" title="or"></a>or</h3><p><code>or</code> 与 <code>and</code> 类似, 一组布尔值中若存在一个 <code>True</code> 则返回 <code>True</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; or $ map (==4) [2,3,4,5,6,1]   <br>True   <br>ghci&gt; or $ map (&gt;4) [1,2,3]   <br>False<br></code></pre></td></tr></table></figure>

<h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p><code>any</code> 取一个限制条件和一组 List 作参数, 如果有某个元素符合, 则返回 <code>True</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; any (==4) [2,3,5,6,1,4]   <br>True   <br>ghci&gt; any (`elem` [<span class="hljs-string">&#x27;A&#x27;</span>..<span class="hljs-string">&#x27;Z&#x27;</span>]) <span class="hljs-string">&quot;HEYGUYSwhatsup&quot;</span>   <br>True<br></code></pre></td></tr></table></figure>

<h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p><code>all</code> 也取一个限制条件和一组 List 作参数, 如果所有元素都符合, 则返回 <code>True</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; all (&gt;4) [6,9,10]   <br>True   <br>ghci&gt; all (`elem` [<span class="hljs-string">&#x27;A&#x27;</span>..<span class="hljs-string">&#x27;Z&#x27;</span>]) <span class="hljs-string">&quot;HEYGUYSwhatsup&quot;</span>   <br>False   <br></code></pre></td></tr></table></figure>

<h3 id="iterate"><a href="#iterate" class="headerlink" title="iterate"></a>iterate</h3><p><code>iterate</code> 取一个函数和一个值作参数, 用该值调用函数并用结果接着调用函数, 得到一个无限的 List:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; take 10 $ iterate (*2) 1   <br>[1,2,4,8,16,32,64,128,256,512]   <br>ghci&gt; take 3 $ iterate (++ <span class="hljs-string">&quot;haha&quot;</span>) <span class="hljs-string">&quot;haha&quot;</span>   <br>[<span class="hljs-string">&quot;haha&quot;</span>,<span class="hljs-string">&quot;hahahaha&quot;</span>,<span class="hljs-string">&quot;hahahahahaha&quot;</span>]<br></code></pre></td></tr></table></figure>

<h3 id="splitAt"><a href="#splitAt" class="headerlink" title="splitAt"></a>splitAt</h3><p><code>splitAt</code> 取一个 <code>List</code> 和数值作参数, 将该 <code>List</code> 在特定的位置断开, 返回一个包含两个 <code>List</code> 的二元组:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; splitAt 3 <span class="hljs-string">&quot;heyman&quot;</span>   <br>(<span class="hljs-string">&quot;hey&quot;</span>,<span class="hljs-string">&quot;man&quot;</span>)   <br>ghci&gt; splitAt 100 <span class="hljs-string">&quot;heyman&quot;</span>   <br>(<span class="hljs-string">&quot;heyman&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)   <br>ghci&gt; splitAt (-3) <span class="hljs-string">&quot;heyman&quot;</span>   <br>(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;heyman&quot;</span>)   <br>ghci&gt; <span class="hljs-built_in">let</span> (a,b) = splitAt 3 <span class="hljs-string">&quot;foobar&quot;</span> <span class="hljs-keyword">in</span> b ++ a   <br><span class="hljs-string">&quot;barfoo&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h3><p><code>takeWhile</code> 从一个 List 中取元素, 直到遇到不符合条件的元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; takeWhile (&gt;3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]   <br>[6,5,4]   <br>ghci&gt; takeWhile (/=<span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-string">&quot;This is a sentence&quot;</span>   <br><span class="hljs-string">&quot;This&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="dropWhile"><a href="#dropWhile" class="headerlink" title="dropWhile"></a>dropWhile</h3><p><code>dropWhile</code> 丢弃掉 List 中满足条件的元素, 直到遇到不符合条件的元素, 返回剩下元素.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; dropWhile (/=<span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-string">&quot;This is a sentence&quot;</span>   <br><span class="hljs-string">&quot; is a sentence&quot;</span>   <br>ghci&gt; dropWhile (3) [1,2,2,2,3,4,5,4,3,2,1]   <br>[3,4,5,4,3,2,1]<br></code></pre></td></tr></table></figure>

<h3 id="span"><a href="#span" class="headerlink" title="span"></a>span</h3><p><code>span</code> 与 <code>takeWhile</code> 类似, 在初次遇到 <code>False</code> 时断开, 只不过还会返回余下的 List:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">let</span> (fw，rest) = span (/=<span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-string">&quot;This is a sentence&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;First word:&quot;</span> ++ fw ++ <span class="hljs-string">&quot;，the rest:&quot;</span> ++ rest   <br><span class="hljs-string">&quot;First word: This，the rest: is a sentence&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p><code>break</code> 与 <code>span</code> 类似, 只不过是初次遇到 <code>True</code> 时断开, 返回两个 List:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">break</span> (==4) [1,2,3,4,5,6,7]   <br>([1,2,3],[4,5,6,7])   <br>ghci&gt; span (/=4) [1,2,3,4,5,6,7]   <br>([1,2,3],[4,5,6,7])<br></code></pre></td></tr></table></figure>

<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p><code>sort</code> 将一个可排序的 List 按照升序排列:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">sort</span> [8,5,3,2,1,6,4,2]   <br>[1,2,2,3,4,5,6,8]   <br>ghci&gt; <span class="hljs-built_in">sort</span> <span class="hljs-string">&quot;This will be sorted soon&quot;</span>   <br><span class="hljs-string">&quot; Tbdeehiillnooorssstw&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><p><code>group</code> 将一个 List 中相同元素组合成子 List:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]   <br>[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]<br></code></pre></td></tr></table></figure>

<h3 id="inits-和-tails"><a href="#inits-和-tails" class="headerlink" title="inits 和 tails"></a>inits 和 tails</h3><p>与 <code>init</code> 和 <code>tail</code> 类似, 但会递归调用自身直到 List 为空:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; inits <span class="hljs-string">&quot;w00t&quot;</span>   <br>[<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-string">&quot;w0&quot;</span>,<span class="hljs-string">&quot;w00&quot;</span>,<span class="hljs-string">&quot;w00t&quot;</span>]   <br>ghci&gt; tails <span class="hljs-string">&quot;w00t&quot;</span>   <br>[<span class="hljs-string">&quot;w00t&quot;</span>,<span class="hljs-string">&quot;00t&quot;</span>,<span class="hljs-string">&quot;0t&quot;</span>,<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;&quot;</span>]   <br>ghci&gt; <span class="hljs-built_in">let</span> w = <span class="hljs-string">&quot;w00t&quot;</span> <span class="hljs-keyword">in</span> zip (inits w) (tails w)   <br>[(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;w00t&quot;</span>),(<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-string">&quot;00t&quot;</span>),(<span class="hljs-string">&quot;w0&quot;</span>,<span class="hljs-string">&quot;0t&quot;</span>),(<span class="hljs-string">&quot;w00&quot;</span>,<span class="hljs-string">&quot;t&quot;</span>),(<span class="hljs-string">&quot;w00t&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)]<br></code></pre></td></tr></table></figure>

<h3 id="isInfixOf"><a href="#isInfixOf" class="headerlink" title="isInfixOf"></a>isInfixOf</h3><p><code>isInfixOf</code> 从一个 List 中搜索一个子 List, 若包含, 则返回 <code>True</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-string">&quot;cat&quot;</span> `isInfixOf` <span class="hljs-string">&quot;im a cat burglar&quot;</span>   <br>True   <br>ghci&gt; <span class="hljs-string">&quot;Cat&quot;</span> `isInfixOf` <span class="hljs-string">&quot;im a cat burglar&quot;</span>   <br>False   <br>ghci&gt; <span class="hljs-string">&quot;cats&quot;</span> `isInfixOf` <span class="hljs-string">&quot;im a cat burglar&quot;</span>   <br>False<br></code></pre></td></tr></table></figure>

<h3 id="isPrefixOf-和-isSuffixOf"><a href="#isPrefixOf-和-isSuffixOf" class="headerlink" title="isPrefixOf 和 isSuffixOf"></a>isPrefixOf 和 isSuffixOf</h3><p><code>isPrefixOf</code> 和 <code>isSuffixOf</code> 分别检查一个 List 是否以某个 <code>List</code> 开头或者结尾:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-string">&quot;hey&quot;</span> `isPrefixOf` <span class="hljs-string">&quot;hey there!&quot;</span>   <br>True   <br>ghci&gt; <span class="hljs-string">&quot;hey&quot;</span> `isPrefixOf` <span class="hljs-string">&quot;oh hey there!&quot;</span>   <br>False   <br>ghci&gt; <span class="hljs-string">&quot;there!&quot;</span> `isSuffixOf` <span class="hljs-string">&quot;oh hey there!&quot;</span>   <br>True   <br>ghci&gt; <span class="hljs-string">&quot;there!&quot;</span> `isSuffixOf` <span class="hljs-string">&quot;oh hey there&quot;</span>   <br>False<br></code></pre></td></tr></table></figure>

<h3 id="elem-和-notElem"><a href="#elem-和-notElem" class="headerlink" title="elem 和 notElem"></a>elem 和 notElem</h3><p><code>elem</code> 和 <code>notElem</code> 检查一个 List 是否包含某元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; 1 `elem` [0,2,3,4,5]<br>False<br>ghci&gt; 1 `notElem` [0,2,3,4,5]<br>True<br>ghci&gt; 1 `elem` [0,1,2,3,4,5]<br>True<br>ghci&gt; 1 `notElem` [0,1,2,3,4,5]<br>False<br></code></pre></td></tr></table></figure>

<h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h3><p><code>partition</code> 取一个限制条件和 List 作参数, 返回两个 <code>List</code>, 第一个 <code>List</code> 中包含所有符合条件的元素, 第二个包含余下元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; partition (`elem` [<span class="hljs-string">&#x27;A&#x27;</span>..<span class="hljs-string">&#x27;Z&#x27;</span>]) <span class="hljs-string">&quot;BOBsidneyMORGANeddy&quot;</span>   <br>(<span class="hljs-string">&quot;BOBMORGAN&quot;</span>,<span class="hljs-string">&quot;sidneyeddy&quot;</span>)   <br>ghci&gt; partition (&gt;3) [1,3,5,6,3,2,1,0,3,7]   <br>([5,6,7],[1,3,3,2,1,0,3])<br></code></pre></td></tr></table></figure>

<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>find</code> 取一个限制条件和 List 作参数, 返回首个符合条件的元素, 且该元素是一个 <code>Maybe</code> 值.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; find (&gt;4) [1,2,3,4,5,6]   <br>Just 5   <br>ghci&gt; find (&gt;9) [1,2,3,4,5,6]   <br>Nothing   <br>ghci&gt; :t find   <br>find :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a<br></code></pre></td></tr></table></figure>

<h3 id="elemIndex"><a href="#elemIndex" class="headerlink" title="elemIndex"></a>elemIndex</h3><p><code>elemIndex</code> 与 <code>elem</code> 类似, 但其 “可能” 返回要找元素的索引:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t elemIndex   <br>elemIndex :: (Eq a) =&gt; a -&gt; [a] -&gt; Maybe Int   <br>ghci&gt; 4 `elemIndex` [1,2,3,4,5,6]   <br>Just 3   <br>ghci&gt; 10 `elemIndex` [1,2,3,4,5,6]   <br>Nothing<br></code></pre></td></tr></table></figure>

<h3 id="elemIndices"><a href="#elemIndices" class="headerlink" title="elemIndices"></a>elemIndices</h3><p><code>elemIndices</code> 与 <code>elemIndex</code> 类似, 只不过返回一组索引:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; findIndex (==4) [5,3,2,1,6,4]   <br>Just 5   <br>ghci&gt; findIndex (==7) [5,3,2,1,6,4]   <br>Nothing   <br>ghci&gt; findIndices (`elem` [<span class="hljs-string">&#x27;A&#x27;</span>..<span class="hljs-string">&#x27;Z&#x27;</span>]) <span class="hljs-string">&quot;Where Are The Caps?&quot;</span>   <br>[0,6,10,14]<br></code></pre></td></tr></table></figure>

<h3 id="zip-zip3-zip7"><a href="#zip-zip3-zip7" class="headerlink" title="zip, zip3,..,zip7"></a>zip, zip3,..,zip7</h3><p><code>zip3</code>, <code>zipWith3</code> 是组合 3 个 List 到一个三元组, 一直到 <code>zip7</code>, <code>zipWith7</code> 可以组合 7 个 List 到一个七元组:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; zipWith3 (\x y z -&gt; x + y + z) [1,2,3] [4,5,2,2] [2,2,3]   <br>[7,9,8]   <br>ghci&gt; zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]   <br>[(2,2,5,2),(3,2,5,2),(3,2,3,2)]<br></code></pre></td></tr></table></figure>

<h3 id="lines"><a href="#lines" class="headerlink" title="lines"></a>lines</h3><p><code>lines</code> 取一个字符串作参数, 返回其中每一行组成的 <code>List</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; lines <span class="hljs-string">&quot;first line\nsecond line\nthird line&quot;</span>   <br>[<span class="hljs-string">&quot;first line&quot;</span>,<span class="hljs-string">&quot;second line&quot;</span>,<span class="hljs-string">&quot;third line&quot;</span>]<br></code></pre></td></tr></table></figure>

<h3 id="unlines"><a href="#unlines" class="headerlink" title="unlines"></a>unlines</h3><p><code>unlines</code> 取一组字符串的 List 作参数, 将其通过 <code>\n</code> 合并成一个字符串:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; unlines [<span class="hljs-string">&quot;first line&quot;</span>，<span class="hljs-string">&quot;second line&quot;</span>，<span class="hljs-string">&quot;third line&quot;</span>]   <br><span class="hljs-string">&quot;first line\nsecond line\nthird line\n&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="words"><a href="#words" class="headerlink" title="words"></a>words</h3><p><code>words</code> 将一个字符串分为一组单词:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; words <span class="hljs-string">&quot;hey these are the words in this sentence&quot;</span>   <br>[<span class="hljs-string">&quot;hey&quot;</span>,<span class="hljs-string">&quot;these&quot;</span>,<span class="hljs-string">&quot;are&quot;</span>,<span class="hljs-string">&quot;the&quot;</span>,<span class="hljs-string">&quot;words&quot;</span>,<span class="hljs-string">&quot;in&quot;</span>,<span class="hljs-string">&quot;this&quot;</span>,<span class="hljs-string">&quot;sentence&quot;</span>]   <br>ghci&gt; words <span class="hljs-string">&quot;hey these are the words in this\nsentence&quot;</span>   <br>[<span class="hljs-string">&quot;hey&quot;</span>,<span class="hljs-string">&quot;these&quot;</span>,<span class="hljs-string">&quot;are&quot;</span>,<span class="hljs-string">&quot;the&quot;</span>,<span class="hljs-string">&quot;words&quot;</span>,<span class="hljs-string">&quot;in&quot;</span>,<span class="hljs-string">&quot;this&quot;</span>,<span class="hljs-string">&quot;sentence&quot;</span>] <br></code></pre></td></tr></table></figure>

<h3 id="unwords"><a href="#unwords" class="headerlink" title="unwords"></a>unwords</h3><p><code>unwords</code> 将一组单词 List 组合为一个字符串:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; unwords [<span class="hljs-string">&quot;hey&quot;</span>,<span class="hljs-string">&quot;there&quot;</span>,<span class="hljs-string">&quot;mate&quot;</span>]   <br><span class="hljs-string">&quot;hey there mate&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="nub"><a href="#nub" class="headerlink" title="nub"></a>nub</h3><p><code>nub</code> 取一个 List 作参数, 筛掉所有重复元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; nub [1,2,3,4,3,2,1,2,3,4,3,2,1]   <br>[1,2,3,4]   <br>ghci&gt; nub <span class="hljs-string">&quot;Lots of words and stuff&quot;</span>   <br><span class="hljs-string">&quot;Lots fwrdanu&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><code>delete</code> 取一个元素和 List 作参数, 删掉 List 中首次出现的这一元素.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; delete <span class="hljs-string">&#x27;h&#x27;</span> <span class="hljs-string">&quot;hey there ghang!&quot;</span>   <br><span class="hljs-string">&quot;ey there ghang!&quot;</span>   <br>ghci&gt; delete <span class="hljs-string">&#x27;h&#x27;</span> 。delete <span class="hljs-string">&#x27;h&#x27;</span> $ <span class="hljs-string">&quot;hey there ghang!&quot;</span>   <br><span class="hljs-string">&quot;ey tere ghang!&quot;</span>   <br>ghci&gt; delete <span class="hljs-string">&#x27;h&#x27;</span> 。delete <span class="hljs-string">&#x27;h&#x27;</span> 。delete <span class="hljs-string">&#x27;h&#x27;</span> $ <span class="hljs-string">&quot;hey there ghang!&quot;</span>   <br><span class="hljs-string">&quot;ey tere gang!&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title="\\"></a><code>\\</code></h3><p><code>\\</code> 是 List 的差集操作, 其会除掉左边 List 中所有存在于右边 List 中的元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [1..10] \\ [2,5,9]   <br>[1,3,4,6,7,8,10]   <br>ghci&gt; <span class="hljs-string">&quot;Im a big baby&quot;</span> \\ <span class="hljs-string">&quot;big&quot;</span>   <br><span class="hljs-string">&quot;Im a baby&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p><code>union</code> 是 List 的并集操作, 返回两个 List 的并集, 其会遍历第二个 List, 若某元素不存在于第一个 List 中, 则追加到第一个 List:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-string">&quot;hey man&quot;</span> `union` <span class="hljs-string">&quot;man what&#x27;s up&quot;</span>   <br><span class="hljs-string">&quot;hey manwt&#x27;sup&quot;</span>   <br>ghci&gt; [1..7] `union` [5..10]   <br>[1,2,3,4,5,6,7,8,9,10]<br></code></pre></td></tr></table></figure>

<h3 id="intersection"><a href="#intersection" class="headerlink" title="intersection"></a>intersection</h3><p><code>intersection</code> 是 List 的交集, 返回两个 List 的相同部分:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [1..7] `intersect` [5..10]   <br>[5,6,7]<br></code></pre></td></tr></table></figure>

<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p><code>insert</code> 将一个元素插入一个可排序的 List, 并将其置于首个大于它的元素之前:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; insert 4 [1,2,3,5,6,7]   <br>[1,2,3,4,5,6,7]   <br>ghci&gt; insert <span class="hljs-string">&#x27;g&#x27;</span> $ [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;f&#x27;</span>] ++ [<span class="hljs-string">&#x27;h&#x27;</span>..<span class="hljs-string">&#x27;z&#x27;</span>]   <br><span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>   <br>ghci&gt; insert 3 [1,2,4,3,2,1]   <br>[1,2,3,4,3,2,1]<br></code></pre></td></tr></table></figure>

<h3 id="xxxBy"><a href="#xxxBy" class="headerlink" title="xxxBy"></a>xxxBy</h3><p><code>xxxBy</code> 这类函数是 <code>sort</code>, <code>insert</code>, <code>delete</code> 等等函数的通用版本, 接受一个函数来进行判断.</p>
<p>这里先介绍 <code>Data.Function</code> 中的 <code>on</code> 函数, 其定义如下:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">on</span> :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c   <br><span class="hljs-title">f</span> `on` g = \x y -&gt; f (g x) (g y)<br></code></pre></td></tr></table></figure>
<ul>
<li>执行 <code>(==) on </code>(&gt; 0)<code>得到的函数等价于</code>\x y -&gt; (x &gt; 0) &#x3D;&#x3D; (y &gt; 0)&#96;</li>
</ul>
<p>比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> xs = [[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>],[],[<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]]   <br><span class="hljs-title">ghci</span>&gt; sortBy (compare `on` length) xs   <br>[[],[<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]]<br></code></pre></td></tr></table></figure>
<ul>
<li>可以读作, 按照长度来比较进行排序</li>
</ul>
<h2 id="Data-Char"><a href="#Data-Char" class="headerlink" title="Data.Char"></a>Data.Char</h2><p><code>Data.Char</code> 包含了一组用于处理字符的函数. 字符串本质是 “字符” 的 List, 因此在 <code>map</code>, <code>filter</code> 函数中经常用到该模块中的函数.</p>
<h3 id="判定字符范围的函数"><a href="#判定字符范围的函数" class="headerlink" title="判定字符范围的函数"></a>判定字符范围的函数</h3><ul>
<li><code>isControl</code> 判断一个字符是否是控制字符。</li>
<li><code>isSpace</code> 判断一个字符是否是空格字符，包括空格，tab，换行符等.</li>
<li><code>isLower</code> 判断一个字符是否为小写.</li>
<li><code>isUper</code> 判断一个字符是否为大写。</li>
<li><code>isAlpha</code> 判断一个字符是否为字母.</li>
<li><code>isAlphaNum</code> 判断一个字符是否为字母或数字.</li>
<li><code>isPrint</code> 判断一个字符是否是可打印的.</li>
<li><code>isDigit</code> 判断一个字符是否为数字.</li>
<li><code>isOctDigit</code> 判断一个字符是否为八进制数字.</li>
<li><code>isHexDigit</code> 判断一个字符是否为十六进制数字.</li>
<li><code>isLetter</code> 判断一个字符是否为字母.</li>
<li><code>isMark</code> 判断是否为unicode注音字符，你如果是法国人就会经常用到的.</li>
<li><code>isNumber</code> 判断一个字符是否为数字.</li>
<li><code>isPunctuation</code> 判断一个字符是否为标点符号.</li>
<li><code>isSymbol</code> 判断一个字符是否为货币符号.</li>
<li><code>isSeperater</code> 判断一个字符是否为unicode空格或分隔符.</li>
<li><code>isAscii</code> 判断一个字符是否在unicode字母表的前128位。</li>
<li><code>isLatin1</code> 判断一个字符是否在unicode字母表的前256位.</li>
<li><code>isAsciiUpper</code> 判断一个字符是否为大写的ascii字符.</li>
<li><code>isAsciiLower</code> 判断一个字符是否为小写的ascii字符.</li>
</ul>
<p>这些函数的类型都是 <code>Char -&gt; Bool</code>.</p>
<h3 id="generalCategory"><a href="#generalCategory" class="headerlink" title="generalCategory"></a>generalCategory</h3><p><code>generalCategory</code> 的类型为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">generalCategory</span> :: <span class="hljs-type">Char</span> -&gt; <span class="hljs-type">GeneralCategory</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>GeneralCategory</code> 是一个枚举类型, 表示字符可能所在的分类</li>
</ul>
<p>示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; generalCategory <span class="hljs-string">&#x27; &#x27;</span>   <br>Space   <br>ghci&gt; generalCategory <span class="hljs-string">&#x27;A&#x27;</span>   <br>UppercaseLetter   <br>ghci&gt; generalCategory <span class="hljs-string">&#x27;a&#x27;</span>   <br>LowercaseLetter   <br>ghci&gt; generalCategory <span class="hljs-string">&#x27;.&#x27;</span>   <br>OtherPunctuation   <br>ghci&gt; generalCategory <span class="hljs-string">&#x27;9&#x27;</span>   <br>DecimalNumber<br></code></pre></td></tr></table></figure>

<p>由于 <code>GeneralCategory</code> 是 <code>Eq</code> 类型类中的类型, 因此可以用 <code>generalCategory c == Space</code> 这样的代码来比较.</p>
<h3 id="符号转换"><a href="#符号转换" class="headerlink" title="符号转换"></a>符号转换</h3><ul>
<li><code>toUpper</code> 将一个字符转为大写字母，若该字符不是小写字母，就按原值返回.</li>
<li><code>toLower</code> 将一个字符转为小写字母，若该字符不是大写字母，就按原值返回.</li>
<li><code>toTitle</code> 将一个字符转为 <code>title-case</code>，对大多数字符而言，<code>title-case</code> 就是大写.</li>
<li><code>digitToInt</code> 将一个字符转为 <code>Int</code> 值，而这一字符必须得在 <code>&#39;1&#39;..&#39;9&#39;,&#39;a&#39;..&#39;f&#39;</code> 或 <code>&#39;A&#39;..&#39;F&#39;</code> 的范围之内.</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; map digitToInt <span class="hljs-string">&quot;34538&quot;</span>   <br>[3,4,5,3,8]   <br>ghci&gt; map digitToInt <span class="hljs-string">&quot;FF85AB&quot;</span>   <br>[15,15,8,5,10,11]<br></code></pre></td></tr></table></figure>

<p><code>intToDigit</code> 取一个 <code>0~15</code> 的 <code>Int</code> 值作为参数, 返回一个小写的字符:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; intToDigit 15   <br><span class="hljs-string">&#x27;f&#x27;</span>   <br>ghci&gt; intToDigit 5   <br><span class="hljs-string">&#x27;5&#x27;</span><br></code></pre></td></tr></table></figure>

<p><code>ord</code> (ordinal) 和 <code>chr</code> (character) 函数可以将字符与对应 unicode 码相互转换:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; ord <span class="hljs-string">&#x27;a&#x27;</span>   <br>97   <br>ghci&gt; chr 97   <br><span class="hljs-string">&#x27;a&#x27;</span>   <br>ghci&gt; map ord <span class="hljs-string">&quot;abcdefgh&quot;</span>   <br>[97,98,99,100,101,102,103,104]<br></code></pre></td></tr></table></figure>

<h2 id="Data-Map"><a href="#Data-Map" class="headerlink" title="Data.Map"></a>Data.Map</h2><p>关联列表 (也叫字典), 是按照键值对排列而没有特定顺序的一种 <code>List</code>. Haskell 中用二元组的 List 来表示关联列表, 第一个元素是键, 第二个元素是值, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">phoneBook</span> = [(<span class="hljs-string">&quot;betty&quot;</span>,<span class="hljs-string">&quot;555-2938&quot;</span>) , <br>             (<span class="hljs-string">&quot;bonnie&quot;</span>,<span class="hljs-string">&quot;452-2928&quot;</span>) , <br>             (<span class="hljs-string">&quot;patsy&quot;</span>,<span class="hljs-string">&quot;493-2928&quot;</span>) , <br>             (<span class="hljs-string">&quot;lucille&quot;</span>,<span class="hljs-string">&quot;205-2928&quot;</span>) , <br>             (<span class="hljs-string">&quot;wendy&quot;</span>,<span class="hljs-string">&quot;939-8282&quot;</span>) , <br>             (<span class="hljs-string">&quot;penny&quot;</span>,<span class="hljs-string">&quot;853-2492&quot;</span>) ]<br></code></pre></td></tr></table></figure>

<p>实现一个通过键来查找值的函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">findKey</span> :: (<span class="hljs-type">Eq</span> k) =&gt; k -&gt; [(k,v)] -&gt; <span class="hljs-type">Maybe</span> v  <br><span class="hljs-title">findKey</span> key = foldr (\(k,v) acc -&gt; <span class="hljs-keyword">if</span> key == k <span class="hljs-keyword">then</span> <span class="hljs-type">Just</span> v <span class="hljs-keyword">else</span> acc) <span class="hljs-type">Nothing</span><br></code></pre></td></tr></table></figure>

<p>这其实就对应 <code>Data.Map</code> 中的 <code>lookup</code> 函数.</p>
<p>由于 <code>Data.Map</code> 与 <code>Prelude</code>, <code>Data.List</code> 中的部分函数有命名冲突, 因此通常这样导入:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.Map <span class="hljs-keyword">as</span> Map<br></code></pre></td></tr></table></figure>

<h3 id="fromList"><a href="#fromList" class="headerlink" title="fromList"></a>fromList</h3><p><code>fromList</code> 取一个关联列表作为参数, 返回一个等价的 <code>map</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Map</span>.fromList [(<span class="hljs-string">&quot;betty&quot;</span>,<span class="hljs-string">&quot;555-2938&quot;</span>),(<span class="hljs-string">&quot;bonnie&quot;</span>,<span class="hljs-string">&quot;452-2928&quot;</span>),(<span class="hljs-string">&quot;lucille&quot;</span>,<span class="hljs-string">&quot;205-2928&quot;</span>)]  <br><span class="hljs-title">fromList</span> [(<span class="hljs-string">&quot;betty&quot;</span>,<span class="hljs-string">&quot;555-2938&quot;</span>),(<span class="hljs-string">&quot;bonnie&quot;</span>,<span class="hljs-string">&quot;452-2928&quot;</span>),(<span class="hljs-string">&quot;lucille&quot;</span>,<span class="hljs-string">&quot;205-2928&quot;</span>)]  <br><span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Map</span>.fromList [(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)]  <br><span class="hljs-title">fromList</span> [(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)]<br></code></pre></td></tr></table></figure>
<ul>
<li>其会忽略重复的键</li>
</ul>
<p><code>fromList</code> 的函数声明如下:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Map</span>.fromList :: (<span class="hljs-type">Ord</span> k) =&gt; [(k，v)] -&gt; <span class="hljs-type">Map</span>.<span class="hljs-type">Map</span> k v<br></code></pre></td></tr></table></figure>
<p><code>Map.Map k v</code> 表示其返回一个将 <code>k</code> 映射为 <code>v</code> 的 <code>map</code>. 这里要求 <code>k</code> 需要时可排序的, 因为其会按照某种顺序组织在一棵树中.</p>
<h3 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h3><p><code>empty</code> 返回一个空 <code>map</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Map.empty  <br>fromList []<br></code></pre></td></tr></table></figure>

<h3 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h3><p><code>insert</code> 取一个键, 一个值和一个 <code>map</code> 作参数, 给该 <code>map</code> 插入新的键值对, 返回一个新的 <code>map</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Map.empty  <br>fromList []  <br>ghci&gt; Map.insert 3 100  <br>Map.empty fromList [(3,100)]  <br>ghci&gt; Map.insert 5 600 (Map.insert 4 200 ( Map.insert 3 100  Map.empty))  <br>fromList [(3,100),(4,200),(5,600)] <br>ghci&gt; Map.insert 5 600 . Map.insert 4 200 . Map.insert 3 100 $ Map.empty  <br>fromList [(3,100),(4,200),(5,600)]<br></code></pre></td></tr></table></figure>

<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p><code>null</code> 检查一个 <code>map</code> 是否为空:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Map.null Map.empty  <br>True  <br>ghci&gt; Map.null $ Map.fromList [(2,3),(5,5)]  <br>False<br></code></pre></td></tr></table></figure>

<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p><code>size</code> 返回一个 <code>map</code> 的大小:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Map.size Map.empty  <br>0  <br>ghci&gt; Map.size $ Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)]  <br>5<br></code></pre></td></tr></table></figure>

<h3 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h3><p><code>singleton</code> 取一个键值对, 返回一个只包含该键值对的 <code>map</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Map.singleton 3 9  <br>fromList [(3,9)]  <br>ghci&gt; Map.insert 5 9 $ Map.singleton 3 9  <br>fromList [(3,9),(5,9)]<br></code></pre></td></tr></table></figure>

<h3 id="lookup"><a href="#lookup" class="headerlink" title="lookup"></a>lookup</h3><p><code>lookup</code> 接受一个键和 <code>map</code>, 如果找到对应的值, 就返回 <code>Just something</code>, 否则返回 <code>Nothing</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">let</span> scores = Map.fromList [(<span class="hljs-string">&quot;math&quot;</span>, 98), (<span class="hljs-string">&quot;chinese&quot;</span>, 60), (<span class="hljs-string">&quot;english&quot;</span>, 93)]<br>ghci&gt; Map.lookup <span class="hljs-string">&quot;math&quot;</span> scores<br>Just 98<br>ghci&gt; Map.lookup <span class="hljs-string">&quot;physics&quot;</span> scores<br>Nothing<br></code></pre></td></tr></table></figure>

<h3 id="member"><a href="#member" class="headerlink" title="member"></a>member</h3><p><code>member</code> 接受一个键与 <code>map</code>, 判断该键是否存在于该 <code>map</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Map.member 3 $ Map.fromList [(3,6),(4,3),(6,9)]  <br>True  <br>ghci&gt; Map.member 3 $ Map.fromList [(2,5),(4,5)]  <br>False<br></code></pre></td></tr></table></figure>

<h3 id="map-和-filter-1"><a href="#map-和-filter-1" class="headerlink" title="map 和 filter"></a>map 和 filter</h3><p>与 <code>List</code> 的版本类似:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Map.map (*100) $ Map.fromList [(1,1),(2,4),(3,9)]  <br>fromList [(1,100),(2,400),(3,900)]  <br>ghci&gt; Map.filter isUpper $ Map.fromList [(1,<span class="hljs-string">&#x27;a&#x27;</span>),(2,<span class="hljs-string">&#x27;A&#x27;</span>),(3,<span class="hljs-string">&#x27;b&#x27;</span>),(4,<span class="hljs-string">&#x27;B&#x27;</span>)]  <br>fromList [(2,<span class="hljs-string">&#x27;A&#x27;</span>),(4,<span class="hljs-string">&#x27;B&#x27;</span>)]<br></code></pre></td></tr></table></figure>

<h3 id="toList"><a href="#toList" class="headerlink" title="toList"></a>toList</h3><p><code>toList</code> 是 <code>fromList</code> 的反函数, 从 <code>map</code> 返回一个 <code>List</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Map.toList . Map.insert 9 2 $ Map.singleton 4 3  <br>[(4,3),(9,2)]<br></code></pre></td></tr></table></figure>

<h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><p><code>keys</code> 返回键组成的 <code>List</code>, 等价于 <code>map fst . Map.toList</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">let</span> scores = Map.fromList [(<span class="hljs-string">&quot;math&quot;</span>, 98), (<span class="hljs-string">&quot;chinese&quot;</span>, 60), (<span class="hljs-string">&quot;english&quot;</span>, 93)]<br>ghci&gt; Map.keys scores<br>[<span class="hljs-string">&quot;chinese&quot;</span>,<span class="hljs-string">&quot;english&quot;</span>,<span class="hljs-string">&quot;math&quot;</span>]<br></code></pre></td></tr></table></figure>

<h3 id="elems"><a href="#elems" class="headerlink" title="elems"></a>elems</h3><p><code>elems</code> 返回值组成的 <code>List</code>, 等价于 <code>map snd . toList</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">let</span> scores = Map.fromList [(<span class="hljs-string">&quot;math&quot;</span>, 98), (<span class="hljs-string">&quot;chinese&quot;</span>, 60), (<span class="hljs-string">&quot;english&quot;</span>, 93)]<br>ghci&gt; Map.elems scores<br>[60,93,98]<br></code></pre></td></tr></table></figure>

<h3 id="fromListWith"><a href="#fromListWith" class="headerlink" title="fromListWith"></a>fromListWith</h3><p><code>fromListWith</code> 和 <code>fromList</code> 类似, 但其把重复键交给一个函数来处理:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">phoneBookToMap :: (Ord k) =&gt; [(k，a)] -&gt; Map.Map k [a]  <br>phoneBookToMap xs = Map.fromListWith (++) $ map (\(k,v) -&gt; (k,[v])) xs  <br>ghci&gt; Map.lookup <span class="hljs-string">&quot;patsy&quot;</span> $ phoneBookToMap phoneBook  <br>[<span class="hljs-string">&quot;827-9162&quot;</span>,<span class="hljs-string">&quot;943-2929&quot;</span>,<span class="hljs-string">&quot;493-2928&quot;</span>]<br></code></pre></td></tr></table></figure>

<p>有比如, 遇到相同键时, 只取值最大的一个:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Map.fromListWith max [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]  <br>fromList [(2,100),(3,29),(4,22)]<br></code></pre></td></tr></table></figure>

<p>遇到相同的键时, 将值加起来:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Map.fromListWith (+) [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]  <br>fromList [(2,108),(3,62),(4,37)]<br></code></pre></td></tr></table></figure>

<h3 id="insertWith"><a href="#insertWith" class="headerlink" title="insertWith"></a>insertWith</h3><p><code>insertWith</code> 与 <code>insert</code> 类似, 当插入一个已存在的键时, 用一个函数处理:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Map.insertWith (+) 3 100 $ Map.fromList [(3,4),(5,103),(6,339)]  <br>fromList [(3,104),(5,103),(6,339)]<br></code></pre></td></tr></table></figure>

<h2 id="Data-Set"><a href="#Data-Set" class="headerlink" title="Data.Set"></a>Data.Set</h2><p><code>Data.Set</code> 提供了对数学中的集合的处理. 集合既像 <code>List</code> 也像 <code>Map</code>, 但其每个元素都是唯一的, 且内部的数据由一棵树来组织, 元素必须得是可排序的.</p>
<p>对于插入, 删除, 判断从属关系之类的操作, <code>set</code> 会比 <code>List</code> 快很多.</p>
<p>由于 <code>Data.Set</code> 与 <code>Prelude</code> 和 <code>Data.List</code> 模块也存在大量的命名冲突, 因此用下面方式导入:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.Set <span class="hljs-keyword">as</span> Set<br></code></pre></td></tr></table></figure>

<h3 id="fromList-1"><a href="#fromList-1" class="headerlink" title="fromList"></a>fromList</h3><p>同 <code>Data.Map</code> 中的 <code>fromList</code>, 取一个 List 作参数并将其转为一个 <code>set</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">text1 = <span class="hljs-string">&quot;I just had an anime dream. Anime... Reality... Are they so different?&quot;</span>  <br>text2 = <span class="hljs-string">&quot;The old man left his garbage can out and now his trash is all over my lawn!&quot;</span><br>ghci&gt; <span class="hljs-built_in">let</span> set1 = Set.fromList text1  <br>ghci&gt; <span class="hljs-built_in">let</span> set2 = Set.fromList text2  <br>ghci&gt; set1  <br>fromList <span class="hljs-string">&quot; .?AIRadefhijlmnorstuy&quot;</span>  <br>ghci&gt; set2  <br>fromList <span class="hljs-string">&quot; !Tabcdefghilmnorstuvwy&quot;</span><br></code></pre></td></tr></table></figure>

<p>可以看到 <code>set</code> 中所有元素是排了序的, 且每个元素唯一.</p>
<h3 id="intersection-1"><a href="#intersection-1" class="headerlink" title="intersection"></a>intersection</h3><p><code>intersection</code> 函数取两个 <code>Set</code> 的交集:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Set.intersection set1 set2  <br>fromList <span class="hljs-string">&quot; adefhilmnorstuy&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="difference"><a href="#difference" class="headerlink" title="difference"></a>difference</h3><p><code>difference</code> 取差集, 得到存在于第一个集合但是不在第二个集合的元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Set.difference set1 set2  <br>fromList <span class="hljs-string">&quot;.?AIRj&quot;</span>  <br>ghci&gt; Set.difference set2 set1  <br>fromList <span class="hljs-string">&quot;!Tbcgvw&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="union-1"><a href="#union-1" class="headerlink" title="union"></a>union</h3><p><code>union</code> 取两个 set 的并集:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Set.union set1 set2  <br>fromList <span class="hljs-string">&quot; !.?AIRTabcdefghijlmnorstuvwy&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="empty-1"><a href="#empty-1" class="headerlink" title="empty"></a>empty</h3><p><code>empty</code> 返回一个空的 <code>set</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Set.empty<br>fromList []<br></code></pre></td></tr></table></figure>

<h3 id="null-1"><a href="#null-1" class="headerlink" title="null"></a>null</h3><p><code>null</code> 判断 <code>set</code> 是否为空:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Set.null Set.empty<br>True<br></code></pre></td></tr></table></figure>

<h3 id="size-1"><a href="#size-1" class="headerlink" title="size"></a>size</h3><p><code>size</code> 返回 <code>set</code> 的大小:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Set.size Set.empty<br>0<br></code></pre></td></tr></table></figure>

<h3 id="singleton-1"><a href="#singleton-1" class="headerlink" title="singleton"></a>singleton</h3><p><code>singleton</code> 接受一个参数, 返回一个只包含该元素的 <code>Set</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Set.singleton 9<br>fromList 9<br></code></pre></td></tr></table></figure>

<h3 id="insert-2"><a href="#insert-2" class="headerlink" title="insert"></a>insert</h3><p><code>insert</code> 取一个值和 <code>Set</code>, 返回插入新值后的 <code>Set</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Set.insert 4 $ Set.fromList [9,3,8,1]  <br>fromList [1,3,4,8,9]<br></code></pre></td></tr></table></figure>

<h3 id="delete-1"><a href="#delete-1" class="headerlink" title="delete"></a>delete</h3><p><code>delete</code> 取一个值和 <code>Set</code>, 返回删除该值后的 <code>Set</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Set.delete 4 $ Set.fromList [3,4,5,4,3,4,5]  <br>fromList [3,5]<br></code></pre></td></tr></table></figure>

<h3 id="子集和真子集判断"><a href="#子集和真子集判断" class="headerlink" title="子集和真子集判断"></a>子集和真子集判断</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Set.fromList [2,3,4] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]  <br>True  <br>ghci&gt; Set.fromList [1,2,3,4,5] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]  <br>True  <br>ghci&gt; Set.fromList [1,2,3,4,5] `Set.isProperSubsetOf` Set.fromList [1,2,3,4,5]  <br>False  <br>ghci&gt; Set.fromList [2,3,4,8] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]  <br>False<br></code></pre></td></tr></table></figure>

<h3 id="map-和-filter-2"><a href="#map-和-filter-2" class="headerlink" title="map 和 filter"></a>map 和 filter</h3><p>类似 <code>List</code> 和 <code>Map</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Set.filter odd $ Set.fromList [3,4,5,6,7,2,3,4]  <br>fromList [3,5,7]  <br>ghci&gt; Set.map (+1) $ Set.fromList [3,4,5,6,7,2,3,4]  <br>fromList [3,4,5,6,7,8]<br></code></pre></td></tr></table></figure>

<h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><p>比如创建一个计算几何图形体积和面积组成的模块, 新建一个 <code>Geometry.hs</code> 文件, 模块名需要与文件名一致, 在声明处要列出包含的函数名:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">module</span> Geometry  <br>( <span class="hljs-title">sphereVolume</span>  <br>, <span class="hljs-title">sphereArea</span>  <br>, <span class="hljs-title">cubeVolume</span>  <br>, <span class="hljs-title">cubeArea</span>  <br>, <span class="hljs-title">cuboidArea</span>  <br>, <span class="hljs-title">cuboidVolume</span>  <br><span class="hljs-title">i</span>) <span class="hljs-keyword">where</span><br></code></pre></td></tr></table></figure>

<p>在后续包含各函数的函数体:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">module</span> Geometry  <br>( <span class="hljs-title">sphereVolume</span>  <br>, <span class="hljs-title">sphereArea</span>  <br>, <span class="hljs-title">cubeVolume</span>  <br>, <span class="hljs-title">cubeArea</span>  <br>, <span class="hljs-title">cuboidArea</span>  <br>, <span class="hljs-title">cuboidVolume</span>  <br>) <span class="hljs-keyword">where</span>  <br><br><span class="hljs-title">sphereVolume</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">sphereVolume</span> radius = (<span class="hljs-number">4.0</span> / <span class="hljs-number">3.0</span>) * pi * (radius ^ <span class="hljs-number">3</span>)  <br><br><span class="hljs-title">sphereArea</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">sphereArea</span> radius = <span class="hljs-number">4</span> * pi * (radius ^ <span class="hljs-number">2</span>)  <br><br><span class="hljs-title">cubeVolume</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">cubeVolume</span> side = cuboidVolume side side side  <br><br><span class="hljs-title">cubeArea</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">cubeArea</span> side = cuboidArea side side side  <br><br><span class="hljs-title">cuboidVolume</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">cuboidVolume</span> a b c = rectangleArea a b * c  <br><br><span class="hljs-title">cuboidArea</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">cuboidArea</span> a b c = rectangleArea a b * <span class="hljs-number">2</span> + rectangleArea a c * <span class="hljs-number">2</span> + rectangleArea c b * <span class="hljs-number">2</span>  <br><br><span class="hljs-title">rectangleArea</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">rectangleArea</span> a b = a * b<br></code></pre></td></tr></table></figure>

<h3 id="分层组织"><a href="#分层组织" class="headerlink" title="分层组织"></a>分层组织</h3><p>假如要把 <code>Geometry</code> 分成三个子模块, 每个模块对应各自的图形对象. 先建立一个 <code>Geometry</code> 文件夹, 注意首字母大写, 然后在里面新建三个文件:</p>
<ul>
<li><p><code>Sphere.hs</code> 文件:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">module</span> Geometry.Sphere  <br>( <span class="hljs-title">volume</span>  <br>, <span class="hljs-title">area</span>  <br>) <span class="hljs-keyword">where</span>  <br><br><span class="hljs-title">volume</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">volume</span> radius = (<span class="hljs-number">4.0</span> / <span class="hljs-number">3.0</span>) * pi * (radius ^ <span class="hljs-number">3</span>)  <br><br><span class="hljs-title">area</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">area</span> radius = <span class="hljs-number">4</span> * pi * (radius ^ <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>Cuboid.hs</code> 文件:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">module</span> Geometry.Cuboid  <br>( <span class="hljs-title">volume</span>  <br>, <span class="hljs-title">area</span>  <br>) <span class="hljs-keyword">where</span>  <br><br><span class="hljs-title">volume</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">volume</span> a b c = rectangleArea a b * c  <br><br><span class="hljs-title">area</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">area</span> a b c = rectangleArea a b * <span class="hljs-number">2</span> + rectangleArea a c * <span class="hljs-number">2</span> + rectangleArea c b * <span class="hljs-number">2</span>  <br><br><span class="hljs-title">rectangleArea</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">rectangleArea</span> a b = a * b<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>Cube.hs</code> 文件:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">module</span> Geometry.Cube  <br>( <span class="hljs-title">volume</span>  <br>, <span class="hljs-title">area</span>  <br>) <span class="hljs-keyword">where</span>  <br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Geometry.Cuboid <span class="hljs-keyword">as</span> Cuboid  <br><br><span class="hljs-title">volume</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">volume</span> side = <span class="hljs-type">Cuboid</span>.volume side side side  <br><br><span class="hljs-title">area</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>  <br><span class="hljs-title">area</span> side = <span class="hljs-type">Cuboid</span>.area side side side<br></code></pre></td></tr></table></figure></li>
</ul>
<p>导入示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Geometry.Sphere <span class="hljs-keyword">as</span> Sphere  <br><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Geometry.Cuboid <span class="hljs-keyword">as</span> Cuboid  <br><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Geometry.Cube <span class="hljs-keyword">as</span> Cube<br></code></pre></td></tr></table></figure>

<h1 id="构造类型和类型类"><a href="#构造类型和类型类" class="headerlink" title="构造类型和类型类"></a>构造类型和类型类</h1><h2 id="Algebraic-Data-Types-入门"><a href="#Algebraic-Data-Types-入门" class="headerlink" title="Algebraic Data Types 入门"></a>Algebraic Data Types 入门</h2><p>可以用 <code>data</code> 关键字来构造自己的类型, 比如 <code>Bool</code> 在标准库中的定义:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Bool</span> = <span class="hljs-type">False</span> | <span class="hljs-type">True</span></span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>=</code> 左边是类型的名称</li>
<li><code>=</code> 右边是 Value Constructor (值构造子), 其明确了该类型的可能值</li>
<li><code>|</code> 读作 ”或</li>
<li>类型名和 Value Constructor 的首字母必大写</li>
</ul>
<p>假设我们要定义一个 <code>Shape</code> 类型来表示图形, 图形可以是 <code>Circle</code> 或 <code>Rectangle</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Shape</span> = <span class="hljs-type">Circle</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> | <span class="hljs-type">Rectangle</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span></span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>Circle</code> 是构造子, <code>Float Float Float</code> 是它包含的项, 这里前两项表示圆心的坐标, 尾项表示半径</li>
<li><code>Rectangle</code> 也是构造子, <code>Float Float Float Float</code> 是它包含的项, 前两项表示左上角坐标, 后两项表示右上角坐标</li>
</ul>
<p>构造子本质上是一个函数, 因此 “构造子的项” 其实是函数的参数. “对应类型的值” 就是该函数的返回值.</p>
<p>因此查看 <code>Circle</code> 和 <code>Rectangle</code> 的类型:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t Circle   <br>Circle :: Float -&gt; Float -&gt; Float -&gt; Shape   <br>ghci&gt; :t Rectangle   <br>Rectangle :: Float -&gt; Float -&gt; Float -&gt; Float -&gt; Shape<br></code></pre></td></tr></table></figure>

<p>假设写一个函数来计算图形的面积:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">surface</span> :: <span class="hljs-type">Shape</span> -&gt; <span class="hljs-type">Float</span><br><span class="hljs-title">surface</span> (<span class="hljs-type">Circle</span> _ _ r) = pi * r ^ <span class="hljs-number">2</span><br><span class="hljs-title">surface</span> (<span class="hljs-type">Rectangle</span> x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)<br></code></pre></td></tr></table></figure>
<ul>
<li>注意该函数的类型不能写为 <code>Circle -&gt; Float</code> 或 <code>Rectangle -&gt; Float</code>, 因为 <code>Circle</code> 和 <code>Rectangle</code> 都是构造子 (函数), 而不是类型</li>
</ul>
<p>若要将 <code>Shape</code> 类型输出到控制台, 需要让其成为 <code>Show</code> 类型类的成员, 这样写:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Shape</span> = <span class="hljs-type">Circle</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> | <span class="hljs-type">Rectangle</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>deriving (Show)</code> 会让 Haskell 自动将该类型至于 <code>Show</code> 类型类中</li>
</ul>
<p>由于 <code>Circle</code> 和 <code>Rectangle</code> 就是函数, 因此可以交给 <code>map</code> 等处理:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">ghci</span>&gt; map (<span class="hljs-type">Circle</span> <span class="hljs-number">10</span> <span class="hljs-number">20</span>) [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>]   <br>[<span class="hljs-type">Circle</span> <span class="hljs-number">10.0</span> <span class="hljs-number">20.0</span> <span class="hljs-number">4.0</span>,<span class="hljs-type">Circle</span> <span class="hljs-number">10.0</span> <span class="hljs-number">20.0</span> <span class="hljs-number">5.0</span>,<span class="hljs-type">Circle</span> <span class="hljs-number">10.0</span> <span class="hljs-number">20.0</span> <span class="hljs-number">6.0</span>,<span class="hljs-type">Circle</span> <span class="hljs-number">10.0</span> <span class="hljs-number">20.0</span> <span class="hljs-number">6.0</span>]<br></code></pre></td></tr></table></figure>

<p>增加一个表示二维空间中点的类型:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Point</span> = <span class="hljs-type">Point</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Shape</span> = <span class="hljs-type">Circle</span> <span class="hljs-type">Point</span> <span class="hljs-type">Float</span> | <span class="hljs-type">Rectangle</span> <span class="hljs-type">Point</span> <span class="hljs-type">Point</span> <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)</span><br></code></pre></td></tr></table></figure>
<ul>
<li>注意这里的 <code>Point</code> 类型与其构造子同名, 这没有什么特别含义, 这种命名方式也很常见</li>
</ul>
<p>使用示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">surface</span> :: <span class="hljs-type">Shape</span> -&gt; <span class="hljs-type">Float</span>   <br><span class="hljs-title">surface</span> (<span class="hljs-type">Circle</span> _ r) = pi * r ^ <span class="hljs-number">2</span>   <br><span class="hljs-title">surface</span> (<span class="hljs-type">Rectangle</span> (<span class="hljs-type">Point</span> x1 y1) (<span class="hljs-type">Point</span> x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)<br></code></pre></td></tr></table></figure>

<p>在模块中导出类型可以这样写:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">module</span> Shapes<br>( <span class="hljs-type">Point(..)</span><br>, <span class="hljs-type">Shape(..)</span><br>, <span class="hljs-title">surface</span> <br><span class="hljs-title">i</span>) <span class="hljs-keyword">where</span><br></code></pre></td></tr></table></figure>
<ul>
<li>在类型后加上括号, 里面写上要导出的构造子, 并用 <code>,</code> 分隔. 如果要导出所有构造子, 则写 <code>..</code></li>
</ul>
<h2 id="Record-Syntax"><a href="#Record-Syntax" class="headerlink" title="Record Syntax"></a>Record Syntax</h2><p><code>Record Syntax</code> 是另一种类型的定义语法, 语义更加清晰, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Person</span> = <span class="hljs-type">Person</span> &#123; <span class="hljs-title">firstName</span> :: <span class="hljs-type">String</span>   </span><br><span class="hljs-class">                     , <span class="hljs-title">lastName</span> :: <span class="hljs-type">String</span>   </span><br><span class="hljs-class">                     , <span class="hljs-title">age</span> :: <span class="hljs-type">Int</span>   </span><br><span class="hljs-class">                     , <span class="hljs-title">height</span> :: <span class="hljs-type">Float</span>   </span><br><span class="hljs-class">                     , <span class="hljs-title">phoneNumber</span> :: <span class="hljs-type">String</span>   </span><br><span class="hljs-class">                     , <span class="hljs-title">flavor</span> :: <span class="hljs-type">String</span>   </span><br><span class="hljs-class">                     &#125; <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>=</code> 右边的 <code>Person</code> 同样是 Value Constructor</li>
<li>用 <code>&#123;&#125;</code> 包裹的是 <code>Person</code> 的参数, 比如 <code>firstName :: String</code>, 需要标明字段名和类型</li>
</ul>
<p>用 Record Syntax 定义后, Haskell 会自动生成这些函数: <code>firstName</code>, <code>lastName</code>, <code>age</code>, <code>height</code>, <code>phoneNumber</code> 和 <code>flavor</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t flavor   <br>flavor :: Person -&gt; String   <br>ghci&gt; :t firstName   <br>firstName :: Person -&gt; String<br></code></pre></td></tr></table></figure>

<p>另一个示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Car</span> = <span class="hljs-type">Car</span> &#123;<span class="hljs-title">company</span> :: <span class="hljs-type">String</span>, <span class="hljs-title">model</span> :: <span class="hljs-type">String</span>, <span class="hljs-title">year</span> :: <span class="hljs-type">Int</span>&#125; <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Car &#123;company=<span class="hljs-string">&quot;Ford&quot;</span>, model=<span class="hljs-string">&quot;Mustang&quot;</span>, year=1967&#125;   <br>Car &#123;company = <span class="hljs-string">&quot;Ford&quot;</span>, model = <span class="hljs-string">&quot;Mustang&quot;</span>, year = 1967&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>各项不需要关注顺序</li>
</ul>
<h2 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h2><p>比如前面 Value Constructor, 取几个参数返回一个新值, 比如 <code>Car</code> 的构造子是取三个参数返回一个 <code>Car</code>.</p>
<p>与之类似, 类型构造子可以取类型作为参数, 产生新类型. 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Maybe</span> a = <span class="hljs-type">Nothing</span> | <span class="hljs-type">Just</span> a</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这里的 <code>a</code> 就是类型参数</li>
<li><code>Maybe</code> 是类型构造子 (这个需要注意, <code>Maybe</code> 不是类型)</li>
<li><code>Maybe Char</code>, <code>Maybe Int</code> 这些才是类型</li>
<li><code>Nothing</code> 和 <code>Just a</code> 是值构造子</li>
</ul>
<p>如果拿 <code>Char</code> 作为参数交给 <code>Maybe</code>, 则可以得到一个 <code>Maybe Char</code> 类型. 如 <code>Just &#39;a&#39;</code> 的类型就是 <code>Maybe Char</code>.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Just <span class="hljs-string">&quot;Haha&quot;</span>   <br>Just <span class="hljs-string">&quot;Haha&quot;</span>   <br>ghci&gt; Just 84   <br>Just 84   <br>ghci&gt; :t Just <span class="hljs-string">&quot;Haha&quot;</span>   <br>Just <span class="hljs-string">&quot;Haha&quot;</span> :: Maybe [Char]   <br>ghci&gt; :t Just 84   <br>Just 84 :: (Num t) =&gt; Maybe t   <br>ghci&gt; :t Nothing   <br>Nothing :: Maybe a<br></code></pre></td></tr></table></figure>

<p>需要注意 <code>Nothing</code> 的类型是 <code>Maybe a</code>. 比如一个函数接受 <code>Maybe Int</code> 类型的参数, 那么传递给它 <code>Nothing</code> 也是可以的.</p>
<p>空 <code>List</code> 的类型是 <code>[a]</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t []<br>[] :: [a]<br></code></pre></td></tr></table></figure>

<p>因此可以有: <code>[1,2,3]++[]</code>, <code>[&quot;ha&quot;,&quot;ha&quot;,&quot;ha&quot;]++[]</code> 等等用法.</p>
<p>通常仅在一个类型中包含的类型并不影响它的行为时才引入类型参数.</p>
<h2 id="派生实例"><a href="#派生实例" class="headerlink" title="派生实例"></a>派生实例</h2><p>类型派生之前见过了, 通过 <code>deriving (typeclass)</code> 的语法, 自动为类型加上 “类型类” 描述的行为, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Person</span> = <span class="hljs-type">Person</span> &#123; <span class="hljs-title">firstName</span> :: <span class="hljs-type">String</span>   </span><br><span class="hljs-class">                     , <span class="hljs-title">lastName</span> :: <span class="hljs-type">String</span>   </span><br><span class="hljs-class">                     , <span class="hljs-title">age</span> :: <span class="hljs-type">Int</span>   </span><br><span class="hljs-class">                     &#125; <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Eq</span>)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>这样就能比较两个 <code>Person</code> 类型了</li>
</ul>
<p>让其属于多个类型类:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Person</span> = <span class="hljs-type">Person</span> &#123; <span class="hljs-title">firstName</span> :: <span class="hljs-type">String</span>   </span><br><span class="hljs-class">                     , <span class="hljs-title">lastName</span> :: <span class="hljs-type">String</span>   </span><br><span class="hljs-class">                     , <span class="hljs-title">age</span> :: <span class="hljs-type">Int</span>   </span><br><span class="hljs-class">                     &#125; <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Eq</span>, <span class="hljs-type">Show</span>, <span class="hljs-type">Read</span>)</span><br></code></pre></td></tr></table></figure>

<p>派生 <code>Ord</code> 类型类的实例可以让其能够进行比较, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Day</span> = <span class="hljs-type">Monday</span> | <span class="hljs-type">Tuesday</span> | <span class="hljs-type">Wednesday</span> | <span class="hljs-type">Thursday</span> | <span class="hljs-type">Friday</span> | <span class="hljs-type">Saturday</span> | <span class="hljs-type">Sunday</span> <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Eq</span>, <span class="hljs-type">Ord</span>, <span class="hljs-type">Show</span>, <span class="hljs-type">Read</span>, <span class="hljs-type">Bounded</span>, <span class="hljs-type">Enum</span>)</span><br></code></pre></td></tr></table></figure>

<p>相关操作:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Wednesday   <br>Wednesday   <br>ghci&gt; show Wednesday   <br><span class="hljs-string">&quot;Wednesday&quot;</span>   <br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;Saturday&quot;</span> :: Day   <br>Saturday<br>ghci&gt; Saturday == Sunday   <br>False   <br>ghci&gt; Saturday == Saturday   <br>True   <br>ghci&gt; Saturday &gt; Friday   <br>True   <br>ghci&gt; Monday `compare` Wednesday   <br>LT<br>ghci&gt; minBound :: Day   <br>Monday   <br>ghci&gt; maxBound :: Day   <br>Sunday<br>ghci&gt; succ Monday   <br>Tuesday   <br>ghci&gt; pred Saturday   <br>Friday   <br>ghci&gt; [Thursday .. Sunday]   <br>[Thursday,Friday,Saturday,Sunday]   <br>ghci&gt; [minBound .. maxBound] :: [Day]   <br>[Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]<br></code></pre></td></tr></table></figure>

<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>比如 <code>[Char]</code> 与 <code>String</code> 类型就是等价的, 这是由 “类型别名” 实现的, 需要用 <code>type</code> 关键字:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">String</span> = [<span class="hljs-type">Char</span>]</span><br></code></pre></td></tr></table></figure>

<p>使用类型别名通常只是为了让类型声明更易读.</p>
<p>类型别名也可以是有参数的, 如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">AssocList</span> k v = [(<span class="hljs-title">k</span>,<span class="hljs-title">v</span>)]</span><br></code></pre></td></tr></table></figure>

<p>此时, 如果要声明一个从关联 List 中按键取值的函数, 其类型可以定义为: <code>(Eq k) =&gt; k -&gt; AssocList k v -&gt; Maybe v</code></p>
<p>可以通过不全的类型参数来调用类型构造子, 得到一个 “不全调用的类型构造子”, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">IntMap</span> v = <span class="hljs-type">Map</span> <span class="hljs-type">Int</span> v</span><br></code></pre></td></tr></table></figure>

<p>可以写为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">IntMap</span> = <span class="hljs-type">Map</span> <span class="hljs-type">Int</span></span><br></code></pre></td></tr></table></figure>

<h2 id="Recursive-data-structures"><a href="#Recursive-data-structures" class="headerlink" title="Recursive data structures"></a>Recursive data structures</h2><p>比如一个 <code>List</code> 的定义是: 要么是空的 <code>List</code>, 要么是一个元素后面用 <code>:</code> 连接了另一个 <code>List</code>.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">List</span> a = <span class="hljs-type">Empty</span> | <span class="hljs-type">Cons</span> a (<span class="hljs-type">List</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>, <span class="hljs-type">Read</span>, <span class="hljs-type">Eq</span>, <span class="hljs-type">Ord</span>)</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>Cons</code> 这个 value constructor 就指代 <code>:</code>, 其接受一个值和另一个 <code>List</code> 来构造一个 <code>List</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Empty<br>Empty<br>ghci&gt; 5 `Cons` Empty<br>Cons 5 Empty<br>ghci&gt; 4 `Cons` (5 `Cons` Empty)<br>Cons 4 (Cons 5 Empty)<br>ghci&gt; 3 `Cons` (4 `Cons` (5 `Cons` Empty))<br>Cons 3 (Cons 4 (Cons 5 Empty))<br></code></pre></td></tr></table></figure>

<h3 id="特殊字符函数"><a href="#特殊字符函数" class="headerlink" title="特殊字符函数"></a>特殊字符函数</h3><p>可以将一个特殊字符定义为一个函数, 它们会自动具有中缀的性质, 比如对于乘法符号 <code>*</code>, 其声明为 <code>infixl 7 *</code>:</p>
<ul>
<li><code>infixl</code> (infix left, 中缀左结合) 是关键字, 表示一个 <code>fixity</code> (结合性&#x2F;优先级) 声明</li>
<li><code>7</code> 是优先等级, 越大越高, 是一个 <code>0~9</code> 的整数</li>
<li><code>*</code> 是指定的符号, 不能是字母组成的普通函数名</li>
</ul>
<p>定义一个独立的字符中缀函数, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">infixr</span> <span class="hljs-number">5</span>  ++<br>(++) :: [a] -&gt; [a] -&gt; [a]<br>[]     ++ ys = ys<br>(x:xs) ++ ys = x : (xs ++ ys)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>infixr</code> 指 <code>infix right</code></li>
</ul>
<p>假如只让这个中缀函数作为 value construct, 示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">infixr</span> <span class="hljs-number">5</span> :-:<br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">List</span> a = <span class="hljs-type">Empty</span> | a :-: (<span class="hljs-type">List</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>, <span class="hljs-type">Read</span>, <span class="hljs-type">Eq</span>, <span class="hljs-type">Ord</span>)</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这里的 <code>infixr</code> 声明是 <code>data</code> 类型声明的一部分</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; 3 :-: 4 :-: 5 :-: Empty<br>(:-:) 3 ((:-:) 4 ((:-:) 5 Empty))<br>ghci&gt; <span class="hljs-built_in">let</span> a = 3 :-: 4 :-: 5 :-: Empty<br>ghci&gt; 100 :-: a<br>(:-:) 100 ((:-:) 3 ((:-:) 4 ((:-:) 5 Empty)))<br></code></pre></td></tr></table></figure>

<h3 id="构造子与模式匹配的关系"><a href="#构造子与模式匹配的关系" class="headerlink" title="构造子与模式匹配的关系"></a>构造子与模式匹配的关系</h3><p>在 Haskell 中:</p>
<ul>
<li>Constructor (构造子) 用来创建数据</li>
<li>Pattern matching (模式匹配) 用来解构数据</li>
</ul>
<p>模式匹配的本质就是通过 “解构” value constructor 来提取内部字段. 可以说没有构造子就没有模式匹配.</p>
<p>通常可以这样理解, 构造子函数用于将数据打包并带上标签, 模式匹配用于识别标签并提取数据.</p>
<p>先说说 “构造子本质是一个函数”, 考虑下面定义:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Maybe</span> a = <span class="hljs-type">Nothing</span> | <span class="hljs-type">Just</span> a</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>Nothong</code> 是一个不带参数的函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Nothing</span> :: <span class="hljs-type">Maybe</span> a<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>Just</code> 是一个含一个参数的函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Just</span> :: a -&gt; <span class="hljs-type">Maybe</span> a<br></code></pre></td></tr></table></figure></li>
</ul>
<p>可以直接像函数一样调用:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">x</span> = <span class="hljs-type">Just</span> <span class="hljs-number">42</span><br><span class="hljs-title">y</span> = <span class="hljs-type">Nothong</span><br></code></pre></td></tr></table></figure>
<p>这里相当于, Haskell 在内部创建了一个带有标签的 <code>Just</code> 和 <code>payload x</code> 的对象, 假设是下面这样表示 (实际上不是, 这里便于理解):</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-name">Tag:</span> Just, Payload: (<span class="hljs-name">42</span>)]<br>[<span class="hljs-name">Tag:</span> Nothing]<br></code></pre></td></tr></table></figure>
<ul>
<li><code>Tag</code> 是构造子的标识, 用于模式匹配的分支选择</li>
<li><code>Payload</code> 是构造子携带的数据</li>
</ul>
<p>而模式匹配如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">f</span> :: <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">f</span> <span class="hljs-type">Nothing</span>  = <span class="hljs-string">&quot;no value&quot;</span><br><span class="hljs-title">f</span> (<span class="hljs-type">Just</span> x) = <span class="hljs-string">&quot;value is &quot;</span> ++ show x<br></code></pre></td></tr></table></figure>

<p>可以理解为:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">switch</span> (value.tag) &#123;<br>  <span class="hljs-keyword">case</span> NOTHING: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;no value&quot;</span>;<br>  <span class="hljs-keyword">case</span> JUST:    x = value.payload[<span class="hljs-number">0</span>]; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;value is &quot;</span> + <span class="hljs-keyword">show</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="二元搜索树示例"><a href="#二元搜索树示例" class="headerlink" title="二元搜索树示例"></a>二元搜索树示例</h3><p>二元搜索树 (Binary search tree) 的结构是:</p>
<ul>
<li>每个节点指向两个子节点, 一个位于左侧, 一个位于右侧</li>
<li>左侧子节点的元素比该节点的值小</li>
<li>右侧子节点的元素比该节点的值大</li>
</ul>
<p>比如一个节点包含值 <code>5</code>, 那么其左子树的所有元素都会小于 <code>5</code>, 右子树的所有元素都会大于 <code>5</code>.</p>
<p>进行搜索时, 从节点值为 <code>5</code> 的开始, 查找值为 <code>8</code> 的位置:</p>
<ul>
<li>由于 <code>8 &gt; 5</code>, 则往右边搜索, 假如下个节点的值是 <code>7</code></li>
<li>由于 <code>8 &gt; 7</code>, 继续往右边搜索并找到对应的节点</li>
</ul>
<p>如果不是这棵树而是一个 <code>List</code>, 则需要进行顺序查找.</p>
<p><code>Data.Set</code> 和 <code>Data.Map</code> 中的 <code>Set</code> 和 <code>Map</code> 都是用树来实现的, 只不过使用的是平衡二元搜索树而不是随意的二元搜索树.</p>
<p>这里用一个普通的二元搜索树做例子, 先定义其结构: 如果不是空树就是带有值并含有两棵子树.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Tree</span> a = <span class="hljs-type">EmptyTree</span> | <span class="hljs-type">Node</span> a (<span class="hljs-type">Tree</span> <span class="hljs-title">a</span>) (<span class="hljs-type">Tree</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>, <span class="hljs-type">Read</span>, <span class="hljs-type">Eq</span>)</span><br></code></pre></td></tr></table></figure>

<p>先实现一个插入的函数: 函数接受两个参数, 一棵树和一个元素, 把元素插入到这棵二元搜索树中. 从根节点开始, 拿该元素与树的节点比较, 如果比较小就往左走, 如果比较大则往右走, 重复这个动作直到碰到一棵空树, 然后插入节点.</p>
<p>由于 Haskell 没法修改该变量, 因此该函数会返回一棵新树:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">singleton</span> :: a -&gt; <span class="hljs-type">Tree</span> a<br><span class="hljs-title">singleton</span> x = <span class="hljs-type">Node</span> x <span class="hljs-type">EmptyTree</span> <span class="hljs-type">EmptyTree</span><br><br><span class="hljs-title">treeInsert</span> :: (<span class="hljs-type">Ord</span> a) =&gt; a -&gt; <span class="hljs-type">Tree</span> a -&gt; <span class="hljs-type">Tree</span> a<br><span class="hljs-title">treeInsert</span> x <span class="hljs-type">EmptyTree</span> = singleton x<br><span class="hljs-title">treeInsert</span> x (<span class="hljs-type">Node</span> a left right)<br>      | x == a = <span class="hljs-type">Node</span> x left right<br>      | x &lt; a  = <span class="hljs-type">Node</span> a (treeInsert x left) right<br>      | x &gt; a  = <span class="hljs-type">Node</span> a left (treeInsert x right)<br></code></pre></td></tr></table></figure>

<p>实现一个函数来检查某个元素是否已经在这棵树中: 先定义结束条件, 如果走到一棵空树位置还没有找到, 则说明元素不在这棵树中; 假设走到非空的树, 如果该元素小于节点值, 则继续往左走, 如果大于节点值, 则往右走:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">treeElem</span> :: (<span class="hljs-type">Ord</span> a) =&gt; a -&gt; <span class="hljs-type">Tree</span> a -&gt; <span class="hljs-type">Bool</span><br><span class="hljs-title">treeElem</span> x <span class="hljs-type">EmptyTree</span> = <span class="hljs-type">False</span><br><span class="hljs-title">treeElem</span> x (<span class="hljs-type">Node</span> a left right)<br>    | x == a = <span class="hljs-type">True</span><br>    | x &lt; a  = treeElem x left<br>    | x &gt; a  = treeElem x right<br></code></pre></td></tr></table></figure>

<p>假如现在要遍历一个 List 来创建一棵树, 可以用 <code>fold</code> 来实现:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">let</span> nums = [8,6,4,1,7,3,5]<br>ghci&gt; <span class="hljs-built_in">let</span> numsTree = foldr treeInsert EmptyTree nums<br>ghci&gt; numsTree<br>Node 5 (Node 3 (Node 1 EmptyTree EmptyTree) (Node 4 EmptyTree EmptyTree)) (Node 7 (Node 6 EmptyTree EmptyTree) (Node 8 EmptyTree EmptyTree))<br></code></pre></td></tr></table></figure>

<h2 id="构造-typeclass"><a href="#构造-typeclass" class="headerlink" title="构造 typeclass"></a>构造 typeclass</h2><p>Typeclass 类似 interface, 其定义了一组行为, 希望满足这些行为的类型作为这个 typeclass 的 instance.</p>
<p>Typeclass 的行为由函数来描述, 不一定要提供对应实现. 如果一个类型是某个 typeclass 的 instance, 那么这个类型就能使用 typeclass 中定义的函数.</p>
<p>需要注意这里的 typeclass 与面向对象语言中的 <code>class</code> 是完全不同的.</p>
<p>比如 <code>Eq</code> 这个 typeclass 描述可以比较相等的事物, 其定义了 <code>==</code> 和 <code>/=</code> 两个函数, 如果有一个类型 <code>Car</code>, 并且对 <code>Car</code> 做相等比较是有意义的, 那么就可以把 <code>Car</code> 当作 <code>Eq</code> 的一个 instance.</p>
<p>在 <code>Prelude</code> 中, <code>Eq</code> 是这样定义的:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Eq</span> a <span class="hljs-keyword">where</span></span><br>    (==) :: a -&gt; a -&gt; <span class="hljs-type">Bool</span><br>    (/=) :: a -&gt; a -&gt; <span class="hljs-type">Bool</span><br>    x == y = not (x /= y)<br>    x /= y = not (x == y)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>class Eq a where</code>, 表示定义了一个新的 typeclass 叫 <code>Eq</code>, 这里 <code>a</code> 是一个类型变量, 表示定义 <code>instance</code> 时指定的类型</li>
<li><code>(==)</code> 和 <code>(/=)</code> 两行描述了所需的函数声明</li>
<li>后两行描述了函数之间的关联, 若提供实现, 只需要提供一个就行</li>
</ul>
<p>我们这里定义有 <code>class Eq a where</code>, 然后定义了 <code>(==) :: a -&gt; a -&gt; Bool</code>, 如果查看函数的类别, 可以发现是 <code>(Eq a) =&gt; a -&gt; a -&gt; Bool</code>. 也就是 <code>Eq</code> instance 的类别才能调用该函数.</p>
<p>假如有下面类别:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">TrafficLight</span> = <span class="hljs-type">Red</span> | <span class="hljs-type">Yellow</span> | <span class="hljs-type">Green</span></span><br></code></pre></td></tr></table></figure>
<ul>
<li>这个定义中, 该类别不是任何 <code>class</code> 的 <code>instance</code></li>
</ul>
<p>不使用 <code>deriving</code> 而手动让其成为 <code>Eq</code> 的 <code>instance</code> 可以这样写:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Eq</span> <span class="hljs-type">TrafficLight</span> <span class="hljs-keyword">where</span></span><br>    <span class="hljs-type">Red</span> == <span class="hljs-type">Red</span> = <span class="hljs-type">True</span><br>    <span class="hljs-type">Green</span> == <span class="hljs-type">Green</span> = <span class="hljs-type">True</span><br>    <span class="hljs-type">Yellow</span> == <span class="hljs-type">Yellow</span> = <span class="hljs-type">True</span><br>    _ == _ = <span class="hljs-type">False</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>instance</code> 关键字表示要定义某个 typeclass 的 instance</li>
<li>当定义 <code>Eq</code> 时有 <code>class Eq a where</code>, 从这里 instance 定义的写法 <code>instance Eq TrafficLight where</code> 可以看出, <code>a</code> 会被换成这里的 <code>TrafficLight</code> 类别</li>
</ul>
<p>添加为 <code>Show</code> 的 <code>instance</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Show</span> <span class="hljs-type">TrafficLight</span> <span class="hljs-keyword">where</span></span><br>    show <span class="hljs-type">Red</span>    = <span class="hljs-string">&quot;Red light&quot;</span><br>    show <span class="hljs-type">Yellow</span> = <span class="hljs-string">&quot;Yellow light&quot;</span><br>    show <span class="hljs-type">Green</span>  = <span class="hljs-string">&quot;Green light&quot;</span><br></code></pre></td></tr></table></figure>

<p>可以把一个 typeclass 定义为其他 typeclass 的 subclass, 相当于添加了一个 class constraints (就和函数的类型约束一样), 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> (<span class="hljs-type">Eq</span> <span class="hljs-title">a</span>) =&gt; <span class="hljs-type">Num</span> a <span class="hljs-keyword">where</span></span><br>   ...<br></code></pre></td></tr></table></figure>
<ul>
<li>在定义 <code>a</code> 类型为 <code>Num</code> 的 <code>instance</code> 之前, 需要先将 <code>a</code> 定义为 <code>Eq</code> 的 <code>instance</code></li>
</ul>
<p>对于 <code>Maybe</code>, <code>List</code> 这种类型构造子, 不能直接写成:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Eq</span> <span class="hljs-type">Maybe</span> <span class="hljs-keyword">where</span></span><br>    ...<br></code></pre></td></tr></table></figure>

<p>应该写成:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> (<span class="hljs-type">Eq</span> <span class="hljs-title">m</span>) =&gt; <span class="hljs-type">Eq</span> (<span class="hljs-type">Maybe</span> <span class="hljs-title">m</span>) <span class="hljs-keyword">where</span></span><br>    <span class="hljs-type">Just</span> x == <span class="hljs-type">Just</span> y = x == y<br>    <span class="hljs-type">Nothing</span> == <span class="hljs-type">Nothing</span> = <span class="hljs-type">True</span><br>    _ == _ = <span class="hljs-type">False</span><br></code></pre></td></tr></table></figure>
<ul>
<li>因为在 <code>instance</code> 定义中, 用 <code>==</code> 来比较 <code>m</code> 类型的值, 因此还需要保证 <code>m</code> 是 <code>Eq</code> 的 <code>instance</code></li>
<li><code>(Maybe m)</code> 会构造一个具体的类别</li>
</ul>
<p>在 <code>ghci</code> 中, 可以用 <code>:info</code> 来查看一个 <code>typeclass</code> 定义了哪些函数, 以及哪些类型属于这个 typeclass.</p>
<h2 id="yes-no-typeclass"><a href="#yes-no-typeclass" class="headerlink" title="yes-no typeclass"></a>yes-no typeclass</h2><p>假如模仿 <code>javascript</code> 的 <code>if expression</code> 中的 <code>yes-no</code> 判断逻辑, 定义一个 typeclass:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">YesNo</span> a <span class="hljs-keyword">where</span></span><br>    yesno :: a -&gt; <span class="hljs-type">Bool</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>YesNo</code> typeclass 定义了一个函数, 接受一个值判断输出 <code>True</code> 还是 <code>False</code></li>
</ul>
<p>定义具体的 <code>instance</code> 如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">YesNo</span> <span class="hljs-type">Int</span> <span class="hljs-keyword">where</span></span><br>    yesno <span class="hljs-number">0</span> = <span class="hljs-type">False</span><br>    yesno _ = <span class="hljs-type">True</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">YesNo</span> [a] <span class="hljs-keyword">where</span></span><br>    yesno [] = <span class="hljs-type">False</span><br>    yesno _  = <span class="hljs-type">True</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">YesNo</span> <span class="hljs-type">Bool</span> <span class="hljs-keyword">where</span></span><br>    yesno = id<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">YesNo</span> (<span class="hljs-type">Maybe</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">where</span></span><br>    yesno (<span class="hljs-type">Just</span> _) = <span class="hljs-type">True</span><br>    yesno <span class="hljs-type">Nothing</span>  = <span class="hljs-type">False</span><br></code></pre></td></tr></table></figure>
<ul>
<li>对于数字, 非零数字都是 <code>True</code>, 只有 <code>0</code> 是 <code>False</code></li>
<li>对于列表, 非空 List 都是 <code>True</code>, 只有空 List 是 <code>False</code></li>
<li><code>id</code> 是标准库中的一个函数, 接受一个参数并回传相同的东西</li>
<li>对于 <code>Maybe</code>, 有具体类别的是 <code>True</code>, 如果是 <code>Nothing</code> 则为 <code>False</code></li>
</ul>
<p>测试:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; yesno $ length []<br>False<br>ghci&gt; yesno <span class="hljs-string">&quot;haha&quot;</span><br>True<br>ghci&gt; yesno <span class="hljs-string">&quot;&quot;</span><br>False<br>ghci&gt; yesno $ Just 0<br>True<br>ghci&gt; yesno True<br>True<br>ghci&gt; yesno []<br>False<br>ghci&gt; yesno [0,0,0]<br>True<br>ghci&gt; :t yesno<br>yesno :: (YesNo a) =&gt; a -&gt; Bool<br></code></pre></td></tr></table></figure>

<p>定义一个函数来模拟 <code>if expression</code> 的行为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">yesnoif</span> :: (<span class="hljs-type">YesNo</span> y) =&gt; y -&gt; a -&gt; a -&gt; a<br><span class="hljs-title">yesnoif</span> yesnoVal yesResult noResult =<br>    <span class="hljs-keyword">if</span> yesno yesnoVal <span class="hljs-keyword">then</span> yesResult <span class="hljs-keyword">else</span> noResult<br></code></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; yesnoIf [] <span class="hljs-string">&quot;YEAH!&quot;</span> <span class="hljs-string">&quot;NO!&quot;</span><br><span class="hljs-string">&quot;NO!&quot;</span><br>ghci&gt; yesnoIf [2,3,4] <span class="hljs-string">&quot;YEAH!&quot;</span> <span class="hljs-string">&quot;NO!&quot;</span><br><span class="hljs-string">&quot;YEAH!&quot;</span><br>ghci&gt; yesnoIf True <span class="hljs-string">&quot;YEAH!&quot;</span> <span class="hljs-string">&quot;NO!&quot;</span><br><span class="hljs-string">&quot;YEAH!&quot;</span><br>ghci&gt; yesnoIf (Just 500) <span class="hljs-string">&quot;YEAH!&quot;</span> <span class="hljs-string">&quot;NO!&quot;</span><br><span class="hljs-string">&quot;YEAH!&quot;</span><br>ghci&gt; yesnoIf Nothing <span class="hljs-string">&quot;YEAH!&quot;</span> <span class="hljs-string">&quot;NO!&quot;</span><br><span class="hljs-string">&quot;NO!&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="Functor-typeclass"><a href="#Functor-typeclass" class="headerlink" title="Functor typeclass"></a>Functor typeclass</h2><p><code>Functor</code> typeclass 表示一切可以 map over 的事物 (指一切容器), 比如 <code>List</code>, <code>Set</code> 等.</p>
<p>定义如下:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> f <span class="hljs-keyword">where</span></span><br>    fmap :: (a -&gt; b) -&gt; f a -&gt; f b<br></code></pre></td></tr></table></figure>
<ul>
<li><code>f</code> 是一个类型构造子, <code>f a</code> 才是具体的类别</li>
<li><code>fmap</code> 接收两个参数:<ul>
<li>一个函数 (声明中的这部分 <code>(a -&gt; b)</code>), 将一个类别映射到另一个类别</li>
<li>原始的类别参数 (<code>f a</code>)</li>
</ul>
</li>
</ul>
<p>比如 <code>map</code> 就是针对 <code>List</code> 的 <code>fmap</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> [] <span class="hljs-keyword">where</span></span><br>    fmap = map<br></code></pre></td></tr></table></figure>
<ul>
<li><code>[]</code> 是类型构造子, <code>[Int]</code> 这种才是具体的类别</li>
</ul>
<h2 id="Kind"><a href="#Kind" class="headerlink" title="Kind"></a>Kind</h2><p>每个值, 如 <code>3</code>, <code>&quot;YEAH&quot;</code>, <code>takeWhile</code> 等都有自己的类别. 类别是一个标签, 每个值都会携带, 而类别自己也有标签, 称为 <code>kind</code>.</p>
<p>可以理解 <code>kind</code> 为类别的类别.</p>
<p>可以在 <code>ghci</code> 中用 <code>:k</code> 来查看一个类别的 <code>kind</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :k Int<br>Int :: *<br></code></pre></td></tr></table></figure>
<ul>
<li><code>*</code> 表示这个类别是具体类别, 读作 <code>star</code> 或 <code>type</code>. 一个具体类别不需要接收参数</li>
</ul>
<p>查看 <code>Maybe</code> 的 kind:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :k Maybe<br>Maybe :: * -&gt; *<br></code></pre></td></tr></table></figure>
<ul>
<li><code>* -&gt; *</code> 表示 <code>Maybe</code> 构造子接收一个具体类别 (比如 <code>Int</code>), 然后回传一个具体类别 (如 <code>Maybe Int</code>)</li>
</ul>
<p>可以查看 <code>Maybe Int</code> 的 kind:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :k Maybe Int<br>Maybe Int :: *<br></code></pre></td></tr></table></figure>

<p>假如要把下面类型声明为 <code>Functor</code> 的 instance:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Barry</span> t k p = <span class="hljs-type">Barry</span> &#123; <span class="hljs-title">yabba</span> :: <span class="hljs-title">p</span>, <span class="hljs-title">dabba</span> :: <span class="hljs-title">t</span> <span class="hljs-title">k</span> &#125;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>Barry</code> 的 kind 为 <code>(* -&gt; *) -&gt; * -&gt; * -&gt; *</code></li>
<li>而 <code>Functor</code> 期望接收一个类型构造子, 也就是 <code>* -&gt; *</code> 的 kind, 因此需要 <code>partial apply</code> 头两个参数</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> (<span class="hljs-type">Barry</span> <span class="hljs-title">a</span> <span class="hljs-title">b</span>) <span class="hljs-keyword">where</span></span><br>    fmap f (<span class="hljs-type">Barry</span> &#123;yabba = x, dabba = y&#125;) = <span class="hljs-type">Barry</span> &#123;yabba = f x, dabba = y&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>(Barry a b)</code> 就是 partial apply 后的结果</li>
</ul>
<h1 id="Haskell-输入与输出"><a href="#Haskell-输入与输出" class="headerlink" title="Haskell 输入与输出"></a>Haskell 输入与输出</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>在 Haskell 中, 一个函数不能改变状态, 比如改变一个变量的内容 (当一个函数会改变状态, 我们说这个函数是有副作用的). 函数唯一可以做的事是根据给定的参数来计算结果.</p>
<p>实际上输出内容到屏幕这个行为改变了输出设备的状态. Haskell 设计了一套系统来处理所有有副作用的函数, 从而将程序分为纯粹和非纯粹两部分.</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>在一个 Haskell 文件 <code>helloworld.hs</code> 中写入:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = putStrLn <span class="hljs-string">&quot;hello, world!&quot;</span><br></code></pre></td></tr></table></figure>

<p>编译运行:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ghc --make helloworld<br>[1 of 1] Compiling Main                 ( helloworld.hs, hellowowlrd.o )<br>Linking helloworld ...<br>$ ./helloworld<br>hello, world<br></code></pre></td></tr></table></figure>

<p>可以检查 <code>putStrLn</code> 函数的类型:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t putStrLn<br>putStrLn :: String -&gt; IO ()<br>ghci&gt; :t putStrLn <span class="hljs-string">&quot;hello, world&quot;</span><br>putStrLn <span class="hljs-string">&quot;hello, world&quot;</span> :: IO ()<br></code></pre></td></tr></table></figure>
<ul>
<li>这样解读: <code>putStrLn</code> 接受一个字符串并回传一个 <code>I/O action</code>, 这个 <code>I/O action</code> 包含了 <code>()</code> 类型 (一个空 <code>tuple</code>)</li>
<li><code>I/O action</code> 会造成副作用, 通常指读取输入或输出到屏幕, 也代码回传某些值</li>
<li>由于在屏幕上打印字符串没有实际有意义的回传值, 因此用 <code>()</code> 来表示</li>
</ul>
<p><code>I/O action</code> 会在绑定到 <code>main</code> 这个名字时触发.</p>
<p>如果一个程序只能有一个 <code>I/O action</code>, 感觉限制比较大. 通常需要用 <code>do</code> 表示法, 来将所有 <code>I/O action</code> 绑定为一个:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    putStrLn <span class="hljs-string">&quot;Hello, what&#x27;s your name?&quot;</span><br>    name &lt;- getLine<br>    putStrLn (<span class="hljs-string">&quot;Hey &quot;</span> ++ name ++ <span class="hljs-string">&quot;, you rock!&quot;</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li>整个 <code>do</code> 表示法的类型由最后一个 <code>I/O action</code> 决定</li>
<li>这也是为什么 <code>main</code> 的类型永远是 <code>main :: IO something</code>, 但按照惯例, 一般不写出 <code>main</code> 的类型</li>
<li><code>getLine</code> 的类型是 <code>getLine :: IO String</code>, 是一个回传 <code>String</code> 的 <code>I/O action</code>, 因此 <code>name</code> 的类型是 <code>String</code></li>
<li>从 <code>I/O action</code> 中取出数据要用 <code>&lt;-</code></li>
</ul>
<p>每个 <code>I/O action</code> 都会封装一个值, 比如程序可以这样写:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    foo &lt;- putStrLn <span class="hljs-string">&quot;Hello, what&#x27;s your name?&quot;</span><br>    name &lt;- getLine<br>    putStrLn (<span class="hljs-string">&quot;Hey &quot;</span> ++ name ++ <span class="hljs-string">&quot;, you rock!&quot;</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>foo</code> 取到的是 <code>()</code> (空 <code>tuple</code>)</li>
<li>需要注意, 在 <code>do block</code> 中, 最后一个 <code>action</code> 不能绑定任何名字 (这需要了解 Monad 相关内容)</li>
</ul>
<p>在 <code>do block</code> 中使用 <code>let binding</code> 可以不需要添加 <code>in</code> 的部分:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> Data.Char<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    putStrLn <span class="hljs-string">&quot;What&#x27;s your first name?&quot;</span><br>    firstName &lt;- getLine<br>    putStrLn <span class="hljs-string">&quot;What&#x27;s your last name?&quot;</span><br>    lastName &lt;- getLine<br>    <span class="hljs-keyword">let</span> bigFirstName = map toUpper firstName<br>        bigLastName = map toUpper lastName<br>    putStrLn $ <span class="hljs-string">&quot;hey &quot;</span> ++ bigFirstName ++ <span class="hljs-string">&quot; &quot;</span> ++ bigLastName ++ <span class="hljs-string">&quot;, how are you?&quot;</span><br></code></pre></td></tr></table></figure>

<p>循环读取输入并将读进来的字符反过来输出到屏幕的示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    line &lt;- getLine<br>    <span class="hljs-keyword">if</span> null line<br>        <span class="hljs-keyword">then</span> return ()<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">do</span><br>            putStrLn $ reverseWords line<br>            main<br><br><span class="hljs-title">reverseWords</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">reverseWords</span> = unwords . map reverse . words<br></code></pre></td></tr></table></figure>
<ul>
<li>Haskell 中的 <code>return</code> 与其他语言不同, 并不是结束一个函数的执行, 而是将一个 pure value 包裹在啊 <code>I/O action</code> 中, 比如 <code>return &quot;lala&quot;</code> 的类型就是 <code>IO String</code></li>
</ul>
<p>同样可以用 <code>&lt;-</code> 从 <code>return xxx</code> 中取值并绑定:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    a &lt;- return <span class="hljs-string">&quot;hell&quot;</span><br>    b &lt;- return <span class="hljs-string">&quot;yeah!&quot;</span><br>    putStrLn $ a ++ <span class="hljs-string">&quot; &quot;</span> ++ b<br></code></pre></td></tr></table></figure>

<p>一般只会在需要一个什么都不做的 <code>I/O action</code> 时使用 <code>return</code>.</p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="putStr"><a href="#putStr" class="headerlink" title="putStr"></a>putStr</h3><p><code>putStr</code> 与 <code>putStrLn</code> 类似, 接受一个字符串作为参数, 并返回一个 <code>I/O action</code> 打印字符串到终端, 只是不会添加换行符:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span> putStr <span class="hljs-string">&quot;Hey, &quot;</span><br>          putStr <span class="hljs-string">&quot;I&#x27;m &quot;</span><br>          putStr <span class="hljs-string">&quot;Jie!&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="putChar"><a href="#putChar" class="headerlink" title="putChar"></a>putChar</h3><p><code>putChar</code> 接受一个字符, 并返回一个 <code>I/O action</code> 将他打印到终端上:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = putChar <span class="hljs-string">&quot;h&quot;</span><br>       putChar <span class="hljs-string">&quot;e&quot;</span><br>       putChar <span class="hljs-string">&quot;l&quot;</span><br>       putChar <span class="hljs-string">&quot;l&quot;</span><br>       putChar <span class="hljs-string">&quot;o&quot;</span><br></code></pre></td></tr></table></figure>

<p><code>putStr</code> 本质就是 <code>putChar</code> 递归定义得到的:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">putStr</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">IO</span> ()<br><span class="hljs-title">putStr</span> [] = return ()<br><span class="hljs-title">putStr</span> (x:xs) = <span class="hljs-keyword">do</span><br>    putChar x<br>    putStr  xs<br></code></pre></td></tr></table></figure>

<h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p><code>print</code> 接受类型在 <code>Show typeclass</code> 中的值, 先用 <code>show</code> 将值变成字符串, 然后将其输出到终端上. 它基本等价于 <code>putStrLn . show</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span> print <span class="hljs-type">True</span><br>          print <span class="hljs-number">2</span><br>          print <span class="hljs-string">&quot;haha&quot;</span><br>          print <span class="hljs-number">3.2</span><br>          print [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure>

<h3 id="getChar"><a href="#getChar" class="headerlink" title="getChar"></a>getChar</h3><p><code>getChar</code> 从输入读入一个字符到 <code>I/O action</code>, 需要注意由于缓冲区的原因, 只有按下 <code>Enter</code> 时才会触发读取字符的行为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    c &lt;- getChar<br>    <span class="hljs-keyword">if</span> c /= &#x27; &#x27;<br>        <span class="hljs-keyword">then</span> <span class="hljs-keyword">do</span><br>            putChar c<br>            main<br>        <span class="hljs-keyword">else</span> return ()<br></code></pre></td></tr></table></figure>

<h3 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h3><p><code>sequence</code> 接受一串 <code>I/O action</code>, 并回传一个会依次执行他们的 <code>I/O action</code>, 运算的结果是 <code>I/O action</code> 包裹的 List. 他的类型是 <code>sequence :: [IO a] -&gt; IO [a]</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    a &lt;- getLine<br>    b &lt;- getLine<br>    c &lt;- getLine<br>    print [a,b,c]<br></code></pre></td></tr></table></figure>

<p>等价于:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    rs &lt;- sequence [getLine, getLine, getLine]<br>    print rs<br></code></pre></td></tr></table></figure>

<p>常见的使用是用 <code>print</code> 或 <code>putStrLn</code> 之类的函数 <code>map</code> 到串上, 其返回一串 <code>I/O action</code>, 此时就需要用 <code>sequence</code> 来打包:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; sequence (map <span class="hljs-built_in">print</span> [1,2,3,4,5])<br>1<br>2<br>3<br>4<br>5<br>[(),(),(),(),()]<br></code></pre></td></tr></table></figure>

<p>由于 <code>sequence</code> 和 <code>map</code> 搭配的操作很常见, 因此有 <code>mapM</code> 函数, 其接受一个函数和一个串列, 先对串列应用函数, 然后再 <code>sequence</code> 结果:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; mapM <span class="hljs-built_in">print</span> [1,2,3]<br>1<br>2<br>3<br>[(),(),()]<br>ghci&gt; mapM_ <span class="hljs-built_in">print</span> [1,2,3]<br>1<br>2<br>3<br></code></pre></td></tr></table></figure>
<ul>
<li><code>mapM_</code> 会额外丢弃运算结果</li>
</ul>
<h3 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h3><p><code>forever</code> 接受一个 <code>I/O action</code> 并返回一个永远作同一件事的 <code>I/O action</code>. 其包含在 <code>Control.Monad</code> 中, 下面例子会不断要求用户输入内容, 并把输入的东西转成大写输出到屏幕:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> Control.Monad<br><span class="hljs-keyword">import</span> Data.Char<br><br><span class="hljs-title">main</span> = forever $ <span class="hljs-keyword">do</span><br>    putStr <span class="hljs-string">&quot;Give me some input: &quot;</span><br>    l &lt;- getLine<br>    putStrLn $ map toUpper l<br></code></pre></td></tr></table></figure>

<h2 id="文件和字符流"><a href="#文件和字符流" class="headerlink" title="文件和字符流"></a>文件和字符流</h2><h3 id="getContents"><a href="#getContents" class="headerlink" title="getContents"></a>getContents</h3><p><code>getContents</code> 是一个从标准输入一直读取直到 EOF (End-Of-File) 的 <code>I/O action</code>, 其类型是 <code>getContents :: IO String</code>.</p>
<p><code>getContents</code> 还是惰性 I&#x2F;O, 比如 <code>foo &lt;- getContents</code>, 他不会立即读取所有输入到 <code>foo</code> 中, 会先将它们存在 memory 里面, 只有在真正使用数据时才会读取.</p>
<p>比如将一个文本文件的内容重定向给程序, 下面是文本文件 <code>haiku.txt</code>:</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">I<span class="hljs-symbol">&#x27;m</span> a lil&#x27; teapot<br>What<span class="hljs-symbol">&#x27;s</span> <span class="hljs-keyword">with</span> that airplane food, huh?<br>It<span class="hljs-symbol">&#x27;s</span> so small, tasteless<br></code></pre></td></tr></table></figure>

<p>使用 <code>getContents</code> 的示例, 将下面代码保存为 <code>capslocker.hs</code> 文件:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> Data.Char<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    contents &lt;- getContents<br>    putStr $ map toUpper contents<br></code></pre></td></tr></table></figure>

<p>编译运行:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ghc --make capslocker<br>$ <span class="hljs-built_in">cat</span> haiku.txt | capslocker<br>I<span class="hljs-string">&#x27;M A LIL&#x27;</span> TEAPOT<br>WHAT<span class="hljs-string">&#x27;S WITH THAT AIRPLANE FOOD, HUH?</span><br><span class="hljs-string">IT&#x27;</span>S SO SMALL, TASTELESS<br></code></pre></td></tr></table></figure>

<p>另一示例, 读取输入, 打印少于 10 个字符的行:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    contents &lt;- getContents<br>    putStr (shortLinesOnly contents)<br><br><span class="hljs-title">shortLinesOnly</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">shortLinesOnly</span> input =<br>    <span class="hljs-keyword">let</span> allLines = lines input<br>        shortLines = filter (\line -&gt; length line &lt; <span class="hljs-number">10</span>) allLines<br>        result = unlines shortLines<br>    <span class="hljs-keyword">in</span> result<br></code></pre></td></tr></table></figure>

<p>由于这种输入一个字符串, 经过转换后再返回输出的模式很常见. 因此 Haskell 建立了函数 <code>interact</code>, 其接受一个 <code>String -&gt; String</code> 的函数, 并返回一个 <code>I/O action</code>, 这个 <code>I/O action</code> 会读取一些输入, 调用传入的函数然后打印结果, 因此上面程序可以改写为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = interact shortLinesOnly<br><br><span class="hljs-title">shortLinesOnly</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">shortLinesOnly</span> input =<br>    <span class="hljs-keyword">let</span> allLines = lines input<br>        shortLines = filter (\line -&gt; length line &lt; <span class="hljs-number">10</span>) allLines<br>        result = unlines shortLines<br>    <span class="hljs-keyword">in</span> result<br></code></pre></td></tr></table></figure>

<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>读写终端也是一种文件读写, 只是文件名是 <code>stdout</code> 和 <code>stdin</code> (分别表示标准输出和标准输入).</p>
<p>现在编写一个示例程序, 打开一个叫 <code>girlfriend.txt</code> 的文件, 并将内容打印到终端. <code>girlfriend.txt</code> 文件的内容是:</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Hey! Hey! You! You!<br>I don&#x27;t like your girlfriend!<br>No way! No way!<br>I think you need a new one!<br></code></pre></td></tr></table></figure>

<p>主程序如下:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.IO<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    handle &lt;- openFile <span class="hljs-string">&quot;girlfriend.txt&quot;</span> <span class="hljs-type">ReadMode</span><br>    contents &lt;- hGetContents handle<br>    putStr contents<br>    hClose handle<br></code></pre></td></tr></table></figure>

<p>运行:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ runhaskell girlfriend.hs<br>Hey! Hey! You! You!<br>I don<span class="hljs-string">&#x27;t like your girlfriend!</span><br><span class="hljs-string">No way! No way!</span><br><span class="hljs-string">I think you need a new one!</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>openFile</code> 的类型是 <code>openFile :: FilePath -&gt; IOMode -&gt; IOHandle</code>. 这里的 <code>FilePath</code> 是 <code>String</code> 的别名; <code>IOMode</code> 定义如下: <code>data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode</code></li>
<li><code>hGetContents</code> 接受一个 <code>Handle</code>, 并回传一个 <code>IO String</code>, 类似于 <code>getContents</code> 函数. 它也是惰性的, 并不会一次性把文件全部内容读取到内存中</li>
<li><code>hClose</code> 接受一个 <code>Handle</code> 然后返回一个关掉文件的 <code>I/O action</code></li>
</ul>
<p>也可以用 <code>withFile</code> 函数来读取文件, 其类型为 <code>withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a</code>, 例如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.IO<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    withFile <span class="hljs-string">&quot;girlfriend.txt&quot;</span> <span class="hljs-type">ReadMode</span> (\handle -&gt; <span class="hljs-keyword">do</span><br>        contents &lt;- hGetContents handle<br>        putStr contents)<br></code></pre></td></tr></table></figure>
<ul>
<li>其接受一个文件路径, 文件打开模式, 以及一个处理 <code>handle</code> 的函数, 最后返回一个会打开文件, 对文件进行操作, 并关闭文件的 <code>I/O action</code></li>
</ul>
<p>可以自己实现一个 <code>withFile</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">withFile&#x27;</span> :: <span class="hljs-type">FilePath</span> -&gt; <span class="hljs-type">IOMode</span> -&gt; (<span class="hljs-type">Handle</span> -&gt; <span class="hljs-type">IO</span> a) -&gt; <span class="hljs-type">IO</span> a<br><span class="hljs-title">withFile&#x27;</span> path mode f = <span class="hljs-keyword">do</span><br>    handle &lt;- openFile path mode<br>    result &lt;- f handle<br>    hClose handle<br>    return result<br></code></pre></td></tr></table></figure>
<ul>
<li><code>return</code> 的作用是, 把从 <code>f</code> 得到的结果包裹在一个 <code>I/O action</code> 中</li>
</ul>
<p>对于文件的读取和写入, 还有 <code>hGetLine</code>, <code>hPutStr</code>, <code>hPutStrLn</code>, <code>hGetChar</code> 等等, 只是相对于没有 <code>h</code> 开头的函数版本多了一个 <code>handle</code> 参数而已, 比如:</p>
<ul>
<li><code>hPutStrLn</code> 接受一个 <code>handle</code> 和字符串, 返回一个打印添加了换行符的字符串到文件中的 <code>I/O action</code></li>
</ul>
<p>由于读写文件的操作非常频繁, 因此还封装了更上层的函数:</p>
<ul>
<li><code>readFile</code>, 类型是 <code>readFile :: FilePath -&gt; IO String</code>. 其会返回一个惰性读取文件的 <code>I/O action</code>:</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.IO<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    contents &lt;- readFile <span class="hljs-string">&quot;girlfriend.txt&quot;</span><br>    putStr contents<br></code></pre></td></tr></table></figure>

<ul>
<li><code>writeFile</code>, 类型是 <code>writeFile :: FilePath -&gt; String -&gt; IO ()</code>. 如果文件存在, 则会先清空再写入:</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.IO<br><span class="hljs-keyword">import</span> Data.Char<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    contents &lt;- readFile <span class="hljs-string">&quot;girlfriend.txt&quot;</span><br>    writeFile <span class="hljs-string">&quot;girlfriendcaps.txt&quot;</span> (map toUpper contents)<br></code></pre></td></tr></table></figure>

<ul>
<li><code>appendFile</code>, 与 <code>writeFile</code> 类似, 只不过不会清空文件, 而是追加内容:<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.IO<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    todoItem &lt;- getLine<br>    appendFile <span class="hljs-string">&quot;todo.txt&quot;</span> (todoItem ++ <span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<p>对文本文件而言, 默认的 <code>buffer</code> 通常是 <code>line-buffer</code>, 一行一行处理, 而对于二进制文件而言, 默认是 <code>block-buffer</code>, 每次读入一个 chunk.</p>
<p>可以用 <code>hSetBuffering</code> 来控制 <code>buffer</code> 的行为, 其接受一个 <code>handle</code> 和一个 <code>BufferMode</code>, 返回一个会设置 <code>buffer</code> 行为的 <code>I/O action</code>.</p>
<p><code>BufferMode</code> 是一个 <code>enumeration</code> 类型, 可能的值有 <code>NoBuffering</code>, <code>LineBuffering</code>, <code>BlockBuffering (Maybe int)</code>. <code>Maybe Int</code> 用来表示一个 <code>chunk</code> 会有多少 byte. 如果是 <code>Nothing</code>, 则由操作系统决定. <code>NoBuffering</code> 表示一次读取一个 <code>charactor</code>.</p>
<p>下面例子将 <code>buffer</code> 的行为改为一次读取 <code>2048 bytes</code> 的 chunk, 而不是一行一行读取:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    withFile <span class="hljs-string">&quot;something.txt&quot;</span> <span class="hljs-type">ReadMode</span> (\handle -&gt; <span class="hljs-keyword">do</span><br>        hSetBuffering handle $ <span class="hljs-type">BlockBuffering</span> (<span class="hljs-type">Just</span> <span class="hljs-number">2048</span>)<br>        contents &lt;- hGetContents handle<br>        putStr contents)<br></code></pre></td></tr></table></figure>
<ul>
<li>用更大的 <code>chunk</code> 能减少磁盘访问次数</li>
</ul>
<p>可以用 <code>hFlush</code> 来刷新 buffer, 它接受一个 handle 并返回一个会 <code>flush buffer</code> 到文件的 <code>I/O action</code>.</p>
<p>默认情况下:</p>
<ul>
<li>对于 <code>line-buffering</code>, buffer 每填充一行, 会 <code>flush</code> 到文件</li>
<li>对于 <code>block-buffering</code>, buffer 每填满一个 chunk, 会 <code>flush</code> 到文件</li>
<li>在关闭 <code>handle</code> 时, 也会进行 <code>flush</code></li>
</ul>
<p>使用 <code>hFlush</code> 则会强制进行刷新.</p>
<p>一个复杂一点的程序示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.IO<br><span class="hljs-keyword">import</span> System.Directory<br><span class="hljs-keyword">import</span> Data.List<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    handle &lt;- openFile <span class="hljs-string">&quot;todo.txt&quot;</span> <span class="hljs-type">ReadMode</span><br>    (tempName, tempHandle) &lt;- openTempFile <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-string">&quot;temp&quot;</span><br>    contents &lt;- hGetContents handle<br>    <span class="hljs-keyword">let</span> todoTasks = lines contents<br>    numberedTasks = zipWith (\n line -&gt; show n ++ <span class="hljs-string">&quot; - &quot;</span> ++ line) [<span class="hljs-number">0</span>..] todoTasks<br>    putStrLn <span class="hljs-string">&quot;These are your TO-DO items:&quot;</span><br>    putStr $ unlines numberedTasks<br>    putStrLn <span class="hljs-string">&quot;Which one do you want to delete?&quot;</span><br>    numberString &lt;- getLine<br>    <span class="hljs-keyword">let</span> number = read numberString<br>    newTodoItems = delete (todoTasks !! number) todoTasks<br>    hPutStr tempHandle $ unlines newTodoItems<br>    hClose handle<br>    hClose tempHandle<br>    removeFile <span class="hljs-string">&quot;todo.txt&quot;</span><br>    renameFile tempName <span class="hljs-string">&quot;todo.txt&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>openTempFile</code> 接受一个目录名和模板文件名 (临时文件名会在此基础上添加字符串), 在目录下创建一个临时文件, 其返回一个会创建临时文件的 <code>I/O action</code>, 这个 <code>I/O action</code> 的结果会包含一个二元组, 内容是临时文件名和对应的 handle</li>
<li><code>removeFile</code> 会删除一个文件</li>
<li><code>renameFile</code> 会重命名一个文件</li>
</ul>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>在 <code>System.Environment</code> 模块中, 有两个 <code>I/O action</code> 可用于处理命令行参数:</p>
<ul>
<li><code>getArgs</code>, 类型是  <code>getArgs :: IO [String]</code>. 其会将命令行参数包裹在字符串数组中</li>
<li><code>getProgName</code>, 类型是 <code>getProgName :: IO String</code>. 其包含当前程序名</li>
</ul>
<p>示例程序:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.Environment<br><span class="hljs-keyword">import</span> Data.List<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    args &lt;- getArgs<br>    progName &lt;- getProgName<br>    putStrLn <span class="hljs-string">&quot;The arguments are:&quot;</span><br>    mapM putStrLn args<br>    putStrLn <span class="hljs-string">&quot;The program name is:&quot;</span><br>    putStrLn progName<br></code></pre></td></tr></table></figure>

<p>一个完整的复杂一些的程序:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.Environment<br><span class="hljs-keyword">import</span> System.Directory<br><span class="hljs-keyword">import</span> System.IO<br><span class="hljs-keyword">import</span> Data.List<br><br><span class="hljs-title">dispatch</span> :: [(<span class="hljs-type">String</span>, [<span class="hljs-type">String</span>] -&gt; <span class="hljs-type">IO</span> ())]<br><span class="hljs-title">dispatch</span> =  [ (<span class="hljs-string">&quot;add&quot;</span>, add)<br>            , (<span class="hljs-string">&quot;view&quot;</span>, view)<br>            , (<span class="hljs-string">&quot;remove&quot;</span>, remove)<br>            ]<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    (command:args) &lt;- getArgs<br>    <span class="hljs-keyword">let</span> (<span class="hljs-type">Just</span> action) = lookup command dispatch<br>    action args<br><br><span class="hljs-title">add</span> :: [<span class="hljs-type">String</span>] -&gt; <span class="hljs-type">IO</span> ()<br><span class="hljs-title">add</span> [fileName, todoItem] = appendFile fileName (todoItem ++ <span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-title">view</span> :: [<span class="hljs-type">String</span>] -&gt; <span class="hljs-type">IO</span> ()<br><span class="hljs-title">view</span> [fileName] = <span class="hljs-keyword">do</span><br>    contents &lt;- readFile fileName<br>    <span class="hljs-keyword">let</span> todoTasks = lines contents<br>        numberedTasks = zipWith (\n line -&gt; show n ++ <span class="hljs-string">&quot; - &quot;</span> ++ line) [<span class="hljs-number">0</span>..] todoTasks<br>    putStr $ unlines numberedTasks<br><br><span class="hljs-title">remove</span> :: [<span class="hljs-type">String</span>] -&gt; <span class="hljs-type">IO</span> ()<br><span class="hljs-title">remove</span> [fileName, numberString] = <span class="hljs-keyword">do</span><br>    handle &lt;- openFile fileName <span class="hljs-type">ReadMode</span><br>    (tempName, tempHandle) &lt;- openTempFile <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-string">&quot;temp&quot;</span><br>    contents &lt;- hGetContents handle<br>    <span class="hljs-keyword">let</span> number = read numberString<br>        todoTasks = lines contents<br>        newTodoItems = delete (todoTasks !! number) todoTasks<br>    hPutStr tempHandle $ unlines newTodoItems<br>    hClose handle<br>    hClose tempHandle<br>    removeFile fileName<br>    renameFile tempName fileName<br></code></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ghc --make todo.hs<br>$ ./todo view todo.txt<br>0 - Iron the dishes<br>1 - Dust the dog<br>2 - Take salad out of the oven<br><br>$ ./todo add todo.txt <span class="hljs-string">&quot;Pick up children from drycleaners&quot;</span><br><br>$ ./todo view todo.txt<br>0 - Iron the dishes<br>1 - Dust the dog<br>2 - Take salad out of the oven<br>3 - Pick up children from drycleaners<br><br>$ ./todo remove todo.txt 2<br><br>$ ./todo view todo.txt<br>0 - Iron the dishes<br>1 - Dust the dog<br>2 - Pick up children from drycleaners<br></code></pre></td></tr></table></figure>

<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p><code>System.Random</code> 模块中的 <code>random</code> 函数能用于产生伪随机数, 其类型为 <code>random :: (RandomGen g, Random a) =&gt; g -&gt; (a,g)</code>:</p>
<ul>
<li><code>RandomGen</code> typeclass, 指代那些可以当做产生随机数的源头的类型.</li>
<li><code>Random</code> typeclass 指装载随机数的类型.</li>
</ul>
<p>该函数接受一个 <code>random generator</code>, 返回一个随机数以及新的 <code>random generator</code>.</p>
<p><code>System.Random</code> 模块中的 <code>StdGen</code> 类型就是 <code>RandomGen</code> 的一个实例, 可以用 <code>mkStdGen</code> 来创建该类型的值, <code>mkStdGen :: Int -&gt; StdGen</code>, 示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; random (mkStdGen 100) :: (Int, StdGen)<br>(-1352021624,651872571 1655838864)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>random</code> 可以产生任何 <code>Random</code> typeclass 中的类型, 因此需要告诉 Haskell 具体的类型</li>
<li>这里 <code>tuple</code> 的第二个元素是新的 <code>random generator</code> 的文本表示</li>
</ul>
<p>如果再运行相同语句, 得到的还是同样的值, 因为本质上是伪随机数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; random (mkStdGen 100) :: (Int, StdGen)<br>(-1352021624,651872571 1655838864)<br></code></pre></td></tr></table></figure>

<p>产生不同类别随机数的例子:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; random (mkStdGen 949488) :: (Float, StdGen)<br>(0.8938442,1597344447 1655838864)<br>ghci&gt; random (mkStdGen 949488) :: (Bool, StdGen)<br>(False,1485632275 40692)<br>ghci&gt; random (mkStdGen 949488) :: (Integer, StdGen)<br>(1691547873,1597344447 1655838864)<br></code></pre></td></tr></table></figure>

<p>如果要写一个函数, 仿真丢三次硬币, 需要这样写:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">threeCoins</span> :: <span class="hljs-type">StdGen</span> -&gt; (<span class="hljs-type">Bool</span>, <span class="hljs-type">Bool</span>, <span class="hljs-type">Bool</span>)<br><span class="hljs-title">threeCoins</span> gen =<br>    <span class="hljs-keyword">let</span> (firstCoin, newGen) = random gen<br>        (secondCoin, newGen&#x27;) = random newGen<br>        (thirdCoin, newGen&#x27;) = random newGen&#x27;<br>    <span class="hljs-keyword">in</span>  (firstCoin, secondCoin, thirdCoin)<br></code></pre></td></tr></table></figure>

<p>运行示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; threeCoins (mkStdGen 21)<br>(True,True,True)<br>ghci&gt; threeCoins (mkStdGen 22)<br>(True,False,True)<br>ghci&gt; threeCoins (mkStdGen 943)<br>(True,False,True)<br>ghci&gt; threeCoins (mkStdGen 944)<br>(True,True,True)<br></code></pre></td></tr></table></figure>

<h3 id="randoms"><a href="#randoms" class="headerlink" title="randoms"></a>randoms</h3><p><code>randoms</code> 函数接受一个 <code>generator</code> 并返回一个无穷列表:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Int]<br>[-1807975507,545074951,-1015194702,-1622477312,-502893664]<br>ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Bool]<br>[True,True,True,True,False]<br>ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Float]<br>[7.904789e-2,0.62691015,0.26363158,0.12223756,0.38291094]<br></code></pre></td></tr></table></figure>

<p>该函数可以这样实现:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">randoms&#x27;</span> :: (<span class="hljs-type">RandomGen</span> g, <span class="hljs-type">Random</span> a) =&gt; g -&gt; [a]<br><span class="hljs-title">randoms&#x27;</span> gen = <span class="hljs-keyword">let</span> (value, newGen) = random gen <span class="hljs-keyword">in</span> value:randoms&#x27; newGen<br></code></pre></td></tr></table></figure>

<h3 id="randomR"><a href="#randomR" class="headerlink" title="randomR"></a>randomR</h3><p><code>randomR</code> (Random Range), 会生成指定范围内的随机数, 其类型为 <code>randomR :: (RandomGen g, Random a) =&gt; (a,a) -&gt; g -&gt; (a,g)</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; randomR (1,6) (mkStdGen 359353)<br>(6,1494289578 40692)<br>ghci&gt; randomR (1,6) (mkStdGen 35935335)<br>(3,1250031057 40692)<br></code></pre></td></tr></table></figure>

<h3 id="randomRs"><a href="#randomRs" class="headerlink" title="randomRs"></a>randomRs</h3><p><code>randomRs</code> 生成无限长的范围内的随机数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; take 10 $ randomRs (<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;z&#x27;</span>) (mkStdGen 3) :: [Char]<br><span class="hljs-string">&quot;ndkxbvmomg&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="getStdGen"><a href="#getStdGen" class="headerlink" title="getStdGen"></a>getStdGen</h3><p><code>getStdGen</code> 是一个 <code>I/O action</code>, 类型是 <code>getStdGen :: IO Stdgen</code>, 当程序运行时, 其会向系统索要一个 random generator 并保存为一个 global generator. 而 <code>getStdGen</code> 就是获取这个 generator 并将其绑定到某个名称上:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.Random<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    gen &lt;- getStdGen<br>    putStr $ take <span class="hljs-number">20</span> (randomRs (&#x27;a&#x27;,&#x27;z&#x27;) gen)<br></code></pre></td></tr></table></figure>

<p>如果调用两次 <code>getStdGen</code>, 实际上得到的是相同的 random generator.</p>
<h3 id="newStdGen"><a href="#newStdGen" class="headerlink" title="newStdGen"></a>newStdGen</h3><p><code>newStdGen</code> 也是一个 <code>I/O action</code>, 其会把现有的 random generator 分成两个新的 generators, 然后把其中一个指定成 global generator, 并回传另一个:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.Random<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    gen &lt;- getStdGen<br>    putStrLn $ take <span class="hljs-number">20</span> (randomRs (&#x27;a&#x27;,&#x27;z&#x27;) gen)<br>    gen&#x27; &lt;- newStdGen<br>    putStr $ take <span class="hljs-number">20</span> (randomRs (&#x27;a&#x27;,&#x27;z&#x27;) gen&#x27;)<br></code></pre></td></tr></table></figure>

<h2 id="Bytestrings"><a href="#Bytestrings" class="headerlink" title="Bytestrings"></a>Bytestrings</h2><p>由于 Haskell 的惰性求值, 用 <code>List</code> 来处理大字符串会比较慢, 为此有 <code>Bytestrings</code> 数据结构来处理.</p>
<p><code>Bytestrings</code> 与 <code>List</code> 类似, 但他的每一个元素都是一个 byte (8 bits), 并且惰性也不同.</p>
<p><code>Bytestrings</code> 分两种:</p>
<ul>
<li><code>strict</code>, 位于 <code>Data.ByteString</code> 模块中, 会完全移除惰性. 因此也没法创建无限长的 <code>strict bytestrings</code>, 当 <code>bytestrings</code> 中的第一个 byte 求值时, 整个 <code>bytestrings</code> 都会被求值</li>
<li><code>lazy</code>, 位于 <code>Data.ByteString.Lazy</code> 模块中, 其具有一些惰性, 但没有 <code>List</code> 那么极端, 它会一个 <code>chunk</code> 一个 <code>chunnk</code> 将文件读入到内存中, 而非一次全部读取</li>
</ul>
<p>由于这两个模块中很多函数名与 <code>Data.List</code> 中的函数冲突, 因此一般需要 <code>qualified import</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.ByteString.Lazy <span class="hljs-keyword">as</span> B<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.ByteString <span class="hljs-keyword">as</span> S<br></code></pre></td></tr></table></figure>
<ul>
<li>大多时候都会使用 <code>Lazy</code> 的版本</li>
</ul>
<h3 id="pack"><a href="#pack" class="headerlink" title="pack"></a>pack</h3><p><code>pack</code> 函数的类型是 <code>pack :: [Word8] -&gt; ByteString</code>, 接受一个 <code>Wrod8</code> 类型的 List, 并返回一个 <code>ByteString</code>.</p>
<ul>
<li><code>Word8</code> 是一个 <code>0~255</code> 之间的数, 表示 <code>8-bit</code> 的数字, 属于 <code>Num</code> typeclass</li>
<li>作用就是把一些数值打包成一个 <code>ByteString</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; B.pack [99,97,110]<br>Chunk <span class="hljs-string">&quot;can&quot;</span> Empty<br>ghci&gt; B.pack [98..120]<br>Chunk <span class="hljs-string">&quot;bcdefghijklmnopqrstuvwx&quot;</span> Empty<br></code></pre></td></tr></table></figure>

<h3 id="unpack"><a href="#unpack" class="headerlink" title="unpack"></a>unpack</h3><p><code>unpack</code> 函数的类型是 <code>unpack :: ByteString -&gt; [Word8]</code>, 将一个 <code>ByteString</code> 转为一组数值:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">let</span> bs = pack [1,2,3]<br>ghci&gt; bs<br><span class="hljs-string">&quot;\SOH\STX\ETX&quot;</span><br>ghci&gt; unpack bs<br>[1,2,3]<br></code></pre></td></tr></table></figure>

<h3 id="fromChunks-和-toChunks"><a href="#fromChunks-和-toChunks" class="headerlink" title="fromChunks 和 toChunks"></a>fromChunks 和 toChunks</h3><p><code>fromChunks</code> 接受一组 strict bytestrings, 然后将其变成一组 lazy bytestrings:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; B.fromChunks [S.pack [40,41,42], S.pack [43,44,45], S.pack [46,47,48]]<br>Chunk <span class="hljs-string">&quot;()*&quot;</span> (Chunk <span class="hljs-string">&quot;+,-&quot;</span> (Chunk <span class="hljs-string">&quot;./0&quot;</span> Empty))<br></code></pre></td></tr></table></figure>

<p><code>toChunks</code> 接受一组 lazy bytestrings, 然后转换成一组 strict bytestrings.</p>
<h3 id="cons"><a href="#cons" class="headerlink" title="cons"></a>cons</h3><p><code>cons</code> 接受一个 <code>byte</code> 和一个 <code>bytestring</code>, 并将这个 byte 放到 <code>bytestring</code> 的前端. 该操作是 lazy 的, 而 <code>cons&#39;</code> 函数是 <code>strict</code> 的:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; B.cons 85 $ B.pack [80,81,82,84]<br>Chunk <span class="hljs-string">&quot;U&quot;</span> (Chunk <span class="hljs-string">&quot;PQRT&quot;</span> Empty)<br>ghci&gt; B.cons<span class="hljs-string">&#x27; 85 $ B.pack [80,81,82,84]</span><br><span class="hljs-string">Chunk &quot;UPQRT&quot; Empty</span><br><span class="hljs-string">ghci&gt; foldr B.cons B.empty [50..60]</span><br><span class="hljs-string">Chunk &quot;2&quot; (Chunk &quot;3&quot; (Chunk &quot;4&quot; (Chunk &quot;5&quot; (Chunk &quot;6&quot; (Chunk &quot;7&quot; (Chunk &quot;8&quot; (Chunk &quot;9&quot; (Chunk &quot;:&quot; (Chunk &quot;;&quot; (Chunk &quot;&lt;&quot;</span><br><span class="hljs-string">Empty))))))))))</span><br><span class="hljs-string">ghci&gt; foldr B.cons&#x27;</span> B.empty [50..60]<br>Chunk <span class="hljs-string">&quot;23456789:;&lt;&quot;</span> Empty<br></code></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><code>ByteString</code> 模块中还有很多像 <code>Data.List</code> 中的函数, 如 <code>head</code>, <code>tail</code>, <code>init</code>, <code>null</code> 等等. 也有很多像 <code>System.IO</code> 中的函数.</p>
<p>比如实现 <code>System.Directory</code> 模块中的 <code>copyFile</code> 函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.Environment<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.ByteString.Lazy <span class="hljs-keyword">as</span> B<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    (fileName1:fileName2:_) &lt;- getArgs<br>    copyFile fileName1 fileName2<br><br><span class="hljs-title">copyFile</span> :: <span class="hljs-type">FilePath</span> -&gt; <span class="hljs-type">FilePath</span> -&gt; <span class="hljs-type">IO</span> ()<br><span class="hljs-title">copyFile</span> source dest = <span class="hljs-keyword">do</span><br>    contents &lt;- <span class="hljs-type">B</span>.readFile source<br>    <span class="hljs-type">B</span>.writeFile dest contents<br></code></pre></td></tr></table></figure>

<h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><p><code>IO</code> 或者 pure code 都有可能会发生 Exceptions (例外):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; 4 `div` 0<br>*** Exception: divide by zero<br>ghci&gt; <span class="hljs-built_in">head</span> []<br>*** Exception: Prelude.<span class="hljs-built_in">head</span>: empty list<br></code></pre></td></tr></table></figure>

<p>但尽量不在 pure code 中使用 <code>Exception</code>, 更好的是利用 Haskell 的类型系统, 使用 <code>Either</code> 或 <code>Maybe</code> 之类的类型来表示可能的失败.</p>
<p>下面是一个 I&#x2F;O Exception 的示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.Environment<br><span class="hljs-keyword">import</span> System.IO<br><span class="hljs-keyword">import</span> System.Directory<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span> (fileName:_) &lt;- getArgs<br>            fileExists &lt;- doesFileExist fileName<br>            <span class="hljs-keyword">if</span> fileExists<br>                <span class="hljs-keyword">then</span> <span class="hljs-keyword">do</span> contents &lt;- readFile fileName<br>                    putStrLn $ <span class="hljs-string">&quot;The file has &quot;</span> ++ show (length (lines contents)) ++ <span class="hljs-string">&quot; lines!&quot;</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">do</span> putStrLn <span class="hljs-string">&quot;The file doesn&#x27;t exist!&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>doesFileExist</code> 的类型是 <code>doesFileExist :: FilePath -&gt; IO Bool</code>, 注意其返回的是一个 <code>I/O action</code> 并包含值, 因此不能直接在 <code>if expression</code> 中使用</li>
</ul>
<p>另一种输出错误消息的方法需要借助 <code>System.IO.Error</code> 中的 <code>catch</code> 函数, 其类型是 <code>catch :: IO a -&gt; (IOError -&gt; IO a) -&gt; IO a</code>, 其接受两个参数:</p>
<ul>
<li>第一个是一个 <code>I/O action</code>, 比如一个打开文件的 <code>I/O action</code>, 类似其他语言的 <code>try</code> 部分</li>
<li>第二个是 handler 函数, 如果第一个参数的 <code>I/O action</code> 丢出了 <code>Exception</code>, 那么就会传递给 handler 来处理, 因此 <code>catch</code> 的输出就是 <code>handler</code> 的输出</li>
<li><code>IOError</code> 代表一个 <code>I/O exception</code> 已经发生, 其附带 exception 的信息</li>
</ul>
<p>示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.Environment<br><span class="hljs-keyword">import</span> System.IO<br><span class="hljs-keyword">import</span> System.IO.Error<br><br><span class="hljs-title">main</span> = toTry `catch` handler<br><br><span class="hljs-title">toTry</span> :: <span class="hljs-type">IO</span> ()<br><span class="hljs-title">toTry</span> = <span class="hljs-keyword">do</span> (fileName:_) &lt;- getArgs<br>            contents &lt;- readFile fileName<br>            putStrLn $ <span class="hljs-string">&quot;The file has &quot;</span> ++ show (length (lines contents)) ++ <span class="hljs-string">&quot; lines!&quot;</span><br><br><span class="hljs-title">handler</span> :: <span class="hljs-type">IOError</span> -&gt; <span class="hljs-type">IO</span> ()<br><span class="hljs-title">handler</span> e = putStrLn <span class="hljs-string">&quot;Whoops, had some trouble!&quot;</span><br></code></pre></td></tr></table></figure>

<p>也可以根据错误类型来输出:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.Environment<br><span class="hljs-keyword">import</span> System.IO<br><span class="hljs-keyword">import</span> System.IO.Error<br><br><span class="hljs-title">main</span> = toTry `catch` handler<br><br><span class="hljs-title">toTry</span> :: <span class="hljs-type">IO</span> ()<br><span class="hljs-title">toTry</span> = <span class="hljs-keyword">do</span> (fileName:_) &lt;- getArgs<br>            contents &lt;- readFile fileName<br>            putStrLn $ <span class="hljs-string">&quot;The file has &quot;</span> ++ show (length (lines contents)) ++ <span class="hljs-string">&quot; lines!&quot;</span><br><br><span class="hljs-title">handler</span> :: <span class="hljs-type">IOError</span> -&gt; <span class="hljs-type">IO</span> ()<br><span class="hljs-title">handler</span> e<br>    | isDoesNotExistError e = putStrLn <span class="hljs-string">&quot;The file doesn&#x27;t exist!&quot;</span><br>    | otherwise = ioError e<br></code></pre></td></tr></table></figure>
<p><code>isDoesNotExistError :: IOError -&gt; Bool</code> 是一个断言函数, 其他常见的断言函数还有:</p>
<ul>
<li><code>isAlreadyExistsError</code></li>
<li><code>isDoesNotExistError</code></li>
<li><code>isFullError</code></li>
<li><code>isEOFError</code></li>
<li><code>isIllegalOperation</code></li>
<li><code>isPermissionError</code></li>
<li><code>isUserError</code></li>
</ul>
<p>相对应的, 可以用 <code>userError</code>, <code>ioError</code> 等函数来抛出 exception.</p>
<p><code>System.IO.Error</code> 还提供了很多 <code>ioe</code> 开头的函数, 用于从 <code>IOError</code> 中抽取出一些信息, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> System.Environment<br><span class="hljs-keyword">import</span> System.IO<br><span class="hljs-keyword">import</span> System.IO.Error<br><br><span class="hljs-title">main</span> = toTry `catch` handler<br><br><span class="hljs-title">toTry</span> :: <span class="hljs-type">IO</span> ()<br><span class="hljs-title">toTry</span> = <span class="hljs-keyword">do</span> (fileName:_) &lt;- getArgs<br>    contents &lt;- readFile fileName<br>    putStrLn $ <span class="hljs-string">&quot;The file has &quot;</span> ++ show (length (lines contents)) ++ <span class="hljs-string">&quot; lines!&quot;</span><br><br><span class="hljs-title">handler</span> :: <span class="hljs-type">IOError</span> -&gt; <span class="hljs-type">IO</span> ()<br><span class="hljs-title">handler</span> e<br>    | isDoesNotExistError e =<br>        <span class="hljs-keyword">case</span> ioeGetFileName e <span class="hljs-keyword">of</span> <span class="hljs-type">Just</span> path -&gt; putStrLn $ <span class="hljs-string">&quot;Whoops! File does not exist at: &quot;</span> ++ path<br>                                 <span class="hljs-type">Nothing</span> -&gt; putStrLn <span class="hljs-string">&quot;Whoops! File does not exist at unknown location!&quot;</span><br>    | otherwise = ioError e<br></code></pre></td></tr></table></figure>

<h1 id="Haskell-Functors-Applicative-Functors-和-Monoids"><a href="#Haskell-Functors-Applicative-Functors-和-Monoids" class="headerlink" title="Haskell Functors, Applicative Functors 和 Monoids"></a>Haskell Functors, Applicative Functors 和 Monoids</h1><p>在 Haskell 中, <code>Functor</code> 是一个 typeclass, 为 “可映射的容器” 提供一种统一的抽象: 在不改变容器结构的前提下, 对其中的值应用一个函数. 比如 <code>List</code>, <code>Maybe</code>, <code>Tree</code> 等等都属于 <code>Functor</code> typeclass 中.</p>
<p><code>Functor</code> typeclass 只有一个 method, 叫 <code>fmap</code>, 类型是 <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>, 可以这样描述: 给一个从 <code>a</code> 映射到 <code>b</code> 的函数, 以及一个装了 <code>a</code> 的盒子, 会返回一个装了 <code>b</code> 的盒子, 就好像用这个函数将每个元素都转成了 <code>b</code> 一样.</p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><code>IO</code> 也是 <code>Functor</code> 的 <code>instance</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">IO</span> <span class="hljs-keyword">where</span></span><br>    fmap f action = <span class="hljs-keyword">do</span><br>        result &lt;- action<br>        return (f result)<br></code></pre></td></tr></table></figure>
<ul>
<li>对一个 <code>I/O action</code> 做 map over 的结果仍然是 <code>I/O action</code></li>
<li><code>f</code> 是一个函数, <code>action</code> 是一个 <code>I/O action</code></li>
<li>先执行传入的 <code>I/O action</code>, 并将结果绑定成 <code>result</code></li>
<li><code>return</code> 会将其参数用 <code>I/O</code> 包裹并返回, <code>(f result)</code> 返回一个具体的类别</li>
<li><code>do block</code> 的返回值是最后一个 <code>I/O action</code> 的返回值</li>
</ul>
<p>比如将下面 <code>I/O</code> 改写为 <code>fmap</code> 的版本:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span> line &lt;- getLine<br>        <span class="hljs-keyword">let</span> line&#x27; = reverse line<br>        putStrLn $ <span class="hljs-string">&quot;You said &quot;</span> ++ line&#x27; ++ <span class="hljs-string">&quot; backwards!&quot;</span><br>        putStrLn $ <span class="hljs-string">&quot;Yes, you really said &quot;</span> ++ line&#x27; ++ <span class="hljs-string">&quot; backwards!&quot;</span><br></code></pre></td></tr></table></figure>

<p>改写为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span> line &lt;- fmap reverse getLine  <br>            putStrLn $ <span class="hljs-string">&quot;You said &quot;</span> ++ line ++ <span class="hljs-string">&quot; backwards!&quot;</span>  <br>            putStrLn $ <span class="hljs-string">&quot;Yes, you really said&quot;</span> ++ line ++ <span class="hljs-string">&quot; backwards!&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>getLine</code> 的类型是 <code>IO String</code></li>
<li><code>fmap reverse getLine</code> 的返回值也是 <code>IO String</code></li>
<li>把这里 <code>fmap</code> 的类型限定在 <code>IO</code> 可以看作是: <code>fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b</code></li>
</ul>
<p>如果你将 <code>IO action</code> 绑定到一个名称只是为了应用一个函数的话, 就可以考虑直接用 <code>fmap</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> Data.Char  <br><span class="hljs-keyword">import</span> Data.List  <br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span> line &lt;- fmap (intersperse &#x27;-&#x27; . reverse . map toUpper) getLine  <br>          putStrLn line<br></code></pre></td></tr></table></figure>

<h2 id="gt-r"><a href="#gt-r" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h2><p>一个类型描述 <code>r -&gt; a</code> 可以写成 <code>(-&gt;) r a</code>, 其本质就是一个接受两个参数的 type constructor.</p>
<p>由于 <code>Functor</code> 的 <code>instance</code> 需要时接受一个参数的 type constructor, 因此需要构造 <code>(-&gt;) r</code>, 此时就只接受一个参数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> ((-&gt;) r) <span class="hljs-keyword">where</span></span><br>    fmap f g = (\x -&gt; f (g x))<br></code></pre></td></tr></table></figure>
<p><code>fmap</code> 的类型是 <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>, 把这里的 <code>f</code> 替换为 <code>(-&gt;) r</code> 可以得到 <code>fmap :: (a -&gt; b) -&gt; (-&gt;) r a -&gt; (-&gt;) r b</code>, 把 <code>(-&gt;) r a</code> 换成 <code>r -&gt; a</code> 的形式, 有 <code>fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</code>.</p>
<p>可以看出这里将一个函数映射为另一个函数. 类似将一个 List 映射为另一个 List, 将一个 <code>Maybe</code> 映射为另一个 <code>Maybe</code>.</p>
<p>从参数, 将一个从 <code>a</code> 到 <code>b</code> 的 function 以及一个从 <code>r</code> 到 <code>a</code> 的 function 映射到一个从 <code>r</code> 到 <code>b</code> 的 function, 这就是 function composition (先执行 <code>r -&gt; a</code> 然后执行 <code>a -&gt; b</code> 的类型就是 <code>r -&gt; b</code>).</p>
<h2 id="Functor-本质"><a href="#Functor-本质" class="headerlink" title="Functor 本质"></a>Functor 本质</h2><p><code>Functor</code> 更准确的理解是: 其代表一个计算的上下文, 是一个 computation. 毕竟 <code>Functor</code> 这个 typeclass 里只有 <code>fmap</code> 这一个函数, <code>fmap</code> 就用来描述这个 computation. 传给 <code>fmap</code> 的函数就是执行这个 computation 的主体.</p>
<p>比如:</p>
<ul>
<li><code>Maybe</code> 是一个可能失败的计算</li>
<li><code>[]</code> 是一个非确定的计算 (有多个可能的结果)</li>
<li><code>IO</code> 是一个带副作用的计算</li>
</ul>
<p><code>fmap</code> 的类型是 <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>, 可以理解为接受一个 <code>a -&gt; b</code> 的函数, 返回一个 <code>f a -&gt; f b</code> 的函数, 这样的动作也称 <code>lifting</code>. 把一个函数 <code>lift</code> 到可以在 <code>functors</code> 上面操作.</p>
<h2 id="Functor-laws"><a href="#Functor-laws" class="headerlink" title="Functor laws"></a>Functor laws</h2><p>一个东西要成为 <code>functor</code>, 必须要遵守某些定律:</p>
<ol>
<li>对 <code>functor</code> 调用 <code>fmap id</code>, 应该等同于直接对 <code>functor</code> 调用 <code>id</code>, 即 <code>fmap id = id</code>:</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; fmap <span class="hljs-built_in">id</span> (Just 3)  <br>Just 3  <br>ghci&gt; <span class="hljs-built_in">id</span> (Just 3)  <br>Just 3  <br>ghci&gt; fmap <span class="hljs-built_in">id</span> [1..5]  <br>[1,2,3,4,5]  <br>ghci&gt; <span class="hljs-built_in">id</span> [1..5]  <br>[1,2,3,4,5]  <br>ghci&gt; fmap <span class="hljs-built_in">id</span> []  <br>[]  <br>ghci&gt; fmap <span class="hljs-built_in">id</span> Nothing  <br>Nothing<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>将两个函数合并之后 map over 一个 functor 的结果, 应该等价于先将第一个函数 map over 一个 functor, 再将第二个函数 map over 那个 functor 的结果, 即 <code>fmap (f . g) = fmap f . fmap g</code></li>
</ol>
<h2 id="Applicative-functors"><a href="#Applicative-functors" class="headerlink" title="Applicative functors"></a>Applicative functors</h2><p><code>Applicative functors</code> 是加强版的 <code>functors</code>, 其定义为 <code>Control.Applicative</code> 中的 <code>Applicative</code> typeclass:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> (<span class="hljs-type">Functor</span> <span class="hljs-title">f</span>) =&gt; <span class="hljs-type">Applicative</span> f <span class="hljs-keyword">where</span></span>  <br>    pure :: a -&gt; f a  <br>    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b<br></code></pre></td></tr></table></figure>
<ul>
<li><code>pure</code> 将一个值映射为包含该值的 <code>functor</code>. 可以理解为将 <code>a</code> 放入一个默认的 compute context 中</li>
<li><code>&lt;*&gt;</code> 是加强版的 <code>fmap</code>, 其接受一个包含函数的 functor 和包含值的 functor, 用第一个 functor 中的函数对第二个 functor 中的值做 map over 操作</li>
</ul>
<p>比如 <code>Maybe</code> 的 Applicative 实现:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> <span class="hljs-type">Maybe</span> <span class="hljs-keyword">where</span></span><br>    pure = <span class="hljs-type">Just</span><br>    <span class="hljs-type">Nothing</span> &lt;*&gt; _ = <span class="hljs-type">Nothing</span><br>    (<span class="hljs-type">Just</span> f) &lt;*&gt; something = fmap f something<br></code></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Just (+3) &lt;*&gt; Just 9  <br>Just 12  <br>ghci&gt; pure (+3) &lt;*&gt; Just 10  <br>Just 13  <br>ghci&gt; pure (+3) &lt;*&gt; Just 9  <br>Just 12  <br>ghci&gt; Just (++<span class="hljs-string">&quot;hahah&quot;</span>) &lt;*&gt; Nothing  <br>Nothing  <br>ghci&gt; Nothing &lt;*&gt; Just <span class="hljs-string">&quot;woot&quot;</span>  <br>Nothing<br></code></pre></td></tr></table></figure>

<p>还能这样写:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5  <br>Just 8  <br>ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Nothing  <br>Nothing  <br>ghci&gt; pure (+) &lt;*&gt; Nothing &lt;*&gt; Just 5  <br>Nothing<br></code></pre></td></tr></table></figure>

<p><code>Control.Applicative</code> 中定义的 <code>&lt;$&gt;</code> 函数是中缀版的 <code>fmap</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell">(&lt;$&gt;) :: (<span class="hljs-type">Functor</span> f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b<br><span class="hljs-title">f</span> &lt;$&gt; x = fmap f x<br></code></pre></td></tr></table></figure>

<p>如果 <code>f</code> 接受 3 个 applicative functor, 则可以这样写: <code>f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z</code>.</p>
<p>下面是一个 <code>f</code> 接受两个 applicative functor 的例子:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; (++) &lt;$&gt; Just <span class="hljs-string">&quot;johntra&quot;</span> &lt;*&gt; Just <span class="hljs-string">&quot;volta&quot;</span>  <br>Just <span class="hljs-string">&quot;johntravolta&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这种形式就像函数一个一个吃掉参数</li>
</ul>
<p><code>List</code> 也是 applicative functor:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> [] <span class="hljs-keyword">where</span></span>  <br>    pure x = [x]  <br>    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]<br></code></pre></td></tr></table></figure>
<ul>
<li>每个函数都会与每个元素产生一个值</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [(*0),(+100),(^2)] &lt;*&gt; [1,2,3]  <br>[0,0,0,101,102,103,1,4,9]<br></code></pre></td></tr></table></figure>

<p><code>IO</code> 也是 <code>Applicative</code> 的 instance:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> <span class="hljs-type">IO</span> <span class="hljs-keyword">where</span></span><br>    pure = return<br>    a &lt;*&gt; b = <span class="hljs-keyword">do</span><br>        f &lt;- a<br>        x &lt;- br<br>        return (f x)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>a</code> 是包裹函数的 <code>I/O action</code></li>
<li><code>b</code> 是包裹一个值的 <code>I/O action</code></li>
<li>这里 <code>&lt;*&gt;</code> 的类型是 <code>&lt;*&gt; :: IO (a -&gt; b) -&gt; IO a -&gt; IO b</code></li>
</ul>
<p>可以将下面例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">myAction</span> :: <span class="hljs-type">IO</span> <span class="hljs-type">String</span><br><span class="hljs-title">myAction</span> = <span class="hljs-keyword">do</span><br>    a &lt;- getLine<br>    b &lt;- getLine<br>    return $ a ++ b<br></code></pre></td></tr></table></figure>

<p>写为 applicative style:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">myAction</span> :: <span class="hljs-type">IO</span> <span class="hljs-type">String</span><br><span class="hljs-title">myAction</span> = (++) &lt;$&gt; getLine &lt;*&gt; getLine<br></code></pre></td></tr></table></figure>

<p><code>(-&gt;) r</code> 的例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> ((-&gt;) r) <span class="hljs-keyword">where</span></span><br>    pure x = (\_ -&gt; x)<br>    f &lt;*&gt; g = \x -&gt; f x (g x)<br></code></pre></td></tr></table></figure>

<h2 id="newtype"><a href="#newtype" class="headerlink" title="newtype"></a>newtype</h2><p><code>newtype</code> 可以基于一个现有类型构造一个新类型, 限制是只能用一个值构造子跟单一字段, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">CharList</span> = <span class="hljs-type">CharList</span> &#123; <span class="hljs-title">getCharList</span> :: [<span class="hljs-type">Char</span>] &#125; <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Eq</span>, <span class="hljs-type">Show</span>)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; CharList <span class="hljs-string">&quot;this will be shown!&quot;</span>  <br>CharList &#123;getCharList = <span class="hljs-string">&quot;this will be shown!&quot;</span>&#125;  <br>ghci&gt; CharList <span class="hljs-string">&quot;benny&quot;</span> == CharList <span class="hljs-string">&quot;benny&quot;</span>  <br>True  <br>ghci&gt; CharList <span class="hljs-string">&quot;benny&quot;</span> == CharList <span class="hljs-string">&quot;oisters&quot;</span>  <br>False<br></code></pre></td></tr></table></figure>

<h2 id="Monoids"><a href="#Monoids" class="headerlink" title="Monoids"></a>Monoids</h2><p>一个 Monoid 是指类型有遵守结合率的二元函数, 并且该函数还要包含一个 identity 值. 如果某个值是函数的一个 identity, 其表示将这个值传递给函数时, 函数永远输出另一边的值, 比如 <code>1</code> 是 <code>*</code> 的 identity, 有 <code>1 * 9 = 9</code>, <code>1 * 10 = 10</code>, 永远输出另一边; 又如 <code>[]</code> 是 <code>++</code> 的 identity, 有 <code>[] ++ [1,2,3] = [1,2,3]</code>, <code>[4,5,6] ++ [] = [4,5,6]</code>.</p>
<p><code>Data.Monoid</code> 模块中定义了 <code>Monoid</code> 这个 typeclass:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Monoid</span> m <span class="hljs-keyword">where</span></span><br>    mempty :: m<br>    mappend :: m -&gt; m -&gt; m<br>    mconcat :: [m] -&gt; m<br>    mconcat = foldr mappend mempty<br></code></pre></td></tr></table></figure>
<ul>
<li><code>m</code> 是一个具体类型, 说明只有具体类型才能定义成 <code>Monoid</code> 的 <code>instance</code></li>
<li><code>mempty</code> 表示特定 <code>monoid</code> 的 identity</li>
<li><code>mappend</code> 接受两个相同类型的值并返回同样类别的值</li>
<li><code>mconcat</code> 将一组 <code>monoid</code> 值简化为单一值</li>
</ul>
<p>定义一个 monoid 需要满足:</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">mempty `mappend` x = x<br>x `mappend` mempty = x<br>(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)<br></code></pre></td></tr></table></figure>

<h3 id="Lists-are-monoids"><a href="#Lists-are-monoids" class="headerlink" title="Lists are monoids"></a>Lists are monoids</h3><p>List 是一种 monoid:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monoid</span> [a] <span class="hljs-keyword">where</span></span><br>    mempty  = []<br>    mappend = (++)<br></code></pre></td></tr></table></figure>

<p>比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [1,2,3] `mappend` [4,5,6]  <br>[1,2,3,4,5,6]  <br>ghci&gt; (<span class="hljs-string">&quot;one&quot;</span> `mappend` <span class="hljs-string">&quot;two&quot;</span>) `mappend` <span class="hljs-string">&quot;tree&quot;</span>  <br><span class="hljs-string">&quot;onetwotree&quot;</span>  <br>ghci&gt; <span class="hljs-string">&quot;one&quot;</span> `mappend` (<span class="hljs-string">&quot;two&quot;</span> `mappend` <span class="hljs-string">&quot;tree&quot;</span>)  <br><span class="hljs-string">&quot;onetwotree&quot;</span>  <br>ghci&gt; <span class="hljs-string">&quot;one&quot;</span> `mappend` <span class="hljs-string">&quot;two&quot;</span> `mappend` <span class="hljs-string">&quot;tree&quot;</span>  <br><span class="hljs-string">&quot;onetwotree&quot;</span>  <br>ghci&gt; <span class="hljs-string">&quot;pang&quot;</span> `mappend` mempty  <br><span class="hljs-string">&quot;pang&quot;</span>  <br>ghci&gt; mconcat [[1,2],[3,6],[9]]  <br>[1,2,3,6,9]  <br>ghci&gt; mempty :: [a]  <br>[]<br></code></pre></td></tr></table></figure>

<h3 id="Product-and-Sum"><a href="#Product-and-Sum" class="headerlink" title="Product and Sum"></a>Product and Sum</h3><p>数值也能表现成 monoid, 比如 <code>*</code> 是二元函数, 且有 <code>identity</code> 为 <code>1</code>; <code>+</code> 是二元函数, 且有 <code>identity</code> 为 <code>0</code>.</p>
<p><code>Data.Monoid</code> 导出了两种类型 <code>Product</code> 和 <code>Sum</code>. <code>Product</code> 的定义如下:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Product</span> a = <span class="hljs-type">Product</span> &#123; <span class="hljs-title">getProduct</span> :: <span class="hljs-title">a</span> &#125;</span><br>    <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Eq</span>, <span class="hljs-type">Ord</span>, <span class="hljs-type">Read</span>, <span class="hljs-type">Show</span>, <span class="hljs-type">Bounded</span>)<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> (<span class="hljs-type">Num</span> <span class="hljs-title">a</span>) =&gt; <span class="hljs-type">Monoid</span> (<span class="hljs-type">Product</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">where</span></span><br>    mempty = <span class="hljs-type">Product</span> <span class="hljs-number">1</span><br>    <span class="hljs-type">Product</span> x `mappend` <span class="hljs-type">Product</span> y = <span class="hljs-type">Product</span> (x * y)<br></code></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; getProduct $ Product 3 `mappend` Product 9  <br>27  <br>ghci&gt; getProduct $ Product 3 `mappend` mempty  <br>3  <br>ghci&gt; getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2  <br>24  <br>ghci&gt; getProduct . mconcat . map Product $ [3,4,2]  <br>24<br></code></pre></td></tr></table></figure>

<h3 id="Any-and-All"><a href="#Any-and-All" class="headerlink" title="Any and All"></a>Any and All</h3><p><code>Bool</code> 有两种表示成 <code>monoid</code> 的方式, 一种是将 <code>||</code> 看作二元函数, <code>False</code> 看作 <code>identity</code>. <code>Any</code> 这个 newtype 就是 <code>Monoid</code> 的一个 instance:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Any</span> = <span class="hljs-type">Any</span> &#123; <span class="hljs-title">getAny</span> :: <span class="hljs-type">Bool</span> &#125;</span><br>    <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Eq</span>, <span class="hljs-type">Ord</span>, <span class="hljs-type">Read</span>, <span class="hljs-type">Show</span>, <span class="hljs-type">Bounded</span>)<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monoid</span> <span class="hljs-type">Any</span> <span class="hljs-keyword">where</span></span><br>    mempty = <span class="hljs-type">Any</span> <span class="hljs-type">False</span><br>    <span class="hljs-type">Any</span> x `mappend` <span class="hljs-type">Any</span> y = <span class="hljs-type">Any</span> (x || y)<br></code></pre></td></tr></table></figure>

<p>另一种是将 <code>&amp;&amp;</code> 看作二元函数, <code>True</code> 看作 <code>identity</code>. <code>All</code> 的定义如下:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">All</span> = <span class="hljs-type">All</span> &#123; <span class="hljs-title">getAll</span> :: <span class="hljs-type">Bool</span> &#125;    </span><br>    <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Eq</span>, <span class="hljs-type">Ord</span>, <span class="hljs-type">Read</span>, <span class="hljs-type">Show</span>, <span class="hljs-type">Bounded</span>)<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monoid</span> <span class="hljs-type">All</span> <span class="hljs-keyword">where</span></span><br>    mempty = <span class="hljs-type">All</span> <span class="hljs-type">True</span><br>    <span class="hljs-type">All</span> x `mappend` <span class="hljs-type">All</span> y = <span class="hljs-type">All</span> (x &amp;&amp; y)<br></code></pre></td></tr></table></figure>

<h3 id="The-Ordering-monoid"><a href="#The-Ordering-monoid" class="headerlink" title="The Ordering monoid"></a>The Ordering monoid</h3><p><code>Ordering</code> 类型也具有 monoid 的性质:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monoid</span> <span class="hljs-type">Ordering</span> <span class="hljs-keyword">where</span></span><br>    mempty = <span class="hljs-type">EQ</span><br>    <span class="hljs-type">LT</span> `mappend` _ = <span class="hljs-type">LT</span><br>    <span class="hljs-type">EQ</span> `mappend` y = y<br>    <span class="hljs-type">GT</span> `mappend` _ = <span class="hljs-type">GT</span><br></code></pre></td></tr></table></figure>
<ul>
<li>定义为: 当 <code>mappend</code> 两个 <code>Ordering</code> 类型值时, 保留左边的值, 除非左边是 <code>EQ</code></li>
</ul>
<h3 id="Maybe-the-monoid"><a href="#Maybe-the-monoid" class="headerlink" title="Maybe the monoid"></a>Maybe the monoid</h3><p><code>Maybe a</code> 也有多种方式表现成 <code>Monoid</code>, 一种是将 <code>a</code> 视作是 monoid, 然后将 <code>mappend</code> 实现为使用 <code>Just</code> 包裹的值的 <code>mappend</code>, 且将 <code>Nothing</code> 作为 identity:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monoid</span> a =&gt; <span class="hljs-type">Monoid</span> (<span class="hljs-type">Maybe</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">where</span></span>  <br>    mempty = <span class="hljs-type">Nothing</span>  <br>    <span class="hljs-type">Nothing</span> `mappend` m = m  <br>    m `mappend` <span class="hljs-type">Nothing</span> = m  <br>    <span class="hljs-type">Just</span> m1 `mappend` <span class="hljs-type">Just</span> m2 = <span class="hljs-type">Just</span> (m1 `mappend` m2)<br></code></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Nothing `mappend` Just <span class="hljs-string">&quot;andy&quot;</span>  <br>Just <span class="hljs-string">&quot;andy&quot;</span>  <br>ghci&gt; Just LT `mappend` Nothing  <br>Just LT  <br>ghci&gt; Just (Sum 3) `mappend` Just (Sum 4)  <br>Just (Sum &#123;getSum = 7&#125;)<br></code></pre></td></tr></table></figure>

<h1 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h1><p>Monad 可以看作是一种加强版的 <code>Applicative Functor</code>.</p>
<p>一个 applicative value 可以看作是附有 context 的值, 比如 <code>a</code> 只是一个普通的字符, 但 <code>Just &#39;a&#39;</code> 是一个附加了 <code>context</code> 的字符. 他不是 <code>Char</code> 而是 <code>Maybe Char</code>, 这种类型告诉我们这个值可能是一个字符, 也可能什么都没有.</p>
<p>Monad 考虑的问题是: 如果有一个具有 context 的值 <code>m a</code>, 如何用只接受普通值的函数来处理, 并返回一个具有 context 的值. 也就是说, 要求函数类型如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">(&gt;&gt;=) :: (<span class="hljs-type">Monad</span> m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b<br></code></pre></td></tr></table></figure>
<ul>
<li><code>&gt;&gt;=</code> 被称呼为 <code>bind</code></li>
</ul>
<h2 id="Monad-typeclass"><a href="#Monad-typeclass" class="headerlink" title="Monad typeclass"></a>Monad typeclass</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Monad</span> m <span class="hljs-keyword">where</span></span><br>    return :: a -&gt; m a<br><br>    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b<br>    (&gt;&gt;)  :: m a -&gt; m b -&gt; m b<br>    x &gt;&gt; y = x &gt;&gt;= \_ =&gt; y<br><br>    fail :: <span class="hljs-type">String</span> -&gt; m a<br>    fail msg = error msg<br></code></pre></td></tr></table></figure>
<p>虽然每个 Monad 都是 applicative functor, 但这里的 <code>m</code> 并没有添加这个类型限制.</p>
<ul>
<li>第一个函数 <code>return</code> 等价于 <code>pure</code>, 其接受一个普通值并把他放进一个最小的 <code>context</code> 中. 也就是说它把一个普通值包在一个 monad 里</li>
<li>第二个函数是 bind <code>&gt;&gt;=</code>, 接受一个 monadic value, 把它喂给一个接受普通值的函数, 并回传一个 monadic value</li>
<li><code>&gt;&gt;</code> 暂时不了解</li>
<li><code>fail</code> 函数被 Haskell 用在处理语法错误的情况</li>
</ul>
<p><code>Maybe</code> 是 Monad 的 <code>instance</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> <span class="hljs-type">Maybe</span> <span class="hljs-keyword">where</span></span><br>    return x = <span class="hljs-type">Just</span> x<br>    <span class="hljs-type">Nothing</span> &gt;&gt;= f = <span class="hljs-type">Nothing</span><br>    <span class="hljs-type">Just</span> x &gt;&gt;= f = f x<br>    fail _ = <span class="hljs-type">Nothing</span><br></code></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">return</span> <span class="hljs-string">&quot;WHAT&quot;</span> :: Maybe String  <br>Just <span class="hljs-string">&quot;WHAT&quot;</span>  <br>ghci&gt; Just 9 &gt;&gt;= \x -&gt; <span class="hljs-built_in">return</span> (x*10)  <br>Just 90  <br>ghci&gt; Nothing &gt;&gt;= \x -&gt; <span class="hljs-built_in">return</span> (x*10)  <br>Nothing<br></code></pre></td></tr></table></figure>

<h2 id="do-表示法"><a href="#do-表示法" class="headerlink" title="do 表示法"></a>do 表示法</h2><p><code>do</code> 不只可以用在 <code>IO</code> 上, 还可以用在任何 <code>monad</code> 上, 可以把 monadic value 串成一串.</p>
<p>比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">foo</span> :: <span class="hljs-type">Maybe</span> <span class="hljs-type">String</span>  <br><span class="hljs-title">foo</span> = <span class="hljs-type">Just</span> <span class="hljs-number">3</span>   &gt;&gt;= (\x -&gt; <br>      <span class="hljs-type">Just</span> <span class="hljs-string">&quot;!&quot;</span> &gt;&gt;= (\y -&gt; <br>      <span class="hljs-type">Just</span> (show x ++ y)))<br></code></pre></td></tr></table></figure>

<p>可以用 <code>do</code> 表示法改写为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">foo</span> :: <span class="hljs-type">Maybe</span> <span class="hljs-type">String</span>  <br><span class="hljs-title">foo</span> = <span class="hljs-keyword">do</span>  <br>    x &lt;- <span class="hljs-type">Just</span> <span class="hljs-number">3</span>  <br>    y &lt;- <span class="hljs-type">Just</span> <span class="hljs-string">&quot;!&quot;</span>  <br>    <span class="hljs-type">Just</span> (show x ++ y)<br></code></pre></td></tr></table></figure>

<p>在 <code>do</code> 表示法中, 每一行都是一个 monadic value, 可以用 <code>&lt;-</code> 来其绑定到一个变量. 但要注意最后一个值, 比如这里的 <code>Just (show x ++ y)</code> 不能绑定, 不然与对应 <code>&gt;&gt;=</code> 的形式不同.</p>
<p>在 <code>do</code> 表示法中还可以进行模式匹配:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">justH</span> :: <span class="hljs-type">Maybe</span> <span class="hljs-type">Char</span>  <br><span class="hljs-title">justH</span> = <span class="hljs-keyword">do</span>  <br>    (x:xs) &lt;- <span class="hljs-type">Just</span> <span class="hljs-string">&quot;hello&quot;</span>  <br>    return x<br></code></pre></td></tr></table></figure>
<p>如果模式匹配错误, 则会调用 <code>fail</code> 函数, 默认的实现如下:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">fail</span> :: (<span class="hljs-type">Monad</span> m) =&gt; <span class="hljs-type">String</span> -&gt; m a  <br><span class="hljs-title">fail</span> msg = error msg<br></code></pre></td></tr></table></figure>

<h2 id="List-Monad"><a href="#List-Monad" class="headerlink" title="List Monad"></a>List Monad</h2><p><code>Maybe</code> 包含可能会失败的 context, 而 <code>List</code> 包含 non-determinism 的 context, 比如 <code>5</code> 这样的值是 <code>deterministic</code> 的, 因为只有一个值, 结果很明确; 而 <code>[3,8,9]</code> 这样的值包含多种结果, 是 <code>non-determinism</code> 的.</p>
<p><code>List</code> 的 <code>Monad</code> instance 定义:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> [] <span class="hljs-keyword">where</span></span><br>    return x = [x]<br>    xs &gt;&gt;= f = concat (map f xs)<br>    fail _ = []<br></code></pre></td></tr></table></figure>
<ul>
<li>只包含一个元素的 list 就是最小的 context</li>
<li><code>f</code> 函数需要回传 non-deterministic value, 比如接受一个数值产生两个数值</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [3,4,5] &gt;&gt;= \x -&gt; [x,-x]  <br>[3,-3,4,-4,5,-5]<br></code></pre></td></tr></table></figure>

<p>可以用 <code>&gt;&gt;=</code> 将它们串起来:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [1,2] &gt;&gt;= \n -&gt; [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>] &gt;&gt;= \ch -&gt; <span class="hljs-built_in">return</span> (n,ch)  <br>[(1,<span class="hljs-string">&#x27;a&#x27;</span>),(1,<span class="hljs-string">&#x27;b&#x27;</span>),(2,<span class="hljs-string">&#x27;a&#x27;</span>),(2,<span class="hljs-string">&#x27;b&#x27;</span>)]<br></code></pre></td></tr></table></figure>
<p>这里 <code>return (n,ch)</code> 会从 <code>n</code> 和 <code>ch</code> 中分别取元素并产生 <code>tuple</code>, 最后构成一个 List.</p>
<p>改为 <code>do</code> 表示法:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">listOfTuples</span> :: [(<span class="hljs-type">Int</span>,<span class="hljs-type">Char</span>)]  <br><span class="hljs-title">listOfTuples</span> = <span class="hljs-keyword">do</span>  <br>    n &lt;- [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]  <br>    ch &lt;- [&#x27;a&#x27;,&#x27;b&#x27;]  <br>    return (n,ch)<br></code></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; listOfTuples<br>[(1,<span class="hljs-string">&#x27;a&#x27;</span>),(1,<span class="hljs-string">&#x27;b&#x27;</span>),(2,<span class="hljs-string">&#x27;a&#x27;</span>),(2,<span class="hljs-string">&#x27;b&#x27;</span>)]<br></code></pre></td></tr></table></figure>

<p>这个就是 list comprehension 的结果. 本质上 <code>list comprehension</code> 就是一个语法糖, 它和 <code>do</code> 表示法最终都会转换成 <code>&gt;&gt;=</code> 来计算.</p>
<h2 id="Monad-laws"><a href="#Monad-laws" class="headerlink" title="Monad laws"></a>Monad laws</h2><p>一个类型要成为 monad 的 instance, 需要满足 monad laws. 虽然 Haskell 允许任何类型成为任何 typeclass 的 instance, 但我们最好要确定它们满足了这些 laws.</p>
<h3 id="Left-identity"><a href="#Left-identity" class="headerlink" title="Left identity"></a>Left identity</h3><p>一个值, 将他用 <code>return</code> 包裹在一个默认的 context 中, 然后用 <code>&gt;&gt;=</code> 将其喂给一个函数, 得到的结果应该与直接调用函数的结果一样, 即 <code>return x &gt;&gt;= f</code> 需要等于 <code>f x</code>.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">return</span> 3 &gt;&gt;= (\x -&gt; Just (x+100000))  <br>Just 100003  <br>ghci&gt; (\x -&gt; Just (x+100000)) 3  <br>Just 100003<br>ghci&gt; <span class="hljs-built_in">return</span> <span class="hljs-string">&quot;WoM&quot;</span> &gt;&gt;= (\x -&gt; [x,x,x])  <br>[<span class="hljs-string">&quot;WoM&quot;</span>,<span class="hljs-string">&quot;WoM&quot;</span>,<span class="hljs-string">&quot;WoM&quot;</span>]  <br>ghci&gt; (\x -&gt; [x,x,x]) <span class="hljs-string">&quot;WoM&quot;</span>  <br>[<span class="hljs-string">&quot;WoM&quot;</span>,<span class="hljs-string">&quot;WoM&quot;</span>,<span class="hljs-string">&quot;WoM&quot;</span>]<br></code></pre></td></tr></table></figure>

<h3 id="Right-identity"><a href="#Right-identity" class="headerlink" title="Right identity"></a>Right identity</h3><p>如果有一个 monadic value, 并且将其用 <code>&gt;&gt;=</code> 喂给了 <code>return</code>, 那么结果就会是原有的 monadic value: <code>m &gt;&gt;= return</code> 需要等于 <code>m</code>.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; Just <span class="hljs-string">&quot;move on up&quot;</span> &gt;&gt;= (\x -&gt; <span class="hljs-built_in">return</span> x)  <br>Just <span class="hljs-string">&quot;move on up&quot;</span>  <br>ghci&gt; [1,2,3,4] &gt;&gt;= (\x -&gt; <span class="hljs-built_in">return</span> x)  <br>[1,2,3,4]  <br>ghci&gt; putStrLn <span class="hljs-string">&quot;Wah!&quot;</span> &gt;&gt;= (\x -&gt; <span class="hljs-built_in">return</span> x)  <br>Wah!<br></code></pre></td></tr></table></figure>

<p>Left identity 和 right identity 描述的都是 <code>return</code> 的行为.</p>
<h3 id="Associativity"><a href="#Associativity" class="headerlink" title="Associativity"></a>Associativity</h3><p>用 <code>&gt;&gt;=</code> 把一串 monadic function 串在一起时, 它们的先后顺序不应该影响结果: <code>(m &gt;&gt;= f) &gt;&gt;= g</code> 与 <code>m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code> 是相等的.</p>
<h2 id="Writer-Monad"><a href="#Writer-Monad" class="headerlink" title="Writer Monad"></a>Writer Monad</h2><p><code>Writer Monad</code> 是一种在计算过程中累积额外信息 (log) 的机制. 定义在 <code>Control.Monad.Writer</code> 模块中:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Writer</span> w a = <span class="hljs-type">Writer</span> &#123; <span class="hljs-title">runWriter</span> :: (<span class="hljs-title">a</span>, <span class="hljs-title">w</span>) &#125;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>a</code> 是任意类型, 表示包含的值</li>
<li><code>w</code> 表示附加信息</li>
</ul>
<p>其 <code>Monad</code> instance 的定义如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> (<span class="hljs-type">Monoid</span> <span class="hljs-title">w</span>) =&gt; <span class="hljs-type">Monad</span> (<span class="hljs-type">Writer</span> <span class="hljs-title">w</span>) <span class="hljs-keyword">where</span></span><br>    return x = <span class="hljs-type">Writer</span> (x, mempty)<br>    (<span class="hljs-type">Writer</span> (x,v)) &gt;&gt;= f = <span class="hljs-keyword">let</span> (<span class="hljs-type">Writer</span> (y, v&#x27;)) = f x <span class="hljs-keyword">in</span> <span class="hljs-type">Writer</span> (y, v `mappend` v&#x27;)<br></code></pre></td></tr></table></figure>
<ul>
<li>注意 <code>w</code> 是 <code>Monoid</code> 的 instance</li>
</ul>
<p>测试:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; runWriter (<span class="hljs-built_in">return</span> 3 :: Writer String Int)  <br>(3,<span class="hljs-string">&quot;&quot;</span>)  <br>ghci&gt; runWriter (<span class="hljs-built_in">return</span> 3 :: Writer (Sum Int) Int)  <br>(3,Sum &#123;getSum = 0&#125;)  <br>ghci&gt; runWriter (<span class="hljs-built_in">return</span> 3 :: Writer (Product Int) Int)  <br>(3,Product &#123;getProduct = 1&#125;)<br></code></pre></td></tr></table></figure>
<ul>
<li>由于 <code>Writer</code> 并没有定义成 <code>Show</code> 的 instance, 因此需要用 <code>runWriter</code> 将其转换为普通的 <code>tuple</code></li>
</ul>
<p>示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> Control.Monad.Writer  <br><br><span class="hljs-title">logNumber</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Writer</span> [<span class="hljs-type">String</span>] <span class="hljs-type">Int</span>  <br><span class="hljs-title">logNumber</span> x = <span class="hljs-type">Writer</span> (x, [<span class="hljs-string">&quot;Got number: &quot;</span> ++ show x])  <br><br><span class="hljs-title">multWithLog</span> :: <span class="hljs-type">Writer</span> [<span class="hljs-type">String</span>] <span class="hljs-type">Int</span>  <br><span class="hljs-title">multWithLog</span> = <span class="hljs-keyword">do</span>  <br>    a &lt;- logNumber <span class="hljs-number">3</span>  <br>    b &lt;- logNumber <span class="hljs-number">5</span>  <br>    return (a*b)<br></code></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; runWriter multWithLog  <br>(15,[<span class="hljs-string">&quot;Got number: 3&quot;</span>,<span class="hljs-string">&quot;Got number: 5&quot;</span>])<br></code></pre></td></tr></table></figure>

<h3 id="Adding-logging-to-programs"><a href="#Adding-logging-to-programs" class="headerlink" title="Adding logging to programs"></a>Adding logging to programs</h3><p>Haskell 提供了 <code>gcd</code> 函数 (greatest common divisor), 这里实现一个具有 <code>log</code> 功能的 <code>gcd</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">gcd&#x27;</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>  <br><span class="hljs-title">gcd&#x27;</span> a b   <br>    | b == <span class="hljs-number">0</span>    = a  <br>    | otherwise = gcd&#x27; b (a `mod` b)<br></code></pre></td></tr></table></figure>

<p>添加有 log 的版本:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> Control.Monad.Writer  <br><br><span class="hljs-title">gcd&#x27;</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Writer</span> [<span class="hljs-type">String</span>] <span class="hljs-type">Int</span>  <br><span class="hljs-title">gcd&#x27;</span> a b  <br>  | b == <span class="hljs-number">0</span> = <span class="hljs-keyword">do</span>  <br>      tell [<span class="hljs-string">&quot;Finished with &quot;</span> ++ show a]  <br>      return a  <br>  | otherwise = <span class="hljs-keyword">do</span>  <br>      tell [show a ++ <span class="hljs-string">&quot; mod &quot;</span> ++ show b ++ <span class="hljs-string">&quot; = &quot;</span> ++ show (a `mod` b)]  <br>      gcd&#x27; b (a `mod` b)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>tell</code> 实现了 <code>MonadWriter</code> typeclass, 能接受一个 monoid value, 并放入 <code>()</code> 中形成一个 <code>Writer</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; mapM_ putStrLn $ snd $ runWriter (gcd<span class="hljs-string">&#x27; 8 3)  </span><br><span class="hljs-string">8 mod 3 = 2  </span><br><span class="hljs-string">3 mod 2 = 1  </span><br><span class="hljs-string">2 mod 1 = 0  </span><br><span class="hljs-string">Finished with 1</span><br></code></pre></td></tr></table></figure>

<h2 id="Reader-Monad"><a href="#Reader-Monad" class="headerlink" title="Reader Monad"></a>Reader Monad</h2><p>Reader Monad 指, 把函数视为具有 <code>context</code> 的值.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> Control.Monad.Instances  <br><br><span class="hljs-title">addStuff</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>  <br><span class="hljs-title">addStuff</span> = <span class="hljs-keyword">do</span>  <br>  a &lt;- (*<span class="hljs-number">2</span>)  <br>  b &lt;- (+<span class="hljs-number">10</span>)  <br>  return (a+b)<br></code></pre></td></tr></table></figure>

<h2 id="State-Monad"><a href="#State-Monad" class="headerlink" title="State Monad"></a>State Monad</h2><p>由于 Haskell 的纯粹性, 其无法改变全局状态, 这让 Haskell 在一些依赖状态变化等领域上难以应用.</p>
<p>State Monad 特性就是让 Haskell 更容易地处理状态性问题, 并且让其他部分保持纯粹性. 其定义在 <code>Control.Monad.State</code> 模块中:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">State</span> s a = <span class="hljs-type">State</span> &#123; <span class="hljs-title">runState</span> :: <span class="hljs-title">s</span> -&gt; (<span class="hljs-title">a</span>,<span class="hljs-title">s</span>) &#125;</span><br></code></pre></td></tr></table></figure>
<p>一个 <code>State s a</code> 代表的是一个改变状态的操作, 其操作的状态为类型 <code>s</code>, 而产生的结果是 <code>a</code>.</p>
<p>定义为 <code>Monad</code> 的 instance 如下:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Monad</span> (<span class="hljs-type">State</span> <span class="hljs-title">s</span>) <span class="hljs-keyword">where</span></span>  <br>    return x = <span class="hljs-type">State</span> $ \s -&gt; (x,s)  <br>    (<span class="hljs-type">State</span> h) &gt;&gt;= f = <span class="hljs-type">State</span> $ \s -&gt; <span class="hljs-keyword">let</span> (a, newState) = h s  <br>                                        (<span class="hljs-type">State</span> g) = f a  <br>                                    <span class="hljs-keyword">in</span>  g newState<br></code></pre></td></tr></table></figure>

<h2 id="Error-Monad"><a href="#Error-Monad" class="headerlink" title="Error Monad"></a>Error Monad</h2><p>定义在 <code>Control.Monad.Error</code> 中有:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> (<span class="hljs-type">Error</span> <span class="hljs-title">e</span>) =&gt; <span class="hljs-type">Monad</span> (<span class="hljs-type">Either</span> <span class="hljs-title">e</span>) <span class="hljs-keyword">where</span></span>  <br>    return x = <span class="hljs-type">Right</span> x   <br>    <span class="hljs-type">Right</span> x &gt;&gt;= f = f x  <br>    <span class="hljs-type">Left</span> err &gt;&gt;= f = <span class="hljs-type">Left</span> err  <br>    fail msg = <span class="hljs-type">Left</span> (strMsg msg)<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Haskell/" class="category-chain-item">Haskell</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Haskell-基础学习</div>
      <div>http://example.com/2025/12/22/Haskell-基础学习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jie</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年12月22日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/30/Reverse-Polish-notation-form/" title="Reverse-Polish-notation-form">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Reverse-Polish-notation-form</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/22/Functional-Programming/" title="Functional-Programming">
                        <span class="hidden-mobile">Functional-Programming</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'zKurisu/comments-utterances');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Jie</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Orkarin</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
