

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/wallhaven-j5kjgy_1920x1080.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jie">
  <meta name="keywords" content="">
  
    <meta name="description" content="Haskell bookW3Cschool Haskell 教程 介绍Haskell 是一门通用的纯函数式编程语言. 其诞生于 1987 年的 “Haskell 报告”, 命名源自数学家 Haskell Curry, 旨在为函数式编程提供一个标准化的研究和实践平台. 像 C, C++, Python 这些编程语言是 “命令式编程语言”, 随着命令的执行, 计算机的状态随之发生改变. 安装在 Arc">
<meta property="og:type" content="article">
<meta property="og:title" content="Haskell-基础学习">
<meta property="og:url" content="http://example.com/2025/12/22/Haskell-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Haskell bookW3Cschool Haskell 教程 介绍Haskell 是一门通用的纯函数式编程语言. 其诞生于 1987 年的 “Haskell 报告”, 命名源自数学家 Haskell Curry, 旨在为函数式编程提供一个标准化的研究和实践平台. 像 C, C++, Python 这些编程语言是 “命令式编程语言”, 随着命令的执行, 计算机的状态随之发生改变. 安装在 Arc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/haskell-install-lsp.png">
<meta property="article:published_time" content="2025-12-22T13:17:09.000Z">
<meta property="article:modified_time" content="2025-12-28T13:51:04.497Z">
<meta property="article:author" content="Jie">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/haskell-install-lsp.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Haskell-基础学习 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<!-- hexo injector head_end start --><style>.typst-app {
  margin: 0;
  --typst-dom-scale: 1;
  /* --typst-dom-scale: 1.5; */
  margin: 5px;
}

.typst-dom-page {
  width: calc(var(--data-page-width, 100%) * var(--typst-dom-scale));
  height: calc(var(--data-page-height) * var(--typst-dom-scale));
  --data-text-width: calc(1px * var(--typst-dom-scale));
  --data-text-height: calc(1px * var(--typst-dom-scale));
}

.typst-back-canvas {
  position: absolute;
  z-index: -1;
  width: calc(var(--data-page-width, 100%) * var(--typst-dom-scale));
  height: calc(var(--data-page-height) * var(--typst-dom-scale));
  pointer-events: none;
}

.typst-svg-page {
  position: absolute;
  z-index: 0;
  width: calc(var(--data-page-width, 100%) * var(--typst-dom-scale));
  height: calc(var(--data-page-height) * var(--typst-dom-scale));
}

.typst-html-semantics {
  position: absolute;
  z-index: 2;
  width: calc(var(--data-page-width, 100%) * var(--typst-dom-scale));
  height: calc(var(--data-page-height) * var(--typst-dom-scale));
  color: transparent;
  font-family: monospace;
  white-space: pre;
  opacity: 0.62;
}

.typst-html-semantics span {
  color: transparent;
  font-family: monospace;
  transform-origin: left top;
  position: absolute;
  display: inline-block;
  left: 0;
  top: 0;
}

.typst-content-hint {
  position: absolute;
  display: inline-block;
  width: 1px;
  height: 1px;
  overflow: hidden;
}

.typst-html-semantics a {
  position: absolute;
  display: inline-block;
}

/* set transparent itself */
.typst-content-group {
  pointer-events: visible;
}

.typst-html-semantics span::-moz-selection {
  color: transparent;
  background: #7db9de;
}

.typst-html-semantics span::selection {
  color: transparent;
  background: #7db9de;
}

.typst-html-semantics *::-moz-selection {
  color: transparent;
  background: transparent;
}

.typst-html-semantics *::selection {
  color: transparent;
  background: transparent;
}

.typst-content-fallback {
  color: transparent;
  background: transparent;
}

.pseudo-link,
.typst-text {
  pointer-events: none;
}

.tsel span,
.tsel {
  left: 0;
  position: fixed;
  text-align: justify;
  white-space: pre;
  width: 100%;
  height: 100%;
  text-align-last: justify;
  color: transparent;
}
.tsel span::-moz-selection,
.tsel::-moz-selection {
  color: transparent;
  background: #7db9dea0;
}
.tsel span::selection,
.tsel::selection {
  color: transparent;
  background: #7db9dea0;
}
.pseudo-link {
  fill: transparent;
  cursor: pointer;
  pointer-events: all;
}
svg {
  fill: none;
}

.outline_glyph path,
path.outline_glyph {
  fill: var(--glyph_fill);
  stroke: var(--glyph_stroke);
}

.outline_glyph path,
path.outline_glyph {
  transition: 0.2s fill stroke;
}
.hover .typst-text {
  --glyph_fill: #66bab7;
  --glyph_stroke: #66bab7;
}

.typst-jump-ripple,
.typst-debug-react-ripple {
  width: 0;
  height: 0;
  background-color: transparent;
  position: absolute;
  border-radius: 50%;
}
.typst-jump-ripple {
  border: 1px solid #66bab7;
}
.typst-debug-react-ripple {
  border: 1px solid #cb1b45;
}
@keyframes typst-jump-ripple-effect {
  to {
    width: 10vw;
    height: 10vw;
    opacity: 0.01;
    margin: -5vw;
  }
}
@keyframes typst-debug-react-ripple-effect {
  to {
    width: 3vw;
    height: 3vw;
    opacity: 0.01;
    margin: -1.5vw;
  }
}
</style>
<script>/// https://segmentfault.com/a/1190000016574288
(function () {
  var ie = !!(window.attachEvent && !window.opera);
  var wk = /webkit\/(\d+)/i.test(navigator.userAgent) && RegExp.$1 < 525;
  var fn = [];
  var run = function () {
    for (var i = 0; i < fn.length; i++) fn[i]();
  };
  var d = document;
  d.ready = function (f) {
    if (!ie && !wk && d.addEventListener) return d.addEventListener('DOMContentLoaded', f, false);
    if (fn.push(f) > 1) return;
    if (ie)
      (function () {
        try {
          d.documentElement.doScroll('left');
          run();
        } catch (err) {
          setTimeout(arguments.callee, 0);
        }
      })();
    else if (wk)
      var t = setInterval(function () {
        if (/^(loaded|complete)$/.test(d.readyState)) clearInterval(t), run();
      }, 0);
  };
})();
</script>
<script type="module" src="/typst/typst-main.js"></script><script src="/typst/svg-utils.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jie</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/SteinsGate_all.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Haskell-基础学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-12-22 21:17" pubdate>
          2025年12月22日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          27k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          228 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Haskell-基础学习</h1>
            
            
              <div class="markdown-body">
                
                <p><a target="_blank" rel="noopener" href="https://haskellbook.com/">Haskell book</a><br><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/hsriti/r6w1aozt.html">W3Cschool Haskell 教程</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Haskell 是一门通用的纯函数式编程语言. 其诞生于 1987 年的 “Haskell 报告”, 命名源自数学家 Haskell Curry, 旨在为函数式编程提供一个标准化的研究和实践平台.</p>
<p>像 C, C++, Python 这些编程语言是 “命令式编程语言”, 随着命令的执行, 计算机的状态随之发生改变.</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在 Archlinux 上, Haskell 相关工具链可以安装如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo pacman -S ghc cabal-install<br></code></pre></td></tr></table></figure>
<ul>
<li><code>ghc</code> 是 Haskell 编译器, 包含 GHCi</li>
<li><code>cabal</code> 是 Haskell 的包管理器, 用于安装第三方库和应用程序</li>
</ul>
<p>验证安装:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghc --version   <span class="hljs-comment"># 查看 GHC 版本（如 9.6.3）</span><br>cabal --version <span class="hljs-comment"># 查看 Cabal 版本（如 3.10.2.0）</span><br>ghci --version  <span class="hljs-comment"># 查看 GHCi 版本（通常与 GHC 一致）</span><br></code></pre></td></tr></table></figure>

<p>初始化 cabal:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 初始化 Cabal 用户环境（如果首次使用）</span><br>cabal update<br><br><span class="hljs-comment"># 查看 Cabal 配置</span><br>cabal user-config init<br></code></pre></td></tr></table></figure>

<h2 id="安装-LSP"><a href="#安装-LSP" class="headerlink" title="安装 LSP"></a>安装 LSP</h2><p>先安装 <code>ghcup</code> (Glasgow Haskell Compiler UPdater), 一个用于管理 Haskell 工具链的命令行工具:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo pacman -S ghcup-hs-bin<br></code></pre></td></tr></table></figure>

<p>用 <code>ghcup</code> 来安装 lsp:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghcup install hls latest<br></code></pre></td></tr></table></figure>

<p>如果你用的 nvim, 则用 <code>mason</code> 装 <code>haskell-language-server</code> 即可.</p>
<p><img src="/../img/haskell-install-lsp.png" srcset="/img/loading.gif" lazyload></p>
<p>使用时, 需要在项目根目录添加 <code>hie.yaml</code> 文件, 内容如下:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cradle:</span><br>  <span class="hljs-attr">stack:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;./&quot;</span><br><br><span class="hljs-comment"># 或者如果是 Cabal 项目</span><br><span class="hljs-attr">cradle:</span><br>  <span class="hljs-attr">cabal:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;./&quot;</span><br></code></pre></td></tr></table></figure>

<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><p>Haskell 是惰性的, 意思是: 函数在真正需要结果以前不会被求值.</p>
<p>比如有一个 <code>list</code>: <code>xs = [1,2,3,4,5,6,7,8]</code>, 还有一个函数 <code>doubleMe</code>, 其可以将一个 list 中的所有元素都乘以 <code>2</code>, 并返回一个新的 List. 若是在命令式语言中, 把一个 list 乘以 8, 需要执行 <code>doubleMe(doubleMe(doubleMe(xs)))</code>, 会立即遍历三遍. 而在惰性语言中, 调用 <code>doubleMe</code> 时并不会立即求值.</p>
<h1 id="Hoogle"><a href="#Hoogle" class="headerlink" title="Hoogle"></a>Hoogle</h1><p>Hoogle 是一个 Haskell 专用的搜索引擎, 主要用于查找函数, 类型签名, 模块等信息.</p>
<p>可以通过 <a target="_blank" rel="noopener" href="https://hoogle.haskell.org/">https://hoogle.haskell.org</a> 在线访问.</p>
<p>也可以安装离线工具, 生成本地数据库:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装 Hoogle</span><br>cabal install hoogle<br><br><span class="hljs-comment"># 生成标准库索引</span><br>hoogle generate<br><br><span class="hljs-comment"># 启动本地服务器（默认端口 8080）</span><br>hoogle server<br></code></pre></td></tr></table></figure>

<h1 id="GHCi"><a href="#GHCi" class="headerlink" title="GHCi"></a>GHCi</h1><p>GHCi, Glasgow Haskell Compiler Interactive, 是 Haskell 官方的交互式编程环境, 用于快速测试代码片段, 调试等.</p>
<p>比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ghci<br>GHCi, version 9.6.3: https://www.haskell.org/ghc/  :? <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span><br>Prelude&gt; 1 + 2<br>3<br>Prelude&gt; map (*2) [1,2,3]<br>[2,4,6]<br>Prelude&gt; :t map  -- 查看类型<br>map :: (a -&gt; b) -&gt; [a] -&gt; [b]<br>Prelude&gt; :quit  -- 退出<br></code></pre></td></tr></table></figure>

<p>GHCi 这类交互模式通常称为 REPL, Read-Eval-Print Loop, 是交互式编程环境的核心工作模式. 几乎所有编程语言都有对应的 REPL 工具, 只是名称和用法略有不同. 比如 Haskell 使用的就是 GHCi (Glasgow Haskell Compiler Interactive).</p>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :quit<br>Leaving GHCi.<br></code></pre></td></tr></table></figure>

<h2 id="设置-prompt"><a href="#设置-prompt" class="headerlink" title="设置 prompt"></a>设置 prompt</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :<span class="hljs-built_in">set</span> prompt <span class="hljs-string">&quot;hello&gt;&quot;</span><br>hello&gt;<br></code></pre></td></tr></table></figure>

<h2 id="检查表达式类别"><a href="#检查表达式类别" class="headerlink" title="检查表达式类别"></a>检查表达式类别</h2><p>用 <code>:type</code> 或 <code>:t</code> 指令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-string">&#x27;a&#x27;</span> :: Char<br>ghci&gt; :t True   <br>True :: Bool   <br>ghci&gt; :t <span class="hljs-string">&quot;HELLO!&quot;</span>   <br><span class="hljs-string">&quot;HELLO!&quot;</span> :: [Char]<br></code></pre></td></tr></table></figure>

<p>注意, 查看中缀函数的类型时, 需要用 <code>()</code>  括起来, 比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t (==)   <br>(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool<br></code></pre></td></tr></table></figure>


<h1 id="All-You-Need-is-Lambda"><a href="#All-You-Need-is-Lambda" class="headerlink" title="All You Need is Lambda"></a>All You Need is Lambda</h1><p>这部分内容源自 “Haskell Programming from first principles” 这本书, 这里主要对相关概念做一些铺垫 (你可以选择跳过这一节).</p>
<p>函数式编程的本质是: programs are a combination of expressions. 函数也是一类 expression (将一组输入映射到一组输出).</p>
<p>在 Haskell 中, 函数是 first-class, 意思是: 可以把函数当作值来传递, 一个函数可以作为另一个函数的参数.</p>
<p>Haskell 是 pure functional language, 这里的 “pure” 也可以叫做 “referential transparency”, 表示: 对同一个函数而言, 相同的输入会得到相同的输出.</p>
<h2 id="Lambda-calculus"><a href="#Lambda-calculus" class="headerlink" title="Lambda calculus"></a>Lambda calculus</h2><p>Lambda calculus (“Lambda” 可以看作是一个函数名, “calculus” 表示这是一种计算方法) 是一个形式化系统 (formal system), 用于通过变量绑定和替换来表达计算.</p>
<p>“形式化系统” 是指一种使用纯粹符号进行推理和计算的数学框架. 可以理解为一个完全由规则和符号构成的游戏.</p>
<p>Lambda calculus 有三个基本的组件 (也称 Lambda terms):</p>
<ul>
<li>Expressions</li>
<li>Variables</li>
<li>Abstractions</li>
</ul>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;expression&gt;</span> ::= &lt;name&gt;                    (变量)<br>               | λ<span class="hljs-attribute">&lt;name&gt;</span>.<span class="hljs-attribute">&lt;expression&gt;</span>      (抽象/函数定义)<br>               | <span class="hljs-attribute">&lt;expression&gt;</span> <span class="hljs-attribute">&lt;expression&gt;</span> (应用/函数调用)<br></code></pre></td></tr></table></figure>

<p>Expressions 是另外两个组件的超集: expressions 既可以是变量, 也可以是抽象或这些东西的组合.</p>
<p>Abstraction 就是指函数, 其由 head 和 body 组成:</p>
<ul>
<li>Head: 包含一个 $\lambda$ 后跟一个变量名</li>
<li>Body: 另一个 expression</li>
</ul>
<p>比如:<br>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x . x<br>\end{aligned}<br>}<br>$$</p>
<ul>
<li>$\lambda x$ 是 head</li>
<li>$x$ 是 body</li>
<li><code>.</code> 将两部分分开</li>
</ul>
<h2 id="Beta-规约"><a href="#Beta-规约" class="headerlink" title="Beta 规约"></a>Beta 规约</h2><p>用输入表达式替换函数体内所有绑定变量的实例, 并消除函数头部的过程称 beta 规约.</p>
<p>比如:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x . x<br>\end{aligned}<br>}<br>$$</p>
<p>假如输入表达式是 <code>2</code>:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>(\lambda x . x) 2<br>\end{aligned}<br>}<br>$$</p>
<p>Beta 规约后就是: <code>2</code> (用 <code>2</code> 替换 body 内的 <code>x</code> 得到 $\lambda x . 2$, 再去掉 head 就得到结果 <code>2</code>).</p>
<p>消除头部告诉你函数已被应用到输入表达式.</p>
<p>假如输入表达式是函数 $\lambda y . y$, 则规约如下:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>(\lambda x . x) (\lambda y . y) \newline~ \newline<br>\lambda y . y<br>\end{aligned}<br>}<br>$$</p>
<p>这里引入一个新语法 <code>[x := z]</code>, 表示用 <code>z</code> 替换所有 body 中的 <code>x</code>, 因此上述规约过程可以写为:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>(\lambda x . x) (\lambda y . y) \newline~ \newline<br>[x :&#x3D; (\lambda y . y)] \newline~ \newline<br>\lambda y . y<br>\end{aligned}<br>}<br>$$</p>
<p>再看一个例子, 需要注意 lambda calculus 是左结合的:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>(\lambda x . x)(\lambda y . y)z \newline~ \newline<br>((\lambda x . x) (\lambda y . y)) z \newline~ \newline<br>[x :&#x3D; (\lambda y . y)] \newline~ \newline<br>(\lambda y . y) z \newline~ \newline<br>[y :&#x3D; z] \newline~ \newline<br>z<br>\end{aligned}<br>}<br>$$</p>
<p>Beta 规约会在没有更多 head 或者没有参数可以应用函数时停止.</p>
<p>需要注意, lambda calculus 每次只处理一个参数, <code>zz</code> 表示两个参数, <code>z(z)</code> 表示两个参数, <code>(zz)</code> 表示一个参数. 也要注意参数的处理是从左到右的, 比如 <code>ab</code>, 先处理 <code>a</code>, 再处理 <code>b</code>.</p>
<h2 id="Alpha-Equivalent"><a href="#Alpha-Equivalent" class="headerlink" title="Alpha Equivalent"></a>Alpha Equivalent</h2><p>Alpha Equivalent 指: 参数名字不重要, 只要结构相同就是同一个函数. </p>
<p>比如:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x . x \equiv \lambda y . y \equiv \lambda z . z<br>\end{aligned}<br>}<br>$$</p>
<h2 id="Free-Variable"><a href="#Free-Variable" class="headerlink" title="Free Variable"></a>Free Variable</h2><p>函数头部会告诉我们在应用函数时要替换哪些变量, 这些变量也称 “绑定变量”, 与输入表达式绑定在一起.</p>
<p>若函数主体中有头部中未命名的变量, 则称为 “自由变量”, 比如:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x . xy<br>\end{aligned}<br>}<br>$$</p>
<ul>
<li><code>x</code> 是绑定变量, 在 head 中有命名</li>
<li><code>y</code> 自由变量, 无法规约</li>
</ul>
<h2 id="Multiple-Arguments"><a href="#Multiple-Arguments" class="headerlink" title="Multiple Arguments"></a>Multiple Arguments</h2><p>每个 lambda 只能绑定一个参数并且只能接受一个参数. 如果需要多个参数, 需要写成多个嵌套的头部, 这样在消除一个头部时, 可以继续下一个. 这种转换过程称 currying.</p>
<p>比如, 下面 lambda calculus:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x y . x y<br>\end{aligned}<br>}<br>$$</p>
<p>本质上是下面的简化写法:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x . (\lambda y . x y)<br>\end{aligned}<br>}<br>$$</p>
<p>规约示例:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>\lambda x y . x y \newline~ \newline<br>(\lambda x y . x y) 1\ 2 \newline~ \newline<br>(\lambda x (\lambda y) . x y)1\ 2 \newline~ \newline<br>[x :&#x3D; 1] \newline~ \newline<br>((\lambda y). 1 y) 2 \newline~ \newline<br>[y :&#x3D; 2] \newline~ \newline<br>1\ 2<br>\end{aligned}<br>}<br>$$</p>
<h2 id="Beta-normal-form"><a href="#Beta-normal-form" class="headerlink" title="Beta normal form"></a>Beta normal form</h2><p>如果一个 lambda 不能继续进行 beta 规约 (应用 lambda 到参数) 时, 称其得到了一个完全求值的表达式, 这种形式也称 <code>beta normal form</code>.</p>
<p>比如:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(10 + 2)</span> * <span class="hljs-number">100</span> / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这个表达式已经没有任何参数了, 不能继续用一个 lambda 进行 beta 规约, 此时它处于 <code>beta normal form</code>.</li>
</ul>
<h2 id="Combinators"><a href="#Combinators" class="headerlink" title="Combinators"></a>Combinators</h2><p>如果一个 lambda 不包含自由变量, 则称其为 “Combinator (组合子)”.</p>
<p>比如下面例子是 combinators:</p>
<ul>
<li>$\lambda x . x$</li>
<li>$\lambda xy . x$</li>
<li>$\lambda x y z . x z (y z)$</li>
</ul>
<p>所有 body 中的变量都在 head 中声明过.</p>
<p>以下例子不是 combinators:</p>
<ul>
<li>$\lambda y . x$</li>
<li>$\lambda x . x z$</li>
</ul>
<h2 id="Divergence"><a href="#Divergence" class="headerlink" title="Divergence"></a>Divergence</h2><p>Divergence 意味着规约过程永不停止, 始终有可规约的 lambda 项.</p>
<p>比如下面例子:</p>
<ul>
<li>$(\lambda x . xx) (\lambda x . xx)$</li>
<li>$([x :&#x3D; (\lambda x . xx)] xx)$</li>
<li>$(\lambda x . xx) (\lambda x . xx)$</li>
</ul>
<!-- # Hello Haskell -->
<!-- 第一个 hello world 程序, 将下面代码保存到 `test.hs` 中: -->
<!---->
<!-- ```haskell -->
<!-- sayHello :: String -> IO () -->
<!-- sayHello x = putStrLn ("Hello, " ++ x ++ "!") -->
<!-- ``` -->
<!-- - `::` 之后的 `String -> IO ()` 是一个类型 -->
<!---->
<!-- 启用 `ghci` 并加载该文件: -->
<!-- ```sh -->
<!-- $ ghci -->
<!-- GHCi, version 9.6.6: https://www.haskell.org/ghc/  :? for help -->
<!-- ghci> :load test.hs -->
<!-- [1 of 2] Compiling Main             ( test.hs, interpreted ) -->
<!-- Ok, one module loaded. -->
<!-- ghci> sayHello "Jie" -->
<!-- Hello, Jie! -->
<!-- ``` -->
<!---->
<!-- ## Expressions -->
<!-- Haskell 中的一切都是 expression 或者 declaration. -->
<!---->
<!-- Expressions 可以是 values, combinations of values, or functions applied to values. 每个 expression 都会得到一个结果. -->
<!---->
<!-- 比如下面这些都是 expressions: -->
<!-- ``` -->
<!-- 1 -->
<!-- 1 + 1 -->
<!-- "Icarus" -->
<!-- ``` -->
<!---->
<!-- 当一个 expression 不能继续求值时, 就称其到达了 "Normal form", 比如 `1 + 1` 的 normal form 是 `2`. -->
<!---->
<!-- ## Functions -->
<!-- Haskell 中的 Functions 都是 curried function, 将一个接收多个参数的函数转化为嵌套的形式, 每一层处理一个参数. -->
<!---->
<!-- 在源文件中定义函数与 GHCi 中定义会有一些区别. 比如在源文件中: -->
<!---->
<!-- ```haskell -->
<!-- triple x = x * 3 -->
<!-- ``` -->
<!-- - `triple` 是函数名, Haskell 是大小写敏感的, 函数命名通常用小写字母开头 -->
<!-- - `x` 是参数 -->
<!-- - `=` 分割函数 body 部分 -->
<!-- - `x * 3` 是函数 body -->
<!---->
<!-- 在 GHCi 中定义时, 需要加上 `let` 关键字: -->
<!---->
<!-- ```haskell -->
<!-- let triple x = x * 3 -->
<!-- ``` -->
<!---->
<!-- 调用示例: -->
<!-- ```sh -->
<!-- Prelude> triple 2 -->
<!-- 6 -->
<!-- ``` -->
<!---->
<!-- 调用等价于下面规约过程: -->
<!---->
<!-- ``` -->
<!--  triple            2 -->
<!-- (triple x = x * 3) 2 -->
<!-- (triple 2 = 2 * 3) -->
<!-- 2 * 3 -->
<!-- 6 -->
<!-- ``` -->
<!---->

<h1 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h1><p>如下:</p>
<ul>
<li><code>&amp;&amp;</code> 表示 “与”</li>
<li><code>||</code> 表示 “或”</li>
<li><code>not</code> 表示 “非”, 这里与其他语言不太一样, 不是 <code>!</code></li>
<li><code>==</code> 表示相等</li>
<li><code>/=</code> 表示不相等</li>
</ul>
<h1 id="简单函数"><a href="#简单函数" class="headerlink" title="简单函数"></a>简单函数</h1><p>Haskell 中 <code>*</code> (乘法运算符) 本质也是一个函数, 两个参数把它夹在中间, 这被称为”中缀函数”. 其他大多数不能被参数夹在中间的函数称 “前缀函数”.</p>
<p>在大多数命令式编程语言中的函数调用形式通常是函数名, 括号, 以及由逗号分隔的参数表, 如: <code>hello(arg1, arg2)</code>; 而在 haskell 中, 函数的调用形式是函数名, 空格, 空格分隔的参数表, 比如: <code>hello arg1 arg2</code>.</p>
<p>几个 haskell 中的简单函数示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; succ 8<br>9<br></code></pre></td></tr></table></figure>
<ul>
<li><code>succ</code>, “successor”, 返回一个数的后继, 比如这里的 <code>8</code> 后继就是 <code>9</code></li>
</ul>
<p>接受两个参数的函数, 如 <code>min</code> 和 <code>max</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; min 9 10<br>9<br>ghci&gt; max 3.4 3.2<br>3.4<br></code></pre></td></tr></table></figure>

<p>在 Haskell 中, 函数调用有高权限, 比如下面两句是等价的:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; succ 9 + max 5 4 + 1<br>16<br>ghci&gt; (succ 9) + (max 5 4) + 1<br>16<br></code></pre></td></tr></table></figure>

<p>很多时候需要用 <code>()</code> 来改变优先级, 避免出现不符合预期的结果, 比如要取 <code>9*10</code> 的后继, 不能写为 <code>succ 9*10</code> (这个的结果是先取 <code>9</code> 的后继 <code>10</code>, 再乘以 <code>10</code>), 应该写为 <code>succ (9*10)</code>.</p>
<p>如果一个函数有两个参数, 可以用 ` 将其括起来, 然后用中缀函数的形式来调用, 比如 <code>div</code> 函数是两个整数相除得到商, 可以写为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; div 92 10<br>9<br>ghci&gt; 92 `div` 10<br>9<br></code></pre></td></tr></table></figure>

<p>需要注意, 在命令式编程中, 函数调用必须要加括号, 比如 <code>foo()</code>, <code>bar(1)</code>. 而在 haskell 中, 函数调用必须加括号, 比如 <code>bar (bar 3)</code>.</p>
<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">doubleMe</span> x = x + x<br></code></pre></td></tr></table></figure>
<p>先函数名, 然后是空格分隔的参数列表, 然后用 <code>=</code> 分隔函数签名和函数体.</p>
<ul>
<li><code>doubleMe</code> 是函数名</li>
<li><code> x</code> 是空格分隔的参数列表</li>
<li><code>=</code> 是分隔符</li>
<li><code>x + x</code> 是函数体</li>
</ul>
<p>调用示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; doubleMe 10<br>20<br></code></pre></td></tr></table></figure>

<p>两个参数的函数声明示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">doubleUs</span> x y = x*<span class="hljs-number">2</span> + y*<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>或者利用先前定义的函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">doubleUs</span> x y = doubleMe x + doubleMe y<br></code></pre></td></tr></table></figure>

<p>但其实要注意, haskell 中的函数定义是没有顺序的.</p>
<h2 id="常见谓词函数"><a href="#常见谓词函数" class="headerlink" title="常见谓词函数"></a>常见谓词函数</h2><p><code>odd</code> 判断一个数是否为奇数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; odd 9<br>True<br>ghci&gt; odd 10<br>False<br></code></pre></td></tr></table></figure>

<p><code>even</code> 判断一个数是否为偶数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; even 1<br>False<br>ghci&gt; even 2<br>True<br></code></pre></td></tr></table></figure>

<h1 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h1><p>在 haskell 中, <code>if</code> 语句的 <code>else</code> 部分是不可省略的, 因为它要求每个函数和表达式都要返回一个结果, 而 <code>if</code> 语句也是一个表达式, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">doubleSmallNumber</span> x = (<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">then</span> x <span class="hljs-keyword">else</span> x*<span class="hljs-number">2</span>) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>函数名中可以包含单引号 <code>&#39;</code>, 通常用来区分一个稍经修改, 但差别不大的函数, 比如下面的定义也是合法的:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">conanO&#x27;Brien</span> = <span class="hljs-string">&quot;It&#x27;s a-me, Conan O&#x27;Brien&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>没有参数的函数通常称 “定义”</li>
<li>首字母大写通常是不允许的</li>
</ul>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>Haskell 中的 <code>List</code> 是一种单类型的数据结构, 只能存储多个相同类型的元素, 比如一组数字或一组字符串:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">lostNumbers</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">23</span>,<span class="hljs-number">48</span>]<br></code></pre></td></tr></table></figure>
<ul>
<li>List 用 <code>[]</code> 括号包裹</li>
<li>元素用 <code>,</code> 分隔</li>
</ul>
<p>字符串实际上是一组字符的 List 的语法糖, 比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; str = <span class="hljs-string">&quot;hello&quot;</span><br>ghci&gt; str<span class="hljs-string">&#x27; = [&#x27;</span>h<span class="hljs-string">&#x27;, &#x27;</span>e<span class="hljs-string">&#x27;, &#x27;</span>l<span class="hljs-string">&#x27;, &#x27;</span>l<span class="hljs-string">&#x27;, &#x27;</span>o<span class="hljs-string">&#x27;]</span><br><span class="hljs-string">ghci&gt; str</span><br><span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-string">ghci&gt; str&#x27;</span><br><span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="List-合并"><a href="#List-合并" class="headerlink" title="List 合并"></a>List 合并</h2><p>两个 List 的合并可以用 <code>++</code> 运算符, 比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [1,2,3,4] ++ [5,6,7,8]<br>[1,2,3,4,5,6,7,8]<br>ghci&gt; <span class="hljs-string">&quot;hello&quot;</span> ++ <span class="hljs-string">&quot; &quot;</span> ++ <span class="hljs-string">&quot;world&quot;</span><br><span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>

<p>可以用 <code>:</code> 运算符向 List 前端插入一个元素, 比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt;  <span class="hljs-string">&#x27;A&#x27;</span>:<span class="hljs-string">&quot; SMALL CAT&quot;</span><br><span class="hljs-string">&quot;A SMALL CAT&quot;</span><br>ghci&gt; 1:[2,3,4,5]<br>[1,2,3,4,5]<br></code></pre></td></tr></table></figure>

<p>本质上, <code>[1,2,3]</code> 是 <code>1:2:3:[]</code> 的语法糖:</p>
<ul>
<li><code>[]</code> 是空 list</li>
<li><code>3:[]</code> 得到 <code>[3]</code></li>
<li><code>2:[3]</code> 得到 <code>[2,3]</code></li>
<li><code>1:[2,3]</code> 得到 <code>[1,2,3]</code></li>
</ul>
<h2 id="索引取元素"><a href="#索引取元素" class="headerlink" title="索引取元素"></a>索引取元素</h2><p>用 <code>!!</code> 运算符来按照索引取得 <code>List</code> 中的元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-string">&quot;Jie Orkarin&quot;</span> !! 4<br><span class="hljs-string">&#x27;O&#x27;</span><br>ghci&gt; [0,1,2,3,4] !! 3<br>3<br></code></pre></td></tr></table></figure>
<ul>
<li>注意 List 越界会报错</li>
</ul>
<h2 id="List-嵌套"><a href="#List-嵌套" class="headerlink" title="List 嵌套"></a>List 嵌套</h2><p>嵌套的 List 就是多维数组, 比如:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">ghci&gt; a = <span class="hljs-string">[[1,2,3]]</span><br>ghci&gt; [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]:a<br><span class="hljs-string">[[4,5,6,7,8],[1,2,3]]</span><br></code></pre></td></tr></table></figure>
<ul>
<li>注意就算是嵌套也需要是相同类别的元素</li>
</ul>
<h2 id="List-之间的比较"><a href="#List-之间的比较" class="headerlink" title="List 之间的比较"></a>List 之间的比较</h2><p>Haskell list 的比较规则是按照 “Lexicographic Order”, 就和在字典里查单词一样的逻辑:</p>
<ul>
<li>从左到右逐个元素比较</li>
<li>一旦发现一对不相等的元素, 就根据这对元素的大小来决定整个列表的大小</li>
<li>如果前面的所有元素都相等, 则较长的列表更大</li>
</ul>
<p>比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [3,2,1] &gt; [2,1,0]<br>True<br></code></pre></td></tr></table></figure>
<ul>
<li>第一个元素对就不等</li>
<li><code>3 &gt; 2</code>, 因此整体是 <code>[3,2,1] &gt; [2,1,0]</code></li>
</ul>
<p>其他例子:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [3,2,1] &gt; [2,10,100]<br>True<br>ghci&gt; [3,4,2] &gt; [3,4]<br>True<br>ghci&gt; [3,4,2] &gt; [4,2]<br>True<br></code></pre></td></tr></table></figure>

<h2 id="返回特定位置的元素"><a href="#返回特定位置的元素" class="headerlink" title="返回特定位置的元素"></a>返回特定位置的元素</h2><p>如 <code>head</code> 返回 List 的头部, 即首个元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">head</span> [5,4,3,2,1]<br>5<br></code></pre></td></tr></table></figure>

<p><code>tail</code> 返回 List 的尾部, 注意是去除头部元素之后的所有元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">tail</span> [5,4,3,2,1]<br>[4,3,2,1]<br></code></pre></td></tr></table></figure>

<p><code>last</code> 返回最后一个元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; last [5,4,3,2,1]<br>1<br></code></pre></td></tr></table></figure>

<p><code>init</code> 返回除去最后一个元素的部分:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; init [5,4,3,2,1]<br>[5,4,3,2]<br></code></pre></td></tr></table></figure>

<p>需要注意这几个函数作用在空 list 上时会报错.</p>
<h2 id="返回长度"><a href="#返回长度" class="headerlink" title="返回长度"></a>返回长度</h2><p><code>length</code> 函数返回一个 list 的长度:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; length [5,4,3,2,1]<br>5<br></code></pre></td></tr></table></figure>

<h2 id="是否为空"><a href="#是否为空" class="headerlink" title="是否为空"></a>是否为空</h2><p><code>null</code> 函数检查一个 List 是否为空:</p>
<ul>
<li>如果是空, 则返回 <code>True</code></li>
<li>如果不为空, 则返回 <code>False</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; null [1,2,3]<br>False<br>ghci&gt; null []<br>True<br></code></pre></td></tr></table></figure>

<h2 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h2><p><code>reverse</code> 函数将一个 List 反转:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; reverse [5,4,3,2,1]<br>[1,2,3,4,5]<br></code></pre></td></tr></table></figure>

<h2 id="返回前-n-个元素"><a href="#返回前-n-个元素" class="headerlink" title="返回前 n 个元素"></a>返回前 n 个元素</h2><p><code>take</code> 返回一个 List 的前几个元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; take 3 [5,4,3,2,1]<br>[5,4,3]<br>ghci&gt; take 5 [1,2]<br>[1,2]<br>ghci&gt; take 0 [5,4,3]<br>[]<br></code></pre></td></tr></table></figure>
<ul>
<li>取 <code>n</code> 大于 list 长度, 则返回整个 list</li>
<li>取 <code>n</code> 为 <code>0</code>, 则返回空 list</li>
</ul>
<h2 id="删除前-n-个元素"><a href="#删除前-n-个元素" class="headerlink" title="删除前 n 个元素"></a>删除前 n 个元素</h2><p><code>drop</code> 和 <code>take</code> 类似, 只不过是删除一个 List 中的前 <code>n</code> 个元素:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; drop 3 [8,4,2,1,5,6]<br>[1,5,6]<br>ghci&gt; drop 0 [1,2,3,4]<br>[1,2,3,4]<br>ghci&gt; drop 100 [1,2,3,4]<br>[]<br></code></pre></td></tr></table></figure>

<h2 id="最大最小元素"><a href="#最大最小元素" class="headerlink" title="最大最小元素"></a>最大最小元素</h2><p><code>maximum</code> 返回一个 list 中的最大元素, <code>minimum</code> 返回最小的:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; minimum [8,4,2,1,5,6]<br>1<br>ghci&gt; maximum [1,9,2,3,4]<br>9<br></code></pre></td></tr></table></figure>

<h2 id="元素之和-x2F-积"><a href="#元素之和-x2F-积" class="headerlink" title="元素之和&#x2F;积"></a>元素之和&#x2F;积</h2><p><code>sum</code> 返回一个 list 中所有元素的和:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">sum</span> [5,2,1,6,3,2,5,7]<br>31<br></code></pre></td></tr></table></figure>

<p><code>product</code> 返回一个 list 中所有元素的积:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; product [6,2,1,2]<br>24<br></code></pre></td></tr></table></figure>

<h2 id="元素是否存在"><a href="#元素是否存在" class="headerlink" title="元素是否存在"></a>元素是否存在</h2><p><code>elem</code> 函数判断一个元素是否包含于一个 List 中, 通常用中缀函数的形式调用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; 4 `elem` [1,2,3,4]<br>True<br>ghci&gt; 4 `elem` [5,6,7,8]<br>False<br></code></pre></td></tr></table></figure>

<h2 id="区间构造"><a href="#区间构造" class="headerlink" title="区间构造"></a>区间构造</h2><p>用 <code>..</code> 运算符, 比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [1..20]<br>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]<br>ghci&gt; [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;z&#x27;</span>]<br><span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br></code></pre></td></tr></table></figure>

<p>允许指定一个步长, 如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [2,4..20]<br>[2,4,6,8,10,12,14,16,18,20]<br>ghci&gt; [3,6..20]<br>[3,6,9,12,15,18]<br></code></pre></td></tr></table></figure>

<p>尽量不在这种构造中使用浮点数.</p>
<p>如果不指定上界, 则会产生一个无限长的 list, 由于 Haskell 是惰性的, 它不会对其求值, 因此是可行的.</p>
<p>如果要取 <code>24</code> 个 <code>13</code> 的倍数, 可以这样写:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; take 24 [13, 26..]<br></code></pre></td></tr></table></figure>

<p><code>cycle</code> 函数接受一个 list 作为参数, 然后循环产生一个无限 list, 因此一般需要配合 <code>take</code> 等函数来划定结束的范围:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; take 10 (cycle [1,2,3])<br>[1,2,3,1,2,3,1,2,3,1]<br></code></pre></td></tr></table></figure>

<p><code>repeat</code> 函数接受一个值作为参数, 并返回一个只包含该值的无限 List, 通常也配合 <code>take</code> 使用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; take 10 (repeat 5)<br>[5,5,5,5,5,5,5,5,5,5]<br></code></pre></td></tr></table></figure>

<h2 id="List-comprehension"><a href="#List-comprehension" class="headerlink" title="List comprehension"></a>List comprehension</h2><p>List comprehension (列表推导式) 是一种简洁的创建列表的语法. 其灵感来自数学中的 set comprehension, 比如:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>X &#x3D; \{2 \cdot x | x \in N, x \le 10\}<br>\end{aligned}<br>}<br>$$</p>
<ul>
<li>$2 \cdot x$ 是输出函数, <code>x</code> 是变量</li>
<li><code>N</code> 是输入集合, $x \le 10$ 是选择范围</li>
</ul>
<p>在 Haskell 中, 可以写为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [x*2 | x &lt;- [1..10]]<br>[2,4,6,8,10,12,14,16,18,20]<br></code></pre></td></tr></table></figure>
<ul>
<li><code>|</code> 之前的是 “输出函数”</li>
<li><code>x &lt;- [1..10]</code> 是 <code>x</code> 的取值范围</li>
</ul>
<p>可以添加限制条件, 条件与取值范围之间用 <code>,</code> 分隔:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [x*2 | x &lt;- [1..10], x*2 &gt;= 12]<br></code></pre></td></tr></table></figure>
<ul>
<li>从 list 中筛选符合限制条件的操作也称为 “filtering”</li>
</ul>
<p>也可以从多个 <code>list</code> 中构建:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]   <br>[16,20,22,40,50,55,80,100,110]  <br></code></pre></td></tr></table></figure>

<p>用这个语法创建一个 <code>length</code> 函数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">length<span class="hljs-string">&#x27; = sum [1 | _ &lt;- xs]</span><br></code></pre></td></tr></table></figure>

<h1 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h1><p>Tuple 中的元素可以是多种类型, 需要注意, tuple 的长度信息比较重要, 比如常说 “二元组 (两个元素的 tuple)”, “三元组 (三个元素的 tuple)”.</p>
<p>比如:</p>
<ul>
<li><code>[(1,2), (8,11), (4,5)]</code> 是合法的, 但 <code>[(1,2), (8,11,5), (4,5)]</code> 是非法的, 因为 “二元组” 和 “三元组” 是不同的类别, 报错可能如下:</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Couldn&#x27;t</span> match expected <span class="hljs-class"><span class="hljs-keyword">type</span> `(<span class="hljs-title">t</span>, <span class="hljs-title">t1</span>)&#x27;   </span><br><span class="hljs-title">against</span> inferred <span class="hljs-class"><span class="hljs-keyword">type</span> `(<span class="hljs-title">t2</span>, <span class="hljs-title">t3</span>, <span class="hljs-title">t4</span>)&#x27;   </span><br><span class="hljs-type">In</span> the expression: (<span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>)   <br><span class="hljs-type">In</span> the expression: [(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)]   <br><span class="hljs-type">In</span> the definition <span class="hljs-keyword">of</span> `it&#x27;: it = [(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)]<br></code></pre></td></tr></table></figure>

<p><code>(1,2)</code> 和 <code>(&quot;one&quot;, 2)</code> 也是不同的类别, 如: <code>[(1,2), (&quot;one&quot;,2)]</code> 就会报错.</p>
<h2 id="二元组操作"><a href="#二元组操作" class="headerlink" title="二元组操作"></a>二元组操作</h2><p>对于 “二元组”, 有几个常用函数:</p>
<ul>
<li><code>fst</code>, 即 “first”, 返回一个序对的首项:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; fst (8,11)<br>8<br></code></pre></td></tr></table></figure>

<ul>
<li><code>snd</code>, 即 “second”, 返回一个序对的尾项</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; snd (8,11)<br>11<br></code></pre></td></tr></table></figure>

<ul>
<li><code>zip</code> 可以用来生成一组 Pair (二元组) 的 List。 其取两个 List, 然后将它们交叉配对</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; zip [1,2,3,4,5] [5,5,5,5,5]<br>[(1,5),(2,5),(3,5),(4,5),(5,5)]<br>ghci&gt; zip [1 .. 5] [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>]   <br>[(1,<span class="hljs-string">&quot;one&quot;</span>),(2,<span class="hljs-string">&quot;two&quot;</span>),(3,<span class="hljs-string">&quot;three&quot;</span>),(4,<span class="hljs-string">&quot;four&quot;</span>),(5,<span class="hljs-string">&quot;five&quot;</span>)]<br></code></pre></td></tr></table></figure>

<p>如果参数中的两个 list 长度不同, 则会从中间断开, 匹配短的那个:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; zip [5,3,2,6,2,7,2,5,4,6,6] [<span class="hljs-string">&quot;im&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;turtle&quot;</span>]   <br>[(5,<span class="hljs-string">&quot;im&quot;</span>),(3,<span class="hljs-string">&quot;a&quot;</span>),(2,<span class="hljs-string">&quot;turtle&quot;</span>)]<br></code></pre></td></tr></table></figure>

<h2 id="Tuple-比较"><a href="#Tuple-比较" class="headerlink" title="Tuple 比较"></a>Tuple 比较</h2><p>与 list 类似, 但要注意只有相同长度的 tuple 能进行比较.</p>
<h1 id="类型和类型类"><a href="#类型和类型类" class="headerlink" title="类型和类型类"></a>类型和类型类</h1><p>Haskell 中万物都有类型, 能够在编译期间捕获类型相关错误.</p>
<p>Haskell 也支持类型推导, 避免为每个函数或表达式都显示标明其类型.</p>
<p>类型是每个表达式都有的某种标签, 它标明了这一表达式所属的范畴. 例如, 表达式 <code>True</code> 是 <code>boolean</code> 型, “hello” 是个字符串等.</p>
<p>比如在 <code>ghci</code> 中用 <code>:t</code> 检测表达式类型:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t <span class="hljs-string">&#x27;a&#x27;</span>   <br><span class="hljs-string">&#x27;a&#x27;</span> :: Char   <br>ghci&gt; :t True   <br>True :: Bool   <br>ghci&gt; :t <span class="hljs-string">&quot;HELLO!&quot;</span>   <br><span class="hljs-string">&quot;HELLO!&quot;</span> :: [Char]   <br>ghci&gt; :t (True, <span class="hljs-string">&#x27;a&#x27;</span>)   <br>(True, <span class="hljs-string">&#x27;a&#x27;</span>) :: (Bool, Char)   <br>ghci&gt; :t 4 == 5   <br>4 == 5 :: Bool<br></code></pre></td></tr></table></figure>
<ul>
<li><code>:t</code> 的输出为 “表达式” 后跟 “::” 以及类型</li>
<li><code>::</code> 读作 “它的类型为”</li>
<li>凡是明确的类型, 其首字母必定为大写</li>
<li><code>[Char]</code> 理解为一组字符 List</li>
<li>每个 Tuple 根据其内部元素的类型构成一个独立的类型, 比如 <code>(True, &#39;a&#39;)</code> 的类型是 <code>(Bool,Char)</code>; <code>(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)</code> 的类型为 <code>(Char,Char,Char)</code></li>
</ul>
<p>函数也有类别, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">removeNonUppercase</span> :: [<span class="hljs-type">Char</span>] -&gt; [<span class="hljs-type">Char</span>]   <br><span class="hljs-title">removeNonUppercase</span> st = [ c | c &lt;- st, c `elem` [&#x27;<span class="hljs-type">A&#x27;</span>..&#x27;<span class="hljs-type">Z&#x27;</span>]]<br></code></pre></td></tr></table></figure>
<ul>
<li><code>[Char] -&gt; [Char]</code> 表示从一个字符串映射到另一个字符串</li>
</ul>
<p>对于有多个参数的函数, 类型需要写为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">addThree</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>   <br><span class="hljs-title">addThree</span> x y z = x + y + z<br></code></pre></td></tr></table></figure>
<ul>
<li>各参数之间用 <code>-&gt;</code> 分隔, 最后一个是返回值的类型</li>
</ul>
<h2 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h2><ul>
<li><code>Int</code>, 整数. 有上限和下限, 对 32 位的机器通常是 <code>-214748364~214748364</code></li>
<li><code>Integer</code>, 也是整数. 但是无界, 可以表示很大的数, 但是效率不如 <code>Int</code></li>
<li><code>Float</code>, 单精度浮点数. </li>
<li><code>Double</code>, 双精度浮点数.</li>
<li><code>Bool</code>, 布尔值.</li>
<li><code>Char</code>, 表示一个字符. 一个字符由单引号括起, 一组字符的 List 为字符串</li>
<li><code>Tuple</code>, 元组. 其具体的类型由长度和元素类型决定</li>
</ul>
<h2 id="类型变量"><a href="#类型变量" class="headerlink" title="类型变量"></a>类型变量</h2><p>比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t <span class="hljs-built_in">head</span>   <br><span class="hljs-built_in">head</span> :: [a] -&gt; a<br></code></pre></td></tr></table></figure>
<ul>
<li>这里的 <code>a</code> 是小写, 不是具体的类型, 其类似其他语言中的 “泛型 (generic)”, 在 Haskell 中称为 “类型变量” 且更加强大</li>
</ul>
<p>在 Haskell 中, 使用到类型变量的函数被称为 “多态函数”, 类型变量约定俗成使用单个字符, 比如 <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> …</p>
<h2 id="类型类"><a href="#类型类" class="headerlink" title="类型类"></a>类型类</h2><p>类型类 (Typeclass), 类似于其他语言中的 Interface, 其描述了一组类型必须实现的操作, 而不关心具体实现.</p>
<p>一个函数类型声明示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t (==)   <br>(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool<br></code></pre></td></tr></table></figure>
<ul>
<li><code>=&gt;</code> 符号左边的称 “类型约束”, 这里 <code>a</code> 的类型为 <code>Eq</code></li>
</ul>
<p><code>Eq</code> 类提供了判断相等性的接口, 只要是可以比较的类型都属于 <code>Eq</code> 类:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; 5 == 5    <br>True    <br>ghci&gt; 5 /= 5    <br>False    <br>ghci&gt; <span class="hljs-string">&#x27;a&#x27;</span> == <span class="hljs-string">&#x27;a&#x27;</span>    <br>True    <br>ghci&gt; <span class="hljs-string">&quot;Ho Ho&quot;</span> == <span class="hljs-string">&quot;Ho Ho&quot;</span>    <br>True    <br>ghci&gt; 3.432 == 3.432    <br>True<br></code></pre></td></tr></table></figure>

<h3 id="几个基本的类型类"><a href="#几个基本的类型类" class="headerlink" title="几个基本的类型类"></a>几个基本的类型类</h3><ul>
<li><code>Eq</code>, 包含可判断相关性的类型. 提供了 <code>==</code> 和 <code>/=</code> 的函数实现</li>
<li><code>Ord</code>, 包含可比较大小的类型. 提供了 <code>&gt;</code>, <code>&lt;</code> 等用于比较大小的函数. <code>compare</code> 函数取两个 <code>Ord</code> 类中相同类型的值作为参数, 返回比较结果. 这个结果是如下三种类型之一: <code>GT</code>, <code>LT</code>, <code>EQ</code>. 一个类型若要成为 <code>Ord</code> 的成员, 必须先加入 <code>Eq</code> 家族<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-string">&quot;Abrakadabra&quot;</span> &lt; <span class="hljs-string">&quot;Zebra&quot;</span>   <br>True   <br>ghci&gt; <span class="hljs-string">&quot;Abrakadabra&quot;</span> `compare` <span class="hljs-string">&quot;Zebra&quot;</span>   <br>LT   <br>ghci&gt; 5 &gt;= 2   <br>True   <br>ghci&gt; 5 `compare` 3   <br>GT<br></code></pre></td></tr></table></figure></li>
<li><code>Show</code>, 包含可用字符串表示的类型. 常用 <code>show</code> 函数来操作 <code>Show</code> 类型类, 其可以取任一 <code>Show</code> 的成员类型并将其转为字符串<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; show 3   <br><span class="hljs-string">&quot;3&quot;</span>   <br>ghci&gt; show 5.334   <br><span class="hljs-string">&quot;5.334&quot;</span>   <br>ghci&gt; show True   <br><span class="hljs-string">&quot;True&quot;</span><br></code></pre></td></tr></table></figure></li>
<li><code>Read</code>, 包含可以把字符串转为对应类型值的类型. 常用 <code>read</code> 函数来转换<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;True&quot;</span> || False   <br>True   <br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;8.2&quot;</span> + 3.8   <br>12.0   <br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;5&quot;</span> - 2   <br>3   <br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;[1,2,3,4]&quot;</span> ++ [3]   <br>[1,2,3,4,3]<br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;5&quot;</span> :: Int   <br>5   <br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;5&quot;</span> :: Float   <br>5.0   <br>ghci&gt; (<span class="hljs-built_in">read</span> <span class="hljs-string">&quot;5&quot;</span> :: Float) * 4   <br>20.0   <br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;[1,2,3,4]&quot;</span> :: [Int]   <br>[1,2,3,4]   <br>ghci&gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;(3, &#x27;a&#x27;)&quot;</span> :: (Int, Char)   <br>(3, <span class="hljs-string">&#x27;a&#x27;</span>)<br></code></pre></td></tr></table></figure>
注意 <code>::</code> 这里的类型注解是必须的, 虽然编译器可以辨认大部分表达式的类型, 但是遇到 <code>read &quot;5&quot;</code> 这种, 它会搞不清楚其为 <code>Int</code> 还是 <code>Float</code>, 只有在运算时 haskell 才会明确其类型.</li>
<li><code>Enum</code>, 包含可枚举的类型, 有 <code>()</code>, <code>Bool</code>, <code>Char</code>, <code>Ordering</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code> 和 <code>Double</code>:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;e&#x27;</span>]   <br><span class="hljs-string">&quot;abcde&quot;</span>   <br>ghci&gt; [LT .. GT]   <br>[LT,EQ,GT]   <br>ghci&gt; [3 .. 5]   <br>[3,4,5]   <br>ghci&gt; succ <span class="hljs-string">&#x27;B&#x27;</span>   <br><span class="hljs-string">&#x27;C&#x27;</span><br></code></pre></td></tr></table></figure></li>
<li><code>Bounded</code>, 包含有上限和下限的类型:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; minBound :: Int   <br>-2147483648   <br>ghci&gt; maxBound :: Char   <br><span class="hljs-string">&#x27;\1114111&#x27;</span>   <br>ghci&gt; maxBound :: Bool   <br>True   <br>ghci&gt; minBound :: Bool   <br>False<br>ghci&gt; maxBound :: (Bool, Int, Char)   <br>(True,2147483647,<span class="hljs-string">&#x27;\1114111&#x27;</span>)<br></code></pre></td></tr></table></figure></li>
<li><code>Num</code>, 包含具有数字特征的类型:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t 20   <br>20 :: (Num t) =&gt; t<br>ghci&gt; :t (*)   <br>(*) :: (Num a) =&gt; a -&gt; a -&gt; a<br></code></pre></td></tr></table></figure></li>
<li><code>Integral</code>, 同样包含具有数字特征的类型. <code>Num</code> 包含所有的数字, 含实数和整数. 而 <code>Integral</code> 仅包含整数, 其成员类型有 <code>Int</code> 和 <code>Integer</code></li>
<li><code>Floating</code>, 仅包含浮点类型 <code>Float</code> 和 <code>Double</code></li>
</ul>
<h1 id="再探-Haskell-函数"><a href="#再探-Haskell-函数" class="headerlink" title="再探 Haskell 函数"></a>再探 Haskell 函数</h1><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>Haskell 函数的模式匹配, 可以让不同的参数对应不同的函数体, 语法示例如下:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">sayMe</span> :: (<span class="hljs-type">Integral</span> a) =&gt; a -&gt; <span class="hljs-type">String</span>   <br><span class="hljs-title">sayMe</span> <span class="hljs-number">1</span> = <span class="hljs-string">&quot;One!&quot;</span>   <br><span class="hljs-title">sayMe</span> <span class="hljs-number">2</span> = <span class="hljs-string">&quot;Two!&quot;</span>   <br><span class="hljs-title">sayMe</span> <span class="hljs-number">3</span> = <span class="hljs-string">&quot;Three!&quot;</span>   <br><span class="hljs-title">sayMe</span> <span class="hljs-number">4</span> = <span class="hljs-string">&quot;Four!&quot;</span>   <br><span class="hljs-title">sayMe</span> <span class="hljs-number">5</span> = <span class="hljs-string">&quot;Five!&quot;</span>   <br><span class="hljs-title">sayMe</span> x = <span class="hljs-string">&quot;Not between 1 and 5&quot;</span> <br></code></pre></td></tr></table></figure>
<ul>
<li>如果参数是 <code>1</code>, 则应用函数体 <code>One!</code></li>
<li>如果参数是 <code>2</code>, 则应用函数体 <code>Two!</code></li>
<li>…</li>
<li><code>x</code> 匹配剩余参数</li>
</ul>
<p>在调用 <code>sayMe</code> 时, 模式会从上到下挨个检查, 一旦有匹配, 则应用对应的函数体.</p>
<p>另一个示例, 阶乘函数, 这里也是递归函数的写法:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">factorial</span> :: (<span class="hljs-type">Integral</span> a) =&gt; a -&gt; a<br><span class="hljs-title">factorial</span> <span class="hljs-number">1</span> = <span class="hljs-number">0</span><br><span class="hljs-title">factorial</span> n = n * factorial (n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>向量相加示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">addVectors</span> :: (<span class="hljs-type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)   <br><span class="hljs-title">addVectors</span> (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)<br></code></pre></td></tr></table></figure>

<p>利用模式匹配 list 元素:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">head&#x27;</span> :: [a] -&gt; a   <br><span class="hljs-title">head&#x27;</span> [] = error <span class="hljs-string">&quot;Can&#x27;t call head on an empty list, dummy!&quot;</span>   <br><span class="hljs-title">head&#x27;</span> (x:_) = x<br></code></pre></td></tr></table></figure>
<ul>
<li>此时 <code>x</code> 匹配 List 的首个元素</li>
</ul>
<p>另一个例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">tell</span> :: (<span class="hljs-type">Show</span> a) =&gt; [a] -&gt; <span class="hljs-type">String</span>   <br><span class="hljs-title">tell</span> [] = <span class="hljs-string">&quot;The list is empty&quot;</span>   <br><span class="hljs-title">tell</span> (x:[]) = <span class="hljs-string">&quot;The list has one element: &quot;</span> ++ show x   <br><span class="hljs-title">tell</span> (x:y:[]) = <span class="hljs-string">&quot;The list has two elements: &quot;</span> ++ show x ++ <span class="hljs-string">&quot; and &quot;</span> ++ show y   <br><span class="hljs-title">tell</span> (x:y:_) = <span class="hljs-string">&quot;This list is long. The first two elements are: &quot;</span> ++ show x ++ <span class="hljs-string">&quot; and &quot;</span> ++ show y <br></code></pre></td></tr></table></figure>

<p>递归实现一个 <code>length</code> 函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">length&#x27;</span> :: (<span class="hljs-type">Num</span> b) =&gt; [a] -&gt; b   <br><span class="hljs-title">length&#x27;</span> [] = <span class="hljs-number">0</span>   <br><span class="hljs-title">length&#x27;</span> (_:xs) = <span class="hljs-number">1</span> + length&#x27; xs  <br></code></pre></td></tr></table></figure>

<p>递归实现一个 <code>sum</code> 函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">sum&#x27;</span> :: (<span class="hljs-type">Num</span> a) =&gt; [a] -&gt; a   <br><span class="hljs-title">sum&#x27;</span> [] = <span class="hljs-number">0</span>   <br><span class="hljs-title">sum&#x27;</span> (x:xs) = x + sum&#x27; xs <br></code></pre></td></tr></table></figure>

<p><code>as 模式</code> 语法, 在对 list 进行模式分割前面添加 <code>name@</code>, 可以用来引用分割前的 list, 例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">capital</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>   <br><span class="hljs-title">capital</span> <span class="hljs-string">&quot;&quot;</span> = <span class="hljs-string">&quot;Empty string, whoops!&quot;</span>   <br><span class="hljs-title">capital</span> all@(x:xs) = <span class="hljs-string">&quot;The first letter of &quot;</span> ++ all ++ <span class="hljs-string">&quot; is &quot;</span> ++ [x] <br></code></pre></td></tr></table></figure>

<p>调用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; capital <span class="hljs-string">&quot;Dracula&quot;</span><br><span class="hljs-string">&quot;The first letter of Dracula is D&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h2><p><code>Guard</code> 通过检查一个值的某项属性是否为真, 来对应一个函数体.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">bmiTell</span> :: (<span class="hljs-type">RealFloat</span> a) =&gt; a -&gt; <span class="hljs-type">String</span>  <br><span class="hljs-title">bmiTell</span> bmi  <br>    | bmi &lt;= <span class="hljs-number">18.5</span> = <span class="hljs-string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>  <br>    | bmi &lt;= <span class="hljs-number">25.0</span> = <span class="hljs-string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>  <br>    | bmi &lt;= <span class="hljs-number">30.0</span> = <span class="hljs-string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>  <br>    | otherwise   = <span class="hljs-string">&quot;You&#x27;re a whale, congratulations!&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>guard</code> 由 “函数名和参数” 之后的 “竖线加上布尔表达式” 组成, 如果为真, 则使用对应的函数体; 如果为假, 则送到下一个 <code>guard</code> 处</li>
<li>通常 <code>guard</code> 另起一行并缩进 (可以写在一行但是可读性差)</li>
<li>最后一个 <code>guard</code> 类似模式匹配中的 “匹配一切”, 布尔表达式始终为 <code>True</code> 即可</li>
</ul>
<p>实现一个简单的 <code>max</code> 函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">max&#x27;</span> :: (<span class="hljs-type">Ord</span> a) =&gt; a -&gt; a -&gt; a  <br><span class="hljs-title">max&#x27;</span> a b   <br>    | a &gt; b     = a  <br>    | otherwise = b<br></code></pre></td></tr></table></figure>

<p>一个 <code>compare</code> 函数的简单实现:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">myCompare</span> :: (<span class="hljs-type">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="hljs-type">Ordering</span>  <br><span class="hljs-title">a</span> `myCompare` b  <br>    | a &gt; b     = <span class="hljs-type">GT</span>  <br>    | a == b    = <span class="hljs-type">EQ</span>  <br>    | otherwise = <span class="hljs-type">LT</span><br></code></pre></td></tr></table></figure>

<h2 id="where-关键字"><a href="#where-关键字" class="headerlink" title="where 关键字"></a>where 关键字</h2><p><code>where</code> 绑定可以用来定义多个名字和函数. 这些名字对每个 <code>guard</code> 以及整个函数都是可见的:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">bmiTell</span> :: (<span class="hljs-type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="hljs-type">String</span>  <br><span class="hljs-title">bmiTell</span> weight height  <br>    | bmi &lt;= skinny = <span class="hljs-string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>  <br>    | bmi &lt;= normal = <span class="hljs-string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>  <br>    | bmi &lt;= fat    = <span class="hljs-string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>  <br>    | otherwise     = <span class="hljs-string">&quot;You&#x27;re a whale, congratulations!&quot;</span>  <br>    <span class="hljs-keyword">where</span> bmi = weight / height ^ <span class="hljs-number">2</span>  <br>          skinny = <span class="hljs-number">18.5</span>  <br>          normal = <span class="hljs-number">25.0</span>  <br>          fat = <span class="hljs-number">30.0</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>where</code> 通常也另起一行</li>
</ul>
<p>也可以利用模式匹配来简化写法:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell">...<br><span class="hljs-title">where</span> bmi = weight / height ^ <span class="hljs-number">2</span>  <br>      (skinny, normal, fat) = (<span class="hljs-number">18.5</span>, <span class="hljs-number">25.0</span>, <span class="hljs-number">30.0</span>)<br></code></pre></td></tr></table></figure>

<p>另一个例子模式匹配的例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">initials</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>  <br><span class="hljs-title">initials</span> firstname lastname = [f] ++ <span class="hljs-string">&quot;. &quot;</span> ++ [l] ++ <span class="hljs-string">&quot;.&quot;</span>  <br>    <span class="hljs-keyword">where</span> (f:_) = firstname  <br>          (l:_) = lastname<br></code></pre></td></tr></table></figure>

<p>在 <code>where</code> 中定义函数的例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">calcBmis</span> :: (<span class="hljs-type">RealFloat</span> a) =&gt; [(a, a)] -&gt; [a]  <br><span class="hljs-title">calcBmis</span> xs = [bmi w h | (w, h) &lt;- xs] <br>    <span class="hljs-keyword">where</span> bmi weight height = weight / height ^ <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h2 id="let-关键字"><a href="#let-关键字" class="headerlink" title="let 关键字"></a>let 关键字</h2><p><code>let</code> 绑定与 <code>where</code> 绑定类似. <code>where</code> 绑定是在函数底部定义名字, 对包括所有 <code>guard</code> 在内的整个函数可见. 而 <code>let</code> 绑定则是一个表达式, 允许在任何位置定义局部变量, 对不同的 <code>guard</code> 不可见.</p>
<p>一个根据半径和高度求圆柱体表面积的函数示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">cylinder</span> :: (<span class="hljs-type">RealFloat</span> a) =&gt; a -&gt; a -&gt; a  <br><span class="hljs-title">cylinder</span> r h = <br>    <span class="hljs-keyword">let</span> sideArea = <span class="hljs-number">2</span> * pi * r * h  <br>        topArea = pi * r ^<span class="hljs-number">2</span>  <br>    <span class="hljs-keyword">in</span>  sideArea + <span class="hljs-number">2</span> * topArea<br></code></pre></td></tr></table></figure>
<ul>
<li>语法为 <code>let [bindings] in [expressions]</code></li>
<li>在 <code>let</code> 中绑定的名字仅对 <code>in</code> 部分可见</li>
</ul>
<p>需要注意 <code>let</code> 本身是一个表达式:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; 4 * (<span class="hljs-built_in">let</span> a = 9 <span class="hljs-keyword">in</span> a + 1) + 2  <br>42<br></code></pre></td></tr></table></figure>

<p>用 <code>let</code> 定义局部函数的示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; [<span class="hljs-built_in">let</span> square x = x * x <span class="hljs-keyword">in</span> (square 5, square 3, square 2)]  <br>[(25,9,4)]<br></code></pre></td></tr></table></figure>

<p>如果要在一行内定义多个名字, 则需要用 <code>;</code> 分隔:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; (<span class="hljs-built_in">let</span> a = 100; b = 200; c = 300 <span class="hljs-keyword">in</span> a*b*c, <span class="hljs-built_in">let</span> foo=<span class="hljs-string">&quot;Hey &quot;</span>; bar = <span class="hljs-string">&quot;there!&quot;</span> <span class="hljs-keyword">in</span> foo ++ bar)  <br>(6000000,<span class="hljs-string">&quot;Hey there!&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>在 <code>let</code> 中使用模式匹配:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; (<span class="hljs-built_in">let</span> (a,b,c) = (1,2,3) <span class="hljs-keyword">in</span> a+b+c) * 100  <br>600<br></code></pre></td></tr></table></figure>

<p>在 List Comprehension 中使用 <code>let</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a]  <br>calcBmis xs = [bmi | (w, h) &lt;- xs, <span class="hljs-built_in">let</span> bmi = w / h ^ 2]<br></code></pre></td></tr></table></figure>
<ul>
<li>这里忽略了 <code>in</code>, 因为名字的可见性已经预先定义好了</li>
</ul>
<p>如果在 <code>ghci</code> 中使用 <code>let</code> 也能忽略 <code>in</code>, 此时的名字是整个交互中可见</p>
<h2 id="case-表达式"><a href="#case-表达式" class="headerlink" title="case 表达式"></a>case 表达式</h2><p><code>case</code> 表达式类似命令式编程语言中的 <code>case</code> 语句, 通过变量值来选择对应的代码块. 模式匹配本质上就是 <code>case</code> 语句的语法糖.</p>
<p>下面两端代码等价:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">head&#x27;</span> :: [a] -&gt; a  <br><span class="hljs-title">head&#x27;</span> [] = error <span class="hljs-string">&quot;No head for empty lists!&quot;</span>  <br><span class="hljs-title">head&#x27;</span> (x:_) = x<br></code></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">head&#x27;</span> :: [a] -&gt; a  <br><span class="hljs-title">head&#x27;</span> xs = <span class="hljs-keyword">case</span> xs <span class="hljs-keyword">of</span> [] -&gt; error <span class="hljs-string">&quot;No head for empty lists!&quot;</span>  <br>                      (x:_) -&gt; x<br></code></pre></td></tr></table></figure>

<p>case 表达式的语法:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">case</span> expression <span class="hljs-keyword">of</span> pattern -&gt; result  <br>                   pattern -&gt; result  <br>                   pattern -&gt; result  <br>                   ...<br></code></pre></td></tr></table></figure>
<ul>
<li>若第一个模式匹配, 则执行第一个 block 的代码; 否则继续比对下一个模式; 如果到最后都没有匹配, 则产生运行时错误</li>
</ul>
<p>由于它是个表达式, 因此能写在任意地方:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">case</span> expression <span class="hljs-keyword">of</span> pattern -&gt; result  <br>                   pattern -&gt; result  <br>                   pattern -&gt; result  <br>                   ...<br></code></pre></td></tr></table></figure>

<h1 id="Haskell-递归"><a href="#Haskell-递归" class="headerlink" title="Haskell 递归"></a>Haskell 递归</h1><p>递归就是指函数在定义或实现中调用自身的方式. 在数学定义中非常常见, 比如斐波那契数列, 其先定义了两个非递归的数 <code>F(0) = 0, F(1) = 1</code>, 表示数列前两个数为 <code>0</code> 和 <code>1</code>, 接着定义: <code>F(N) = F(N-1) + F(N-2)</code>, 表示斐波那契数是数列前两个数字之和.</p>
<p>在递归定义中声明的非递归值也可以称作 “边界条件”, 便于停止递归.</p>
<p>示例, 求一个列表内元素的最大值:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">maximum&#x27;</span> :: (<span class="hljs-type">Ord</span> a) =&gt; [a] -&gt; a<br><span class="hljs-title">maximum&#x27;</span> []  = error <span class="hljs-string">&quot;maximum of empty list&quot;</span><br><span class="hljs-title">maximum&#x27;</span> [x] = x<br><span class="hljs-title">maximum&#x27;</span> (x:xs) = max x (maximum&#x27; xs)<br></code></pre></td></tr></table></figure>

<p>实现 <code>replicate</code> 函数, 取一个 <code>Integral</code> 值和一个元素做参数, 返回一个包含多个重复元素的 List, 如 <code>replicate 3 5</code> 返回 <code>[5,5,5]</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">replicate&#x27;</span> :: (<span class="hljs-type">Num</span> i, <span class="hljs-type">Ord</span> i) =&gt; i -&gt; a -&gt; [a]   <br><span class="hljs-title">replicate&#x27;</span> n x   <br>    | n &lt;= <span class="hljs-number">0</span>    = []   <br>    | otherwise = x:replicate&#x27; (n-<span class="hljs-number">1</span>) x<br></code></pre></td></tr></table></figure>

<p>实现 <code>take</code> 函数, 从 List 中取一定数量的元素, 如 <code>take 3 [5,4,3,2,1]</code> 得到 <code>[5,4,3]</code>. 若要取零或负数个的话就会得到一个空 List; 若从空 list 中取值, 也是得到空 List:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">take&#x27;</span> :: (<span class="hljs-type">Num</span> i, <span class="hljs-type">Ord</span> i) =&gt; i -&gt; [a] -&gt; [a]   <br><span class="hljs-title">take&#x27;</span> n _   <br>    | n&lt;=<span class="hljs-number">0</span>   = []   <br><span class="hljs-title">take&#x27;</span> _ []     = []   <br><span class="hljs-title">take&#x27;</span> n (x:xs) = x : take&#x27; (n-<span class="hljs-number">1</span>) xs<br></code></pre></td></tr></table></figure>

<p>快速排序的实现示例, 边界条件是, 遇到空 list 则返回空 list. 算法定义: 选数组头部作为 pivot, 将整个数组分为两部分, 小于 pivot 的部分放在 pivot 之前, 大于 pivot 的部分放在 pivot 之后:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">quicksort</span> :: (<span class="hljs-type">Ord</span> a) =&gt; [a] -&gt; [a]   <br><span class="hljs-title">quicksort</span> [] = []   <br><span class="hljs-title">quicksort</span> (x:xs) =   <br>  <span class="hljs-keyword">let</span> smallerSorted = quicksort [a | a&lt;-xs, a&lt;=x]  <br>       biggerSorted = quicksort [a | a&lt;-xs, a &gt; x]   <br>  <span class="hljs-keyword">in</span> smallerSorted ++ [x] ++ biggerSorted<br></code></pre></td></tr></table></figure>
<p>(注意这个并不是业界最优的 quicksort 实现方式)</p>
<h1 id="Haskell-高阶函数"><a href="#Haskell-高阶函数" class="headerlink" title="Haskell 高阶函数"></a>Haskell 高阶函数</h1><p>Haskell 中的函数可以作为参数和返回值传递, 这样的函数被称为 “高阶函数”.</p>
<h2 id="柯里函数"><a href="#柯里函数" class="headerlink" title="柯里函数"></a>柯里函数</h2><p>本质上, Haskell 的所有函数都只有一个参数. 所有多个参数的函数都是 “Curried function”.</p>
<p>比如对于 <code>max 4 5</code>, Haskell 实际的计算过程是 (max 4) 5, <code>(max 4)</code> 会返回一个新函数, 这个新函数可以理解为:</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">maxWith<span class="hljs-number">4</span> <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> if <span class="hljs-keyword">x</span> &gt; <span class="hljs-number">4</span> then <span class="hljs-keyword">x</span> else <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>再把这个新函数应用到参数 <code>5</code>.</p>
<p>下面两种写法是等价的:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">max</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>(max <span class="hljs-number">4</span>) <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>从另一个角度来观察, 查看 <code>max</code> 函数的类型: <code>max :: (Ord a) =&gt; a -&gt; a -&gt; a</code>, 也可以写作: <code>max :: (Ord a) a -&gt; (a -&gt; a)</code>. 读作: <code>max</code> 取一个参数 <code>a</code>, 并返回一个函数, 这个函数取一个 <code>a</code> 类型的参数, 返回一个 <code>a</code>.</p>
<p>这也是为什么 Haskell 用箭头来分隔参数和返回值.</p>
<p>另一个例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">multThree</span> :: (<span class="hljs-type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; a <br><span class="hljs-title">multThree</span> x y z = x * y * z<br></code></pre></td></tr></table></figure>

<p>如果执行 <code>mulThree 3 5 9</code>, 其等价于 <code>((mulTree 3) 5) 9</code>. 执行流程如下:</p>
<ol>
<li>把参数 <code>3</code> 传给 <code>mulTree</code>, 返回一个新函数 <code>mulTreeWithThree x = 3 * x</code></li>
<li>把参数 <code>5</code> 传给新函数, 返回一个新函数 <code>mulTreeWithFifteen x = 5 * mulTreeWithThree x</code>, 等价于 <code>mulTreeWithFifteen x = 5 * 3 * x</code></li>
<li>把参数 <code>9</code> 传给 <code>mulTreeWithFifteen</code> 得到结果 <code>5 * 3 * 9</code></li>
</ol>
<p>Haskell 这种返回函数的方式, 可以很便利地创建新函数, 比如 <code>compare</code> 函数的类型为 <code>(Ord a) =&gt; a -&gt; a -&gt; Ordering</code>, 假如只传入一个参数 <code>100</code>, 有 <code>compare 100</code>, 此时仍然会返回一个函数, 类型是 <code>(Num a, Ord a) =&gt; a -&gt; Ordering</code>. 注意这里由于参数 <code>a</code> 是一个 <code>Num</code>, 所以多了一个类型约束.</p>
<p>示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">compareWithHundred</span> :: (<span class="hljs-type">Num</span> a，<span class="hljs-type">Ord</span> a) =&gt; a -&gt; <span class="hljs-type">Ordering</span> <br><span class="hljs-title">compareWithHundred</span> x = compare <span class="hljs-number">100</span> x<br></code></pre></td></tr></table></figure>

<p>等价于:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">compareWithHundred</span> :: (<span class="hljs-type">Num</span> a，<span class="hljs-type">Ord</span> a) =&gt; a -&gt; <span class="hljs-type">Ordering</span> <br><span class="hljs-title">compareWithHundred</span> = compare <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这种调用方式也称 “不全调用”</li>
</ul>
<p>也可以对中缀函数进行不全调用, 比如 <code>/</code> 的类型是: <code>(/) :: Fractional a =&gt; a -&gt; a -&gt; a</code>. 不全调用示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">divideByTen</span> :: (<span class="hljs-type">Floating</span> a) =&gt; a -&gt; a <br><span class="hljs-title">divideByTen</span> = (/<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li>注意用括号括起来, 返回的函数接收的参数填补到缺失的那一端, 比如这里的分子</li>
</ul>
<p>调用 <code>divideByTen 200</code> 就是 <code>(/10) 200</code>, 等价于 <code>200 / 10</code>.</p>
<p>检查字符是否为大写的函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">isUpperAlphanum</span> :: <span class="hljs-type">Char</span> -&gt; <span class="hljs-type">Bool</span> <br><span class="hljs-title">isUpperAlphanum</span> = (`elem` [&#x27;<span class="hljs-type">A&#x27;</span>..&#x27;<span class="hljs-type">Z&#x27;</span>])<br></code></pre></td></tr></table></figure>

<p>取一个函数, 并调用两次的例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">applyTwice</span> :: (a -&gt; a) -&gt; a -&gt; a   <br><span class="hljs-title">applyTwice</span> f x = f (f x)<br></code></pre></td></tr></table></figure>
<ul>
<li>这里 <code>(a -&gt; a)</code> 的括号并不是必须的, 只是便于观察, 这里表示一个函数, 接受一个 <code>a</code> 类型并返回一个 <code>a</code> 类型</li>
</ul>
<p>调用示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; applyTwice (+3) 10   <br>16   <br>ghci&gt; applyTwice (++ <span class="hljs-string">&quot; HAHA&quot;</span>) <span class="hljs-string">&quot;HEY&quot;</span>   <br><span class="hljs-string">&quot;HEY HAHA HAHA&quot;</span>   <br>ghci&gt; applyTwice (<span class="hljs-string">&quot;HAHA &quot;</span> ++) <span class="hljs-string">&quot;HEY&quot;</span>   <br><span class="hljs-string">&quot;HAHA HAHA HEY&quot;</span>   <br>ghci&gt; applyTwice (multThree 2 2) 9   <br>144   <br>ghci&gt; applyTwice (3:) [1]   <br>[3,3,1]<br></code></pre></td></tr></table></figure>

<p>实现标准库的 <code>zipWith</code>, 其接受一个函数和两个 List, 让函数接受相对应的元素作为参数, 把两个 List 交到一起:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">zipWith&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]   <br><span class="hljs-title">zipWith&#x27;</span> _ [] _ = []   <br><span class="hljs-title">zipWith&#x27;</span> _ _ [] = []   <br><span class="hljs-title">zipWith&#x27;</span> f (x:xs) (y:ys) = f x y : zipWith&#x27; f xs ys<br></code></pre></td></tr></table></figure>

<p>调用示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">ghci</span>&gt; zipWith&#x27; (+) [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]   <br>[<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]   <br><span class="hljs-title">ghci</span>&gt; zipWith&#x27; max [<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] [<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]   <br>[<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]   <br><span class="hljs-title">ghci</span>&gt; zipWith&#x27; (++) [<span class="hljs-string">&quot;foo &quot;</span>，<span class="hljs-string">&quot;bar &quot;</span>，<span class="hljs-string">&quot;baz &quot;</span>] [<span class="hljs-string">&quot;fighters&quot;</span>，<span class="hljs-string">&quot;hoppers&quot;</span>，<span class="hljs-string">&quot;aldrin&quot;</span>]   <br>[<span class="hljs-string">&quot;foo fighters&quot;</span>,<span class="hljs-string">&quot;bar hoppers&quot;</span>,<span class="hljs-string">&quot;baz aldrin&quot;</span>]   <br><span class="hljs-title">ghci</span>&gt; zipWith&#x27; (*) (replicate <span class="hljs-number">5</span> <span class="hljs-number">2</span>) [<span class="hljs-number">1</span>..]   <br>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>]   <br><span class="hljs-title">ghci</span>&gt; zipWith&#x27; (zipWith&#x27; (*)) [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]] [[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]]   <br>[[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">12</span>]]<br></code></pre></td></tr></table></figure>

<p>实现标准库的 <code>flip</code> 函数, 取一个函数作为参数, 并返回一个相似的函数, 只是参数位置颠倒了:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">flip&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)<br><span class="hljs-title">flip&#x27;</span> f = g<br>    <span class="hljs-keyword">where</span> g x y = f y x<br></code></pre></td></tr></table></figure>

<p>可以写成更简单的形式:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">flip&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c   <br><span class="hljs-title">flip&#x27;</span> f y x = f x y<br></code></pre></td></tr></table></figure>

<h2 id="map-和-filter"><a href="#map-和-filter" class="headerlink" title="map 和 filter"></a>map 和 filter</h2><h3 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h3><p><code>map</code> 取一个函数和 <code>List</code> 做参数, 遍历该 <code>List</code> 的每个元素来调用该函数产生一个新的 <code>List</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]   <br><span class="hljs-title">map</span> _ [] = []   <br><span class="hljs-title">map</span> f (x:xs) = f x : map f xs<br></code></pre></td></tr></table></figure>

<p>调用示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; map (+3) [1,5,3,1,6]   <br>[4,8,6,4,9]   <br>ghci&gt; map (++ <span class="hljs-string">&quot;!&quot;</span>) [<span class="hljs-string">&quot;BIFF&quot;</span>，<span class="hljs-string">&quot;BANG&quot;</span>，<span class="hljs-string">&quot;POW&quot;</span>]   <br>[<span class="hljs-string">&quot;BIFF!&quot;</span>,<span class="hljs-string">&quot;BANG!&quot;</span>,<span class="hljs-string">&quot;POW!&quot;</span>]   <br>ghci&gt; map (replicate 3) [3..6]   <br>[[3,3,3],[4,4,4],[5,5,5],[6,6,6]]   <br>ghci&gt; map (map (^2)) [[1,2],[3,4,5,6],[7,8]]   <br>[[1,4],[9,16,25,36],[49,64]]   <br>ghci&gt; map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]   <br>[1,3,6,2,2]<br></code></pre></td></tr></table></figure>

<p>这些调用其实都能用 list comprehension 来替代, 比如 <code>map (+3) [1,5,3,1,6]</code> 与 <code>[x+3 | x &lt;- [1,5,3,1,6]]</code> 完全等价.</p>
<p>假如传递给 <code>map</code> 的是二元函数, 则每次计算都会得到一个一元函数, 比如 <code>map (*) [0..]</code> 的结果大概就是 <code>[(0*),(1*),(2*)..]</code>.</p>
<h3 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h3><p><code>filter</code> 函数取一个布尔函数和一个 List, 返回该 List 中所有符合该布尔条件的元素:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">filter</span> :: (a -&gt; <span class="hljs-type">Bool</span>) -&gt; [a] -&gt; [a]   <br><span class="hljs-title">filter</span> _ [] = []   <br><span class="hljs-title">filter</span> p (x:xs)    <br>    | p x       = x : filter p xs   <br>    | otherwise = filter p xs<br></code></pre></td></tr></table></figure>

<p>调用示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; filter (&gt;3) [1,5,3,2,1,6,4,3,2,1]   <br>[5,6,4]   <br>ghci&gt; filter (==3) [1,2,3,4,5]   <br>[3]   <br>ghci&gt; filter even [1..10]   <br>[2,4,6,8,10]   <br>ghci&gt; <span class="hljs-built_in">let</span> notNull x = not (null x) <span class="hljs-keyword">in</span> filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]   <br>[[1,2,3],[3,4,5],[2,2]]   <br>ghci&gt; filter (`elem` [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;z&#x27;</span>]) <span class="hljs-string">&quot;u LaUgH aT mE BeCaUsE I aM diFfeRent&quot;</span>   <br><span class="hljs-string">&quot;uagameasadifeent&quot;</span>   <br>ghci&gt; filter (`elem` [<span class="hljs-string">&#x27;A&#x27;</span>..<span class="hljs-string">&#x27;Z&#x27;</span>]) <span class="hljs-string">&quot;i lauGh At You BecAuse u r aLL the Same&quot;</span>   <br><span class="hljs-string">&quot;GAYBALLS&quot;</span><br></code></pre></td></tr></table></figure>

<p>这些同样可以用 list comprehension 来实现.</p>
<p><code>takeWhile</code> 函数, 取一个限制条件和 List 作为参数, 从头开始遍历这一 List, 并回传符合限制条件的元素, 一旦遇到不符合条件的元素, 就停止, 比如取出 <code>&quot;elephants know how to party&quot;</code> 中的首个单词, 可以写:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; takeWhile (/=<span class="hljs-string">&quot; &quot;</span>) <span class="hljs-string">&quot;elephants know how to party&quot;</span><br>elephants<br></code></pre></td></tr></table></figure>

<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p><code>Lambda</code> 就是匿名函数, 语法为:</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\args</span> -&gt; body<br></code></pre></td></tr></table></figure>
<ul>
<li>用 <code>\</code> 开头, 后面跟空格分隔的参数列表</li>
<li><code>-&gt;</code> 之后是函数体</li>
</ul>
<p>比如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">numLongChains</span> :: <span class="hljs-type">Int</span>  <br><span class="hljs-title">numLongChains</span> = length (filter (\xs -&gt; length xs &gt; <span class="hljs-number">15</span>) (map chain [<span class="hljs-number">1</span>..<span class="hljs-number">100</span>]))<br></code></pre></td></tr></table></figure>

<p><code>Lambda</code> 是一个表达式, 因此可以任意传递, 这里 <code>(\xs -&gt; length xs &gt; 15)</code> 回传一个函数, 用来判断一个列表的长度是否大于 <code>15</code>.</p>
<p>大多时候都是直接用 curried function 或不全调用, 而非 lambda, 比如 <code>map (+3) [1,6,3,2]</code> 与 <code>map (\x -&gt; x + 3) [1,6,3,2]</code> 是等价的.</p>
<p>多个参数的 <code>lambda</code> 示例:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; zipWith (\a b -&gt; (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]  <br>[153.0,61.5,31.0,15.75,6.6]<br></code></pre></td></tr></table></figure>

<p>(一般情况下, <code>lambda</code> 函数都使用括号包裹的)</p>
<p>由于柯里化, 下面两个函数是等价的:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">addThree</span> :: (<span class="hljs-type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; a  <br><span class="hljs-title">addThree</span> x y z = x + y + z<br></code></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">addThree</span> :: (<span class="hljs-type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; a  <br><span class="hljs-title">addThree</span> = \x -&gt; \y -&gt; \z -&gt; x + y + z<br></code></pre></td></tr></table></figure>

<p>用 <code>lambda</code> 重写一个最易读的 <code>flip</code> 实现:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">flip</span> :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)<br><span class="hljs-title">flip</span> f = \x y -&gt; f y x<br></code></pre></td></tr></table></figure>

<h2 id="关键字-fold"><a href="#关键字-fold" class="headerlink" title="关键字 fold"></a>关键字 fold</h2><p><code>fold</code> 函数用来将一个列表 (或其他递归数据结构) “压缩” 成一个单一的值, 其参数取:</p>
<ul>
<li>一个二元函数</li>
<li>一个初始值 (累加值)</li>
<li>一个需要折叠的 List</li>
</ul>
<p>二元函数的参数是累加值和 List 的首项, 并且返回新的累加值.</p>
<p>所有遍历 List 中元素并据此返回一个值 (这个值也可以是 List) 的操作都可以交给 <code>fold</code> 来实现.</p>
<h3 id="foldl"><a href="#foldl" class="headerlink" title="foldl"></a>foldl</h3><p><code>foldl</code> 函数 (fold left), 从 List 的左端开始折叠, 用初始值和 List 的头部调用二元函数, 得到一个新的累加值, 然后用新的累加值和 List 的下一个元素调用二元函数, 直到遍历整个 List. <code>foldl</code> 函数的类型为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; :t foldl :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b<br></code></pre></td></tr></table></figure>
<ul>
<li><code>t a</code> 可以是 List 等可折叠的数据结构</li>
</ul>
<p>用 <code>foldl</code> 来实现 <code>sum</code> 的示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">sum&#x27;&#x27;</span> :: (<span class="hljs-type">Num</span> a) =&gt; [a] -&gt; a<br><span class="hljs-title">sum&#x27;&#x27;</span> = foldl (+) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这里借助了柯里化和部分调用, <code>foldl (+) 0</code> 会返回一个 <code>[a] -&gt; a</code> 类型的函数</li>
</ul>
<p>用 <code>foldl</code> 来实现 <code>elem</code> 的示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">elem&#x27;</span> :: (<span class="hljs-type">Eq</span> a) =&gt; a -&gt; [a] -&gt; <span class="hljs-type">Bool</span><br><span class="hljs-title">elem&#x27;</span> e xs = foldl (\acc x -&gt; acc || (x == e)) <span class="hljs-type">False</span> xs<br></code></pre></td></tr></table></figure>

<p>用 <code>foldl</code> 来实现 <code>map</code> 的示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">map&#x27;</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]  <br><span class="hljs-title">map&#x27;</span> f xs = foldl (\acc x -&gt; acc ++ [f x]) [] xs<br></code></pre></td></tr></table></figure>

<h3 id="foldr"><a href="#foldr" class="headerlink" title="foldr"></a>foldr</h3><p><code>foldr</code> 函数 (fold right), 从 List 的右端开始折叠, 其余与 <code>foldl</code> 类似.</p>
<p>用 <code>foldr</code> 实现 <code>map</code> 的示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">map&#x27;</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]  <br><span class="hljs-title">map&#x27;</span> f xs = foldr (\x acc -&gt; f x : acc) [] xs<br></code></pre></td></tr></table></figure>

<p>一个理解 <code>foldr</code> 操作的例子, 假设有二元函数 <code>f</code>, 起始值为 <code>z</code>, 从右折叠 <code>[3,4,5,6]</code>, 实际的执行就等价于:</p>
<ul>
<li><code>f 3 (f 4 (f 5 (f 6 z)))</code></li>
</ul>
<h3 id="foldl1-和-foldr1"><a href="#foldl1-和-foldr1" class="headerlink" title="foldl1 和 foldr1"></a>foldl1 和 foldr1</h3><p><code>foldl1</code> 和 <code>foldr1</code> 的行为与 <code>foldl</code> 和 <code>foldr</code> 类似, 只不过不需要提供初始值, 其假定 List 的首个 (或末尾) 元素作为起始值, 并从旁边的元素开始折叠.</p>
<p>比如 <code>sum</code> 函数可以实现为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">sum&#x27;</span> :: (<span class="hljs-type">Num</span> a) =&gt; [a] -&gt; a<br><span class="hljs-title">sum&#x27;</span> = foldl1 (+)<br></code></pre></td></tr></table></figure>
<ul>
<li>但这个要求待折叠的 list 中至少要有一个元素, 不然会产生运行时错误</li>
</ul>
<p>用 <code>fold</code> 函数实现常见库函数的例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">maximum&#x27;</span> :: (<span class="hljs-type">Ord</span> a) =&gt; [a] -&gt; a  <br><span class="hljs-title">maximum&#x27;</span> = foldr1 (\x acc -&gt; <span class="hljs-keyword">if</span> x &gt; acc <span class="hljs-keyword">then</span> x <span class="hljs-keyword">else</span> acc)  <br><br><span class="hljs-title">reverse&#x27;</span> :: [a] -&gt; [a]  <br><span class="hljs-title">reverse&#x27;</span> = foldl (\acc x -&gt; x : acc) []  <br><br><span class="hljs-title">product&#x27;</span> :: (<span class="hljs-type">Num</span> a) =&gt; [a] -&gt; a  <br><span class="hljs-title">product&#x27;</span> = foldr1 (*)  <br><br><span class="hljs-title">filter&#x27;</span> :: (a -&gt; <span class="hljs-type">Bool</span>) -&gt; [a] -&gt; [a]  <br><span class="hljs-title">filter&#x27;</span> p = foldr (\x acc -&gt; <span class="hljs-keyword">if</span> p x <span class="hljs-keyword">then</span> x : acc <span class="hljs-keyword">else</span> acc) []  <br><br><span class="hljs-title">head&#x27;</span> :: [a] -&gt; a  <br><span class="hljs-title">head&#x27;</span> = foldr1 (\x _ -&gt; x)  <br><br><span class="hljs-title">last&#x27;</span> :: [a] -&gt; a  <br><span class="hljs-title">last&#x27;</span> = foldl1 (\_ x -&gt; x)<br></code></pre></td></tr></table></figure>

<h3 id="scanl-scanr-scanl1-和-scanr1"><a href="#scanl-scanr-scanl1-和-scanr1" class="headerlink" title="scanl, scanr, scanl1 和 scanr1"></a>scanl, scanr, scanl1 和 scanr1</h3><p><code>scanl</code> 和 <code>scanr</code> 与 <code>foldl</code> 和 <code>foldr</code> 类似, 只不过它们会记录下累加值的所有状态到一个 List:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">ghci</span>&gt; scanl (+) <span class="hljs-number">0</span> [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]  <br>[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>]  <br><span class="hljs-title">ghci</span>&gt; scanr (+) <span class="hljs-number">0</span> [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]  <br>[<span class="hljs-number">11</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]  <br><span class="hljs-title">ghci</span>&gt; scanl1 (\acc x -&gt; <span class="hljs-keyword">if</span> x &gt; acc <span class="hljs-keyword">then</span> x <span class="hljs-keyword">else</span> acc) [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]  <br>[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>]  <br><span class="hljs-title">ghci</span>&gt; scanl (flip (:)) [] [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]  <br>[[],[<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<br></code></pre></td></tr></table></figure>

<h2 id="有-的函数调用"><a href="#有-的函数调用" class="headerlink" title="有 $ 的函数调用"></a>有 $ 的函数调用</h2><p><code>$</code> 函数, 称作函数调用符:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell">($) :: (a -&gt; b) -&gt; a -&gt; b  <br><span class="hljs-title">f</span> $ x = f x<br></code></pre></td></tr></table></figure>

<p>普通的函数调用符有最高的优先级, 而 <code>$</code> 的优先级最低.</p>
<p>用空格的函数调用符是左结合的, 如 <code>f a b c</code> 与 <code>((f a) b) c</code> 等价.</p>
<p>而 <code>$</code> 是右结合的, 可以用来较少代码中的括号数量, 比如有表达式: <code>sum (map sqrt [1..130])</code></p>
<p>用 <code>$</code> 可以改写为: <code>sum $ map sqrt [1..130]</code>.</p>
<p>另一个例子, 可以把 <code>sqrt (3 + 4 + 9)</code> 改写为 <code>sqrt $ 3 + 4 + 9</code>.</p>
<p>除了减少括号外, <code>$</code> 还可以把数据当作函数来使用, 如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; map ($ 3) [(4+),(10*),(^2),sqrt]  <br>[7.0,30.0,9.0,1.7320508075688772]<br></code></pre></td></tr></table></figure>

<h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><p>函数组合 (复合函数), 在数学上可以这样定义: 给定两个函数:</p>
<ul>
<li>$f: B \rightarrow C$</li>
<li>$g: A \rightarrow B$</li>
</ul>
<p>它们的组合是一个新函数, 记为:</p>
<p>$$<br>\displaylines<br>{<br>\begin{aligned}<br>(f \odot g) (x) &#x3D; f(g(x))<br>\end{aligned}<br>}<br>$$<br>(先应用 <code>g</code>, 再把结果传给 <code>f</code>)</p>
<p>在 Haskell 中, 利用 <code>.</code> 函数来进行函数组合, <code>.</code> 函数的定义为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c  <br><span class="hljs-title">f</span> . g = \x -&gt; f (g x)<br></code></pre></td></tr></table></figure>

<p>需要注意这里的类型声明:</p>
<ul>
<li><code>f</code> 的类型是 <code>b -&gt; c</code></li>
<li><code>g</code> 的类型是 <code>a -&gt; b</code></li>
</ul>
<p><code>f</code> 的输入参数必须与 <code>g</code> 的返回类型相同. 所得到的组合函数的输入类型与 <code>g</code> 相同, 输出类型与 <code>f</code> 相同.</p>
<p>函数组合的主要作用就是生成新函数, 比如要将一个数字 List 全部转换为负数, 可以考虑先取绝对值, 然后全部取负数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; map (\x -&gt; negate (abs x)) [5,-3,-6,7,-3,2,-19,24]  <br>[-5,-3,-6,-7,-3,-2,-19,-24]<br></code></pre></td></tr></table></figure>

<p>可以用函数组合改写为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; map (negate . abs) [5,-3,-6,7,-3,2,-19,24]  <br>[-5,-3,-6,-7,-3,-2,-19,-24]<br></code></pre></td></tr></table></figure>

<p>又比如组合多个函数, <code>f (g (z x))</code> 与 <code>(f . g . z) x</code> 等价, 因此有:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; map (\xs -&gt; negate (<span class="hljs-built_in">sum</span> (<span class="hljs-built_in">tail</span> xs))) [[1..5],[3..6],[1..7]]  <br>[-14,-15,-27]<br></code></pre></td></tr></table></figure>

<p>改为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ghci&gt; map (negate . <span class="hljs-built_in">sum</span> . <span class="hljs-built_in">tail</span>) [[1..5],[3..6],[1..7]]  <br>[-14,-15,-27]<br></code></pre></td></tr></table></figure>

<p>如果包含多个参数的函数, 则可以用不全调用使得每个函数都只剩下一个参数, 比如 <code>sum (replicate 5 (max 6 8))</code> 可以重写为 <code>(sum . replicate 5 . max 6) 8</code>.</p>
<p>如果想去掉括号, 通常在最接近参数的函数之后加上 <code>$</code> 即可, 比如 <code>replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))</code> 可以重写为: <code>replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]</code>.</p>
<p>函数组合还用于定义 point free style 的函数, 如:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">sum&#x27;</span> :: (<span class="hljs-type">Num</span> a) =&gt; [a] -&gt; a     <br><span class="hljs-title">sum&#x27;</span> xs = foldl (+) <span class="hljs-number">0</span> xs<br></code></pre></td></tr></table></figure>
<p>等号两端都有个 <code>xs</code>, 由于 currying, 可以省掉两端的 <code>xs</code>, 因为 <code>foldl (+) 0</code> 会返回一个取一个 List 作为参数的函数, 因此可以改为为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">sum&#x27;</span> :: (<span class="hljs-type">Num</span> a) =&gt; [a] -&gt; a     <br><span class="hljs-title">sum&#x27;</span> = foldl (+) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这就是 point free style</li>
</ul>
<p>对于下面的函数, 则不能直接去掉两端的 <code>x</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">fn</span> x = ceiling (negate (tan (cos (max <span class="hljs-number">50</span> x))))<br></code></pre></td></tr></table></figure>

<p>此时可以借助函数组合, 重写为:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">fn</span> = ceiling . negate . tan . cos . max <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Haskell/" class="category-chain-item">Haskell</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Haskell-基础学习</div>
      <div>http://example.com/2025/12/22/Haskell-基础学习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jie</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年12月22日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/22/Functional-Programming/" title="Functional-Programming">
                        <span class="hidden-mobile">Functional-Programming</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'zKurisu/comments-utterances');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Jie</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Orkarin</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
