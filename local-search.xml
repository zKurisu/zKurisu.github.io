<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ArchWiki 中关于 Bash 的部分</title>
    <link href="/2022/09/07/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Bash-%E7%9A%84%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/07/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Bash-%E7%9A%84%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Bash">ArchWiki</a><br>如果 Bash 以 TTY 中的 <code>login</code>，SSH 守护进程等类似方法派生出来，其被成为 login shell,可以用 <code>-l</code> 或 <code>--login</code> 选项来使用这种模式.</p><p>如果 Bash 的标准输入输出和标准错误输出都连接到终端，并且在启动的时候没有使用 <code>-c</code> 选项和非选项参数，其被称为 interactive shell.</p><p>所有 interactive shell (交互式 shell) 都或执行 <code>/etc/bash.bashrc</code> 和 <code>~/.bashrc</code> 文件中的配置。</p><p>而 login shell (登录 shell) 还会执行 <code>/etc/profile</code> 和 <code>~/.bash_profile</code> 中的配置.</p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><h2 id="Readline-库"><a href="#Readline-库" class="headerlink" title="Readline 库"></a>Readline 库</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>readline 包可能已经作为 Bash 的依赖安装。</p><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><p>其默认使用 <code>Emacs</code> 风格的快捷键与命令行交互。</p><p>设置 vim 风格交互, 在 <code>~/.inputrc</code> 中添加:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> editing-<span class="hljs-keyword">mode</span> <span class="hljs-keyword">vi</span><br></code></pre></td></tr></table></figure><p>若只为 Bash 设置，可修改 <code>~/.bashrc</code>:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> -o <span class="hljs-comment">vi</span><br></code></pre></td></tr></table></figure><p>提示当前的 vi 模式, 在 <code>~/.inputrc</code> 中添加:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">set</span> <span class="hljs-keyword">show</span>-mode-<span class="hljs-keyword">in</span>-prompt <span class="hljs-keyword">on</span><br></code></pre></td></tr></table></figure><p>默认以 <code>(cmd)/(ins)</code> 格式显示，可以通过 <code>vi-ins-mode-string</code> 和 <code>vi-cmd-mode-string</code> 变量自定义.</p><h4 id="为每个模式指定不同的光标样式"><a href="#为每个模式指定不同的光标样式" class="headerlink" title="为每个模式指定不同的光标样式"></a>为每个模式指定不同的光标样式</h4>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中关于 man page</title>
    <link href="/2022/09/07/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-man-page/"/>
    <url>/2022/09/07/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-man-page/</url>
    
    <content type="html"><![CDATA[<p>man 指 manual pages.</p><p>GNU 正在将 man 手册替换成 info 文档 (支持超链接).</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>man-db</code> 提供了 man 命令, less 是 man 的默认分页器.</p><p><code>man-pages</code> 提供了 Linux man 页面的内容.</p><h1 id="阅读手册页"><a href="#阅读手册页" class="headerlink" title="阅读手册页"></a>阅读手册页</h1><p>man pages 分为很多段落：</p><ul><li>1 User commands, 用户可以在命令行中运行的命令</li><li>2 System calls, 内核中封装的函数</li><li>3 Library calls, 所有 library functions 除了 the system call wrappers (大多数为 libc function)</li><li>4 Special files (device), Files found in &#x2F;dev which allow to access to devices through the kernel</li><li>5 File formats and configuration files, 描述各种 human-readable file 和配置文件</li><li>6 Games, Games and funny little programs available on the system</li><li>7 Overview, conventions, and miscellaneous. Overviews or description of various topics, conventions, and protocols, character set standards, the standard filesystem layout, and miscellaneous other things</li><li>8 System management commands, 如 mount 这类命令，大多为 root 用户才能执行</li></ul><p>man pages 通过名称和所属分类标识，可指定分类以访问需要的手册，如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">man</span> <span class="hljs-number">5</span> passwd<br></code></pre></td></tr></table></figure><p>这会显示 <code>/etc/passwd</code> 这个文件的信息.</p><h1 id="搜索手册页"><a href="#搜索手册页" class="headerlink" title="搜索手册页"></a>搜索手册页</h1><p>可以通过 <code>-k</code> 或者 <code>--apropos</code> 参数按指定关键词搜索相关手册.</p><p>关键词搜索是从一个专用的缓存生成的，默认情况下没有这个缓存，会得到 <code>nothing appropriate</code> 这个报错，可以通过 <code>mandb</code> 命令生成缓存,</p><p>每次安装新的 manpage 之后都要运行 <code>mandb</code> 缓存才会更新. 关键字可以使用正则表达式。</p><p>使用 <code>whatis</code> 命令可以只显示需要的 man page 的简要信息.</p><h1 id="使用浏览器阅读-man-page"><a href="#使用浏览器阅读-man-page" class="headerlink" title="使用浏览器阅读 man page"></a>使用浏览器阅读 man page</h1><p>在 Arch 中:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> man -H <span class="hljs-keyword">free</span><br></code></pre></td></tr></table></figure><h1 id="转换成-pdf"><a href="#转换成-pdf" class="headerlink" title="转换成 pdf"></a>转换成 pdf</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ man -t <span class="hljs-tag">&lt;<span class="hljs-name">manpage</span>&gt;</span> | ps2pdf - <span class="hljs-tag">&lt;<span class="hljs-name">pdf</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 bind 命令绑定键位</title>
    <link href="/2022/09/07/%E4%BD%BF%E7%94%A8-bind-%E5%91%BD%E4%BB%A4%E7%BB%91%E5%AE%9A%E9%94%AE%E4%BD%8D/"/>
    <url>/2022/09/07/%E4%BD%BF%E7%94%A8-bind-%E5%91%BD%E4%BB%A4%E7%BB%91%E5%AE%9A%E9%94%AE%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/cnds123321/article/details/124815867">参考</a></p><p><a href="https://www.geeksforgeeks.org/bind-command-in-linux-with-examples/">参考</a></p><p><a href="https://www.computerhope.com/unix/bash/bind.htm">参考</a><br>Arch 中似乎没有内置这个命令，需要自己安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S <span class="hljs-built_in">bind</span><br></code></pre></td></tr></table></figure><h1 id="bind-表示键的方式"><a href="#bind-表示键的方式" class="headerlink" title="bind 表示键的方式"></a>bind 表示<mark>键</mark>的方式</h1><p><code>bind</code> 使用特殊字符和文本字符串的方式来表示键盘:</p><ul><li><code>\C-</code>, 表示按住 <code>Ctrl</code> 键加上 <code>-</code> 后面的键，如 <code>\C-A</code> 表示 <code>Ctrl+A</code> </li><li><code>\e</code>, 转义键, 绑定元键，<code>Alt</code> 是键盘上的元键</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>语法:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bind</span><span class="hljs-meta"> [选项]</span><br></code></pre></td></tr></table></figure><h2 id="查找编码的默认组合"><a href="#查找编码的默认组合" class="headerlink" title="查找编码的默认组合"></a>查找编码的默认组合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> -P<br></code></pre></td></tr></table></figure><p>也可以通过查看 <code>/etc/inputrc</code> 文件。</p><h2 id="查找键码"><a href="#查找键码" class="headerlink" title="查找键码"></a>查找键码</h2><p>使用 <code>Ctrl+v</code> 然后加一个键，就可以查询该键的键码.</p><p>如先按 <code>Ctrl+v</code> 然后按 <code>F7</code>, 结果为 <code>^[[18～</code> 这里的 <code>^[</code> 是转义字符，可以表示为:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\e[18~</span><br></code></pre></td></tr></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul><li><code>-l</code>, 列出所有可绑定编辑的函数的名称</li><li><code>-P</code></li><li><code>-p</code></li><li><code>-S</code>, 列出调用宏的键序列及其值</li><li><code>-s</code>, 和 <code>-S</code>, 相同，但可以用作 <code>bind</code> 输入的形式提供输出</li><li><code>-V</code>, 列出在 bash 键绑定中使用的变量和值</li><li><code>-v</code></li><li><code>-q</code>, 查询</li><li><code>-u function-name</code>, 解除绑定到这个函数上的所有键 </li><li><code>-r keyseq</code> </li><li><code>-f filename</code>, 从文件中读取键绑定，并作为 <code>bind</code> 命令的输入</li><li><code>-x keyseq:shell-command</code>, 绑定命令</li><li><code>-X</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决 vim 插件 Ultisnips 对 markdown 文件无效问题</title>
    <link href="/2022/09/07/%E8%A7%A3%E5%86%B3-vim-%E6%8F%92%E4%BB%B6-Ultisnips-%E5%AF%B9-markdown-%E6%96%87%E4%BB%B6%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/07/%E8%A7%A3%E5%86%B3-vim-%E6%8F%92%E4%BB%B6-Ultisnips-%E5%AF%B9-markdown-%E6%96%87%E4%BB%B6%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>删除 <code>vim-markdown</code> 这个插件就可以解决.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>区分 Non-printing character 和 Escape character</title>
    <link href="/2022/09/07/%E5%8C%BA%E5%88%86-Non-printing-character-%E5%92%8C-Escape-character/"/>
    <url>/2022/09/07/%E5%8C%BA%E5%88%86-Non-printing-character-%E5%92%8C-Escape-character/</url>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Non-printing_character_in_word_processors">reference 1</a><br><a href="https://en.wikipedia.org/wiki/Non-printing_character_in_word_processor://en.wikipedia.org/wiki/Escape_character">reference 2</a></p><h1 id="Non-printing-character-in-word-processors"><a href="#Non-printing-character-in-word-processors" class="headerlink" title="Non-printing character in word processors"></a>Non-printing character in word processors</h1><p>Non-printing character 或者说 formatting marks 是在 word processors 用来 design content 的 characters. 其不是用来打印或显示的。</p><p>在 word processors 中最常见的 non-printable characters 有:</p><ul><li>pilcrow, 段落符号</li><li>space</li><li>non-breaking space</li><li>tab</li></ul><h1 id="Escape-character"><a href="#Escape-character" class="headerlink" title="Escape character"></a>Escape character</h1><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>一个 escape character 不是 control character.</p><p>Escape sequence 是指在转义时使用的有序字符组合.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ANSI 转移序列</title>
    <link href="/2022/09/07/ANSI-%E8%BD%AC%E7%A7%BB%E5%BA%8F%E5%88%97/"/>
    <url>/2022/09/07/ANSI-%E8%BD%AC%E7%A7%BB%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6">参考1</a><br><a href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97">参考2</a><br><a href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%9://blog.csdn.net/linux_rm/article/details/124732456">参考3</a><br><a href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%9://blog.csdn.net/linux_rm/article/details/12473245://www.mardan.wiki/website/2019/04/23/%E4%BF%AE%E6%94%B9terminal%E9%BB%98%E8%AE%A4%E6%8F%90%E7%A4%BA%E6%A0%B7%E5%BC%8F">参考4</a><br>主要是解决我 <code>\[  \]</code> 未理解到的问题.</p><p>暂时理解为，有一部分字符的定义是 “私有的”, 以便终端制造商可以插入他们自己的序列而不与标准相冲突，因此用 <code>\[ \]</code> 包裹起来.</p><h1 id="参考-2-内容"><a href="#参考-2-内容" class="headerlink" title="参考 2 内容"></a>参考 2 内容</h1><p>序列具有不同的长度，所有序列都以 ASCII 字符 <code>ESC</code> 即 <code>\</code> 开头，第二个字节则是 0x40 ～ 0x5F 范围内的字符.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决 Linux 输入长命令时不会自动换行，只会回到行行首，并且覆盖前面的内容问题</title>
    <link href="/2022/09/07/%E8%A7%A3%E5%86%B3-Linux-%E8%BE%93%E5%85%A5%E9%95%BF%E5%91%BD%E4%BB%A4%E6%97%B6%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%EF%BC%8C%E5%8F%AA%E4%BC%9A%E5%9B%9E%E5%88%B0%E8%A1%8C%E8%A1%8C%E9%A6%96%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%A6%86%E7%9B%96%E5%89%8D%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/07/%E8%A7%A3%E5%86%B3-Linux-%E8%BE%93%E5%85%A5%E9%95%BF%E5%91%BD%E4%BB%A4%E6%97%B6%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%EF%BC%8C%E5%8F%AA%E4%BC%9A%E5%9B%9E%E5%88%B0%E8%A1%8C%E8%A1%8C%E9%A6%96%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%A6%86%E7%9B%96%E5%89%8D%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>比如我之前的为:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">PS1</span>=&#x27;\<span class="hljs-number">033</span>[<span class="hljs-number">1</span>;<span class="hljs-number">95</span>m[\u@\h \W]\<span class="hljs-number">033</span>[<span class="hljs-number">0</span>m&#x27;<br></code></pre></td></tr></table></figure><p>就出现了问题。</p><p>解决, 即添加 <code>\[\]</code>:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">PS1</span>=&#x27;\[\<span class="hljs-number">033</span>[<span class="hljs-number">1</span>;<span class="hljs-number">95</span>m[\u@\h \W]\<span class="hljs-number">033</span>[<span class="hljs-number">0</span>m\]&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于 vim 插件 ultisnips 对 markdown 文件无效</title>
    <link href="/2022/09/06/%E5%85%B3%E4%BA%8E-vim-%E6%8F%92%E4%BB%B6-ultisnips-%E5%AF%B9-markdown-%E6%96%87%E4%BB%B6%E6%97%A0%E6%95%88/"/>
    <url>/2022/09/06/%E5%85%B3%E4%BA%8E-vim-%E6%8F%92%E4%BB%B6-ultisnips-%E5%AF%B9-markdown-%E6%96%87%E4%BB%B6%E6%97%A0%E6%95%88/</url>
    
    <content type="html"><![CDATA[<p>暂时没有办法.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UltiSnips 使用</title>
    <link href="/2022/09/06/UltiSnips-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/06/UltiSnips-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>文档资料在 <a href="https://github.com/SirVer/ultisnips.git">https://github.com/SirVer/ultisnips.git</a> 这个仓库的 <code>doc</code> 目录下.<br>也可在 <a href="https://sirver.net/">sirver 的个人博客</a>查看.<br>在 snippet 时，用 <code>&quot;</code> 来注释。</p><p>可以使用 <code>$1</code> 等特殊变量来标识光标的位置:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">snippets</span> t <span class="hljs-string">&quot;A simple HTML text&quot;</span><br>&lt;<span class="hljs-variable">$1</span>&gt; <br>    Hello World<br>&lt;/<span class="hljs-variable">$1</span>&gt;<br></code></pre></td></tr></table></figure><p>比如这一段，当你展开这个 snippets 的时候，光标位于 <code>$1</code> 处，然后你编辑内容时，另一个 <code>$1</code> 也会被编辑.</p><p>另一段, 多了一个 <code>&#123;&#125;</code>:      </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">snippets t <span class="hljs-string">&quot;A simple HTML text&quot;</span><br>&lt;<span class="hljs-variable">$&#123;</span><span class="hljs-number">1</span><span class="hljs-symbol">:div</span>&#125;&gt; <br>    <span class="hljs-title class_">Hello</span> <span class="hljs-title class_">World</span><br>&lt;/<span class="hljs-variable">$1</span>&gt;<br></code></pre></td></tr></table></figure><p>这会使光标选中这个文本 <code>div</code>.</p><p>第三个例子, 在 <code>snippets</code> 这一行后面加上一个 <code>b</code>, 即 begin, 表示只有在行首时在用 tab 直接展开:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">snippets t <span class="hljs-string">&quot;A simple HTML text&quot;</span> b<br>&lt;<span class="hljs-variable">$&#123;</span><span class="hljs-number">1</span><span class="hljs-symbol">:div</span>&#125;&gt; <br>    <span class="hljs-title class_">Hello</span> <span class="hljs-title class_">World</span><br>&lt;/<span class="hljs-variable">$1</span>&gt;<br></code></pre></td></tr></table></figure><p>第四个例子，可以使用正则表达式的替换功能:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">snippets t <span class="hljs-string">&quot;A simple HTML text&quot;</span> b<br>&lt;<span class="hljs-variable">$&#123;1:div&#125;</span>&gt; <br>    Hello World<br>&lt;<span class="hljs-regexp">/$&#123;1/</span>(\w+).*&#125;<span class="hljs-regexp">/$1/</span>&gt;<br></code></pre></td></tr></table></figure><p>这里 <code>&#123;</code> 后面的 1 仍然是光标的位置，最后一排的第二个 <code>$1</code> 表示在第一出光标处被选中的文本，也就是这里的 <code>div</code>.</p><p>使用 `` 包裹起来的部分可以直接写脚本，如 Shell Script, Vimsript, Perl, Python. 语法如下:</p><ul><li>Shell : `echo hi` or `#! &#x2F;usr&#x2F;bin&#x2F;perl<br>                          print “Hello”`</li><li>Vimscript : `!v “1 + 2” . string(1+2)`, 也就是前面有一个 <code>!v</code></li><li>Python : `!p snip.rc &#x3D; “Hello”`, 前面有个 <code>!p</code></li></ul><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是内网穿透</title>
    <link href="/2022/09/06/%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <url>/2022/09/06/%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<p>Intranet Penetration, 内网穿透, 也叫 NAT 穿透，其使具有某一个特定源 IP 地址和源端口号的数据包不被 NAT 设备屏蔽而正确路由到内网主机.</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 系统中常见目录名称及相应内容</title>
    <link href="/2022/09/06/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%86%85%E5%AE%B9/"/>
    <url>/2022/09/06/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/Linux%E7%9B%AE%E5%BD%95.png" alt="Linux目录"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中关于 Bluetooth</title>
    <link href="/2022/09/06/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Bluetooth/"/>
    <url>/2022/09/06/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Bluetooth/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Bluetooth">ArchWiki 中相关部分</a><br>Bluetooth 是一个短距离无线通信的标准，用于在手机，计算机和其他电子设备之间通信。</p><p>在 Linux 中，权威的蓝牙协议栈实现是 BlueZ</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>bluez, 提供蓝牙协议栈</li><li>bluez-utils, 提供  <code>bluetoothctl</code> 实用程序</li><li>btusb 内核模块，是通用的蓝牙驱动，需要检查其是否加载</li><li>启用 <code>bulutooth.service</code></li></ul><p>蓝牙守护进程默认只会向属于 <code>lp</code> 组的用户暴露 <code>bnep0</code> 设备，如果要连接到蓝牙设备，先将用户添加到这个组，可以在 <code>/usr/share/dbus-1/system.d/bluetooth.conf</code> 中修改。</p><p>一些蓝牙适配器和无线网卡绑定，这些蓝牙适配器需要先启用无线网卡才能被内核识别。</p><h1 id="配对"><a href="#配对" class="headerlink" title="配对"></a>配对</h1><p>在使用蓝牙设备之前先检查其有没有被 rfkill 禁用。</p><p>一般步骤：<br>先运行 <code>bluetoothctl</code> 进入交互界面:</p><ol><li>(可选操作) <code>select MAC_address</code>, 选择一个默认的蓝牙接收器</li><li><code>power on</code>, 打开蓝牙，默认为关闭</li><li><code>devices</code>, 获得要配对的设备的 MAC 地址</li><li><code>scan on</code>, 搜索发现所有可配对的设备</li><li><code>agent on</code>, 打开代理或者选择一个特定的代理</li><li><code>pair MAC_address</code>, 配对设备</li><li><code>trust MAC_address</code>, 添加到信任列表</li><li><code>connect MAC_address</code>, 建立链接</li></ol><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>开机后自启动等，见 ArchWiki</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中关于 ALSA</title>
    <link href="/2022/09/06/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-ALSA/"/>
    <url>/2022/09/06/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-ALSA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Advanced_Linux_Sound_Architecture">ArchWiki 相关页面</a><br>ALSA 是 Advanced Linux Sound Architecture 的简称，其提供声卡的内核驱动。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>ALSA 是一组内置的 Linux 内核模块，无需手动安装。</p><p>udev 会在系统启动时自动检测硬件并选择所需的驱动，并加载相应的声音设备驱动模块。</p><h2 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h2><p>一般情况下，本地用户有权播放音频和改变混音器音量。</p><p>要让远程用户拥有这些权限，需要把这些用户加入 <code>audio</code> 用户组。</p><p><code>audio</code> 用户组允许用户直接访问设备。默认情况下不建议把用户加入 <code>audio</code> 用户组.</p><h2 id="ALSA-实用程序"><a href="#ALSA-实用程序" class="headerlink" title="ALSA 实用程序"></a>ALSA 实用程序</h2><p>安装软件包 <code>alsa-utils</code> 其包含 <code>alsamixer</code>, <code>amixer</code> 等:</p><ul><li><code>amixer</code>, shell 命令</li><li><code>alsamixer</code>, 基于 ncurses 的界面</li></ul><h1 id="解除各声道的静音"><a href="#解除各声道的静音" class="headerlink" title="解除各声道的静音"></a>解除各声道的静音</h1><p>ALSA 默认静音所有声道，需要手动解除.</p><h2 id="使用-amixer"><a href="#使用-amixer" class="headerlink" title="使用 amixer"></a>使用 amixer</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ amixer sset <span class="hljs-keyword">Master</span> <span class="hljs-title">unmute</span><br>$ amixer sset Speaker unmute<br>$ amixer sset Headphone unmute<br></code></pre></td></tr></table></figure><h2 id="使用-alsamixer"><a href="#使用-alsamixer" class="headerlink" title="使用 alsamixer"></a>使用 alsamixer</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>alsamixer<br></code></pre></td></tr></table></figure><p>然后上下左右键位.</p><h2 id="启用麦克风"><a href="#启用麦克风" class="headerlink" title="启用麦克风"></a>启用麦克风</h2><p>按 <code>F4</code> 切换至 <code>Capture</code> 选项卡，然后按空格启用一个声道.</p><h2 id="测试更改"><a href="#测试更改" class="headerlink" title="测试更改"></a>测试更改</h2><p>测试声卡是否工作:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ speaker-<span class="hljs-keyword">test</span> -c <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>需根据扬声器的配置，调整 <code>-c</code>.</p><p>若系统有多个声卡，可以用 <code>F6</code> 切换.</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>系统配置文件是 <code>/etc/asound.conf</code>, 分用户配置文件是 <code>~/.asoundrc</code>.</p><p>基本语法见 ArchWiki.</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="禁止启动时自动静音"><a href="#禁止启动时自动静音" class="headerlink" title="禁止启动时自动静音"></a>禁止启动时自动静音</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta"># amixer -c 0 sset <span class="hljs-string">&quot;Auto-Mute Mode&quot;</span> Disabled</span><br></code></pre></td></tr></table></figure><p>使用 <code>alsamixerl</code> 图形界面时:</p><ul><li><code>alsactl store</code> 保存更改</li><li><code>alsactl daemon</code> 保存更改</li></ul><h2 id="键盘控制音量"><a href="#键盘控制音量" class="headerlink" title="键盘控制音量"></a>键盘控制音量</h2><p>将下面命令映射到你的音量键: <code>XF86AudioRaiseVolume</code>, <code>XF86AudioLowerVolume</code>, <code>XF86AudioMute</code>:<br>增加音量:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">amixer set <span class="hljs-keyword">Master</span> <span class="hljs-title">5</span>%+<br></code></pre></td></tr></table></figure><p>减小音量:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">amixer set <span class="hljs-keyword">Master</span> <span class="hljs-title">5</span>%-<br></code></pre></td></tr></table></figure><p>静音&#x2F;解除静音:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">amixer set <span class="hljs-keyword">Master</span> <span class="hljs-title">toggle</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于 Shell 字体美化</title>
    <link href="/2022/09/06/%E5%85%B3%E4%BA%8E-Shell-%E5%AD%97%E4%BD%93%E7%BE%8E%E5%8C%96/"/>
    <url>/2022/09/06/%E5%85%B3%E4%BA%8E-Shell-%E5%AD%97%E4%BD%93%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h1><ul><li>为单个用户安装，将字体放入 <code>~/.local/share/fonts</code> 目录下</li><li>为系统所有用户安装，安装到 <code>/usr/local/share/fonts</code> 目录下, <code>/usr/share/fonts</code> 由包管理器管理，不要手动修改</li></ul><p>需要确保所有用户都有读取字体文件的权限.</p><h1 id="后备字体顺序"><a href="#后备字体顺序" class="headerlink" title="后备字体顺序"></a>后备字体顺序</h1><p>Fontconfig 会自动选择一个满足当前显示需求的字体。</p><p>Fontconfig 允许每个用户使用 <code>$XDG_CONFIG_HOME/fontconfig/fonts.conf</code> 赖调整字体的选择顺序.</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="列出所有已安装字体"><a href="#列出所有已安装字体" class="headerlink" title="列出所有已安装字体"></a>列出所有已安装字体</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">fc</span><span class="hljs-literal">-list</span><br></code></pre></td></tr></table></figure><h2 id="列出特定语言的已安装字体"><a href="#列出特定语言的已安装字体" class="headerlink" title="列出特定语言的已安装字体"></a>列出特定语言的已安装字体</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>fc-list <span class="hljs-symbol">:lang=<span class="hljs-string">&quot;&quot;</span></span><br></code></pre></td></tr></table></figure><p>如中文:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>fc-list <span class="hljs-symbol">:lang=<span class="hljs-string">&quot;zh&quot;</span></span><br></code></pre></td></tr></table></figure><p>可安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S extra/noto-fonts-cjk<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bash 中 tput 使用</title>
    <link href="/2022/09/05/Bash-%E4%B8%AD-tput-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/05/Bash-%E4%B8%AD-tput-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/brahmsjiang/article/details/78170238">参考</a><br><a href="inmp.ailinux.net/tput">参考</a><br>tput 命令通过将 terminfo 数据库对你的终端会话进行初始化和操作。</p><p>可以移动或更改光标，更改文本属性，以及清除终端屏幕的特性。</p><h1 id="terminfo"><a href="#terminfo" class="headerlink" title="terminfo"></a>terminfo</h1><p>UNIX 系统上的 terminfo 数据库用于定义终端和打印机的属性及功能，包括各设备的行数和列数以及要发送至该设备的文本的属性.</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="改变光标属性"><a href="#改变光标属性" class="headerlink" title="改变光标属性"></a>改变光标属性</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">tput <span class="hljs-attribute">clear</span> # 清屏<br>tput sc # save <span class="hljs-attribute">cursor</span> <span class="hljs-attribute">position</span> 保存当前光标位置 <br>tput cup <span class="hljs-number">10</span> <span class="hljs-number">13</span> # <span class="hljs-attribute">cursor</span> <span class="hljs-attribute">position</span> 将光标移动到 row10 col13<br>tput civis # <span class="hljs-attribute">cursor</span> invisible 光标不可见<br>tput cnorm # <span class="hljs-attribute">cursor</span> <span class="hljs-attribute">normal</span> 光标可见<br>tput rc # restore <span class="hljs-attribute">cursor</span> <span class="hljs-attribute">position</span> 光标返回上次保存的位置<br></code></pre></td></tr></table></figure><h3 id="移动光标并显示信息"><a href="#移动光标并显示信息" class="headerlink" title="移动光标并显示信息"></a>移动光标并显示信息</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">tput</span> sc ; <span class="hljs-attribute">tput</span> cup <span class="hljs-number">23</span> <span class="hljs-number">45</span> ; <span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;Input from tput/echo at 23/45&quot;</span> ; <span class="hljs-attribute">tput</span> rc<br></code></pre></td></tr></table></figure><p>这条语句让光标先移动到 (23, 45) 这个坐标，然后打印 <code>Input from tput/echo at 23/45</code> 这句话，最后返回原来的位置.</p><p>在显示了信息之后，光标必须使用 <code>tput rc</code> 返回到之前保存的原始位置.</p><h3 id="更改光标的属性"><a href="#更改光标的属性" class="headerlink" title="更改光标的属性"></a>更改光标的属性</h3><p>在向某一设备显示数据时，将光标转换为不可见可以使数据滚动时的屏幕看起来更整洁，可先使用 <code>civis</code> 选项，再使用 <code>cnorm</code> 选项.</p><h2 id="改变文本属性"><a href="#改变文本属性" class="headerlink" title="改变文本属性"></a>改变文本属性</h2><p>如，使文本加粗，在文本下方添加下划线，更改背景颜色和前景颜色，逆转颜色等。</p><ul><li><code>tput setb</code>, set background</li><li><code>tput setf</code>, set foregrounf<br>颜色和分配的数值有关:</li><li>0 : 黑色</li><li>1 : 蓝色</li><li>2 : 绿色</li><li>3 : 青色</li><li>4 : 红色</li><li>5 : 洋红色</li><li>6 : 黄色</li><li>7 : 白色<br>反显当前颜色 <code>tput rev</code>.</li></ul><p>粗体使用 <code>tput bold</code>.</p><p>添加下划线使用 <code>tput smul</code>, 去除下划线使用 <code>tput rmul</code></p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中关于 Bash 的美化</title>
    <link href="/2022/09/05/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Bash-%E7%9A%84%E7%BE%8E%E5%8C%96/"/>
    <url>/2022/09/05/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-Bash-%E7%9A%84%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Bash/Prompt_customization">ArchWiki Bash&#x2F;Prompt</a></p><h1 id="Bash-x2F-Prompt-customization"><a href="#Bash-x2F-Prompt-customization" class="headerlink" title="Bash&#x2F;Prompt customization"></a>Bash&#x2F;Prompt customization</h1><h2 id="Prompts"><a href="#Prompts" class="headerlink" title="Prompts"></a>Prompts</h2><p>Bash 有 4 个 prompt strings 可以自定义.</p><p>这里的 <code>PS</code> 是 <code>Prompt Stringl</code> 的含义:</p><ul><li><code>PS0</code>, 在每次命令输出后显示在 output 之前, 几乎每个命令都会有输出，它就位于输出之前, 默认是没有的</li><li><code>PS1</code>, 其为基础的 prompt, 会显示在命令之前, 就比如现在的 <code>[jie@EVA ~]$</code>, 全部</li><li><code>PS2</code>, 当 command 需要更多 input 时显示, 如 <code>echo &lt;&lt; EOF</code> 后出现的 <code>&gt;</code></li><li><code>PS3</code></li><li><code>PS4</code></li></ul><p>所有的这些 prompt 都可以在 <code>~/.bashrc</code> 中设置, 如:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">PS2</span>=<span class="hljs-string">&#x27;&gt;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h2><h3 id="Bash-escape-sequeces"><a href="#Bash-escape-sequeces" class="headerlink" title="Bash escape sequeces"></a>Bash escape sequeces</h3><p>当打印 prompt string 时，Bash 会寻找某些反斜线转义的字符 (backslash-escaped characters), 然后把它们扩展成 special strings, 如:</p><ul><li><code>\u</code>, 会被扩展成当前用户的名称</li><li><code>\A</code>, 会被扩展成当前的时间<br>因此，如果:<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r">PS1<span class="hljs-operator">=</span>`\A \u $`<br></code></pre></td></tr></table></figure>就会被扩展成 <code>17:35 username $</code>.</li></ul><p>在 <code>man bash</code> 中查找 <code>PROMTING</code> 可以看到全部列表.</p><p>以下为我自己可能会用到的:</p><ul><li><code>\d</code>, 以 “Weekday Month Date” 的形式显示时间</li><li><code>\h</code>, 第一个 <code>.</code> 之前的 hostname, 一般的 hostname 不一定是一个单词</li><li><code>\H</code>, the hostname</li><li><code>\j</code>, the number of jobs currently managed by shell</li><li><code>\i</code>, the basename of the shell’s terminal device name</li><li><code>\s</code>, shell 的名字</li><li><code>\t</code>, 用 24 小时制 “HH:MM:SS” 显示当前时间</li><li><code>\u</code>, 当前用户的名称</li><li><code>\w</code>, 当前目录，<code>$HOME</code> 被简化为 <code>~</code> 波浪线 (tilde)</li><li><code>\[</code>, 开始 a sequence of non-printing character, 即不会显示出非打印字符</li><li><code>\]</code>, 结束 a sequence of non-printing character<br><code>\a</code> 蜂鸣，<code>\n</code> 换行等都是 non-printing character.</li></ul><h3 id="Terminfo-escape-sequences"><a href="#Terminfo-escape-sequences" class="headerlink" title="Terminfo escape sequences"></a>Terminfo escape sequences</h3><p>查看当前 terminal 提供的 capabilities:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>infocmp<br></code></pre></td></tr></table></figure><p>出现在 <code>=</code> 之前的是 <code>capability</code> 的名字. 可在 <code>/usr/share/terminfo</code> 里面查看具体内容.</p><p>比如 <code>setaf</code> 用来设置 <code>foreground color of whatever text is printed after it</code></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>tput setaf <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>设置例子:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">GREEN</span>=<span class="hljs-string">&quot;\[<span class="hljs-variable">$(tput setaf 2)</span>\]&quot;</span><br><span class="hljs-attribute">RESET</span>=<span class="hljs-string">&quot;\[<span class="hljs-variable">$(tput sgr0)</span>\]&quot;</span><br><br><span class="hljs-attribute">PS1</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;GREEN&#125;</span>my prompt<span class="hljs-variable">$&#123;RESET&#125;</span>&gt;&quot;</span><br></code></pre></td></tr></table></figure><p>Bash man page 建议把 <code>tput</code> 的输出用 <code>\[ \]</code> 包裹。这会帮助 bash 忽略非打印字符 (non-printable characters).</p><h3 id="PROMPT-COMMAND"><a href="#PROMPT-COMMAND" class="headerlink" title="PROMPT_COMMAND"></a>PROMPT_COMMAND</h3><p>这是一个变量，它的值会在 <code>PS1</code> 显示之前被 evaluated. 可用于 resign <code>PS1</code>.</p><h3 id="Escapes-between-command-input-and-output"><a href="#Escapes-between-command-input-and-output" class="headerlink" title="Escapes between command input and output"></a>Escapes between command input and output</h3><p>很多属性在改变后记得 reset.</p><h3 id="Customizing-root-prompts"><a href="#Customizing-root-prompts" class="headerlink" title="Customizing root prompts"></a>Customizing root prompts</h3><p>在 <code>/root</code> 中修改。</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="infocmp-命令"><a href="#infocmp-命令" class="headerlink" title="infocmp 命令"></a>infocmp 命令</h3><p>会显示 the number of colors <code>tput</code> works with.</p><h1 id="参考另一篇文章"><a href="#参考另一篇文章" class="headerlink" title="参考另一篇文章"></a>参考另一篇文章</h1><p><a href="https://b23.tv/8VgYZzp">参考</a></p><h2 id="bash-手册"><a href="#bash-手册" class="headerlink" title="bash 手册"></a>bash 手册</h2><p><code>bash 1 printf</code> 是查看 bash shell 中 <code>printf</code> 的使用.</p><p><code>bash 3 printf</code> 可以查看 C 语言中 <code>printf</code> 的使用.</p><p>一个例子:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">printf</span> &#x27;\<span class="hljs-number">033</span>[<span class="hljs-number">1</span>;<span class="hljs-number">32</span>m yes \<span class="hljs-number">033</span>[<span class="hljs-number">0</span>m&#x27;<br></code></pre></td></tr></table></figure><ul><li><code>\033[</code> 表示开始的色彩控制.</li><li><code>1</code> 表示加粗</li><li><code>;</code> 表示分隔</li><li><code>32m</code> 表示绿色</li><li><code>\033[0m</code>  两个 <code>\033[</code> 之间的内容是范围，<code>0m</code> 是结束<br>具体的颜色可参见 <code>https://misc.flogisoft.com/bash/tip_colors_and_formatting</code>.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 查看设备和驱动安装相关信息</title>
    <link href="/2022/09/05/Linux-%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/"/>
    <url>/2022/09/05/Linux-%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/m1223853767/article/details/79615011">参考</a></p><h1 id="列出所有硬件信息"><a href="#列出所有硬件信息" class="headerlink" title="列出所有硬件信息"></a>列出所有硬件信息</h1><p><code>lspci</code> 命令可以列出所有硬件信息，包括已经安装了驱动和为安装驱动的硬件设备，通过 <code>pci</code> 总线的连接情况读取信息.</p><h1 id="列出当前系统中所有已经加载了的模块-x2F-驱动"><a href="#列出当前系统中所有已经加载了的模块-x2F-驱动" class="headerlink" title="列出当前系统中所有已经加载了的模块&#x2F;驱动"></a>列出当前系统中所有已经加载了的模块&#x2F;驱动</h1><p>使用 <code>lsmod</code> 命令.</p><p><code>lsmod</code> 命令只能显示编译 linux 内核时选中为 “M” 的驱动程序。</p><h1 id="查看该设备的驱动有没有安装"><a href="#查看该设备的驱动有没有安装" class="headerlink" title="查看该设备的驱动有没有安装"></a>查看该设备的驱动有没有安装</h1><p>用 dmesg 命令，其信息较多，需要用 <code>grep</code> 过滤。</p><h1 id="单看指定模块-x2F-驱动的信息"><a href="#单看指定模块-x2F-驱动的信息" class="headerlink" title="单看指定模块&#x2F;驱动的信息"></a>单看指定模块&#x2F;驱动的信息</h1><p>使用 modinfo 命令.</p><p>alias 指这个模块&#x2F;驱动所支持的硬件型号。</p><h1 id="加载驱动"><a href="#加载驱动" class="headerlink" title="加载驱动"></a>加载驱动</h1><p>用modprobe 或 insmod 命令.</p><h1 id="删除一个模块-x2F-驱动"><a href="#删除一个模块-x2F-驱动" class="headerlink" title="删除一个模块&#x2F;驱动"></a>删除一个模块&#x2F;驱动</h1><p>用 rmmod 命令.</p><h1 id="确定需要安装驱动的硬件型号"><a href="#确定需要安装驱动的硬件型号" class="headerlink" title="确定需要安装驱动的硬件型号"></a>确定需要安装驱动的硬件型号</h1><p>查看 <code>/etc/sysconfig/hwconf</code>.</p><p>vendorld 指的是硬件的生产商编号。</p><p>deviceld 指该设备的编号，一般生产商和设备编号都是四位。</p><h1 id="查找与设备相关的信息"><a href="#查找与设备相关的信息" class="headerlink" title="查找与设备相关的信息"></a>查找与设备相关的信息</h1><p>到 <code>http://pci-ids.ucw.cz/iii/</code> 这个网站查找。</p><h1 id="常用的检测命令"><a href="#常用的检测命令" class="headerlink" title="常用的检测命令"></a>常用的检测命令</h1><h2 id="用硬件检测程序-kuduz-探测新硬件"><a href="#用硬件检测程序-kuduz-探测新硬件" class="headerlink" title="用硬件检测程序 kuduz 探测新硬件"></a>用硬件检测程序 kuduz 探测新硬件</h2><h2 id="查看-CPU-信息"><a href="#查看-CPU-信息" class="headerlink" title="查看 CPU 信息"></a>查看 CPU 信息</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>cpuinfo<br></code></pre></td></tr></table></figure><h2 id="查看板卡信息"><a href="#查看板卡信息" class="headerlink" title="查看板卡信息"></a>查看板卡信息</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>pci<br></code></pre></td></tr></table></figure><h2 id="查看-PCI-信息"><a href="#查看-PCI-信息" class="headerlink" title="查看 PCI 信息"></a>查看 PCI 信息</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">lspci</span><br></code></pre></td></tr></table></figure><h2 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/m</span>eminfo<br></code></pre></td></tr></table></figure><h2 id="查看-USB-设备信息"><a href="#查看-USB-设备信息" class="headerlink" title="查看 USB 设备信息"></a>查看 USB 设备信息</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>bus<span class="hljs-regexp">/usb/</span>devices<br></code></pre></td></tr></table></figure><h2 id="查看鼠标和键盘信息"><a href="#查看鼠标和键盘信息" class="headerlink" title="查看鼠标和键盘信息"></a>查看鼠标和键盘信息</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>bus<span class="hljs-regexp">/input/</span>devices<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>bus<span class="hljs-regexp">/usb/</span>devices<br></code></pre></td></tr></table></figure><h2 id="查看硬件信息和使用情况"><a href="#查看硬件信息和使用情况" class="headerlink" title="查看硬件信息和使用情况"></a>查看硬件信息和使用情况</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">fdisk <span class="hljs-meta">&amp; disk -l &amp; df</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>bus<span class="hljs-regexp">/input/</span>devices<br></code></pre></td></tr></table></figure><h2 id="查看各设备的中断请求-IRQ"><a href="#查看各设备的中断请求-IRQ" class="headerlink" title="查看各设备的中断请求 (IRQ)"></a>查看各设备的中断请求 (IRQ)</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/i</span>nterrupts<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">fdisk <span class="hljs-meta">&amp; disk -l &amp; df</span><br></code></pre></td></tr></table></figure><h2 id="查看系统体系结构"><a href="#查看系统体系结构" class="headerlink" title="查看系统体系结构"></a>查看系统体系结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/i</span>nterrupts<br></code></pre></td></tr></table></figure><h2 id="查看包括-bios-cpu-内存等信息"><a href="#查看包括-bios-cpu-内存等信息" class="headerlink" title="查看包括 bios, cpu, 内存等信息"></a>查看包括 bios, cpu, 内存等信息</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">dmidecode</span><br></code></pre></td></tr></table></figure><h2 id="查看硬件信息"><a href="#查看硬件信息" class="headerlink" title="查看硬件信息"></a>查看硬件信息</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">dmesg <span class="hljs-string">| more</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Archlinux 的美化(一部分)</title>
    <link href="/2022/09/05/Archlinux-%E7%9A%84%E7%BE%8E%E5%8C%96-%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/05/Archlinux-%E7%9A%84%E7%BE%8E%E5%8C%96-%E4%B8%80%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="定制简易的系统状态栏"><a href="#定制简易的系统状态栏" class="headerlink" title="定制简易的系统状态栏"></a>定制简易的系统状态栏</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S xsetroot</span><br></code></pre></td></tr></table></figure><p>但貌似我已经安装好了.</p><h1 id="系统音量调节"><a href="#系统音量调节" class="headerlink" title="系统音量调节"></a>系统音量调节</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S alsa-utils</span><br></code></pre></td></tr></table></figure><p>然后使用 amixer 来调节.</p><h1 id="调节屏幕亮度"><a href="#调节屏幕亮度" class="headerlink" title="调节屏幕亮度"></a>调节屏幕亮度</h1><p>用 xbacklight.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Suckless 的 slock 锁屏软件</title>
    <link href="/2022/09/05/Suckless-%E7%9A%84-slock-%E9%94%81%E5%B1%8F%E8%BD%AF%E4%BB%B6/"/>
    <url>/2022/09/05/Suckless-%E7%9A%84-slock-%E9%94%81%E5%B1%8F%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="http://tools.suckless.org/slock/">Suckless</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>slock 是 simple X display locker.</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>其配置文件位于 <code>config.h</code>.</p><h1 id="使用-Xautolock"><a href="#使用-Xautolock" class="headerlink" title="使用 Xautolock"></a>使用 Xautolock</h1><p>可以用 xssstate 或 xss 替换。</p><p>slock 会在用户一段时间没动静时被 xautolock 启用. </p><p>语法格式:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">xautolock</span> -time <span class="hljs-number">10</span> -locker slock<br></code></pre></td></tr></table></figure><p>直接输入 <code>slock</code> 会使屏幕锁住，直到你输入密码.</p><h1 id="slock-getgrnam-nogroup-group-entry-not-found-报错"><a href="#slock-getgrnam-nogroup-group-entry-not-found-报错" class="headerlink" title="slock: getgrnam nogroup: group entry not found 报错"></a>slock: getgrnam nogroup: group entry not found 报错</h1><p>其原因为 <code>config.h</code> 中的:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *user = <span class="hljs-string">&quot;nobody&quot;</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *<span class="hljs-keyword">group</span> = <span class="hljs-string">&quot;nogroup&quot;</span><br></code></pre></td></tr></table></figure><p>出错。</p><p>在 Arch 中，没有权限的 group 仍然称为 <code>nobody</code>, 因此，把 <code>nogroup</code> 改为 <code>nobody</code> 就可以了.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>先拉取源代码:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://git.suckless.org/slock --<span class="hljs-attr">depth=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>进入目录后:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo make clean <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><h1 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h1><h2 id="添加-blured-of-pixelated-screeshot"><a href="#添加-blured-of-pixelated-screeshot" class="headerlink" title="添加 blured of pixelated screeshot"></a>添加 blured of pixelated screeshot</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget http:<span class="hljs-regexp">//</span>tools.suckless.org<span class="hljs-regexp">/slock/</span>patches<span class="hljs-regexp">/blur-pixelated-screen/</span>slock-blur_pixelated_screen-<span class="hljs-number">1.4</span>.diff<br></code></pre></td></tr></table></figure><p>然后:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">patch</span> &lt; slock-blur_pixelated_screen-<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.diff<br></code></pre></td></tr></table></figure><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Arch 中安装 pip</title>
    <link href="/2022/09/05/Arch-%E4%B8%AD%E5%AE%89%E8%A3%85-pip/"/>
    <url>/2022/09/05/Arch-%E4%B8%AD%E5%AE%89%E8%A3%85-pip/</url>
    
    <content type="html"><![CDATA[<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S python-pip</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ranger 工具的安装和使用</title>
    <link href="/2022/09/05/Ranger-%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/05/Ranger-%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ranger/ranger">Github 相关</a><br>ranger 是一个命令行下的文件管理器 (file manager).</p><p>可以在 <code>man ranger</code> 和 <code>HACKING.md</code> 中查看信息.</p><p>对于配置，可以查看 <code>ranger/config/</code> 或者复制默认配置到 <code>~/.config/ranger</code> with <code>ranger --copy-config</code>.</p><p><code>examples/</code> 中包含了脚本和插件，这些文件可以在 <code>/usr/share/doc/ranger</code> 中查看。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>先克隆下仓库:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ranger/</span>ranger.git --depth=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>运行:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo make <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p>使用 <code>h</code> <code>j</code> <code>k</code> <code>l</code> 来 navigate.</p><p><code>Enter</code> 来打开文件。</p><p><code>q</code> 来退出.</p><p>第三列会显示 preview of the current file.</p><p>在 <code>ranger help</code> 中查看更多信息.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是 tmux</title>
    <link href="/2022/09/05/%E4%BB%80%E4%B9%88%E6%98%AF-tmux/"/>
    <url>/2022/09/05/%E4%BB%80%E4%B9%88%E6%98%AF-tmux/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Google 如何搭梯子</title>
    <link href="/2022/09/05/Google-%E5%A6%82%E4%BD%95%E6%90%AD%E6%A2%AF%E5%AD%90/"/>
    <url>/2022/09/05/Google-%E5%A6%82%E4%BD%95%E6%90%AD%E6%A2%AF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.businessnewsdaily.com/15710-how-to-install-a-vpn-connection.html#what-is-a-vpn">How to Install a VPN Connection</a></p>]]></content>
    
    
    <categories>
      
      <category>CNAA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于 PlugInstall 失败问题</title>
    <link href="/2022/09/05/%E5%85%B3%E4%BA%8E-PlugInstall-%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/05/%E5%85%B3%E4%BA%8E-PlugInstall-%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>多试几次就可以安装好.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 libinput</title>
    <link href="/2022/09/05/ArchWiki-%E4%B8%AD-libinput/"/>
    <url>/2022/09/05/ArchWiki-%E4%B8%AD-libinput/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Libinput">ArchWiki libinput</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>libinput 是一个函数库，在 Wayland 上用来接受设备的输入，在 X.Org 上提供输入设备的驱动。它提供对设备事件的检测和接收，对输入设备信号进行处理.</p><p>X.Org 输入驱动为大多数常规输入设备提供了支持，libinput 项目的目标是为触摸板和触摸屏的触摸功能提供高级支持.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在 Xorg 系统中，xf86-input-libinput 包是默认依赖。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>对于 Xorg, 默认的配置文件安装在 <code>/usr/share/X11/xorg.conf.d/40-libinput.conf</code>.</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># libinput list-devices</span><br></code></pre></td></tr></table></figure><p>输出系统中的设备和它们被 libinput 支持的具体特性.</p><h2 id="查看所有设备并确定其名称和编号"><a href="#查看所有设备并确定其名称和编号" class="headerlink" title="查看所有设备并确定其名称和编号"></a>查看所有设备并确定其名称和编号</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>xinput list<br></code></pre></td></tr></table></figure><h2 id="查看-device-的设置"><a href="#查看-device-的设置" class="headerlink" title="查看 device 的设置"></a>查看 device 的设置</h2><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">xinput</span> <span class="hljs-built_in">list-props</span> <span class="hljs-string">device</span><br></code></pre></td></tr></table></figure><h2 id="修改某项设置"><a href="#修改某项设置" class="headerlink" title="修改某项设置"></a>修改某项设置</h2><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">xinput</span> <span class="hljs-built_in">set-prop</span> <span class="hljs-string">device</span> <span class="hljs-string">option</span> <span class="hljs-string">setting</span><br></code></pre></td></tr></table></figure><p><code>device</code> 和 <code>setting</code> 都可以是编号.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关闭 Archlinux 命令行蜂鸣声</title>
    <link href="/2022/09/05/%E5%85%B3%E9%97%AD-Archlinux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%9C%82%E9%B8%A3%E5%A3%B0/"/>
    <url>/2022/09/05/%E5%85%B3%E9%97%AD-Archlinux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%9C%82%E9%B8%A3%E5%A3%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Reason"><a href="#Reason" class="headerlink" title="Reason"></a>Reason</h1><p>主板上的蜂鸣器模块处于打开状态，关闭即可.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>先查看:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">sudo lsmod<span class="hljs-string">| grep pcspkr</span><br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/modprobe.d/nobeep.conf</code> 文件，输入 <code>blacklist pcspkr</code>，然后重启.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>修复 fcitx 无法在终端下使用中文</title>
    <link href="/2022/09/05/%E4%BF%AE%E5%A4%8D-fcitx-%E6%97%A0%E6%B3%95%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87/"/>
    <url>/2022/09/05/%E4%BF%AE%E5%A4%8D-fcitx-%E6%97%A0%E6%B3%95%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>原因是我先把 ArchWiki 上面建议的一些环境变量写在了 <code>~.xinitrc</code> 中，导致其没有其效果，要写在 <code>.pam_environment</code> 这个文件中.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fix the messy code of archlinux to display chinese</title>
    <link href="/2022/09/05/Fix-the-messy-code-of-archlinux-to-display-chinese/"/>
    <url>/2022/09/05/Fix-the-messy-code-of-archlinux-to-display-chinese/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Localization/Chinese">ArchWiki</a><br>Click the hyperlink above, you can chose a font to download.</p><h1 id="Reason"><a href="#Reason" class="headerlink" title="Reason"></a>Reason</h1><p>Why this happen.</p><p>When we locale our archlinux at the very beginning, we uncomment two line in file <code>/etc/locale.gen</code> and set the <code>LANG</code> variable by adding <code>LANG=en_US.UTF-8</code> to <code>/etc/locale.conf</code>:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">sed -i <span class="hljs-string">&#x27;s/^#en_US.UTF-8/en_US.UTF-8/&#x27;</span> <span class="hljs-regexp">/etc/</span>locale.gen<br>sed -i <span class="hljs-string">&#x27;s/^#zh_CN.UTF-8/zh_CN.UTF-8/&#x27;</span> <span class="hljs-regexp">/etc/</span>locale.gen<br>locale-gen<br>echo <span class="hljs-string">&quot;LANG=en_US.UTF-8&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>locale.conf<br></code></pre></td></tr></table></figure><p>That’s not enough.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>One Chinese font needed to be download to display the Chinese in the right way:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S wqy-zenhei</span><br></code></pre></td></tr></table></figure><p>It will be fixxed</p><h1 id="Adding-Chinese-input-method-and-googlepinyin"><a href="#Adding-Chinese-input-method-and-googlepinyin" class="headerlink" title="Adding Chinese input method and googlepinyin"></a>Adding Chinese input method and googlepinyin</h1><p>Install the fcitx:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman fcitx fcitx-googlepinyin fcitx-configtool</span><br></code></pre></td></tr></table></figure><p>Adding some environment variable in <code>~/.xinitrc</code> and start the fcitx when you enter X:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> GTK_IM_MODULE <span class="hljs-attribute">DEFAULT</span>=fcitx<br><span class="hljs-built_in">export</span> QT_IM_MODULE  <span class="hljs-attribute">DEFAULT</span>=fcitx<br><span class="hljs-built_in">export</span> XMODIFIERS    <span class="hljs-attribute">DEFAULT</span>=\@im=fcitx<br>fcitx<br></code></pre></td></tr></table></figure><p>Use <code>fcitx-configtool</code> to set googlepinyin:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>fcitx-configtool<br></code></pre></td></tr></table></figure><p>restart the X.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Screen Shot on Archlinux with dwm</title>
    <link href="/2022/09/04/Screen-Shot-on-Archlinux-with-dwm/"/>
    <url>/2022/09/04/Screen-Shot-on-Archlinux-with-dwm/</url>
    
    <content type="html"><![CDATA[<h1 id="scrot"><a href="#scrot" class="headerlink" title="scrot"></a>scrot</h1><p>install scrot:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S scrot</span><br></code></pre></td></tr></table></figure><h1 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h1><p>Input <code>scrot</code> on command line, and it will save the screen shot in the current file.</p><p>You can specify the window by <code>-s</code> option.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>To adjust the volume on archlinux</title>
    <link href="/2022/09/04/To-adjust-the-volume-on-archlinux/"/>
    <url>/2022/09/04/To-adjust-the-volume-on-archlinux/</url>
    
    <content type="html"><![CDATA[<p>You can not use <code>F2</code> or <code>Fn + F2</code> to adjust the volume, we also need to install a software:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S pulseaudio pulseaudio-alsa pulseaudio-equalizer alsa-utils pavucontrol playerctl</span><br></code></pre></td></tr></table></figure><p>I just install pulseaudio now.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Preview Picture and Change the background of dwm</title>
    <link href="/2022/09/04/Preview-Picture-and-Change-the-background-of-dwm/"/>
    <url>/2022/09/04/Preview-Picture-and-Change-the-background-of-dwm/</url>
    
    <content type="html"><![CDATA[<p>Two software should be installed.</p><h1 id="sxiv"><a href="#sxiv" class="headerlink" title="sxiv"></a>sxiv</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S sxiv</span><br></code></pre></td></tr></table></figure><p>It’s used to preview the picture.</p><p>You need to enter the picture directory first.</p><p>Grammer:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sxiv *    <br></code></pre></td></tr></table></figure><p>Then you can click mouse to change the picture.</p><h1 id="xwallpaper"><a href="#xwallpaper" class="headerlink" title="xwallpaper"></a>xwallpaper</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S xwallpaper</span><br></code></pre></td></tr></table></figure><p>It’s used to set the wallpaper.</p><p>If the path of the picture is <code>~/bgd/wall.png</code>, the grammer:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">xwallpaper --zoom ~<span class="hljs-regexp">/bgd/</span>wall.png<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>About lazygit</title>
    <link href="/2022/09/04/About-lazygit/"/>
    <url>/2022/09/04/About-lazygit/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Beautify the st</title>
    <link href="/2022/09/04/Beautify-the-st/"/>
    <url>/2022/09/04/Beautify-the-st/</url>
    
    <content type="html"><![CDATA[<h1 id="Changing-the-font-size"><a href="#Changing-the-font-size" class="headerlink" title="Changing the font size"></a>Changing the font size</h1><p>It’s better to remove the <code>config.def.h</code> file.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo <span class="hljs-built_in">rm</span> <br></code></pre></td></tr></table></figure><p>Edit the <code>config.h</code> file, changing the value of <code>pixelsize</code>.</p><p>Then reload the st:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ sudo make clean <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><h1 id="The-way-to-patch"><a href="#The-way-to-patch" class="headerlink" title="The way to patch"></a>The way to patch</h1><p>Go to the official Web and get the patch by <code>wget</code> like:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ wget http:<span class="hljs-regexp">//</span>st.suckless.org<span class="hljs-regexp">/patches/</span>alpha/st-alpha-<span class="hljs-number">20220206</span>-<span class="hljs-number">0.8</span>.<span class="hljs-number">5</span>.diff<br></code></pre></td></tr></table></figure><p>Use <code>patch &lt;</code> to patch the <code>.diff</code> file:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ patch &lt; <span class="hljs-keyword">st</span>-<span class="hljs-keyword">alpha</span>-20220206-0.8.5.diff<br></code></pre></td></tr></table></figure><h1 id="To-make-the-background-blur"><a href="#To-make-the-background-blur" class="headerlink" title="To make the background blur"></a>To make the background blur</h1><p>Patch the st-alpha-0.8.2.diff.</p><h1 id="To-change-the-color"><a href="#To-change-the-color" class="headerlink" title="To change the color"></a>To change the color</h1><p>Patch the st-dracula-0.8.5.diff</p><h1 id="Allow-you-to-scrollback"><a href="#Allow-you-to-scrollback" class="headerlink" title="Allow you to scrollback"></a>Allow you to scrollback</h1><p>Patch the st-scrollback-mouse-altscreen-20220127-2c5edf2.diff</p>]]></content>
    
    
    <categories>
      
      <category>Suckless</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/04/hello-world/"/>
    <url>/2022/09/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 xinit 部分</title>
    <link href="/2022/09/04/ArchWiki-%E4%B8%AD-xinit-%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/04/ArchWiki-%E4%B8%AD-xinit-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org.title/Xinit">ArchWiki 中 xinit 部分</a><br>xinit 程序允许用户手动启动 Xorg 显示服务器。</p><p>startx 脚本是 xinit 的一个前端。</p><p>xinit 通常用于启动窗口管理器或桌面环境.</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>xinit 和 startx 需要一个可选的客户端程序参数，如果没有提供参数，它们会2寻找 <code>~/.xinitrc</code> 作为一个 shell 脚本运行。</p><h2 id="xinitrc"><a href="#xinitrc" class="headerlink" title="xinitrc"></a>xinitrc</h2><p><code>~/.xinitrc</code> 如果存在于用户的主目录中，startx 和 xinit 会执行它, 否则，startx 将运行默认的 <code>/etc/X11/xinit/xinitrc</code>.</p><p>这个默认的 xinitrc 将启动一个包含 Twm, xorg-xclock 和 Xterm 的基本环境，要启动不同的窗口管理器或桌面环境，首先要在主目录下创建一个默认的 <code>xinitrc</code> 副本.</p><p>注意 <code>exec</code> 后面的行将会被忽略，因此其他的东西应该放在 <code>exec</code> 这行命令之前.</p><p>在窗口管理器之前启动的长期运行的程序，如屏保和墙纸程序，必须使用 <code>&amp;</code> 放入后台运行，否则，在执行窗口管理器或桌面环境之前，脚本会停止运行并等待每个程序退出.</p><h2 id="登录时自动启动-X"><a href="#登录时自动启动-X" class="headerlink" title="登录时自动启动 X"></a>登录时自动启动 X</h2><p>在 login shell 初始化文件，如 Bash 的 <code>~/.bash_profile</code> 或 Zsh 的 <code>~/.zprofile</code> 中放置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DISPLAY&#125;</span>&quot;</span> ] &amp;&amp; [ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;XDG_VTNR&#125;</span>&quot;</span> -eq 1 ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">exec</span> startx<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h2 id="在没有窗口管理器的情况下启动应用程序"><a href="#在没有窗口管理器的情况下启动应用程序" class="headerlink" title="在没有窗口管理器的情况下启动应用程序"></a>在没有窗口管理器的情况下启动应用程序</h2><p>如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ~/.xinitrc</span><br><br>...<br><br><span class="hljs-built_in">exec</span> chromium<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决使用 lightdm 登入 Arch 后未打开 dwm 问题</title>
    <link href="/2022/09/04/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8-lightdm-%E7%99%BB%E5%85%A5-Arch-%E5%90%8E%E6%9C%AA%E6%89%93%E5%BC%80-dwm-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/04/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8-lightdm-%E7%99%BB%E5%85%A5-Arch-%E5%90%8E%E6%9C%AA%E6%89%93%E5%BC%80-dwm-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Display_Manager">ArckWiki DM 部分</a></p><h1 id="Display-Manager"><a href="#Display-Manager" class="headerlink" title="Display Manager"></a>Display Manager</h1><p>Display Manager 通常是一个在启动过程结束时，代替默认 shell 显示图形用户界面.</p><h1 id="Greeter"><a href="#Greeter" class="headerlink" title="Greeter"></a>Greeter</h1><p>greeter 是提示用户输入密码的 GUI 界面，如果配置了自动登录，可以不使用 greeter. 默认配置使用的是 <code>lightdm-gtk-greeter</code>.</p><p>可以通过更改配置文件中的 <code>[Seat:*]</code> 部分来设置 greeter.</p><p>可以通过 <code>ls -l /usr/share/xgreeters/</code> 来获取 greeter 的可用选项.</p><h1 id="会话配置"><a href="#会话配置" class="headerlink" title="会话配置"></a>会话配置</h1><p>会话，即在 greeter 输入密码账号后即将进入的程序，一般为 Window Manager 或桌面.</p><p>多数显示管理器会读取 <code>/usr/share/xsessions</code> 目录获取可用的会话列表，此目录中包含各个标准的桌面文件。</p><p>要建立会话，可以在 <code>/usr/share/xsessions</code> 中新建 <code>.desktop</code> 后缀的文件.</p><p>格式 (以我自己 Ubuntu 上的 gnome.desktop) 为例:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Desktop Entry]</span><br><span class="hljs-attr">Name</span>=GNOME<br><span class="hljs-attr">Comment</span>=This session logs you into GNOME<br><span class="hljs-attr">Exec</span>=/usr/bin/gnome-session --session=gnome<br><span class="hljs-attr">TryExec</span>=/usr/bin/gnome-session<br><span class="hljs-attr">Type</span>=Application<br><span class="hljs-attr">DesktopNames</span>=GNOME<br><span class="hljs-attr">X-GDM-SessionRegisters</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">X-Ubuntu-Gettext-Domain</span>=gnome-session-<span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><p>里面的 <code>gnome-session</code> 是一个 shell 脚本.</p><h1 id="运行-xinitrc-会话"><a href="#运行-xinitrc-会话" class="headerlink" title="运行 ~/.xinitrc 会话"></a>运行 <code>~/.xinitrc</code> 会话</h1><p>需要安装 <code>xinit-xsession</code> 后，在显示管理器中提供一个运行 xinitrc 会话的选项，需确保 <code>~/.xinitrc</code> 可执行，然后再显示管理器中选择 <code>xinitrc</code> 作为会话.</p><h1 id="没有窗口管理器启动应用程序"><a href="#没有窗口管理器启动应用程序" class="headerlink" title="没有窗口管理器启动应用程序"></a>没有窗口管理器启动应用程序</h1><p>可以在没有窗口修饰，桌面或窗口管理器的情况下启动应用程序。</p><p>如，要启动 <code>google-chrome</code>，在 <code>/usr/share/xsessions/</code> 中创建 <code>web-browser.desktop</code>:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Desktop Entry]</span><br><span class="hljs-attr">Name</span>=Web Browser<br><span class="hljs-attr">Comment</span>=Use a web browser as your session<br><span class="hljs-attr">Exec</span>=/usr/bin/google-chrone --auto-launch-at-startup<br><span class="hljs-attr">TryExec</span>=/usr/bin/google-chrone --auto-launch-at-startup<br><span class="hljs-attr">Icon</span>=google-chrome<br><span class="hljs-attr">Type</span>=Application<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查看 Linux 下的网卡信息</title>
    <link href="/2022/09/03/%E6%9F%A5%E7%9C%8B-Linux-%E4%B8%8B%E7%9A%84%E7%BD%91%E5%8D%A1%E4%BF%A1%E6%81%AF/"/>
    <url>/2022/09/03/%E6%9F%A5%E7%9C%8B-Linux-%E4%B8%8B%E7%9A%84%E7%BD%91%E5%8D%A1%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Systemd-networkd">ArchWiki</a><br>systemd-networkd 是一个管理网络配置的系统守护进程.</p><h1 id="查看网络设备"><a href="#查看网络设备" class="headerlink" title="查看网络设备"></a>查看网络设备</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">ls <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span>/net<br></code></pre></td></tr></table></figure><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>systemd 是 Arch 安装的一部分，包含操作有线网络所需的所有文件，无线适配器可以通过其他服务(如 wpa_supplicant 或 iwd) 来配置.</p><p>通过 <code>ifconfig</code> 显示的设备中:</p><p><code>enp7s0</code> 是当前实机的网卡.</p><p><code>enpls0</code> 是有线适配器.</p><p><code>wlp2s0</code> 是无线适配器.</p><h1 id="NCI"><a href="#NCI" class="headerlink" title="NCI"></a>NCI</h1><p>NIC 为 Network Interface Controler, 网络接口控制器。又称网络适配器 (network adapter), 网卡 (netword card), 或局域网接收器 (LAN adapter).</p><p>其是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件.</p><p>每个网卡都有一个被称为 MAC 地址的独一无二的 48 位串行号，被写在卡的一块 ROM 中.</p><p>网卡以前是作为扩展卡插到计算机总线上的，现在大部分新的计算机都在主板上集成了网络接口，这些主板或是在主板芯片中集成了以太网的功能，或是使用一块通过 PCI 连接到主板上的廉价网卡.</p><h1 id="网卡名称的变迁"><a href="#网卡名称的变迁" class="headerlink" title="网卡名称的变迁"></a>网卡名称的变迁</h1><p><a href="https://www.freeaihub.com/post/104299.html">参考</a><br>一开始，Linux 的网卡名称为 eth0, wlan0. 现在变为了 enp7s0, wlp6s0.</p><h2 id="eth0-wlan0-的含义"><a href="#eth0-wlan0-的含义" class="headerlink" title="eth0, wlan0 的含义"></a>eth0, wlan0 的含义</h2><p>eth0 是系统自动选择的网络设备名称，来自 ethernet.</p><p>无线网卡就是 wlan, 来自 Wireless LAN.</p><p>lo 为 Loopback.</p><p>tun 为 Tunnel.</p><p>br 为 Bridge.</p><h2 id="enp7s0-wlp60-的含义"><a href="#enp7s0-wlp60-的含义" class="headerlink" title="enp7s0, wlp60 的含义"></a>enp7s0, wlp60 的含义</h2><p>enp7s0 中 en 代表 ethernet, wlp60 中 wl 代表 wireless.</p><p>pXsY (X, Y 是整数值) 代表 PCI 的位置。</p><h1 id="virbr"><a href="#virbr" class="headerlink" title="virbr"></a>virbr</h1><p>virbr0 (Virtual network switch) 是一种虚拟网络接口，这是由于安装和启用了 libvirt 服务后生成的，libvirt 在服务器 (host) 上生成一个 virbr0, host 上所有虚拟机 (guests) 通过这个 virbr0 连起来. 默认情况下, virbr0 使用的是 NAT 模式 (采用 IP Masquerade).</p><h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>NAT 是 Network Address Translation, 网络地址转换</p><p>当专用网内部的主机分配了本地的 IP 地址 (即仅在本专用网内使用的专用地址), 但又想和因特网上的主机通信, 通常使用 NAT.</p><h1 id="PCI-总线"><a href="#PCI-总线" class="headerlink" title="PCI 总线"></a>PCI 总线</h1><p>PCI 是 Peripheral Component Interconnect(外设部件互联标准) 的缩写。其为个人电脑使用最广泛的接口. 几乎所有的主板产品上都带有这种插槽。PCI 插槽也是主板带有最多数量的插槽类型。</p><p>从结构上看，PCI 是在 CPU 的供应商和原来的系统总线之间插入的一级总线，具体由一个桥接电路实现对这一层的管理，并实现上下之间的接口以协调数据的传输.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器人学习小纲要</title>
    <link href="/2022/09/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BA%B2%E8%A6%81/"/>
    <url>/2022/09/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BA%B2%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><p>线性代数书:</p><ul><li>《Linear Algebra Done Right》</li><li>《Linear Algebra Done Wrong》<br><a href="https://www.math.brown.edu/~treil/papers/LADW/book.pdf">线代书</a></li></ul><h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><p>博文: Makefile详解(超级好)_mingw</p><h1 id="Javascript-和-HTML-学习"><a href="#Javascript-和-HTML-学习" class="headerlink" title="Javascript 和 HTML 学习"></a>Javascript 和 HTML 学习</h1><p><a href="http://www.w3schools.com/">资料</a><br>网站左侧的 “Learn HTML”、”Learn CSS”、”Learn Javascript”、”Learn JQuery”.</p><p>网站: three.js、examples</p><p>PHP</p><p>一本书: 《数学之美》</p><h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><p>Solidworks 画基本的机械图.</p><p>Altium Designer 作图.</p><p>开发套件: Arduino STEM educational Robot kits Building Platform.</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于多系统安装</title>
    <link href="/2022/09/03/%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <url>/2022/09/03/%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>删除一个双系统之中的一个系统，直接格式化分区也问题不大，只是启动时引导还在.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 XFS 部分</title>
    <link href="/2022/09/03/ArchWiki-%E4%B8%AD-XFS-%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/03/ArchWiki-%E4%B8%AD-XFS-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/XFS">ArchWiki XFS 部分</a><br>XFS 是高新能日志式文件系统.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 UEFI 部分</title>
    <link href="/2022/09/03/ArchWiki-%E4%B8%AD-UEFI-%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/03/ArchWiki-%E4%B8%AD-UEFI-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Unified_Extensible_Firmware_Interface">ArchWiki</a><br>UEFI 是 Unified Extensible Firmware Interface, 统一可扩展固件接口, 是操作系统和固件之间接口的模型。UEFI 提供了启动操作系统或预启动程序的标准环境.</p><h1 id="Arch-boot-process"><a href="#Arch-boot-process" class="headerlink" title="Arch boot process"></a>Arch boot process</h1><p><a href="https://wiki.archlinux.org/title/Arch_boot_process">ArchWiki中相关部分</a></p><h2 id="固件类型"><a href="#固件类型" class="headerlink" title="固件类型"></a>固件类型</h2><p>固件是开机时最先执行的程序。</p><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>Basic Input-Output System, 是系统开启时最先运行的程序 (固件), 大多数情况存储在主板本身的一块闪存内，独立于其他系统存储。</p><p>其分区受限制, 在 2010 年起逐渐被 UEFI 替换.</p><h3 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h3><p>其不从主引导记录 (MBR) 中启动任何引导代码.</p><p>UEFI 启动过程依赖<mark>非易失性随机访问存储器</mark> (NVRAM)</p><p>UEFI 会启动 EFI 应用程序，例如 boot loader, bootmanager 和 UEFI Shell等。这些程序通常以文件形式存储在 EFI 系统分区中. 厂商可以将其特定文件存储在 <code>EFI</code> 系统分区的 <code>/EFI/vendor_name</code> 文件夹下.</p><p>UEFI 规范通过 Compatibility Support Module, CSM, 来支持 BIOS 引导.</p><h4 id="NVRAM"><a href="#NVRAM" class="headerlink" title="NVRAM"></a>NVRAM</h4><p>其全称为 Non-volatile random-access memory.</p><p>它可以在断电时仍然保存其中的数据.</p><p>而 DRAM (dynammic random-access memory) 和 SRAM (static random-access memory) 都需要在连接电源的情况下.</p><p>Read-only memory device 可以用作存储 system firmware in 嵌入式系统。它们可以保存 initial processor instructions required to bootstrap a computer system.</p><h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化."></a>系统初始化.</h2><p>系统开启后，会先执行加电自检 (Power-on self-test, POST). 具体见官网。</p><h2 id="引导加载程序"><a href="#引导加载程序" class="headerlink" title="引导加载程序"></a>引导加载程序</h2><p>Boot loader. 是由计算机固件 (BIOS 或 UEFI) 启动的软件。它负责用想要的内核参数加载内核，并根据配置文件初始化 RAM 磁盘.</p><p>文件系统支持是从固件继承的。UEFI 规范要求支持 FAT12, FAT16 和 FAT32 文件系统.</p><p><code>.efi</code> 就是 EFI 应用程序.</p><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>内核是操作系统的核心。它运行于一个叫 “内核空间” 的底层上，负责机器硬件和应用程序之间的交流。</p><h1 id="UEFI-1"><a href="#UEFI-1" class="headerlink" title="UEFI"></a>UEFI</h1><h2 id="UEFI-固件架构"><a href="#UEFI-固件架构" class="headerlink" title="UEFI 固件架构"></a>UEFI 固件架构</h2><p>UEFI 下的每一个程序，无论它是某个 OS 引导其还是某个内存测试或数据恢复工具，都要兼容于 EFI 固件位数或体系结构。</p><p>目前主流的 UEFI 固件都采用 x86_64 EFI 固件。</p><p>x86_64 EFI 不能兼容 32 位 EFI 程序.</p><p>查看 UEFI 系统位数:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ cat <span class="hljs-regexp">/sys/</span>firmware<span class="hljs-regexp">/efi/</span>fw_platform_size<br></code></pre></td></tr></table></figure><h2 id="UEFI-变量"><a href="#UEFI-变量" class="headerlink" title="UEFI 变量"></a>UEFI 变量</h2><p>获取变量列表:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>efivar -l<br></code></pre></td></tr></table></figure><h3 id="用户空间工具"><a href="#用户空间工具" class="headerlink" title="用户空间工具"></a>用户空间工具</h3><h4 id="efibootmgr"><a href="#efibootmgr" class="headerlink" title="efibootmgr"></a>efibootmgr</h4><h2 id="UEFI-Shell"><a href="#UEFI-Shell" class="headerlink" title="UEFI Shell"></a>UEFI Shell</h2><p>UEFI Shell 是固件的终端，可用于启动包括引导器的 UEFI 程序.</p><p>也可用于采集固件和系统的各种信息.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>fzf 工具的安装和使用</title>
    <link href="/2022/09/03/fzf-%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/03/fzf-%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/junegunn/fzf">github 相关内容</a><br>fzf 是 fuzzy finder 的简称。</p><p>用于在命令行下查找文件, 目录等。</p><p>注意在下载后： Key bindings (CREL-T&#x2F;CREL-R&#x2F;CREL-C) and fuzzy auto-completion may not be enabled by default.</p><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p>使用几个快捷键：</p><ul><li><code>CTRL-K</code> 和 <code>CTRL-J</code> 用于上下移动</li><li><code>Enter</code> 用于选中，<code>CTRL-C</code> 用于退出</li><li><code>-m</code> multi-select mode, 使用 <code>TAB</code> 和 <code>Shift-TAB</code> 来标记多个 items</li><li>鼠标滚轮也能移动<br>被选中的会被输出到 STDOUT 中。</li></ul><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>可改变窗口大小，具体见 github.</p><h2 id="Search-syntax"><a href="#Search-syntax" class="headerlink" title="Search syntax"></a>Search syntax</h2><p>可以使用空格来进行层次搜索, 比如 <code>Documents/books/hello.txt</code>, 你可以在 fzf 中输入 <code>Do boo hello</code> 来查找。</p><p>用 <code>|</code> 代表 “或者”, <code>^</code> , <code>$</code> 和 <code>!</code> 都可以使用.</p><h1 id="fzf-tmux-script"><a href="#fzf-tmux-script" class="headerlink" title="fzf-tmux script"></a><code>fzf-tmux</code> script</h1><p>具体看 github, 暂时不了解。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git clone --depth 含义</title>
    <link href="/2022/09/03/git-clone-depth-%E5%90%AB%E4%B9%89/"/>
    <url>/2022/09/03/git-clone-depth-%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p><code>git clone --depth=1</code> 意思就是克隆下载最近一次 commit 的一个分支. 这样版本项目文件就不会很大.</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>窗口管理器 dwm 和 终端 st</title>
    <link href="/2022/09/03/%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%99%A8-dwm-%E5%92%8C-%E7%BB%88%E7%AB%AF-st/"/>
    <url>/2022/09/03/%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%99%A8-dwm-%E5%92%8C-%E7%BB%88%E7%AB%AF-st/</url>
    
    <content type="html"><![CDATA[<p><a href="https://suckless.org/">suckless 官网</a><br>suckless 是一个开源社区. 其是一个极简主义的爱好者.</p><h1 id="st"><a href="#st" class="headerlink" title="st"></a>st</h1><p>st 是 simple terminal.</p><h1 id="dwm"><a href="#dwm" class="headerlink" title="dwm"></a>dwm</h1><p>dwm 是 dynamic window manager, 动态窗口管理器.</p><p>dwm 是 X 下的一个动态窗口管理器.</p><h2 id="Xorg"><a href="#Xorg" class="headerlink" title="Xorg"></a>Xorg</h2><p><a href="https://wiki.archlinux.org/title/Xorg">ArchWiki</a><br>X.org 项目，其提供了 X 窗口系统的开源实现.</p><p>Xorg 简称 X, 几乎是 Linux 中图形用户程序的必备条件.</p><p>其潜在的继任者为 <code>Wayland</code>.</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>用户通常选择安装窗口管理器或桌面环境以配合使用 X.</p><p>一般为:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">pacman -S xorg xorg-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h4 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h4><p>查看显卡类型:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lspci <span class="hljs-string">|grep -e VGA -e 3D</span><br></code></pre></td></tr></table></figure><p>有几个输出说明有几个显卡.</p><p>查看所有开源驱动:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pacman -Ss xf86-<span class="hljs-selector-tag">video</span><br></code></pre></td></tr></table></figure><p><img src="/../img/%E9%A9%B1%E5%8A%A8.png" alt="驱动"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>Xorg 命令通常不直接运行，而是使用显示管理器或者 xinit 来启动 X server.</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Arch 提供了位于 <code>/usr/share/X11/xorg.conf.d</code> 的默认配置文件.</p><h2 id="dwm-使用"><a href="#dwm-使用" class="headerlink" title="dwm 使用"></a>dwm 使用</h2><h3 id="打开终端"><a href="#打开终端" class="headerlink" title="打开终端"></a>打开终端</h3><p><code>[Shift]+[Alt]+[Enter]</code></p><h3 id="打开-dmenu"><a href="#打开-dmenu" class="headerlink" title="打开 dmenu"></a>打开 dmenu</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Alt]</span>+<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><h3 id="切换-master-window-和-stack-window"><a href="#切换-master-window-和-stack-window" class="headerlink" title="切换 master window 和 stack window"></a>切换 master window 和 stack window</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Alt]</span>+<span class="hljs-selector-attr">[Enter]</span><br></code></pre></td></tr></table></figure><h3 id="Moving-Aroung"><a href="#Moving-Aroung" class="headerlink" title="Moving Aroung"></a>Moving Aroung</h3><p><code>  [Alt]+[j]</code><br>或者<br><code>  [Alt]+[k]</code></p><h3 id="将一个小窗口移动到其他-Tab-中"><a href="#将一个小窗口移动到其他-Tab-中" class="headerlink" title="将一个小窗口移动到其他 Tab 中"></a>将一个小窗口移动到其他 Tab 中</h3><p>如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Alt]</span>+<span class="hljs-selector-attr">[Shift]</span>+<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>会把当前的这一个 window 移动到 tab 2 中。</p><h3 id="进入其他的-Tab"><a href="#进入其他的-Tab" class="headerlink" title="进入其他的 Tab"></a>进入其他的 Tab</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">[Alt]+[<span class="hljs-literal">Tab</span> <span class="hljs-built_in">number</span>]<br></code></pre></td></tr></table></figure><h3 id="选择一个-window-作为-master"><a href="#选择一个-window-作为-master" class="headerlink" title="选择一个 window 作为 master"></a>选择一个 window 作为 master</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Alt]</span>+<span class="hljs-selector-tag">i</span><br></code></pre></td></tr></table></figure><p>这里的 <code>i</code> 为 increase.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[Alt]</span>+d<br></code></pre></td></tr></table></figure><p>这里的 <code>d</code> 为 decrease.</p><h3 id="关闭一个-window"><a href="#关闭一个-window" class="headerlink" title="关闭一个 window"></a>关闭一个 window</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Alt]</span>+<span class="hljs-selector-attr">[Shift]</span>+c<br></code></pre></td></tr></table></figure><h3 id="退出-dwm"><a href="#退出-dwm" class="headerlink" title="退出 dwm"></a>退出 dwm</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Alt]</span>+<span class="hljs-selector-attr">[Shift]</span>+<span class="hljs-selector-tag">q</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Arch 中的 Yay</title>
    <link href="/2022/09/02/Arch-%E4%B8%AD%E7%9A%84-Yay/"/>
    <url>/2022/09/02/Arch-%E4%B8%AD%E7%9A%84-Yay/</url>
    
    <content type="html"><![CDATA[<p>yay 是一个 AUR helper，其会帮你从 AUR 安装软件.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://aur.archlinux.org/yay.git --<span class="hljs-attr">depth=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>进入目录后执行:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">makepkg -si</span><br></code></pre></td></tr></table></figure><p>可以通过:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -Qs yay</span><br></code></pre></td></tr></table></figure><p>来查看本机安装的 yay 程序.</p><h1 id="上述安装时可能会报错"><a href="#上述安装时可能会报错" class="headerlink" title="上述安装时可能会报错"></a>上述安装时可能会报错</h1><p>使用另一种方法安装, 先添加 archlinuxcn 的源</p><h2 id="开启-32-位软件库支持和-ArchlinuxCN-库的支持"><a href="#开启-32-位软件库支持和-ArchlinuxCN-库的支持" class="headerlink" title="开启 32 位软件库支持和 ArchlinuxCN 库的支持"></a>开启 32 位软件库支持和 ArchlinuxCN 库的支持</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>pacman.conf<br></code></pre></td></tr></table></figure><p>将 <code>[multilib]</code> 一节中的两行注释去掉.</p><p>在文档的最后添加:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">[archlinuxcn]<br>Server = https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/archlinuxcn/</span><span class="hljs-variable">$arch</span><br></code></pre></td></tr></table></figure><p>执行 <code>sudo pacman -Syyu</code> 更新 pacman 数据库.</p><p>安装 <code>archlinuxcn-keyring</code> 包导入 GPG key:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S archlinuxcn-keyring</span><br></code></pre></td></tr></table></figure><p>若报错，则执行以下命令:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo pacman -Syyu<br>sudo pacman -S haveged<br>sudo pacman -Syu haveged<br>sudo systemctl <span class="hljs-keyword">start</span> haveged<br>sudo systemctl <span class="hljs-keyword">enable</span> haveged<br><br>sudo rm -fr /etc/pacman.d/gnupg<br>sudo pacman-key <span class="hljs-comment">--init</span><br>sudo pacman-key <span class="hljs-comment">--populate archlinux</span><br>sudo pacman-key <span class="hljs-comment">--populate archlinuxcn</span><br></code></pre></td></tr></table></figure><p>最后安装 <code>yay</code>:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S yay</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 KDE 部分</title>
    <link href="/2022/09/02/ArchWiki-%E4%B8%AD-KDE-%E9%83%A8%E5%88%86/"/>
    <url>/2022/09/02/ArchWiki-%E4%B8%AD-KDE-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/KDE">ArchWiki</a><br>首先，KDE 是一套由 Plasma 桌面环境、一系列的库、框架 (KDE Frameworks) 和一些应用组成的软件项目.</p><p>所以说，Plasma 才是桌面环境, KDE 只是软件项目.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Plasma-桌面"><a href="#Plasma-桌面" class="headerlink" title="Plasma 桌面"></a>Plasma 桌面</h2><p>安装 Plasma 之前需安装 Xorg 依赖:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">sudo pacman -S xorg xorg-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>安装 plasma-meta 元软件包:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo pacman -S plasma-<span class="hljs-keyword">meta</span><br></code></pre></td></tr></table></figure><h1 id="启动-Plasma"><a href="#启动-Plasma" class="headerlink" title="启动 Plasma"></a>启动 Plasma</h1><p>若使用 <code>xinit/startx</code> 启动 Plasma 桌面，在 <code>.xinitrc</code> 文件中添加 <code>export DESKTOP_SESSION=plasma</code></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>KDE 应用大部分配置存储于 <code>~/.config</code> 目录下.</p><h2 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h2><p>Plasma 和 SDDM 都会使用存在 <code>/var/lib/AccountsService/icons/</code> 的图像作为用户头像.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ssh 远程连接时 permission denied</title>
    <link href="/2022/09/02/ssh-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%97%B6-permission-denied/"/>
    <url>/2022/09/02/ssh-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%97%B6-permission-denied/</url>
    
    <content type="html"><![CDATA[<p>可能存在三种情况:</p><ol><li>检查并确定密码有没有错误</li><li>查看用户名是否存在</li><li>若是登录 root 账户，一般是配置文件中将 root 设置为不允许远程登录.</li></ol><p>sshd 的配置文件为 <code>/etc/ssh/sshd_config</code>.</p><p>修改为允许 root 远程登录, 即添加一行 <code>PermitRootLogin yes</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是 dhcpcd, e2fsprogs, iwd</title>
    <link href="/2022/09/02/%E4%BB%80%E4%B9%88%E6%98%AF-dhcpcd-e2fsprogs-iwd/"/>
    <url>/2022/09/02/%E4%BB%80%E4%B9%88%E6%98%AF-dhcpcd-e2fsprogs-iwd/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于操作系统在 PATH 路径下查找命令</title>
    <link href="/2022/09/02/%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8-PATH-%E8%B7%AF%E5%BE%84%E4%B8%8B%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/09/02/%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8-PATH-%E8%B7%AF%E5%BE%84%E4%B8%8B%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>不会递归查找 <code>$PATH</code> 中添加目录之下的子目录.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>将 hexo 博客上传到 gitee</title>
    <link href="/2022/09/02/%E5%B0%86-hexo-%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%88%B0-gitee/"/>
    <url>/2022/09/02/%E5%B0%86-hexo-%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%88%B0-gitee/</url>
    
    <content type="html"><![CDATA[<p>本以为会和 deploy-git 冲突，然而并没有。</p><p>先在 gitee 上新建仓库。</p><p>回到本地的 Blog 目录，<code>git init</code> 创建成 git 仓库，<code>git add .</code> 和 <code>git commit</code> 之后 <code>git remote add</code> 添加远程仓库，直接 <code>git pull</code> 就行.</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用 Git 克隆单个分支</title>
    <link href="/2022/09/01/%E7%94%A8-Git-%E5%85%8B%E9%9A%86%E5%8D%95%E4%B8%AA%E5%88%86%E6%94%AF/"/>
    <url>/2022/09/01/%E7%94%A8-Git-%E5%85%8B%E9%9A%86%E5%8D%95%E4%B8%AA%E5%88%86%E6%94%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Arch_User_Repositor">ArchWiki</a><br>在 ArchWiki 上看的.</p><p>代码如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> --branch branch_name/package_name --single-branch https://github.com/archlinux/aur</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>打开 gnome-shell-extension</title>
    <link href="/2022/09/01/%E6%89%93%E5%BC%80-gnome-shell-extension/"/>
    <url>/2022/09/01/%E6%89%93%E5%BC%80-gnome-shell-extension/</url>
    
    <content type="html"><![CDATA[<p>原本这个东西在 <code>gnome-tweaks tool</code> 里面，现在独立出来了，在应用栏里面搜索 <code>extension</code> 就会找到.</p>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git push 后文件夹为空且带 @xxxx</title>
    <link href="/2022/08/31/git-push-%E5%90%8E%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%BA%E7%A9%BA%E4%B8%94%E5%B8%A6-xxxx/"/>
    <url>/2022/08/31/git-push-%E5%90%8E%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%BA%E7%A9%BA%E4%B8%94%E5%B8%A6-xxxx/</url>
    
    <content type="html"><![CDATA[<p>提交的文件夹是 git 拉取而来的，文件夹里面原本就有 <code>.git</code> 目录，因此会提交给另一个远程分支上去。</p><p>删除 <code>.git</code> 目录即可解决。</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装和使用 zsh</title>
    <link href="/2022/08/31/%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-zsh/"/>
    <url>/2022/08/31/%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-zsh/</url>
    
    <content type="html"><![CDATA[<p>进入 zsh 的 vi 编辑模式，按 <code>esc</code>.<br>阅读书籍 《Learning Shell Scripting with Zsh》</p><h1 id="1-Getting-Started"><a href="#1-Getting-Started" class="headerlink" title="1 Getting Started"></a>1 Getting Started</h1><p>zsh 配置文件 <code>.zshrc</code> 里面的命名机制 – 大小写敏感且忽略下划线. 如: <code>SOME_OPTION</code> 和 <code>SOMEOPTION</code> 是同一个东西。</p><p>两个命令 – <code>setopt</code> 和 <code>unsetopt</code>:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">setopt SOME_OPTION # enables <span class="hljs-keyword">any</span> <span class="hljs-keyword">option</span><br>unsetopt SOME_OPTION # use this <span class="hljs-keyword">to</span> <span class="hljs-keyword">disable</span> <span class="hljs-keyword">any</span> <span class="hljs-keyword">option</span><br></code></pre></td></tr></table></figure><p>在选项前面添加 <code>NO</code> 是和 <code>unsetopt</code> 一样的效果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">setopt</span> NO_SOME_OPTION<br></code></pre></td></tr></table></figure><p>zsh 用 <code>#</code> 作为注释。</p><p>一行命令:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span>load -U promptinit<br></code></pre></td></tr></table></figure><p>这里的 <code>proptinit</code> 是一个模块，</p><h2 id="Shell-option"><a href="#Shell-option" class="headerlink" title="Shell option"></a>Shell option</h2><p><code>-v</code> 参数，意为 “verbose” , 它会把你输入的命令再打印一遍。</p><p><code>-f</code> 参数，会打开一个 zsh, 这个 zsh, 没有任何配置。</p><p>在已经打开的 zsh 中使用 <code>set</code> 可以设置 zsh 的参数.</p><p>用 <code>set +某个参数</code> 可以取消</p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ssh 使用</title>
    <link href="/2022/08/31/ssh-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/31/ssh-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>首先需要知道一台机器的 IP 地址，以及其上面一个账户名和密码, 如:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh root<span class="hljs-variable">@ip</span><br></code></pre></td></tr></table></figure><p>然后系统会提示输入密码，密码正确就会进入.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>fish 这一软件</title>
    <link href="/2022/08/31/fish-%E8%BF%99%E4%B8%80%E8%BD%AF%E4%BB%B6/"/>
    <url>/2022/08/31/fish-%E8%BF%99%E4%B8%80%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>Fish 是 “the Friendly Interactive Shell” 的简称，其支持语法高亮，自动建议，标签完成等。</p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 Git 时 refusing to merge unrelated histories 解决</title>
    <link href="/2022/08/31/%E4%BD%BF%E7%94%A8-Git-%E6%97%B6-refusing-to-merge-unrelated-histories-%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/08/31/%E4%BD%BF%E7%94%A8-Git-%E6%97%B6-refusing-to-merge-unrelated-histories-%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>原因是两个仓库不同导致，我先是新建了一个仓库，然后 <code>git add remote</code> 了一个 gitee 仓库，接着 <code>git pull</code> 下来，最后往上面直接提交了. 这导致了问题，因为不是直接 <code>git clone</code> 而来的。</p><p>先将两个仓库 <code>merge</code> 在一起就可以解决，但遇到了报错，使用 <code>--allow-unrelated-histories</code> 可以消除。</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决用 kvm 创建 archlinux 虚拟机时进入 UEFI Interactive Shell 问题</title>
    <link href="/2022/08/30/%E8%A7%A3%E5%86%B3%E7%94%A8-kvm-%E5%88%9B%E5%BB%BA-archlinux-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%B6%E8%BF%9B%E5%85%A5-UEFI-Interactive-Shell-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/30/%E8%A7%A3%E5%86%B3%E7%94%A8-kvm-%E5%88%9B%E5%BB%BA-archlinux-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%B6%E8%BF%9B%E5%85%A5-UEFI-Interactive-Shell-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>虚拟机启动后，会自动寻找启动分区 <code>/dev/vda</code> 下面的 <code>EFI/boot/</code> 目录下的引导文件, 如 x86_64 平台的引导文件一般为 <code>bootx64.efi</code>, 而启动分区在 UEFI Interactive Shell 界面一般以 <code>FS0:</code> 的盘符存在。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>先进入 <code>FS0:</code> 盘符:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">Shell&gt; FS0:<br><span class="hljs-symbol">FS0:</span>\&gt;<br></code></pre></td></tr></table></figure><p>查看当前文件:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">FS0:</span>\&gt; ls<br></code></pre></td></tr></table></figure><p>进入 <code>EFI</code> 目录:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">FS0:</span>\&gt; cd EFI<br></code></pre></td></tr></table></figure><p>创建 <code>boot</code> 目录并把 <code>hostname</code>(你自己设置的) 目录下的 <code>grubx64.efi</code> 复制到 <code>boot</code> 目录中并重命名为 <code>bootx64.efi</code>.</p><p>最后启动 <code>bootx64.efi</code> 文件来重启。</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pacstrap 的使用</title>
    <link href="/2022/08/30/pacstrap-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/30/pacstrap-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://man.archlinux.org/man/pacstrap.8">ArchWiki</a><br>pacstrap 用于将软件包下载到 specified new root directory.</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> pacstrap [<span class="hljs-keyword">option</span>] root [packages...]<br></code></pre></td></tr></table></figure><p>如果没有指定软件包，the base metapackage 会被下载。</p><p>这里的 <code>root</code> 是一个目录，如装 archlinux 时:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">pacstrap /mnt base linux linux-firmware</span><br></code></pre></td></tr></table></figure><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>pacstrap is designed to create a new system installation from scratch. The specified packages will be installed into a given directory after setting up some basic mountpoints.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中关于 GnuPG</title>
    <link href="/2022/08/30/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-GnuPG/"/>
    <url>/2022/08/30/ArchWiki-%E4%B8%AD%E5%85%B3%E4%BA%8E-GnuPG/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/GnuPG">ArchWiki</a><br>GnuPG (即 GPG) 是一个自由软件，其实现了 RFC4880 所定义的 OpenPGP 标准.</p><p>GnuPG 可用于加密和签名你的数据和通讯信息, 包含一个通用的密钥管理系统以及用于各种公钥目录的访问模块。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装软件包 gnupg 时，软件包 pinentry 也会被同时安装。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="目录位置"><a href="#目录位置" class="headerlink" title="目录位置"></a>目录位置</h2><p>默认为 <code>~/.gnupg</code>.</p><p>改变:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ gpg --homedir path<span class="hljs-regexp">/to/</span><span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>或设置 <code>GNUPGHOME</code> 环境变量。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="导出公钥"><a href="#导出公钥" class="headerlink" title="导出公钥"></a>导出公钥</h2><p>GPG 的主要用途就是通过公钥加密信息以确保其私密性，你可以分发自己的公钥，而其他人通过该公钥加密发给你的信息。</p><p>其他人需要有你的公钥才能给你发加密信息。</p><h2 id="导入公共密钥"><a href="#导入公共密钥" class="headerlink" title="导入公共密钥"></a>导入公共密钥</h2><p>要给其他人发送加密信息，或者验证他们的签名，就需要他们的公钥，通过文件 <code>public.key</code> 导入公钥到密钥环。</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 archlinux 的安装</title>
    <link href="/2022/08/30/Archlinux%20%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2022/08/30/Archlinux%20%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Installation_guide">ArchWiki</a><br><a href="https://www.bilibili.com/read/cv15713480">参考博客</a></p><h1 id="一些知识点"><a href="#一些知识点" class="headerlink" title="一些知识点"></a>一些知识点</h1><p>Arch Linux 现在只支持 x86_64(即 amd64) 架构.</p><p>Arch Linux 的发布版本只是安装和修复环境，包含 base 元软件包和一些辅助软件，一般每月上旬发布一次。</p><p>使用 <code>pacman -Syu</code> 命令升级系统。</p><p>新功能通过 <code>pacman -Syu</code> 即可拥有。</p><p><code>pacman -Qs</code> 可用于查找包.</p><p><a href="https://wiki.archlinux.org/title/System_maintenance">提高系统稳定性</a></p><p>Arch Linux 安装镜像不支持安全启动 (Secure Boot).</p><p>虚拟控制台默认的 Shell 是 Zsh.</p><p>如果要清除原来的分区信息, 通过创建一个新的分区表, 利用 <code>fdisk</code>.</p><p>BIOS with MBR.</p><p>UEFI with GPT.</p><p>如果要启动的磁盘已经有一个 EFI 系统分区，不要新建 EFI 分区。</p><p>如果要创建一个 EFI 系统分区，使用 <code>mkfs.fat)8</code> 将其格式化为 Fat32.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># mkfs.fat -F <span class="hljs-number">32</span> <span class="hljs-regexp">/dev/</span>efi_system_partition<br></code></pre></td></tr></table></figure><p>挂载分区一定要遵循顺序，先挂载 (root) 分区到 (&#x2F;mnt), 再挂载引导 (boot) 分区到 (&#x2F;mnt&#x2F;boot 或 &#x2F;mnt&#x2F;efi), 最后再挂载其他分区。</p><p>如果创建了交换空间卷，使用 <code>swapon</code> 启动它:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># swapon <span class="hljs-regexp">/dev/</span>swap_partition<br></code></pre></td></tr></table></figure><p>文件 <code>/etc/pacman.d/mirrorlist</code> 定义了软件包会从哪个镜像下载.<br>安装必需得软件包:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">pacstrap /mnt base linux linux-firmware</span><br></code></pre></td></tr></table></figure><p>在虚拟机或容器中安装时，可以不安装固件软件包 (即 linux-firmware).</p><p>这里安装 <code>base-devel</code> 可能更好。</p><p>要生成文件系统表，用于在系统启动时自动挂载分区。</p><p>注意b站那个教程装 kde 桌面时，软件包是 <code>kde-applications-meta</code>.</p><h1 id="自己安装的全过程-综合多个安装教程-并在虚拟机上实验"><a href="#自己安装的全过程-综合多个安装教程-并在虚拟机上实验" class="headerlink" title="自己安装的全过程 (综合多个安装教程, 并在虚拟机上实验)"></a>自己安装的全过程 (综合多个安装教程, 并在虚拟机上实验)</h1><h2 id="修改命令行字体"><a href="#修改命令行字体" class="headerlink" title="修改命令行字体"></a>修改命令行字体</h2><p>修改命令行的字体，其字体文件存放在 <code>/usr/share/kbd/consolefonts</code> 下:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># setfont <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/kbd/</span>consolefonts/LatGrkCyr-<span class="hljs-number">12</span>x22.psfu.gz<br></code></pre></td></tr></table></figure><p>这个字体较大.</p><h2 id="修改键盘布局"><a href="#修改键盘布局" class="headerlink" title="修改键盘布局"></a>修改键盘布局</h2><p>使用 <code>loadkeys</code> 命令，如:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># loadkeys colemak</span><br></code></pre></td></tr></table></figure><h2 id="修改键位"><a href="#修改键位" class="headerlink" title="修改键位"></a>修改键位</h2><p>查看所有的 keycode, 使用 <code>dumpkeys</code> 命令:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">dumpkeys -l</span><br></code></pre></td></tr></table></figure><p>文件名任意，如 <code>keys.conf</code>，其目的是写一个键盘的配置文件:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># keys.conf</span><br><span class="hljs-attribute">keycode</span> <span class="hljs-number">1</span> = Caps_Lock # <span class="hljs-number">1</span> 原本是 Escape 键的 keycode<br><span class="hljs-attribute">keycode</span> <span class="hljs-number">58</span> = Escape<br></code></pre></td></tr></table></figure><p>然后用 <code>loadkeys</code> 加载一下配置文件.</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"># loadkeys <span class="hljs-built_in">keys</span>.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><h2 id="查看启动方式"><a href="#查看启动方式" class="headerlink" title="查看启动方式"></a>查看启动方式</h2><p>如果不是 UEFI 启动方式则装不了 arch.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls <span class="hljs-regexp">/sys/</span>firmware<span class="hljs-regexp">/efi/</span>efivars<br></code></pre></td></tr></table></figure><h2 id="连接网络设备"><a href="#连接网络设备" class="headerlink" title="连接网络设备"></a>连接网络设备</h2><p>先通过 <code>ip link</code> 查看网络设备, 然后用 <code>ip link set &lt;name&gt; up</code> 连接</p><p>这里可能会有 <code>RTNETLINK answers: Operation not possible due to RF-kill</code> , 原因是网卡被警用，解决方法:</p><p>使用 <code>rfkill</code> 命令, 先查看当前状态:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rfkill list</span> <br></code></pre></td></tr></table></figure><p>unblock 硬件:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rfkill</span> unblock 设备号或名<br></code></pre></td></tr></table></figure><h3 id="使用-wpa-supplicant"><a href="#使用-wpa-supplicant" class="headerlink" title="使用 wpa_supplicant"></a>使用 wpa_supplicant</h3><h4 id="扫描当前-wifi"><a href="#扫描当前-wifi" class="headerlink" title="扫描当前 wifi"></a>扫描当前 wifi</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># iwlist wlan0 scan</span><br></code></pre></td></tr></table></figure><p>这里的 <code>wlan0</code> 是设备.</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># iwlist wlan0 scan | grep ESSID </span><br></code></pre></td></tr></table></figure><p>可以列出 wifi 名列表. 这里 <code>ESSID</code> 的含义就是 wifi 名.</p><h4 id="连接-wifi"><a href="#连接-wifi" class="headerlink" title="连接 wifi"></a>连接 wifi</h4><p>使用 <code>wpa_passphrase</code>.</p><p>格式:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"># wpa_passphrase <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">passwd</span>&gt;</span> &gt; <span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># wpa_passphrase CW_WIFI 12345678 &gt; internet.conf</span><br></code></pre></td></tr></table></figure><p>用 <code>wpa_supplicant</code> 利用配置文件连接网络:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># wpa_supplicant -c internet.conf -i wlan0 &amp;</span><br></code></pre></td></tr></table></figure><p><code>-c</code> 选项指定配置文件，<code>-i</code> 选项指定设备. 这里的 <code>&amp;</code> 是放在后台运行.</p><p>连接之后需动态获取一个 IP 地址。</p><h3 id="使用-iwctl"><a href="#使用-iwctl" class="headerlink" title="使用 iwctl"></a>使用 iwctl</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">iwctl</span> <br>[<span class="hljs-string">iwd</span>] <span class="hljs-string">device</span> <span class="hljs-string">list</span><br>[<span class="hljs-string">iwd</span>] <span class="hljs-string">station</span> &lt;<span class="hljs-string">device</span>&gt; <span class="hljs-string">scan</span><br>[<span class="hljs-string">iwd</span>] <span class="hljs-string">station</span> &lt;<span class="hljs-string">device</span>&gt; <span class="hljs-built_in">get-networks</span><br>[<span class="hljs-string">iwd</span>] <span class="hljs-string">station</span> &lt;<span class="hljs-string">device</span>&gt; <span class="hljs-string">connect</span> &lt;<span class="hljs-string">wifi</span> <span class="hljs-string">name</span>&gt;<br>[<span class="hljs-string">iwd</span>] <span class="hljs-string">quit</span><br></code></pre></td></tr></table></figure><h3 id="动态获取-IP-地址"><a href="#动态获取-IP-地址" class="headerlink" title="动态获取 IP 地址"></a>动态获取 IP 地址</h3><p>使用 <code>dhcpcd</code>:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># dhcpcd &amp;</span><br></code></pre></td></tr></table></figure><p>还是放在后台运行.</p><h3 id="若无法连接网络"><a href="#若无法连接网络" class="headerlink" title="若无法连接网络"></a>若无法连接网络</h3><p>具体情况为 <code>wlan0</code> 这个设备消失了，听 LUG 群里面说是没有安装网卡驱动。</p><p>暂时解决方法为，使用启动盘，然后 <code>arch-chroot</code> 上去后操作.</p><p>另一个方法就是插网线.</p><p>在已经安装好的系统中，<code>iwlist</code> 这个命令用不了，因为没有安装，因此需要:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pancman -S wireless_tools</span><br></code></pre></td></tr></table></figure><h4 id="查看网卡型号"><a href="#查看网卡型号" class="headerlink" title="查看网卡型号"></a>查看网卡型号</h4><p>利用 lspci:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lspci <span class="hljs-string">| grep -i ethernet</span><br></code></pre></td></tr></table></figure><p>比如我的输出为:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">07</span>:<span class="hljs-number">00</span>.<span class="hljs-number">0</span> Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/<span class="hljs-number">8168</span>/<span class="hljs-number">8411</span> PCI Express Gigabit Ethernet Controller (rev <span class="hljs-number">15</span>)<br></code></pre></td></tr></table></figure><p>这里 Realtek Semiconductor 是公司名. <code>RTL8111/8168/8411</code> 就是网卡型号.</p><p>看无线网卡应该为 <code>Network controller</code>. <a href="https://www.intel.ca/">intel</a></p><h4 id="查看网卡驱动以及版本号"><a href="#查看网卡驱动以及版本号" class="headerlink" title="查看网卡驱动以及版本号"></a>查看网卡驱动以及版本号</h4><p>要使 NIC 硬件正常运行，必须给电脑的 NCI 硬件设备安装对应的网卡驱动程序.</p><h5 id="使用-dmesg-和-modinfo"><a href="#使用-dmesg-和-modinfo" class="headerlink" title="使用 dmesg 和 modinfo"></a>使用 dmesg 和 modinfo</h5><p>使用 dmesg (display message) 命令查看, 这个命令用于显示开机信息，开机的信息也保存在 <code>/var/log</code> 中. 内核在引导期间会加载必要的硬件驱动程序，因此 dmesg 命令的输出中会存在是否安装了以太网卡驱动程序的信息.</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">dmesg <span class="hljs-string">|grep NIC </span><br></code></pre></td></tr></table></figure><p>使用 <code>modinfo</code> 命令查看版本号, 格式为:</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">modinfo &lt;<span class="hljs-built_in">driver</span> <span class="hljs-built_in">name</span>&gt;<br></code></pre></td></tr></table></figure><h5 id="使用-ethtool-查看"><a href="#使用-ethtool-查看" class="headerlink" title="使用 ethtool 查看"></a>使用 ethtool 查看</h5><p>可能需要先安装，在 Ubuntu 中:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ethtool<br></code></pre></td></tr></table></figure><p>使用 ethtool (ethernet tool) 来查看网卡名对应的网卡驱动名以及网卡驱动版本号, 格式为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ethtool -i <span class="hljs-tag">&lt;<span class="hljs-name">NIC</span> <span class="hljs-attr">name</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="使用-lshw-命令查看"><a href="#使用-lshw-命令查看" class="headerlink" title="使用 lshw 命令查看"></a>使用 lshw 命令查看</h5><p>lshw (list hardware) 可以查询到网卡对应的网卡驱动信息以及网卡驱动版本号:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">sudo lshw -<span class="hljs-keyword">class</span> <span class="hljs-symbol">network</span>  <br></code></pre></td></tr></table></figure><h4 id="查看网卡生产商"><a href="#查看网卡生产商" class="headerlink" title="查看网卡生产商"></a>查看网卡生产商</h4><p>先下载一些网络诊断工具:</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">pacman -S <span class="hljs-built_in">net</span>-tools<br></code></pre></td></tr></table></figure><p>先查看网卡信息:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure><p>里面一串格式类似为: <code>00-00-00-AA-BB-CC</code> 的就是 MAC 地址.</p><p>得到一个网卡的 MAC 地址后，打开一个查询工具 (<a href="https://itool.co/mac">工具</a>) 输入 MAC 地址就可以查到网卡生产商的信息.</p><p>这里提一下 MAC 地址的结构，如 <code>A1-B2-C3-D4-E5-F6</code>, 前三个为厂商唯一，后三个为厂商分配的.</p><h2 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h2><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">timedatectl</span> <span class="hljs-built_in">set-ntp</span> <span class="hljs-string">true</span> <br><span class="hljs-string">timedatettl</span> <span class="hljs-string">status</span><br></code></pre></td></tr></table></figure><h2 id="配置-pacman"><a href="#配置-pacman" class="headerlink" title="配置 pacman"></a>配置 pacman</h2><p><code>pacman -S</code> 中 <code>S</code> 的含义是 “Synchronism”<br>配置文件为 <code>/etc/pacman.conf</code>, 其中，去除 <code>#Color</code> 前面的 <code>#</code> 注释符，<code>Color</code> 的意思是在安装软件包时，会给出彩色的提示，而不是黑白.</p><p>文件中:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[core]<br><span class="hljs-keyword">Include</span> = <span class="hljs-regexp">/etc/</span>pacman.d/mirrorlist<br>[extra]<br><span class="hljs-keyword">Include</span> = <span class="hljs-regexp">/etc/</span>pacman.d/mirrorlist<br>[community]<br><span class="hljs-keyword">Include</span> = <span class="hljs-regexp">/etc/</span>pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><p>这些都代表 arch 的软件源. 这个 <code>mirrorlist</code> 里面记录的是 arch 软件源服务器的地址.</p><p>进入文件后把 China 的放在最顶上，因为 pacman 是从上往下读取.</p><p>利用 vim 的宏录制可以干很多重复的工作.</p><p>在 vim 中寻找空行为 <code>/^\n</code></p><p>archlinuxcn 中的源很多不是官方编译。</p><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>先备份:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp -a <span class="hljs-regexp">/etc/</span>pacman.d<span class="hljs-regexp">/mirrorlist /</span>etc<span class="hljs-regexp">/pacman.d/mi</span>rrorlist.bak <br></code></pre></td></tr></table></figure><p>添加华为的源和阿里云的源:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Server = https:<span class="hljs-regexp">//</span>repo.huaweicloud.com<span class="hljs-regexp">/archlinux/</span><span class="hljs-variable">$repo</span><span class="hljs-regexp">/os/</span><span class="hljs-variable">$arch</span><br>Server = https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/archlinux/</span><span class="hljs-variable">$repo</span><span class="hljs-regexp">/os/</span><span class="hljs-variable">$arch</span><br></code></pre></td></tr></table></figure><p>更新:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -Syy</span><br></code></pre></td></tr></table></figure><h2 id="使用-ssh-连接"><a href="#使用-ssh-连接" class="headerlink" title="使用 ssh 连接"></a>使用 ssh 连接</h2><p>使用 <code>ssh</code> 连接后安装比较方便, 因此先:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># pacman -Syy openssh</span><br></code></pre></td></tr></table></figure><p>启动 <code>sshd</code>:</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl enable sshd<br><span class="hljs-params">system</span>ctl start sshd<br><span class="hljs-params">system</span>ctl status sshd<br></code></pre></td></tr></table></figure><p>先修改一下 root 密码，方便连接:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">passwd root</span> <br></code></pre></td></tr></table></figure><p>然后回到自己的终端进行 ssh 连接:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh root<span class="hljs-variable">@ip</span><br></code></pre></td></tr></table></figure><p>这个 ip 后面没有端口号.</p><h2 id="磁盘分区及格式化"><a href="#磁盘分区及格式化" class="headerlink" title="磁盘分区及格式化"></a>磁盘分区及格式化</h2><p>先用 <code>fdisk -l</code> 命令查看磁盘位置, 然后用 <code>fdisk</code> 命令直接分区。如 <code>fdisk /dev/vda</code></p><p>之后格式化磁盘, <code>boot</code> 分区格式化为 <code>fat32</code>，如 <code>mkfs.fat -F 32 /dev/vda2</code></p><p><code>/</code> 根目录分区格式化为 <code>ext4</code>, 如 <code>mkfs.ext4 /dev/vda1</code></p><p>将分区挂载，先挂载 <code>/</code> 根分区到 <code>/mnt</code> 目录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">mount /dev/vda2 /mnt</span><br></code></pre></td></tr></table></figure><p>然后将 <code>boot</code> 分区挂载到 <code>/mnt/boot</code>, 先得创建一个目录:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># mkdir <span class="hljs-regexp">/mnt/</span>boot<br># mount <span class="hljs-regexp">/dev/</span>vda1 <span class="hljs-regexp">/mnt/</span>boot<br></code></pre></td></tr></table></figure><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>安装几个工具:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># pacstrap /mnt base bae-devel linux linux-firmware dhcpcd e2fsprogs iwd</span><br></code></pre></td></tr></table></figure><p><code>base</code> 包包含 20 来个基础的软件.</p><p><code>linux</code> 是 linux 内核。</p><p><code>linux-firmware</code> 是 linux 的框架.</p><p><code>base-devel</code> 中也同样有重要的 packages, 比如 GCC 和 make.</p><p>这里 <code>dhcpcd</code> 是用来动态获取 ip 的。</p><p><code>e2fsprogs</code> 是一个 Ext2 (及 Ext3&#x2F;4) 文件系统工具，它包含了诸如创建、修复、配置、调试 ext2 文件系统等的标准工具.</p><p><code>iwd</code> 是 iNet Wireless Daemon 项目，旨在基于 Linux 设备提供全面的 Wi-Fi 连接解决方案。<br>pacstrap 是一个脚本，它会往一个文件夹里面安装你想要的软件，当前未将根目录挂载到 <code>/mnt</code> 时，其所在环境为启动盘所在的位置而不是系统盘. 因此需要把根目录挂载. </p><h3 id="生成文件系统表"><a href="#生成文件系统表" class="headerlink" title="生成文件系统表"></a>生成文件系统表</h3><p>用于自动挂载分区，不然系统无法正常启动.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># genfstab -U <span class="hljs-regexp">/mnt &gt;&gt; /m</span>nt<span class="hljs-regexp">/etc/</span>fstab<br># cat <span class="hljs-regexp">/mnt/</span>etc/fstab<br></code></pre></td></tr></table></figure><p>执行以下命令进入到我们安装的系统，对系统进行配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">arch-chroot /mnt</span><br></code></pre></td></tr></table></figure><h3 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">ln -sf <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/zoneinfo/</span>Asia<span class="hljs-regexp">/Shanghai /</span>etc/localtime<br><span class="hljs-comment"># 同步硬件时钟</span><br>hwclock --systohc<br></code></pre></td></tr></table></figure><h3 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h3><p>Local 明确规定了地域、货币、时区日期的格式、字符排列方式和其他本地化标准.</p><p>生成 Local 信息</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sed -i <span class="hljs-string">&#x27;s/^#en_US.UTF-8/en_US.UTF-8/&#x27;</span> <span class="hljs-regexp">/etc/</span>locale.gen<br>sed -i <span class="hljs-string">&#x27;s/^#zh_CN.UTF-8/zh_CN.UTF-8/&#x27;</span> <span class="hljs-regexp">/etc/</span>locale.gen<br>locale-gen<br></code></pre></td></tr></table></figure><p>创建 locale.conf 文件，并编辑设定 LANG 变量:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;LANG=en_US.UTF-8&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>locale.conf<br></code></pre></td></tr></table></figure><p>主机名配置:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;ArchLinux&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>hostname<br></code></pre></td></tr></table></figure><p>生成对应 hosts, 将 <code>hostname</code> 换成自己设置的:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo -e <span class="hljs-string">&quot;127.0.0.1 localhost\n::1 localhost\n127.0.1.1 hostname.localdomain hostname&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>hosts<br></code></pre></td></tr></table></figure><p>设置 root 密码:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">passwd root</span><br></code></pre></td></tr></table></figure><h3 id="安装引导程序"><a href="#安装引导程序" class="headerlink" title="安装引导程序"></a>安装引导程序</h3><p>安装 Linux 引导加载程序，才能在安装后启动系统.</p><h4 id="安装徽码"><a href="#安装徽码" class="headerlink" title="安装徽码"></a>安装徽码</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># amd 电脑安装</span><br><span class="hljs-attribute">pacman</span> -S amd-ucode<br><span class="hljs-comment"># intel 电脑安装</span><br>pacman -S intel-ucode<br></code></pre></td></tr></table></figure><p>其中 <code>intel-ucode</code> 是厂家或程序提供商来为你的电脑 cpu 更新一些驱动.</p><h4 id="配置-grub"><a href="#配置-grub" class="headerlink" title="配置 grub"></a>配置 grub</h4><p>Arch 使用 grub2 管理引导，安装相关程序:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S grub efibootmgr efivar os-prober</span><br></code></pre></td></tr></table></figure><h4 id="安装引导"><a href="#安装引导" class="headerlink" title="安装引导"></a>安装引导</h4><p>在安装 <code>grub</code> 之前，需要先确认系统架构是什么.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">uname</span> -m</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">grub-install <span class="hljs-attribute">--target</span>=x86_64-efi <span class="hljs-attribute">--efi-directory</span>=/boot <span class="hljs-attribute">--bootloader-id</span>=Arch --recheck<br><span class="hljs-comment"># --bootloader-id=name 中的name可改</span><br></code></pre></td></tr></table></figure><p>grub2 默认禁用了 os-prober, 如果是选择双系统或多系统安装，需手动开启该选项。</p><p>os-prober 可以检查其他硬盘上的其他系统引导, 如果不开启，可能无法识别其他系统.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">echo <span class="hljs-string">&quot;GRUB_DISABLE_OS_PROBER=false&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">default</span>/grub <br></code></pre></td></tr></table></figure><h4 id="生成引导配置文件"><a href="#生成引导配置文件" class="headerlink" title="生成引导配置文件"></a>生成引导配置文件</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">grub-mkconfig -o <span class="hljs-regexp">/boot/g</span>rub/grub.cfg<br></code></pre></td></tr></table></figure><h3 id="配置开机启动项"><a href="#配置开机启动项" class="headerlink" title="配置开机启动项"></a>配置开机启动项</h3><p>开机后自动连接网络, 需下载联网程序并设置开机自启动:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 下载 wifi 管理</span><br>pacman -S dhcpcd iwd networkmanager<br><span class="hljs-comment"># 设置启动项</span><br>systemctl <span class="hljs-built_in">enable</span> dhcpcd<br>systemctl <span class="hljs-built_in">enable</span> iwd<br>systemctl <span class="hljs-built_in">enable</span> NetworkManager<br></code></pre></td></tr></table></figure><h3 id="ARU-添加-ArchlinuxCN"><a href="#ARU-添加-ArchlinuxCN" class="headerlink" title="ARU 添加 ArchlinuxCN"></a>ARU 添加 ArchlinuxCN</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># /etc/pacman.conf</span><br>[archlinux]<br>Server = http:<span class="hljs-regexp">//mi</span>rror.lzu.edu.cn<span class="hljs-regexp">/archlinuxcn/</span><span class="hljs-variable">$arch</span><br></code></pre></td></tr></table></figure><p>去掉 <code># Color</code> 前的注释符.</p><p>然后更新一下:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -Syy</span> <br></code></pre></td></tr></table></figure><p>若报错则需获取 gpg 密钥:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">rm -rf <span class="hljs-regexp">/etc/</span>pacman.d<span class="hljs-regexp">/gnupg/</span><br>pacman-key --init<br>pacman-key --populate archlinux archlinuxcn<br>pacman -Syy<br></code></pre></td></tr></table></figure><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 退出 arch root 安装环境</span><br><span class="hljs-keyword">exit</span> <br><span class="hljs-comment"># 取消挂载</span><br>umount -R /mnt<br><span class="hljs-comment"># 重启</span><br>reboot<br></code></pre></td></tr></table></figure><h3 id="若-win-和-Ubuntu-的引导记录在-grub-中消失"><a href="#若-win-和-Ubuntu-的引导记录在-grub-中消失" class="headerlink" title="若 win 和 Ubuntu 的引导记录在 grub 中消失"></a>若 win 和 Ubuntu 的引导记录在 grub 中消失</h3><p>实际上的引导记录还是存在的，可以通过 <code>/etc/efi</code> 目录下查看.</p><p>要找到启动 Ubuntu 和 Win 的方法，可以在 BIOS 中进行顺序的切换.</p><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">useradd -m -G wheel -s <span class="hljs-regexp">/bin/</span>bash &lt;username&gt;<br></code></pre></td></tr></table></figure><p>设置用户密码:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">passwd <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span><br></code></pre></td></tr></table></figure><p>赋予用户 sudo 权限, 修改 <code>/etc/sudoers</code> 文件, 去掉 <code>%wheel</code> 行之前的注释. 需要先修改文件权限。</p><h3 id="安装-dwm-窗口管理器"><a href="#安装-dwm-窗口管理器" class="headerlink" title="安装 dwm 窗口管理器"></a>安装 dwm 窗口管理器</h3><p><a href="https://www.cnblog.com/language/p/154415">参考博客</a><br><a href="https://b23.tv/F1W9Gmm">参考b站</a><br>先说一个误会，自己在参考一个视频后拉取了别人的 pwm 仓库，然后安装后不知道如何使用，重新安装原始包即可.</p><h4 id="桌面环境与窗口管理器概述"><a href="#桌面环境与窗口管理器概述" class="headerlink" title="桌面环境与窗口管理器概述"></a>桌面环境与窗口管理器概述</h4><p>桌面环境会提供很多工具。大多数桌面环境包括一整套整合应用程序和使用工.</p><p>窗口管理器仅仅用于管理窗口，安装了窗口管理器之后就可以不用安装桌面环境.</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>有些可能在前面以经安装好了:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S acpi usbutils pciutils</span><br></code></pre></td></tr></table></figure><ul><li><p><code>acpi</code> 是用来查看电池电量的工具。</p></li><li><p><code>usbutils</code> 是用来查看系统 USB 设备.</p></li><li><p><code>pciutils</code> 用来查看系统 PCI 设备。</p></li></ul><p>安装驱动:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">pacman -S xf86-vedio-<span class="hljs-built_in">int</span>el mesa xf86-input-libinput<br></code></pre></td></tr></table></figure><p>这三个好像本就安装好了的，因为我在下载的时候显示的是 <code>reinstall</code>.</p><ul><li><p><code>xf86-vedio-intel</code> 是显核的驱动.</p></li><li><p><code>mesa</code> 是用来配合显卡的另一种上层驱动.</p></li><li><p><code>xf86-input-libinput</code> 是笔记本触摸板的驱动.</p></li></ul><p>安装X窗口系统的相关服务:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">pacman -S <span class="hljs-keyword">xorg </span><span class="hljs-keyword">xorg-xinit </span>xwallpaper sxiv <span class="hljs-keyword">scrotv </span>picom<br></code></pre></td></tr></table></figure><ul><li><code>xorg</code> 是 X 服务，用来显示图形界面</li><li><code>xorg-xinit</code> 是 X 服务的启动程序</li><li><code>xwallpaper</code> 用于更换壁纸</li><li><code>sxiv</code> 用于预览图片</li><li><code>scrotv</code> 用于截屏</li><li><code>picom</code> 窗口渲染，后面做半透明渲染</li></ul><h4 id="安装窗口管理器"><a href="#安装窗口管理器" class="headerlink" title="安装窗口管理器"></a>安装窗口管理器</h4><p>安装 suckless 全家桶:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://git.suckless.org/dwm --<span class="hljs-attr">depth=</span><span class="hljs-number">1</span> <br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://git.suckless.org/st --<span class="hljs-attr">depth=</span><span class="hljs-number">1</span> <br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://git.suckless.org/dmwnu --<span class="hljs-attr">depth=</span><span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><p>分别进入这几个下载下来的目录，并执行 <code>sudo make clean install</code>.</p><p>在家目录下创建 <code>.xinitrc</code> 文件并添加 <code>exec dwm</code>.</p><h4 id="安装亮度控制和-Night-Mode"><a href="#安装亮度控制和-Night-Mode" class="headerlink" title="安装亮度控制和 Night Mode"></a>安装亮度控制和 Night Mode</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S brightnessctl redshift</span><br></code></pre></td></tr></table></figure><p>在 <code>.xinitrc</code> 文件中添加 <code>brightnessctl set 20% &amp;</code> 和 <code>redshift -P -O 4800 &amp;</code></p><p>同样在 <code>.xinitrc</code> 中添加 <code>picom &amp;</code></p><h3 id="安装-lightdm-服务"><a href="#安装-lightdm-服务" class="headerlink" title="安装 lightdm 服务"></a>安装 lightdm 服务</h3><p><code>lightdm</code> 是一个 display manager，也就是提供一个登录界面.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo pacman -S lightdm lightdm-webkit2-greeter lightdm-webkit-theme-litarvan<br></code></pre></td></tr></table></figure><p>其配置文件位置为 <code>/etc/lightdm/lightdm.conf</code> 修改该配置文件，修改 <code>greeter-session</code> 的为 <code>greeter-session=lightdm-webkit2-greeter</code>.</p><p>接着修改 <code>/etc/lightdm/lightdm-webkit2-greeter.conf</code> 将 <code>detect_theme_errors</code> 的值改为 <code>false</code>. <code>webkit_theme</code> 的值改为 <code>litarvan</code>.</p><h3 id="安装-kde-桌面环境"><a href="#安装-kde-桌面环境" class="headerlink" title="安装 kde 桌面环境"></a>安装 kde 桌面环境</h3><p>先安装依赖的 xorg 包.</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">sudo pacman -S xorg xorg-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>最小安装 kde 和 plasma 桌面:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo pacman -S plasma-<span class="hljs-keyword">meta</span> sddm<br></code></pre></td></tr></table></figure><p>之前装的 <code>kde-applications-meta</code> 里面是应用，不是桌面环境. 详情见<a href="https://wiki.archlinux.org/title/KDE">ArchWiki</a></p><p>sddm 是 kde 使用的登录管理器.</p><p>设置 sddm 的开机启动:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo systemctl <span class="hljs-built_in">enable</span> sddm<br></code></pre></td></tr></table></figure><p>下载一些应用:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx">  <span class="hljs-attribute">sudo</span> pacman -S konsole alacritty dolphin ark gwenview lolcat sl neofetch<br><span class="hljs-comment"># konsole 和 alacritty 都是终端</span><br><span class="hljs-comment"># dolphin 是文件管理器</span><br><span class="hljs-comment"># ark 是归档管理器，就是解压缩的</span><br><span class="hljs-comment"># gwenview 是看图片的</span><br><span class="hljs-comment"># lolcat neofetch 和 sl 是防止你打开终端没事干</span><br></code></pre></td></tr></table></figure><h3 id="国内开发的桌面环境有-deepin"><a href="#国内开发的桌面环境有-deepin" class="headerlink" title="国内开发的桌面环境有 deepin"></a>国内开发的桌面环境有 deepin</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pscman -S deepin deepin-extra</span><br></code></pre></td></tr></table></figure><p>这是一个已经配置好的皮肤，附带很多软件.</p><p>将 <code>/etc/lightdm/k=lightdm.conf</code> 中 <code>greeter-session</code> 改为:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">greeter-session</span><span class="hljs-operator">=</span>lightdm-deepin-greeter<br></code></pre></td></tr></table></figure><h3 id="TLP"><a href="#TLP" class="headerlink" title="TLP"></a>TLP</h3><p>用于管理电池.</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>进入一个 b 站 up 的 github 页面– <a href="https://github.com/theniceboy">主页</a></p><h3 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yay -S netease-cloud-music</span><br></code></pre></td></tr></table></figure><h3 id="百度网盘"><a href="#百度网盘" class="headerlink" title="百度网盘"></a>百度网盘</h3>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 pacman 部分</title>
    <link href="/2022/08/30/ArchWiki-%E4%B8%AD-pacman-%E9%83%A8%E5%88%86/"/>
    <url>/2022/08/30/ArchWiki-%E4%B8%AD-pacman-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Pacman">ArchWiki</a></p><p>pacman 的目标是简化对软件包的管理。</p><p>pacman 用 C 语言编写，并使用 tar 作为打包格式.</p><p>似乎是，官方的软件仓库的内容可直接用 pacman 下载.</p><p>运行 <code>pacman -Ql pacman | grep -E &#39;bin/.+&#39;</code> 可查看完整的工具列表。</p><p><code>pacman-contrib</code> 软件包包含一些有用的工具。</p><p><a href="https://wiki.archlinux.org/title/Pacman/Rosetta">pacman 和其他包管理器对比</a></p><p>在 Arch 上安装软件包时，避免在还没有更新系统前刷新同步软件包列表.</p><p>更新软件包:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>pacman -Syy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 AUR 部分</title>
    <link href="/2022/08/30/ArchWiki-%E4%B8%AD-AUR-%E9%83%A8%E5%88%86/"/>
    <url>/2022/08/30/ArchWiki-%E4%B8%AD-AUR-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/Arch_User_Repository_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">ArchLinux</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AUR (Arch User Repository), 其软件包以 <code>PKGBUILD</code> 的形式提供，用户自己通过 <code>makepkg</code> 生成包，再由 <code>pacman</code> 安装。</p><p>创建 AUR 的初衷是方便用户维护和分享新软件包.</p><p>可通过 SSH 连接到 AUR: 运行 <code>ssh aur@aur.archlinux.org help</code> 可获得可用指令列表。</p><p>AUR 维护人员现在仍被称为受信用户 (TU).</p><p>Git 仓库成为 PKGBUILD 的发布方式.</p><p>Github 上的 AUR Archive 储存了迁移过程中的所有 AUR3 软件包仓库。<br><a href="https://github.com/aur-archive">AUR Archive</a></p><h1 id="安装与更新软件包"><a href="#安装与更新软件包" class="headerlink" title="安装与更新软件包"></a>安装与更新软件包</h1><p>基本步骤:</p><ol><li>从 AUR 下载包含 PKGBUILD 和其他安装文件的 tar 包</li><li>用 <code>tar -xvf packagename.tar.gz</code> 解包到一个仅用于编译 AUR 的空闲文件夹</li><li>验证 PKGBUILD 和其他相关文件，确保其中不含有恶意代码</li><li>在保存文件的目录下运行 <code>makepkg</code>, 这将下载代码，编译并打包</li><li>运行 <code>pacman -U package_file</code> 将软件包安装到系统上</li></ol><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>需安装 <code>base-devel</code> 软件包组，其包含了 <code>make</code> 和其他编译工具。</p><h1 id="获取软件包构建所需的文件"><a href="#获取软件包构建所需的文件" class="headerlink" title="获取软件包构建所需的文件"></a>获取软件包构建所需的文件</h1><p>使用 git:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span></span><br></code></pre></td></tr></table></figure><p>使用 curl:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ curl -L -O https:<span class="hljs-regexp">//</span>aur.archlinux.org<span class="hljs-regexp">/cgit/</span>aur.git<span class="hljs-regexp">/snapshot/</span>package_name.tar.gz<br></code></pre></td></tr></table></figure><p>不用 root 用户运行 <code>makepkg</code> 能够在一定程度上防止恶意代码损坏系统。</p><p>可以使用 <code>git clean -dfX</code> 删除所有被 git 忽略的文件，从而删除所有以前构建的包文件。</p><p><code>makepkg</code> 常用参数:</p><ul><li><code>-s/--syncdeps</code> 在构建之前使用 pacman 自动解析和安装任何依赖项。如果包依赖于其他 AUR 包，则您应先手动安装它们。</li><li><code>-i/--install</code> 安装成功的包。这使您可以跳过通常手动完成的下一步。</li><li><code>-r/--rmdeps</code> 在构建后删除构建时依赖项，因为它们不再需要。但是，下次更新包时可能需要重新安装这些依赖项。</li><li><code>-c/--clean</code> 在构建后清理临时构建文件，因为它们不再需要。这些文件通常仅在调试构建过程时才需要。</li></ul><h1 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h1><p>使用 <code>pacman</code>:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># pacman -U package_name-version-architecture.pkg.tar.zst</span><br></code></pre></td></tr></table></figure><h1 id="升级包"><a href="#升级包" class="headerlink" title="升级包"></a>升级包</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git pull<br></code></pre></td></tr></table></figure><h1 id="调试包构建过程"><a href="#调试包构建过程" class="headerlink" title="调试包构建过程"></a>调试包构建过程</h1><ol><li>在构建之前，确保环境最新</li><li>确保安装 <code>base-devle</code></li><li>使用 <code>-s</code> 选项和 <code>makepkg</code> 配置</li></ol>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决用 U 盘作为启动盘时没找到 Linux 的安装选项</title>
    <link href="/2022/08/30/%E8%A7%A3%E5%86%B3%E7%94%A8-U-%E7%9B%98%E4%BD%9C%E4%B8%BA%E5%90%AF%E5%8A%A8%E7%9B%98%E6%97%B6%E6%B2%A1%E6%89%BE%E5%88%B0-Linux-%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%89%E9%A1%B9/"/>
    <url>/2022/08/30/%E8%A7%A3%E5%86%B3%E7%94%A8-U-%E7%9B%98%E4%BD%9C%E4%B8%BA%E5%90%AF%E5%8A%A8%E7%9B%98%E6%97%B6%E6%B2%A1%E6%89%BE%E5%88%B0-Linux-%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%89%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>grub 不支持用 ntfs 格式的启动盘，需要将其改为 ext4&#x2F;fat32, 这里使用 fat32 格式即可:</p><p>先用 <code>fdisk</code> 查找设备:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo fdisk -l<br></code></pre></td></tr></table></figure><p>然后修改格式, 假设设备为 <code>/dev/sda1</code>:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo mkfs.vfat <span class="hljs-regexp">/dev/</span>sda1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决在 hexo 博客中无法显示图片问题</title>
    <link href="/2022/08/30/%E8%A7%A3%E5%86%B3%E5%9C%A8-hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/30/%E8%A7%A3%E5%86%B3%E5%9C%A8-hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>将图片放入 <code>source/img</code> 文件中可在博客中正常显示。</p><p>将图片放入与博文同名的文件夹中可以在 <code>instant-markdown-d</code> 中正确显示.</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArchWiki 中 PKGBUILD 部分</title>
    <link href="/2022/08/30/ArchWiki-%E4%B8%AD-PKGBUILD-%E9%83%A8%E5%88%86/"/>
    <url>/2022/08/30/ArchWiki-%E4%B8%AD-PKGBUILD-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/PKGBUILD">文章位置</a><br>A <code>PKGBUILD</code> is a shell script (也就是说是一个 shell 脚本文件，应该和 Makefile 类似) containing the build information required by Arch Linux packages.</p><p>Arch Linux 用 <code>makepkg</code> 创建软件包。</p><p>当 <code>makepkg</code> 运行时，它会在当前目录寻找 <code>PKGBUILD</code> 文件，并依照其中的指令编译或获取所需的依赖文件，并生成 <code>pkgname.pkg.tar.xz</code> 软件包。生成的包内有二进制文件和安装指令，可以使用 <code>pacman</code> 进行安装。</p><p>可使用 <code>namcap</code> 来检查 <code>PKGBUILD</code> 文件中的常见打包错误。</p><p><code>pkgname</code>, <code>pkgver</code>, <code>pkgrel</code> 和 <code>arch</code> 是 <code>PKGBUILD</code> 文件必须包含的变量。</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>asp 工具相关</title>
    <link href="/2022/08/30/asp-%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/08/30/asp-%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/archlinux/asp">主页</a><br><code>asp</code> is a tool to manage the build source files used to create Arch Linux packages. </p><p><code>asp</code> 替代了 <code>abs</code>, 其提供了更多的 date sources, 使用一个 sparse checkout model 来维护 diskspace.</p><h1 id="使用-asp"><a href="#使用-asp" class="headerlink" title="使用 asp"></a>使用 asp</h1><p>To clone the svntogit-repository for a specific package, use:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>asp checkout pkgname<br></code></pre></td></tr></table></figure><p>这会把一个 git repository for the given package 克隆到一个目录 named like the package.</p><p>去更新这个 git repository, 可以 <code>asp update</code> followed by <code>git pull</code> inside the git repository.</p><p>如果要 copy 一个快照 of the current PKGBUILD for 一个特指的 package, use:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ asp ex<span class="hljs-keyword">port</span> pkgname<br></code></pre></td></tr></table></figure><h1 id="直接使用-git"><a href="#直接使用-git" class="headerlink" title="直接使用 git"></a>直接使用 git</h1><p>clone 一个特指的 branch:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> --branch branch/package --single-branch https://github.com/archlinux/svntogit-packages.git</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>阅读 ArchWiki 中 Arch Linux 部分</title>
    <link href="/2022/08/30/%E9%98%85%E8%AF%BB-ArchWiki-%E4%B8%AD-Arch-Linux-%E9%83%A8%E5%88%86/"/>
    <url>/2022/08/30/%E9%98%85%E8%AF%BB-ArchWiki-%E4%B8%AD-Arch-Linux-%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/">ArchWiki</a><br>Arch Linux 更为简洁，一开始的内容很少，几乎所有配置都需要自己添加。</p><p>其基于滚动发行 (rolling-releasel).</p><p>一开始只有 commandline 界面。</p><p>arch 的包管理器为 pacman.</p><h1 id="About-Arch-Build-System"><a href="#About-Arch-Build-System" class="headerlink" title="About Arch Build System"></a>About Arch Build System</h1><p>The Arch build system is a port-like system for building and packaging software from source code.</p><p><mark>pacman</mark> is the specialized Arch tool for binary package management.</p><p><mark>ABS</mark>(Arch Build System) is a collection of tools for compiling source into installable <code>.pkg.tar.zst</code> packages.</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><code>ABS</code> 包含以下工具作为 a complete toolkit:</p><ul><li>Repository tree, 是 repository 的文件结构</li><li>PKGBUILD, 是一个 bash script</li><li>makepkg, a shell command tool which reads PKGBUILDs, automatically downloads and compiles the sources and creates a <code>.pkg.tar*</code> according to the <code>PKGEXT</code> array in <code>makepkg.conf</code></li><li>pacman, to install and remove the build packages and for fetching dependencies.</li><li>AUR (The Arch User Repository)</li></ul><h2 id="Repository-tree"><a href="#Repository-tree" class="headerlink" title="Repository tree"></a>Repository tree</h2><p>一个包，假如为 <code>acl</code>, 其 tree 大概为:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">acl <br>acl/repos<br>acl<span class="hljs-regexp">/repos/</span>core-x86_64<br>acl<span class="hljs-regexp">/repos/</span>core-x86_64/PKGBUILD<br>acl/trunk<br>acl<span class="hljs-regexp">/trunk/</span>PKGBUILD<br>acl<br></code></pre></td></tr></table></figure><p><code>repos</code> 目录中为官方发布的，<code>truck</code> 目录是还没有发布到 <code>repos</code> 中的。</p><p>真正的源码不会存在于 ABS directory 中, <code>PKGBUILD</code> 里面包含了一个 URL, that will download the source code when the package is built.</p><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><h4 id="Retrieve-PKGBUILD-source"><a href="#Retrieve-PKGBUILD-source" class="headerlink" title="Retrieve PKGBUILD source"></a>Retrieve PKGBUILD source</h4><p>为了得到 PKGBUILD file 需要构建一个具体的 package from source, 可以使用 <code>SVN</code> 或者 <code>GIT</code>.</p><p>先决条件是 install the <code>asp</code> package.</p><p>Asp 是一个工具，用于使用 GIT 来获取 the build source file for Arch Linux packages.</p>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 之禅</title>
    <link href="/2022/08/29/Python-%E4%B9%8B%E7%A6%85/"/>
    <url>/2022/08/29/Python-%E4%B9%8B%E7%A6%85/</url>
    
    <content type="html"><![CDATA[<p>在交互界面中输入 <code>import this</code> 可以看到.</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 权威指南 Notes</title>
    <link href="/2022/08/29/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-Notes/"/>
    <url>/2022/08/29/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.joes-hardware.com/">Joe的五金商店</a></p><h1 id="第一部分-HTTP-Web-的基础"><a href="#第一部分-HTTP-Web-的基础" class="headerlink" title="第一部分 HTTP: Web 的基础"></a>第一部分 HTTP: Web 的基础</h1><h2 id="第一章-HTTP-概述"><a href="#第一章-HTTP-概述" class="headerlink" title="第一章 HTTP 概述"></a>第一章 HTTP 概述</h2><h3 id="1-1-HTTP-–-因特网的多媒体信使"><a href="#1-1-HTTP-–-因特网的多媒体信使" class="headerlink" title="1.1 HTTP – 因特网的多媒体信使"></a>1.1 HTTP – 因特网的多媒体信使</h3><p>HTTP (Hypertext Transfer  Protocol, 超文本传输协议).</p><h3 id="1-2-Web-客户端和服务器"><a href="#1-2-Web-客户端和服务器" class="headerlink" title="1.2 Web 客户端和服务器"></a>1.2 Web 客户端和服务器</h3><p>HTTP 客户端和 HTTP 服务器共同构成了万维网的基本组件。</p><h3 id="1-3-资源"><a href="#1-3-资源" class="headerlink" title="1.3 资源"></a>1.3 资源</h3><p>Web resource 在 Web server 中。</p><h4 id="1-3-1-媒体类型"><a href="#1-3-1-媒体类型" class="headerlink" title="1.3.1 媒体类型"></a>1.3.1 媒体类型</h4><p>MIME (Multipurpose Internet Mail Extension, 多用途因特网邮件扩展) 类型用来描述并标记多媒体内容.</p><p>Web 服务器会为所有 HTTP 对象数据附加一个 MIME 类型。</p><p>MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠分隔，如:</p><ul><li>HTML 格式的文本文档由 text&#x2F;html 类型来标记<br>由此可见，MIME 类型不是特指一种类型.</li></ul><h4 id="1-3-2-URI"><a href="#1-3-2-URI" class="headerlink" title="1.3.2 URI"></a>1.3.2 URI</h4><p>URI (Uniform Resource Identifier, 统一资源标识符). 唯一标识并定位信息资源.</p><p>URI 有两种形式:</p><ul><li>URL</li><li>URN</li></ul><h4 id="1-3-3-URL"><a href="#1-3-3-URL" class="headerlink" title="1.3.3 URL"></a>1.3.3 URL</h4><p>URL (Uniform Resource Locator), 描述一台特定服务器上某资源的特定位置.</p><p>URL 大都遵循一种标准格式，其包含三个部分:</p><ol><li>方案 (scheme), 即协议类型, 如: <code>http://</code></li><li>服务器的因特网地址，如: <code>www.joes-hardware.com</code></li><li>其余部分指定 Web 服务器上的某个资源，如: <code>/specials/saw-blade.gif</code></li></ol><h4 id="1-3-4-URN"><a href="#1-3-4-URN" class="headerlink" title="1.3.4 URN"></a>1.3.4 URN</h4><p>URN (Uniform Resource Name), 与目前的资源所在地无关，其作为特定内容的唯一名称使用。如: <code>urn:ietf:rfc:2141</code></p><p>这种框架可以在对象从一处搬移到另一处时，保持稳定的访问名称。</p><h3 id="1-4-事务"><a href="#1-4-事务" class="headerlink" title="1.4 事务"></a>1.4 事务</h3><p>一个 HTTP 事务由一条请求命令和一个响应结果组成，这种通信是通过名为 HTTP 报文 (HTTP message) 的格式化数据块进行的。</p><h4 id="1-4-1-方法"><a href="#1-4-1-方法" class="headerlink" title="1.4.1 方法"></a>1.4.1 方法</h4><p>HTTP 支出几种不同的请求命令，这些命令被称为 HTTP 方法 (HTTP method). 每条 HTTP 请求报文都包含一个方法，这个方法会告诉服务器要执行什么动作。</p><p>5种常见的 HTTP 方法:</p><ul><li>GET, 从服务器向客户端发送命名资源</li><li>PUT，将来自客户端的数据存储到一个命名的服务器资源中</li><li>DELETE, 从服务器删除命名资源</li><li>POST, 将客户端数据发送到一个服务器网关应用程序</li><li>HEAD, 仅发送命名资源响应中的 HTTP 首部</li></ul><h4 id="1-4-2-状态码"><a href="#1-4-2-状态码" class="headerlink" title="1.4.2 状态码"></a>1.4.2 状态码</h4><p>每条 HTTP 响应报文返回时都会携带一个状态码，状态码是一个三位数字的代码。</p><p>几种常见的状态码:</p><ul><li>200, OK, 文档正确返回</li><li>302，Redirect, 到其他地方获取资源</li><li>404, Not Found, 无法找到资源</li></ul><h4 id="1-4-3-Web-页面中可以包含多个对象"><a href="#1-4-3-Web-页面中可以包含多个对象" class="headerlink" title="1.4.3 Web 页面中可以包含多个对象"></a>1.4.3 Web 页面中可以包含多个对象</h4><h3 id="1-5-报文"><a href="#1-5-报文" class="headerlink" title="1.5 报文"></a>1.5 报文</h3><p>从 Web 客户端发往 Web 服务器的 HTTP 报文称为请求报文 (request message), 从服务器发往客户端的报文称为响应报文 (response message).</p><p>其包含三个部分:</p><ul><li>起始行</li><li>首部字段, 每个首部字段都包含一个名字和一个值，其用 <code>:</code> 分隔</li><li>主体, 可包含二进制数据</li></ul><h3 id="1-6-连接"><a href="#1-6-连接" class="headerlink" title="1.6 连接"></a>1.6 连接</h3><h4 id="1-6-1-TCP-x2F-IP"><a href="#1-6-1-TCP-x2F-IP" class="headerlink" title="1.6.1 TCP&#x2F;IP"></a>1.6.1 TCP&#x2F;IP</h4><p>HTTP 协议位于 TCP 的上层，HTTP 使用 TCP 来传输其报文数据. TCP 位于 IP 上层。<br><img src="/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-Notes/%E5%88%86%E5%B1%82.png" alt="分层"></p><h4 id="1-6-2-连接、IP-地址及端口号"><a href="#1-6-2-连接、IP-地址及端口号" class="headerlink" title="1.6.2 连接、IP 地址及端口号"></a>1.6.2 连接、IP 地址及端口号</h4><p>在 HTTP 客户端向服务器发送报文之前，需要用网际协议 (Internet Protocol, IP) 地址和端口号在客户端和服务器之间建立一条 TCP&#x2F;IP 连接。</p><p>URL 中没有端口号，可以假设其有默认端口号。</p><h4 id="1-6-3-一个使用-Telnet-的实例"><a href="#1-6-3-一个使用-Telnet-的实例" class="headerlink" title="1.6.3 一个使用 Telnet 的实例"></a>1.6.3 一个使用 Telnet 的实例</h4><p>Telnet 程序可以将键盘连接到某个目标 TCP 端口，并将此 TCP 端口的输出回送到显示屏上.</p><p>Telent 常用于远程终端会话，其几乎可以连接所有的 TCP 服务器。</p><p>使用 <code>telnet</code> 程序:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ telnet www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>其会输出三行内容表示已经建立好了连接，此时我们可以输入请求命令如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span>/tools.html HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>nc 程序可以方便地操纵基于 UDP 和 TCP 的流量.</p><h3 id="1-7-协议版本"><a href="#1-7-协议版本" class="headerlink" title="1.7 协议版本"></a>1.7 协议版本</h3><p>目前仍使用的版本:</p><ul><li>HTTP&#x2F;0.9</li><li>HTTP&#x2F;1.0</li><li>HTTP&#x2F;1.0+</li><li>HTTP&#x2F;1.1</li><li>HTTP&#x2F;2.0</li></ul><h3 id="1-8-Web-的结构组件"><a href="#1-8-Web-的结构组件" class="headerlink" title="1.8 Web 的结构组件"></a>1.8 Web 的结构组件</h3><p>较为重要的应用程序:</p><ul><li>代理, 位于客户端和服务器之间的 HTTP 中间实体</li><li>缓存, HTTP 仓库，使常用页面的副本可以保存在离客户端更近的地方</li><li>网关, 连接其他应用程序的特殊的 Web 服务器</li><li>隧道, 对 HTTP 通信报文进行盲转发的特殊代理</li><li>Agent 代理, 发起自动 HTTP 请求的半智能 Web 客户端</li></ul><h4 id="1-8-1-代理"><a href="#1-8-1-代理" class="headerlink" title="1.8.1 代理"></a>1.8.1 代理</h4><p>代理还可以对请求和响应进行过滤。</p><h4 id="1-8-2-缓存"><a href="#1-8-2-缓存" class="headerlink" title="1.8.2 缓存"></a>1.8.2 缓存</h4><p>客户端从附近缓存下载文档会比从远程 Web 服务器下载快得多.</p><h4 id="1-8-3-网关"><a href="#1-8-3-网关" class="headerlink" title="1.8.3 网关"></a>1.8.3 网关</h4><p>gateway, 作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议.</p><h4 id="1-8-4-隧道"><a href="#1-8-4-隧道" class="headerlink" title="1.8.4 隧道"></a>1.8.4 隧道</h4><p>HTTP 隧道的一种常见用途是通过 HTTP 连接承载加密的安全套接字层 (SSL, Secure Socket Layer) 流量，使其可以穿过只允许 Web 流量通过的防火墙。</p><h4 id="1-8-5-Agent-代理"><a href="#1-8-5-Agent-代理" class="headerlink" title="1.8.5 Agent 代理"></a>1.8.5 Agent 代理</h4><p>是代表客户发起 HTTP 请求的客户端程序。</p><p>所有发布 Web 请求的应用程序都是 HTTP Agent 代理.</p><h2 id="第二章-URL-与资源"><a href="#第二章-URL-与资源" class="headerlink" title="第二章 URL 与资源"></a>第二章 URL 与资源</h2><h3 id="2-1-浏览因特网资源"><a href="#2-1-浏览因特网资源" class="headerlink" title="2.1 浏览因特网资源"></a>2.1 浏览因特网资源</h3><p>URL 为应用程序提供了一种访问资源的手段。</p><h3 id="2-2-URL-的语法"><a href="#2-2-URL-的语法" class="headerlink" title="2.2 URL 的语法"></a>2.2 URL 的语法</h3><p>URL 语法会随方案的不同而有所不同.</p><p>大部分 URL 都遵循通用的 URL 语法，而且不同 URL 方案的风格和语法都有不少重叠。</p><p>浏览器通常会用其他应用程序来处理特殊的资源.</p><p>由9部分构成的通用格式:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&lt;scheme&gt;<span class="hljs-symbol">://&lt;user&gt;</span><span class="hljs-symbol">:&lt;password&gt;</span>@&lt;host&gt;<span class="hljs-symbol">:&lt;port&gt;/&lt;path&gt;</span>;&lt;params&gt;<span class="hljs-string">?&lt;</span>query&gt;#&lt;frag&gt;<br></code></pre></td></tr></table></figure><p>解释:<br><img src="/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-Notes/URL%E7%BB%84%E4%BB%B6.png" alt="URL组件"><br><img src="/../img/URL%E7%BB%84%E4%BB%B6.png" alt="URL组件"></p><h4 id="2-2-1-方案-–-使用什么协议"><a href="#2-2-1-方案-–-使用什么协议" class="headerlink" title="2.2.1 方案 – 使用什么协议"></a>2.2.1 方案 – 使用什么协议</h4><p>方案，告诉负责解析 URL 的应用程序应该使用什么协议。</p><p>方案名是大小写无关的，<code>https://</code> 和 <code>HTTPS://</code> 等价。</p><h4 id="2-2-2-主机与端口"><a href="#2-2-2-主机与端口" class="headerlink" title="2.2.2 主机与端口"></a>2.2.2 主机与端口</h4><p>主机组件标识了因特网上能够访问资源的宿主机器。如用域名或 IP 地址来表示主机名.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.jows-hardware.com:<span class="hljs-number">80</span>/index.html<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">161.58</span>.<span class="hljs-number">228.45</span>:<span class="hljs-number">80</span>/index.html<br></code></pre></td></tr></table></figure><p>端口组件标识了服务器正在监听的网络端口。</p><h4 id="2-2-3-用户名和密码"><a href="#2-2-3-用户名和密码" class="headerlink" title="2.2.3 用户名和密码"></a>2.2.3 用户名和密码</h4><p>如果某应用程序使用的 URL 方案要求输入用户名和密码，但用户没有提供，它通常会插入一个默认的用户名和密码。</p><h4 id="2-2-4-路径"><a href="#2-2-4-路径" class="headerlink" title="2.2.4 路径"></a>2.2.4 路径</h4><p>URL 的路径组件说明了资源位于服务器的什么地方。</p><p>可以用字符 “&#x2F;“ 将 HTTP URL 的路径组件划分成一些路径段 (path segment), 每个路径段都有自己的参数 (param) 组件。</p><h4 id="2-2-5-参数"><a href="#2-2-5-参数" class="headerlink" title="2.2.5 参数"></a>2.2.5 参数</h4><p>负责解析 URL 的应用程序需要这些协议参数来访问资源。</p><p>FTP 有两种传输模式:</p><ul><li>二进制</li><li>文本形式</li></ul><h4 id="2-2-6-查询字符串"><a href="#2-2-6-查询字符串" class="headerlink" title="2.2.6 查询字符串"></a>2.2.6 查询字符串</h4><p>很多资源，比如数据库服务，都是可以通过提问题或进行查询来缩小所请求资源的类型范围。</p><p>按照常规，很多网关都希望查询字符串以一系列 “名&#x3D;值” 对的形式出现，名值对之间用字符 “&amp;” 分隔:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.joes-hardware.com/inventory-check.cgi?item=<span class="hljs-number">12731</span>&amp;color=blue<br></code></pre></td></tr></table></figure><h4 id="2-2-7-片段"><a href="#2-2-7-片段" class="headerlink" title="2.2.7 片段"></a>2.2.7 片段</h4><p>HTTP 服务器通常只处理整个对象，而不是对象的片段，客户端不能将片段传送给服务器，浏览器从服务器获得了整个资源后，会根据片段来显示你感兴趣的那部分资源。</p><h3 id="2-3-URL-快捷方式"><a href="#2-3-URL-快捷方式" class="headerlink" title="2.3 URL 快捷方式"></a>2.3 URL 快捷方式</h3><h4 id="2-3-1-相对-URL"><a href="#2-3-1-相对-URL" class="headerlink" title="2.3.1 相对 URL"></a>2.3.1 相对 URL</h4><p>URL 有两种方式:</p><ul><li>绝对 URL, 其包含访问资源所需的全部信息</li><li>相对 URL, 需借助基础 (base) URL 进行解析<br><img src="/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-Notes/%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80URL.png" alt="使用基础 URL"><br><img src="/../img/%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80URL.png" alt="使用基础 URL"></li></ul><h5 id="基础-URL"><a href="#基础-URL" class="headerlink" title="基础 URL"></a>基础 URL</h5><p>转换处理的第一步就是找到基础 URL.</p><p>基础 URL 可以来自:</p><ul><li>在资源中显示提供，如在 HTML 文档中包含一个定义了基础 URL 的 HTML 标记 <code>&lt;BASE&gt;</code>.</li><li>封装资源的基础 URL, 将它所属资源的 URL 作为基础</li><li>没有基础 URL</li></ul><h5 id="解析相对引用"><a href="#解析相对引用" class="headerlink" title="解析相对引用"></a>解析相对引用</h5><p>通常称作分解 (decomposing) URL, 将1基础和相对 URL 划分成组件。</p><h4 id="2-3-2-自动扩展-URL"><a href="#2-3-2-自动扩展-URL" class="headerlink" title="2.3.2 自动扩展 URL"></a>2.3.2 自动扩展 URL</h4><p>用户不需要输入完整的 URL, 因为浏览器会自动扩展。</p><p>以下两种方式:</p><ul><li>主机名扩展</li><li>历史扩展</li></ul><h3 id="2-4-各种令人头疼的字符"><a href="#2-4-各种令人头疼的字符" class="headerlink" title="2.4 各种令人头疼的字符"></a>2.4 各种令人头疼的字符</h3><h4 id="2-4-1-URL-字符集"><a href="#2-4-1-URL-字符集" class="headerlink" title="2.4.1 URL 字符集"></a>2.4.1 URL 字符集</h4><p>通过<mark>转义序列</mark>, 就可以用 US-ASCII 字符集的有限子集对任意字符值或数据进行编码.</p><h4 id="2-4-2-编码机制"><a href="#2-4-2-编码机制" class="headerlink" title="2.4.2 编码机制"></a>2.4.2 编码机制</h4><p>为了避开安全自负即表示法带来的限制，人们设计了一种编码机制，用来在 URL 中表示各种不安全的字符。</p><p>这种编码机制就是通过一种”转义”表示法来表示不安全字符的，这种转义表示法包含:</p><ul><li>一个百分号 (%)</li><li>百分号后跟着两个表示字符 ASCII 码的十六进制数</li></ul><h4 id="2-4-3-字符限制"><a href="#2-4-3-字符限制" class="headerlink" title="2.4.3 字符限制"></a>2.4.3 字符限制</h4><p>即特殊字符，使用原意时需转义:<br><img src="/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-Notes/%E4%BF%9D%E7%95%99%E5%8F%8A%E5%8F%97%E9%99%90%E7%9A%84%E5%AD%97%E7%AC%A6.png" alt="保留及受限的字符"><br><img src="/../img/%E4%BF%9D%E7%95%99%E5%8F%8A%E5%8F%97%E9%99%90%E7%9A%84%E5%AD%97%E7%AC%A6.png" alt="保留及受限的字符"></p><h3 id="2-5-方案的世界"><a href="#2-5-方案的世界" class="headerlink" title="2.5 方案的世界"></a>2.5 方案的世界</h3><p>常见的方案及格式:<br><img src="/../img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%A1%88%E5%8F%8A%E6%A0%BC%E5%BC%8F.png" alt="常见的方案及格式"><br><img src="/../img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%A1%88%E5%8F%8A%E6%A0%BC%E5%BC%8F2.png" alt="常见的方案及格式"><br><img src="/../img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%A1%88%E5%8F%8A%E6%A0%BC%E5%BC%8F3.png" alt="常见的方案及格式"></p><h2 id="第3章-HTTP-报文"><a href="#第3章-HTTP-报文" class="headerlink" title="第3章 HTTP 报文"></a>第3章 HTTP 报文</h2><h3 id="3-1-报文流"><a href="#3-1-报文流" class="headerlink" title="3.1 报文流"></a>3.1 报文流</h3><p>HTTP 报文是在 HTTP 应用程序之间发送的数据块。</p><p>报文在客户端、服务器和代理之间流动，术语 “流入”, “流出”, “上游”, “下游” 都是用来描述报文方向的。</p><h4 id="3-1-1-报文"><a href="#3-1-1-报文" class="headerlink" title="3.1.1 报文"></a>3.1.1 报文</h4><p>HTTP 使用术语 流入 (inbound) 和 流出 (outbound) 来描述事务处理 (transaction) 的方向。</p><p>“流入” 是流向服务器方向，”流出” 是流向用户 Agent 代理方向。</p><h4 id="3-1-2-报文向下游流动"><a href="#3-1-2-报文向下游流动" class="headerlink" title="3.1.2 报文向下游流动"></a>3.1.2 报文向下游流动</h4><p>不管是请求报文还是响应报文，所有报文都会向下游 (downstream) 流动。所有报文的发送者都在接收者的上游 (upstream).</p><h3 id="3-2-报文的组成部分"><a href="#3-2-报文的组成部分" class="headerlink" title="3.2 报文的组成部分"></a>3.2 报文的组成部分</h3><p>每条报文都包含一条来自客户端的请求，活着一条来自服务器的响应。</p><p>其包含三个部分:<br><img src="/../img/HTTP%E6%8A%A5%E6%96%87%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86.png" alt="HTTP 报文的三个部分"><br><code>Content-Type</code> 行说明了主体是什么。</p><p><code>Content-Length</code> 行说明了主体有多大。</p><h4 id="3-2-1-报文的语法"><a href="#3-2-1-报文的语法" class="headerlink" title="3.2.1 报文的语法"></a>3.2.1 报文的语法</h4><p>请求报文格式:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">&lt;<span class="hljs-keyword">method</span>&gt; &lt;<span class="hljs-title function_">request</span>-<span class="hljs-title function_">URL</span>&gt; &lt;<span class="hljs-title function_">version</span>&gt; # 这是请求行，字段用空格分隔<br>&lt;<span class="hljs-title function_">headers</span>&gt;<br><br>&lt;<span class="hljs-title function_">entity</span>-<span class="hljs-title function_">body</span>&gt;<br></code></pre></td></tr></table></figure><p>响应报文格式:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;version&gt;</span> <span class="hljs-section">&lt;status&gt;</span> <span class="hljs-section">&lt;reason-phrase&gt;</span> <span class="hljs-comment"># 这是响应行，也由空格分隔字段</span><br><span class="hljs-section">&lt;headers&gt;</span><br><br><span class="hljs-section">&lt;entity-body&gt;</span><br></code></pre></td></tr></table></figure><p>一组 HTTP 首部总应该以一个空行结束，甚至即使没有首部和实体的主体部分也应如此.</p><p>有些服务器会实现一些自己的请求方法，这些附加的方法是对 HTTP 规范的扩展，被称为<mark>扩展方法</mark>.</p><p><img src="/../img/%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB.png" alt="状态码分类"></p><p>原因短语是响应起始行中的最后一个组件. 它为状态码提供了文本形式的解释.</p><p>版本号不会被当做小数处理，版本中的每个数字都会被当做一个单独的数字来处理，因此，在比较 HTTP 版本时，每个数字都必须要单独进行比较，以便确定哪个版本更高, 如: HTTP&#x2F;2.22 比 HTTP&#x2F;2.3 的版本高.</p><h4 id="3-2-3-首部"><a href="#3-2-3-首部" class="headerlink" title="3.2.3 首部"></a>3.2.3 首部</h4><p>每个 HTTP 首部都有一种简单的语法: 名字后面跟着冒号 <code>:</code> , 然后跟上可选的空格，再跟上字段值，最后是一个 CRLF.</p><p><img src="/../img/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A6%96%E9%83%A8%E5%AE%9E%E4%BE%8B.png" alt="常见的首部实例"></p><h5 id="首部延续行"><a href="#首部延续行" class="headerlink" title="首部延续行"></a>首部延续行</h5><p>将长的首部行分为多行可以提高可读性，多出来的每行前面至少要有一个空格或制表符.</p><h4 id="3-2-4-实体的主体部分"><a href="#3-2-4-实体的主体部分" class="headerlink" title="3.2.4 实体的主体部分"></a>3.2.4 实体的主体部分</h4><p>HTTP 报文的第三部分是可选的实体主体部分，实体的主体是 HTTP 报文的负荷，就是 HTTP 要传输的内容。</p><h4 id="3-2-5-版本-0-9-的报文"><a href="#3-2-5-版本-0-9-的报文" class="headerlink" title="3.2.5 版本 0.9 的报文"></a>3.2.5 版本 0.9 的报文</h4><h3 id="3-3-方法"><a href="#3-3-方法" class="headerlink" title="3.3 方法"></a>3.3 方法</h3><p>如果一台服务器要与 HTTP 1.1 兼容，那么只要为其资源实现 GET 方法和 HEAD 方法就可以了.</p><h4 id="3-3-1-安全方法"><a href="#3-3-1-安全方法" class="headerlink" title="3.3.1 安全方法"></a>3.3.1 安全方法</h4><p>HTTP 定义了一组被称为<mark>安全方法</mark>的方法，GET 方法和 HEAD 方法都被认为是安全的。</p><h4 id="3-3-2-GET"><a href="#3-3-2-GET" class="headerlink" title="3.3.2 GET"></a>3.3.2 GET</h4><p>GET 是最常用的方法，通常用于请求服务器发送某个资源.</p><h4 id="3-3-3-HEAD"><a href="#3-3-3-HEAD" class="headerlink" title="3.3.3 HEAD"></a>3.3.3 HEAD</h4><p>HEAD 方法和 GET 方法的行为很类似，但服务器在响应中只返回首部。不会反悔实体的主体部分.</p><h4 id="3-3-4-PUT"><a href="#3-3-4-PUT" class="headerlink" title="3.3.4 PUT"></a>3.3.4 PUT</h4><p>向服务器写入文档。</p><h4 id="3-3-5-POST"><a href="#3-3-5-POST" class="headerlink" title="3.3.5 POST"></a>3.3.5 POST</h4><p>通常用于支持 HTML 的表单。</p><h4 id="3-3-6-TRACE"><a href="#3-3-6-TRACE" class="headerlink" title="3.3.6 TRACE"></a>3.3.6 TRACE</h4><p>客户端发起一个请求时这个请求可能要穿过防火墙、代理、网关或其他一些应用程序，每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子.</p><p>TRACE 方法只要用于诊断。</p><h4 id="3-3-7-OPTIONS"><a href="#3-3-7-OPTIONS" class="headerlink" title="3.3.7 OPTIONS"></a>3.3.7 OPTIONS</h4><p>该方法请求 Web 服务器告知其支持的各种功能。</p><h4 id="3-3-8-DELETE"><a href="#3-3-8-DELETE" class="headerlink" title="3.3.8 DELETE"></a>3.3.8 DELETE</h4><p>请求服务器删除请求 URL 所指定的资源.</p><p>客户端应用程序无法保证删除操作一定会被执行。因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求.</p><h3 id="3-4-状态码"><a href="#3-4-状态码" class="headerlink" title="3.4 状态码"></a>3.4 状态码</h3><p>HTTP 状态码被分成五大类。</p><p>状态码为客户端提供了一种理解事务处理结果的便捷方式.</p><h4 id="3-4-1-100-199-–-信息性状态码"><a href="#3-4-1-100-199-–-信息性状态码" class="headerlink" title="3.4.1 100 ~ 199 – 信息性状态码"></a>3.4.1 100 ~ 199 – 信息性状态码</h4><h4 id="3-4-2-200-299-–-成功状态码"><a href="#3-4-2-200-299-–-成功状态码" class="headerlink" title="3.4.2 200 ~ 299 – 成功状态码"></a>3.4.2 200 ~ 299 – 成功状态码</h4><h4 id="3-4-3-300-399-–-重定向状态码"><a href="#3-4-3-300-399-–-重定向状态码" class="headerlink" title="3.4.3 300 ~ 399 – 重定向状态码"></a>3.4.3 300 ~ 399 – 重定向状态码</h4><p>重定向状态码要么告诉客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。</p><h4 id="3-4-4-400-499-–-客户端错误状态码"><a href="#3-4-4-400-499-–-客户端错误状态码" class="headerlink" title="3.4.4 400 ~ 499 – 客户端错误状态码"></a>3.4.4 400 ~ 499 – 客户端错误状态码</h4><h4 id="3-4-5-500-599-–-服务器错误状态码"><a href="#3-4-5-500-599-–-服务器错误状态码" class="headerlink" title="3.4.5 500 ~ 599 – 服务器错误状态码"></a>3.4.5 500 ~ 599 – 服务器错误状态码</h4><p>服务器自身出错了.</p><h3 id="3-5-首部"><a href="#3-5-首部" class="headerlink" title="3.5 首部"></a>3.5 首部</h3><p>在请求和响应报文中都可以用首部来提供信息,有些首部是某种报文专用的，有些首部更通用一些。</p><p>五个主要类型:</p><ul><li>通用首部</li><li>请求首部</li><li>响应首部</li><li>实体首部</li><li>扩展首部</li></ul><h4 id="3-5-1-通用首部"><a href="#3-5-1-通用首部" class="headerlink" title="3.5.1 通用首部"></a>3.5.1 通用首部</h4><p>这些首部提供了与报文相关的最基本的信息。<br><img src="/../img/%E9%80%9A%E7%94%A8%E7%9A%84%E4%BF%A1%E6%81%AF%E6%80%A7%E9%A6%96%E9%83%A8.png" alt="通用的信息性首部"></p><h4 id="3-5-2-请求首部"><a href="#3-5-2-请求首部" class="headerlink" title="3.5.2 请求首部"></a>3.5.2 请求首部</h4><p>请求首部是在请求报文中有意义的首部，用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力.</p><h5 id="Accept-首部"><a href="#Accept-首部" class="headerlink" title="Accept 首部"></a>Accept 首部</h5><h5 id="条件请求首部"><a href="#条件请求首部" class="headerlink" title="条件请求首部"></a>条件请求首部</h5><p>为请求加上某些限制</p><h5 id="安全请求首部"><a href="#安全请求首部" class="headerlink" title="安全请求首部"></a>安全请求首部</h5><p>要求客户端在获取特定的资源之前，先对自身进行认证。</p><h5 id="代理请求首部"><a href="#代理请求首部" class="headerlink" title="代理请求首部"></a>代理请求首部</h5><h4 id="3-5-3-响应首部"><a href="#3-5-3-响应首部" class="headerlink" title="3.5.3 响应首部"></a>3.5.3 响应首部</h4><p>响应首部为客户端提供了一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令.</p><h5 id="协商首部"><a href="#协商首部" class="headerlink" title="协商首部"></a>协商首部</h5><p>就是资源有多种，可以考虑要哪个。</p><h5 id="安全响应首部"><a href="#安全响应首部" class="headerlink" title="安全响应首部"></a>安全响应首部</h5><p>HTTP 的质询&#x2F;响应认证机制的响应侧.</p><h4 id="3-5-3-实体首部"><a href="#3-5-3-实体首部" class="headerlink" title="3.5.3 实体首部"></a>3.5.3 实体首部</h4><p>提供了有关实体及其内容的大量信息.</p><h5 id="内容首部"><a href="#内容首部" class="headerlink" title="内容首部"></a>内容首部</h5><p>与实体内容有关的信息.</p><h5 id="实体缓存首部"><a href="#实体缓存首部" class="headerlink" title="实体缓存首部"></a>实体缓存首部</h5><p>提供了与被缓存实体有关的信息.</p><h2 id="第四章-连接管理"><a href="#第四章-连接管理" class="headerlink" title="第四章 连接管理"></a>第四章 连接管理</h2><p>HTTP 连接是 HTTP 报文传输的关键通道.</p><h3 id="4-1-TCP-连接"><a href="#4-1-TCP-连接" class="headerlink" title="4.1 TCP 连接"></a>4.1 TCP 连接</h3><p>世界上几乎所有的 HTTP 通信都是由 TCP&#x2F;IP 承载的.</p><h4 id="4-1-1-TCP-的可靠数据管道"><a href="#4-1-1-TCP-的可靠数据管道" class="headerlink" title="4.1.1 TCP 的可靠数据管道"></a>4.1.1 TCP 的可靠数据管道</h4><p>HTTP 连接实际上就是 TCP 连接及其使用规则。</p><p>TCP 为 HTTP 提供了一条可靠的比特传输管道.<br><img src="/TCP%E8%BF%9E%E6%8E%A5.png" alt="TCP连接"></p><h4 id="4-1-2-TCP-流是分段的、由-IP-分组传送"><a href="#4-1-2-TCP-流是分段的、由-IP-分组传送" class="headerlink" title="4.1.2 TCP 流是分段的、由 IP 分组传送"></a>4.1.2 TCP 流是分段的、由 IP 分组传送</h4><p>TCP 的数据是通过 IP 数据报的小数据块来发送的.</p><p>HTTPS 就是在 HTTP 和 TCP 之间插入了一个密码加密层.</p><p><img src="/HTTP%E5%92%8CHTTPS%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88.png" alt="HTTP和HTTPS网络协议栈"></p><p>每个 IP 数据报都包括:</p><ul><li>一个 IP 分组首部</li><li>一个 TCP 首段</li><li>一个 TCP 数据块</li></ul><h4 id="4-1-3-保持-TCP-连接持续不断地运行"><a href="#4-1-3-保持-TCP-连接持续不断地运行" class="headerlink" title="4.1.3 保持 TCP 连接持续不断地运行"></a>4.1.3 保持 TCP 连接持续不断地运行</h4><p>在任何时刻计算机都可以有几条 TCP 连接处于打开状态。TCP 是通过端口号来保持所有这些连接持续不断地运行.</p><p>端口号和雇员使用的电话分机号很类似.</p><p>IP 地址可以将你连接到正确的计算机，而端口号则可以将你连接到正确的应用程序上去.</p><p>TCP 连接是通过 4 个值来识别的:</p><ul><li>源 IP 地址</li><li>源端口号</li><li>目的 IP 地址</li><li>目的端口号<br>这 4 个值一起唯一定义了一条连接。</li></ul><h4 id="4-1-4-用-TCP-套接字编程"><a href="#4-1-4-用-TCP-套接字编程" class="headerlink" title="4.1.4 用 TCP 套接字编程"></a>4.1.4 用 TCP 套接字编程</h4><p>操作系统提供了一些操纵其 TCP 连接的工具：<br><img src="/%E5%B8%B8%E8%A7%81%E5%A5%97%E6%8E%A5%E5%AD%97API.png" alt="常见套接字API"></p><p>通信过程:<br><img src="/TCP%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" alt="TCP通信过程"></p><h3 id="4-2-对-TCP-性能的考虑"><a href="#4-2-对-TCP-性能的考虑" class="headerlink" title="4.2 对 TCP 性能的考虑"></a>4.2 对 TCP 性能的考虑</h3><p>HTTP 事务的性能在很大程度上取决于底层 TCP 通道的性能。</p><h4 id="4-2-1-HTTP-事务的时延"><a href="#4-2-1-HTTP-事务的时延" class="headerlink" title="4.2.1 HTTP 事务的时延"></a>4.2.1 HTTP 事务的时延</h4><h3 id="4-3-HTTP-连接的处理"><a href="#4-3-HTTP-连接的处理" class="headerlink" title="4.3 HTTP 连接的处理"></a>4.3 HTTP 连接的处理</h3><h4 id="4-3-1-常被误解的-Connection-首部"><a href="#4-3-1-常被误解的-Connection-首部" class="headerlink" title="4.3.1 常被误解的 Connection 首部"></a>4.3.1 常被误解的 Connection 首部</h4><p>HTTP 允许在客户端和最终的源端服务器之间存在一串 HTTP 中间实体.</p><p>在某些情况下，两个相邻的 HTTP 应用程序会为它们共享的连接应用一组选项。</p><p>HTTP 的 Connection 首部字段中有一个由逗号分隔的<mark>连接标签</mark>列表，用于指定不会传播到其他连接中的选项.</p><h4 id="4-3-2-串行事务处理时延"><a href="#4-3-2-串行事务处理时延" class="headerlink" title="4.3.2 串行事务处理时延"></a>4.3.2 串行事务处理时延</h4><h1 id="第二部分-HTTP-结构"><a href="#第二部分-HTTP-结构" class="headerlink" title="第二部分 HTTP 结构"></a>第二部分 HTTP 结构</h1><h2 id="第5章-Web-服务器"><a href="#第5章-Web-服务器" class="headerlink" title="第5章 Web 服务器"></a>第5章 Web 服务器</h2><h3 id="5-1-各种形状和尺寸的-Web-服务器"><a href="#5-1-各种形状和尺寸的-Web-服务器" class="headerlink" title="5.1 各种形状和尺寸的 Web 服务器"></a>5.1 各种形状和尺寸的 Web 服务器</h3><p>“Web 服务器” 可以用来表示 Web 服务器的软件，也可以用来表示提供 Web 页面的特定设备或计算机.</p><h4 id="5-1-1-Web-服务器的实现"><a href="#5-1-1-Web-服务器的实现" class="headerlink" title="5.1.1 Web 服务器的实现"></a>5.1.1 Web 服务器的实现</h4><h4 id="5-1-2-通用软件-Web-服务器"><a href="#5-1-2-通用软件-Web-服务器" class="headerlink" title="5.1.2 通用软件 Web 服务器"></a>5.1.2 通用软件 Web 服务器</h4><h4 id="5-1-3-Web-服务器设备"><a href="#5-1-3-Web-服务器设备" class="headerlink" title="5.1.3 Web 服务器设备"></a>5.1.3 Web 服务器设备</h4><p>Web server appliance 是预先打包好的软硬件解决方案.</p><h4 id="5-1-3-嵌入式-Web-服务器"><a href="#5-1-3-嵌入式-Web-服务器" class="headerlink" title="5.1.3 嵌入式 Web 服务器"></a>5.1.3 嵌入式 Web 服务器</h4><h3 id="5-2-最小的-Perl-Web-服务器"><a href="#5-2-最小的-Perl-Web-服务器" class="headerlink" title="5.2 最小的 Perl Web 服务器"></a>5.2 最小的 Perl Web 服务器</h3><h3 id="5-3-实际的-Web-服务器会做些什么"><a href="#5-3-实际的-Web-服务器会做些什么" class="headerlink" title="5.3 实际的 Web 服务器会做些什么"></a>5.3 实际的 Web 服务器会做些什么</h3><ol><li>建立连接</li><li>接收请求</li><li>处理请求</li><li>访问资源</li><li>构建响应</li><li>发送响应</li><li>记录事务处理过程，会将与已完成事务有关的内容记录在一个日志文件中</li></ol><h3 id="5-4-第一步-–-接收客户端连接"><a href="#5-4-第一步-–-接收客户端连接" class="headerlink" title="5.4 第一步 – 接收客户端连接"></a>5.4 第一步 – 接收客户端连接</h3><h4 id="5-4-1-处理新连接"><a href="#5-4-1-处理新连接" class="headerlink" title="5.4.1 处理新连接"></a>5.4.1 处理新连接</h4><p>Web 服务器可以随意拒绝或立即关闭任意一条连接。</p><h4 id="5-4-2-客户端主机名识别"><a href="#5-4-2-客户端主机名识别" class="headerlink" title="5.4.2 客户端主机名识别"></a>5.4.2 客户端主机名识别</h4><p>可以用 “反向 DNS” 对大部分 Web 服务器进行配置，以便将客户端 IP 地址转换成客户端主机名。</p><p>主机名查找可能会花费很长时间，这样会降低 Web 事务处理的速度.</p><p>可以用配置指令 HostnameLookups 启用 Apache 的主机查找功能.</p><h4 id="5-4-3-通过-ident-确定客户端用户"><a href="#5-4-3-通过-ident-确定客户端用户" class="headerlink" title="5.4.3 通过 ident 确定客户端用户"></a>5.4.3 通过 ident 确定客户端用户</h4><p>有些 Web 服务器还支持 IETF 的 idnet 协议，服务器可以通过 ident 协议找到发起 HTTP 连接的用户名.</p><p>如果客户端支持 ident 协议，就在 TCP 端口 113 上监听 ident 请求.</p><p>可以通过 Apache 的 IdentityCheck on 指令告知 Apache Web 服务器使用 ident 查找功能.</p><h3 id="5-5-第二步-–-接收请求报文"><a href="#5-5-第二步-–-接收请求报文" class="headerlink" title="5.5 第二步 – 接收请求报文"></a>5.5 第二步 – 接收请求报文</h3><p>连接上有数据到达时，Web 服务器会从网络连接中读取数据，并将请求报文中的内容解析出来。</p><h4 id="5-5-1-报文的内部表示法"><a href="#5-5-1-报文的内部表示法" class="headerlink" title="5.5.1 报文的内部表示法"></a>5.5.1 报文的内部表示法</h4><p>有些 Web 服务器还会用便于进行报文操作的内部数据结构来存储请求报文.</p><h4 id="5-5-2-连接的输入-x2F-输出处理结构"><a href="#5-5-2-连接的输入-x2F-输出处理结构" class="headerlink" title="5.5.2 连接的输入&#x2F;输出处理结构"></a>5.5.2 连接的输入&#x2F;输出处理结构</h4><p>不同的 Web 服务器结构会以不同的方式为请求服务:</p><ul><li>单线程 Web 服务器</li><li>多进程及多线程 Web 服务器</li><li>复用 I&#x2F;O 的服务器</li><li>复用的多线程 Web 服务器</li></ul><p><img src="/../img/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%84.png" alt="Web服务器输入输出结构"></p><h3 id="5-6-第三步-–-处理请求"><a href="#5-6-第三步-–-处理请求" class="headerlink" title="5.6 第三步 – 处理请求"></a>5.6 第三步 – 处理请求</h3><h3 id="5-7-第四步-–-对资源的映射及访问"><a href="#5-7-第四步-–-对资源的映射及访问" class="headerlink" title="5.7 第四步 – 对资源的映射及访问"></a>5.7 第四步 – 对资源的映射及访问</h3><p>在 Web 服务器将内容传送给客户端之前，要将请求报文中的 URI 映射为 Web 服务器上适当的内容或内容生成器.</p><h4 id="5-7-1-docroot"><a href="#5-7-1-docroot" class="headerlink" title="5.7.1 docroot"></a>5.7.1 docroot</h4><p>文档的根目录即 document root (docroot).</p><p>最简单的资源映射形式就是用请求 URI 作为名字来访问 Web 服务器文件系统中的文件.</p><h5 id="虚拟托管的-docroot"><a href="#虚拟托管的-docroot" class="headerlink" title="虚拟托管的 docroot"></a>虚拟托管的 docroot</h5><p>虚拟托管的 Web 服务器会在同一台 Web 服务器上提供多个 Web 站点，每个站点在服务器上都有自己独有的文档根目录。</p><h5 id="用户的主目录-docroot"><a href="#用户的主目录-docroot" class="headerlink" title="用户的主目录 docroot"></a>用户的主目录 docroot</h5><p>Docroot 的另一种常见应用是在 Web 服务器上为人们提供私有的 Web 站点. 通常会把那些以斜杠和波浪号 (&#x2F;~) 开始，后面跟着用户名的 URI 映射为此用户的私有文档根目录.</p><h4 id="5-7-2-目录列表"><a href="#5-7-2-目录列表" class="headerlink" title="5.7.2 目录列表"></a>5.7.2 目录列表</h4><p>Web 服务器可以接收对目录 URL 的请求，其路径可以解析为一个目录。</p><p>大多数 Web 服务器都会去查找目录中一个名为 index.html 或 index.htm 的文件来代表此目录。如果用户请求的是一个目录的 URL, 而且这个目录中有一个名为 index.html (或 index.htm) 的文件，服务器就会返回那个文件的内容.</p><p>在 Apache Web 服务器上，可以用配置命令 DirectoryIndex 来配置要作为默认目录文件使用的文件名集合。指令 DirectoryIndex 会按照优先顺序列出所有可以作为目录索引文件使用的文件名.</p><h4 id="5-7-3-动态内容资源的映射"><a href="#5-7-3-动态内容资源的映射" class="headerlink" title="5.7.3 动态内容资源的映射"></a>5.7.3 动态内容资源的映射</h4><h3 id="5-8-第五步-–-构建响应"><a href="#5-8-第五步-–-构建响应" class="headerlink" title="5.8 第五步 – 构建响应"></a>5.8 第五步 – 构建响应</h3><h3 id="5-9-第六步-–-发送响应"><a href="#5-9-第六步-–-发送响应" class="headerlink" title="5.9 第六步 – 发送响应"></a>5.9 第六步 – 发送响应</h3><h3 id="5-10-第七部-–-记录日志"><a href="#5-10-第七部-–-记录日志" class="headerlink" title="5.10 第七部 – 记录日志"></a>5.10 第七部 – 记录日志</h3><h2 id="第六章-代理"><a href="#第六章-代理" class="headerlink" title="第六章 代理"></a>第六章 代理</h2><p>Web 代理 (proxy) 服务器是网络的中间实体，代理位于客户端和服务器之间，在各端点之间来回传送 HTTP 报文.</p><h3 id="6-1-Web-的中间实体"><a href="#6-1-Web-的中间实体" class="headerlink" title="6.1 Web 的中间实体"></a>6.1 Web 的中间实体</h3><p>HTTP 的代理服务既是 Web 服务器又是 Web 客户端。</p><h4 id="6-1-1-私有和共享代理"><a href="#6-1-1-私有和共享代理" class="headerlink" title="6.1.1 私有和共享代理"></a>6.1.1 私有和共享代理</h4><p>代理服务器可以使某个客户端专用的，也可以是很多客户端共享的。</p><p>单个客户端专用的代理称为<mark>私有代理</mark>.</p><p>众多客户端共享的代理被称为<mark>公共代理</mark>. 其成本效率高，更容易管理.</p><h4 id="6-1-2-代理与网关的对比"><a href="#6-1-2-代理与网关的对比" class="headerlink" title="6.1.2 代理与网关的对比"></a>6.1.2 代理与网关的对比</h4><p>代理连接的是两个或多个使用相同协议的应用程序。</p><p>网关连接的是两个或多个使用不同协议的端点。其扮演的是”协议转换器”的角色.<br><img src="/%E4%BB%A3%E7%90%86%E5%92%8C%E7%BD%91%E5%85%B3%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="代理和网关的区别"></p><h3 id="6-2-为什么使用代理"><a href="#6-2-为什么使用代理" class="headerlink" title="6.2 为什么使用代理"></a>6.2 为什么使用代理</h3><p>代理服务器可以看到并接触到所有流过的 HTTP 流量，所以代理可以监视流量并对其进行修改。</p><p>可以用反向代理来提高访问慢速 Web 服务器上公共内容时的性能，这些反向代理通常被称为服务器加速器 (server accelerator).</p><h3 id="6-3-代理会去往何处"><a href="#6-3-代理会去往何处" class="headerlink" title="6.3 代理会去往何处"></a>6.3 代理会去往何处</h3><h4 id="6-3-1-代理服务器的部署"><a href="#6-3-1-代理服务器的部署" class="headerlink" title="6.3.1 代理服务器的部署"></a>6.3.1 代理服务器的部署</h4><p>部署代理的几种方式:</p><ul><li>出口代理，将代理固定在本地网络的出口点，以便控制本地网络与大型因特网之间的流量.</li><li>访问 (入口) 代理，将代理放在 ISP 访问点上，用以处理来自客户的聚合请求.</li><li>反向代理, 部署在网络边缘，在 Web 服务器之前，作为替代物 (即反向代理) 使用, 在那里它们可以处理所有传送给 Web 服务器的请求, 并只在必要时向 Web 服务器请求资源. 反向代理通常会直接冒用 Web 服务器的名字和 IP 地址</li><li>网络交换代理, 将具有足够处理能力的代理放在网络之间的因特网对等交换点上，通过缓存来减轻因特网节点的拥塞，并对流量进行监视</li></ul><h4 id="6-3-2-代理的层次结构-proxy-hierarchy"><a href="#6-3-2-代理的层次结构-proxy-hierarchy" class="headerlink" title="6.3.2 代理的层次结构 (proxy hierarchy)"></a>6.3.2 代理的层次结构 (proxy hierarchy)</h4><p>报文会从一个代理传给另一个代理.<br><img src="/%E4%B8%89%E7%BA%A7%E7%9A%84%E4%BB%A3%E7%90%86%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="三级的代理层次结构"></p><p>靠近服务器的代理为<mark>父代理</mark>.</p><p>靠近客户端的代理为<mark>子代理</mark></p><h5 id="代理层次结构的内容路由"><a href="#代理层次结构的内容路由" class="headerlink" title="代理层次结构的内容路由"></a>代理层次结构的内容路由</h5><p>代理层次结构可以是动态的, 即并不是单一的路线。</p><h4 id="6-3-3-代理是如何获取流量的"><a href="#6-3-3-代理是如何获取流量的" class="headerlink" title="6.3.3 代理是如何获取流量的"></a>6.3.3 代理是如何获取流量的</h4><p>有四种常见方式可以使客户流量流向代理:</p><ul><li>修改客户端, 手动将客户端配置为使用代理服务器</li><li>修改网络, </li><li>修改 DNS 的命名空间</li><li>修改 Web 服务器</li></ul><h3 id="6-4-客户端的代理设置"><a href="#6-4-客户端的代理设置" class="headerlink" title="6.4 客户端的代理设置"></a>6.4 客户端的代理设置</h3><p>所有现代的 Web 浏览器都允许用户对代理使用进行配置。</p><p>几种方法:</p><ul><li>手工配置</li><li>预先配置浏览器</li><li>代理的自动配置</li><li>WPAD 的代理发现</li></ul><h3 id="6-5-与代理请求有关的一些棘手问题"><a href="#6-5-与代理请求有关的一些棘手问题" class="headerlink" title="6.5 与代理请求有关的一些棘手问题"></a>6.5 与代理请求有关的一些棘手问题</h3><h4 id="6-5-1-代理-URI-与服务器-URI-不同"><a href="#6-5-1-代理-URI-与服务器-URI-不同" class="headerlink" title="6.5.1 代理 URI 与服务器 URI 不同"></a>6.5.1 代理 URI 与服务器 URI 不同</h4><p>除了这一点之外，Web 服务器报文和 Web 代理报文的语法是一样的。</p><p>客户端向 Web 服务器发送请求时，请求行中只包含部分 URI (URI 中不包含方案、主机或端口).</p><p>客户端向代理发送请求时，请求行中则包含完整的 URI.</p><h4 id="6-5-2-与虚拟主机一样的问题"><a href="#6-5-2-与虚拟主机一样的问题" class="headerlink" title="6.5.2 与虚拟主机一样的问题"></a>6.5.2 与虚拟主机一样的问题</h4><h4 id="6-5-3-拦截代理会收到部分-URI"><a href="#6-5-3-拦截代理会收到部分-URI" class="headerlink" title="6.5.3 拦截代理会收到部分 URI"></a>6.5.3 拦截代理会收到部分 URI</h4><h3 id="6-6-追踪报文"><a href="#6-6-追踪报文" class="headerlink" title="6.6 追踪报文"></a>6.6 追踪报文</h3><h4 id="6-6-2-Via-首部"><a href="#6-6-2-Via-首部" class="headerlink" title="6.6.2 Via 首部"></a>6.6.2 Via 首部</h4><p>Via 首部字段列出了与报文途径的每个中间节点有关的信息.</p><p>报文每经过一个节点，都必须将这个中间节点添加到 Via 列表的末尾.</p><h5 id="Via-的语法"><a href="#Via-的语法" class="headerlink" title="Via 的语法"></a>Via 的语法</h5><p>由逗号 <code>,</code> 分隔。</p><p>每个 waypoint 最多包含四个组件:</p><ul><li>可选的协议名</li><li>必选的协议版本</li><li>必选的节点名</li><li>可选的描述性注释</li></ul><h5 id="Via-的请求和响应路径"><a href="#Via-的请求和响应路径" class="headerlink" title="Via 的请求和响应路径"></a>Via 的请求和响应路径</h5><p>请求和响应通常都是通过同一条 TCP 连接传输的，响应报文会沿着与请求报文相同的路径回传。</p><h5 id="Via-与网关"><a href="#Via-与网关" class="headerlink" title="Via 与网关"></a>Via 与网关</h5><p>有些代理会为使用非 HTTP 协议的服务提供网关的功能，Via 首部记录了这些协议转换.</p><h5 id="Server-和-Via-首部"><a href="#Server-和-Via-首部" class="headerlink" title="Server 和 Via 首部"></a>Server 和 Via 首部</h5><p>Server 响应首部字段对原始服务器使用的软件进行了描述:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Server</span>: Apache/<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">14</span> (Unix) PHP/<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h5 id="Via-的隐私和安全问题"><a href="#Via-的隐私和安全问题" class="headerlink" title="Via 的隐私和安全问题"></a>Via 的隐私和安全问题</h5><p>当代理服务器作为网络防火墙的一部分使用时，是不应该转发防火墙后面那些主机的名字和端口号的.</p><p>如果不允许进行 Via 节点名转发，作为安全防线的一部分使用的代理就应该用适当的假名来取代那台主机的名字.</p><h4 id="6-6-2-TRACE-方法"><a href="#6-6-2-TRACE-方法" class="headerlink" title="6.6.2 TRACE 方法"></a>6.6.2 TRACE 方法</h4><p>代理服务器可以在转发报文时对其进行修改，可以添加、修改或删除首部，也可以将主体部分转换称不同的格式.</p><p>通过 HTTP&#x2F;1.1 的 TRACE 方法，用户可以跟踪经代理链传输的请求报文，观察报文经过了哪些代理, 以及每个代理是如何对请求报文进行修改的。</p><p>可以使用 <code>Max-Forwards</code> 首部来限制 TRACE 和 OPTIONS 请求所经过的代替跳数.</p><p><code>Max-Forwards</code> 请求首部字段包含了一个整数，用来说明这条请求报文还可以被转发的次数.</p><p>转发一次, <code>Max-Forwards</code> 后的整数减一。</p><h3 id="6-7-代理认证"><a href="#6-7-代理认证" class="headerlink" title="6.7 代理认证"></a>6.7 代理认证</h3><p>这种机制可以阻止对内容的请求，直到用户向代理提供了有效的访问权限证书为止.</p><h3 id="6-8-代理的互操作性"><a href="#6-8-代理的互操作性" class="headerlink" title="6.8 代理的互操作性"></a>6.8 代理的互操作性</h3><h4 id="6-8-1-处理代理不支持的首部和方法"><a href="#6-8-1-处理代理不支持的首部和方法" class="headerlink" title="6.8.1 处理代理不支持的首部和方法"></a>6.8.1 处理代理不支持的首部和方法</h4><p>代理必须对不认识的首部字段进行转发，而且必须维持同名首部字段的相对顺序.</p><h4 id="6-8-2-OPTIONS-发现对可选特性的支持"><a href="#6-8-2-OPTIONS-发现对可选特性的支持" class="headerlink" title="6.8.2 OPTIONS: 发现对可选特性的支持"></a>6.8.2 OPTIONS: 发现对可选特性的支持</h4><h4 id="6-8-3-Allow-首部"><a href="#6-8-3-Allow-首部" class="headerlink" title="6.8.3 Allow 首部"></a>6.8.3 Allow 首部</h4><p>Allow 实体首部字段列出了请求 URI 标识的资源所支持的方法列表，如果请求 URI 为 <code>*</code> ，列出的就是整个服务器所支持的方法列表.</p><h2 id="第七章-缓存"><a href="#第七章-缓存" class="headerlink" title="第七章 缓存"></a>第七章 缓存</h2><p>Web 缓存是可以自动保存常见文档副本的 HTTP 设备.</p><h3 id="7-1-冗余的数据传输"><a href="#7-1-冗余的数据传输" class="headerlink" title="7.1 冗余的数据传输"></a>7.1 冗余的数据传输</h3><h3 id="7-2-带宽瓶颈"><a href="#7-2-带宽瓶颈" class="headerlink" title="7.2 带宽瓶颈"></a>7.2 带宽瓶颈</h3><h3 id="7-3-瞬间拥塞"><a href="#7-3-瞬间拥塞" class="headerlink" title="7.3 瞬间拥塞"></a>7.3 瞬间拥塞</h3><p>缓存在破坏瞬间拥塞 (Flash Crowds) 时非常重要.</p><h3 id="7-4-距离时延"><a href="#7-4-距离时延" class="headerlink" title="7.4 距离时延"></a>7.4 距离时延</h3><h3 id="7-5-命中和未命中的"><a href="#7-5-命中和未命中的" class="headerlink" title="7.5 命中和未命中的"></a>7.5 命中和未命中的</h3><p>用已有的副本为某些到达缓存的请求提供服务，被称为<mark>缓存命中</mark> (cache hit).</p><p>到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器，被称为<mark>缓存未命中</mark> (cache miss)</p><h4 id="7-5-1-再验证"><a href="#7-5-1-再验证" class="headerlink" title="7.5.1 再验证"></a>7.5.1 再验证</h4><p>缓存需对它们保存的副本进行检测，判断是否为服务器上的最新副本。这被称为<mark>HTTP 再验证</mark> (revalidaion).</p><p>大部分缓存只有在客户端发起请求，并且副本旧得足以需要检测的时候，才会对副本进行 revalidation.</p><p>使用 <code>If-Modified-Since</code> 首，告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改下，才发送此对象.</p><h4 id="7-5-2-命中率"><a href="#7-5-2-命中率" class="headerlink" title="7.5.2 命中率"></a>7.5.2 命中率</h4><p>由缓存提供服务的请求所占的比例被称为<mark>缓存命中率</mark> (cache hit rate).</p><h4 id="7-5-3-字节命中率"><a href="#7-5-3-字节命中率" class="headerlink" title="7.5.3 字节命中率"></a>7.5.3 字节命中率</h4><p>字节命中率表示的是缓存提供的字节在传输的所有字节中所占的比例。</p><h4 id="7-5-4-区分命中和未命中的情况"><a href="#7-5-4-区分命中和未命中的情况" class="headerlink" title="7.5.4 区分命中和未命中的情况"></a>7.5.4 区分命中和未命中的情况</h4><p>客户端可以通过 <code>Date</code> 首部来判断响应是否来自缓存，将 <code>Date</code> 首部的值与当前时间进行比较，如果响应中的日期值比较早，客户端通常就可以认为这是一条缓存的响应.</p><h3 id="7-6-缓存的拓扑结构"><a href="#7-6-缓存的拓扑结构" class="headerlink" title="7.6 缓存的拓扑结构"></a>7.6 缓存的拓扑结构</h3><p>缓存可以是单个用户专用的，也可以是数千名用户共享的。</p><p>专用缓存被称为<mark>私有缓存</mark> (private cache).</p><p>共享的缓存被称为<mark>公有缓存</mark> (public cache).</p><h4 id="7-6-1-私有缓存"><a href="#7-6-1-私有缓存" class="headerlink" title="7.6.1 私有缓存"></a>7.6.1 私有缓存</h4><p>Web 浏览器中有内建的私有缓存。</p><h4 id="7-6-2-公有代理缓存"><a href="#7-6-2-公有代理缓存" class="headerlink" title="7.6.2 公有代理缓存"></a>7.6.2 公有代理缓存</h4><p>公有缓存是特殊的共享代理服务器, 被称为<mark>缓存代理服务器</mark> (caching proxy server).</p><h4 id="7-6-3-代理缓存的层次结构"><a href="#7-6-3-代理缓存的层次结构" class="headerlink" title="7.6.3 代理缓存的层次结构"></a>7.6.3 代理缓存的层次结构</h4><p><img src="/../img/%E7%BC%93%E5%AD%98%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="缓存层次结构"></p><h4 id="7-6-4-网状缓存-x2F-内容路由以及对等缓存"><a href="#7-6-4-网状缓存-x2F-内容路由以及对等缓存" class="headerlink" title="7.6.4 网状缓存&#x2F;内容路由以及对等缓存"></a>7.6.4 网状缓存&#x2F;内容路由以及对等缓存</h4><p>有些网络结构会构建复杂的<mark>网状缓存</mark> (cache mesh).</p><p>一种代理缓存会决定选择何种路由对内容进行访问、管理和传送，因此可将其称为<mark>内容路由</mark> (content router).</p><p>缓存之间这些更为复杂的关系允许不同的组织互为对等 (peer) 实体，将它们的缓存连接起来以实现共赢。</p><p>提供可选的对等支持的缓存被称为<mark>兄弟缓存</mark> (sibling cache).</p><h3 id="7-7-缓存的处理步骤"><a href="#7-7-缓存的处理步骤" class="headerlink" title="7.7 缓存的处理步骤"></a>7.7 缓存的处理步骤</h3><p>对一条 HTTP GET 报文的基本缓存处理过程包括7个步骤:</p><ol><li>接受</li><li>解析</li><li>查询</li><li>新鲜度检测</li><li>创建响应</li><li>发送</li><li>日志</li></ol><p><img src="/../img/%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%AA%E6%96%B0%E9%B2%9C%E7%9A%84%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD.png" alt="处理一个新鲜的缓存命中"></p><h3 id="7-8-保持副本的新鲜"><a href="#7-8-保持副本的新鲜" class="headerlink" title="7.8 保持副本的新鲜"></a>7.8 保持副本的新鲜</h3><h4 id="7-8-1-文档过期"><a href="#7-8-1-文档过期" class="headerlink" title="7.8.1 文档过期"></a>7.8.1 文档过期</h4><p>通过特殊的 HTTP Cache-Control 首部和 Expires 首部，HTTP 让原始服务器向每个文档附加了一个 “过期日期”. 这些首部说明了在多长时间内可以将这些内容视为新鲜的。</p><p>在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系.</p><h4 id="7-8-2-过期日期和使用期"><a href="#7-8-2-过期日期和使用期" class="headerlink" title="7.8.2 过期日期和使用期"></a>7.8.2 过期日期和使用期</h4><p>Expires 首部使用绝对日期.</p><p>Cache-Control: max-age 首部使用相对时间 (以秒为单位).</p><h4 id="7-8-3-服务器再验证"><a href="#7-8-3-服务器再验证" class="headerlink" title="7.8.3 服务器再验证"></a>7.8.3 服务器再验证</h4><p>已缓存文档过期意味着到了要和服务器进行核对的时间，这种情况被称为 <mark>“服务器再验证”</mark>.</p><h4 id="7-8-4-用条件方法进行再验证"><a href="#7-8-4-用条件方法进行再验证" class="headerlink" title="7.8.4 用条件方法进行再验证"></a>7.8.4 用条件方法进行再验证</h4><p>HTTP 允许缓存向原始服务器发送一个 “条件 GET” , 请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体.</p><p>HTTP 定义了 5 个条件请求首部,对缓存再验证来说最有用的 2 个首部是:</p><ul><li>If-Modified-Since</li><li>If-None-Match</li></ul><p>所有的条件首部都以前缀 “If-“ 开头.j w</p><h4 id="7-8-7-强弱验证器"><a href="#7-8-7-强弱验证器" class="headerlink" title="7.8.7 强弱验证器"></a>7.8.7 强弱验证器</h4><p>实体标签和最近修改日期都是<mark>缓存验证器</mark> (cache validator).</p><p>弱验证器允许对一些内容进行修改.</p><h4 id="7-8-8-什么时候使用实体标签和最近修改日期"><a href="#7-8-8-什么时候使用实体标签和最近修改日期" class="headerlink" title="7.8.8 什么时候使用实体标签和最近修改日期"></a>7.8.8 什么时候使用实体标签和最近修改日期</h4><h3 id="7-9-控制缓存的能力"><a href="#7-9-控制缓存的能力" class="headerlink" title="7.9 控制缓存的能力"></a>7.9 控制缓存的能力</h3><h2 id="第8章-集成点-网关、隧道及中继"><a href="#第8章-集成点-网关、隧道及中继" class="headerlink" title="第8章 集成点: 网关、隧道及中继"></a>第8章 集成点: 网关、隧道及中继</h2><h3 id="8-1-网关"><a href="#8-1-网关" class="headerlink" title="8.1 网关"></a>8.1 网关</h3><p>网关 (gateway) 可以作为某种翻译器使用。</p><p>有些网关会自动将 HTTP 流量转换为其他协议，这样 HTTP 客户端无需了解其他协议，就可以与其他应用程序进行交互了。</p><h4 id="客户端和服务器端网关"><a href="#客户端和服务器端网关" class="headerlink" title="客户端和服务器端网关"></a>客户端和服务器端网关</h4><p>Web 网关在一侧使用 HTTP 协议，在另一侧使用另一种协议.</p><p>可以用一个斜杠来分隔客户端和服务器端协议，并以此对网关进行描述:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">客户端协议</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">服务器端协议</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8-2-协议网关"><a href="#8-2-协议网关" class="headerlink" title="8.2 协议网关"></a>8.2 协议网关</h3><p>将 HTTP 流量导向网关时所使用的的方式与流量导向代理的方式相同。</p><h4 id="8-2-1-HTTP-x2F-服务器端-Web-网关"><a href="#8-2-1-HTTP-x2F-服务器端-Web-网关" class="headerlink" title="8.2.1 HTTP&#x2F;*: 服务器端 Web 网关"></a>8.2.1 HTTP&#x2F;*: 服务器端 Web 网关</h4><p>请求流入原始服务器时，服务器端 Web 网关会将客户端 HTTP 请求转换为其他协议.</p><h4 id="8-2-2-HTTP-x2F-HTTPS-服务器端安全网关"><a href="#8-2-2-HTTP-x2F-HTTPS-服务器端安全网关" class="headerlink" title="8.2.2 HTTP&#x2F;HTTPS: 服务器端安全网关"></a>8.2.2 HTTP&#x2F;HTTPS: 服务器端安全网关</h4><p>一个组织可以通过网关对所有输入 Web 的请求加密，以提供额外的隐私和安全性保护.</p><h4 id="8-2-3-HTTPS-x2F-HTTP-客户端安全加速器网关"><a href="#8-2-3-HTTPS-x2F-HTTP-客户端安全加速器网关" class="headerlink" title="8.2.3 HTTPS&#x2F;HTTP 客户端安全加速器网关"></a>8.2.3 HTTPS&#x2F;HTTP 客户端安全加速器网关</h4><p>它们接受安全的 HTTPS 流量,对安全流量进行解密,并向 Web 服务器发送普通的 HTTP 请求.</p><p>这些网关中通常包含专用的解密硬件.</p><h3 id="8-3-资源网关"><a href="#8-3-资源网关" class="headerlink" title="8.3 资源网关"></a>8.3 资源网关</h3><p>最常见的网关, 应用程序服务器, 会将目标服务器与网关结合在一个服务器中实现.</p><p>CGI (Common Gateway Interface), 通用网关接口, 其为一个标准接口集, Web 服务器可以用它来装载程序以响应对特定 URL 的 HTTP 请求,并收集程序的输出数据,将其放在 HTTP 响应中回送.</p><p>服务器和网关是相互独立的应用程序.</p><h4 id="8-3-1-CGI"><a href="#8-3-1-CGI" class="headerlink" title="8.3.1 CGI"></a>8.3.1 CGI</h4><p>CGI 应用程序是独立于服务器的,几乎可以用任意语言来实现.</p><p>CGI 很简单, 几乎所有的 HTTP 服务器都支持它.</p><p>CGI 应用程序对用户来说是不可见的.</p><h4 id="8-3-2-服务器扩展-API"><a href="#8-3-2-服务器扩展-API" class="headerlink" title="8.3.2 服务器扩展 API"></a>8.3.2 服务器扩展 API</h4><p>CGI 协议为外部翻译器与现有的 HTTP 服务提供了一种简洁的接口方式.</p><p>扩展 API 允许程序员将自己的代码嫁接到服务器上,或者用自己的代码将服务器的一个组件完整地替换出来.</p><h3 id="8-4-应用程序接口和-Web-服务器"><a href="#8-4-应用程序接口和-Web-服务器" class="headerlink" title="8.4 应用程序接口和 Web 服务器"></a>8.4 应用程序接口和 Web 服务器</h3><p>HTTP 可以作为一种连接应用程序的基础软件来使用.</p><p>应用程序之间要配合工作，所要交互的信息比 HTTP 首部所能表达的信息要复杂得多。</p><h3 id="8-5-隧道"><a href="#8-5-隧道" class="headerlink" title="8.5 隧道"></a>8.5 隧道</h3><p>HTTP 的另一种用法 – Web 隧道 (Web tunnel), 这种方式可以通过 HTTP 应用程序访问使用非 HTTP 协议的应用程序。</p><p>Web 隧道允许用户通过 HTTP 链接发送非 HTTP 流量.</p><p>使用 Web 隧道最常见的原因就是要在 HTTP 连接中嵌入非 HTTP 流量，这样，这类流量就可以穿过只允许 Web 流量通过的防火墙了.</p><h4 id="8-5-1-用-CONNECT-建立-HTTP-隧道"><a href="#8-5-1-用-CONNECT-建立-HTTP-隧道" class="headerlink" title="8.5.1 用 CONNECT 建立 HTTP 隧道"></a>8.5.1 用 CONNECT 建立 HTTP 隧道</h4>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机自顶向下方法 Notes</title>
    <link href="/2022/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-Notes/"/>
    <url>/2022/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h1><h2 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1 什么是因特网"></a>1.1 什么是因特网</h2><h3 id="1-1-1-具体构成描述"><a href="#1-1-1-具体构成描述" class="headerlink" title="1.1.1 具体构成描述"></a>1.1.1 具体构成描述</h3><p>所有连接因特网的设备都称为<mark>主机</mark> (host) 或<mark>端系统</mark> (end system).</p><p>端系统通过<mark>通信链路</mark> (communication link) 和分组交换机 (packet switch) 连接到一起。</p><h3 id="1-1-2-服务描述"><a href="#1-1-2-服务描述" class="headerlink" title="1.1.2 服务描述"></a>1.1.2 服务描述</h3><p><mark>分布式应用程序</mark> (distributed application), 其应用程序涉及多个相互交换数据的端系统。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 库 shadowsocks 使用</title>
    <link href="/2022/08/29/Python-%E5%BA%93-shadowsocks-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/29/Python-%E5%BA%93-shadowsocks-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>curl 命令笔记</title>
    <link href="/2022/08/29/curl-%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/29/curl-%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://curl.se/">官网</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>curl 全称为 CommandLine Uniform Resource Locator, 即 CommandLine url. 可用于数据和文件的传输。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>一般语法为:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ curl <span class="hljs-comment">[-参数]</span> <span class="hljs-comment">[URL]</span><br></code></pre></td></tr></table></figure><h2 id="获取一个界面"><a href="#获取一个界面" class="headerlink" title="获取一个界面"></a>获取一个界面</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">curl</span> www.baidu.com<br></code></pre></td></tr></table></figure><p>未指定所用协议，curl 会智能选择。其返回页面的 HTML 代码。</p><h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><h3 id="v-–verbose"><a href="#v-–verbose" class="headerlink" title="-v –verbose"></a>-v –verbose</h3><p>用于跟踪 url 的连接信息。</p><p>返回的信息包含: 域名解释过程，请求头信息 (request)，回应头信息 (response) 等.</p><h3 id="i-–include"><a href="#i-–include" class="headerlink" title="-i –include"></a>-i –include</h3><p>和 <code>-v</code> 选项类似，是其子集。在输出信息中包含 HTTP 头信息。</p><h3 id="I-–head"><a href="#I-–head" class="headerlink" title="-I –head"></a>-I –head</h3><p>和 <code>-v</code> 选项类似，是其子集。只显示返回的头信息。</p><h3 id="u-–user"><a href="#u-–user" class="headerlink" title="-u –user"></a>-u –user</h3><p>带用户验证的连接.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ curl -u username:password https:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/<br></code></pre></td></tr></table></figure><h3 id="d-–data"><a href="#d-–data" class="headerlink" title="-d –data"></a>-d –data</h3><p>带请求参数的连接:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ curl -d <span class="hljs-string">&#x27;user=xiaoruan&amp;age=22&#x27;</span> http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/index.html<br></code></pre></td></tr></table></figure><p>实际为 <code>http://127.0.0.1/index.html?user=xiaoruan&amp;age=22</code></p><h3 id="X-–request"><a href="#X-–request" class="headerlink" title="-X –request"></a>-X –request</h3><p>指定请求方式:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">curl</span> <span class="hljs-literal">-XGET</span> www.baidu.com<br><span class="hljs-variable">$</span> <span class="hljs-built_in">curl</span> <span class="hljs-literal">-XPOST</span> www.baidu.com<br></code></pre></td></tr></table></figure><h3 id="H-–header"><a href="#H-–header" class="headerlink" title="-H –header"></a>-H –header</h3><p>自定义请求头:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -i -H <span class="hljs-string">&#x27;ACCEPT: application/json&#x27;</span> -d <span class="hljs-string">&#x27;name=Foo&amp;status=Bar&#x27;</span> http://localhost:49160/json</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>指定版本 安装 Ruby</title>
    <link href="/2022/08/29/%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC-%E5%AE%89%E8%A3%85-Ruby/"/>
    <url>/2022/08/29/%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC-%E5%AE%89%E8%A3%85-Ruby/</url>
    
    <content type="html"><![CDATA[<p>通过 <code>RVM</code> 安装，RVM 即 Ruby Version Manager, 是 Ruby 版本及安装工具。</p><p>安装 rvm:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ curl -L https:<span class="hljs-regexp">//g</span>et.rvm.io | bash -s stable<br></code></pre></td></tr></table></figure><p>验证 rvm 是否安装正确:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rvm -v<br></code></pre></td></tr></table></figure><p>安装指定版本的 Ruby:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ rvm <span class="hljs-keyword">install</span> <span class="hljs-number">2.0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>查看:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rvm list<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决 curl: (60) ssl certificate problem certificate has expired 问题</title>
    <link href="/2022/08/29/%E8%A7%A3%E5%86%B3-curl-60-ssl-certificate-problem-certificate-has-expired-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/29/%E8%A7%A3%E5%86%B3-curl-60-ssl-certificate-problem-certificate-has-expired-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>根据报错添加 <code>-k</code> 参数即可:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">curl -k</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>本机端口的使用</title>
    <link href="/2022/08/29/%E6%9C%AC%E6%9C%BA%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/29/%E6%9C%AC%E6%9C%BA%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>例如在容器中对外打开 80 端口，其映射到宿主机的 49153 端口，即 <code>0.0.0.0:49153-&gt;80/tcp</code>，那么可以在浏览器使用 <code>localhost:49153/</code> 来打开。</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决在 Docker 中换源后 No system certificates available. Try installing ca-certificates 问题</title>
    <link href="/2022/08/28/%E8%A7%A3%E5%86%B3%E5%9C%A8-Docker-%E4%B8%AD%E6%8D%A2%E6%BA%90%E5%90%8E-No-system-certificates-available-Try-installing-ca-certificates-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/28/%E8%A7%A3%E5%86%B3%E5%9C%A8-Docker-%E4%B8%AD%E6%8D%A2%E6%BA%90%E5%90%8E-No-system-certificates-available-Try-installing-ca-certificates-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 知识点</title>
    <link href="/2022/08/28/Nginx-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/08/28/Nginx-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="同步和异步，阻塞和非阻塞"><a href="#同步和异步，阻塞和非阻塞" class="headerlink" title="同步和异步，阻塞和非阻塞"></a>同步和异步，阻塞和非阻塞</h1><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><ul><li>同步, 当一个同步调用发出去后，调用者要一直等待调用的结果通知后，才能进行后续的执行</li><li>异步，当一个异步调用发出去后，调用者不需要一直等待调用结果的返回，其想要获取调用结果一般采取两种方式<ol><li>主动轮询异步调用结果</li><li>被调用方通过 callback 来通知</li></ol></li></ul><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><ul><li>阻塞，调用在发出后，在消息返回前，当前线&#x2F;进程会被挂起，直到有消息返回，当前线&#x2F;进程才会被激活</li><li>非阻塞，调用在发出去后，不会阻塞当前线&#x2F;进程，而会立即返回</li></ul><h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p>nginx 采用异步非阻塞方式工作。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>当连接有 I&#x2F;O 产生时，epoll 就会告诉进程哪个连接有 I&#x2F;O 事件，然后进程就会去处理这个事件。其让 nginx 有高并发, 即同时处理多个连接.</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>nginx (engine x) 是一个高性能的 HTTP 和反向代理服务器, 同时也提供 IMAP 和 SMTP 服务。其特点是占用内存少，并发能力强。</p><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>两种工作模式.</p><h3 id="master-worker-模式"><a href="#master-worker-模式" class="headerlink" title="master-worker 模式"></a>master-worker 模式</h3><p>有一个 master 进程和至少一个 worker 进程。</p><p>master 进程负责处理系统信号，管理 worker 进程。</p><p>worker 进程负责处理具体的业务逻辑。</p><p>常用于生产环境。</p><h3 id="单进程模式"><a href="#单进程模式" class="headerlink" title="单进程模式"></a>单进程模式</h3><p>只有一个进程.</p><p>方便使用 gdb 等工具进行调试。</p><p>一般用于开发阶段和调试。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>修改 Linux 主机名</title>
    <link href="/2022/08/28/%E4%BF%AE%E6%94%B9-Linux-%E4%B8%BB%E6%9C%BA%E5%90%8D/"/>
    <url>/2022/08/28/%E4%BF%AE%E6%94%B9-Linux-%E4%B8%BB%E6%9C%BA%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>修改 <code>/etc/hostname</code> 文件即可。</p><p>使其立即生效:</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">hostnamectl</span> <span class="hljs-built_in">set-hostname</span> 新的名字<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 supervisor 库</title>
    <link href="/2022/08/28/Python-%E4%B8%AD-supervisor-%E5%BA%93/"/>
    <url>/2022/08/28/Python-%E4%B8%AD-supervisor-%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p><a href="http://supervisord.org/">官网</a><br><a href="https://www.jb51.net/article/235260.htm">参考博客</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>是用 Python 开发的 client&#x2F;server 服务，为 Linux&#x2F;Unix 系统下的进程管理程序.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> supervisor<br></code></pre></td></tr></table></figure><p>安装之后(Ubuntu 22.04)，<code>~/.local/bin</code> 目录下会出现三个程序:</p><ul><li>supervisortd</li><li>supervisorctl</li><li>echo_supervisord_conf, 用于生成初始化配置文件 <code>/etc/supervisord.conf</code></li></ul><h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>其由两个主要组成部分:</p><ul><li>supervisord, 一个守护进程，负责启动所管理的进程，并将所管理的进程作为自己的子程序启动，在所管理的进程出现崩溃时会自动重启</li><li>supervisorctl, 一个命令行管理工具，用于执行 stop, start, restart 等命令</li></ul><h1 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h1><p>调用 <code>echo_supervisord_conf</code> 命令，先添加至 <code>PATH</code> 变量:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<br>vim <span class="hljs-string">.bashrc</span><br></code></pre></td></tr></table></figure><p>添加: <code>export PATH=$PATH:~/.local/bin</code></p><p>因为我们以普通用户操作，执行:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo chown user.<span class="hljs-keyword">user</span> <span class="hljs-title">/etc</span>/supervisord.conf<br></code></pre></td></tr></table></figure><p>开始初始化:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$ echo_supervisord_conf &gt; <span class="hljs-regexp">/etc/</span>supervisord.conf<br></code></pre></td></tr></table></figure><p>因后续权限问题还是把 <code>/etc/supervisord.conf</code> 的所属改为 root.</p><h2 id="使用-include"><a href="#使用-include" class="headerlink" title="使用 include"></a>使用 include</h2><p><code>/etc/supervisord.conf</code> 文件的最后是:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[<span class="hljs-keyword">include</span>]<br>files = relative<span class="hljs-regexp">/directory/</span>*.ini<br></code></pre></td></tr></table></figure><p>其用来为进程写配置文件.</p><p>此时创建一个目录并添加至 <code>[include]</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">mkdir</span> /etc/supervisor ;<span class="hljs-built_in">cd</span> /etc/supervisor</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">touch</span> config.d</span><br></code></pre></td></tr></table></figure><h2 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h2><ul><li>command：启动程序使用的命令，可以是绝对路径或者相对路径</li><li>process_name：一个python字符串表达式，用来表示supervisor进程启动的这个的名称，默认值是%(program_name)s</li><li>numprocs：Supervisor启动这个程序的多个实例，如果numprocs&gt;1，则process_name的表达式必须包含%(process_num)s，默认是1</li><li>numprocs_start：一个int偏移值，当启动实例的时候用来计算numprocs的值</li><li>priority：权重，可以控制程序启动和关闭时的顺序，权重越低：越早启动，越晚关闭。默认值是999</li><li>autostart：如果设置为true，当supervisord启动的时候，进程会自动重启。</li><li>autorestart：值可以是false、true、unexpected。false：进程不会自动重启，unexpected：当程序退出时的退出码不是exitcodes中定义的时，进程会重启，true：进程会无条件重启当退出的时候。</li><li>startsecs：程序启动后等待多长时间后才认为程序启动成功</li><li>startretries：supervisord尝试启动一个程序时尝试的次数。默认是3</li><li>exitcodes：一个预期的退出返回码，默认是0,2。</li><li>stopsignal：当收到stop请求的时候，发送信号给程序，默认是TERM信号，也可以是 HUP, INT, QUIT, KILL, USR1, or USR2。</li><li>stopwaitsecs：在操作系统给supervisord发送SIGCHILD信号时等待的时间</li><li>stopasgroup：如果设置为true，则会使supervisor发送停止信号到整个进程组</li><li>killasgroup：如果设置为true，则在给程序发送SIGKILL信号的时候，会发送到整个进程组，它的子进程也会受到影响。</li><li>user：如果supervisord以root运行，则会使用这个设置用户启动子程序</li><li>redirect_stderr：如果设置为true，进程则会把标准错误输出到supervisord后台的标准输出文件描述符。</li><li>stdout_logfile：把进程的标准输出写入文件中，如果stdout_logfile没有设置或者设置为AUTO，则supervisor会自动选择一个文件位置。</li><li>stdout_logfile_maxbytes：标准输出log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小</li><li>stdout_logfile_backups：标准输出日志轮转备份的数量，默认是10，如果设置为0，则不备份</li><li>stdout_capture_maxbytes：当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB</li><li>stdout_events_enabled：如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发</li><li>stderr_logfile：把进程的错误日志输出一个文件中，除非redirect_stderr参数被设置为true</li><li>stderr_logfile_maxbytes：错误log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小</li><li>stderr_logfile_backups：错误日志轮转备份的数量，默认是10，如果设置为0，则不备份</li><li>stderr_capture_maxbytes：当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB</li><li>stderr_events_enabled：如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发</li><li>environment：一个k&#x2F;v对的list列表</li><li>directory：supervisord在生成子进程的时候会切换到该目录</li><li>umask：设置进程的umask</li><li>serverurl：是否允许子进程和内部的HTTP服务通讯，如果设置为AUTO，supervisor会自动的构造一个url</li></ul><h2 id="配置文件实例"><a href="#配置文件实例" class="headerlink" title="配置文件实例"></a>配置文件实例</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[program:sougou]</span>   <span class="hljs-comment">#souogu 为程序的名称</span><br><span class="hljs-attr">command</span>=scrapy crawl sougou <span class="hljs-comment">#需要执行的命令</span><br><span class="hljs-attr">directory</span>=/home/mzj/桌面/sougou/sougou/wechat_name/wechat_name/spiders  <span class="hljs-comment">#命令执行的目录</span><br><span class="hljs-attr">environment</span>=ASPNETCORE__ENVIRONMENT=Production <span class="hljs-comment">#环境变量</span><br><span class="hljs-attr">user</span>=root <span class="hljs-comment">#用户</span><br><span class="hljs-attr">stopsignal</span>=INT<br><span class="hljs-attr">autostart</span>=<span class="hljs-literal">true</span> <span class="hljs-comment">#是否自启动</span><br><span class="hljs-attr">autorestart</span>=<span class="hljs-literal">true</span> <span class="hljs-comment">#是否自动重启</span><br><span class="hljs-attr">startsecs</span>=<span class="hljs-number">3</span> <span class="hljs-comment">#自动重启时间间隔（s）</span><br><span class="hljs-attr">stderr_logfile</span>=/home/mzj/桌面/sougou/sougou/wechat_name/wechat_name/spiders/oss<span class="hljs-literal">off</span>ical.err.log <span class="hljs-comment">#错误日志文件</span><br><span class="hljs-attr">stdout_logfile</span>=/home/mzj/桌面/sougou/sougou/wechat_name/wechat_name/spiders/oss<span class="hljs-literal">off</span>ical.out.log <span class="hljs-comment">#输出日志文件</span><br></code></pre></td></tr></table></figure><h1 id="使用-web-界面管理"><a href="#使用-web-界面管理" class="headerlink" title="使用 web 界面管理"></a>使用 web 界面管理</h1><p>修改 <code>/etc/supervisord.conf</code> :</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">;[inet_http_server]         ; <span class="hljs-type">inet</span> (tcp) <span class="hljs-keyword">server</span> disabled <span class="hljs-keyword">by</span> <span class="hljs-keyword">default</span><br>;port=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">9001</span>        ; ip_address:port specifier, *:port <span class="hljs-keyword">for</span> <span class="hljs-keyword">all</span> iface<br>;username=<span class="hljs-keyword">user</span>              ; <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> username (<span class="hljs-keyword">open</span> <span class="hljs-keyword">server</span>)<br>;<span class="hljs-keyword">password</span>=<span class="hljs-number">123</span>               ; <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> <span class="hljs-keyword">password</span> (<span class="hljs-keyword">open</span> <span class="hljs-keyword">server</span>)<br></code></pre></td></tr></table></figure><p>去掉注释符号:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[inet_http_server]         ; <span class="hljs-type">inet</span> (tcp) <span class="hljs-keyword">server</span> disabled <span class="hljs-keyword">by</span> <span class="hljs-keyword">default</span><br>port=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">9001</span>        ; ip_address:port specifier, *:port <span class="hljs-keyword">for</span> <span class="hljs-keyword">all</span> iface<br>username=<span class="hljs-keyword">user</span>              ; <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> username (<span class="hljs-keyword">open</span> <span class="hljs-keyword">server</span>)<br><span class="hljs-keyword">password</span>=<span class="hljs-number">123</span>               ; <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> <span class="hljs-keyword">password</span> (<span class="hljs-keyword">open</span> <span class="hljs-keyword">server</span>)<br></code></pre></td></tr></table></figure><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><ul><li>supervisord : 启动supervisor</li><li>supervisorctl reload :修改完配置文件后重新启动supervisor</li><li>supervisorctl status :查看supervisor监管的进程状态</li><li>supervisorctl start 进程名 ：启动XXX进程</li><li>supervisorctl stop 进程名 ：停止XXX进程</li><li>supervisorctl stop all：停止全部进程，注：start、restart、stop都不会载入最新的配置文件。</li><li>supervisorctl update：根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 psutil 库</title>
    <link href="/2022/08/28/Python-%E4%B8%AD-psutil-%E5%BA%93/"/>
    <url>/2022/08/28/Python-%E4%B8%AD-psutil-%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>psutil 是 process and system utilities.</p><p>其实现了 UNIX 命令行的许多功能。可跨平台使用，用于系统监控，性能分析，进程管理。</p><p><a href="https://psutil.readthedocs.io/en/latest">官方文档</a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="获取-CPU-信息"><a href="#获取-CPU-信息" class="headerlink" title="获取 CPU 信息"></a>获取 CPU 信息</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> psutil<br><br></code></pre></td></tr></table></figure><h3 id="获取完整信息"><a href="#获取完整信息" class="headerlink" title="获取完整信息"></a>获取完整信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.cpu_times()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取-CPU-逻辑个数"><a href="#获取-CPU-逻辑个数" class="headerlink" title="获取 CPU 逻辑个数"></a>获取 CPU 逻辑个数</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.cpu_count()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取-CPU-物理个数"><a href="#获取-CPU-物理个数" class="headerlink" title="获取 CPU 物理个数"></a>获取 CPU 物理个数</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import psutil<br><br><span class="hljs-built_in">print</span>(psutil.cpu_count(<span class="hljs-attribute">logical</span>=<span class="hljs-literal">False</span>))<br></code></pre></td></tr></table></figure><h3 id="获取-CPU-使用率"><a href="#获取-CPU-使用率" class="headerlink" title="获取 CPU 使用率"></a>获取 CPU 使用率</h3><p>其有两个参数，前者为 interval, 指定计算 CPU 使用率的时间间隔, 后者 percpu 指定需要总的使用率还是每个 CPU 的使用率:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import psutil<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(10):<br>    <span class="hljs-built_in">print</span>(psutil.cpu_percent(<span class="hljs-attribute">interval</span>=1))<br>    <span class="hljs-built_in">print</span>(psutil.cpu_percent(<span class="hljs-attribute">interval</span>=1, <span class="hljs-attribute">percpu</span>=Ture))<br></code></pre></td></tr></table></figure><h2 id="获取内存信息"><a href="#获取内存信息" class="headerlink" title="获取内存信息"></a>获取内存信息</h2><h3 id="获取内存的使用情况"><a href="#获取内存的使用情况" class="headerlink" title="获取内存的使用情况"></a>获取内存的使用情况</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.virtual_memory()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取系统交换内存的统计信息"><a href="#获取系统交换内存的统计信息" class="headerlink" title="获取系统交换内存的统计信息"></a>获取系统交换内存的统计信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.swap_memory()</span></span>)<br></code></pre></td></tr></table></figure><h2 id="获取磁盘信息"><a href="#获取磁盘信息" class="headerlink" title="获取磁盘信息"></a>获取磁盘信息</h2><h3 id="获取磁盘分区的信息"><a href="#获取磁盘分区的信息" class="headerlink" title="获取磁盘分区的信息"></a>获取磁盘分区的信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.disk_partitions)</span></span><br></code></pre></td></tr></table></figure><h3 id="获取磁盘的使用情况"><a href="#获取磁盘的使用情况" class="headerlink" title="获取磁盘的使用情况"></a>获取磁盘的使用情况</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.disk_usage(<span class="hljs-string">&#x27;/&#x27;</span>)</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取磁盘的-IO-统计信息-读写速度等"><a href="#获取磁盘的-IO-统计信息-读写速度等" class="headerlink" title="获取磁盘的 IO 统计信息(读写速度等)"></a>获取磁盘的 IO 统计信息(读写速度等)</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.disk_io_counters()</span></span>)<br></code></pre></td></tr></table></figure><h2 id="获取网络信息"><a href="#获取网络信息" class="headerlink" title="获取网络信息"></a>获取网络信息</h2><h3 id="获取总的网络-IO-信息"><a href="#获取总的网络-IO-信息" class="headerlink" title="获取总的网络 IO 信息"></a>获取总的网络 IO 信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.net_io_counters()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取网卡的-IO-信息"><a href="#获取网卡的-IO-信息" class="headerlink" title="获取网卡的 IO 信息"></a>获取网卡的 IO 信息</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import psutil<br><br><span class="hljs-built_in">print</span>(psutil.net_io_counters(<span class="hljs-attribute">pernic</span>=Ture))<br></code></pre></td></tr></table></figure><h3 id="获取网络接口信息"><a href="#获取网络接口信息" class="headerlink" title="获取网络接口信息"></a>获取网络接口信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.net_if_addrs()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取网络接口状态信息"><a href="#获取网络接口状态信息" class="headerlink" title="获取网络接口状态信息"></a>获取网络接口状态信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.net_if_stats()</span></span>)<br></code></pre></td></tr></table></figure><h2 id="获取其他系统信息"><a href="#获取其他系统信息" class="headerlink" title="获取其他系统信息"></a>获取其他系统信息</h2><h3 id="获取系统开机的时间"><a href="#获取系统开机的时间" class="headerlink" title="获取系统开机的时间,"></a>获取系统开机的时间,</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.boot_time()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取连接系统的用户列表"><a href="#获取连接系统的用户列表" class="headerlink" title="获取连接系统的用户列表"></a>获取连接系统的用户列表</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.users()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取系统全部的进程信息"><a href="#获取系统全部的进程信息" class="headerlink" title="获取系统全部的进程信息"></a>获取系统全部的进程信息</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.pids()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="获取单个进程的信息，获取指定进程-ID-x3D-100"><a href="#获取单个进程的信息，获取指定进程-ID-x3D-100" class="headerlink" title="获取单个进程的信息，获取指定进程 ID&#x3D;100"></a>获取单个进程的信息，获取指定进程 ID&#x3D;100</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">  import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.Process(<span class="hljs-number">100</span>)</span></span>)<br></code></pre></td></tr></table></figure><h2 id="模拟-ps-命令效果"><a href="#模拟-ps-命令效果" class="headerlink" title="模拟 ps 命令效果"></a>模拟 ps 命令效果</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import psutil<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(psutil.test()</span></span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 Chrome 浏览器将 markdown preview 输出为 PDF 文件</title>
    <link href="/2022/08/28/%E4%BD%BF%E7%94%A8-Chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%86-markdown-preview-%E8%BE%93%E5%87%BA%E4%B8%BA-PDF-%E6%96%87%E4%BB%B6/"/>
    <url>/2022/08/28/%E4%BD%BF%E7%94%A8-Chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%86-markdown-preview-%E8%BE%93%E5%87%BA%E4%B8%BA-PDF-%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>进入 Chrome 浏览器，点击右键找到 <code>print</code> .</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 语言规范</title>
    <link href="/2022/08/28/Python-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/"/>
    <url>/2022/08/28/Python-%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-语言规范"><a href="#Python-语言规范" class="headerlink" title="Python 语言规范"></a>Python 语言规范</h1><h2 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h2><h3 id="使用-pylint-工具"><a href="#使用-pylint-工具" class="headerlink" title="使用 pylint 工具"></a>使用 pylint 工具</h3><p>pylint 是一个在 Python 源代码中查找 bug 的工具。</p><p>可以使用 <code>pylint --list-msgs</code> 来获取 pylint 警告列表。</p><p>使用 <code>pylink --help-msg=C6409</code> 获取关于特定消息的更多信息.</p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>仅对包和模块进行导入，而不单独导入函数或者类。</p><p>使用 <code>from x import y as z</code> 当模块太长。</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>使用模块的全路径名来导入每个模块。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><code>ValueError</code> 指示一个程序错误。</p><p><code>assert</code> 保证内部的正确性。</p><p><code>raise</code> 语句，指示意外情况。</p><p>减少 <code>try/except</code> 块中的代码量。</p><p>使用 <code>finally</code> 子句来执行那些无论 try 块中有没有异常都应该被执行的代码。</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>避免全局变量。</p><p>鼓励使用模块级的常量如 <code>MAX_HOLY_HANDGRENADE_COUT = 3</code>，命名全用大写且用 <code>_</code> 分隔。</p><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><p>适用于单行函数。</p><p>又名三元运算符，是对于 if 语句的一种更简短的句法规则:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> if cond else <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搭建梯子的原理</title>
    <link href="/2022/08/28/%E6%90%AD%E5%BB%BA%E6%A2%AF%E5%AD%90%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2022/08/28/%E6%90%AD%E5%BB%BA%E6%A2%AF%E5%AD%90%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><a href="www.120cctv.cn/1494.html">参考博客</a></p><h1 id="什么是-GFW"><a href="#什么是-GFW" class="headerlink" title="什么是 GFW"></a>什么是 GFW</h1><h2 id="GFW-是-Great-Firewall-的简称，即中国防火墙，会屏蔽一些域名。"><a href="#GFW-是-Great-Firewall-的简称，即中国防火墙，会屏蔽一些域名。" class="headerlink" title="GFW 是 Great Firewall 的简称，即中国防火墙，会屏蔽一些域名。"></a>GFW 是 Great Firewall 的简称，即中国防火墙，会屏蔽一些域名。</h2><p><a href="https://b23.tv/NCShBzN">参考</a></p><h1 id="VPN-概念，技术原理和误区"><a href="#VPN-概念，技术原理和误区" class="headerlink" title="VPN 概念，技术原理和误区"></a>VPN 概念，技术原理和误区</h1><p>HTTP 协议比较大的缺点就是明文，其并没有对数据进行加密.</p><p>VPN 是 Virtual Private Network, 虚拟专用网络.</p><p>公司所要发送的数据都要经过 VPN 集线器加密.</p><p>VPN 有很多类型:</p><h2 id="VPN-类型"><a href="#VPN-类型" class="headerlink" title="VPN 类型"></a>VPN 类型</h2><h3 id="站点-–-站点"><a href="#站点-–-站点" class="headerlink" title="站点 – 站点"></a>站点 – 站点</h3><p>多用在同一个公司，但不同地点的内部网. 也可以用在不同公司的外部网.</p><p>站点对站点意味着两端或者多端的地点相对固定。</p><p>这时，数据包上的源地址会被更改为当前 VPN 集线器的地址，目标地址会被更改为目的 VPN 集线器的地址. 这样就隐藏了实际原地址和实际目标地址.</p><h3 id="客户端-–-站点"><a href="#客户端-–-站点" class="headerlink" title="客户端 – 站点"></a>客户端 – 站点</h3><p>客户端 – 站点 VPN，也可以称为远程登录 VPN, 其适合居家办公的情景.</p><p>一般来说，这种类型的 VPN 可以用浏览器直接通信. 也可以另外安装客户端软件来进行 VPN 通信.</p><p>这种类型也分为:</p><ul><li>全隧道, 即所有的网络数据都走公司网</li><li>半隧道</li></ul><h2 id="VPN-职责"><a href="#VPN-职责" class="headerlink" title="VPN 职责"></a>VPN 职责</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>常用算法为 AES 和 3DES, 这里的 E 代表 Encryption.</p><h3 id="保护数据完整性"><a href="#保护数据完整性" class="headerlink" title="保护数据完整性"></a>保护数据完整性</h3><p>使用 Hash, 使用算法根据字符串生成唯一的 Hash 值.</p><p>常用算法为 MD5 和 SHA.</p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>常见使用的算法有 PSK 和 RSA.</p><h2 id="VPN-的框架"><a href="#VPN-的框架" class="headerlink" title="VPN 的框架"></a>VPN 的框架</h2><p>主要运用了两个协议:</p><ul><li>IPsec, IP Security, 位于网络层，其既可以用在 “客户端 – 站点” VPN, 也可以用在 “站点 – 站点” VPN</li><li>SSL&#x2F;TLS, 位于表示层,  这里位于后面的 S 都是 Security 的含义</li></ul>]]></content>
    
    
    <categories>
      
      <category>CNSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CNSS 夏令营网站习题总结</title>
    <link href="/2022/08/28/CNSS-%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BD%91%E7%AB%99%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2022/08/28/CNSS-%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BD%91%E7%AB%99%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="运行-Neofetch"><a href="#运行-Neofetch" class="headerlink" title="运行 Neofetch"></a>运行 Neofetch</h1><p>Neofetch 用于漂亮的显示系统 logo 和一些系统信息.</p><p>安装 Neofetch:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt -yqq <span class="hljs-keyword">install</span> neofetch<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CNSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 下处理图片</title>
    <link href="/2022/08/28/Ubuntu-%E4%B8%8B%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87/"/>
    <url>/2022/08/28/Ubuntu-%E4%B8%8B%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>需要用到 <code>file</code> 命令和 <code>convert</code> 命令，若没有 <code>convert</code> 命令:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> graphicsmagick-imagemagick-compat<br></code></pre></td></tr></table></figure><h1 id="使用-file-命令"><a href="#使用-file-命令" class="headerlink" title="使用 file 命令"></a>使用 <code>file</code> 命令</h1><p>其作用为查看图片参数:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> <span class="hljs-keyword">file</span> helloc.png<br></code></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">helloc</span>.png: PNG image data, <span class="hljs-number">976</span> x <span class="hljs-number">1064</span>, <span class="hljs-number">8</span>-bit/color RGBA, non-interlaced<br></code></pre></td></tr></table></figure><h1 id="使用-convert-命令"><a href="#使用-convert-命令" class="headerlink" title="使用 convert 命令"></a>使用 <code>convert</code> 命令</h1><p>使用 <code>-crop</code> 参数的格式为:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>convert <span class="hljs-variable">$&#123;</span>SOURCE_IMG&#125; -crop <span class="hljs-variable">$&#123;</span>HIGHT&#125;x<span class="hljs-variable">$&#123;</span>WIDTH&#125;+<span class="hljs-variable">$&#123;</span>LEFT_TOP_X&#125;+<span class="hljs-variable">$&#123;</span>LEFT_TOP_Y&#125; <span class="hljs-variable">$&#123;</span>TARGET_IMG&#125;<br></code></pre></td></tr></table></figure><p>前面的 <code>$&#123;HIGHT&#125;x$&#123;WIDTH&#125;</code> 为目标的大小，<code>$&#123;LEFT_TOP_X&#125;</code> 为开始裁剪的宽度，<code>$&#123;LEFT_TOP_Y&#125;</code> 为开始裁剪的高度。也就是从左上角开始数的位置.</p>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 time 库</title>
    <link href="/2022/08/27/Python-%E4%B8%AD-time-%E5%BA%93/"/>
    <url>/2022/08/27/Python-%E4%B8%AD-time-%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>time 库是 Python 中处理时间的标准库。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul><li>获取系统时间，并格式化输出</li><li>计时，方便分析程序的性能</li></ul><h1 id="time-函数"><a href="#time-函数" class="headerlink" title="time() 函数"></a>time() 函数</h1><p>用于获取从1970年1月1日00：00：00开始，到现在的总秒数，也被称为计算机内部时间.</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dos">import <span class="hljs-built_in">time</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">time</span>.<span class="hljs-built_in">time</span>())<br></code></pre></td></tr></table></figure><h1 id="localtime-函数和-gmtime-函数"><a href="#localtime-函数和-gmtime-函数" class="headerlink" title="localtime() 函数和 gmtime() 函数"></a>localtime() 函数和 gmtime() 函数</h1><p>都可返回以元组表示的时间对象.</p><p>localtime() 返回当地时间。</p><p>gmtime() 返回世界统一时间。</p><p>两者的默认参数为 <code>time.time()</code> 的返回值. 接受一个浮点数，表示秒。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import <span class="hljs-selector-tag">time</span><br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(time.localtime()</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(time.gmtime()</span></span>)<br></code></pre></td></tr></table></figure><h1 id="ctime-函数"><a href="#ctime-函数" class="headerlink" title="ctime() 函数"></a>ctime() 函数</h1><p>其会读取当前时间并以易读的格式表示，返回字符串, 默认参数为 <code>time.time()</code> 的返回值:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import <span class="hljs-selector-tag">time</span><br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(time.ctime()</span></span>)<br></code></pre></td></tr></table></figure><h1 id="strftime-函数"><a href="#strftime-函数" class="headerlink" title="strftime() 函数"></a>strftime() 函数</h1><p>以字符串形式格式化输出时间, 接受两个参数，前者为格式，后者为时间对象:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">import <span class="hljs-keyword">time</span> <br><br>t = time.localtime()<br><span class="hljs-keyword">print</span>(time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H: %M: %S&quot;</span>, t))<br></code></pre></td></tr></table></figure><p>其格式有:</p><ul><li><code>%Y</code></li><li><code>%m</code></li><li><code>%d</code></li><li><code>%B</code>, 完整月份名</li><li><code>%b</code>, 简化</li><li><code>%A</code>, 完整星期名</li><li><code>%a</code>, 简化</li><li><code>%H</code></li><li><code>%I</code>, 12 小时制</li><li><code>%p</code>, 上下午</li><li><code>%M</code></li><li><code>%S</code></li></ul><h1 id="perf-counter"><a href="#perf-counter" class="headerlink" title="perf_counter()"></a>perf_counter()</h1><p>记录 CPU 运行时间，返回值以秒为单位.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> <span class="hljs-type">time</span><br><br>start = <span class="hljs-type">time</span>.perf_counter()<br>end = <span class="hljs-type">time</span>.perf_counter()<br>print(<span class="hljs-keyword">start</span>)<br>print(<span class="hljs-keyword">end</span>)<br>print(<span class="hljs-keyword">end</span>-<span class="hljs-keyword">start</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 format 函数用法</title>
    <link href="/2022/08/27/Python-%E4%B8%AD-format-%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <url>/2022/08/27/Python-%E4%B8%AD-format-%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="通过-index-即位置"><a href="#通过-index-即位置" class="headerlink" title="通过 index 即位置"></a>通过 index 即位置</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;This is a &#123;0&#125; about &#123;1&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;example&#x27;</span>, <span class="hljs-string">&#x27;format&#x27;</span>))<br>This <span class="hljs-keyword">is</span> a example about <span class="hljs-built_in">format</span><br></code></pre></td></tr></table></figure><p>另一个例子:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&gt;&gt;&gt; print(<span class="hljs-string">&#x27;&#123;0&#125; two three three two &#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;one&#x27;</span>))<br><span class="hljs-literal">one</span> <span class="hljs-literal">two</span> <span class="hljs-literal">three</span> <span class="hljs-literal">three</span> <span class="hljs-literal">two</span> <span class="hljs-literal">one</span><br></code></pre></td></tr></table></figure><p>若不输入数字，则按顺序填充。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&gt;&gt;&gt; print(<span class="hljs-string">&#x27;&#123;&#125; two three three two &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>))<br><span class="hljs-literal">one</span> <span class="hljs-literal">two</span> <span class="hljs-literal">three</span> <span class="hljs-literal">three</span> <span class="hljs-literal">two</span> <span class="hljs-literal">one</span><br></code></pre></td></tr></table></figure><h1 id="通过-keys-关键词"><a href="#通过-keys-关键词" class="headerlink" title="通过 keys 关键词"></a>通过 keys 关键词</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;My name is &#123;name&#125;, a &#123;identity&#125;&#x27;</span>.format(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Jie&#x27;</span>, <span class="hljs-attribute">identity</span>=<span class="hljs-string">&#x27;student&#x27;</span>))<br></code></pre></td></tr></table></figure><h1 id="通过下标"><a href="#通过下标" class="headerlink" title="通过下标"></a>通过下标</h1><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">data = [<span class="hljs-string">&#x27;Jie&#x27;</span>, <span class="hljs-string">&#x27;student&#x27;</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;My name is &#123;0[0]&#125;, a &#123;0[0]&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(data))</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 安装 Google 浏览器</title>
    <link href="/2022/08/27/Ubuntu-%E5%AE%89%E8%A3%85-Google-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <url>/2022/08/27/Ubuntu-%E5%AE%89%E8%A3%85-Google-%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>通过源代码安装，进入 <code>https://www.google.cn/chrome/</code> 下载 <code>.deb</code> 包.</p><p>然后:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/Downloads</span><br>sudo dpkg -i google-chrome-stable_current_amd64.deb<br></code></pre></td></tr></table></figure><p>从命令行打开 Google 浏览器:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">google-chrome</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装 Python 库 psycopg2 报错</title>
    <link href="/2022/08/27/%E5%AE%89%E8%A3%85-Python-%E5%BA%93-psycopg2-%E6%8A%A5%E9%94%99/"/>
    <url>/2022/08/27/%E5%AE%89%E8%A3%85-Python-%E5%BA%93-psycopg2-%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>报错内容为:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts">.<span class="hljs-keyword">/psycopg/</span>psycopg.h:<span class="hljs-number">36</span>:<span class="hljs-number">10</span>: fatal error: libpq-fe.h: No such file or directory<br>         <span class="hljs-number">36</span> | <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libpq-fe.h&gt;</span></span><br>            |          ^~~~~~~~~~~~<br>      compilation terminated.<br></code></pre></td></tr></table></figure><p>因此安装依赖:</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install libpq-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>然后重新安装:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> psycopg2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 3 连接 PostgreSQL 数据库</title>
    <link href="/2022/08/27/Python-3-%E8%BF%9E%E6%8E%A5-PostgreSQL-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/08/27/Python-3-%E8%BF%9E%E6%8E%A5-PostgreSQL-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p><a href="https://pypi.org/project/psycopg2/">相关文档</a><br>使用 psycopg2 库。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Psycopg2 在 C 中作为 libpg 包装器实现的。其兼容 Unicode 和 Python3.</p><h1 id="Basic-module-usage"><a href="#Basic-module-usage" class="headerlink" title="Basic module usage"></a>Basic module usage</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> psycopg2<br><br>conn = psycopg2.<span class="hljs-keyword">connect</span>(&quot;dbname=test user=postgres&quot;)<br>cur = conn.<span class="hljs-keyword">cursor</span><br>cur.<span class="hljs-keyword">execute</span>(&quot;CREATE TABLE test (id serial PRIMARY KEY, num integer, data varchar);&quot;)<br>cur.<span class="hljs-keyword">execute</span>(&quot;INSERT INTO test (num, data) VALUES (%s, %s)&quot;, (<span class="hljs-number">100</span>, &quot;abc&#x27;def&quot;))<br>cur.<span class="hljs-keyword">execute</span>(&quot;SELECT * FROM test;&quot;)<br>cur.fetchone()<br>conn.<span class="hljs-keyword">commit</span>()<br>cur.<span class="hljs-keyword">close</span>()<br>conn.<span class="hljs-keyword">close</span>()<br></code></pre></td></tr></table></figure><p><code>connect()</code> 方法能够创建一个 session, 然后返回一个 connection instance.</p><p><code>connect()</code> 方法的参数:</p><ul><li>dbname, 数据库名称</li><li>database, 同样是数据库名称</li><li>user，用于验证的用户名</li><li>password, 密码</li><li>host, 主机地址</li><li>port, 连接的端口号</li></ul><p>使用类似于 <code>connect(host=&#39;localhost&#39;, database=&quot;test&quot;, user=&quot;postgres&quot;)</code></p><p><code>connection</code> 是一个类，其 <code>cursor()</code> 方法创建一个 cursor instance, 其可用来执行数据库命令和查询。如使用 <code>execute()</code> 或 <code>executemany</code> 方法来执行命令， 用 <code>fetchmany()</code> 或 <code>fetchall()</code> 或 <code>fetchone()</code> 方法来 retrieve data from database。</p><p><code>commit()</code> 和 <code>rollback()</code> 方法用于停止一个 transactions.</p><h1 id="Passing-parameters-to-SQL-queries"><a href="#Passing-parameters-to-SQL-queries" class="headerlink" title="Passing parameters to SQL queries"></a>Passing parameters to SQL queries</h1><p>使用 <code>execute()</code> 方法与 <code>%s</code>:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">cur.execute(<span class="hljs-string">&quot;&quot;&quot;</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">    INSERT INTO some_table (an_int, a_date, a_string)</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">    VALUES (%s, %s, %s);</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">    &quot;&quot;&quot;</span>,</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    (<span class="hljs-number">10</span>, datetime.date(<span class="hljs-number">2005</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>), <span class="hljs-string">&quot;O&#x27;Reilly&quot;</span>))</span><br></code></pre></td></tr></table></figure><p>可以使用 named arguments <code>%(name)s</code>, 其顺序可以和 <code>VALUES</code> 不同，且可被重复使用:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">cur.execute(<span class="hljs-string">&quot;&quot;&quot;</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">    INSERT INTO some_table (an_int, a_date, a_string)</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">    VALUES (%(int)s, %(date)s, %(date)s, %(str)s);</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">    &quot;&quot;&quot;</span>,</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    &#123;<span class="hljs-string">&#x27;int&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;str&#x27;</span>: <span class="hljs-string">&quot;O&#x27;Reilly&quot;</span>, <span class="hljs-string">&#x27;date&#x27;</span>: datetime.date(<span class="hljs-number">2005</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>)&#125;)</span><br></code></pre></td></tr></table></figure><p>这里的 <code>date</code> 就被使用了两次。且这里用的是字典。</p><p>表示 <code>%</code> 需要使用 <code>%%</code>:</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure"><span class="hljs-string">&quot;SELECT (%s %% 2) = 0 AS even&quot;</span><span class="hljs-punctuation">,</span> (<span class="hljs-number">10</span><span class="hljs-punctuation">,</span>)<br></code></pre></td></tr></table></figure><p>注意第二个参数必须为 sequence, 因此要写为 <code>(10,)</code> 或 <code>[10]</code></p><p>这里的 placeholder 必须是 <code>%s</code> 而不能是其他。</p><p>若需要动态查询，需要:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cur<span class="hljs-selector-class">.execute</span>(<br>    <span class="hljs-built_in">SQL</span>(<span class="hljs-string">&quot;INSERT INTO &#123;&#125; VALUES (%s)&quot;</span>)<span class="hljs-selector-class">.format</span>(<span class="hljs-built_in">Identifier</span>(<span class="hljs-string">&#x27;number&#x27;</span>)),<br>    (<span class="hljs-number">10</span>,))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 必知必会 Notes</title>
    <link href="/2022/08/27/MySQL-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-Notes/"/>
    <url>/2022/08/27/MySQL-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-Notes/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 with open 用法</title>
    <link href="/2022/08/27/Python-%E4%B8%AD-with-open-%E7%94%A8%E6%B3%95/"/>
    <url>/2022/08/27/Python-%E4%B8%AD-with-open-%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>open() 的几个 mode:</p><ul><li>‘r’</li><li>‘w’</li><li>‘a’</li><li>‘r+’</li></ul><h1 id="使用-with-关键词"><a href="#使用-with-关键词" class="headerlink" title="使用 with 关键词"></a>使用 with 关键词</h1><p>使用 with 可以不用担心 file.close() 问题。其在使用完毕后会自动关闭文件。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">with</span> open(&#x27;filename&#x27;, &#x27;mode&#x27;) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-class"><span class="hljs-keyword">data</span> = f.read()</span><br>    print(<span class="hljs-class"><span class="hljs-keyword">data</span>)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 编程从认知到实践</title>
    <link href="/2022/08/26/Python-%E7%BC%96%E7%A8%8B%E4%BB%8E%E8%AE%A4%E7%9F%A5%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/08/26/Python-%E7%BC%96%E7%A8%8B%E4%BB%8E%E8%AE%A4%E7%9F%A5%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="第8章-读写文件"><a href="#第8章-读写文件" class="headerlink" title="第8章 读写文件"></a>第8章 读写文件</h1><h2 id="8-1-文件与文件路径"><a href="#8-1-文件与文件路径" class="headerlink" title="8.1 文件与文件路径"></a>8.1 文件与文件路径</h2><h3 id="8-1-1-Windows-上的倒斜杠以及-OS-X-和-Linux-上的正斜杠"><a href="#8-1-1-Windows-上的倒斜杠以及-OS-X-和-Linux-上的正斜杠" class="headerlink" title="8.1.1 Windows 上的倒斜杠以及 OS X 和 Linux 上的正斜杠"></a>8.1.1 Windows 上的倒斜杠以及 OS X 和 Linux 上的正斜杠</h3><p>如果想程序运行在所有操作系统上，在编写 Python 脚本时，就必须处理这两种情况。</p><h3 id="8-1-3-绝对路径与相对路径"><a href="#8-1-3-绝对路径与相对路径" class="headerlink" title="8.1.3 绝对路径与相对路径"></a>8.1.3 绝对路径与相对路径</h3><h2 id="8-2-文件读写过程"><a href="#8-2-文件读写过程" class="headerlink" title="8.2 文件读写过程"></a>8.2 文件读写过程</h2><p>在 Python 中，读写文件有 3 个步骤:</p><ol><li>调用 open() 函数，返回一个 File 对象</li><li>调用 File 对象的 read() 或 write() 方法</li><li>调用 File 对象的 close() 方法，关闭该文件</li></ol><h3 id="8-2-1-用-open-函数打开文件"><a href="#8-2-1-用-open-函数打开文件" class="headerlink" title="8.2.1 用 open() 函数打开文件"></a>8.2.1 用 open() 函数打开文件</h3><p>第一个参数是路径，第二个参数是模式.</p><h3 id="8-2-2-读取文件内容"><a href="#8-2-2-读取文件内容" class="headerlink" title="8.2.2 读取文件内容"></a>8.2.2 读取文件内容</h3><p>用 read() 函数。</p><p>用 readlines() 方法，可以取得一个列表，其元素是一个字符串，即文本中的一行.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">sonnetFile = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;sonnet29.txt&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">sonnetFile.readline()</span><br></code></pre></td></tr></table></figure><h3 id="8-2-3-写入文件"><a href="#8-2-3-写入文件" class="headerlink" title="8.2.3 写入文件"></a>8.2.3 写入文件</h3><p>写模式为 ‘w’, 添加模式为 ‘a’.</p><h2 id="8-3-用-shelve-模块保存变量"><a href="#8-3-用-shelve-模块保存变量" class="headerlink" title="8.3 用 shelve 模块保存变量"></a>8.3 用 shelve 模块保存变量</h2><p>利用 shelve 模块，可以将 Python 程序中的变量保存到二进制的 shelf 文件中:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import shelve<br><br>shelfFile = shelve<span class="hljs-selector-class">.open</span>(<span class="hljs-string">&#x27;mydata&#x27;</span>)<br>cats = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Zophie&#x27;</span>, <span class="hljs-string">&#x27;Pooka&#x27;</span>, <span class="hljs-string">&#x27;Simon&#x27;</span>]</span><br>shelfFile<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;cats&#x27;</span>]</span> = cats<br>shelfFile<span class="hljs-selector-class">.close</span>()<br></code></pre></td></tr></table></figure><p>调用 shelve.open() 并传入一个文件名，然后将返回的值保存在一个变量中，可以像字典一样操作这个变量，完成时需要调用 close().</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 os 库</title>
    <link href="/2022/08/26/Python-%E4%B8%AD-os-%E5%BA%93/"/>
    <url>/2022/08/26/Python-%E4%B8%AD-os-%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="getcwd"><a href="#getcwd" class="headerlink" title="getcwd()"></a>getcwd()</h2><p>获取当前工作路径。</p><h2 id="listdir-path"><a href="#listdir-path" class="headerlink" title="listdir(path)"></a>listdir(path)</h2><p>返回 <code>path</code> 下的文件和目录组成的列表，类似 Linux 命令 <code>ls</code></p><h2 id="walk-path"><a href="#walk-path" class="headerlink" title="walk(path)"></a>walk(path)</h2><p>遍历指定 <code>path</code> 下的所有目录，返回由路径、文件夹、文件 三个列表组成的元组。</p><h2 id="path-exists-path"><a href="#path-exists-path" class="headerlink" title="path.exists(path)"></a>path.exists(path)</h2><p>判断路径下的目录是否存在，存在返回 Ture.</p><h2 id="mkdir-path"><a href="#mkdir-path" class="headerlink" title="mkdir(path)"></a>mkdir(path)</h2><p>创建一个目录。</p><h2 id="makedirs-path"><a href="#makedirs-path" class="headerlink" title="makedirs(path)"></a>makedirs(path)</h2><p>创建递归目录。</p><h2 id="rmdir-path"><a href="#rmdir-path" class="headerlink" title="rmdir(path)"></a>rmdir(path)</h2><p>删除目录.</p><h2 id="path-join-path1-path2"><a href="#path-join-path1-path2" class="headerlink" title="path.join(path1, path2)"></a>path.join(path1, path2)</h2><p>将两个路径拼接。其会包含正确的路径分隔符.</p><h2 id="path-split-path"><a href="#path-split-path" class="headerlink" title="path.split(path)"></a>path.split(path)</h2><p>将路径拆分为:</p><ul><li>绝对路径, 除文件名部分</li><li>文件名<br>返回元组.</li></ul><h2 id="path-dirname-path"><a href="#path-dirname-path" class="headerlink" title="path.dirname(path)"></a>path.dirname(path)</h2><p>获取文件的绝对路径。</p><h2 id="path-basename-path"><a href="#path-basename-path" class="headerlink" title="path.basename(path)"></a>path.basename(path)</h2><p>只获取文件名.</p><h2 id="path-isdir-path"><a href="#path-isdir-path" class="headerlink" title="path.isdir(path)"></a>path.isdir(path)</h2><p>判断是否是目录。</p><h2 id="path-isfile-path"><a href="#path-isfile-path" class="headerlink" title="path.isfile(path)"></a>path.isfile(path)</h2><p>判断是否为文件。</p><h2 id="path-sep"><a href="#path-sep" class="headerlink" title="path.sep"></a>path.sep</h2><p>返回当前操作系统的路径分隔符。</p><h2 id="path-getsize-path"><a href="#path-getsize-path" class="headerlink" title="path.getsize(path)"></a>path.getsize(path)</h2><p>返回文件大小.</p><h2 id="path-abspath-path"><a href="#path-abspath-path" class="headerlink" title="path.abspath(path)"></a>path.abspath(path)</h2><p>返回参数的绝对路径的字符串。</p><h2 id="path-isabs-path"><a href="#path-isabs-path" class="headerlink" title="path.isabs(path)"></a>path.isabs(path)</h2><p>如果参数是一个绝对路径，就返回 Ture.</p><h2 id="path-relpath-path-start"><a href="#path-relpath-path-start" class="headerlink" title="path.relpath(path, start)"></a>path.relpath(path, start)</h2><p>返回从 start 路径到 path 的相对路径的字符串，若未指定 start, 就使用当前工作目录.</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 multiprocessing 库使用</title>
    <link href="/2022/08/26/Python-%E4%B8%AD-multiprocessing-%E5%BA%93%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/26/Python-%E4%B8%AD-multiprocessing-%E5%BA%93%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>爬虫时单线程比较慢，使用 <code>multiprocessing</code> 库可以实现多进程.</p><p>常用组件:</p><h1 id="Process-类"><a href="#Process-类" class="headerlink" title="Process 类"></a>Process 类</h1><p>Process 类用于创建进程对象，需传入</p><ul><li>需要执行的函数, 传给 <code>target</code> </li><li>函数的参数, 传给 <code>args</code></li></ul><p>创建好一个 Process 实例后可以使用 <code>start()</code> 方法启动。</p><p>语法:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">Process([<span class="hljs-params">group</span>], [<span class="hljs-params">target</span>], [<span class="hljs-params">name</span>], [<span class="hljs-params">args</span>], [<span class="hljs-params">kwargs</span>])</span><br></code></pre></td></tr></table></figure><p>其中:</p><ul><li>group, 指定进程组</li><li>target, 传递函数</li><li>name，指定进程名字</li><li>args, 以元组的方式传递参数</li><li>kwargs, 以字典的方式给 target 指定的函数传递参数</li></ul><p>常用方法:</p><ul><li>start(), 启动实例</li><li>is_alive(), 判断进程是否还存在</li><li>join([timeout]), 是否等待进程执行结束，或等待多少秒</li><li>terminate(), 终止子进程</li></ul><p>常用属性:</p><ul><li>name, 进程别名</li><li>pid, 进程号</li></ul><h1 id="进程池-Pool-和-map"><a href="#进程池-Pool-和-map" class="headerlink" title="进程池 Pool() 和 map()"></a>进程池 Pool() 和 map()</h1><p>Processing Pool, 用于创建多个进程.</p><p> 定义一个 Pool:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import multiprocessing<br><br><span class="hljs-attribute">pool</span> <span class="hljs-operator">=</span> multiprocessing.Pool<br></code></pre></td></tr></table></figure><p>此时 <code>pool</code> 为一个 Processing pool，其会根据当前运行环境来决定运行多少个进程，并把每次调用分别变成一个进程，例如 CPU 有 8 个核, 那么进程池的大小就会默认设置为 8.</p><p>利用 <code>map()</code> 方法，向 Processing pool 中传递函数和参数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">result = pool.<span class="hljs-keyword">map</span>(<span class="hljs-function"><span class="hljs-keyword">func</span>, <span class="hljs-title">range</span><span class="hljs-params">(10)</span></span>)<br></code></pre></td></tr></table></figure><p>这里的参数应该是一个列表，包含每一次调用所需要的参数。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 就该这么学</title>
    <link href="/2022/08/26/Linux-%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6/"/>
    <url>/2022/08/26/Linux-%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="第10章-使用-Apache-服务部署静态网站"><a href="#第10章-使用-Apache-服务部署静态网站" class="headerlink" title="第10章 使用 Apache  服务部署静态网站"></a>第10章 使用 Apache  服务部署静态网站</h1><h2 id="10-1-网站服务程序"><a href="#10-1-网站服务程序" class="headerlink" title="10.1 网站服务程序"></a>10.1 网站服务程序</h2><p>安装 apache 服务程序:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> apache2<br></code></pre></td></tr></table></figure><p>默认界面的地址为 <code>http;//127.0.0.1</code></p><h2 id="10-2-配置服务文件参数"><a href="#10-2-配置服务文件参数" class="headerlink" title="10.2 配置服务文件参数"></a>10.2 配置服务文件参数</h2><h1 id="第13章-使用-BIND-提供域名解析服务"><a href="#第13章-使用-BIND-提供域名解析服务" class="headerlink" title="第13章 使用 BIND 提供域名解析服务"></a>第13章 使用 BIND 提供域名解析服务</h1><h2 id="13-1-DNS-域名解析服务"><a href="#13-1-DNS-域名解析服务" class="headerlink" title="13.1 DNS 域名解析服务"></a>13.1 DNS 域名解析服务</h2><p>DNS，即 Domian Name System. 用于管理和解析域名与 IP 地址对应关系的技术.</p><p>将域名解析为 IP 地址，即正向解析。将 IP 地址解析为域名，即反向解析.</p><p>域名后缀一般分为:</p><ul><li>国际域名</li><li>国内域名<br>常见域名有:</li><li>.com : 商业组织</li><li>.org : 非营利组织</li><li>.gov : 政府部门</li><li>.net : 网络服务商</li><li>.edu : 教育机构</li><li>.pub : 公共大众</li><li>.cn : 中国国家顶级域名</li></ul><h2 id="13-2-安装-bind-服务程序"><a href="#13-2-安装-bind-服务程序" class="headerlink" title="13.2 安装 bind 服务程序"></a>13.2 安装 bind 服务程序</h2><p>BIND (Berkeley Internet Name Domain, 伯克利因特网名称域) 服务是全球范围内使用最广泛、最安全可靠且高效的域名解析服务程序. 可加上 chroot (牢笼机制) 扩展包，以便有效地限制 bind 服务程序仅能对自身的配置文件进行操作，以确保整个服务器的安全。</p><p>bind 服务程序下有三个比较关键的文件:</p><ul><li>主配置文件 (&#x2F;etc&#x2F;named.conf) :其参数用来定义 bind 服务程序的运行</li><li>区域配置文件 (&#x2F;etc&#x2F;named.rfc1912.zones) :用来保存域名和 IP 地址对应关系的所在位置，没有包含具体的域名、IP 地址对应关系等信息: 服务类型有三种:<ul><li>hint (根区域)</li><li>master (主区域) 即主服务器</li><li>slave (辅助区域) 即从服务器</li></ul></li><li></li><li>数据配置文件 (&#x2F;var&#x2F;named) :用来保存域名和 IP 地址真是对应关系的数据配置文件<br>在 Linux 系统中，bind 服务程序的名称为 named.</li></ul><p><code>named-checkconf</code> 命令用于检查主配置文件中的语法或参数的错误。</p><p><code>named-checkzone</code> 命令用于检查数据配置文件中的语法或参数错误。</p><h1 id="第15章-使用-Postfix-与-Dovecot-部署邮件系统"><a href="#第15章-使用-Postfix-与-Dovecot-部署邮件系统" class="headerlink" title="第15章 使用 Postfix 与 Dovecot 部署邮件系统"></a>第15章 使用 Postfix 与 Dovecot 部署邮件系统</h1><h2 id="15-1-电子邮件系统"><a href="#15-1-电子邮件系统" class="headerlink" title="15.1 电子邮件系统"></a>15.1 电子邮件系统</h2><p>使用 “姓名@计算机主机名称” 的格式来规范电子信箱的名称.</p><p>电子邮件系统基于邮件协议来完成电子邮箱的传输.</p><p>常见的邮箱协议:</p><ul><li>Simple Mail Transfer Protocol, SMTP, 用于发送和中转的电子邮件，占用服务器的 TCP&#x2F;25 端口</li><li>Post Office Protocol 3, 用于将电子邮件存储到本地主机，占用服务器的 TCP&#x2F;110 端口</li><li>Internet Message Access Protocol 4, 用于在本地主机访问邮件，占用服务器的 TCP&#x2F;143 端口</li></ul><p>在电子邮件系统中，为用户收发邮件的服务器名为<mark>邮件用户代理</mark>(Main User Agent) 即 MUA.</p><p>用于保存用户邮件的”信箱”服务器叫<mark>邮件投递代理</mark>(Mail Transfer Agent) 即 MDA. 其将<mark>邮件传输代理</mark>(Mail Transfer Agent) 即 MTA 的邮件保存在本地。</p><p>部署邮件系统需注意:</p><ul><li>添加反垃圾和反病毒模块</li><li>对邮件加密</li><li>添加邮件监控审核模块</li><li>保障稳定性</li></ul><h2 id="15-2-部署基础的电子邮件系统"><a href="#15-2-部署基础的电子邮件系统" class="headerlink" title="15.2 部署基础的电子邮件系统"></a>15.2 部署基础的电子邮件系统</h2><h3 id="15-1-2-配置-Postfix-服务程序"><a href="#15-1-2-配置-Postfix-服务程序" class="headerlink" title="15.1.2 配置 Postfix 服务程序"></a>15.1.2 配置 Postfix 服务程序</h3>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在 Ubuntu 容器中下载 ip 等命令</title>
    <link href="/2022/08/25/%E5%9C%A8-Ubuntu-%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%B8%8B%E8%BD%BD-ip-%E7%AD%89%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/08/25/%E5%9C%A8-Ubuntu-%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%B8%8B%E8%BD%BD-ip-%E7%AD%89%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> update<br>apt-<span class="hljs-built_in">get</span> install net-tools iputils-ping iproute2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Puppet, Chef 工具</title>
    <link href="/2022/08/25/Puppet-Chef-%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/08/25/Puppet-Chef-%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>puppet 使用自有的 puppet 描述语言，可管理配置文件、用户、cron任务、软件包、系统服务等.</p><p>puppet 采用 Client&#x2F;Server 结构，所有客户端和一个或几个服务器交互。每个客户端周期性(默认为半个小时)向服务器发送请求，获得其最新的配置信息，保证和该配置信息同步。配置完成后，puppet 客户端可以反馈给服务器端一个消息。</p><h1 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h1><p>有两种运行模式:</p><ul><li>standalone 模式: 在单台服务器上制定规则，只能在单台服务器上运行</li><li>master&#x2F;agent 模式: master 制定规则，可以推送到多台 agent 服务器上运行</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 工具 strace, perf, 和 /proc</title>
    <link href="/2022/08/25/Linux-%E5%B7%A5%E5%85%B7-strace-perf-%E5%92%8C-proc/"/>
    <url>/2022/08/25/Linux-%E5%B7%A5%E5%85%B7-strace-perf-%E5%92%8C-proc/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第一本 Docker 书</title>
    <link href="/2022/08/25/%E7%AC%AC%E4%B8%80%E6%9C%AC-Docker-%E4%B9%A6/"/>
    <url>/2022/08/25/%E7%AC%AC%E4%B8%80%E6%9C%AC-Docker-%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-简介"><a href="#第1章-简介" class="headerlink" title="第1章 简介"></a>第1章 简介</h1><p>容器(container) 和 管理程序虚拟化(hypervisor virtualization) 不同:</p><ul><li>HV, 通过中间层将一台或多台独立的机器虚拟运行于物理硬件之上</li><li>Container, 直接运行在操作系统内核之上的用户空间</li></ul><p>容器只能运行与底层宿主机相同或相似的操作系统。</p><p>Docker 是为改变容器的复杂性。</p><h2 id="1-1-Docker-简介"><a href="#1-1-Docker-简介" class="headerlink" title="1.1 Docker 简介"></a>1.1 Docker 简介</h2><p>Docker 是一个能够把开发的应用程序自动部署到容器的开源引擎。所以说是和容器相关联。</p><p>Docker 在虚拟化的容器执行环境中增加了一个应用程序部署引擎。</p><h3 id="1-1-1-提供一个简单、轻量的建模方式"><a href="#1-1-1-提供一个简单、轻量的建模方式" class="headerlink" title="1.1.1 提供一个简单、轻量的建模方式"></a>1.1.1 提供一个简单、轻量的建模方式</h3><p>Docker 依赖于”写时复制”模型。</p><h3 id="1-1-2-职责的逻辑分离"><a href="#1-1-2-职责的逻辑分离" class="headerlink" title="1.1.2 职责的逻辑分离"></a>1.1.2 职责的逻辑分离</h3><h3 id="1-1-3-快速、高效的开发生命周期"><a href="#1-1-3-快速、高效的开发生命周期" class="headerlink" title="1.1.3 快速、高效的开发生命周期"></a>1.1.3 快速、高效的开发生命周期</h3><h3 id="1-1-4-鼓励使用面向服务的架构"><a href="#1-1-4-鼓励使用面向服务的架构" class="headerlink" title="1.1.4 鼓励使用面向服务的架构"></a>1.1.4 鼓励使用面向服务的架构</h3><h2 id="1-2-Docker-组件"><a href="#1-2-Docker-组件" class="headerlink" title="1.2 Docker 组件"></a>1.2 Docker 组件</h2><p>核心组件:</p><ul><li>Docker 客户端和服务器，也称为 Docker 引擎</li><li>Docker 镜像</li><li>Registry</li><li>Docker 容器</li></ul><h3 id="1-2-1-Docker-客户端和服务器"><a href="#1-2-1-Docker-客户端和服务器" class="headerlink" title="1.2.1 Docker 客户端和服务器"></a>1.2.1 Docker 客户端和服务器</h3><p>Docker 是一个客户端&#x2F;服务器(C&#x2F;S)架构的程序。</p><p>Docker 提供了一个命令行工具 docker 以及一整套 RESTFUL API 来与守护进程交互。</p><h3 id="1-2-2-Docker-镜像"><a href="#1-2-2-Docker-镜像" class="headerlink" title="1.2.2 Docker 镜像"></a>1.2.2 Docker 镜像</h3><p>用户基于镜像来运行自己的容器。</p><p>可以把镜像当做容器的”源代码”.</p><h3 id="1-2-3-Registry"><a href="#1-2-3-Registry" class="headerlink" title="1.2.3 Registry"></a>1.2.3 Registry</h3><p>Docker 用 Registry 来保存用户构建的镜像。</p><p>Registry 分为公有和私有两种。</p><p>可在 Docker Hub 上保存自己的私有镜像。</p><h3 id="1-2-4-容器"><a href="#1-2-4-容器" class="headerlink" title="1.2.4 容器"></a>1.2.4 容器</h3><p>Docker 可以帮用户构建和部署容器，用户只需要把自己的应用程序或服务打包放进容器即可。</p><p>Docker 容器是:</p><ul><li>一个镜像格式</li><li>一系列标准的操作</li><li>一个执行环境</li></ul><p>Docker 借鉴了集装箱的概念，集装箱运输货物，Docker 运输软件。Docker 是运输工, 对容器进行操作。</p><p>每个容器都包含一个软件镜像，也就是容器的”货物”.</p><p>所有容器都按照相同的方式将内容”装载”进去，</p><h2 id="1-3-能用-Docker-做什么"><a href="#1-3-能用-Docker-做什么" class="headerlink" title="1.3 能用 Docker 做什么"></a>1.3 能用 Docker 做什么</h2><p>容器可以为各种测试提供很好的沙盒环境.</p><h2 id="1-4-Docker-与配置管理"><a href="#1-4-Docker-与配置管理" class="headerlink" title="1.4 Docker 与配置管理"></a>1.4 Docker 与配置管理</h2><p>Docker 很轻量: 镜像是分层的，可以对其进行迅速的迭代.</p><p>Docker 一个显著特点就是，对不同的宿主机、应用程序和服务，可能会表现出不同的特性与架构。</p><h2 id="1-5-Docker-的技术组件"><a href="#1-5-Docker-的技术组件" class="headerlink" title="1.5 Docker 的技术组件"></a>1.5 Docker 的技术组件</h2><h1 id="第2章-安装-Docker"><a href="#第2章-安装-Docker" class="headerlink" title="第2章 安装 Docker"></a>第2章 安装 Docker</h1><h2 id="2-1-安装-Docker-的先决条件"><a href="#2-1-安装-Docker-的先决条件" class="headerlink" title="2.1 安装 Docker 的先决条件"></a>2.1 安装 Docker 的先决条件</h2><h2 id="2-2-在-Ubuntu-和-Debian-中安装-Docker"><a href="#2-2-在-Ubuntu-和-Debian-中安装-Docker" class="headerlink" title="2.2 在 Ubuntu 和 Debian 中安装 Docker"></a>2.2 在 Ubuntu 和 Debian 中安装 Docker</h2><h3 id="2-2-1-检查前提条件"><a href="#2-2-1-检查前提条件" class="headerlink" title="2.2.1 检查前提条件"></a>2.2.1 检查前提条件</h3><h4 id="1-内核"><a href="#1-内核" class="headerlink" title="1. 内核"></a>1. 内核</h4><p>使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">uname</span> -a</span><br></code></pre></td></tr></table></figure><p>若下载新内核，可使用命令加载新内核:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo <span class="hljs-built_in">update-grub</span><br><span class="hljs-variable">$</span> reboot<br></code></pre></td></tr></table></figure><h4 id="2-检查-Device-Mapper"><a href="#2-检查-Device-Mapper" class="headerlink" title="2. 检查 Device Mapper"></a>2. 检查 Device Mapper</h4><p>使用 Device Mapper 作为存储驱动。</p><p>Device Mapper 支持”自动精简配置”(thin-provisioning)的概念，可以在一种文件系统中存储多台虚拟设备(Docker镜像中的层).</p><p>确认是否安装:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ ls -l <span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span><span class="hljs-regexp">/misc/</span>device-mapper<br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ sudo <span class="hljs-keyword">grep</span> device-mapper <span class="hljs-regexp">/proc/</span>devices<br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo modprobe dm_mod<br></code></pre></td></tr></table></figure><h3 id="2-2-2-安装-Docker"><a href="#2-2-2-安装-Docker" class="headerlink" title="2.2.2 安装 Docker"></a>2.2.2 安装 Docker</h3><p>到<a href="https://docs.docker.com/engine/install/ubuntu/">官网</a>查看.</p><h3 id="2-2-3-Docker-与-UFW"><a href="#2-2-3-Docker-与-UFW" class="headerlink" title="2.2.3 Docker 与 UFW"></a>2.2.3 Docker 与 UFW</h3><p>UWF 即 Uncomplicated Firewall.</p><p>Docker 使用一个网桥来管理容器中的网络。</p><p>默认情况下，UFW 会丢弃所有转发的数据包，因此需要在 UFW 中启用数据包的转发.</p><p>修改 <code>/etc/default/ufw</code> 文件:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DEFAULT_FORWARD_POLICY</span>=<span class="hljs-string">&quot;DROP&quot;</span><br></code></pre></td></tr></table></figure><p>改为:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DEFAULT_FORWARD_POLICY</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span><br></code></pre></td></tr></table></figure><p>重新加载:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo ufw reload<br></code></pre></td></tr></table></figure><h2 id="2-9-Docker-守护进程"><a href="#2-9-Docker-守护进程" class="headerlink" title="2.9 Docker 守护进程"></a>2.9 Docker 守护进程</h2><p>用户可以使用 <code>docker daemon</code> 命令控制 Docker 守护进程。</p><p>守护进程监听 <code>/var/run/docker.sock</code> 这个 UNIX套接字文件，来获取来自客户端的 Docker 请求。</p><h3 id="2-9-1-配置-Docker-守护进程"><a href="#2-9-1-配置-Docker-守护进程" class="headerlink" title="2.9.1 配置 Docker 守护进程"></a>2.9.1 配置 Docker 守护进程</h3><p>用 <code>-H</code> 标志调整守护进程绑定监听接口的方式, 可以使用 <code>-H</code> 标志指定不同的网络接口和端口配置:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker daemon -H tcp:<span class="hljs-regexp">//</span><span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">2375</span><br></code></pre></td></tr></table></figure><p>使用 <code>-D</code> 参数来输出 Docker 守护进程的详细信息:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker daemon -D<br></code></pre></td></tr></table></figure><h2 id="2-10-升级-Docker"><a href="#2-10-升级-Docker" class="headerlink" title="2.10 升级 Docker"></a>2.10 升级 Docker</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo apt-<span class="hljs-built_in">get</span> update<br>$ sudo apt-<span class="hljs-built_in">get</span> install docker-engine<br></code></pre></td></tr></table></figure><h2 id="2-11-Docker-用户界面"><a href="#2-11-Docker-用户界面" class="headerlink" title="2.11 Docker 用户界面"></a>2.11 Docker 用户界面</h2><h1 id="第3章-Docker-入门"><a href="#第3章-Docker-入门" class="headerlink" title="第3章 Docker 入门"></a>第3章 Docker 入门</h1><h2 id="3-1-确保-Docker-已经就绪"><a href="#3-1-确保-Docker-已经就绪" class="headerlink" title="3.1 确保 Docker 已经就绪"></a>3.1 确保 Docker 已经就绪</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ sudo docker <span class="hljs-meta">info</span><br></code></pre></td></tr></table></figure><h2 id="3-2-运行我们的第一个容器"><a href="#3-2-运行我们的第一个容器" class="headerlink" title="3.2 运行我们的第一个容器"></a>3.2 运行我们的第一个容器</h2><p><code>docker run</code> 命令提供了 Docker 容器的创建到启动的功能。</p><p>可以使用 <code>docker help run</code> 获取命令列表。</p><p>使用 <code>man</code> 页, <code>man docker-run</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -i -t ubuntu <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><p><code>-i</code> 参数保证容器中 STDIN 是开启的。</p><p><code>-t</code> 参数告诉 Docker 为要创建的容器分配一个伪 tty 终端.</p><p><code>ubuntu</code> 是用来告诉 Docker 基于什么镜像来创建容器，<code>ubuntu</code> 镜像是一个常备镜像，也可以称为”基础”(base) 镜像，由 Docker 公司提供，保存在 Docker Hub Registry 上。</p><p>Docker 会检查本地是否存在 <code>ubuntu</code> 镜像，如果没有，Docker 就会连接官方维护的 Docker Hub Registry, 查看 Docker Hub 中是否存在该镜像，Docker 一旦找到该镜像，就会下载到本地。</p><p>随后，Docker 在文件系统内部用这个镜像创建了一个新容器，该容器拥有自己的 网络、IP地址，以及一个用来和宿主机进行通信的桥接网络接口。</p><p><code>/bin/bash</code> 是我们告诉 Docker 在容器中运行的命令。</p><h2 id="3-3-使用第一个容器"><a href="#3-3-使用第一个容器" class="headerlink" title="3.3 使用第一个容器"></a>3.3 使用第一个容器</h2><p>我进入的界面为:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@895508d7a56f</span><span class="hljs-symbol">:/</span><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>这里 <code>root</code> 为 root 账户，<code>895508d7a56f</code> 为容器 ID(即主机名). 其为一个完整的 Ubuntu 系统。</p><p>获取主机名:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@895508d7a56f</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># hostname</span><br></code></pre></td></tr></table></figure><p>查看容器的网络配置:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@895508d7a56f</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># ip a</span><br></code></pre></td></tr></table></figure><p>使用 <code>exit</code> 命令可以退出容器。</p><p><code>docker ps -a</code> 查看当前系统中容器的列表。</p><p><code>docker ps -l</code> 列出最后一个运行的容器。</p><p>有三种方式可以唯一指定容器:</p><ul><li>短 UUID</li><li>长 UUID</li><li>名称</li></ul><h2 id="3-4-容器命名"><a href="#3-4-容器命名" class="headerlink" title="3.4 容器命名"></a>3.4 容器命名</h2><p>Docker 会为我们创建的每一个容器自动生成一个随机的名称。</p><p>使用 <code>--name</code> 标志来指定名称:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ sudo doker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name bob_the_container -i -t ubuntu /bin/bash</span><br></code></pre></td></tr></table></figure><p>一个合法的名称只能包括 <code>[a-zA-Z0-9.-]</code></p><p>很多 Docker 命令中，都可以用容器的名称来替代容器 ID.</p><p>容器的命名是唯一的。</p><p>用 <code>docker rm</code> 可删掉容器。</p><h2 id="3-5-重新启动已经停止的容器"><a href="#3-5-重新启动已经停止的容器" class="headerlink" title="3.5 重新启动已经停止的容器"></a>3.5 重新启动已经停止的容器</h2><p>启动停止的容器:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">start</span> bob_the_container <span class="hljs-comment"># 也可以使用容器 ID</span><br></code></pre></td></tr></table></figure><p>重新启动用 <code>docker restart</code></p><p>使用 <code>docker create</code> 创建一个容器但不运行它.</p><h2 id="3-6-附着到容器上"><a href="#3-6-附着到容器上" class="headerlink" title="3.6 附着到容器上"></a>3.6 附着到容器上</h2><p>Docker 容器重新启动的时候，会沿用 <code>docker run</code> 命令时指定的参数来运行。</p><p>也可以用 <code>docker attach</code> 命令重新附着到该容器的会话上:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ sudo docker attach bob_the_container<br></code></pre></td></tr></table></figure><h2 id="3-7-创建守护式容器"><a href="#3-7-创建守护式容器" class="headerlink" title="3.7 创建守护式容器"></a>3.7 创建守护式容器</h2><p>除交互式运行的容器(interactive container) 还有守护式容器(daemonized container), 其没有交互式会话。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run --name daemon_dave -d ubuntu <span class="hljs-regexp">/bin/</span>sh -c <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span><br></code></pre></td></tr></table></figure><p>使用 <code>-d</code> 参数，即放入后台运行。</p><h2 id="3-8-容器内部都在干些什么"><a href="#3-8-容器内部都在干些什么" class="headerlink" title="3.8 容器内部都在干些什么"></a>3.8 容器内部都在干些什么</h2><p>使用 <code>docker logs</code> 获取容器的日志.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker logs daemon_dave<br></code></pre></td></tr></table></figure><p>可加入 <code>-f</code> 选项:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker logs <span class="hljs-operator">-f</span> daemon_dave<br></code></pre></td></tr></table></figure><p>获取最后十行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker logs --<span class="hljs-built_in">tail</span> 10 daemon_dave</span><br></code></pre></td></tr></table></figure><p>加上时间戳:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker logs -ft daemon_dave<br></code></pre></td></tr></table></figure><h2 id="3-9-Docker-日志驱动"><a href="#3-9-Docker-日志驱动" class="headerlink" title="3.9 Docker 日志驱动"></a>3.9 Docker 日志驱动</h2><p>使用 <code>--log-drive</code> 选项:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ sudo docker run <span class="hljs-params">--log-driver=</span><span class="hljs-string">&quot;syslog&quot;</span> <span class="hljs-params">--name</span> daemon_dwayne -d ubuntu <span class="hljs-string">/bash/sh</span> -c <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span><br></code></pre></td></tr></table></figure><p>使用 <code>syslog</code> 时会警用 <code>docker logs</code> 命令，并将所有容器的日志输出都重定向到 <code>Syslog</code>.</p><p>若使用 <code>none</code> 则禁用日志。</p><h2 id="3-10-查看容器内的进程"><a href="#3-10-查看容器内的进程" class="headerlink" title="3.10 查看容器内的进程"></a>3.10 查看容器内的进程</h2><p>使用 <code>docker top</code> 命令:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">$ sudo docker <span class="hljs-built_in">top</span> daemon_dave<br></code></pre></td></tr></table></figure><h2 id="3-11-Docker-统计信息"><a href="#3-11-Docker-统计信息" class="headerlink" title="3.11 Docker 统计信息"></a>3.11 Docker 统计信息</h2><p><code>docker stats</code> 显示一个或多个容器的统计信息:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker stats daemon_dave daemon_kate daemon_clare<br></code></pre></td></tr></table></figure><h2 id="3-12-在容器内部运行进程"><a href="#3-12-在容器内部运行进程" class="headerlink" title="3.12 在容器内部运行进程"></a>3.12 在容器内部运行进程</h2><p>可以再容器内运行的进程有两种类型:</p><ul><li>后台任务</li><li>交互式任务</li></ul><p>使用 <code>docker exec</code> 命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker <span class="hljs-built_in">exec</span> -d daemon_dave <span class="hljs-built_in">touch</span> /etc/new_config_file</span><br></code></pre></td></tr></table></figure><p>就是对一个正在运行的容器使用。</p><h2 id="3-13-停止守护式容器"><a href="#3-13-停止守护式容器" class="headerlink" title="3.13 停止守护式容器"></a>3.13 停止守护式容器</h2><p>使用 <code>docker stop</code> 命令:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ sudo docker stop daemon_dave<br></code></pre></td></tr></table></figure><p>交互式可以通过 <code>exit</code></p><p>想要快速停止某个容器，使用 <code>docker kill</code>:</p><p>显示最后 x 个容器:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-n</span> x<br></code></pre></td></tr></table></figure><h2 id="3-14-自动重启容器"><a href="#3-14-自动重启容器" class="headerlink" title="3.14 自动重启容器"></a>3.14 自动重启容器</h2><p>使用 <code>--restart</code> 标志，磨人的行为是 Docker 不会重启容器。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-built_in">run</span> <span class="hljs-attribute">--restart</span>=always --name <br></code></pre></td></tr></table></figure><p>另一个 <code>on-failure</code> 参数，即在退出状态码为非 0 值时重启，且可指定重启次数:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">--restart</span>=<span class="hljs-literal">on</span>-failure:<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="3-15-深入容器"><a href="#3-15-深入容器" class="headerlink" title="3.15 深入容器"></a>3.15 深入容器</h2><p><code>docker inspect</code> 获取更多容器信息:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker inspect daemon_dave<br></code></pre></td></tr></table></figure><p>使用 <code>-f</code> 或 <code>--format</code> 标志选定查看结果:</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">$ sudo docker inspect --format=&#x27;</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">.State.Running</span> &#125;&#125;</span><span class="language-xml">&#x27; daemon_dave</span><br></code></pre></td></tr></table></figure><p>可指定多个容器.</p><h2 id="3-16-删除容器"><a href="#3-16-删除容器" class="headerlink" title="3.16 删除容器"></a>3.16 删除容器</h2><p>使用 <code>docker rm</code> 命令:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">rm</span> <span class="hljs-number">80430</span>f8d0921<br></code></pre></td></tr></table></figure><p>可传递 <code>-f</code> 参数。</p><p>删除所有容器:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">rm</span> `sudo docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span>`<br></code></pre></td></tr></table></figure><h1 id="第4章-使用-Docker-镜像和仓库"><a href="#第4章-使用-Docker-镜像和仓库" class="headerlink" title="第4章 使用 Docker 镜像和仓库"></a>第4章 使用 Docker 镜像和仓库</h1><h2 id="4-1-什么是-Docker-镜像"><a href="#4-1-什么是-Docker-镜像" class="headerlink" title="4.1 什么是 Docker 镜像"></a>4.1 什么是 Docker 镜像</h2><p>Docker 镜像是由文件系统叠加而成。</p><p>最低端是一个引导文件系统 bootfs.</p><p>当一个容器启动后，它会被移到内存中，而引导文件系统则会被卸载(unmount).</p><p>Docker 镜像的第二层是 root 文件系统 rootfs, 其位于引导文件系统之上。</p><p>Docker 利用联合加载技术(union mount), 即一次同时加载多个文件系统，但是在外面看起来只能看到一个文件系统。</p><p>联合加载会将各层文件系统叠加到一起，这样最终的文件系统会包含所有底层的文件和目录。</p><p>Docker 将这样的文件系统称为镜像。一个镜像可以放到另一个镜像的顶部。位于下面的镜像称为父镜像(parent image), 最底层的镜像称为基础镜像(base image).</p><p>当从一个镜像启动容器时，Docker 会在该镜像最顶层加载一个读写文件系统，我们在 Docke 中运行的程序就是在这个读写层中执行。</p><p>每个只读镜像层都是只读，并且以后永远不会变化。</p><p>写时复制(copy on write)机制，想修改一个文件，这个文件首先会从该读写层下面的只读层复制到该读写层，该文件的只读版本依然存在，但是被读写层中的该文件副本所隐藏。</p><h2 id="4-2-列出镜像"><a href="#4-2-列出镜像" class="headerlink" title="4.2 列出镜像"></a>4.2 列出镜像</h2><p>列出主机上可用的镜像, 使用 <code>docker images</code>:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker images<br></code></pre></td></tr></table></figure><p>本地镜像都保存在 Docker 宿主机的 <code>/ver/lib/docker</code> 目录下.</p><p>镜像从仓库下载，镜像保存在仓库中，仓库存在于 Registry 中。</p><p>每个镜像仓库都可以存放很多镜像.</p><p>使用 <code>docker pull</code> 命令来拉取仓库中的镜像。</p><p>可以通过在仓库名后面加上一个冒号和标签名来指定该仓库中的某一镜像:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ sudo docker <span class="hljs-built_in">run</span> -t -i <span class="hljs-comment">--name new_container ubuntu:12.04 /bin/bash</span><br></code></pre></td></tr></table></figure><p>一个镜像可以有多个标签。</p><p>Docker Hub 中有两种类型的仓库:</p><ul><li>用户仓库(user repository), 都是由 Docker 用户创建的, 其命名由用户名和仓库名两部分组成</li><li>顶层仓库(top-level repository), 由 Docker 内部的人来管理, 其命名只包含仓库名</li></ul><h2 id="4-3-拉取镜像"><a href="#4-3-拉取镜像" class="headerlink" title="4.3 拉取镜像"></a>4.3 拉取镜像</h2><p>如:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker pull <span class="hljs-symbol">fedora:</span><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h2 id="4-4-查找镜像"><a href="#4-4-查找镜像" class="headerlink" title="4.4 查找镜像"></a>4.4 查找镜像</h2><p>使用 <code>docker search</code> 命令来查找所有 Docker Hub 上公共的可用镜像。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker search puppet<br></code></pre></td></tr></table></figure><h2 id="4-5-构建镜像"><a href="#4-5-构建镜像" class="headerlink" title="4.5 构建镜像"></a>4.5 构建镜像</h2><p>两种方法:</p><ul><li>docker commit</li><li>docker build 和 Dockerfile 文件<br>使用 <code>Dockerfile</code> 更加灵活.</li></ul><h3 id="4-5-1-创建-Docker-Hub"><a href="#4-5-1-创建-Docker-Hub" class="headerlink" title="4.5.1 创建 Docker Hub"></a>4.5.1 创建 Docker Hub</h3><p>登录到 Docker Hub, 使用 <code>docker login</code> 命令:<br><code>$ sudo docker login</code><br>用户的个人认证信息会被保存在 <code>$HOME/.docker/config.json</code> 中。</p><h3 id="4-5-2-用-Docker-的-commit-命令创建镜像"><a href="#4-5-2-用-Docker-的-commit-命令创建镜像" class="headerlink" title="4.5.2 用 Docker 的 commit 命令创建镜像"></a>4.5.2 用 Docker 的 commit 命令创建镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker commit 4aab3ce3cb76 jamtur01/apache2</span><br></code></pre></td></tr></table></figure><p><code>4aab3ce3cb76</code> 是容器的 ID, <code>jamtur01</code> 是目标镜像仓库, <code>apache2</code> 是镜像名.</p><p><code>docker commit</code> 提交的只是创建容器的镜像与容器的当前状态之间有差异的部分。</p><p>可以在提交镜像时指定更多的数据(包括标签):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker commit -m<span class="hljs-string">&quot;A new custom image&quot;</span> -a<span class="hljs-string">&quot;James Turnbull&quot;</span> 4aab3ce3cb76 jamtur01/apache2:webserver</span><br></code></pre></td></tr></table></figure><p><code>-m</code> 选项是创建镜像的提交信息。</p><p><code>-a</code> 选项是该镜像的作者信息。</p><p><code>webserver</code> 是标签名。</p><p>可以使用 <code>docker inspect</code> 命令来查看新创建的镜像的详细信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker inspect jamtur01/apache2:webserver</span><br></code></pre></td></tr></table></figure><h3 id="4-5-3-用-Dockerfile-构建镜像"><a href="#4-5-3-用-Dockerfile-构建镜像" class="headerlink" title="4.5.3 用 Dockerfile 构建镜像"></a>4.5.3 用 Dockerfile 构建镜像</h3><p>一般不推荐使用 <code>docker commit</code> 来构建镜像。</p><p>Dockerfile 使用基本的基于 DSL(Domain Specific Language) 语法的指令来构建一个 Docker 镜像。</p><h4 id="第一个-Dockerfile"><a href="#第一个-Dockerfile" class="headerlink" title="第一个 Dockerfile"></a>第一个 Dockerfile</h4><p>创建的用来保存 Dockerfile 的目录称为构建环境(build environment), Docker 则称此环境为上下文(context)或构建上下文(build context),</p><p>Docker 会在构建镜像时将构建上下文和该上下文中的文件和目录上传到 Docker 守护进程。</p><p>例子:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Version: 0.0.1</span><br><span class="hljs-keyword">FROM</span> ubuntu:14.04<br>MAINTAINER james Turnbull <span class="hljs-string">&quot;james@example.com&quot;</span><br><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> update &amp;&amp; apt-<span class="hljs-built_in">get</span> install -y nginx<br><span class="hljs-built_in">RUN</span> echo <span class="hljs-string">&#x27;Hi, I am in your container&#x27;</span> \<br>    &gt;/usr/share/nginx/html/index.html<br>EXPOSE 80<br></code></pre></td></tr></table></figure><p>Dockerfile 由指令和参数构成。</p><p>每条指令，如 <code>FROM</code>, 都必须为大写字母, 而且后面要跟随一个参数.</p><p>每条指令都会创建一个新的镜像层并对镜像进行提交。</p><p>运行流程:</p><ul><li>Docker从基础镜像运行一个容器。<br>  -执行一条指令，对容器做出修改。<br>  -执行类似docker commit的操作，提交一个新的镜像层。<br>  -Docker再基于刚提交的镜像运行一个新容器。<br>  -执行Dockerfile中的下一条指令，直到所有指令都执行完毕</li></ul><p>Dockerfile 中的注释是 <code>#</code> 开头的行.</p><p><code>MAINTAINER</code> 指令告诉 Docker 该镜像的作者是谁，以及作者的电子邮件地址。</p><p><code>RUN</code> 指令会在当前镜像中运行指定的命令. 每条 <code>RUN</code> 指令都会创建一个新的镜像层。</p><p>默认情况下，<code>RUN</code> 指令会在 shell 里使用 <code>/bin/sh -c</code> 来执行。</p><p>若在不支持 shell 的平台上，使用 <code>exec</code> 格式的 <code>RUN</code> 指令:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">RUN</span> [<span class="hljs-string">&quot;appt-get&quot;</span>, <span class="hljs-string">&quot; install&quot;</span>, <span class="hljs-string">&quot;-y&quot;</span>, <span class="hljs-string">&quot;nginx&quot;</span>]<br></code></pre></td></tr></table></figure><p>这里的 <code>-y</code> 参数是 <code>yes</code> 的意思。</p><p><code>EXPOSE</code> 指令，告诉 Docker 该容器内的应用程序将会使用容器的指定端口。</p><p>可以指定多个 <code>EXPOSE</code> 指令来向外部公开多个端口。</p><h3 id="4-5-4-基于-Dockerfile-构建新镜像"><a href="#4-5-4-基于-Dockerfile-构建新镜像" class="headerlink" title="4.5.4 基于 Dockerfile 构建新镜像"></a>4.5.4 基于 Dockerfile 构建新镜像</h3><p>执行 <code>docker build</code> 命令时，Dockerfile 中的所有指令都会被执行并且提交，并且在该命令成功结束后返回一个新镜像。</p><p>使用 <code>-t</code> 选项为新镜像设置仓库和名称以及标签:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo docker build -t=<span class="hljs-string">&quot;jamtur01/static_web:v1&quot;</span> .<br></code></pre></td></tr></table></figure><p>如果没有制定任何标签，Docker 将会自动为镜像设置一个 <code>latest</code> 标签.</p><p>最后一个 <code>.</code> 告诉 Docker 到本地目录中找 Dockerfile 文件，也可指定一个 Git 仓库的源地址来指定 Dockerfile 的位置.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo docker build -t=<span class="hljs-string">&quot;jamtur01/static_web:v1&quot;</span> git<span class="hljs-variable">@github</span>.<span class="hljs-symbol">com:</span>jamtur01/docker-static_web<br></code></pre></td></tr></table></figure><p><code>-f</code> 参数指定文件:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ sudo docker build -t=<span class="hljs-string">&quot;jamtur01/static_web&quot;</span> -f path<span class="hljs-regexp">/to/</span><span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>构建目录中的 <code>.dockerignore</code> 类似于 <code>.gitignore</code></p><h3 id="4-5-5-指令失败时会怎样"><a href="#4-5-5-指令失败时会怎样" class="headerlink" title="4.5.5 指令失败时会怎样"></a>4.5.5 指令失败时会怎样</h3><h3 id="4-5-6-Dockerfile-和构建缓存"><a href="#4-5-6-Dockerfile-和构建缓存" class="headerlink" title="4.5.6 Dockerfile 和构建缓存"></a>4.5.6 Dockerfile 和构建缓存</h3><p>它会将之前的镜像层看做缓存，意思是第二次 <code>docker build</code> 时，会接着从上次结束时运行。</p><p>忽略缓存功能，使用 <code>docker build --no-cache</code></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> sudo docker build --<span class="hljs-keyword">no</span>-cache -t=<span class="hljs-string">&quot;jamtur01/static_web&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-5-7-基于构建缓存的-Dockerfile-模板"><a href="#4-5-7-基于构建缓存的-Dockerfile-模板" class="headerlink" title="4.5.7 基于构建缓存的 Dockerfile 模板"></a>4.5.7 基于构建缓存的 Dockerfile 模板</h3><p>一般在 Dockerfile 文件顶部使用相同的指令集模板:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FROM</span> ubuntu:<span class="hljs-number">14</span>.<span class="hljs-number">04</span><br><span class="hljs-attribute">MAINTAINER</span> James Turnbull <span class="hljs-string">&quot;james@example.com&quot;</span><br><span class="hljs-attribute">ENV</span> REFRESHED_AT <span class="hljs-number">2014</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span><br><span class="hljs-attribute">RUN</span> apt-get -qq update<br></code></pre></td></tr></table></figure><p><code>ENV</code> 指令用于在镜像中设置环境变量。</p><p>模板实际上就是自己常用的配置。</p><h3 id="4-5-8-查看新镜像"><a href="#4-5-8-查看新镜像" class="headerlink" title="4.5.8 查看新镜像"></a>4.5.8 查看新镜像</h3><p>深入探求镜像是如何被构建出来的，使用 <code>docker history</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">history</span> <span class="hljs-number">22</span>d47c8cb6e5<br></code></pre></td></tr></table></figure><h3 id="4-5-9-从新镜像启动容器"><a href="#4-5-9-从新镜像启动容器" class="headerlink" title="4.5.9 从新镜像启动容器"></a>4.5.9 从新镜像启动容器</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -p 80 --name static_web jamtur01/static_web nginx -g <span class="hljs-string">&quot;daemon off;&quot;</span></span><br></code></pre></td></tr></table></figure><p><code>-d</code> 选项告诉 Docker 以分离(detached)的方式在后台运行。</p><p><code>-p</code> 选项，用来控制 Docker 在运行时应该公开哪些网络端口给外部(宿主机).</p><p>Docker 可以通过两种方法来在宿主机上分配端口:</p><ul><li>Docker 可以在宿主机上随机选择一个位于 32768~61000 的比较大的端口号来映射到容器的 80 端口上</li><li>可以在 Docker 宿主机中指定一个具体的端口号来映射到容器中的 80 端口上</li></ul><p><code>docker run</code> 命令会在 Docker 宿主机上随即打开一个端口，连接到容器中的 80 端口上。</p><p>可用 <code>docker ps</code> 命令查看容器的端口分配情况:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-l</span><br></code></pre></td></tr></table></figure><p>也可通过 <code>docker port</code> 命令来查看容器的端口映射情况:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker port <span class="hljs-number">6751</span>b94bb5c0 <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>使用 <code>-p</code> 选项指定容器中的端口映射到 Docker 宿主机的某一特定端口上:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ sudo docker <span class="hljs-built_in">run</span> -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> <span class="hljs-comment">--name static_web</span><br></code></pre></td></tr></table></figure><p>前者是宿主机端口，后者是容器端口。 </p><p>将端口绑定限制在特定的网络接口(即IP地址)上:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -p 127.0.0.1:80:80 --name static_web jamtur01/static_web nginx -g <span class="hljs-string">&quot;daemon off;&quot;</span></span><br></code></pre></td></tr></table></figure><p>其将容器内的 80 端口绑定到本地宿主机的 127.0.0.1 这个 IP 的 80 端口上. 不指定如 80 就是随机端口。</p><p>使用 <code>-P</code> 参数将 Dockerfile 中通过 <code>EXPOSE</code> 指令指定的端口公开:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -P --name static_web jamtur01/static_web nginx -g <span class="hljs-string">&quot;daemon off;&quot;</span></span><br></code></pre></td></tr></table></figure><p>并绑定到随机端口。</p><p>有了这个端口号，就可以使用本地宿主机的 IP 地址连接到运行中的容器.</p><h3 id="4-5-10-Dockerfile-指令"><a href="#4-5-10-Dockerfile-指令" class="headerlink" title="4.5.10 Dockerfile 指令"></a>4.5.10 Dockerfile 指令</h3><p>[清单](<a href="http://docs.docker.com/">http://docs.docker.com/</a> reference &#x2F;builder&#x2F;)</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>用于指定一个容器启动时要运行的命令.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">CMD <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>后面为参数.</p><p>这是存储在一个数组结构中.</p><p><code>docker run</code> 命令后若指定要运行的命令, 会覆盖 Dockerfile 中的 CMD 指令.</p><p>在 Dockerfile 中只能指定一条 CMD 命令.</p><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p><code>docker run</code> 命令行中指定的任何参数都会被当做参数再次传递给 <code>ENTRYPOINT</code> 指令中指定的命令.</p><p>如:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTERYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/usr/sbin/ nginx&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>然后:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker build <span class="hljs-attribute">-t</span>=<span class="hljs-string">&quot;jamtur01/static_web&quot;</span><br>$ sudo docker <span class="hljs-built_in">run</span> -t -i jamtur01/static_web -g <span class="hljs-string">&quot;daemon off;&quot;</span><br></code></pre></td></tr></table></figure><p>其中 <code>-g &quot;daemon off;&quot;</code> 就会传递给 <code>ENTEYPOINT</code></p><p>可用 <code>docker run</code> 的 <code>--entrypoint</code> 选项来覆盖 <code>ENTRYPOINT</code> 指令.</p><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>用来从镜像创建一个容器时,在容器内部设置一个工作目录,<code>ENTRYPOINT</code> 和 <code>/</code> 或 <code>CMD</code> 指定的程序会在这个目录下执行.</p><p>可以设置不同的工作目录:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /opt/webapp/db</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> bundle install</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /opt/webapp</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;rackup&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>可以通过 <code>-w</code> 选项在运行时设置工作目录:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ sudo docker <span class="hljs-keyword">run</span> -ti -w /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span> ubuntu <span class="hljs-keyword">pwd</span><br></code></pre></td></tr></table></figure><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>用于设置环境变量:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ENV RVM_PATH <span class="hljs-regexp">/home/</span>rvm/<br></code></pre></td></tr></table></figure><p>也可通过 <code>docker run</code> 命令的 <code>-e</code> 参数来传递环境变量:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -ti -e <span class="hljs-string">&quot;WEB_PORT=8000&quot;</span> ubuntu <span class="hljs-built_in">env</span></span><br></code></pre></td></tr></table></figure><h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>指定该镜像以什么样的用户去执行:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">USER</span> <span class="hljs-title">nginx</span><br></code></pre></td></tr></table></figure><p>可以指定用户名或 UID 以及组或 GID:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">USER</span> <span class="hljs-title">user</span><br><span class="hljs-keyword">USER</span> <span class="hljs-title">user</span>:<span class="hljs-keyword">group</span><br><span class="hljs-title">USER</span> uid<br><span class="hljs-keyword">USER</span> <span class="hljs-title">uid</span>:gid<br><span class="hljs-keyword">USER</span> <span class="hljs-title">user</span>:gid<br><span class="hljs-keyword">USER</span> <span class="hljs-title">uid</span>:group<br></code></pre></td></tr></table></figure><p>默认用户为 root, 可以用 <code>docker run</code> 的 <code>-u</code> 选项覆盖.</p><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>用来向基于镜像创建的容器添加卷, 一个卷是可以存在于一个或者多个容器内的特定的目录.</p><p>特点:</p><ul><li>卷可以在容器间共享和重用</li><li>一个容器可以不是必须和其他容器共享卷</li><li>对卷的修改是立时生效的</li><li>对卷的修改不会对更新镜像产生影响</li><li>卷会一直存在知道没有任何容器再使用它.</li></ul><p>卷功能可以让我们将内容添加到镜像而不提交.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">VOLUME <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/opt/project&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>为基于此镜像创建的任何容器创建一个名为 <code>/opt/project</code> 的挂载点.</p><p><code>docker cp</code> 允许从容器复制文件和复制文件到容器上.</p><p>指定多个卷:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">VOLUME <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/opt/project&quot;</span>, <span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>用来将构建环境下的文件和目录复制到镜像中.</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADD</span> software.lic /<span class="hljs-meta">opt</span>/application/software.lic<br></code></pre></td></tr></table></figure><p>前者为原文件位置,后者为目的文件位置.</p><p>源文件位置也可以是 URL.</p><p>Docker 通过目的地址参数末尾的字符来判断文件源是目录还是文件:</p><ul><li>目的地址以 <code>/</code> 结尾, 则为目录</li><li>不以, 则为文件</li></ul><p>如果将压缩文件指定为源文件,会将其解压:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ADD latest.tar.gz <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/wordpress/</span><br></code></pre></td></tr></table></figure><p>目前 Docker 还不支持以 URL 方式指定的源文件位置中使用归档文件.</p><p><code>ADD</code> 指令会使构建缓存无效.</p><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>类似于 <code>ADD</code>, 但 <code>COPY</code> 只关心在构建上下文中复制本地文件,而不会 extraction 和 decompression.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span> conf.d<span class="hljs-regexp">/ /</span>etc<span class="hljs-regexp">/apache2/</span><br></code></pre></td></tr></table></figure><p>文件源路径必须是一个与当前构建环境相对的文件或者目录, 本地文件都放到和 Dockerfile 同一个目录下,不能复制该目录之外的任何文件.</p><h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>用于为 Docker 镜像添加元数据. 元数据以键值对的形式展现:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">LABEL version<span class="hljs-operator">=</span><span class="hljs-string">&quot;1.0&quot;</span><br>LAVEL location<span class="hljs-operator">=</span><span class="hljs-string">&quot;New York&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;Data Center&quot;</span> role<span class="hljs-operator">=</span><span class="hljs-string">&quot;Web Server&quot;</span><br></code></pre></td></tr></table></figure><p>推荐将所有元数据都放到一条 LABEL 指令中.</p><p>然后通过  <code>docker inspect</code> 命令来查看 Docker 镜像中的标签信息.</p><h4 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h4><p>用来设置停止容器时发送什么系统调用给容器. 这个信号必须是内核系统调用表中合法的数或者 SIGNAME 格式中的信号名称.</p><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p>用来定义可以在 <code>docker build</code> 命令运行时传递给构建运行时的变量, 只需在构建时使用 <code>--build-arg</code> 参数, 用户只能在构建时指定在 Dockerfile 文件中定义过的参数:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ARG</span> build<br><span class="hljs-keyword">ARG</span> webapp_user=<span class="hljs-keyword">user</span><br></code></pre></td></tr></table></figure><p>第二条指定了默认值:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ sudo docker <span class="hljs-keyword">build </span>--<span class="hljs-keyword">build-arg </span><span class="hljs-keyword">build=1234 </span>-t <span class="hljs-keyword">jamtur01/webapp</span><br></code></pre></td></tr></table></figure><p>不要使用 <code>ARG</code> 来传递证书或者密钥.      </p><p>Docker 预定义了一组 ARG 变量:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">HTTP<span class="hljs-emphasis">_PROXY</span><br><span class="hljs-emphasis">http_proxy</span><br><span class="hljs-emphasis">HTTPS_PROXY</span><br><span class="hljs-emphasis">https_proxy</span><br><span class="hljs-emphasis">ftp_proxy</span><br><span class="hljs-emphasis">FTP_PROXY</span><br><span class="hljs-emphasis">NO_PROXY</span><br><span class="hljs-emphasis">no_</span>proxy<br></code></pre></td></tr></table></figure><h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p>为镜像添加触发器(trigger). 当一个镜像被用作其他镜像的基础镜像时, 该镜像中的触发器将会被执行.</p><p>触发器会在构建过程中插入新指令, 我们可以认为这些指令是紧跟在 FROM 之后指定的:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ONBUILD</span> <span class="hljs-keyword">ADD</span><span class="language-bash"> . /app/arc</span><br><span class="hljs-keyword">ONBUILD</span> <span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app/src &amp;&amp; make</span><br></code></pre></td></tr></table></figure><p><code>ONBUILD</code> 指令可以在镜像上运行 <code>docker inspect</code> 查看.</p><p><code>ONBUILD</code> 触发器会按照父镜像中指定的顺序执行, 并且只能被继承一次.</p><p>有部分指令不能用在 <code>ONBUILD</code> 中, 防止递归调用.</p><h2 id="4-6-将镜像推送到-Docker-Hub"><a href="#4-6-将镜像推送到-Docker-Hub" class="headerlink" title="4.6 将镜像推送到 Docker Hub"></a>4.6 将镜像推送到 Docker Hub</h2><p>使用 <code>docker push</code> 命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker push jamtur01/static_web</span><br></code></pre></td></tr></table></figure><p>应该要先登录, 用 <code>docker login</code></p><h3 id="自动构建-Automated-Builds"><a href="#自动构建-Automated-Builds" class="headerlink" title="自动构建(Automated Builds)"></a>自动构建(Automated Builds)</h3><p>将 Github 或 BitBucket 中含有 Dockerfile 文件的仓库连接到 Docker Hub 即可. 具体参考书籍.</p><h2 id="4-7-删除镜像"><a href="#4-7-删除镜像" class="headerlink" title="4.7 删除镜像"></a>4.7 删除镜像</h2><p>使用 <code>docker rmi</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker rmi jamtur01/static_web</span><br></code></pre></td></tr></table></figure><p>每一个 <code>Deleted:</code> 行都代表一个镜像层被删除.</p><h2 id="4-8-运行自己的-Docker-Registry"><a href="#4-8-运行自己的-Docker-Registry" class="headerlink" title="4.8 运行自己的 Docker Registry"></a>4.8 运行自己的 Docker Registry</h2><p>Registry 就相当于 repository.</p><h3 id="4-8-1-从容器运行-Registry"><a href="#4-8-1-从容器运行-Registry" class="headerlink" title="4.8.1 从容器运行 Registry"></a>4.8.1 从容器运行 Registry</h3><p>从容器安装一个 Registry:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-built_in">run</span> -p 5000:5000 registry:2<br></code></pre></td></tr></table></figure><p>启动一个运行 Registry 应用 2.0 版本的容器.</p><h3 id="4-8-2-测试新-Registry"><a href="#4-8-2-测试新-Registry" class="headerlink" title="4.8.2 测试新 Registry"></a>4.8.2 测试新 Registry</h3><p>先通过 <code>docker images</code> 找到镜像 ID:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker images jamtur01/static_web</span><br></code></pre></td></tr></table></figure><p>然后用 Registry 给镜像打上标签:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ sudo docker <span class="hljs-keyword">tag</span> <span class="hljs-title">22d47c8cb6e5</span><br></code></pre></td></tr></table></figure><p>最后通过 <code>docker push</code> 将其推送到 Registry 中, 为了指定新的 Registry 的地址, 需要在镜像名前加上主机名和端口前缀:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ sudo docker <span class="hljs-keyword">push</span> docker.example.com:<span class="hljs-number">5000</span><span class="hljs-regexp">/jamtur01/</span>static_web<br></code></pre></td></tr></table></figure><p>使用其构建新容器:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -t -i docker.example.com:5000/jamtur01/static_web</span><br></code></pre></td></tr></table></figure><h2 id="4-9-其他可选的-Registry-服务"><a href="#4-9-其他可选的-Registry-服务" class="headerlink" title="4.9 其他可选的 Registry 服务"></a>4.9 其他可选的 Registry 服务</h2><h1 id="第5章-在测试中使用-Docker"><a href="#第5章-在测试中使用-Docker" class="headerlink" title="第5章 在测试中使用 Docker"></a>第5章 在测试中使用 Docker</h1><h2 id="5-1-使用-Docker-测试静态网站"><a href="#5-1-使用-Docker-测试静态网站" class="headerlink" title="5.1 使用 Docker 测试静态网站"></a>5.1 使用 Docker 测试静态网站</h2><p>将 Docker 作为本地 Web 开发环境是 Docker 的一个最简单的应用场景。</p><p>要想保持 Docker 容器的活跃状态，需要其中运行的进程不能中断，默认情况下，Nginx 会以守护进程的方式启动，这会导致容器只是短暂运行，在守护进程被 fork 后，发起守护进程的原始进程就会退出，这时容器就停止运行了.</p><h3 id="5-1-2-构建-Sample-网站和-Nginx-镜像"><a href="#5-1-2-构建-Sample-网站和-Nginx-镜像" class="headerlink" title="5.1.2 构建 Sample 网站和 Nginx 镜像"></a>5.1.2 构建 Sample 网站和 Nginx 镜像</h3><h3 id="5-1-3-从-Sample-网站和-Nginx-镜像构建容器"><a href="#5-1-3-从-Sample-网站和-Nginx-镜像构建容器" class="headerlink" title="5.1.3 从 Sample 网站和 Nginx 镜像构建容器"></a>5.1.3 从 Sample 网站和 Nginx 镜像构建容器</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -d -p <span class="hljs-number">80</span> --name website -v <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/website:/</span>var<span class="hljs-regexp">/www/</span>html<span class="hljs-regexp">/website jamtur01/</span>nginx nginx<br></code></pre></td></tr></table></figure><p>这里的 <code>-v</code> 选项允许我们将宿主机的目录作为卷，挂载到容器里。</p><p>两个目录用 <code>:</code> 分隔，前者为宿主机目录，后者为容器目录，如果容器目录不存在，Docker 会自动创建一个。</p><p>可以通过在目录后面加上 <code>rw</code> 或 <code>ro</code> 来指定容器内目录的读写状态:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -d -p <span class="hljs-number">80</span> --name website -v <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/website:/</span>var<span class="hljs-regexp">/www/</span>html<span class="hljs-regexp">/website:ro jamtur01/</span>nginx nginx<br></code></pre></td></tr></table></figure><h4 id="卷的概念"><a href="#卷的概念" class="headerlink" title="卷的概念"></a>卷的概念</h4><p>卷是在一个或者多个容器内被选定的目录，可以绕过分层的联合文件系统，为 Docker 提供持久数据或者共享数据。</p><p>对卷的修改会立即生效，并绕过镜像，当提交或者创建镜像时，卷不被包含在镜像里。</p><p>卷是从宿主机而来。</p><h3 id="5-1-4-修改网站"><a href="#5-1-4-修改网站" class="headerlink" title="5.1.4 修改网站"></a>5.1.4 修改网站</h3><p>直接修改本地宿主机的 website 目录下的 index.html 文件, 也就是卷内的文件:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ vim <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/website/i</span>ndex.html<br></code></pre></td></tr></table></figure><h2 id="5-2-使用-Docker-构建并测试-Web-应用程序"><a href="#5-2-使用-Docker-构建并测试-Web-应用程序" class="headerlink" title="5.2 使用 Docker 构建并测试 Web 应用程序"></a>5.2 使用 Docker 构建并测试 Web 应用程序</h2><p>Sinatra 是一个基于 Ruby 的 Web 应用框架，它包含一个 Web 应用库，以及简单的领域专用语言 (DSL) 来构建 Web 应用。</p><p>Sinatra 非常适合用来创建一个小型的示例应用进行测试。</p><h3 id="5-2-1-构建-Sinatra-应用程序"><a href="#5-2-1-构建-Sinatra-应用程序" class="headerlink" title="5.2.1 构建 Sinatra 应用程序"></a>5.2.1 构建 Sinatra 应用程序</h3><h3 id="5-2-4-将-Sinatra-应用程序连接到-Redis-容器"><a href="#5-2-4-将-Sinatra-应用程序连接到-Redis-容器" class="headerlink" title="5.2.4 将 Sinatra 应用程序连接到 Redis 容器"></a>5.2.4 将 Sinatra 应用程序连接到 Redis 容器</h3><p>两种比较现实的连接 Docker 容器的方法是:</p><ul><li>Docker Networking, Docker 1.9 及更新版本推荐使用</li><li>Docker link, Docker 1.9 之前版本推荐使用</li></ul><p>Docker Networking 和 Docker link 的区别:</p><ul><li>Docker Networking 可以将容器连接到不同宿主机上的容器</li><li>通过 Docker Networking 连接的容器可以在无需更新连接的情况下，对停止、启动或者重启容器。</li><li>使用 Docker Networking, 不必事先创建容器再去连接它。同样不必关心容器的运行顺序。</li></ul><h3 id="5-2-5-Docker-内部连网"><a href="#5-2-5-Docker-内部连网" class="headerlink" title="5.2.5 Docker 内部连网"></a>5.2.5 Docker 内部连网</h3><p>在安装 Docker 时，会创建一个新的网络接口，名字是 docker0.</p><p>每个 Docker 容器都会在这个接口上分配一个 IP 地址。</p><p>启动 IPv6, 在运行 Docker 守护进程时加上 <code>--ipv6</code> 标志.</p><p>接口本身的地址是这个 Docker 网络的网关地址，也是所有 Docker 容器的网关地址。</p><p>Docker 会默认使用 172.17.x.x 作为子网地址，除非被占用，Docker 就会在 172.16~172.30 这个范围内尝试创建子网.</p><p>Docker 每创建一个容器就会创建一组互联的网络接口，其中一端作为容器里的 eth0 接口，而另一端统一命名为 vethec6a 这种名字，作为宿主机的一个端口.</p><p>通过把每个 veth* 接口绑定到 docker0 网桥，Docker 创建了一个虚拟子网，这个子网由宿主机和所有的 Docker 容器共享。</p><p>从容器内跟踪路由:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"># apt-<span class="hljs-built_in">get</span> -yqq <span class="hljs-keyword">update</span> &amp;&amp; apt-<span class="hljs-built_in">get</span> install -yqq traceroute<br># traceroute google.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><p>查看宿主机的 IPTables NAT 配置:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">$ sudo iptables -<span class="hljs-built_in">t</span> nat -L -<span class="hljs-built_in">n</span><br></code></pre></td></tr></table></figure><p>Docker 默认会把公开的端口绑定到所有的网络接口上。</p><p>如果重启容器，Docker 会改变容器的 IP 地址.</p><h3 id="5-2-6-Docker-Networking"><a href="#5-2-6-Docker-Networking" class="headerlink" title="5.2.6 Docker Networking"></a>5.2.6 Docker Networking</h3><p>容器之间的连接用网络创建，被称为 Docker Networking.</p><p>Docker Networking 允许用户创建自己的网络，容器可以通过这个网上互相通信.</p><p>使用 Docker Networking 需先创建一个网络，然后在这个网络下启动容器:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo docker network create app<br></code></pre></td></tr></table></figure><p><code>create</code> 后接名称.</p><p>查看新创建的网络:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ sudo docker network <span class="hljs-keyword">inspect</span> <span class="hljs-keyword">app</span><br></code></pre></td></tr></table></figure><p><a href="https://docs.docker.com/engine/userguide/networking/get-started-overlay/">Docker 多宿主机网络文档</a></p><p>列出当前系统中的所有网络:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker network <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>删除一个 Docker 网络:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker network <span class="hljs-built_in">rm</span><br></code></pre></td></tr></table></figure><p>添加容器:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-built_in">run</span> -d <span class="hljs-attribute">--net</span>==app --name db jamtur01/redis<br></code></pre></td></tr></table></figure><p><code>--net</code> 标志指定了新容器将会在哪个网络中运行。</p><p>Docker 会感知所有在这个网络下运行的容器，并且通过 <code>/etc/hosts</code> 文件将这些容器的地址保存到本地 DNS 中。</p><p><code>app</code> 网络内部的任何主机都可以使用 <code>hostname.app</code> 形式来被解析。</p><p>在宿主机下如:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ ping <span class="hljs-keyword">db</span>.<span class="hljs-keyword">app</span><br></code></pre></td></tr></table></figure><h4 id="将已有容器连接到-Docker-网络"><a href="#将已有容器连接到-Docker-网络" class="headerlink" title="将已有容器连接到 Docker 网络"></a>将已有容器连接到 Docker 网络</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ sudo docker network connect app db2<br></code></pre></td></tr></table></figure><p>这里 <code>app</code> 为网络名称，<code>db2</code> 为容器名称.</p><h4 id="断开一个容器与指定网络的链接"><a href="#断开一个容器与指定网络的链接" class="headerlink" title="断开一个容器与指定网络的链接"></a>断开一个容器与指定网络的链接</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ sudo docker network disconnect app db2<br></code></pre></td></tr></table></figure><p>一个容器可以同时隶属多个 Docker Networking.</p><h4 id="通过-Docker-link-连接容器"><a href="#通过-Docker-link-连接容器" class="headerlink" title="通过 Docker link 连接容器"></a>通过 Docker link 连接容器</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -p <span class="hljs-number">4567</span> --name webapp --link redis:db -t -i -v <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/webapp_redis:/</span>opt<span class="hljs-regexp">/webapp jamtur01/</span>sinatra <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><p><code>--link</code> 标志，用于创建两个容器间的客户-服务链接。其需要两个参数，前者是要链接的容器的名称，后一个是这个链接的别名。这里 <code>webapp</code> 是客户，<code>redis</code> 是”服务”.</p><p>通过把容器链接在一起，可以让客户容器直接访问任意服务容器的公开端口.</p><p>只有使用 <code>--link</code> 标志链接到这个容器的容器才能连接到这个端口。</p><p>可以把多个容器链接在一起:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ sudo docker run -p 4567 <span class="hljs-params">--name</span> webapp2 <span class="hljs-params">--link</span> redis<span class="hljs-function">:db</span> <span class="hljs-string">...</span><br>$ sudo docker run -p 4567 <span class="hljs-params">--name</span> webapp3 <span class="hljs-params">--link</span> redis<span class="hljs-function">:db</span> <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>在运行容器时指定 <code>--add-host</code> 选项，可以在 <code>/etc/hosts</code> 文件中添加相应的记录:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-built_in">run</span> -p 4567 <span class="hljs-attribute">--add-host</span>=docker:10.0.0.1 <span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure><p>在容器中可以用 <code>env</code> 命令查看新创建的环境变量的信息.</p><h3 id="5-2-7-使用容器连接来通信"><a href="#5-2-7-使用容器连接来通信" class="headerlink" title="5.2.7 使用容器连接来通信"></a>5.2.7 使用容器连接来通信</h3><h2 id="5-3-Docker-用于持续集成"><a href="#5-3-Docker-用于持续集成" class="headerlink" title="5.3 Docker 用于持续集成"></a>5.3 Docker 用于持续集成</h2><p>即在多开发者的持续集成测试场景中使用 Docker.</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker 学习</title>
    <link href="/2022/08/25/Docker-%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/08/25/Docker-%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="http://coolshell.cn/articles/17010.html">网博客1</a><br><a href="http://coolshell.cn/articles/17049.html">网博客2</a><br><a href="http://coolshell.cn/articles/17061.html">网博客3</a><br><a href="http://coolshell.cn/articles/17200.html">网博客4</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kvm, libvirt 和 qemu</title>
    <link href="/2022/08/25/kvm-libvirt-%E5%92%8C-qemu/"/>
    <url>/2022/08/25/kvm-libvirt-%E5%92%8C-qemu/</url>
    
    <content type="html"><![CDATA[<h1 id="查看是否支持虚拟化"><a href="#查看是否支持虚拟化" class="headerlink" title="查看是否支持虚拟化"></a>查看是否支持虚拟化</h1><p>使用:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ <span class="hljs-attribute">LC_ALL</span>=C lscpu |grep Virtualization<br></code></pre></td></tr></table></figure><p>若输出 <code>Virtualization:         VT-x</code> 即可。</p><p>或:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ <span class="hljs-keyword">grep</span> -Eoc <span class="hljs-string">&#x27;(vmx|svm)&#x27;</span> <span class="hljs-regexp">/proc/</span>cpuinfo<br></code></pre></td></tr></table></figure><p>输出大于0的数字.</p><h1 id="查看是否支持硬件加速"><a href="#查看是否支持硬件加速" class="headerlink" title="查看是否支持硬件加速"></a>查看是否支持硬件加速</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ sudo apt <span class="hljs-keyword">install</span> cpu-checker<br></code></pre></td></tr></table></figure><p>输入:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>kvm-ok<br></code></pre></td></tr></table></figure><p>若输出为:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">KVM acceleration can be used</span><br></code></pre></td></tr></table></figure><p>即表明支持。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> sudo apt install qemu qemu-kvm libvirt-deamon-<span class="hljs-keyword">system</span> libvirt-client virt-manager virtinst bridge-utils<br></code></pre></td></tr></table></figure><p>安装软件:</p><ul><li>qemu-kvm, 为 KVM 管理程序提供硬件仿真</li><li>libvirt 管理虚拟机和其他虚拟化功能的软件集合, 其包含一个 API 库，一个守护进程 (libvirtd) 和一个命令行工具 (virsh)</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>需把镜像文件放在 <code>/var/lib/libvirt/images</code> 中。</p><p>需要在 <code>virt-manager</code> 中添加一个叫做 <code>network</code> 的网络连接。</p><p>先创建一个虚拟机磁盘的镜像:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> qemu<span class="hljs-literal">-img</span> create <span class="hljs-operator">-f</span> qcow2 archlinux.qcow2 <span class="hljs-number">40</span>G<br></code></pre></td></tr></table></figure><p>通过脚本创建虚拟机:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ sudo virt-install <span class="hljs-attr">--name</span> archlinux <span class="hljs-attr">--os-variant</span>=archlinux <span class="hljs-attr">--memory</span> <span class="hljs-number">4096</span> <span class="hljs-attr">--vcpus</span> <span class="hljs-number">2</span> <span class="hljs-attr">--disk</span> path=./archlinux<span class="hljs-selector-class">.qcow2</span>,size=<span class="hljs-number">20</span> <span class="hljs-attr">--cdrom</span>=/var/lib/libvirt/images/archlinux-<span class="hljs-number">2022.08</span>.<span class="hljs-number">05</span>-x86_64<span class="hljs-selector-class">.iso</span>  <span class="hljs-attr">--boot</span> loader=/usr/share/qemu/OVMF<span class="hljs-selector-class">.fd</span> <span class="hljs-attr">--virt-type</span> kvm <span class="hljs-attr">--network</span> network=network,bridge=virbr1<br></code></pre></td></tr></table></figure><p>部分选项说明:</p><ul><li>–name, 创建虚拟机名称</li><li>–os-variant, 创建虚拟机类型</li><li>–memory, 虚拟机的内存大小</li><li>–vcpus, 虚拟机的 CPU 数量</li><li>–cdrom, 虚拟机的 CD, 可接 ISO 镜像路径</li><li>–disk path, 指定虚拟机硬盘路径</li><li>–disk path, 指定虚拟机硬盘大小，单位为 G</li><li>–boot, 指定启动的 BIOS, Archlinux 只支持 UEFI 启动</li><li>–virt-type, 选择 hypervisor, 如 kvm, qemu, xen 等</li><li>–network, 添加网卡</li></ul><p>若遇到 <code>cannot access storage file (as uid:107, gid:107) permission denied</code> 类似的报错, 修改 <code>/etc/libvirt/qemu.comf</code> 文件中:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta"># user = <span class="hljs-string">&quot;root&quot;</span></span><br><br><span class="hljs-meta"># group = <span class="hljs-string">&quot;root&quot;</span></span><br></code></pre></td></tr></table></figure><p>改为:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span><br><span class="hljs-attribute">group</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span><br></code></pre></td></tr></table></figure><p>若遇到 <code>You will need to grant the &#39;libvirt-qemu&#39; user search permissions for the following directories</code> 报错，是 <code>libvirt-qemu</code> 用户没有当前 qemu 文件所在位置用户的权限，将 <code>libvirt-qemu</code> 添加到当前的用户组即可, 即修改 <code>/etc/group</code> 文件。</p><h1 id="正式安装注意"><a href="#正式安装注意" class="headerlink" title="正式安装注意"></a>正式安装注意</h1><p>貌似必须得创建 <code>/boot</code> 分区。</p><h1 id="进入虚拟机后的配置"><a href="#进入虚拟机后的配置" class="headerlink" title="进入虚拟机后的配置"></a>进入虚拟机后的配置</h1><p>在设置里面搜索 “Display Configuration” 可以修改分辨率。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kde, kwin 和 krunner</title>
    <link href="/2022/08/25/kde-kwin-%E5%92%8C-krunner/"/>
    <url>/2022/08/25/kde-kwin-%E5%92%8C-krunner/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解决使用 startx 命令后无法更换壁纸</title>
    <link href="/2022/08/25/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8-startx-%E5%91%BD%E4%BB%A4%E5%90%8E%E6%97%A0%E6%B3%95%E6%9B%B4%E6%8D%A2%E5%A3%81%E7%BA%B8/"/>
    <url>/2022/08/25/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8-startx-%E5%91%BD%E4%BB%A4%E5%90%8E%E6%97%A0%E6%B3%95%E6%9B%B4%E6%8D%A2%E5%A3%81%E7%BA%B8/</url>
    
    <content type="html"><![CDATA[<p>无法在 <code>gnome-tweaks tool</code> 管理界面中更换，但可以直接在设置里面更换，或者右键更换。</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中查看模块或函数的文档</title>
    <link href="/2022/08/24/Python-%E4%B8%AD%E6%9F%A5%E7%9C%8B%E6%A8%A1%E5%9D%97%E6%88%96%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%87%E6%A1%A3/"/>
    <url>/2022/08/24/Python-%E4%B8%AD%E6%9F%A5%E7%9C%8B%E6%A8%A1%E5%9D%97%E6%88%96%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>常见的查询函数有 help(), dir() 和 print().</p><h1 id="使用-help"><a href="#使用-help" class="headerlink" title="使用 help()"></a>使用 help()</h1><p>首先进入交互界面并输入 <code>help()</code>:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl">$ python3<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">help</span>()</span><br></code></pre></td></tr></table></figure><p>就会出现:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">help</span>&gt;<br></code></pre></td></tr></table></figure><p>输入 modules, 就会显示所有的模块:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">help</span>&gt; modules<br></code></pre></td></tr></table></figure><p>若查看某一个函数，在 Python 交互界面下:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">help</span>(requests.get)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><p>输入具体的 modules name, 就可以查看. 输入 <code>q</code> 可以退出。</p><h1 id="使用-dir"><a href="#使用-dir" class="headerlink" title="使用 dir()"></a>使用 dir()</h1><p>同样在 Python 的交互界面，需要先 <code>import</code> 再查看:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> requests</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">dir</span>(requests)</span><br></code></pre></td></tr></table></figure><p>会显示该模块的所有关键词。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中的 yeild 的用法</title>
    <link href="/2022/08/24/Python-%E4%B8%AD%E7%9A%84-yeild-%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2022/08/24/Python-%E4%B8%AD%E7%9A%84-yeild-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>可以把 yield 视为 return. 但是，带有 yeild 的函数会被当做一个生成器，而不再是一个普通函数。</p><p>这个函数可以与 <code>next()</code> 函数配合使用，在下一次执行时会沿着上一次 yeild 停止处开始。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 的 logging 库</title>
    <link href="/2022/08/24/Python-%E7%9A%84-logging-%E5%BA%93/"/>
    <url>/2022/08/24/Python-%E7%9A%84-logging-%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>logging 在这里是”日志”的含义。</p><p>日志是用来记录程序运行事件的工具。</p><h1 id="什么时候使用-logging-包"><a href="#什么时候使用-logging-包" class="headerlink" title="什么时候使用 logging 包"></a>什么时候使用 logging 包</h1><p>日志函数的命名依据于<strong>事件级别</strong>:</p><ul><li>DEBUG, 通常用在调试时输出详细信息</li><li>INFO，确认函数在正常运行</li><li>WARNING, 在程序依旧能够正常运行的情况下，记录某个期望外的运行事件或记录一些达到临界值的运行信息</li><li>ERROR, 因为某些严重的运行错误，影响程序的某些功能使用</li><li>CRITICAL, 运行错误存在导致程序不能继续运行的场景<br>默认的事件级别为 WARNING, 只有事件级别高于 WARNING 才会被捕捉。</li></ul><p>可以显示设置日志级别。</p><h1 id="把日志写入文件"><a href="#把日志写入文件" class="headerlink" title="把日志写入文件"></a>把日志写入文件</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import<span class="hljs-built_in"> logging</span><br><span class="hljs-built_in"></span><br>logging.basicConfig(<span class="hljs-attribute">filename</span>=<span class="hljs-string">&#x27;example.log&#x27;</span>, <span class="hljs-attribute">level</span>=logging.DEBUG) # 指定了文件名以及等级<br>logging.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&#x27;This message should go to the log file&#x27;</span>)<br>logging.<span class="hljs-built_in">info</span>(<span class="hljs-string">&#x27;So should this&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>basicConfig()</code> 函数仅在第一次调用时生效。 </p><p>在命令行配置日志级别:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">--<span class="hljs-built_in">log</span>=<span class="hljs-built_in">INFO</span><br></code></pre></td></tr></table></figure><h1 id="记录变量信息"><a href="#记录变量信息" class="headerlink" title="记录变量信息"></a>记录变量信息</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import<span class="hljs-built_in"> logging</span><br><span class="hljs-built_in"></span><br>logging.<span class="hljs-built_in">warning</span>(<span class="hljs-string">&#x27;%s before you %s&#x27;</span>, <span class="hljs-string">&#x27;Look&#x27;</span>, <span class="hljs-string">&#x27;Leap!&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="自定义日志信息的格式"><a href="#自定义日志信息的格式" class="headerlink" title="自定义日志信息的格式"></a>自定义日志信息的格式</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> logging<br><br>logging.basicConfig(<span class="hljs-keyword">format</span>=<span class="hljs-string">&#x27;%(levelname)s:%(message)s&#x27;</span>, <span class="hljs-keyword">level</span>=logging.<span class="hljs-keyword">DEBUG</span>) # 利用 <span class="hljs-keyword">format</span> 参数<br></code></pre></td></tr></table></figure><h1 id="展示时间信息"><a href="#展示时间信息" class="headerlink" title="展示时间信息"></a>展示时间信息</h1><p>增加 <code>%(asctime)s</code> 来让你的程序输出时间信息。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import<span class="hljs-built_in"> logging</span><br><span class="hljs-built_in"></span><br>logging.basicConfig(<span class="hljs-attribute">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(message)s&#x27;</span>)<br></code></pre></td></tr></table></figure><p>自定义时间格式:</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">logging.basicConfig(format=&#x27;%(asctime)<span class="hljs-keyword">s</span> %(message)<span class="hljs-keyword">s</span>&#x27;, datefmt=&#x27;<span class="hljs-built_in">%m</span>/<span class="hljs-built_in">%d</span>/<span class="hljs-built_in">%Y</span> <span class="hljs-built_in">%I</span>:<span class="hljs-built_in">%M</span>:<span class="hljs-built_in">%S</span> <span class="hljs-built_in">%p</span>&#x27;) # 传入 datefmt 参数<br></code></pre></td></tr></table></figure><h1 id="error-方法"><a href="#error-方法" class="headerlink" title="error 方法"></a>error 方法</h1><p>将 error 方法里的 exc_info 参数设置为 Ture, 可以打印出 Traceback 错误堆栈信息。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>鸟哥的 Linux 私房菜 Notes</title>
    <link href="/2022/08/24/%E9%B8%9F%E5%93%A5%E7%9A%84-Linux-%E7%A7%81%E6%88%BF%E8%8F%9C-Notes/"/>
    <url>/2022/08/24/%E9%B8%9F%E5%93%A5%E7%9A%84-Linux-%E7%A7%81%E6%88%BF%E8%8F%9C-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第6章-Linux-文件与目录管理"><a href="#第6章-Linux-文件与目录管理" class="headerlink" title="第6章 Linux 文件与目录管理"></a>第6章 Linux 文件与目录管理</h1><h2 id="6-4-文件与目录的默认权限与隐藏权限"><a href="#6-4-文件与目录的默认权限与隐藏权限" class="headerlink" title="6.4 文件与目录的默认权限与隐藏权限"></a>6.4 文件与目录的默认权限与隐藏权限</h2><h3 id="6-4-3-文件特殊权限-SUID-SGID-SBIT"><a href="#6-4-3-文件特殊权限-SUID-SGID-SBIT" class="headerlink" title="6.4.3 文件特殊权限: SUID, SGID, SBIT"></a>6.4.3 文件特殊权限: SUID, SGID, SBIT</h3><h4 id="Set-UID"><a href="#Set-UID" class="headerlink" title="Set UID"></a>Set UID</h4><h1 id="第13章-Linux-账号管理与-ACL-权限设置"><a href="#第13章-Linux-账号管理与-ACL-权限设置" class="headerlink" title="第13章 Linux 账号管理与 ACL 权限设置"></a>第13章 Linux 账号管理与 ACL 权限设置</h1><h2 id="13-1-Linux-的账号与用户组"><a href="#13-1-Linux-的账号与用户组" class="headerlink" title="13.1 Linux 的账号与用户组"></a>13.1 Linux 的账号与用户组</h2><h3 id="13-1-1-用户标识符-UID-与-GID"><a href="#13-1-1-用户标识符-UID-与-GID" class="headerlink" title="13.1.1 用户标识符: UID 与 GID"></a>13.1.1 用户标识符: UID 与 GID</h3><p>账号的 ID 与 账号的对应在 <code>/etc/passwd</code> 中。</p><p>每个登录的用户至少都会获取两个 ID, 一个是用户 ID (User ID, UID), 一个是用户组 ID (Group ID, GID).</p><h3 id="13-1-2-用户账号"><a href="#13-1-2-用户账号" class="headerlink" title="13.1.2 用户账号"></a>13.1.2 用户账号</h3><p>输入账号和密码后，系统的处理:</p><ol><li>先查找 <code>/etc/passwd</code> 里面是否有你输入的账号，如果有，则将账号对应的 UID 和 GID (在 <code>/etc/group</code> 中) 读出, 并将家目录与 Shell 设置也读出.</li><li>再来核对密码表。这时 Linux 会进入 <code>/etc/shadow</code> 里面找出对应的账号与 UID.</li><li>如果一切正常，则进入 shell 管理阶段。</li></ol><p>对 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 的详细说明可见 <code>man 5 passwd</code> 和 <code>man 5 shadow</code>.</p><h4 id="etc-passwd-文件结构"><a href="#etc-passwd-文件结构" class="headerlink" title="/etc/passwd 文件结构"></a><code>/etc/passwd</code> 文件结构</h4><p>有七部分内容，用 <code>:</code> 隔开:</p><ol><li>账号名称</li><li>密码</li><li>UID</li><li>GID</li><li>用户信息说明栏</li><li>家目录, 当账户登录时就会进入的目录</li><li>shell</li></ol><h4 id="etc-shadow-文件结构"><a href="#etc-shadow-文件结构" class="headerlink" title="/etc/shadow 文件结构"></a><code>/etc/shadow</code> 文件结构</h4><p>同样以 <code>:</code> 分隔，共有九个字段:</p><ol><li>账户名称</li><li>密码</li><li>最近修改密码的日期, 其计算的天数从 1971-1-1 开始</li><li>密码不可被修改的天数</li><li>密码需要重新修改的天数</li><li>密码需要修改期限前的警告天数</li><li>密码过期后的账号宽限时间</li><li>账号失效日期</li><li>保留</li></ol><p>root 密码忘记的解决办法:</p><ul><li>重新启动后进入单人维护模式</li><li>以 Live CD 启动后挂载根目录去修改 <code>/etc/shadow</code></li></ul><p>查看 shadow 是使用哪种加密的机制:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">authconfig --<span class="hljs-built_in">test</span> |grep hasing</span><br></code></pre></td></tr></table></figure><h3 id="13-1-3-关于用户组-有效与初始用户组-groups-newgr"><a href="#13-1-3-关于用户组-有效与初始用户组-groups-newgr" class="headerlink" title="13.1.3 关于用户组: 有效与初始用户组, groups, newgr"></a>13.1.3 关于用户组: 有效与初始用户组, groups, newgr</h3><p>两个文件 <code>/etc/group</code> 和 <code>/etc/gshadow</code>.</p><h4 id="etc-group-文件结构"><a href="#etc-group-文件结构" class="headerlink" title="/etc/group 文件结构"></a><code>/etc/group</code> 文件结构</h4><ol><li>组名</li><li>用户组密码</li><li>GID</li><li>此用户组主持的账号名称</li></ol><h4 id="有效用户组-effective-group-和初始用户组-initial-group"><a href="#有效用户组-effective-group-和初始用户组-initial-group" class="headerlink" title="有效用户组 (effective group) 和初始用户组 (initial group)"></a>有效用户组 (effective group) 和初始用户组 (initial group)</h4><p>初始用户组 (<code>/etc/passwd</code> 中的第4字段) 在用户一登录就会主动获取，不需要在 <code>/etc/group</code> 的第四个字段内写入该账号。</p><p>通常有效用户组的作用就是新建文件, 一个账号新建的文件，其所属用户组为有效用户组.</p><p>通过 <code>groups</code> 命令查看，第一个输出即为有效用户组，后面的为用户所属的其他用户组.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">groups</span></span><br></code></pre></td></tr></table></figure><h4 id="newgrp-有效用户组的切换"><a href="#newgrp-有效用户组的切换" class="headerlink" title="newgrp: 有效用户组的切换"></a>newgrp: 有效用户组的切换</h4><p>你想要切换的用户组必须是你已经有支持的用户组。</p><p>这个命令可以修改目前用户的有效用户组，而且使用另一个 shell 提供此功能。用户的环境设置不会有影响，但是其用户组权限会重新计算。</p><h4 id="etc-gshadow-文件结构"><a href="#etc-gshadow-文件结构" class="headerlink" title="/etc/gshadow 文件结构"></a><code>/etc/gshadow</code> 文件结构</h4><ol><li>组名</li><li>密码栏</li><li>用户组管理员账号</li><li>有加入该用户组支持的所属账号<br>gshadow 的最大功能是建立用户组管理员。</li></ol><h2 id="13-2-账号管理"><a href="#13-2-账号管理" class="headerlink" title="13.2 账号管理"></a>13.2 账号管理</h2><h3 id="13-2-1-新增与删除用户-useradd-相关配置文件，passwd-usermod-userdel"><a href="#13-2-1-新增与删除用户-useradd-相关配置文件，passwd-usermod-userdel" class="headerlink" title="13.2.1 新增与删除用户: useradd, 相关配置文件，passwd, usermod, userdel"></a>13.2.1 新增与删除用户: useradd, 相关配置文件，passwd, usermod, userdel</h3><h4 id="useradd-参考文件"><a href="#useradd-参考文件" class="headerlink" title="useradd 参考文件"></a>useradd 参考文件</h4><p>useradd 的默认值查看:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># useradd -D</span><br></code></pre></td></tr></table></figure><p>其内容位于 <code>/etc/default/useradd</code></p><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># passwd</span><br></code></pre></td></tr></table></figure><p>后面不接账号就是修改自己的密码。</p><p>利用 standard input 建立用户的密码:</p><h4 id="change"><a href="#change" class="headerlink" title="change"></a>change</h4><p>显示纤细的密码参数:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># change -l 账号名</span><br></code></pre></td></tr></table></figure><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>对账号设置进行调整.</p><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>删除用户的相关数据。</p><h3 id="13-2-2-用户功能"><a href="#13-2-2-用户功能" class="headerlink" title="13.2.2 用户功能"></a>13.2.2 用户功能</h3><h4 id="chsh"><a href="#chsh" class="headerlink" title="chsh"></a>chsh</h4><p>change shell 的简写。<br>选项及参数:</p><ul><li><code>-l</code>, 列出目前系统上可用的 shell</li><li><code>-s</code>, 设置修改自己的 shell<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;abc543cc&quot;</span> | passwd --stdin vbird2</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="第15章-计划任务-crontab"><a href="#第15章-计划任务-crontab" class="headerlink" title="第15章 计划任务(crontab)"></a>第15章 计划任务(crontab)</h1><h2 id="15-1-什么是计划任务"><a href="#15-1-什么是计划任务" class="headerlink" title="15.1 什么是计划任务"></a>15.1 什么是计划任务</h2><h3 id="15-1-1-Linux-计划任务的种类-at-cron"><a href="#15-1-1-Linux-计划任务的种类-at-cron" class="headerlink" title="15.1.1 Linux 计划任务的种类: at, cron"></a>15.1.1 Linux 计划任务的种类: at, cron</h3><ul><li>at, 处理仅执行一次就结束的任务，即突发性任务, 需 atd 服务</li><li>cron, 所设置的任务会循环的执行，即例行任务，每隔一段时间就执行，需 crond 服务</li></ul><h2 id="15-2-仅执行一次的计划任务"><a href="#15-2-仅执行一次的计划任务" class="headerlink" title="15.2 仅执行一次的计划任务"></a>15.2 仅执行一次的计划任务</h2><h3 id="15-2-1-atd-的启动和-at-的运行方式"><a href="#15-2-1-atd-的启动和-at-的运行方式" class="headerlink" title="15.2.1 atd 的启动和 at 的运行方式"></a>15.2.1 atd 的启动和 at 的运行方式</h3><p>在 Ubuntu 下安装 atd 服务:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">sudo apt update<br>sudo apt <span class="hljs-keyword">install </span><span class="hljs-built_in">at</span><br></code></pre></td></tr></table></figure><p>手动启动:</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl restart atd<br>sudo <span class="hljs-params">system</span>ctl enable atd<br>sudo <span class="hljs-params">system</span>ctl status atd<br></code></pre></td></tr></table></figure><h4 id="at-的运行方式"><a href="#at-的运行方式" class="headerlink" title="at 的运行方式"></a>at 的运行方式</h4><p>使用 <code>at</code> 命令来产生所要运行的任务，并以文本文件的方式写入 <code>/var/spool/at</code> 目录内等待 atd 服务的执行。</p><p>可以利用 <code>/etc/at.allow</code> 和 <code>/etc/at.deny</code> 两个文件实现对 at 的限制。</p><p>添加后的工作情况为:</p><ol><li>先找寻 <code>/etc/at.allow</code> 文件，写在这个文件的用户才能使用 at</li><li>如果 <code>/etc/at.allow</code> 文件不存在，则找寻 <code>/etc/at.deny</code> 文件，写在 <code>/etc/at.deny</code> 中的用户不能使用 at</li><li>如果两个文件都不存在，那么只有 root 用户可以使用 at 命令</li></ol><p>不希望某些用户使用 at，就将那个用户的账号写入 <code>/etc/at.deny</code>, 一个账号写一行。</p><h3 id="15-2-2-实际运行单一计划任务"><a href="#15-2-2-实际运行单一计划任务" class="headerlink" title="15.2.2 实际运行单一计划任务"></a>15.2.2 实际运行单一计划任务</h3><p>使用:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">at <span class="hljs-selector-attr">[-mldv]</span> <span class="hljs-selector-tag">TIME</span><br></code></pre></td></tr></table></figure><p>at 命令的选项和参数:</p><ul><li>-m : 应该是 mail, 当 at 的任务完成后，即便没有输出信息，也会发送 email 通知</li><li>-l : 应该是 list, <code>at -l</code> 相当于 <code>atq</code>, 列出目前系统上所有该使用者的 at 计划</li><li>-d : 应该是 delete, <code>at -d</code> 相当于 <code>atrm</code>, 可以取消一个在 <code>at</code> 计划中的任务</li><li>-c : 应该是 code, 可以列出后面接的该项任务的实际命令内容</li></ul><p>最重要的是 <code>TIME</code> 参数, 其格式为:</p><ul><li>HH:MM</li><li>HH:MM YYYY-MM-DD</li><li>HH:MM[am|pm] [Mouth] [Date]</li><li>HH:MM[am|pm] + number [minutes|hours|days|weeks]<br>可以有 <code>now + ...</code> 方式。</li></ul><p>使用 at 时会进入 at shell 的环境执行命令，所以命令最好用绝对路径。</p><p>at 的执行和终端环境无关，如果要显示 Hello:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;Hello&quot;</span> &gt; <span class="hljs-regexp">/dev/</span>tty1<br></code></pre></td></tr></table></figure><p>即通过终端设备处理.</p><p>由于 at 计划任务的使用，系统会将该项 at 任务独立出你的 bash 环境，直接交给系统的 atd 程序来接管。</p><h4 id="at-任务的管理"><a href="#at-任务的管理" class="headerlink" title="at 任务的管理"></a>at 任务的管理</h4><p>使用 <code>atq</code> 查询，<code>atrm</code> 删除。</p><h4 id="batch-系统有空时才执行后台任务"><a href="#batch-系统有空时才执行后台任务" class="headerlink" title="batch: 系统有空时才执行后台任务"></a>batch: 系统有空时才执行后台任务</h4><p>batch 命令也是调用 at 来执行。</p><p>它是在 CPU 任务负载小于 0.8 时才执行你的任务。</p><p>任务负载，即 CPU 在单一时间点所负责的任务数量, 而不是 CPU 的使用率。</p><p>CPU 的任务负载大，代表 CPU 必须要在不同的任务之间执行频繁的任务切换。</p><p>不论是 crontab 还是 at, 其最小单位都是分钟，即它们的任务都是”每分钟检查一次”来处理。</p><h2 id="15-3-循环执行的计划任务"><a href="#15-3-循环执行的计划任务" class="headerlink" title="15.3 循环执行的计划任务"></a>15.3 循环执行的计划任务</h2><h3 id="15-3-1-用户的设置"><a href="#15-3-1-用户的设置" class="headerlink" title="15.3.1 用户的设置"></a>15.3.1 用户的设置</h3><p>建立循环任务需使用 <code>crontab</code> 这个命令。</p><p>配置文件有:</p><ul><li><code>/etc/cron.allow</code></li><li><code>/etc/cron.deny</code><br>前者的优先级同样高于后者。</li></ul><p>使用 <code>crontab</code> 建立计划任务之后，该项任务会被记录到 <code>/var/spool/cron/dmtsai</code> 中。<code>cron</code> 每执行一项任务都会被记录到 <code>/var/log/cron</code> 这个日志文件中。</p><p>语法:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">crontab [-u username] [-l|<span class="hljs-type">-e</span>|<span class="hljs-type">-r</span>]<br></code></pre></td></tr></table></figure><p>选项和参数:</p><ul><li>-u : 只有 root 才能执行这个任务，或者帮其他使用者建立&#x2F;删除 crontab 任务</li><li>-e : edit, 编辑 crontab 任务内容</li><li>-l : list, 查看 crontab 任务内容</li><li>-r : remove, 删除所有的 crontab 任务内容，若仅删除一项，使用 <code>-e</code> 选项<br>每项任务(即每行)都有六个字段:</li><li>分钟, 0~59</li><li>小时, 0~23</li><li>日期, 1~31</li><li>月份, 1~12</li><li>周, 0~7</li><li>命令<br>几个特殊字符:</li><li><code>*</code>, 任何时候</li><li><code>,</code>, 分隔时段</li><li><code>-</code>, 一段时间</li><li><code>/n</code>, 每隔 n 个单位</li></ul><h3 id="15-3-2-系统的配置文件"><a href="#15-3-2-系统的配置文件" class="headerlink" title="15.3.2 系统的配置文件"></a>15.3.2 系统的配置文件</h3><p><code>crontab -e</code> 这个 crontab 是 <code>/usr/bin/crontab</code> 这个可执行文件。</p><p><code>/etc/crontab</code> 是一个文本文件。</p><p>cron 会每分钟去读取一次 <code>/etc/crontab</code> 和 <code>/var/spool/cron</code> 文件。</p><p>由于 cron 是读取到内存当中，所以在修改完 <code>/etc/crontab</code> 这个文件后，可能不会立即执行，这个时候需要重启 crond 服务: <code>sudo systemctl restart crond</code>.</p><h3 id="15-3-3-一些注意事项"><a href="#15-3-3-一些注意事项" class="headerlink" title="15.3.3 一些注意事项"></a>15.3.3 一些注意事项</h3><h2 id="15-4-可唤醒停机期间的工作任务"><a href="#15-4-可唤醒停机期间的工作任务" class="headerlink" title="15.4 可唤醒停机期间的工作任务"></a>15.4 可唤醒停机期间的工作任务</h2><p><code>anacron</code> 命令，执行时间到了但却没有执行的计划任务。</p><h3 id="15-4-1-什么是-anacron"><a href="#15-4-1-什么是-anacron" class="headerlink" title="15.4.1 什么是 anacron"></a>15.4.1 什么是 anacron</h3><p>anacron 也是每小时被 crond 执行一次，然后 anacron 再去检测相关的计划任务有没有被执行，如果有超过期限的任务在，就执行该任务，执行完毕或无需执行任何任务时，anacron 就停止。</p><h1 id="第16章-进程管理与-SELinux-初探"><a href="#第16章-进程管理与-SELinux-初探" class="headerlink" title="第16章 进程管理与 SELinux 初探"></a>第16章 进程管理与 SELinux 初探</h1><p>Linux  得程序通常称为 fork-and-exec 的流程。</p><p>进程都会借由父进程以复制 (fork) 的方式产生一个一模一样的子进程，然后被复制出来的子进程再以 exec 的方式执行实际要执行的进程，最终就成为一个子进程。</p><p>常驻在内存当中的进程通常都是负责一些系统所提供的功能以服务用户的各项任务，因此这些常驻程序就被称为: 服务 (daemon).</p><h2 id="16-1-2-Linux-的多人多任务环境"><a href="#16-1-2-Linux-的多人多任务环境" class="headerlink" title="16.1.2 Linux 的多人多任务环境"></a>16.1.2 Linux 的多人多任务环境</h2><p>在 Linux 下执行一个命令时，系统会将相关的权限、属性、进程代码与数据等均加载到内存，并基于这些进程一个进程标识符(PID), 最终该命令可以执行的任务则与这个 PID 的权限有关。</p><h3 id="多重登录环境的七个基本终端界面"><a href="#多重登录环境的七个基本终端界面" class="headerlink" title="多重登录环境的七个基本终端界面"></a>多重登录环境的七个基本终端界面</h3><p>Linux 会默认启动六个终端登录环境的进程。</p><h2 id="16-2-任务管理-job-control"><a href="#16-2-任务管理-job-control" class="headerlink" title="16.2 任务管理 (job control)"></a>16.2 任务管理 (job control)</h2><h3 id="16-2-1-什么是任务管理"><a href="#16-2-1-什么是任务管理" class="headerlink" title="16.2.1 什么是任务管理"></a>16.2.1 什么是任务管理</h3><p>放入后台的任务是不可以用 <code>ctrl + c</code> 终止的。</p><h3 id="16-2-2-job-control-的管理"><a href="#16-2-2-job-control-的管理" class="headerlink" title="16.2.2 job control 的管理"></a>16.2.2 job control 的管理</h3><p>bash 只能够管理自己的任务而不能管理其他 bash 的任务。</p><p>在命令后加上 <code>&amp;</code> 代表将该命令丢到后台中，此时 bash 会给予这个命令一个任务号码 (job number).</p><p>利用数据流重定向处理输出信息:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ tar -zpcvf <span class="hljs-regexp">/tmp/</span>tec.tar.gz <span class="hljs-regexp">/etc &gt; /</span>tmp/log.txt <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> &amp;<br></code></pre></td></tr></table></figure><h4 id="将目前任务丢到后台中暂停-–-ctrl-z"><a href="#将目前任务丢到后台中暂停-–-ctrl-z" class="headerlink" title="将目前任务丢到后台中暂停 – ctrl + z"></a>将目前任务丢到后台中暂停 – ctrl + z</h4><p>默认情况下，使用 [ctrl+z] 丢到后台的程序都是暂停状态。</p><h4 id="查看目前后台任务状态"><a href="#查看目前后台任务状态" class="headerlink" title="查看目前后台任务状态"></a>查看目前后台任务状态</h4><p>使用 <code>jobs</code> 命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">jobs</span> [-lrs]</span><br></code></pre></td></tr></table></figure><p>几个参数:</p><ul><li>-l : 除了列出 job number 与命令串外，同时列出 PID 号码</li><li>-r : 仅列出正在后台 run 的任务</li><li>-s : 仅列出正在后台 stop 的任务<br>使用 <code>jobs -l</code> 后，观察 <code>+</code> <code>-</code> 号，其中 <code>+</code> 代表默认的使用任务，也就是说仅输入 <code>fg</code> 就会被拿到前台中来处理.</li></ul><h4 id="将后台任务拿到前台处理：-fg"><a href="#将后台任务拿到前台处理：-fg" class="headerlink" title="将后台任务拿到前台处理： fg"></a>将后台任务拿到前台处理： fg</h4><p>fg 即 foreground.</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">fg %</span>jobnumber<br></code></pre></td></tr></table></figure><p><code>jobnumber</code> 是任务号码，前面的 <code>%</code> 可有可无。</p><h4 id="让任务在后台下的状态变成运行中-bg"><a href="#让任务在后台下的状态变成运行中-bg" class="headerlink" title="让任务在后台下的状态变成运行中: bg"></a>让任务在后台下的状态变成运行中: bg</h4><p>让 <code>Stopped</code> 的任务变为 <code>Running</code>.</p><h4 id="管理后台当中的任务：kill"><a href="#管理后台当中的任务：kill" class="headerlink" title="管理后台当中的任务：kill"></a>管理后台当中的任务：kill</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">kill</span> <span class="hljs-literal">-signal</span> %jobnumber<br><span class="hljs-variable">$</span> <span class="hljs-built_in">kill</span> <span class="hljs-literal">-l</span><br></code></pre></td></tr></table></figure><p>选项和参数:</p><ul><li>-l : 列出目前 kill 能够使用的信号 (signal) 有哪些</li><li>signal : 代表给予后面接的那个任务什么样的指示，可以用 <code>man 7 signal</code> 查询</li><li>-1 : 重新读取一次参数的配置文件</li><li>-2 : 代表由键盘输入 [ctrl]-c 同样的操作</li><li>-9 : 立即强制删除一个任务</li><li>-15 : 以正常方式终止一项任务</li></ul><h3 id="16-2-3-脱机管理问题"><a href="#16-2-3-脱机管理问题" class="headerlink" title="16.2.3 脱机管理问题"></a>16.2.3 脱机管理问题</h3><p>任务管理中的后台是 bash 的后台，而不是系统的后台。</p><p>使用 <code>nohup</code> 命令, 其可以在脱机或注销系统后，还能够让任务继续执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> [命令与参数] &lt;== 在终端前台中的任务</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> [命令与参数] &lt;== 在终端后台中的任务</span><br></code></pre></td></tr></table></figure><p><code>nohug</code> 命令并不支持 bash 的内置命令。</p><p>使用 <code>nohug</code> 的信息输出会被重定向到 <code>~/nohup.out</code></p><h2 id="16-3-进程管理"><a href="#16-3-进程管理" class="headerlink" title="16.3 进程管理"></a>16.3 进程管理</h2><h3 id="16-3-1-查看进程"><a href="#16-3-1-查看进程" class="headerlink" title="16.3.1 查看进程"></a>16.3.1 查看进程</h3><p><code>ps</code> 命令的两个常用选项:</p><ul><li><code>ps -l</code> : 查看自己 bash 的进程</li><li><code>ps aux</code> : 查看所有系统运行的进程</li></ul><p>一般来说 <code>ps aux</code> 会按照 PID 的顺序来排序显示。</p><p>如果你发现某个进程的 CMD 后面接上了 <defunct> 时，就代表该进程是僵尸进程。</p><h4 id="top-动态查看进程的变化"><a href="#top-动态查看进程的变化" class="headerlink" title="top : 动态查看进程的变化"></a>top : 动态查看进程的变化</h4><p>使用方式:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">$ <span class="hljs-built_in">top</span> [-d数字] | <span class="hljs-type">top</span> [-bnp]<br></code></pre></td></tr></table></figure><p>参数和选项:</p><ul><li><code>-d</code> : 后面接秒数，就是整个进程界面更新的秒数。默认是5秒</li><li><code>-b</code> : 以批量的方式执行 top, 通常搭配数据流重定向来将批量的结果输出为文件</li><li><code>-n</code> : 与 <code>-b</code> 搭配，表示执行几次 top 的输出结果</li><li><code>-p</code> : 指定某个 PID 来执行查看监测<br><code>top</code> 默认使用 CPU 使用率作为排序依据，可换。</li></ul><h4 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ pstree <span class="hljs-comment">[-A|U]</span> <span class="hljs-comment">[-up]</span><br></code></pre></td></tr></table></figure><p>选项与参数:</p><ul><li>-A : 各进程树之间的连接以 ASCII 的方式 </li><li>-U : 各进程树之间的连接以 Unicode 的方式 </li><li>-p : 同时列出每个进程的 PID</li><li>-A : 同时列出每个进程的所属账号名称</li></ul><h3 id="16-3-2-进程的管理"><a href="#16-3-2-进程的管理" class="headerlink" title="16.3.2 进程的管理"></a>16.3.2 进程的管理</h3><p>进程的管理是通过给予该进程一个信号 (signal) 去告知该进程你想要让它做什么。</p><p>主要信号的代号、名称及内容:</p><ul><li>1 SIGHUP 启动被终止的进程，可让该 PID 重新读取自己的配置文件</li><li>2 SIGINT 相当于键盘输入 [ctrl]-c 来终止一个进程</li><li>9 SIGKILL 强制中断一个进程的执行</li><li>15 SIGTERM 以正常方式结束进程的方式终止进程</li><li>19 SIGSTOP 相当于键盘输入 [ctrl]-z 来暂停一个进程<br>使用:<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">kill</span> <span class="hljs-literal">-signal</span> PID<br></code></pre></td></tr></table></figure></li></ul><h4 id="通过命令的内容来终止进程-–-killall"><a href="#通过命令的内容来终止进程-–-killall" class="headerlink" title="通过命令的内容来终止进程 – killall"></a>通过命令的内容来终止进程 – killall</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ killall <span class="hljs-comment">[-iIe]</span> <span class="hljs-comment">[-signal]</span> <span class="hljs-comment">[command name]</span><br></code></pre></td></tr></table></figure><p>参数:</p><ul><li><code>-i</code> : interactive, 在删除时会出现提示字符</li><li><code>-I</code> : 忽略大小写</li><li><code>-e</code> : exact, 表示接完整命令，但不能超过 15 个字符, 如 <code>/bin.bash</code> 是完整的，<code>bash</code> 不算完整</li></ul><p>其可以将系统当中所有以某个命令启动的进程全部删除。</p><h3 id="16-3-3-关于进程的执行顺序"><a href="#16-3-3-关于进程的执行顺序" class="headerlink" title="16.3.3 关于进程的执行顺序"></a>16.3.3 关于进程的执行顺序</h3><p>需考虑进程的优先级 (priority) 和 CPU 调度。</p><h4 id="Priority-和-Nice-值"><a href="#Priority-和-Nice-值" class="headerlink" title="Priority 和 Nice 值"></a>Priority 和 Nice 值</h4><p>Linux 给予进程一个优先级 (Priority, PRI), PRI 值越低代表越优先.</p><p>如果要调整进程的优先级，就要通过 nice 值，即 NI.</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">PRI <span class="hljs-comment">(new)</span> = PRI <span class="hljs-comment">(old)</span> + <span class="hljs-symbol">NI</span><br></code></pre></td></tr></table></figure><p>注意项:</p><ul><li>nice 值可调整范围为 -20 ~ 19</li><li>root 可随意调整自己或它人的进程的 nice 值，且范围为 -20 ~ 19</li><li>一般用户仅可调整自己进程的 nice 值，且范围为 0 ~ 19</li><li>一般用户仅可将 nice 值调高</li></ul><h4 id="nice-新执行的命令即给予-nice-值"><a href="#nice-新执行的命令即给予-nice-值" class="headerlink" title="nice : 新执行的命令即给予 nice 值"></a>nice : 新执行的命令即给予 nice 值</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nice</span> [-n 数字] <span class="hljs-built_in">command</span></span><br></code></pre></td></tr></table></figure><h4 id="renice-已存在的进程的-nice-重新调整"><a href="#renice-已存在的进程的-nice-重新调整" class="headerlink" title="renice : 已存在的进程的 nice 重新调整"></a>renice : 已存在的进程的 nice 重新调整</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ renice [<span class="hljs-built_in">number</span>] PID<br></code></pre></td></tr></table></figure><h3 id="16-3-4-查看系统资源信息"><a href="#16-3-4-查看系统资源信息" class="headerlink" title="16.3.4 查看系统资源信息"></a>16.3.4 查看系统资源信息</h3><ul><li>free，查看内存使用情况</li><li>uname, 查看系统与内核相关信息</li><li>uptime，查看系统启动时间与任务负载</li><li>netstat，追踪网络或 socket 文件</li><li>dmesg, 分析内核产生的信息</li><li>vmstat, 检测系统资源变化</li></ul><h2 id="16-4-特殊文件与进程"><a href="#16-4-特殊文件与进程" class="headerlink" title="16.4 特殊文件与进程"></a>16.4 特殊文件与进程</h2><h3 id="16-4-1-具有-SUID-x2F-SGID-权限的命令执行状态"><a href="#16-4-1-具有-SUID-x2F-SGID-权限的命令执行状态" class="headerlink" title="16.4.1 具有 SUID&#x2F;SGID 权限的命令执行状态"></a>16.4.1 具有 SUID&#x2F;SGID 权限的命令执行状态</h3><p>SUID 特点:</p><ul><li>SUID 权限仅对二进制程序有效</li><li>执行这对于该程序需要具有 x 的可执行权限</li><li>本权限仅在执行该程序的过程中有效 (run-time)</li><li>执行者将具有该程序拥有者的权限<br>查询整个系统的 SUID&#x2F;SGID 的文件:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ <span class="hljs-keyword">find</span> <span class="hljs-regexp">/ -perm /</span><span class="hljs-number">6000</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="16-4-2-proc-代表的含义"><a href="#16-4-2-proc-代表的含义" class="headerlink" title="16.4.2 /proc/* 代表的含义"></a>16.4.2 <code>/proc/*</code> 代表的含义</h3><p>进程都是在内存中的，而内存中的数据又都是写入到 <code>/proc/*</code> 这个目录下的. 主机上面的各个进程的 PID 都以目录的形式存在于 <code>/proc</code> 中。</p><p><code>/proc</code> 目录下的文件，相关的文件对应相关的内容。</p><h3 id="16-4-3-查询已使用文件或已执行进程使用的文件"><a href="#16-4-3-查询已使用文件或已执行进程使用的文件" class="headerlink" title="16.4.3 查询已使用文件或已执行进程使用的文件"></a>16.4.3 查询已使用文件或已执行进程使用的文件</h3><h4 id="fuser-借由文件-或文件系统-找出正在使用该文件的进程"><a href="#fuser-借由文件-或文件系统-找出正在使用该文件的进程" class="headerlink" title="fuser: 借由文件 (或文件系统) 找出正在使用该文件的进程"></a>fuser: 借由文件 (或文件系统) 找出正在使用该文件的进程</h4><h4 id="lsof-列出被进程所使用的文件名称"><a href="#lsof-列出被进程所使用的文件名称" class="headerlink" title="lsof: 列出被进程所使用的文件名称"></a>lsof: 列出被进程所使用的文件名称</h4><h4 id="pidof-找出某个正在执行的进程的-PID"><a href="#pidof-找出某个正在执行的进程的-PID" class="headerlink" title="pidof: 找出某个正在执行的进程的 PID"></a>pidof: 找出某个正在执行的进程的 PID</h4><h3 id="16-5-SELinux-初探"><a href="#16-5-SELinux-初探" class="headerlink" title="16.5 SELinux 初探"></a>16.5 SELinux 初探</h3><h4 id="16-5-1-什么是-SELinux"><a href="#16-5-1-什么是-SELinux" class="headerlink" title="16.5.1 什么是 SELinux"></a>16.5.1 什么是 SELinux</h4><p>SELinux 是 Security Enhanced Linux 的缩写 </p><h4 id="当初设计的目标：-避免资源误用"><a href="#当初设计的目标：-避免资源误用" class="headerlink" title="当初设计的目标： 避免资源误用"></a>当初设计的目标： 避免资源误用</h4><p>SELinux 是整合到内核的一个模块，更多内容可参考 <a href="https://www.nsa.gov/what-we-do/research/selinux">链接</a></p><p>SELinux 是在进行进程，文件等详细权限配置时依据的一个内核模块。</p><h4 id="传统的文件权限与帐号的关系-自主访问控制"><a href="#传统的文件权限与帐号的关系-自主访问控制" class="headerlink" title="传统的文件权限与帐号的关系: 自主访问控制"></a>传统的文件权限与帐号的关系: 自主访问控制</h4><p>各种权限设置对 root 是无效的.</p><p>DAC, Discretionary Access Control, 自主访问控制, 即，当某个进程想要对文件进行读写时，系统就会根据进程的拥有者和用户组，对比文件的权限，只有通过权限检查，才可以读写文件的方式.</p><h4 id="以策略规则制定进程读取特定文件-强制访问控制-MAC"><a href="#以策略规则制定进程读取特定文件-强制访问控制-MAC" class="headerlink" title="以策略规则制定进程读取特定文件: 强制访问控制 (MAC)"></a>以策略规则制定进程读取特定文件: 强制访问控制 (MAC)</h4><p>MAC, Mandatory Access Control, 强制访问控制。用户的权限根据进程而定，root 所获取的权限也不一定是 root.</p><p>默认情况下，httpd 这个进程仅能在 <code>/var/www/</code> 这个目录下读取文件.</p><h4 id="16-5-2-SELinux-的运行模式"><a href="#16-5-2-SELinux-的运行模式" class="headerlink" title="16.5.2 SELinux 的运行模式"></a>16.5.2 SELinux 的运行模式</h4><ul><li>主体 (subject), SELinux 主要管理的就是进程</li><li>目标 (Object), 主体进程能否读写的目标资源一般就是文件系统.</li><li>策略 (Policy), 这些策略内还会有详细的规则 (rule) 来指定不同的服务是否开放某些资源的读写</li></ul><p>SELinux 的重点是保护进程读取文件系统的权限.</p><h1 id="第17章-认识系统服务-daemon"><a href="#第17章-认识系统服务-daemon" class="headerlink" title="第17章 认识系统服务(daemon)"></a>第17章 认识系统服务(daemon)</h1><h2 id="17-1-什么是-daemon-与服务-service"><a href="#17-1-什么是-daemon-与服务-service" class="headerlink" title="17.1 什么是 daemon 与服务(service)"></a>17.1 什么是 daemon 与服务(service)</h2><p>系统为了某些功能必须提供一些服务，这个服务就叫做 service, 完成 service 的程序叫 daemon. 也就是说, daemon 是程序，service 是功能。</p><p>服务的名称建立之后，在Linux 中使用时，通常在服务的名称后面加上一个 ‘d’, 这个 ‘d’ 代表的就是 daemon 的意思。</p><h3 id="17-1-1-早期-System-V-的-init-管理操作中-daemon-的主要分类-Optional"><a href="#17-1-1-早期-System-V-的-init-管理操作中-daemon-的主要分类-Optional" class="headerlink" title="17.1.1 早期 System V 的 init 管理操作中 daemon 的主要分类(Optional)"></a>17.1.1 早期 System V 的 init 管理操作中 daemon 的主要分类(Optional)</h3><h4 id="服务的启动、关闭与查看等方式"><a href="#服务的启动、关闭与查看等方式" class="headerlink" title="服务的启动、关闭与查看等方式"></a>服务的启动、关闭与查看等方式</h4><p>所有的服务启动脚本放置于 <code>/etc/init.d</code> 目录。</p><p>处理方式:</p><ul><li>启动: <code>/etc/init.d/daemon start</code></li><li>关闭: <code>/etc/init.d/daemon stop</code></li><li>重新启动: <code>/etc/init.d/daemon restart</code></li><li>查看状态: <code>/etc/init.d/daemon status</code></li></ul><h4 id="服务启动的分类"><a href="#服务启动的分类" class="headerlink" title="服务启动的分类"></a>服务启动的分类</h4><h4 id="服务的依赖性问题"><a href="#服务的依赖性问题" class="headerlink" title="服务的依赖性问题"></a>服务的依赖性问题</h4><h4 id="运行级别的分类"><a href="#运行级别的分类" class="headerlink" title="运行级别的分类"></a>运行级别的分类</h4><p>基本上 Linux 提供了7个运行级别, 分别是 0、1、2、3、4、5、6.</p><p>链接文件名(SXXdaemon)的功能为: S 为启动该服务，XX 是数字, 为启动顺序.</p><h4 id="制定运行级别默认要启动的服务"><a href="#制定运行级别默认要启动的服务" class="headerlink" title="制定运行级别默认要启动的服务"></a>制定运行级别默认要启动的服务</h4><p>通过以下命令操作:</p><ul><li>默认要启动: chkconfig daemon on</li><li>默认不启动: chkconfig daemon off </li><li>查看默认为启动与否: chkconfig –list daemon</li></ul><h4 id="运行级别的切换操作"><a href="#运行级别的切换操作" class="headerlink" title="运行级别的切换操作"></a>运行级别的切换操作</h4><p>从命令行界面 (runlevel3) 切换到图形界面 (runlevel5), 只需用 <code>init 5</code> 即可。</p><p>这里的命令行界面就是 tty 界面。Ubuntu 上也可行。</p><h3 id="17-1-2-systemd-使用的-unit-分类"><a href="#17-1-2-systemd-使用的-unit-分类" class="headerlink" title="17.1.2 systemd 使用的 unit 分类"></a>17.1.2 systemd 使用的 unit 分类</h3><p>旧的 init 启动脚本是”一项一项任务依序启动”的模式，速度较慢。</p><p>systemd 让所有服务同时启动。</p><p>systemd 可以兼容 init 的启动脚本，旧的 init 的启动脚本能够通过 systemd 来管理。</p><p>全部的 systemd 都用 systemctl 这个管理程序进行管理，而 systemctl 支持的语法有限制。</p><p>如果某个服务启动是管理员手动执行(即直接输入 daemon)，而不是使用 systemctl, 那么 systemd 将无法检测到该服务，无法进一步管理。</p><h4 id="systemd-的配置文件放置目录"><a href="#systemd-的配置文件放置目录" class="headerlink" title="systemd 的配置文件放置目录"></a>systemd 的配置文件放置目录</h4><p>systemd 将过去 daemon 执行脚本通通称为一个服务单位(unit), 每种服务单位用功能区分.</p><p>配置文件所在目录:</p><ul><li><code>/usr/lib/systemd/system</code>: 每个服务最主要的启动脚本设置</li><li><code>/run/systemd/system</code>: 系统执行过程中产生的服务脚本，其脚本的优先级高于 <code>/usr/lib/systemd/system</code> 中</li><li><code>/etc/systemed/system</code>: 管理员根据主机系统的需求建立的执行脚本，其优先级比 <code>/run/systemd/system</code> 高</li></ul><h4 id="systemd-的-unit-类型分类说明"><a href="#systemd-的-unit-类型分类说明" class="headerlink" title="systemd 的 unit 类型分类说明"></a>systemd 的 unit 类型分类说明</h4><p>通过扩展名判断。</p><h2 id="17-2-通过-systemctl-管理服务"><a href="#17-2-通过-systemctl-管理服务" class="headerlink" title="17.2 通过 systemctl 管理服务"></a>17.2 通过 systemctl 管理服务</h2><p>systemd 只有 systemctl 这个命令来处理。</p><h3 id="17-2-1-通过-systemctl-管理单一服务-service-unit-的启动-x2F-开机启动与查看状态"><a href="#17-2-1-通过-systemctl-管理单一服务-service-unit-的启动-x2F-开机启动与查看状态" class="headerlink" title="17.2.1 通过 systemctl 管理单一服务 (service unit) 的启动&#x2F;开机启动与查看状态"></a>17.2.1 通过 systemctl 管理单一服务 (service unit) 的启动&#x2F;开机启动与查看状态</h3><p>服务的启动一般有两个阶段:</p><ul><li>开机时要不要启动</li><li>现在要不要启动</li></ul><p>systemctl 命令语法:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ systemctl <span class="hljs-comment">[command]</span> <span class="hljs-comment">[unit]</span><br></code></pre></td></tr></table></figure><p><code>[command]</code> 主要有:</p><ul><li>start </li><li>stop</li><li>restart</li><li>enable, 设置下次开机时，后面的 unit 会被启动</li><li>disable</li><li>status</li><li>is-active</li><li>is-enable</li></ul><p>不应该使用 <code>kill</code> 的方式来关闭一个正常的服务。</p><h1 id="第18章-认识与分析日志文件"><a href="#第18章-认识与分析日志文件" class="headerlink" title="第18章 认识与分析日志文件"></a>第18章 认识与分析日志文件</h1><h2 id="18-1-什么是日志文件"><a href="#18-1-什么是日志文件" class="headerlink" title="18.1 什么是日志文件"></a>18.1 什么是日志文件</h2><p>就是记录系统活动信息的几个文件.</p><h4 id="Linux-常见的日志文件名"><a href="#Linux-常见的日志文件名" class="headerlink" title="Linux 常见的日志文件名"></a>Linux 常见的日志文件名</h4><p>日志文件的权限通常是设置为仅有 root 能够读取.</p><p>常见的日志文件有:</p><ul><li>&#x2F;var&#x2F;log&#x2F;boot.log : 只会存储本次开机的信息</li><li>&#x2F;var&#x2F;log&#x2F;cron </li><li>&#x2F;var&#x2F;log&#x2F;dmesg</li><li>&#x2F;var&#x2F;log&#x2F;lastlog</li><li>&#x2F;var&#x2F;log&#x2F;maillog</li><li>&#x2F;var&#x2F;log&#x2F;messages</li><li>&#x2F;var&#x2F;log&#x2F;secure</li><li>&#x2F;var&#x2F;log&#x2F;wtmp, &#x2F;var&#x2F;log&#x2F;failing, 记录正确登录系统者的账户信息与错误登录时所使用的账户信息</li><li>&#x2F;var&#x2F;log&#x2F;httpd&#x2F;<em>, &#x2F;var&#x2F;log&#x2F;samba&#x2F;</em></li></ul><h4 id="日志文件所需相关服务-daemon-与程序"><a href="#日志文件所需相关服务-daemon-与程序" class="headerlink" title="日志文件所需相关服务 (daemon) 与程序"></a>日志文件所需相关服务 (daemon) 与程序</h4><p>日志文件的产生一般有两种方式:</p><ul><li>由软件开发商自行定义写入的日志文件与相关格式, 如 WWW 软件 apache</li><li>另 Linux 发行版提供的日志文件管理服务来统一管理</li></ul><p>可以使用 logrotate 工具来自动化处理日志文件容量与更新. </p><h2 id="19-1-Linux-的启动流程分析"><a href="#19-1-Linux-的启动流程分析" class="headerlink" title="19.1 Linux 的启动流程分析"></a>19.1 Linux 的启动流程分析</h2><h3 id="19-1-1-启动流程一览"><a href="#19-1-1-启动流程一览" class="headerlink" title="19.1.1 启动流程一览"></a>19.1.1 启动流程一览</h3><p>Boot loader 可以指定使用哪个内核文件来启动，并实际加载到内核中解压缩与执行。此时内核就能够开始在内存中活动，并检测所有硬件信息与加载适当的驱动程序来使整台主机开始运行，等到内核检测硬件与加载驱动程序完毕后，操作系统便开始运行.</p><h3 id="19-1-2-BIOS-boot-loader-与-kernel-加载"><a href="#19-1-2-BIOS-boot-loader-与-kernel-加载" class="headerlink" title="19.1.2 BIOS, boot loader 与 kernel 加载"></a>19.1.2 BIOS, boot loader 与 kernel 加载</h3><p>BIOS, 无论传统 BIOS 还是 UEFI BIOS 都会被简称为 BIOS.</p><p>在个人计算机架构下，启动整个系统首先就要让系统去加载 BIOS (Basic Input Output System), 并通过 BIOS 程序去加载 CMOS 信息，并且借由 CMOS 内的设置取得主机的各项硬件配置. 在取得这些信息后，BIOS 会进行启动自我检测 (Power-on Self Test, POST), 然后开始执行硬件检测的初始化，并设置 PnP 设备，之后再定义出可启动的设备顺序，接下来就会开始进行设备的数据读取.</p><p>Boot loader 位于启动设备的第一个扇区中。</p><h4 id="boot-loader-的功能"><a href="#boot-loader-的功能" class="headerlink" title="boot loader 的功能"></a>boot loader 的功能</h4><p>loader 的主要功能是识别操作系统的文件格式.</p><p>由于不同操作系统的文件格式不一致，因此每种操作系统都有自己的 boot loader.</p><p>通常操作系统默认都会安装一份 loader 到它根目录所在文件系统的 boot sector 上.</p><p>boot loader 主要的功能如下:</p><ul><li>提供选项：用户可以选择不同的启动选项, 这也是多重引导的重要功能</li><li>加载内核文件: 直接指向可启动的程序区域来启动操作系统</li><li>转交其他 loader: 将启动管理功能转交给其他 loader 负责</li></ul><p>内核文件一般被放置在 <code>/boot</code> 里，并去名为 <code>/boot/vmlinuz</code>.</p><p>Linux 内核可以通过动态加载内核模块，这些模块放置在 <code>/lib/modules</code> 目录内。</p><p>由于模块放置到磁盘根目录内，因此启动的过程中内核必须要挂在根目录，这样才能够读取内核模块提供的加载驱动程序功能.</p><p>一般来说，Linux 发行版都会将非必要的功能且可以编译成为模块的内核功能，编译成为模块.</p><p>虚拟文件系统 (Initial RAM Filesystem) 一般使用的文件名为 <code>/boot/initrd</code> 或 <code>/boot/initramfs</code>, 这个文件可以通过 boot loader 来加载到内存中，然后这个文件会被解压缩并且在内存中模拟成一个根目录.</p><h3 id="19-1-3-第一个程序-systemd-及使用-default-target-进入启动程序分析"><a href="#19-1-3-第一个程序-systemd-及使用-default-target-进入启动程序分析" class="headerlink" title="19.1.3 第一个程序 systemd 及使用 default.target 进入启动程序分析"></a>19.1.3 第一个程序 systemd 及使用 default.target 进入启动程序分析</h3><p>systemd 最主要的功能就是准备软件执行的环境，包括系统的主机名，网络设置，语言设置，文件系统格式及其他服务的启动等.</p><p>要知道系统服务的启用流程，最简单的方法就是:</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-dependencies</span> <span class="hljs-string">graphical</span>.<span class="hljs-string">target</span><br></code></pre></td></tr></table></figure><h3 id="19-1-4-systemd-执行-sysinit-target-初始化系统，basic-target-准备系统"><a href="#19-1-4-systemd-执行-sysinit-target-初始化系统，basic-target-准备系统" class="headerlink" title="19.1.4 systemd 执行 sysinit.target 初始化系统，basic.target 准备系统"></a>19.1.4 systemd 执行 sysinit.target 初始化系统，basic.target 准备系统</h3><h3 id="19-1-5-systemd-启动-multi-user-target-下的服务"><a href="#19-1-5-systemd-启动-multi-user-target-下的服务" class="headerlink" title="19.1.5 systemd 启动 multi-user.target 下的服务"></a>19.1.5 systemd 启动 multi-user.target 下的服务</h3><p>各种主机服务以及提供服务器功能的网络服务的启动，大多附属与 <code>multi-user.target</code>.</p><p>一般服务的启动脚本设置都放在下面的目录内:</p><ul><li><code>/usr/lib/systemd/system</code> , 系统默认的服务启动脚本设置</li><li><code>/etc/systemd/system</code> , 管理员自己开发与设置的脚本设置</li></ul><p>将服务放到 <code>/etc/systemed/system/multi-user.target.want</code> 下就可以在启动时启动它.</p><p>当系统完成启动后，还想要系统额外执行某些程序的话，可以将程序命令或脚本的绝对路径名称写入到 <code>/etc/rc.d/rc.local</code> 这个文件下。 当 <code>rc.local</code> 具有可执行权限时才会被执行。</p><h4 id="提供-tty-界面与登录服务"><a href="#提供-tty-界面与登录服务" class="headerlink" title="提供 tty 界面与登录服务"></a>提供 tty 界面与登录服务</h4><p><code>multi-user.target</code> 下面的 <code>getty.target</code> 操作界面选项是提供 tty 界面。</p><p>用户登录服务也是在 <code>multi-user.target</code> 下。</p><h3 id="19-1-6-systemd-启动-graphical-target-下面的服务"><a href="#19-1-6-systemd-启动-graphical-target-下面的服务" class="headerlink" title="19.1.6 systemd 启动 graphical.target 下面的服务"></a>19.1.6 systemd 启动 graphical.target 下面的服务</h3><p>如果 <code>default.target</code> 是 <code>multi-user.target</code>，这个步骤就不会执行.</p><h3 id="19-1-7-启动过程会用到的主要配置文件"><a href="#19-1-7-启动过程会用到的主要配置文件" class="headerlink" title="19.1.7 启动过程会用到的主要配置文件"></a>19.1.7 启动过程会用到的主要配置文件</h3><p>几个常见的比较重要的配置文件:</p><h4 id="关于模块-etc-modprobe-d-conf-及-etc-modules-load-d-conf"><a href="#关于模块-etc-modprobe-d-conf-及-etc-modules-load-d-conf" class="headerlink" title="关于模块: /etc/modprobe.d/*.conf 及 /etc/modules-load,d/*.conf"></a>关于模块: <code>/etc/modprobe.d/*.conf</code> 及 <code>/etc/modules-load,d/*.conf</code></h4><ul><li><code>/etc/modprobe.d/*.conf</code> 是可以加上模块参数的位置</li><li><code>/etc/modules-load.d/*.conf</code> 是单纯加载模块的位置</li></ul><p><code>systemctl restart systemd-modules-load.service</code> 可重新加载模块.</p><h2 id="19-2-内核与内核模块"><a href="#19-2-内核与内核模块" class="headerlink" title="19.2 内核与内核模块"></a>19.2 内核与内核模块</h2><p>在整个启动的过程当中，是否能够成功驱动我们的主机的硬件设备是内核 (kernel) 的工作。</p><p>内核一般为压缩文件，因此在使用内核之前，就的要将它解压缩后，才能加载到内存当中.</p><p>内核与模块的存放位置:</p><ul><li>内核: <code>/boot/vmlinuz</code> 或 <code>/boot/vmlinuz-version</code></li><li>内核解压缩所需的 RAM Disk: <code>/boot/inistramfs</code> 或 <code>/boot/inistramfs-version</code></li><li>内核模块: <code>/lib/modules/version/kernel</code> 或 <code>/lib/modules/$(uname -r)/kernel</code></li><li>内核源代码: <code>/usr/src/linux</code> 或 <code>/usr/src/kernels</code> (默认不安装)</li></ul><p>添加新硬件支持:</p><ul><li>重新编译内核，并加入最新的硬件驱动程序源代码</li><li>将该硬件的驱动程序编译成为模块，在启动时加载该模块</li></ul><h3 id="19-2-1-内核模块与依赖性"><a href="#19-2-1-内核模块与依赖性" class="headerlink" title="19.2.1 内核模块与依赖性"></a>19.2.1 内核模块与依赖性</h3><p>检查 <code>/lib/modules/$(uname -r)/modules.dep</code> 这个文件，其记录了内核支持的模块的各项依赖性.</p><p>使用 <code>depmod</code> 命令之后，该程序会跑到模块标准放置目录 <code>/lib/modules/$(uname -r)/kernel</code>，并一句相关目录的定义将全部的模块读取出来分析，最终将分析的结果写入 <code>modules.dep</code> 文件中.</p><h4 id="19-2-2-查看内核模块"><a href="#19-2-2-查看内核模块" class="headerlink" title="19.2.2 查看内核模块"></a>19.2.2 查看内核模块</h4><p>使用 <code>lsmod</code> 命令可以查看目前内核加载了多少模块.</p><p>显示的内容包括:</p><ul><li>模块名称 (Module)</li><li>模块的大小 (Size)</li><li>次模块是否被其他模块所使用 (Used by)</li></ul><p>使用 <code>modinfo</code> 命令，可以查看在内核中的模块，也可以查看某个模块文件.</p><h3 id="19-2-3-内核模块的加载与删除"><a href="#19-2-3-内核模块的加载与删除" class="headerlink" title="19.2.3 内核模块的加载与删除"></a>19.2.3 内核模块的加载与删除</h3><p>使用 <code>modprobe</code> 这个命令来加载模块，<code>modprobe</code> 会主动查找 <code>modules.dep</code> 的内容，先解决了模块的依赖性后，才决定需要加载的模块有哪些. 其可加载也可删除.</p><p><code>insmod</code> 需要提供完整文件名的模块。</p><p>内核模块一定是 <code>.ko</code> 结尾的。</p><h3 id="19-2-4-内核模块的额外参数设置-etc-modprobe-d-conf"><a href="#19-2-4-内核模块的额外参数设置-etc-modprobe-d-conf" class="headerlink" title="19.2.4 内核模块的额外参数设置: /etc/modprobe.d/*.conf"></a>19.2.4 内核模块的额外参数设置: <code>/etc/modprobe.d/*.conf</code></h3><h2 id="19-3-Boot-Loader-Grub2"><a href="#19-3-Boot-Loader-Grub2" class="headerlink" title="19.3 Boot Loader: Grub2"></a>19.3 Boot Loader: Grub2</h2><h3 id="19-3-1-boot-loader-的两个-stage"><a href="#19-3-1-boot-loader-的两个-stage" class="headerlink" title="19.3.1 boot loader 的两个 stage"></a>19.3.1 boot loader 的两个 stage</h3><p>在 BIOS 读完信息后，接下来就是回到第一个启动设备的 MBR 去读取 boot loader.</p><p>Linux 将 boot loader 的程序代码执行与设置值加载分成两个阶段 (stage):</p><ul><li>Stage 1: 执行 boot loader 主程序, 这个主程序必须被安装在启动区，即 MBR 或启动扇区 (boot sector)</li><li>Stage 2: 主程序加载配置文件，通过 boot loader 加载所有配置文件与相关的环境参数文件, 一般来说，配置文件都在 <code>/boot</code> 下<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls -l <span class="hljs-regexp">/boot/g</span>rub2<br></code></pre></td></tr></table></figure></li></ul><h3 id="19-3-2-grub2-的配置文件-x2F-boot-x2F-grub2-x2F-grub-cfg-初探"><a href="#19-3-2-grub2-的配置文件-x2F-boot-x2F-grub2-x2F-grub-cfg-初探" class="headerlink" title="19.3.2 grub2 的配置文件 &#x2F;boot&#x2F;grub2&#x2F;grub.cfg 初探"></a>19.3.2 grub2 的配置文件 &#x2F;boot&#x2F;grub2&#x2F;grub.cfg 初探</h3><p>grub2 的优点:</p><ul><li>识别与支持较多文件系统，并且可以使用 grub2 的主程序直接在文件系统中查找内核文件</li><li>启动时可以自行编辑与修改启动设置选项，类似 bash 的命令模式</li><li>可以动态查找配置文件，而不需要在修改配置文件后重新安装 grub2</li></ul><h4 id="磁盘与分区在-grub2-中的代号"><a href="#磁盘与分区在-grub2-中的代号" class="headerlink" title="磁盘与分区在 grub2 中的代号"></a>磁盘与分区在 grub2 中的代号</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(hd0,1)</span>     <span class="hljs-attr"># 一般的默认语法，由 grub2</span> 自动判断分区格式<br><span class="hljs-comment">(hd0,msdos1)</span>    <span class="hljs-attr"># 此磁盘的分区为传统的 MBR 模式</span><br><span class="hljs-attr">(hd0</span>,gpt<span class="hljs-number">1</span>)      <span class="hljs-attr"># 此磁盘的分区为 GPT 模式</span><br></code></pre></td></tr></table></figure><p>注意点:</p><ul><li>以查找顺序作为硬盘的编号 </li><li>第一个查找到的硬盘为 0 号，第二个为 1 号</li><li>每快硬盘的第一个分区代号为 1<br>由于 BIOS 可以调整磁盘的启动顺序，所以 <code>hdn</code> 的 <code>n</code> 会变.</li></ul><h3 id="19-3-3-grub2-配置文件维护-etc-default-grub-与-etc-grub-d"><a href="#19-3-3-grub2-配置文件维护-etc-default-grub-与-etc-grub-d" class="headerlink" title="19.3.3 grub2 配置文件维护 /etc/default/grub 与 /etc/grub.d"></a>19.3.3 grub2 配置文件维护 <code>/etc/default/grub</code> 与 <code>/etc/grub.d</code></h3><h3 id="19-3-4-instramfs-的重要性与建立新-initramfs-文件"><a href="#19-3-4-instramfs-的重要性与建立新-initramfs-文件" class="headerlink" title="19.3.4 instramfs 的重要性与建立新 initramfs 文件"></a>19.3.4 instramfs 的重要性与建立新 initramfs 文件</h3><p>initramfs 内所包含的模块大多是与启动过程有关，而主要以文件系统及硬盘模块为主.</p><p>一般来说，需要 initramfs 的时刻为:</p><ul><li>根目录所在磁盘为 SATA, USB 或 SCSI 等接口设备</li><li>根目录所在文件系统为 LVM, RAID 等特殊格式</li><li>根目录所在文件系统为非传统 Linux 支持的文件系统</li><li>其他必须要内核加载时提供的模块</li></ul><h3 id="19-3-5-测试与安装-grub2"><a href="#19-3-5-测试与安装-grub2" class="headerlink" title="19.3.5 测试与安装 grub2"></a>19.3.5 测试与安装 grub2</h3><h3 id="19-3-6-启动钱的额外功能修改"><a href="#19-3-6-启动钱的额外功能修改" class="headerlink" title="19.3.6 启动钱的额外功能修改"></a>19.3.6 启动钱的额外功能修改</h3><p>选项部分的画面就是 menuentry 后面的文字.</p><h3 id="19-3-7-关于启动画面与终端画面的图形显示方式"><a href="#19-3-7-关于启动画面与终端画面的图形显示方式" class="headerlink" title="19.3.7 关于启动画面与终端画面的图形显示方式"></a>19.3.7 关于启动画面与终端画面的图形显示方式</h3><h2 id="19-4-启动过程的问题解决"><a href="#19-4-启动过程的问题解决" class="headerlink" title="19.4 启动过程的问题解决"></a>19.4 启动过程的问题解决</h2><p>Linux 无法顺利启动时，可进入 rescue 模式去处理.</p><h3 id="19-4-1-忘记-root-密码的解决之道"><a href="#19-4-1-忘记-root-密码的解决之道" class="headerlink" title="19.4.1 忘记 root 密码的解决之道"></a>19.4.1 忘记 root 密码的解决之道</h3><h3 id="19-4-2-直接启动就以-root-执行-bash-的方法"><a href="#19-4-2-直接启动就以-root-执行-bash-的方法" class="headerlink" title="19.4.2 直接启动就以 root 执行 bash 的方法"></a>19.4.2 直接启动就以 root 执行 bash 的方法</h3><h1 id="第20章-基础系统设置与备份策略"><a href="#第20章-基础系统设置与备份策略" class="headerlink" title="第20章 基础系统设置与备份策略"></a>第20章 基础系统设置与备份策略</h1><h2 id="20-1-系统基本设置"><a href="#20-1-系统基本设置" class="headerlink" title="20.1 系统基本设置"></a>20.1 系统基本设置</h2><p>使用 <code>hwclock</code> 是将正确时间写入 BIOS 时间记录.</p><p>使用 <code>ntpdate</code> 手动校时：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ntpdate s2m<span class="hljs-selector-class">.time</span><span class="hljs-selector-class">.edu</span>.cn<br></code></pre></td></tr></table></figure><p><code>s2m.time.edu.cn</code> 是北京大学提供的时间服务器.</p><h3 id="20-1-3-语系设置"><a href="#20-1-3-语系设置" class="headerlink" title="20.1.3 语系设置"></a>20.1.3 语系设置</h3><p><code>/etc/locale.conf</code> 是语系的配置文件，可以用 <code>localectl</code> 来查看目前的系统语系:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">localectl</span><br></code></pre></td></tr></table></figure><h3 id="20-1-4-防火墙建议设置"><a href="#20-1-4-防火墙建议设置" class="headerlink" title="20.1.4 防火墙建议设置"></a>20.1.4 防火墙建议设置</h3><p>防火墙是一种网络数据的过滤方式，它可以根据你服务器启动的服务来设置是否开放，也能够针对对你信任的用户开放.</p><p>相关设置项目:</p><ul><li>服务</li><li>端口</li><li>富规则 (rich rule)</li><li>接口 : 就是这个区域主要是针对那一个网卡来做规范, 如 eth0</li></ul><h2 id="20-2-服务器硬件数据的收集"><a href="#20-2-服务器硬件数据的收集" class="headerlink" title="20.2 服务器硬件数据的收集"></a>20.2 服务器硬件数据的收集</h2><h3 id="20-2-1-使用-dmidecode-查看硬件设备"><a href="#20-2-1-使用-dmidecode-查看硬件设备" class="headerlink" title="20.2.1 使用 dmidecode 查看硬件设备"></a>20.2.1 使用 dmidecode 查看硬件设备</h3><p>dmidecode 可用于查看 CPU 型号，主板型号与内存相关的型号等.</p><p>语法:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">dmidecode</span> -t <span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>选项:</p><ul><li>1 : 详细的系统信息，含主板的型号与硬件的基础信息等</li><li>4 : CPU 的相关信息，包括倍频，外频，内核数，内核线程数等</li><li>9 : 系统的相关插槽格式，包括 PCI, PCI-E 等的插槽规格说明</li><li>17 : 每一个内存插槽的规格，若有内存, 则列出该内存的容量与型号</li></ul><h3 id="20-2-2-硬件资源的收集与分析"><a href="#20-2-2-硬件资源的收集与分析" class="headerlink" title="20.2.2 硬件资源的收集与分析"></a>20.2.2 硬件资源的收集与分析</h3><p>内核所检测到的各项硬件设备，会被记录在 <code>/proc</code> 和 <code>/sys</code> 当中.</p><p><code>lspci</code>, <code>lsusb</code>, <code>iostat</code> 命令.</p><p><code>lspci</code> 的所有数据都是从 <code>/proc/bus/pci</code> 目录中获取。</p><p>在线更新对应文件:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">update-pciids</span><br></code></pre></td></tr></table></figure><p><code>lostat</code> 可用 <code>sudo pacman -S sysstat</code> 来安装.</p><h3 id="20-2-3-了解磁盘的健康状态"><a href="#20-2-3-了解磁盘的健康状态" class="headerlink" title="20.2.3 了解磁盘的健康状态"></a>20.2.3 了解磁盘的健康状态</h3><p>smartd 服务, SMART 是 Self-Monitoring, Analysis and Reporting Technology System 的缩写.</p><p>需要被检测的磁盘支持 SMART 协议.</p><p>smartd 提供一个命令 <code>smartctl</code>.</p><h2 id="20-3-备份要点"><a href="#20-3-备份要点" class="headerlink" title="20.3 备份要点"></a>20.3 备份要点</h2><h3 id="20-3-1-备份数据的考虑"><a href="#20-3-1-备份数据的考虑" class="headerlink" title="20.3.1 备份数据的考虑"></a>20.3.1 备份数据的考虑</h3><h3 id="20-3-2-哪些-Linux-数据具有备份的意义"><a href="#20-3-2-哪些-Linux-数据具有备份的意义" class="headerlink" title="20.3.2 哪些 Linux 数据具有备份的意义"></a>20.3.2 哪些 Linux 数据具有备份的意义</h3><p>通常粗分为两大类:</p><ul><li>系统基本设置信息</li><li>类似网络服务的内容数据</li></ul><h4 id="操作系统本身需要备份的文件"><a href="#操作系统本身需要备份的文件" class="headerlink" title="操作系统本身需要备份的文件"></a>操作系统本身需要备份的文件</h4><p>主要跟 <mark>帐号与系统配置文件</mark> 有关, 包括 <code>/etc/passwd</code>, <code>/etc/shadow</code>, <code>/etc/group</code>, <code>/etc/gshadow</code> 以及 <code>/home</code> 下的用户家目录，一般将 <code>/etc</code> 目录备份下来，几乎所有的配置文件都可以被保存.</p><p>用户的邮件，<code>/var/spool/mail</code> 内容也需要备份.</p><ul><li><code>/etc/</code> 整个目录</li><li><code>/home/</code> 整个目录</li><li><code>/var/spool/mail/</code></li><li><code>/var/spool/&#123;at/cron&#125;/</code></li><li><code>/boot/</code></li><li><code>/root/</code></li><li><code>/usr/local/</code> 或 <code>/opt</code></li></ul><h4 id="网络服务的数据库方面"><a href="#网络服务的数据库方面" class="headerlink" title="网络服务的数据库方面"></a>网络服务的数据库方面</h4><ul><li>软件本身的配置文件, 如 <code>/etc/</code> 整个目录，<code>/usr/local</code> 整个目录</li><li>软件服务提供的数据，以 WWW 为例: <code>/var/www</code> 整个目录或 <code>/srv/www</code> 整个目录</li></ul><h4 id="推荐备份的目录"><a href="#推荐备份的目录" class="headerlink" title="推荐备份的目录"></a>推荐备份的目录</h4><ul><li><code>/etc/</code></li><li><code>/home/</code></li><li><code>/root/</code></li><li><code>/var/spool/mail/</code>, <code>/var/spool/cron/</code>, <code>/var/spool/at/</code></li><li><code>/var/lib/</code></li></ul><h4 id="不需要备份的目录"><a href="#不需要备份的目录" class="headerlink" title="不需要备份的目录"></a>不需要备份的目录</h4><ul><li>&#x2F;dev</li><li>&#x2F;proc, &#x2F;sys, &#x2F;run</li><li>&#x2F;mnt, &#x2F;media</li><li>&#x2F;tmp</li></ul><h2 id="20-4-备份的种类，频率与工具的选择"><a href="#20-4-备份的种类，频率与工具的选择" class="headerlink" title="20.4 备份的种类，频率与工具的选择"></a>20.4 备份的种类，频率与工具的选择</h2><h3 id="20-4-1-完备备份之累积备份-incremental-backup"><a href="#20-4-1-完备备份之累积备份-incremental-backup" class="headerlink" title="20.4.1 完备备份之累积备份 (incremental backup)"></a>20.4.1 完备备份之累积备份 (incremental backup)</h3><p>即将根目录 (&#x2F;) 整个系统都备份下来.</p><p>累计备份指在系统进行完第一次完整备份后，经过一段时间的运行，比较系统与备份文件之间的差异，仅备份有差异的文件.</p><h4 id="累积备份使用的备份软件"><a href="#累积备份使用的备份软件" class="headerlink" title="累积备份使用的备份软件"></a>累积备份使用的备份软件</h4><p>常见的有 dd, cpio, xfsdump&#x2F;sfsrestore 等.</p><p>dd 可以直接读取磁盘的扇区而不理会文件系统，缺点是速度较慢. 其需要使用额外的脚本程序处理.</p><p>xfsdump 可直接进行累积备份</p><p>tar 命令也可用于备份. 常配合 date 命令</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">tar -jpcvf mysql.`date +<span class="hljs-built_in">%Y</span>-<span class="hljs-built_in">%m</span>-<span class="hljs-built_in">%d</span>`.tar.bz2 /var/lib/mysql<br></code></pre></td></tr></table></figure><p>可将备份用脚本配合 crontab 去执行.</p><h3 id="20-4-2-完整备份之差异备份-Differential-backup"><a href="#20-4-2-完整备份之差异备份-Differential-backup" class="headerlink" title="20.4.2 完整备份之差异备份 (Differential backup)"></a>20.4.2 完整备份之差异备份 (Differential backup)</h3><h2 id="20-5-鸟哥的备份策略"><a href="#20-5-鸟哥的备份策略" class="headerlink" title="20.5 鸟哥的备份策略"></a>20.5 鸟哥的备份策略</h2><h1 id="第23章-X-Window-设置介绍"><a href="#第23章-X-Window-设置介绍" class="headerlink" title="第23章 X Window 设置介绍"></a>第23章 X Window 设置介绍</h1><p>Linux 上的图形用户界面模式称为 X Window System. 其对于 Linux 来说只是一个软件。</p><h2 id="23-1-什么是-X-Window-System"><a href="#23-1-什么是-X-Window-System" class="headerlink" title="23.1 什么是 X Window System"></a>23.1 什么是 X Window System</h2><p>名称由来, X 在英文顺序的 W(indow) 后面，有下一代的新窗口之意。因此叫做 X Window System.</p><h3 id="23-1-1-X-Window-System-的发展简史"><a href="#23-1-1-X-Window-System-的发展简史" class="headerlink" title="23.1.1 X Window System 的发展简史"></a>23.1.1 X Window System 的发展简史</h3><p>在 UNIX-like 上面的图形用户接口(GUI)被称为 X 或 X11.</p><h3 id="23-1-2-主要组件-X-Server-x2F-X-Client-x2F-Window-Manager-Display-Manager"><a href="#23-1-2-主要组件-X-Server-x2F-X-Client-x2F-Window-Manager-Display-Manager" class="headerlink" title="23.1.2 主要组件: X Server&#x2F;X Client&#x2F;Window Manager?Display Manager"></a>23.1.2 主要组件: X Server&#x2F;X Client&#x2F;Window Manager?Display Manager</h3><p>X Window System 是基于网络架构的GUI. 意思就是 X Client 从网络上获取需求，X Server 来呈现(即绘制图像)。需要网络提供数据。</p><p>基本可以分成 X Server 和 X Client 两个组件。</p><p>X Server 管理硬件，X Client 是应用程序。</p><p>具体内容:</p><ul><li>X Server, 负责硬件管理、屏幕绘制与提供字体功能。其管理的设备包括: 键盘、鼠标、手写板、显示器、屏幕分辨率与色彩深度、显卡(包括驱动程序)与显示字体等。<br>X Window System 是软件，有自己的配置文件，其设置与 Linux 不一定相同。</li></ul><p>每台客户端主机都需要安装 X Server, 而服务器则是提供 X Client 软件，以提供客户端绘图所需要的数据。</p><ul><li>X Client, 负责 X Server 要求的事件的处理. 其主要工作为处理来自 X Server 的操作，将该操作处理为绘图数据，再将这些绘图数据传回给 X Server. 每个 X Client 并不知道其他 X Client 的存在。</li></ul><p><mark>X Window Manager</mark>: 特殊的 X Client, 负责管理所有的 X Client 软件。</p><p><mark>Display Manager</mark>: 提供登录需求。如 GNOME 的 gdm(GNOME Display Manager).</p><h3 id="23-1-3-X-Window-System-的启动流程"><a href="#23-1-3-X-Window-System-的启动流程" class="headerlink" title="23.1.3 X Window System 的启动流程"></a>23.1.3 X Window System 的启动流程</h3><p>要启动 X Window System, 首先要启动管理硬件和绘图的 X Server, 然后才加载 X Client.</p><p>可在命令行输入 <code>startx</code> 来启动 X 窗口。</p><p>startx 是一个 shell 脚本，会主动帮忙用户建立他们的 X 所需要引用的配置文件。</p><p>语法:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ startx [X <span class="hljs-built_in">Client</span> 参数] -- [X <span class="hljs-built_in">Server</span> 参数]<br></code></pre></td></tr></table></figure><p>startx 最重要的任务是找到用户或是系统默认的 X Server 与 X Client 的配置文件。用户能通过外接参数来修改配置文件的内容。      </p><p>实际上启动 X 的是 xinit 这个程序，startx 仅找出设置值。</p><p>xinit 的语法:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">xinit [<span class="hljs-keyword">client</span> option] -- [<span class="hljs-keyword">server</span> or <span class="hljs-keyword">display</span> option]<br></code></pre></td></tr></table></figure><p>默认情况下，输入 <code>startx</code> 等于 <code>xinit /etc/X11/xinit/xinitrc -- /etc/X11/xinit/xserverrc</code></p><p>xinit 主要在启动 X Server 和加载 X Client, 但这个 xinit 所需要的参数是由 startx 帮忙查找。</p><p>X 启动的时候可以指定启动的接口。</p><p>在 X Window System 的环境下，称 6000 端口为第 0 个显示接口，即 hostname:0. 通常写为 <code>:0</code></p><h3 id="23-1-4-X-启动流程测试"><a href="#23-1-4-X-启动流程测试" class="headerlink" title="23.1.4 X 启动流程测试"></a>23.1.4 X 启动流程测试</h3>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 下查看已开启的服务</title>
    <link href="/2022/08/23/Ubuntu-%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%B7%B2%E5%BC%80%E5%90%AF%E7%9A%84%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/08/23/Ubuntu-%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%B7%B2%E5%BC%80%E5%90%AF%E7%9A%84%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>命令如下:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">service --<span class="hljs-keyword">status</span>-<span class="hljs-built_in">all</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cpython 和 PyPy</title>
    <link href="/2022/08/23/Cpython-%E5%92%8C-PyPy/"/>
    <url>/2022/08/23/Cpython-%E5%92%8C-PyPy/</url>
    
    <content type="html"><![CDATA[<p>Cpython 和 PyPy 都是 Python 的解释器。</p><h1 id="Cpython"><a href="#Cpython" class="headerlink" title="Cpython"></a>Cpython</h1><p>Cpython 是用 C 语言写的, 是目前使用最广泛的解释器，其对于 C&#x2F;Python API 有全面的支持。但是其有全局锁的缺陷，使其性能下降。</p><h1 id="PyPy"><a href="#PyPy" class="headerlink" title="PyPy"></a>PyPy</h1><p>用 Python 实现的解释器，对 C&#x2F;Python 的缺陷有大幅提高，但是对于 C&#x2F;Python API 的支持不全。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在 hexo 中添加 CNAME 文件</title>
    <link href="/2022/08/23/%E5%9C%A8-hexo-%E4%B8%AD%E6%B7%BB%E5%8A%A0-CNAME-%E6%96%87%E4%BB%B6/"/>
    <url>/2022/08/23/%E5%9C%A8-hexo-%E4%B8%AD%E6%B7%BB%E5%8A%A0-CNAME-%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>进入博客目录, 里面的 <code>public</code> 文件夹的内容就是用于创建网站:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Blog/public<br><span class="hljs-built_in">touch</span> CNAME<br></code></pre></td></tr></table></figure><p>然后编辑 CNAME 文件。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 安装 Gparted</title>
    <link href="/2022/08/23/Ubuntu-%E5%AE%89%E8%A3%85-Gparted/"/>
    <url>/2022/08/23/Ubuntu-%E5%AE%89%E8%A3%85-Gparted/</url>
    
    <content type="html"><![CDATA[<p>在命令行下载:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> gparted<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 安装百度网盘</title>
    <link href="/2022/08/23/Ubuntu-%E5%AE%89%E8%A3%85%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/"/>
    <url>/2022/08/23/Ubuntu-%E5%AE%89%E8%A3%85%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<p>进入官网:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>pan.baidu.com/download<br></code></pre></td></tr></table></figure><p>下载 <code>deb</code> 包, 然后开始安装:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> ~/Downloads<br><span class="hljs-attribute">sudo</span> dpkg -i baidunetdisk_4.<span class="hljs-number">11</span>.<span class="hljs-number">5</span>_amd64.deb<br></code></pre></td></tr></table></figure><p>或者直接命令行下载:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> -O baidunetdisk_4.<span class="hljs-number">11</span>.<span class="hljs-number">5</span>_amd64.deb https://pan.baidu.com/download#linux/baidunetdisk_4.<span class="hljs-number">11</span>.<span class="hljs-number">5</span>_amd64.deb<br><span class="hljs-attribute">cd</span> ~/Downloads<br><span class="hljs-attribute">sudo</span> dpkg -i baidunetdisk_4.<span class="hljs-number">11</span>.<span class="hljs-number">5</span>_amd64.deb<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python Web Spider Notes</title>
    <link href="/2022/08/23/Python-Web-Spider-Notes/"/>
    <url>/2022/08/23/Python-Web-Spider-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第2章-基本库的使用"><a href="#第2章-基本库的使用" class="headerlink" title="第2章 基本库的使用"></a>第2章 基本库的使用</h1><h2 id="2-1-urllib-的使用"><a href="#2-1-urllib-的使用" class="headerlink" title="2.1 urllib 的使用"></a>2.1 urllib 的使用</h2><p><code>urllib</code> s是 Python 内置的 HTTP 请求库。</p><p>包含四个模块:</p><ul><li>request, 模拟请求的发送</li><li>error, 处理异常</li><li>parse, 提供 url 的解决方法</li><li>robotparser, 判断哪些网站可以爬</li></ul><h3 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1 发送请求"></a>1 发送请求</h3><h4 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a>urlopen</h4><p>如:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import urllib<span class="hljs-selector-class">.request</span><br><br>response = urllib<span class="hljs-selector-class">.request</span><span class="hljs-selector-class">.urlopen</span>(<span class="hljs-string">&#x27;https://www.python.org&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(response.read()</span></span><span class="hljs-selector-class">.decode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br></code></pre></td></tr></table></figure><p>可以利用 <code>type</code> 方法输出响应类型:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">print</span>(<span class="hljs-keyword">type</span>(request))<br></code></pre></td></tr></table></figure><p>利用 <code>read()</code> 方法可以获得响应的网页内容，<code>status</code> 属性可以得到响应结果的状态码。</p><p><code>urlopen</code> 方法的 API:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">urllib.request.urlopen(url, <span class="hljs-attribute">date</span>=None, [timeout,]*, <span class="hljs-attribute">cafile</span>=None, <span class="hljs-attribute">capath</span>=None, <span class="hljs-attribute">cadefault</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">context</span>=None)<br></code></pre></td></tr></table></figure><h5 id="data-参数"><a href="#data-参数" class="headerlink" title="data 参数"></a>data 参数</h5><p>使用该参数，其请求方式会变为 POST, 且需要将该参数转化为 bytes 类型:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import urllib.parse<br>import urllib.request<br><br>data = bytes(urllib.parse.urlencode(&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;germey&#x27;</span>&#125;), <span class="hljs-attribute">encoding</span>=<span class="hljs-string">&#x27;utf-8&#x27;</span>) # 利用 urlencode 将字典转换为字符串<br>response = urllib.request.urlopen(<span class="hljs-string">&#x27;https://www.httpbin.org/post&#x27;</span>, <span class="hljs-attribute">data</span>=data)<br><span class="hljs-built_in">print</span>(response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br></code></pre></td></tr></table></figure><h5 id="timeout-参数"><a href="#timeout-参数" class="headerlink" title="timeout 参数"></a>timeout 参数</h5><p>用于设置超时时间，单位为秒。 </p><p>其支持 HTTP, HTTPS, FTP 请求。</p><p>通过 <code>try ... expect ...</code> 实现当一个网站长时间未响应就跳过对它的抓取:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import socket<br>import urllib<span class="hljs-selector-class">.request</span><br>import urllib<span class="hljs-selector-class">.error</span><br><br>try:<br>    response = urllib<span class="hljs-selector-class">.request</span><span class="hljs-selector-class">.urlopen</span>(<span class="hljs-string">&#x27;https://www.httpbin.org/get&#x27;</span>, timeout=<span class="hljs-number">0.1</span>)<br>except urllib<span class="hljs-selector-class">.erro</span><span class="hljs-selector-class">.URLError</span> as e:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(e<span class="hljs-selector-class">.reason</span>, socket.timeout):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;TIME OUT&#x27;</span>)<br></code></pre></td></tr></table></figure><p>常理来说，0.1 秒不可能得到服务器的响应。</p><h5 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h5><p>Request 是一个类，将向 urlopen 传入一个 url 改为一个对象，方便配置参数:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import urllib<span class="hljs-selector-class">.request</span><br><br>request = urllib<span class="hljs-selector-class">.request</span><span class="hljs-selector-class">.Request</span>(<span class="hljs-string">&#x27;https://python.org&#x27;</span>)<br>response = urllib<span class="hljs-selector-class">.request</span><span class="hljs-selector-class">.urlopen</span>(request)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(response.read()</span></span><span class="hljs-selector-class">.decode</span>(<span class="hljs-string">&#x27;utd-8&#x27;</span>))<br></code></pre></td></tr></table></figure><p>Request 类构造:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">class</span> usrllib.request.Request(url, data=None, headers=<span class="hljs-comment">&#123;&#125;</span>, origin_req_host=None, unvarifiable=<span class="hljs-keyword">False</span>, <span class="hljs-keyword">method</span>=<span class="hljs-title function_">None</span>)<br></code></pre></td></tr></table></figure><p>添加请求头最常见的办法是通过修改 User-Agent 来伪装浏览器。</p><p>通过 <code>add_header</code> 方法添加 headers 的方式:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">req = request(url=url, data=data, <span class="hljs-keyword">method</span>=&#x27;<span class="hljs-title function_">POST</span>&#x27;)<br><span class="hljs-title function_">req</span>.<span class="hljs-title function_">add_header</span><span class="hljs-params">(<span class="hljs-string">&#x27;User-Agent&#x27;</span>, <span class="hljs-string">&#x27;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h5 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h5><p>如 Cookie 处理、代理设置等。</p><p>使用 Handler 工具.</p><p>urllib.request 模块里的 BaseHandler 类是其他所有 Handler 类的父类。</p><p>另一个比较重要的类是 OpenerDirecctor, 简称为 Opener, 其提供 <code>open</code> 方法，该方法返回的相应类型和 urlopen 一致.</p><p>一般用 Handler 类来创建 Opener 类。</p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>在访问某些网站是会有认证窗口。表明其启用了基本身份认证(HTTP Basic Access Authentication).</p><p>利用 HTTPBasicAuthHandler 模块完成请求:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from urllib<span class="hljs-selector-class">.request</span> import HTTPPasswordMgrWithDefaultRealm, HTTPBasicAuthHandler, build_opener<br>from urllib<span class="hljs-selector-class">.error</span> import URLError<br><br>username = <span class="hljs-string">&#x27;admin&#x27;</span><br>password = <span class="hljs-string">&#x27;admin&#x27;</span><br>url = <span class="hljs-string">&#x27;https://ssr3.scrape.center/&#x27;</span><br><br><span class="hljs-selector-tag">p</span> = <span class="hljs-built_in">HTTPPasswordMgrWithDefaultRealm</span>()<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.add_password</span>(None, url, username, password)<br>auth_handler = <span class="hljs-built_in">HTTPBasicAuthHandler</span>(p)<br>opener = <span class="hljs-built_in">build_opener</span>(auth_handler)<br><br>try:<br>    result = opener<span class="hljs-selector-class">.open</span>(url)<br>    <span class="hljs-selector-tag">html</span> = result<span class="hljs-selector-class">.read</span>()<span class="hljs-selector-class">.decode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(html)<br>except URLError as e:<br>    <span class="hljs-built_in">print</span>(e.reason)<br></code></pre></td></tr></table></figure><h5 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h5><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><h3 id="2-处理异常"><a href="#2-处理异常" class="headerlink" title="2 处理异常"></a>2 处理异常</h3><p>当出现问题时，request 模块便会抛出 error 模块中定义的异常.</p><h4 id="URLError"><a href="#URLError" class="headerlink" title="URLError"></a>URLError</h4><p>URLErrot 类来自 urllib 库中的 error 模块，继承自 OSError 类，是 error 异常模块的基类.</p><p>其有 reason 属性，返回错误原因。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> request, error<br><br><span class="hljs-keyword">try</span>:<br>    response = request.urlopen(<span class="hljs-string">&#x27;https://cuiqigcai.com/404&#x27;</span>)<br>expect URLError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(e.reason)<br></code></pre></td></tr></table></figure><h4 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a>HTTPError</h4><p>是 URLError 的子类，用于处理 HTTP 请求错误.</p><p>其有3个属性:</p><ul><li>code, 返回 HTTP 状态码</li><li>reason, 返回错误原因</li><li>headers, 返回请求头<br>因为 HTTPError 是 URLError 的子类，所以可以先捕获子类的错误再捕获父类的错误。</li></ul><h3 id="3-解析链接"><a href="#3-解析链接" class="headerlink" title="3 解析链接"></a>3 解析链接</h3><p>urllib 库中的 parse 模块，其定义了处理 URL 的标准接口.</p><h4 id="urlparse"><a href="#urlparse" class="headerlink" title="urlparse"></a>urlparse</h4><p>用于实现 URL 的识别和分段的方法。也就是说，一个 URL 是有很多部分组成的，这个方法可以把各个部分区分开. 其利用 URL 中特定的分隔符。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">from</span> <span class="hljs-variable">urllib.parse</span> <span class="hljs-variable">import</span> <span class="hljs-variable">urlparse</span><br><br><span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-function"><span class="hljs-title">urlparse</span>(<span class="hljs-string">&#x27;https://www.baidu.com/index.html;user?id=comment&#x27;</span>)</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">type</span>(<span class="hljs-variable"><span class="hljs-class">result</span></span>))</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable"><span class="hljs-class">result</span></span>)</span><br></code></pre></td></tr></table></figure><p>一个标准的链接格式:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">scheme:<span class="hljs-regexp">//</span>netloc/path;params?query<span class="hljs-comment">#fragment</span><br></code></pre></td></tr></table></figure><p>urlparse 的 API 用法:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">urllib.parse.urlparse(urlstring, schem<span class="hljs-string">e&#x27;&#x27;</span>, allow_fragments=<span class="hljs-keyword">True</span>)<br></code></pre></td></tr></table></figure><p>三个参数:</p><ul><li>urlsring, 即 url</li><li>scheme, 填写协议，只有在 url 中不包含协议时生效</li><li>allow_fragments, 是否省略掉 fragments 部分<br>urlparse 的结果是一个元组，可以用属性名或索引来获取。</li></ul><h4 id="urlunparse"><a href="#urlunparse" class="headerlink" title="urlunparse"></a>urlunparse</h4><p>用于构造 url, 其接受的参数是一个可迭代对象，且长度为6.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from urllib import urlunparse<br><br>data = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;https&#x27;</span>, <span class="hljs-string">&#x27;www.baidu.com&#x27;</span>, <span class="hljs-string">&#x27;index.html&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>. <span class="hljs-string">&#x27;a=6&#x27;</span>, <span class="hljs-string">&#x27;comment&#x27;</span>]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(urlunparse(data)</span></span>)<br></code></pre></td></tr></table></figure><h4 id="urlsplit"><a href="#urlsplit" class="headerlink" title="urlsplit"></a>urlsplit</h4><p>类似于 urlparse.</p><h4 id="urlunsplit"><a href="#urlunsplit" class="headerlink" title="urlunsplit"></a>urlunsplit</h4><p>类似于 urlunparse.</p><h4 id="urljoin"><a href="#urljoin" class="headerlink" title="urljoin"></a>urljoin</h4><p>可以实现链接的解析，拼合与生成。</p><h4 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode"></a>urlencode</h4><p>其在构造 GET 请求时非常有用, 其将字典转换为 url 参数:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from urllib import urlencode<br><br>params = &#123;<br>    <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;germey&#x27;</span>,<br>    <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span><br>&#125;<br>base_url = <span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span><br>url = base_url + <span class="hljs-built_in">urlencode</span>(params)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(url)</span></span><br></code></pre></td></tr></table></figure><h4 id="pase-qs"><a href="#pase-qs" class="headerlink" title="pase_qs"></a>pase_qs</h4><p>将 GET 请求参数传回字典</p><h4 id="parse-qsl"><a href="#parse-qsl" class="headerlink" title="parse_qsl"></a>parse_qsl</h4><h4 id="quote"><a href="#quote" class="headerlink" title="quote"></a>quote</h4><p>将内容转化为 url 编码模式。</p><h4 id="unquote"><a href="#unquote" class="headerlink" title="unquote"></a>unquote</h4><h3 id="4-分析-Robots-协议"><a href="#4-分析-Robots-协议" class="headerlink" title="4 分析 Robots 协议"></a>4 分析 Robots 协议</h3><p>使用 urllib 库中的 robotparse 模块进行分析.</p><h4 id="Robots-协议"><a href="#Robots-协议" class="headerlink" title="Robots 协议"></a>Robots 协议</h4><p>Robots 协议也称爬虫协议，全名为 Robots Exclusion Protocol, 来告诉爬虫和搜索1引擎哪些页面可以爬取。通常是一个 robots.txt 文本文件，位于网站的根目录下，</p><p>搜索爬虫在访问一个站点时，首先会检查这个站点根目录下是否存在 robots.txt 文件，若存在, 则在其定义的爬取范围内爬取。</p><p>robots.txt 样例:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts">User-agent: *<br><span class="hljs-symbol">Disallow:</span> /<br><span class="hljs-symbol">Allow:</span> <span class="hljs-keyword">/public/</span><br></code></pre></td></tr></table></figure><p>其限制了只能爬取 public 目录。</p><p><code>User-agent</code> 描述了搜索爬虫的名称。</p><p><code>Disallow</code> 指定了不允许爬虫爬去的目录，<code>/</code> 表示不允许爬取所有页面.</p><p><code>Allow</code> 一般不单独使用。</p><p>允许爬虫访问所有目录的代码:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">User-agent: *</span><br><span class="hljs-section">Disallow:</span><br></code></pre></td></tr></table></figure><p>只允许某一个爬虫访问所有目录:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">User-agent: WebCrawler</span><br><span class="hljs-section">Disallow:</span><br><span class="hljs-section">User-agent: *</span><br><span class="hljs-section">Disallow: /</span><br></code></pre></td></tr></table></figure><h4 id="爬虫名称"><a href="#爬虫名称" class="headerlink" title="爬虫名称"></a>爬虫名称</h4><p>爬虫有固定名称。</p><h4 id="robotparser"><a href="#robotparser" class="headerlink" title="robotparser"></a>robotparser</h4><p>使用 robotparser 模块来解析 robots.txt 文件。</p><p>该模块提供了 RobotFileParser 类，其根据某网站的 robots.txt 文件来判断一个爬取爬虫是否有权限爬取这个网站。</p><p>RobotFileParser 类的声明:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">urllib.robotparse.RobotFileParser(<span class="hljs-attribute">url</span>=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>传入 robots.txt 文件的链接。</p><p>RobotFileParser 类的常用方法:</p><ul><li>set_url</li><li>read</li><li>parse</li><li>can_fetch</li><li>mtime</li><li>modified<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">from urllib.robotparser import RobotFileParser<br><br>rp = <span class="hljs-constructor">RobotFileParser()</span><br>rp.set<span class="hljs-constructor">_url(&#x27;<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">www</span>.<span class="hljs-params">baidu</span>.<span class="hljs-params">com</span><span class="hljs-operator">/</span><span class="hljs-params">robots</span>.<span class="hljs-params">txt</span>&#x27;)</span><br>rp.read<span class="hljs-literal">()</span><br>print(rp.can<span class="hljs-constructor">_fetch(&#x27;Baiduspider&#x27;, &#x27;<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">www</span>.<span class="hljs-params">baidu</span>.<span class="hljs-params">com</span>&#x27;)</span>)<br>print(rp.can<span class="hljs-constructor">_fetch(&#x27;Baiduspider&#x27;, &#x27;<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">www</span>.<span class="hljs-params">baidu</span>.<span class="hljs-params">com</span><span class="hljs-operator">/</span><span class="hljs-params">homepage</span><span class="hljs-operator">/</span>&#x27;)</span>)<br>print(rp.can<span class="hljs-constructor">_fetch(&#x27;Googlebot, &#x27;<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">www</span>.<span class="hljs-params">baidu</span>.<span class="hljs-params">com</span>&#x27;)</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-2-requests-的使用"><a href="#2-2-requests-的使用" class="headerlink" title="2.2 requests 的使用"></a>2.2 requests 的使用</h2><p>requests 库用 <code>get</code> 方法请求网页。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> requests<br><br>r = requests.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><p>利用 requests 库构建 GET 请求的方法.</p><h4 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h4><p>利用 params 参数传递信息:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">data</span> = &#123;<br>    <span class="hljs-string">&#x27;name&#x27;</span> : <span class="hljs-string">&#x27;germey&#x27;</span><br>    <span class="hljs-string">&#x27;age&#x27;</span> : <span class="hljs-number">25</span><br>&#125;<br>r = request.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;https://www.httpbin.org/get&#x27;</span>, params=<span class="hljs-keyword">data</span>)<br></code></pre></td></tr></table></figure><p>调用 json 方法可以将返回结果(JSON格式的字符串)转化为字典。</p><h4 id="抓取网页"><a href="#抓取网页" class="headerlink" title="抓取网页"></a>抓取网页</h4><h4 id="抓取二进制数据"><a href="#抓取二进制数据" class="headerlink" title="抓取二进制数据"></a>抓取二进制数据</h4><p>如抓取图片、音频、视频等文件。</p><p>Response 对象的两个属性:</p><ul><li>text, 其为 Unicode 文本</li><li>content, 其为 bytes 文本</li></ul><h4 id="添加请求头"><a href="#添加请求头" class="headerlink" title="添加请求头"></a>添加请求头</h4><h2 id="2-3-正则表达式"><a href="#2-3-正则表达式" class="headerlink" title="2.3 正则表达式"></a>2.3 正则表达式</h2><p>Python 的 re 库提供了整个正则表达式的实现.</p><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>从字符串开头进行匹配，若开头不一致则匹配失败。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = re.match(<span class="hljs-string">&#x27;Hello&#x27;</span>, content)<br></code></pre></td></tr></table></figure><p>第一个参数为 regex, 第二个为匹配对象。</p><p>非贪婪的写法为 <code>.*?</code></p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>第三个参数为修饰符:</p><ul><li>re.I, 大小写不敏感</li><li>re.L, 本地化识别匹配</li><li>re.M, 多行匹配，影响 ^ 和 $</li><li>re.S, 匹配内容包括换行符在内的所有字符</li><li>re.U, 根据 Unicode 字符集解析字符</li><li>re.X, 书写表达式更灵活</li></ul><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>这个方法比较类似 Perl 中的 match.</p><p>返回与正则表达式相匹配的第一个字符串.</p><p>使用 group 方法提取括号捕获的内容。</p><h3 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h3><p>返回的结果是列表类型，能够获取与正则表达式相匹配的所有字符串。</p><h3 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h3><p>用于修改文本.</p><p>应该是作用于所有匹配的文本。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">content</span> = re.sub(regex, replacement, content)<br></code></pre></td></tr></table></figure><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><p>将正则字符串编译成正则表达式对象，方便复用:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">pattern</span> = re.compile(regex)<br><span class="hljs-attr">result</span> = re.search(pattern, content)<br></code></pre></td></tr></table></figure><p>compile 同样可以传入修饰符。</p><h2 id="2-4-httpx-的使用"><a href="#2-4-httpx-的使用" class="headerlink" title="2.4 httpx 的使用"></a>2.4 httpx 的使用</h2><p>urllib 库和 requests 库只能爬取支持 HTTP&#x2F;1.1 的网站。</p><p>支持 HTTP&#x2F;2.0 的请求库，具有代表性的是 hyper 和 httpx.</p><p>查看网站的 Network 面板，如果 Protocol 一列是 h2, 证明请求所用的协议是 HTTP&#x2F;2.0</p><h1 id="第3章-网页数据的解析提取"><a href="#第3章-网页数据的解析提取" class="headerlink" title="第3章 网页数据的解析提取"></a>第3章 网页数据的解析提取</h1><h2 id="3-1-XPath-的使用"><a href="#3-1-XPath-的使用" class="headerlink" title="3.1 XPath 的使用"></a>3.1 XPath 的使用</h2><p>XPath 的全称为 XML Path Language, 即 XML 路径语言。用来在 XML 文档中查找信息。</p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>提供路径选择表达式和内建函数。</p><h3 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h3><ul><li>nodename : 选取此节点的所有子节点</li><li>&#x2F; : 选取当前节点的直接子节点</li><li>&#x2F;&#x2F; : 选取当前节点的子孙结点</li><li>. : 选取当前节点</li><li>.. : 选取当前节点的父节点</li><li>@ : 选取属性</li><li>[@attrib] : 选取具有给定属性的所有元素</li><li>[tag] : 选取所有具有指定元素的直接子节点</li><li>[tag&#x3D;’text’] : 选取所有具有指定元素并且文本内容是 text 的节点<br>如:<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>title[@lang=<span class="hljs-string">&#x27;eng&#x27;</span>]<br></code></pre></td></tr></table></figure>每一个规则后面跟的应该就是变量名，这里代表所有名称为 title，同时属性 lang 的值为 eng 的节点.</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> lxml<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Python 中三个引号允许字符串跨多行使用，包括换行，tab等特殊字符。引号可以为单引号也可为双引号.</p><p>lxml 库中的 etree 模块可以自动修正 HTML 文本.</p><p>构造解析对象:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">html</span> = etree<span class="hljs-selector-class">.HTML</span>(text)<br>result = etree<span class="hljs-selector-class">.tostring</span>(html)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(result.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)</span></span>)<br></code></pre></td></tr></table></figure><p><code>text</code> 是一段 HTML 代码字符串，这里 <code>HTML</code> 是一个类，用于初始化这个文本。</p><p><code>tostring</code> 方法输出修正后的 HTML 文本。但其为 bytes 类型。</p><p>也可直接解析文本文件:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from lxml import etree <br><br><span class="hljs-selector-tag">html</span> = etree<span class="hljs-selector-class">.parse</span>(<span class="hljs-string">&#x27;./test.html&#x27;</span>, etree<span class="hljs-selector-class">.HTMLParser</span>())<br>result = etree<span class="hljs-selector-class">.tostring</span>(html)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(result.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)</span></span>)<br></code></pre></td></tr></table></figure><p>这里的 <code>parse</code> 方法的第一个参数为 HTML 文件的路径.</p><h3 id="所有节点"><a href="#所有节点" class="headerlink" title="所有节点"></a>所有节点</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from lxml import etree<br><br><span class="hljs-selector-tag">html</span> = etree<span class="hljs-selector-class">.parse</span>(<span class="hljs-string">&#x27;./test.html&#x27;</span>, etree<span class="hljs-selector-class">.HTMLParser</span>())<br>result = <span class="hljs-selector-tag">html</span><span class="hljs-selector-class">.xpath</span>(<span class="hljs-string">&#x27;//*&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(result)</span></span><br></code></pre></td></tr></table></figure><p>这里 <code>xpath</code> 方法的参数就是 XPath 表达式，其中 <code>*</code> 匹配所有节点。</p><p>结果返回一个列表。其中每个元素都是 Element 类型。</p><h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><p>选择当前 li 节点的所有直接子节点 a:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = html.path(<span class="hljs-string">&#x27;//li/a&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">result</span> = html.xpath(<span class="hljs-string">&#x27;//a[<span class="hljs-variable">@href</span>=&quot;link4.html&quot;]/../<span class="hljs-variable">@class</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>//a[@href=&quot;link4.html&quot;]</code> 的含义是，节点为 <code>a</code>, 其属性 <code>href</code> 的值为 <code>link4.html</code>.</p><h3 id="属性匹配"><a href="#属性匹配" class="headerlink" title="属性匹配"></a>属性匹配</h3><h3 id="文本获取"><a href="#文本获取" class="headerlink" title="文本获取"></a>文本获取</h3><p>用 XPath 中的 <code>text</code> 方法可以得到节点中的文本:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li[@class=&quot;item-0&quot;]/text()&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><p>使用 <code>@</code> 符号:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li/a/@href&#x27;</span>)<br></code></pre></td></tr></table></figure><p>直接的 <code>@href</code> 是获取 href 属性的值，<code>[@href=&quot;link4.html&quot;]</code> 是限定某个属性.</p><h3 id="属性多值匹配"><a href="#属性多值匹配" class="headerlink" title="属性多值匹配"></a>属性多值匹配</h3><p>也就是某个属性的值有多个, 但只限定一个, 使用 <code>contain</code> 方法:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li[contains(@class, &quot;li&quot;)]/a/text()&#x27;</span>)<br></code></pre></td></tr></table></figure><p>第一个参数为属性名，第二个参数为值.</p><h3 id="多属性匹配"><a href="#多属性匹配" class="headerlink" title="多属性匹配"></a>多属性匹配</h3><p>需要根据多个属性来确定一个节点, 使用 <code>and</code> 连接多个属性:</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golo">result = html.xpath(&#x27;//li[contains(<span class="hljs-meta">@class</span>, <span class="hljs-string">&quot;li&quot;</span>) and <span class="hljs-meta">@name</span>=<span class="hljs-string">&quot;item&quot;</span>]/a/text()&#x27;)<br></code></pre></td></tr></table></figure><h3 id="XPath-中的运算符"><a href="#XPath-中的运算符" class="headerlink" title="XPath 中的运算符"></a>XPath 中的运算符</h3><ul><li>or</li><li>and</li><li>mod</li><li>|</li><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li>div</li><li>&#x3D;</li><li>!&#x3D;</li><li>&lt; </li><li>&lt;&#x3D;</li><li><blockquote></blockquote></li><li><blockquote><p>&#x3D;</p></blockquote></li></ul><h3 id="按序选择"><a href="#按序选择" class="headerlink" title="按序选择"></a>按序选择</h3><p>有多个匹配，但只选取一个:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li[1]/a/text()&#x27;</span>)  <span class="hljs-comment"># 1 即选择匹配到的第一个 </span><br><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li[last()]/a/text()&#x27;</span>)<br><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li[position()&lt;3]/a/text()&#x27;</span>)<br><span class="hljs-attr">result</span> = html.xpath(<span class="hljs-string">&#x27;//li[last()-2]/a/text()&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这时 <code>[]</code> 内应该为位置的 index.</p><h3 id="节点轴选择"><a href="#节点轴选择" class="headerlink" title="节点轴选择"></a>节点轴选择</h3><p>轴的形式为 <code>name::</code> </p><p>如祖先节点轴: <code>ancestor::</code></p><h2 id="3-2-Beautiful-Soup-使用"><a href="#3-2-Beautiful-Soup-使用" class="headerlink" title="3.2 Beautiful Soup 使用"></a>3.2 Beautiful Soup 使用</h2><p>Beautiful Soup 借助网页1的结构和属性等特性来解析网页。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Beautiful Soup 是 Python 的一个 HTML 或 XML 的解析库。</p><p>Beautiful Soup 会自动将输入文档转换为 Unicode 编码，将输出文档转换为 utf-8 编码。</p><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>Beautiful Soup 中的解析器及使用方法:</p><ul><li>Python 标准库, <code>BeautifulSoup(markup, &#39;html.parser&#39;)</code></li><li>LXML HTML, <code>BeautifulSoup(markup, &#39;lxml&#39;)</code></li><li>LXML XML, <code>BeautifulSoup(markup, &#39;xml&#39;)</code></li><li>html5lib, <code>BeautifulSoup(markup, &#39;html5lib&#39;)</code></li></ul><p>LXML 解析器能解析 HTML 和  XML.</p><p>例如:</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br>soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;p&gt;Hello&lt;p&gt;&#x27;</span>, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br><span class="hljs-built_in">print</span>(soup.p.<span class="hljs-built_in">string</span>)<br></code></pre></td></tr></table></figure><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from bs4 import BeautifulSoup<br><br>soup = <span class="hljs-built_in">BeautifulSoup</span>(<span class="hljs-selector-tag">html</span>, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(soup.prettify()</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(soup.title.string)</span></span><br></code></pre></td></tr></table></figure><p><code>BeautifulSoup</code> 是一个对象，其第一个参数为 HTML 字符串，第二个参数为解析器的类型。</p><p>用到的几个方法:</p><h4 id="prettify"><a href="#prettify" class="headerlink" title="prettify()"></a>prettify()</h4><p>把要解析的字符串以标准的缩进格式输出。</p><p>也就是让我们以美观的方式看到最开始要处理的字符串.</p><p>若 HTML 字符串不标准，可以自动更正。</p><h4 id="title"><a href="#title" class="headerlink" title="title"></a>title</h4><p><code>soup.title.string</code> 其中 title 是选出 HTML 中的 title 节点，调用 <code>string</code> 属性就得到节点内的文本.</p><h3 id="节点选择器"><a href="#节点选择器" class="headerlink" title="节点选择器"></a>节点选择器</h3><p>实际上，直接调用节点的名称就能选择节点，如 head, p 等。在调用 <code>string</code> 属性就可以得到文本。不用 <code>string</code> 打印的就是 HTML 代码。</p><p>形式为:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">bs4.element.<span class="hljs-keyword">tag</span><br></code></pre></td></tr></table></figure><p><code>Tag</code> 就是属性。</p><p>当有多个节点时，这种方法只能选取第一个匹配项。</p><h3 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h3><h4 id="获取节点名称"><a href="#获取节点名称" class="headerlink" title="获取节点名称"></a>获取节点名称</h4><p>使用 <code>name</code> 属性。</p><h4 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h4><p>使用 <code>attrs</code> 属性，其返回字典:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(soup.p.attrs)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(soup.p.attrs[<span class="hljs-string">&#x27;name&#x27;</span>])</span></span><br></code></pre></td></tr></table></figure><h4 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h4><p>使用 <code>string</code> 属性。</p><h4 id="嵌套选择"><a href="#嵌套选择" class="headerlink" title="嵌套选择"></a>嵌套选择</h4><p>对付节点里面有节点:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">print</span>(soup.head.<span class="hljs-built_in">title</span>.<span class="hljs-built_in">string</span>)<br></code></pre></td></tr></table></figure><h3 id="关联选择"><a href="#关联选择" class="headerlink" title="关联选择"></a>关联选择</h3><p>即以某一点为当前节点，然后选取父节点之类的。</p><h4 id="子节点和子孙节点"><a href="#子节点和子孙节点" class="headerlink" title="子节点和子孙节点"></a>子节点和子孙节点</h4><p>调用 <code>contents</code> 属性，获取直接子节点, 其得到的结果是直接子节点组成的列表。</p><p>调用 <code>children</code> 属性能得到相应的结果。其返回结果是生成器类型。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from bs4 import BeautifulSoup<br><br>soup = <span class="hljs-built_in">BeautifulSoup</span>(<span class="hljs-selector-tag">html</span>, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(soup.p.children)</span></span><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span>, child <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(soup<span class="hljs-selector-class">.p</span>.children)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-selector-tag">i</span>, child)<br></code></pre></td></tr></table></figure><p>这里 <code>enumerate()</code> 函数是 Python 内置函数，其参数为可迭代对象, 可用于计数，返回值是 enumerate 对象，可同时获取参数的索引和值，比如这里的 <code>i</code> 就是索引，<code>child</code> 就是值。</p><p>得到子孙结点，调用 <code>descendants</code> 属性。其返回结果也是生成器类型。</p><h4 id="父节点和祖先节点"><a href="#父节点和祖先节点" class="headerlink" title="父节点和祖先节点"></a>父节点和祖先节点</h4><p>获取父节点，用 <code>parent</code> 属性。</p><p>获取所有祖先节点，用 <code>parents</code> 属性。</p><h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><p>下一个兄弟节点用 <code>next_siblings</code> 属性。</p><p>上一个用 <code>previous_siblings</code> 属性.</p><h4 id="提取信息-1"><a href="#提取信息-1" class="headerlink" title="提取信息"></a>提取信息</h4><p>同样用 <code>string</code> 等。</p><h3 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h3><p>方便灵活查询.</p><h4 id="find-all"><a href="#find-all" class="headerlink" title="find_all"></a>find_all</h4><p>查询所有符合条件的元素，可以给它传入一些属性或文本:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">find<span class="hljs-constructor">_all(<span class="hljs-params">name</span>, <span class="hljs-params">attrs</span>, <span class="hljs-params">recursive</span>, <span class="hljs-params">text</span>, <span class="hljs-operator">**</span><span class="hljs-params">kwargs</span>)</span><br></code></pre></td></tr></table></figure><p>其返回值是列表。</p><h5 id="name"><a href="#name" class="headerlink" title="name"></a>name</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">find<span class="hljs-constructor">_all(<span class="hljs-params">name</span>=<span class="hljs-params">head</span>)</span><br></code></pre></td></tr></table></figure><h5 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h5><p>传入的参数为字典类型:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">find_all</span><span class="hljs-params">(attrs=&#123;<span class="hljs-string">&#x27;id&#x27;</span> : <span class="hljs-string">&#x27;list&#x27;</span>&#125;)</span></span><br></code></pre></td></tr></table></figure><h5 id="text"><a href="#text" class="headerlink" title="text"></a>text</h5><p>可以传入字符串，也可以是正则表达式:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">print(soup.find<span class="hljs-constructor">_all(<span class="hljs-params">text</span>=<span class="hljs-params">re</span>.<span class="hljs-params">compile</span>(&#x27;<span class="hljs-params">link</span>&#x27;)</span>))<br></code></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>返回单个元素.</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>使用方法和 find_all 相同:</p><ul><li>find_parents</li><li>find_parent</li><li>find_next_siblings</li><li>find_previous_siblings</li><li>find_all_next</li><li>find_next</li><li>find_all_previous</li><li>find_previous</li></ul><h3 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h3><h2 id="3-3-pyquery-的使用"><a href="#3-3-pyquery-的使用" class="headerlink" title="3.3 pyquery 的使用"></a>3.3 pyquery 的使用</h2><p>适合于喜欢用 CSS 选择器。</p><h2 id="3-4-parsel-的使用"><a href="#3-4-parsel-的使用" class="headerlink" title="3.4 parsel 的使用"></a>3.4 parsel 的使用</h2><p>XPath 和 CSS 选择器一起使用。</p><h1 id="第4章-数据的存储"><a href="#第4章-数据的存储" class="headerlink" title="第4章 数据的存储"></a>第4章 数据的存储</h1><h2 id="4-2-JSON-文件存储"><a href="#4-2-JSON-文件存储" class="headerlink" title="4.2 JSON 文件存储"></a>4.2 JSON 文件存储</h2><p>JSON 全称为 JavaScript Object Notation, 即 JavaScript 对象标记，通过对象和数组的组合表示数据.</p><h3 id="对象和数组"><a href="#对象和数组" class="headerlink" title="对象和数组"></a>对象和数组</h3><p>对象在 JavaScript 中是指用花括号 <code>&#123;&#125;</code> 包围起来的内容，数据结构是 <code>&#123;key1: value1, key2: value2 ...&#125;</code>. 在面向对象语言中，<code>key</code> 表示对象的属性、<code>value</code> 表示属性对应的值。</p><p>数组在 JavaScript 中是指用方括号 <code>[]</code> 包围起来的内容，数据结构是 <code>[&quot;java&quot;, &quot;javascript&quot;, ...]</code> 这种索引结构。</p><h3 id="读取-JSON"><a href="#读取-JSON" class="headerlink" title="读取 JSON"></a>读取 JSON</h3><p>使用 Python 的 json 库。</p><p><code>loads</code> 方法，将文本字符串转化为 JSON 对象(即 Python 中的列表和字典的嵌套组合).</p><p><code>dumps</code> 方法，将 JSON 对象转化为文本字符串。</p><p>获取键值的方法有两种:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">data<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;name&#x27;</span>]</span><br>data<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>get</code> 方法也可传入第二个参数，其为不存在键名时返回的值。</p><p>JSON 的数据需要用双引号包裹而不是单引号。</p><p><code>load</code> 方法的参数是一个文本操作对象:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> <span class="hljs-type">json</span><br><br>data = <span class="hljs-type">json</span>.<span class="hljs-keyword">load</span>(<span class="hljs-keyword">open</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>print(data)<br></code></pre></td></tr></table></figure><h3 id="输出-JSON"><a href="#输出-JSON" class="headerlink" title="输出 JSON"></a>输出 JSON</h3><p>如果想保存 JSON 对象的缩进格式，往 dumps 方法中添加 <code>indent</code> 参数，代表缩进字符的个数。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>     <span class="hljs-built_in">file</span>.<span class="hljs-built_in">write</span>(json.dumps(data, indent=<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>要想输出中文，需指定参数 <code>ensure_ascii</code> 为 <code>False</code>:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>     <span class="hljs-built_in">file</span>.<span class="hljs-built_in">write</span>(json.dumps(data, indent=<span class="hljs-number">2</span>, ensure_ascii=False))<br></code></pre></td></tr></table></figure><p>也有 <code>dump</code> 方法:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">json.dump(data, open(<span class="hljs-string">&#x27;data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-attribute">endocing</span>=<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-attribute">indent</span>=2, <span class="hljs-attribute">ensure_ascii</span>=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h2 id="4-4-MySQL-存储"><a href="#4-4-MySQL-存储" class="headerlink" title="4.4 MySQL 存储"></a>4.4 MySQL 存储</h2><p>使用 PyMySQL 库操作 MySQL 数据库。</p><h1 id="第5章-Ajax-数据爬取"><a href="#第5章-Ajax-数据爬取" class="headerlink" title="第5章 Ajax 数据爬取"></a>第5章 Ajax 数据爬取</h1><p>Ajax 的全称为 Asynchronous JavaScript and XML, 即异步的 JavaScript 和 XML.</p><p>如: 页面下滑时慢慢加载就是在向 Ajax 获取数据。</p><h2 id="5-1-基本原理"><a href="#5-1-基本原理" class="headerlink" title="5.1 基本原理"></a>5.1 基本原理</h2><p>分为三步:</p><ul><li>发送请求</li><li>解析内容</li><li>渲染页面</li></ul><p>Ajax 是由 JavaScript 实现的。</p><h2 id="5-2-Ajax-分析方法"><a href="#5-2-Ajax-分析方法" class="headerlink" title="5.2 Ajax 分析方法"></a>5.2 Ajax 分析方法</h2><p>Ajax 有其独特的请求类型，叫做 <code>xhr</code></p><h2 id="5-3-Ajax-分析与爬取实战"><a href="#5-3-Ajax-分析与爬取实战" class="headerlink" title="5.3 Ajax 分析与爬取实战"></a>5.3 Ajax 分析与爬取实战</h2><p>在 HTML 中，只能看到源码引用的一些 JavaScript 和 CSS 文件，并没有观察到其他有用信息，说明其在后台调用了 Ajax 接口。</p><p>字典中的 <code>get()</code> 利用键来获取值。</p><h1 id="第6章-异步爬虫"><a href="#第6章-异步爬虫" class="headerlink" title="第6章 异步爬虫"></a>第6章 异步爬虫</h1><h2 id="6-1-协程的基本原理"><a href="#6-1-协程的基本原理" class="headerlink" title="6.1 协程的基本原理"></a>6.1 协程的基本原理</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>协程(coroutine), 是一种运行在用户态的轻量级线程。其拥有自己的寄存器和上下文。</p><h3 id="asyncio-库用法"><a href="#asyncio-库用法" class="headerlink" title="asyncio 库用法"></a>asyncio 库用法</h3><p>几个概念:</p><ul><li>event_loop: 事件循环，相当于无限循环，可将函数注册在其上，当满足条件时调用</li><li>coroutine: Python 中指代协程对象类型，可将其注册到事件循环上</li><li>task: 任务，对协程对象的包装</li><li>future: 代表将来执行或没有执行的任务的结果，本质上同 task</li></ul><h4 id="定义协程"><a href="#定义协程" class="headerlink" title="定义协程"></a>定义协程</h4><p><code>async</code> 关键字，用于定义一个方法, 其为一个无法直接执行的协程对象，必须将此对象注册到事件循环中才可以执行。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua">import asycio<br><br>async def <span class="hljs-built_in">execute</span>(x):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Number:&#x27;</span>, x)<br><br><span class="hljs-built_in">coroutine</span> = <span class="hljs-built_in">execute</span>(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Coroutine:&#x27;</span>, <span class="hljs-built_in">coroutine</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;After calling execute&#x27;</span>)<br><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(<span class="hljs-built_in">coroutine</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;After calling loop&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这里 <code>get_event_loop()</code> 方法创建了一个事件循环, 即其返回值是一个事件循环。</p><p><code>run_until_complete()</code> 方法将协程对象注册到事件循环中. 也就是执行。其在内部隐式将协程对象变为 task.</p><p>显式将协程对象封装为task:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">task</span> <span class="hljs-operator">=</span> loop.create_task(coroutine)<br></code></pre></td></tr></table></figure><p>另外定义 task 的方法, 使用 asyncio 包的 <code>ensure_future</code> 方法:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">task</span> <span class="hljs-operator">=</span> asyncio.ensure_future(coroutine)<br></code></pre></td></tr></table></figure><h4 id="绑定-callback"><a href="#绑定-callback" class="headerlink" title="绑定 callback"></a>绑定 callback</h4><p>即在 task 完成时就会调用的方法, 使用 task 对象的 <code>add_done_callback()</code> 方法:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 中 if __name__ == &#39;__main__&#39; 理解</title>
    <link href="/2022/08/22/Python-%E4%B8%AD-if-name-main-%E7%90%86%E8%A7%A3/"/>
    <url>/2022/08/22/Python-%E4%B8%AD-if-name-main-%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>可以用来检查是否在运行自己。</p><p><code>if __name__ == &#39;__main__&#39;:</code> 只有在代码作为脚本直接运行时才会被执行，而 <code>import</code> 到其他脚本中是不会被执行的。</p><p>如:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">__name__</span> == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;test&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h1 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h1><p>每个 Python 模块(即 Python 文件) 都包含内置变量 <code>__name__</code>, 当模块被直接执行时，其值等于 <code>__main__</code>.</p><p>而被 <code>import</code> 时，其值为文件名.</p><h1 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h1><p><code>if __name__ == &#39;__main__&#39;:</code> 可以模拟程序的入口。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 模块 doctest</title>
    <link href="/2022/08/22/Python-%E6%A8%A1%E5%9D%97-doctest/"/>
    <url>/2022/08/22/Python-%E6%A8%A1%E5%9D%97-doctest/</url>
    
    <content type="html"><![CDATA[<h1 id="doctest-–-Test-interactive-Python-examples"><a href="#doctest-–-Test-interactive-Python-examples" class="headerlink" title="doctest – Test interactive Python examples"></a>doctest – Test interactive Python examples</h1><p><code>doctest</code> 模块会寻找<code>&gt;&gt;&gt;</code>然后执行，判断是否正常工作。</p><p>可用于测试 <code>docstring</code> 是否 up-to-date.</p><p>使用如:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> example.<span class="hljs-keyword">py</span> -v<br></code></pre></td></tr></table></figure><p>前提是要有如下代码:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if __name__ <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;__main__&quot;</span><br>  import doctest<br>  doctest.testmod()<br></code></pre></td></tr></table></figure><p>另一种方法调用可以不用写上述代码:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> -<span class="hljs-keyword">m</span> doctest -v example.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 的部分命令行选项</title>
    <link href="/2022/08/22/Python-%E7%9A%84%E9%83%A8%E5%88%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9/"/>
    <url>/2022/08/22/Python-%E7%9A%84%E9%83%A8%E5%88%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="c-选项"><a href="#c-选项" class="headerlink" title="-c 选项"></a><code>-c</code> 选项</h1><p>应该意为 code.</p><p>后面跟一段 Python 代码。</p><p>如:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">pytho<span class="hljs-symbol">n3</span> -c <span class="hljs-string">&quot;print(&#x27;hello world&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p>若要多行代码, 使用三个单引号<code>&#39;&#39;&#39;</code>:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">python3 -c &#x27;&#x27;&#x27;<br>&gt;print(1)<br>&gt;print(2)<br>&#x27;&#x27;&#x27;<br></code></pre></td></tr></table></figure><h1 id="m-选项"><a href="#m-选项" class="headerlink" title="-m 选项"></a><code>-m</code> 选项</h1><p>应该意为 module.</p><p>后面跟一个 Python 模块</p><h1 id="i-选项"><a href="#i-选项" class="headerlink" title="-i 选项"></a><code>-i</code> 选项</h1><p>应该意为 interactivity.<br>当一个脚本传入或者使用 <code>-c</code> 选项时，执行后进入交互模式，即执行完脚本后就开始<code>&gt;&gt;&gt;</code>:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">pytho<span class="hljs-symbol">n3</span> -i -c <span class="hljs-string">&quot;print(1)&quot;</span><br><span class="hljs-number">1</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h1 id="q-选项"><a href="#q-选项" class="headerlink" title="-q 选项"></a><code>-q</code> 选项</h1><p>应该意为 quiet.</p><p>不显示版权和版本信息.</p><h1 id="W-选项"><a href="#W-选项" class="headerlink" title="-W 选项"></a><code>-W</code> 选项</h1><p>应该意为 Warn.</p><p>包括:</p><ul><li>-Wdefault</li><li>-Werror</li><li>-Walways</li><li>-Wmodule</li><li>-Wonce</li><li>-Wignore</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>流畅的Python</title>
    <link href="/2022/08/22/%E6%B5%81%E7%95%85%E7%9A%84Python/"/>
    <url>/2022/08/22/%E6%B5%81%E7%95%85%E7%9A%84Python/</url>
    
    <content type="html"><![CDATA[<p><code>doctest</code>是 Python 的一个标准库，用来测试，通过模拟控制台对话来检验表达式求值是否正确。</p><p>如:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> -<span class="hljs-keyword">m</span> doctest example_script.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><h1 id="第一部分-序幕"><a href="#第一部分-序幕" class="headerlink" title="第一部分 序幕"></a>第一部分 序幕</h1><h2 id="第一章-Python-数据模型"><a href="#第一章-Python-数据模型" class="headerlink" title="第一章 Python 数据模型"></a>第一章 Python 数据模型</h2><h3 id="1-1-一摞-Python-风格的纸牌"><a href="#1-1-一摞-Python-风格的纸牌" class="headerlink" title="1.1 一摞 Python 风格的纸牌"></a>1.1 一摞 Python 风格的纸牌</h3><p>特殊方法 <code>__len__</code> 和 <code>__getitem</code>.</p><p><code>__len__</code> 支持 <code>len()</code> 操作:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>  <span class="hljs-keyword">return</span> len(<span class="hljs-variable language_">self</span>._cards)<br></code></pre></td></tr></table></figure><p><code>__getitem__</code> 支持 <code>card[]</code> 这样的数组操作:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, position</span>):<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._card[position]<br></code></pre></td></tr></table></figure><h3 id="1-2-如何使用特殊方法"><a href="#1-2-如何使用特殊方法" class="headerlink" title="1.2 如何使用特殊方法"></a>1.2 如何使用特殊方法</h3><p>特殊方法的存在是为了被 Python 解释器调用的，你自己并不需要调用他们。</p><p><code>PyVarObject</code> 是表示内存中长度可变的内置对象的 C 语言结构体。</p><p>特殊方法的调用是隐式的，如 <code>for i in x:</code> 语句，背后其实用的是 <code>iter(x)</code>, 而这个函数的背后则是 <code>x.__iter__()</code> 方法。</p><p>通过内置的函数(如 len、iter、str, 等) 来使用特殊方法是最好的选择。</p><p>不要随意添加特殊方法。</p><h4 id="1-2-1-模拟数值类型"><a href="#1-2-1-模拟数值类型" class="headerlink" title="1.2.1 模拟数值类型"></a>1.2.1 模拟数值类型</h4><p>利用特殊方法，可以让自定义对象通过加号等运算符进行运算。</p><p>特殊方法 <code>__repr__</code>、<code>__abs__</code>、<code>__add__</code>、<code>__mul__</code> 实现向量类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> hypot<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span></span>):<br>        self.x = x<br>        self.y = y<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Vector(%r, %r)&#x27;</span> % (self.x, self.y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__abs__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> hypot(self.x, self.y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bool__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(<span class="hljs-built_in">abs</span>(self))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        x = self.x + other.x<br>        y = self.y + other.y<br>        <span class="hljs-keyword">return</span> Vector(x, y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params">self, scalar</span>):<br>        <span class="hljs-keyword">return</span> Vector(self.x * scalar, self.y * scalar)<br></code></pre></td></tr></table></figure><h4 id="1-2-2-字符串表示形式"><a href="#1-2-2-字符串表示形式" class="headerlink" title="1.2.2 字符串表示形式"></a>1.2.2 字符串表示形式</h4><p>Python 的一个内置函数叫 <code>repr</code>(感觉为 representation), 其将一个对象用字符串的形式表达出来，也就是”字符串表示形式”. 其利用的是 <code>__repr__</code> 特殊方法。</p><p>使用 <code>%r</code> 来获取对象各个属性的标准字符串表示形式。</p><p><code>__repr__</code> 和 <code>__str__</code> 的区别在于，后者是在 <code>str()</code> 函数被使用，或是在 <code>print</code> 函数打印一个对象的时候才被调用。<br><a href="http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python">difference between <strong>str</strong> and <strong>repr</strong> in Python</a></p><h4 id="1-2-3-算术运算符"><a href="#1-2-3-算术运算符" class="headerlink" title="1.2.3 算术运算符"></a>1.2.3 算术运算符</h4><p>通过 <code>__add__</code> 和 <code>__mul__</code>.</p><h4 id="1-2-4-自定义的布尔值"><a href="#1-2-4-自定义的布尔值" class="headerlink" title="1.2.4 自定义的布尔值"></a>1.2.4 自定义的布尔值</h4><p>为了判断一个值 <code>x</code> 为真还是为假，Python 会调用 <code>bool(x)</code>, 这个函数只能返回 True 或者 False.</p><p><code>bool(x)</code> 的背后是调用 <code>x.__bool__()</code> 的结果。如果不存在 <code>__bool__</code> 方法，那么 <code>bool(x)</code> 会尝试调用 <code>x.__len__()</code>, 若返回 0, 则为 false.</p><p>可以实现为:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__bool__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-keyword">return</span> bool(<span class="hljs-variable language_">self</span>.x <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.y)<br></code></pre></td></tr></table></figure><h3 id="1-3-特殊方法一览"><a href="#1-3-特殊方法一览" class="headerlink" title="1.3 特殊方法一览"></a>1.3 特殊方法一览</h3><p><a href="https://docs.python.org/3/reference/datamodel.html">Python 语言参考手册</a></p><h3 id="1-4-为什么-len-不是普通方法"><a href="#1-4-为什么-len-不是普通方法" class="headerlink" title="1.4 为什么 len 不是普通方法"></a>1.4 为什么 len 不是普通方法</h3><p>速度可以很快。</p><h3 id="1-6-延伸阅读"><a href="#1-6-延伸阅读" class="headerlink" title="1.6 延伸阅读"></a>1.6 延伸阅读</h3><p><a href="https://docs.python.org/3/reference/datamodel.html">Python 语言参考手册里的 “Data Model” 一章</a><br><a href="http://stackoverflow.com/users/95810/alex-martelli">Martelli 的 Stack Overflow 主页</a></p><p>特殊方法有时被称为魔术方法。</p><p>元对象协议，元对象指那些对建构语言本身来讲很重要的对象，协议可以看做接口。元对象协议和对象模型都是指建构核心语言的 API.</p><h1 id="第二部分-数据结构"><a href="#第二部分-数据结构" class="headerlink" title="第二部分 数据结构"></a>第二部分 数据结构</h1><h2 id="第2章-序列构成的数组"><a href="#第2章-序列构成的数组" class="headerlink" title="第2章 序列构成的数组"></a>第2章 序列构成的数组</h2><h3 id="2-1-内置序列类型概览"><a href="#2-1-内置序列类型概览" class="headerlink" title="2.1 内置序列类型概览"></a>2.1 内置序列类型概览</h3><ul><li>容器序列, list、tuple 和 collections.deque 这些序列能存放不同类型的数据</li><li>扁平序列，str、bytes、bytearray、memoryview 和 array.array, 这些序列只能容纳一种类型</li></ul><p>容器序列存放的是它们所包含的任意类型的对象的引用。</p><p><mark>扁平序列</mark>存放的是值而不是引用，其为一段连续的内存空间。</p><ul><li>可变序列，list、bytearray、array.array、collections.deque 和 memoryview</li><li>不可变序列，tuple、str 和 bytes</li></ul><h3 id="2-2-列表推导和生成器表达式"><a href="#2-2-列表推导和生成器表达式" class="headerlink" title="2.2 列表推导和生成器表达式"></a>2.2 列表推导和生成器表达式</h3><p>list comprehension(listcomps) 是构建列表的快捷方式。</p><p>生成器表达式(generator expression 简称为 genexps)则可以用来创建其他任何类型的序列。</p><h4 id="2-2-1-列表推导和可读性"><a href="#2-2-1-列表推导和可读性" class="headerlink" title="2.2.1 列表推导和可读性"></a>2.2.1 列表推导和可读性</h4><p>通常的原则是，只用列表推导来创建新的列表，而且尽量保持简短。</p><p>Python 会省略代码里 <code>[]</code>、<code>&#123;&#125;</code> 和 <code>()</code> 中的换行。</p><h5 id="列表推导不会再有变量泄露问题"><a href="#列表推导不会再有变量泄露问题" class="headerlink" title="列表推导不会再有变量泄露问题"></a>列表推导不会再有变量泄露问题</h5><p>列表推导和生成器表达式在 Python3 中都有局部作用域。</p><h4 id="2-2-2-列表推导同-filter-和-map-的比较"><a href="#2-2-2-列表推导同-filter-和-map-的比较" class="headerlink" title="2.2.2 列表推导同 filter 和 map 的比较"></a>2.2.2 列表推导同 filter 和 map 的比较</h4><h4 id="2-2-3-笛卡尔积"><a href="#2-2-3-笛卡尔积" class="headerlink" title="2.2.3 笛卡尔积"></a>2.2.3 笛卡尔积</h4><p>笛卡尔积是一个列表，其长度等于输入变量长度的乘积，其元素为输入变量的一一组合而构成的元组。</p><p>如:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mel">  &gt;&gt;&gt; colors = [<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>]<br>  &gt;&gt;&gt; sizes = [<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>]<br>  &gt;&gt;&gt; tshirts = [(<span class="hljs-keyword">color</span>, <span class="hljs-keyword">size</span>) <span class="hljs-keyword">for</span> <span class="hljs-keyword">color</span> <span class="hljs-keyword">in</span> colors <span class="hljs-keyword">for</span> <span class="hljs-keyword">size</span> <span class="hljs-keyword">in</span> sizes]<br>   <span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string">列表推导的作用只有一个：生成列表。</span><br><span class="hljs-string">#### 2.2.4 生成器表达式</span><br><span class="hljs-string">生成器表达式遵循迭代器原理，可以住个人产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。</span><br><span class="hljs-string"></span><br><span class="hljs-string">生成器表达式的语法跟列表推导差不多，只是把方括号改为圆括号而已。</span><br><span class="hljs-string"></span><br><span class="hljs-string">如果生成器表达式是一个函数调用工程中的唯一参数，那么不需要额外用括号把它围起来。</span><br></code></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>tuple(ord(symbol) for symbol in symbols)<br>   <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">生成笛卡尔积:</span><br></code></pre></td></tr></table></figure><br>colors &#x3D; [‘black’, ‘white’]<br>sizes &#x3D; [‘S’, ‘M’, ‘L’]<br>for tshirt in (‘%s %s’ % (c, s) for c in colors for s in sizes):<br>     print(tshirt)<br>   <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs clean">### <span class="hljs-number">2.3</span> 元组不仅仅是不可变的列表<br>元组还可以用作没有字段名的记录。<br>#### <span class="hljs-number">2.3</span><span class="hljs-number">.1</span> 元组和记录<br>元组其实是对数据的记录: 元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。<br><br>把元组当做一些字段的集合时，其数量和位置信息就非常重要。<br><br>如果在任何表达式里我们在元组内对元素排序，这些元素所携带的信息就会丢失，因为这些信息是跟它们的位置有关的。<br><br>for 循环可以分别提取元组里的元素，也叫做拆包(unpacking).<br>#### <span class="hljs-number">2.3</span><span class="hljs-number">.2</span> 元组拆包<br>最好辨认的元组拆包形式就是平行赋值:<br></code></pre></td></tr></table></figure><br>lax_coordinates &#x3D; (33.9425, -118.408056)<br>latitude, longitude &#x3D; lax_coordinates # 元组拆包<br>   <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">可以用 <span class="hljs-string">`*`</span> 运算符把一个可迭代对象拆开作为函数的参数:<br></code></pre></td></tr></table></figure><br>t &#x3D; (20, 8)<br>divmod(*t)<br>   <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">`_` 占位符用于处理不感兴趣的数据。<br>##### 用 * 来处理剩下的元素<br>在 Python 中，函数使用 `*args` 来获取不确定数量的参数。<br><br>在 Python3 中，这个概念被扩展到了平行赋值中:<br></code></pre></td></tr></table></figure><br>a, b, *rest &#x3D; range(5)<br>a, b, rest<br>  (0, 1, [2, 3, 4])<br>   <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">在平行赋值中，<span class="hljs-string">`*`</span> 前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的任何位置:<br></code></pre></td></tr></table></figure><br>a, *body, c, d &#x3D; range(5)<br>a, body, c, d<br>  (0, [1, 2], 3, 4)<br>   <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### <span class="hljs-number">2.3</span><span class="hljs-number">.3</span> 嵌套元组拆包<br>接受表达式的元组可以是嵌套式的, 如: (a, b, (c, d)).<br><br>在 Python3 之前，元组可以作为形参放在函数声明中, 如:`def fn(a, (b, c), d):`, 然而 Python3 不再支持这种格式。<br>#### <span class="hljs-number">2.3</span><span class="hljs-number">.4</span> 具名元组<br>`collections.namedtuple` 函数用于构建一个带字段名的元组和一个有名字的类。<br><br>创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字，后者可以是有多个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的一个字符串。<br></code></pre></td></tr></table></figure><br>from collections import namedtuple<br>City &#x3D; namedtuple(‘City’, ‘name country population coordinates’)<br>tokyo &#x3D; City(‘Tokyo’, ‘JP’, ‘36.933’, (35.68922, 139.691667))<br>tokyo<br>  City(name&#x3D;’Tokyo’, country&#x3D;’JP’, population&#x3D;36.933, coordinates&#x3D;(35.689722, 139.691667))</p><p>tokyo.population<br>  36.933<br>   <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs clean">所以说第一个参数是显示在括号之前. 等号之前的才是真正的类。一般这两个取相同的值。<br><br>具名元组还有一些自己专有的属性, 最有用的有: `_fields` 类属性、类方法 `_make(iterable)` 和实例方法 `_asdict`(所以说给变量或者函数命名时首字母尽量不用下划线).<br>#### <span class="hljs-number">2.3</span><span class="hljs-number">.5</span> 作为不可变列表的元组<br>除了跟增减元素相关的方法之外，元组支持列表的其他所有方法。<br>### <span class="hljs-number">2.4</span> 切片<br>#### <span class="hljs-number">2.4</span><span class="hljs-number">.1</span> 为什么切片和区间会忽略最后一个元素<br>这个习惯符合 Python, C 和其他语言里以 <span class="hljs-number">0</span> 作为起始下标的传统。<br>#### <span class="hljs-number">2.4</span><span class="hljs-number">.2</span> 对对象进行切片<br>可以用 `s[a:b:c]` 的形式对 s 在 a 和 b 之间以 c 为间隔取值.<br><br>在对 `seq[start:stop:step]` 进行求值的时候，Python 会调用 `seq.__getitem__(slice(start, stop, step))`.<br><br>切片还有两个额外的功能: 多维切片和省略.<br>#### <span class="hljs-number">2.4</span><span class="hljs-number">.3</span> 多维切片和省略<br>`[]` 运算符里还可以使用以逗号分开的多个索引或者是切片.<br><br>要得到 `a[i, j]` 的值，Python 会调用 `a.__getitem__((i, j))`<br><br>省略(ellipsis)的正确书写方法是三个英语句号(...), 其实际上是 Ellipsis 对象的别名，而 Ellipsis 对象又是 ellipsis 类的单一实例。<br>#### <span class="hljs-number">2.4</span><span class="hljs-number">.4</span> 给切片赋值<br></code></pre></td></tr></table></figure><br>l &#x3D; list(range(10))<br>1<br>  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>l[2:5] &#x3D; [20, 30]<br>l<br>  [0, 1, 20, 30, 5, 6, 7, 8, 9]<br>   <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">### <span class="hljs-number">2.5</span> 对序列使用 + 和 *<br>Python 程序员会默认序列是支持 `+` 和 `*` 操作的。<br><br>`+` 用于拼接.<br><br>`*` 用于复制多份。<br>#### 建立由列表组成的列表<br><span class="hljs-title">用列表推导实现:</span><br></code></pre></td></tr></table></figure><br>board &#x3D; [[‘<em>‘] * 3 for i in range(3)]<br>board<br>  [[‘</em>‘, ‘<em>‘, ‘</em>‘], [‘<em>‘, ‘</em>‘, ‘<em>‘], [‘</em>‘, ‘<em>‘, ‘</em>‘]]<br>   <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">区分:</span><br></code></pre></td></tr></table></figure><br>weird_borad &#x3D; [[‘_’] * 3] * 3</p></blockquote></blockquote></blockquote><pre><code class="hljs">其本质是一个对象的多个引用。### 2.6 序列的增量赋值增量赋值运算符 `+=` 和 `*=` 的表现取决于它们的第一个操作对象。`+=` 背后的特殊方法是 `__iadd__`, 其会就地改动，意思就是不会先做加法得到一个对象，然后赋值给左值.如果一个类没有实现这个方法，Python 会退一步调用 `__add__`, 即先做加法创建一个对象用于赋值.以上 `+=` 的概念也适用于 `*=`. 其对应的是 `__imul__`.对不可变序列进行重复拼接操作效率会很低，因为每次都有一个新对象，而解释器需要把原来对象中的元素先复制到新的对象里，然后追加新的元素。#### 一个关于 += 的谜题3个教训:  - 不要把可变对象放在元组里  - 增量赋值不是一个原子操作  - 查看 Python 的字节码对于了解代码背后的运行机制很有帮助### 2.7 list.sort 方法和内置函数 sorted`list.sort` 方法会就地排序列表，其返回值为 None.Python 的一个惯例: 如果一个函数或者方法对对象进行的是就地改动，那它就应该返回 None.`sorted` 函数会创建一个列表作为返回值。不管 `sorted` 接受的是何种参数，其最后都会返回一个列表。这两个都有两个可选的关键词参数:  - reverse, 设定为 True, 被排序的序列里的元素会以降序输出，其默认值为 False.  - key, 其为一个只有一个参数的函数，会作用到序列中的每一个元素上，产生的结果用作排序的对比关键词即依据。如 `key=len` 则使用字符串的长度排序。其默认值为恒等函数(identity function), 也就是默认用元素自己本身的值来排序。### 2.8 用 bisect 来管理已排序的序列bisect 模块包含两个主要函数，bisect 和 insort, 两个函数都利用二分查找算法来在有序序列中查找或插入元素。#### 2.8.1 用 bisect 来搜索其实就是用来找位置，即 index.`bisect(haystack, needle)`，在 haystack 里搜索可以放 needle 的位置，该位置满足的条件是，把 needle 插入这个位置之后，haystack 还能保持升序。其中 haystack 必须是一个有序的序列。`bisect` 函数是 `bisect_right` 函数的别名，其姐妹函数叫 `bisect_left`, 它们区别在于 `bisect_left` 返回的插入位置是原序列中跟被插入元素相等的元素的位置，也就是新元素会放置于它相等的元素的前面，而 `bisect_right` 会放在后面。`bisect` 函数有 lo 和 hi 两个可选参数。#### 2.8.2 用 bisect.insert 插入新元素`insort(seq, item)` 把变量 item 插入到序列 seq 中，并能保持 seq 的升序。### 2.9 当列表不是首选时#### 2.9.1 数组若需要一个只包含数字的列表，`array.array` 比 `list` 更高效。创建数组需要一个类型码，这个类型码用来表示在底层的 C 语言应该存放怎样的数据类型。Python 不会允许你在数组里存放除指定类型之外的数据。#### 2.9.2 内存视图`memoryview` 是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切片。`memoryview.cast` 的概念跟数组模块类似，能用不同的方式读写同一块内存数据，而且内容字节不会随意移动。和 C 语言中的类型转换差不多。#### 2.9.3 NumPy 和 SciPyNumPy 和 SciPy 提供高阶数组和矩阵操作。NumPy 实现了多维同质数组(homogeneous) 和矩阵，这些数据结构不但能处理数字，还能存放其他由用户定义的记录。SciPy 是基于 NumPy 的另一个库，它提供了很多跟科学计算有关的算法，专为线性代数、数值积分和统计学而设计。SciPy 背后为 C 和 Fortran 代码。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查看PYTHONPATH</title>
    <link href="/2022/08/22/%E6%9F%A5%E7%9C%8BPYTHONPATH/"/>
    <url>/2022/08/22/%E6%9F%A5%E7%9C%8BPYTHONPATH/</url>
    
    <content type="html"><![CDATA[<h1 id="查看-PYTHONPATH"><a href="#查看-PYTHONPATH" class="headerlink" title="查看 PYTHONPATH"></a>查看 PYTHONPATH</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>python3<br><span class="hljs-variable">$ </span>&gt;&gt;&gt; <span class="hljs-keyword">import</span> sys<br>  &gt;&gt;&gt; sys.path<br></code></pre></td></tr></table></figure><h1 id="添加路径"><a href="#添加路径" class="headerlink" title="添加路径"></a>添加路径</h1><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">&gt;&gt;&gt; sys.<span class="hljs-built_in">path</span>.<span class="hljs-built_in">append</span>(路径)<br></code></pre></td></tr></table></figure><p>永久添加可以修改<code>.bashrc</code>文件。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决ImportError: cannot import name gcd from fractions 问题</title>
    <link href="/2022/08/22/%E8%A7%A3%E5%86%B3ImportError-cannot-import-name-gcd-from-fractions-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/22/%E8%A7%A3%E5%86%B3ImportError-cannot-import-name-gcd-from-fractions-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>好像 Python3.9 把 <code>gcd</code> 函数移入到 <code>math</code> 模块中了, 因此，将:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> fractions <span class="hljs-keyword">import</span> gcd<br></code></pre></td></tr></table></figure><p>改为:</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> <span class="hljs-built_in">math</span> <span class="hljs-keyword">import</span> gcd<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dist-packages 和 site-packages 的区别</title>
    <link href="/2022/08/22/dist-packages-%E5%92%8C-site-packages-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/08/22/dist-packages-%E5%92%8C-site-packages-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="dist-packages"><a href="#dist-packages" class="headerlink" title="dist-packages"></a>dist-packages</h1><p>当模块从Debian的包管理器下载时，其会被安装至<code>dist-packages</code>:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/python3.10/</span>dist-packages<br></code></pre></td></tr></table></figure><p>由于<code>easy_install</code>和<code>pip</code>都是从包管理器下载，因此用这两个安装的模块也会到<code>dist-packages</code>.</p><h1 id="site-packages"><a href="#site-packages" class="headerlink" title="site-packages"></a>site-packages</h1><p>从源代码安装Python, 其会使用<code>site-packages</code>目录。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下安装tkinter</title>
    <link href="/2022/08/22/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85tkinter/"/>
    <url>/2022/08/22/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85tkinter/</url>
    
    <content type="html"><![CDATA[<p>使用命令如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install python3-tk<br></code></pre></td></tr></table></figure><p>或者:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install python-tk<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装 turtle 库</title>
    <link href="/2022/08/22/%E5%AE%89%E8%A3%85-turtle-%E5%BA%93/"/>
    <url>/2022/08/22/%E5%AE%89%E8%A3%85-turtle-%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>直接通过<code>pip</code>安装会报错.</p><p>先通过<code>wget</code>下载:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> -O turtle-<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.tar.gz https://pypi.tuna.tsinghua.edu.cn/packages/ff/f0/<span class="hljs-number">21</span>a42e9e424d24bdd0e509d5ed3c7dfb8f47d962d9c044dba903b0b4a26f/turtle-<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.tar.gz<br></code></pre></td></tr></table></figure><p>解压后进入文件夹:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> turtle-<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">vim</span> setup.py<br></code></pre></td></tr></table></figure><p>修改第40行为:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">except</span> (ValueError, ve):<br></code></pre></td></tr></table></figure><p>也就是加了一个括号。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>wget 部分常用参数</title>
    <link href="/2022/08/22/wget-%E9%83%A8%E5%88%86%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/"/>
    <url>/2022/08/22/wget-%E9%83%A8%E5%88%86%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="下载单个文件并重命名"><a href="#下载单个文件并重命名" class="headerlink" title="下载单个文件并重命名"></a>下载单个文件并重命名</h1><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">wget -O <span class="hljs-keyword">new</span><span class="hljs-type">name</span> url<br></code></pre></td></tr></table></figure><h1 id="断电续传，也就是接着上次没下载完的"><a href="#断电续传，也就是接着上次没下载完的" class="headerlink" title="断电续传，也就是接着上次没下载完的"></a>断电续传，也就是接着上次没下载完的</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">wget -c url</span><br></code></pre></td></tr></table></figure><h1 id="后台下载"><a href="#后台下载" class="headerlink" title="后台下载"></a>后台下载</h1><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">wget</span> -<span class="hljs-keyword">b</span> url<br></code></pre></td></tr></table></figure><p>查看进度用:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">tail <span class="hljs-operator">-f</span> w<span class="hljs-built_in">get-log</span><br></code></pre></td></tr></table></figure><h1 id="下载多个文件"><a href="#下载多个文件" class="headerlink" title="下载多个文件"></a>下载多个文件</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cat</span> &gt; filelist.txt<br>url1<br>url2<br>url3<br>url4<br><br><span class="hljs-built_in">wget</span> <span class="hljs-literal">-i</span> filelist.txt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>wget: unable to resolve host address</title>
    <link href="/2022/08/22/wget-unable-to-resolve-host-address/"/>
    <url>/2022/08/22/wget-unable-to-resolve-host-address/</url>
    
    <content type="html"><![CDATA[<p>一般是网络问题。</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu 下 Python 模块的库导入</title>
    <link href="/2022/08/22/ubuntu-%E4%B8%8B-Python-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BA%93%E5%AF%BC%E5%85%A5/"/>
    <url>/2022/08/22/ubuntu-%E4%B8%8B-Python-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BA%93%E5%AF%BC%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>使用 <code>pip</code> 安装。</p><p><code>pip</code> 提速:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">mkdir</span> .pip<br><span class="hljs-keyword">cd</span> .pip<br><span class="hljs-keyword">vim</span> pip.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><p>添加:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>]<br>  <span class="hljs-keyword">index</span>-url=https://pypi.tuna.tsinghua.edu.cn/simple<br>[install]<br>  <span class="hljs-keyword">trusted</span>-host=mirrors.aliyun.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 小知识点</title>
    <link href="/2022/08/22/Python-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/08/22/Python-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="print-函数"><a href="#print-函数" class="headerlink" title="print() 函数"></a>print() 函数</h1><p>如:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">print</span>(&#x27;The <span class="hljs-built_in">length</span> of <span class="hljs-built_in">%s</span> <span class="hljs-built_in">is</span> %d&#x27; <span class="hljs-symbol">%</span>(s,x))<br></code></pre></td></tr></table></figure><p>这里的<code>%(s,x)</code>，其中<code>%</code>标记转换说明符的开始，<code>(s,x)</code>为转换说明符。</p><p>可以一次输出多个对象:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a, b)</span></span><br></code></pre></td></tr></table></figure><p>可直接输出列表，字典，元组等变量。</p><p>最小字段宽度和精度设置和C语言相同。</p><h1 id="try-…-except"><a href="#try-…-except" class="headerlink" title="try … except"></a>try … except</h1><p>将可能发生错误的语句放在<code>try</code>模块，用<code>except</code>处理异常。</p><p><code>except</code> 可以指定一个专门的异常，若未指定则默认为所有异常。</p><p>每一个<code>try</code>都至少要有一个<code>except</code>.</p><p>可以多分支.</p><p>若使用 <code>try ... except ... finally</code>, <code>finally</code> 部分无论 <code>try</code> 是否捕获错误都会执行。</p><p><code>except</code> 中的 <code>as</code> 应该是设置别名。</p><h1 id="字符串单引号和双引号"><a href="#字符串单引号和双引号" class="headerlink" title="字符串单引号和双引号"></a>字符串单引号和双引号</h1><p>两者皆可。</p><h1 id="range-x-y-z"><a href="#range-x-y-z" class="headerlink" title="range(x, y, z)"></a>range(x, y, z)</h1><p><code>z</code>是步长量。</p><h1 id="转换类型"><a href="#转换类型" class="headerlink" title="转换类型"></a>转换类型</h1><p>如:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">self.R</span> = int(R)<br></code></pre></td></tr></table></figure><h1 id="Python-缩进"><a href="#Python-缩进" class="headerlink" title="Python 缩进"></a>Python 缩进</h1><p>Python 用缩进来区分代码层次。</p><h1 id="m-选项"><a href="#m-选项" class="headerlink" title="-m 选项"></a><code>-m</code> 选项</h1><p>使用 <code>-m</code> 选项时，Python 会把当前工作目录添加到 <code>sys.path</code> 中。</p><h1 id="isinstance-函数"><a href="#isinstance-函数" class="headerlink" title="isinstance() 函数"></a>isinstance() 函数</h1><p>用于判断一个对象是否为一个已知类型。</p><p>语法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">isinstance</span><span class="hljs-params">(object, classinfo)</span></span> <br></code></pre></td></tr></table></figure><p>返回布尔值。</p><p>和 <code>type()</code> 的区别:</p><ul><li>type() 不考虑继承关系，不会认为子类是一种父类类型</li><li>isinstance() 考虑继承关系，认为子类是一种父类类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 极客项目编程</title>
    <link href="/2022/08/22/Python-%E6%9E%81%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/08/22/Python-%E6%9E%81%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第一部分-热身运动"><a href="#第一部分-热身运动" class="headerlink" title="第一部分 热身运动"></a>第一部分 热身运动</h1><h2 id="第1章-解析iTunes播放列表"><a href="#第1章-解析iTunes播放列表" class="headerlink" title="第1章 解析iTunes播放列表"></a>第1章 解析iTunes播放列表</h2><h3 id="1-1-iTunes-播放列表文件剖析"><a href="#1-1-iTunes-播放列表文件剖析" class="headerlink" title="1.1 iTunes 播放列表文件剖析"></a>1.1 iTunes 播放列表文件剖析</h3><h2 id="第2章-万花尺"><a href="#第2章-万花尺" class="headerlink" title="第2章 万花尺"></a>第2章 万花尺</h2><p><code>turtle</code>模块比较慢。</p><h3 id="2-1-参数方程"><a href="#2-1-参数方程" class="headerlink" title="2.1 参数方程"></a>2.1 参数方程</h3><h4 id="2-1-1-万花尺方程"><a href="#2-1-1-万花尺方程" class="headerlink" title="2.1.1 万花尺方程"></a>2.1.1 万花尺方程</h4><p>大多数计算机程序的角度计算需要弧度。</p><h1 id="第二部分-模拟生命"><a href="#第二部分-模拟生命" class="headerlink" title="第二部分 模拟生命"></a>第二部分 模拟生命</h1><h2 id="第3章-Conway-生命游戏"><a href="#第3章-Conway-生命游戏" class="headerlink" title="第3章 Conway 生命游戏"></a>第3章 Conway 生命游戏</h2><p>类似于 Pac-Man(吃豆子) 在边界的工作方式，如果超出了屏幕的顶部，就会重新在底部出现，如果超出了屏幕的左侧，就会重新在右侧出现。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在 Ubuntu 下安装JDK</title>
    <link href="/2022/08/20/%E5%9C%A8-Ubuntu-%E4%B8%8B%E5%AE%89%E8%A3%85JDK/"/>
    <url>/2022/08/20/%E5%9C%A8-Ubuntu-%E4%B8%8B%E5%AE%89%E8%A3%85JDK/</url>
    
    <content type="html"><![CDATA[<h1 id="安装-Open-JDK"><a href="#安装-Open-JDK" class="headerlink" title="安装 Open JDK"></a>安装 Open JDK</h1><p>添加OpenJDK源:</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">sudo<span class="hljs-built_in"> add-apt-repository </span>ppa:openjdk-r/ppa<br>sudo apt-get update<br>sudo apt-get install openjdk-8-jdk<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo deplpy 后404 not found</title>
    <link href="/2022/08/17/hexo-deplpy-%E5%90%8E404-not-found/"/>
    <url>/2022/08/17/hexo-deplpy-%E5%90%8E404-not-found/</url>
    
    <content type="html"><![CDATA[<p>在<code>hexo d</code>之后，Github上面的<code>CNAME</code>文件消失了，重新添加即可，最好是直接写在Blog所在本地目录中。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在hexo中添加图片</title>
    <link href="/2022/08/17/%E5%9C%A8hexo%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/"/>
    <url>/2022/08/17/%E5%9C%A8hexo%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>将图片放入<code>/source/img</code>中, 先安装一个插件, 才能用 markdown 的格式添加图片:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">cnpm install hexo-asset-<span class="hljs-built_in">image</span> --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure><p>还需确认<code>_config.yml</code>文件中<code>post_asset_folder: true</code>.</p><p>插入格式为:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">![alt](<span class="hljs-regexp">/img/</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown 插入图片</title>
    <link href="/2022/08/17/Markdown-%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <url>/2022/08/17/Markdown-%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>语法:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[显示失败时显示的文字]</span>(文件的本地路径)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Github Pages 和个人域名绑定</title>
    <link href="/2022/08/17/Github-Pages-%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"/>
    <url>/2022/08/17/Github-Pages-%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>添加两条记录.<br><img src="/img/add_records.png" alt="adding records1"><br><img src="/img/add_records1.png" alt="adding records2"></p><p>记录值是输入域名.</p><p>在Github Pages 中添加。在添加了记录之后, 添加可能还是会失败, 等待一段时间就可以成功。</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo fluid 主题 ERROR Script load failed 问题</title>
    <link href="/2022/08/17/hexo-fluid-%E4%B8%BB%E9%A2%98-ERROR-Script-load-failed-%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/17/hexo-fluid-%E4%B8%BB%E9%A2%98-ERROR-Script-load-failed-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>首先通过 cnpm 重新安装 fluid 主题.</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>修改 hexo 博客目录中的 <code>_config.yml</code>:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid<br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN<br></code></pre></td></tr></table></figure><p>遇到 <code>peerDependencies WARNING</code>. 看看缺什么，然后顺着安装.</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm ERR! Cannot read properties of null()</title>
    <link href="/2022/08/16/npm-ERR-Cannot-read-properties-of-null/"/>
    <url>/2022/08/16/npm-ERR-Cannot-read-properties-of-null/</url>
    
    <content type="html"><![CDATA[<p>使用<code>npn install hexo-util --save</code> 时报这个错.</p><p>使用<code>npm cache clear --force</code> 时报 <code>npm WARN using --force Recommended protections disabled</code></p><p>用<code>npm cache verify</code> 检查 cache 是否正常工作.</p><p>我的 npm 当前版本为 8.11.0.</p><p>降低版本:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install npm@<span class="hljs-number">6</span>.<span class="hljs-number">14</span>.<span class="hljs-number">10</span> -g<br></code></pre></td></tr></table></figure><p>若报错，则使用:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cnpm</span> install npm@<span class="hljs-number">6</span>.<span class="hljs-number">14</span>.<span class="hljs-number">10</span> -g<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm install 报错</title>
    <link href="/2022/08/16/npm-install-%E6%8A%A5%E9%94%99/"/>
    <url>/2022/08/16/npm-install-%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>使用 <code>cnpm</code> 下载.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 nrm</title>
    <link href="/2022/08/16/%E4%BD%BF%E7%94%A8-nrm/"/>
    <url>/2022/08/16/%E4%BD%BF%E7%94%A8-nrm/</url>
    
    <content type="html"><![CDATA[<p>查询已有源:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nrm <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>切换源:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">npm <span class="hljs-keyword">use</span> &lt;<span class="hljs-keyword">name</span>&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装hexo fluid主题</title>
    <link href="/2022/08/16/%E5%AE%89%E8%A3%85hexo-fluid%E4%B8%BB%E9%A2%98/"/>
    <url>/2022/08/16/%E5%AE%89%E8%A3%85hexo-fluid%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>hexo 的版本在 5.0.0 以上，直接通过 npm 安装:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>然后将 <code>_config.yml</code>的内容复制到 <code>_config.fluid.yml</code> 中。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 22.04 无法调节亮度</title>
    <link href="/2022/08/14/Ubuntu-22-04-%E6%97%A0%E6%B3%95%E8%B0%83%E8%8A%82%E4%BA%AE%E5%BA%A6/"/>
    <url>/2022/08/14/Ubuntu-22-04-%E6%97%A0%E6%B3%95%E8%B0%83%E8%8A%82%E4%BA%AE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>进入BIOS, 将 Graphic Device 中的 Discrete Graphic 改为 Dynamic Graphics.</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL基础教程 Notes</title>
    <link href="/2022/08/10/SQL%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-Notes/"/>
    <url>/2022/08/10/SQL%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第0章-绪论-搭建SQL的学习环境"><a href="#第0章-绪论-搭建SQL的学习环境" class="headerlink" title="第0章 绪论 搭建SQL的学习环境"></a>第0章 绪论 搭建SQL的学习环境</h1><h2 id="0-1-PostgreSQL的安装和连接设置"><a href="#0-1-PostgreSQL的安装和连接设置" class="headerlink" title="0-1 PostgreSQL的安装和连接设置"></a>0-1 PostgreSQL的安装和连接设置</h2><p>在命令行使用postgreSQL需要登录 postgres 账户:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo su postgres</span><br></code></pre></td></tr></table></figure><p>进入 sql 命令行执行:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>psql<br></code></pre></td></tr></table></figure><p>postgres 账户的目录在 &#x2F;var&#x2F;lib&#x2F;postgresql.</p><h2 id="官方Ubuntu上使用postgresql教程"><a href="#官方Ubuntu上使用postgresql教程" class="headerlink" title="官方Ubuntu上使用postgresql教程"></a>官方Ubuntu上使用postgresql教程</h2><p><a href="https://ubuntu.com/server/docs/databases-postgresql">reference</a></p><p>配置文件所在位置: &#x2F;etc&#x2F;postgresql&#x2F;<version>&#x2F;main, 目录中. 我的在: &#x2F;etc&#x2F;postgresql&#x2F;14&#x2F;main.</p><p>连接 default PostgreSQL template database:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> -u postgres psql template1<br></code></pre></td></tr></table></figure><p>To configure the password for the user postgres:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> postgres <span class="hljs-keyword">with</span> <span class="hljs-keyword">encrypted</span> <span class="hljs-keyword">password</span> <span class="hljs-string">&#x27;your_password&#x27;</span>;<br></code></pre></td></tr></table></figure><p>Restarting the PostgreSQL service to initialize the new configuration:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">sudo systemctl <span class="hljs-built_in">restart</span> postgresql.service<br></code></pre></td></tr></table></figure><h2 id="0-1"><a href="#0-1" class="headerlink" title="0-1"></a>0-1</h2><p><code>listen_addresses = &#39;*&#39;</code> 意味着允许所有远程主机进行连接。<br><code>listen_addresses = &#39;localhost&#39;</code> 意味着只允许本地机器进行连接。</p><h2 id="0-2-通过PostgreSQL执行SQL语句"><a href="#0-2-通过PostgreSQL执行SQL语句" class="headerlink" title="0-2 通过PostgreSQL执行SQL语句"></a>0-2 通过PostgreSQL执行SQL语句</h2><p><code>psql</code> 是 PostpreSQL 提供的通过命令行执行 SQL 语句的工具。</p><p><code>psql</code> 会把 SQL 语句发送给 PostgreSQL, 然后再将接收到的执行结果显示出来。</p><p>“;” 是 SQL 的结束符， 如果没有输入的话，即使按下回车键，SQL语句也不会执行。</p><p>数据库的名称只能是小写字母.</p><h3 id="创建学习用的数据库"><a href="#创建学习用的数据库" class="headerlink" title="创建学习用的数据库"></a>创建学习用的数据库</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> shop;<br></code></pre></td></tr></table></figure><p><code>postgres</code> 是安装 PostgreSQL 时自动创建的示例数据库。</p><h3 id="连接学习用的数据库-登录"><a href="#连接学习用的数据库-登录" class="headerlink" title="连接学习用的数据库(登录)"></a>连接学习用的数据库(登录)</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">psql -U postgres -d shop</span><br></code></pre></td></tr></table></figure><p>“-d shop” 是指定 “数据库shop” 的意思。</p><p>“-U username” 是 connect to the database as the user <code>username</code> instead of the default. </p><h1 id="第1章-数据库和SQL"><a href="#第1章-数据库和SQL" class="headerlink" title="第1章 数据库和SQL"></a>第1章 数据库和SQL</h1><h2 id="1-1-数据库是什么"><a href="#1-1-数据库是什么" class="headerlink" title="1-1 数据库是什么"></a>1-1 数据库是什么</h2><p>数据库(Database, DB)是将大量数据保存起来，通过计算机加工而成的可以进行高效访问的数据集合。</p><p>用来管理数据库的计算机系统称为<mark>Database Management System, DBMS</mark>.</p><p>系统使用者通常无法直接接触到数据库。</p><h3 id="DSMS的种类"><a href="#DSMS的种类" class="headerlink" title="DSMS的种类"></a>DSMS的种类</h3><p>通过数据的保存格式(数据库的种类)来分类，现阶段主要有以下5种类型:</p><ul><li>Hierarchical Database, HDB</li><li>Relational Database, RDB</li><li>Object Oriented Database, OODB</li><li>XML Database, XMLDB</li><li>Key-Value Store, KVS<br>使用SQL语言的数据库管理系统，也就是关系数据库管理系统(RDBMS).</li></ul><h2 id="1-2-数据库的结构"><a href="#1-2-数据库的结构" class="headerlink" title="1-2 数据库的结构"></a>1-2 数据库的结构</h2><h3 id="RDBMS-的常见系统结构"><a href="#RDBMS-的常见系统结构" class="headerlink" title="RDBMS 的常见系统结构"></a>RDBMS 的常见系统结构</h3><p>最常见的是客户端&#x2F;服务器类型(C&#x2F;S类型).</p><p>RDBMS 既可以和其客户端安装在同一台计算机上，也可以分别安装在不同的计算机上。</p><h3 id="表的结构"><a href="#表的结构" class="headerlink" title="表的结构"></a>表的结构</h3><p>用来管理数据的二维表在关系数据库中简称为<mark>表</mark>.</p><p>表存储在由 RDBMS 管理的数据库中， 一个数据库中可以存储多个表。</p><p>根据 SQL 语句的内容返回的数据同样必须是二维表的形式。</p><p>表的列（垂直方向）称为字段，它代表了保存在表中的数据项目。</p><p>表的行（水平方向）称为记录，它相当于一条数据。</p><p><mark>关系数据库必须以行为单位进行数据读写。</mark></p><p>行和列交汇的方格称为单元格。一个单元格中只<br>能输入一个数据。单元格只是这本书特有的表述方式.</p><h2 id="1-3-SQL-概要"><a href="#1-3-SQL-概要" class="headerlink" title="1-3 SQL 概要"></a>1-3 SQL 概要</h2><h3 id="标准-SQL"><a href="#标准-SQL" class="headerlink" title="标准 SQL"></a>标准 SQL</h3><h3 id="SQL-语句及其种类"><a href="#SQL-语句及其种类" class="headerlink" title="SQL 语句及其种类"></a>SQL 语句及其种类</h3><p>SQL 用关键字、表名、列名等组合而成的一条语句（SQL 语句）来描述操作的内容。</p><p>SQL 语句可以分为以下三类:</p><ul><li>DDL, Data Definition Language, 数据定义语言。其包含: create, drop, alter.</li><li>DML, Data Manipulation Language, 数据操纵语言. 包含: select, insert, update, delete.</li><li>DCL, Data Control Language, 数据控制语言。包含: commit, rollback, grant, revoke.</li></ul><h3 id="SQL-的基本书写规则"><a href="#SQL-的基本书写规则" class="headerlink" title="SQL 的基本书写规则"></a>SQL 的基本书写规则</h3><ul><li>以分号”;”结尾</li><li>SQL 语句不区分大小写, 表中的数据区分大小写</li><li>常数的书写方式是固定的，在SQL语句中直接书写的字符串、日期或者数字等称为常数, 字符串和日期用单引号”‘“标识。</li><li>单词需要用半角空格或者换行符来分隔</li></ul><h2 id="1-4-表的创建"><a href="#1-4-表的创建" class="headerlink" title="1-4 表的创建"></a>1-4 表的创建</h2><h3 id="表的内容的创建"><a href="#表的内容的创建" class="headerlink" title="表的内容的创建"></a>表的内容的创建</h3><h3 id="数据库的创建-create-database语句"><a href="#数据库的创建-create-database语句" class="headerlink" title="数据库的创建(create database语句)"></a>数据库的创建(create database语句)</h3><p>语法:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> &lt;数据库名称&gt;;<br></code></pre></td></tr></table></figure><h3 id="表的创建-create-table语句"><a href="#表的创建-create-table语句" class="headerlink" title="表的创建(create table语句)"></a>表的创建(create table语句)</h3><p>语法:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf">create <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;表名&gt;</span><br>(<span class="hljs-variable">&lt;列名1&gt;</span> <span class="hljs-variable">&lt;数据类型&gt;</span> <span class="hljs-variable">&lt;该列所需约束&gt;</span>,<br> <span class="hljs-variable">&lt;列名2&gt;</span> <span class="hljs-variable">&lt;数据类型&gt;</span> <span class="hljs-variable">&lt;该列所需约束&gt;</span>,<br> <span class="hljs-variable">&lt;列名3&gt;</span> <span class="hljs-variable">&lt;数据类型&gt;</span> <span class="hljs-variable">&lt;该列所需约束&gt;</span>,<br> <span class="hljs-variable">&lt;列名4&gt;</span> <span class="hljs-variable">&lt;数据类型&gt;</span> <span class="hljs-variable">&lt;该列所需约束&gt;</span>,<br>            .<br>            .<br>            .<br> <span class="hljs-variable">&lt;该表的约束1&gt;</span>, <span class="hljs-variable">&lt;该表的约束2&gt;</span>, ......);<br></code></pre></td></tr></table></figure><p><code>NOT NULL</code> 约束只能以列为单位进行设置。</p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>只能使用半角英文字母、数字、下划线作为数据库、表和列的名称。</p><p>名称必须以半角英文字母开头。</p><p>在同一个数据库中不能创建两个相同名称的列。</p><h3 id="数据类型的指定"><a href="#数据类型的指定" class="headerlink" title="数据类型的指定"></a>数据类型的指定</h3><p>所有列都必须指定数据类型。</p><p>数据类型包括:</p><ul><li>integer, 数字型, 不能存储小数</li><li>char, 字符型, char(10), 指定长度, 其为定长字符串</li><li>date, 日期型</li><li>varchar, 可变长字符串, 即使未达到最大长度，也不会用半角空格补足<br>每一列都不能存储与该列数据类型不符的数据。</li></ul><h3 id="约束的设置"><a href="#约束的设置" class="headerlink" title="约束的设置"></a>约束的设置</h3><p>约束是除了数据类型之外，对列中存储的数据进行限制或者追加条件的功能。</p><p><code>NULL</code> 代表可以输入空白。</p><p><code>NOT NULL</code> 代表不能输入空白.</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> (product_id)<br></code></pre></td></tr></table></figure><p>给<code>product_id</code>列设置主键约束。</p><p>主键约束 &#x3D; 非空约束 + 唯一约束</p><h2 id="1-5-表的删除和更新"><a href="#1-5-表的删除和更新" class="headerlink" title="1-5 表的删除和更新"></a>1-5 表的删除和更新</h2><h3 id="表的删除-drop-table"><a href="#表的删除-drop-table" class="headerlink" title="表的删除(drop table)"></a>表的删除(drop table)</h3><p>语法:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">drop</span> <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;表名&gt;</span>;<br></code></pre></td></tr></table></figure><p>删除的表无法恢复。</p><h3 id="表定义的更新-alter-table"><a href="#表定义的更新-alter-table" class="headerlink" title="表定义的更新(alter table)"></a>表定义的更新(alter table)</h3><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> <span class="hljs-operator">&lt;</span>列的定义<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>删除列的<code>alter table</code> 语句:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">alter <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;表名&gt;</span> <span class="hljs-keyword">drop</span> column <span class="hljs-variable">&lt;列名&gt;</span>;<br></code></pre></td></tr></table></figure><p><code>alter table</code> 执行后也无法恢复。</p><h3 id="向Product表中插入数据"><a href="#向Product表中插入数据" class="headerlink" title="向Product表中插入数据"></a>向Product表中插入数据</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">begin</span> <span class="hljs-keyword">transaction</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> &lt;表名&gt; <span class="hljs-keyword">values</span> ();<br><br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><h3 id="表的修改"><a href="#表的修改" class="headerlink" title="表的修改"></a>表的修改</h3><p>修改表名，不同数据库指令不同:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> &lt;originalname&gt; <span class="hljs-keyword">rename</span> <span class="hljs-keyword">to</span> &lt;<span class="hljs-type">name</span>&gt;<br></code></pre></td></tr></table></figure><h1 id="第2章-查询基础"><a href="#第2章-查询基础" class="headerlink" title="第2章 查询基础"></a>第2章 查询基础</h1><p>查询时可以指定一个或多个查询条件。</p><h2 id="2-1-select-语句基础"><a href="#2-1-select-语句基础" class="headerlink" title="2-1 select 语句基础"></a>2-1 select 语句基础</h2><h3 id="列的查询"><a href="#列的查询" class="headerlink" title="列的查询"></a>列的查询</h3><p>通过 select 语句查询并选取出必要数据的过程称为<mark>匹配查询</mark>或查询(query).</p><p>基本语法:</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">select</span> &lt;column <span class="hljs-built_in">name</span>&gt;, ...<br>  <span class="hljs-keyword">from</span> &lt;table <span class="hljs-built_in">name</span>&gt;;<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> product_id, product_name, purchase_price<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><p>查询多列时，需要逗号分隔。</p><h3 id="查询出表中所有列"><a href="#查询出表中所有列" class="headerlink" title="查询出表中所有列"></a>查询出表中所有列</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> *<br>  <span class="hljs-keyword">from</span> &lt;tablename&gt;;<br></code></pre></td></tr></table></figure><p>使用 <code>*</code> 无法设定列的显示顺序。</p><p>SQL 语句可以随意使用换行符。</p><h3 id="为列设定别名"><a href="#为列设定别名" class="headerlink" title="为列设定别名"></a>为列设定别名</h3><p>使用<code>as</code>关键词。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select product_id <span class="hljs-keyword">as</span> <span class="hljs-built_in">id</span><br>  <span class="hljs-keyword">from</span> Product<br></code></pre></td></tr></table></figure><p>别名若要使用中文需要用双引号(“)括起来。</p><h3 id="常数的查询"><a href="#常数的查询" class="headerlink" title="常数的查询"></a>常数的查询</h3><h3 id="从结果中删除重复行"><a href="#从结果中删除重复行" class="headerlink" title="从结果中删除重复行"></a>从结果中删除重复行</h3><p>通过 select 子句中使用 distinct:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> product_type<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><p>使用 distinct 时，null 也被视为一类数据。</p><h3 id="根据-where-语句来选择记录"><a href="#根据-where-语句来选择记录" class="headerlink" title="根据 where 语句来选择记录"></a>根据 where 语句来选择记录</h3><p>select 语句通过 where 子句来指定查询数据的条件。</p><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name<span class="hljs-operator">&gt;</span>, ...<br> <span class="hljs-keyword">from</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">table</span> name<span class="hljs-operator">&gt;</span> <br> <span class="hljs-keyword">where</span> <span class="hljs-operator">&lt;</span>expr<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>首先通过 where 子句查询出符合指定条件的记录，然后再选取出 select 语句指定的列。</p><p>SQL 中子句的书写顺序是固定的，where 子句必须紧跟在 from 子句之后。</p><h3 id="注释的书写方法"><a href="#注释的书写方法" class="headerlink" title="注释的书写方法"></a>注释的书写方法</h3><p>两种:</p><ul><li>1行注释，用<code>--</code></li><li>多行注释，用<code>/*</code> 和 <code>*/</code></li></ul><h2 id="2-2-算术运算符和比较运算符"><a href="#2-2-算术运算符和比较运算符" class="headerlink" title="2-2 算术运算符和比较运算符"></a>2-2 算术运算符和比较运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>如:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> product_name, sale_price,<br>       sale_price * <span class="hljs-number">2</span> <span class="hljs-keyword">as</span> <span class="hljs-string">&quot;sale_price_x2&quot;</span><br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><p>四则运算符号:</p><ul><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li>&#x2F;</li></ul><h3 id="需要注意NULL"><a href="#需要注意NULL" class="headerlink" title="需要注意NULL"></a>需要注意NULL</h3><p>所有包含 null 的计算，结果肯定是 null.</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>使用 <code>=</code> .</p><p>“不等于”比较运算符<code>&lt;&gt;</code>.</p><p>其他比较运算符:</p><ul><li><blockquote><p>&#x3D;</p></blockquote></li><li><blockquote></blockquote></li><li>&lt;&#x3D;</li><li>&lt;</li></ul><h3 id="对字符串使用不等号时的注意事项"><a href="#对字符串使用不等号时的注意事项" class="headerlink" title="对字符串使用不等号时的注意事项"></a>对字符串使用不等号时的注意事项</h3><p>在对字符串类型的数据进行大小比较时，使用的是和数字比较不同的规则。</p><p>按照字典顺序进行比较。以相同字符开头的单词比不同字符开头的单词更接近。</p><h3 id="不能对null使用比较运算符"><a href="#不能对null使用比较运算符" class="headerlink" title="不能对null使用比较运算符"></a>不能对null使用比较运算符</h3><p>SQL 提供了专门用来判断是否为 null 的 <code>is null</code> 运算符。</p><p>如:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> product_name, purchase_price<br>    <span class="hljs-keyword">from</span> Product<br>  <span class="hljs-keyword">where</span> purchase_price <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>若不是 null, 用 <code>is not null</code> 运算符。</p><h2 id="2-3-逻辑运算符"><a href="#2-3-逻辑运算符" class="headerlink" title="2-3 逻辑运算符"></a>2-3 逻辑运算符</h2><h3 id="not-运算符"><a href="#not-运算符" class="headerlink" title="not 运算符"></a>not 运算符</h3><p>需要和其他查询条件组合使用。</p><h3 id="and-运算符和-or-运算符"><a href="#and-运算符和-or-运算符" class="headerlink" title="and 运算符和 or 运算符"></a>and 运算符和 or 运算符</h3><p><code>and</code> 运算符是“与”运算。</p><p><code>or</code> 运算符是”或”运算。</p><h3 id="通过括号强化处理"><a href="#通过括号强化处理" class="headerlink" title="通过括号强化处理"></a>通过括号强化处理</h3><p><code>and</code> 运算符优先于 <code>or</code> 运算符。</p><p>日期的一种格式 <code>2009-09-11</code>.</p><h3 id="逻辑运算符和真值"><a href="#逻辑运算符和真值" class="headerlink" title="逻辑运算符和真值"></a>逻辑运算符和真值</h3><p>比较运算符会把运算结果以真值的形式返回。</p><p>使用 <code>and</code> 运算符进行的逻辑运算称为<mark>逻辑积</mark>.</p><p>使用 <code>or</code> 运算符进行的逻辑运算称为<mark>逻辑和</mark>.</p><p>不能对 null 使用比较运算符。</p><h3 id="含有-null-时的真值"><a href="#含有-null-时的真值" class="headerlink" title="含有 null 时的真值"></a>含有 null 时的真值</h3><p>真值中除真假之外的第三种值–不确定(unknown).</p><p>与通常的逻辑运算被称为<mark>二值逻辑</mark>. </p><p>SQL 中的逻辑运算被称为<mark>三值逻辑</mark>.</p><p>级别: 假 &gt; 不确定 &gt; 真.</p><p>尽量不使用 null, 其会使真值表更复杂。</p><h1 id="第3章-聚合与排序"><a href="#第3章-聚合与排序" class="headerlink" title="第3章 聚合与排序"></a>第3章 聚合与排序</h1><h2 id="3-1-对表进行聚合查询"><a href="#3-1-对表进行聚合查询" class="headerlink" title="3-1 对表进行聚合查询"></a>3-1 对表进行聚合查询</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>SQL中用于汇总的函数:</p><ul><li>count: 计算行数</li><li>sum: 列数据的合计值</li><li>avg: 列数据的平均值</li><li>max: 列数据的最大值</li><li>min: 列数据的最小值<br>用于汇总的函数称为<mark>聚合函数</mark>或者<mark>聚集函数</mark>.</li></ul><p>所谓<mark>聚合</mark>, 就是将多行汇总于一行.</p><h3 id="计算表中数据的行数"><a href="#计算表中数据的行数" class="headerlink" title="计算表中数据的行数"></a>计算表中数据的行数</h3><p>计算全部数据的行数:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(*)<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><h3 id="计算-null-之外的数据的行数"><a href="#计算-null-之外的数据的行数" class="headerlink" title="计算 null 之外的数据的行数"></a>计算 null 之外的数据的行数</h3><p>将对象列设定为参数而不是 <code>*</code>.</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(purchase_price)<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><p>使用星号是<code>count</code>函数特有的，其他函数不能将其作为参数。</p><h3 id="计算合计值"><a href="#计算合计值" class="headerlink" title="计算合计值"></a>计算合计值</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(sale_price)<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><p>所有的聚合函数，如果以列名为参数，那么在计算之前就已经把 null 排除在外了，因此无论有多少个 null 都会被无视。</p><h3 id="计算平均值"><a href="#计算平均值" class="headerlink" title="计算平均值"></a>计算平均值</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(sale_price)<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><h3 id="计算最大值和最小值"><a href="#计算最大值和最小值" class="headerlink" title="计算最大值和最小值"></a>计算最大值和最小值</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(sale_price), <span class="hljs-built_in">min</span>(purchase_price)<br>  from <span class="hljs-built_in">Product</span>;<br></code></pre></td></tr></table></figure><p>max&#x2F;min 函数原则上可以适用于任何数据类型的列。</p><p>sum&#x2F;avg 函数只适用于数值类型。</p><h3 id="使用聚合函数删除重复值-关键字distinct"><a href="#使用聚合函数删除重复值-关键字distinct" class="headerlink" title="使用聚合函数删除重复值(关键字distinct)"></a>使用聚合函数删除重复值(关键字distinct)</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> product_type)<br>  <span class="hljs-keyword">from</span> Product;<br></code></pre></td></tr></table></figure><p>在参数中使用 distinct. 所有的聚合函数都可以使用。</p><h2 id="3-2-对表进行分组"><a href="#3-2-对表进行分组" class="headerlink" title="3-2 对表进行分组"></a>3-2 对表进行分组</h2><p>语法结构:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name1<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name2<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name3<span class="hljs-operator">&gt;</span>, ......<br>    <span class="hljs-keyword">from</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">table</span> name<span class="hljs-operator">&gt;</span><br>  <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name1<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name2<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name3<span class="hljs-operator">&gt;</span>, ......;<br></code></pre></td></tr></table></figure><p><code>group by</code> 子句中指定的列称为 <mark>聚合键</mark>或者<mark>分组列</mark>.</p><p><code>group by</code> 子句应写在 <code>from</code> 语句之后，有 <code>where</code> 语句也应该在 <code>where</code> 语句之后.</p><h3 id="聚合键中包含-null-的情况"><a href="#聚合键中包含-null-的情况" class="headerlink" title="聚合键中包含 null 的情况"></a>聚合键中包含 null 的情况</h3><p>在结果中以空行的形式表现出来。</p><h3 id="使用-where-子句时-group-by-的执行结果"><a href="#使用-where-子句时-group-by-的执行结果" class="headerlink" title="使用 where 子句时 group by 的执行结果"></a>使用 where 子句时 group by 的执行结果</h3><h3 id="与聚合函数和-group-by-子句有关的常见错误"><a href="#与聚合函数和-group-by-子句有关的常见错误" class="headerlink" title="与聚合函数和 group by 子句有关的常见错误"></a>与聚合函数和 group by 子句有关的常见错误</h3><p>使用聚合函数时，select 子句中只能存在以下三种元素:</p><ul><li>常数</li><li>聚合函数</li><li>group by 子句中指定的列名<br>使用 group by 子句时，select 子句中不能出现聚合键之外的别名.</li></ul><p><code>group by</code> 子句也不能使用别名。</p><p><code>group by</code> 子句结果的显示是无序的。</p><p>在 <code>where</code> 子句中不能使用聚合函数。只有 <code>select</code> 子句和 <code>having</code> 子句(以及order by子句) 中能够使用聚合函数。 </p><p><code>distinct</code> 和 <code>group by</code> 都能够删除重复数据。</p><h2 id="3-3-为聚合结果指定条件"><a href="#3-3-为聚合结果指定条件" class="headerlink" title="3-3 为聚合结果指定条件"></a>3-3 为聚合结果指定条件</h2><h3 id="having-子句"><a href="#having-子句" class="headerlink" title="having 子句"></a>having 子句</h3><p><code>where</code> 只能指定记录(行)的条件，而不能用来指定组的条件.</p><p><code>having</code> 子句用于指定集合的条件。</p><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name1<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name2<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name3<span class="hljs-operator">&gt;</span>, ......<br>  <span class="hljs-keyword">from</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">table</span> name<span class="hljs-operator">&gt;</span><br>  <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name1<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name2<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name3<span class="hljs-operator">&gt;</span>, ......<br>  <span class="hljs-keyword">having</span> <span class="hljs-operator">&lt;</span>expr<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>顺序: select -&gt; from -&gt; where -&gt; group by -&gt; having</p><p>如:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">select</span> product_type, count<span class="hljs-comment">(*)</span><br><span class="hljs-comment">  from Product</span><br><span class="hljs-comment">  group by procuct_type</span><br><span class="hljs-comment">  having count(*)</span> = <span class="hljs-number">2</span><span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><h3 id="having-子句的构成要素"><a href="#having-子句的构成要素" class="headerlink" title="having 子句的构成要素"></a>having 子句的构成要素</h3><p>和包含 group by 子句时的 select 子句一样:</p><ul><li>常数</li><li>聚合函数</li><li>group by 子句中指定的列名</li></ul><h3 id="相对于-having-子句，更适合写在-where-子句中的条件"><a href="#相对于-having-子句，更适合写在-where-子句中的条件" class="headerlink" title="相对于 having 子句，更适合写在 where 子句中的条件"></a>相对于 having 子句，更适合写在 where 子句中的条件</h3><p>where 子句 &#x3D; 指定行所对应的条件<br>having 子句 &#x3D; 指定组所对应的条件</p><h3 id="where-子句和-having-子句的执行速度"><a href="#where-子句和-having-子句的执行速度" class="headerlink" title="where 子句和 having 子句的执行速度"></a>where 子句和 having 子句的执行速度</h3><p>通常情况下，将条件写在 where 子句中要比写在 having 子句中的处理速度快。</p><p>通过 WHERE 子句指定条件时，由于排序之前就对数据进行了过滤，因此能够减少排序的数据量。但 HAVING 子句是在排序之后才对数据进行分组的.</p><h2 id="3-4-对查询结果进行排序"><a href="#3-4-对查询结果进行排序" class="headerlink" title="3-4 对查询结果进行排序"></a>3-4 对查询结果进行排序</h2><h3 id="order-by-子句"><a href="#order-by-子句" class="headerlink" title="order by 子句"></a>order by 子句</h3><p>通常，从表中抽取数据，如果没有指定顺序，则为随机。</p><p>在 select 语句末尾添加 order by 子句来指定排列顺序:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">select</span> &lt;column name1&gt;, &lt;column name2&gt;, &lt;column name3&gt;, <span class="hljs-params">...</span><span class="hljs-params">...</span><br>  from &lt;table name&gt;<br>  <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> &lt;排序基准列<span class="hljs-number">1</span>&gt;, &lt;排序基准列<span class="hljs-number">2</span>&gt;, <span class="hljs-params">...</span><span class="hljs-params">...</span>;<br></code></pre></td></tr></table></figure><p>书写顺序: select -&gt; from -&gt; where -&gt; group by -&gt; having -&gt; order by</p><h3 id="指定升序或降序"><a href="#指定升序或降序" class="headerlink" title="指定升序或降序"></a>指定升序或降序</h3><p>降序，在列名之后使用 <code>desc</code>(descendent) 关键词:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> product_id, product_name, sale_price, purchase_price<br>  <span class="hljs-keyword">from</span> Product<br>  <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sale_price <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p>升序，使用 <code>asc</code>(ascendent) 关键词。</p><p>未指定时默认升序排序。</p><h3 id="指定多个排序键"><a href="#指定多个排序键" class="headerlink" title="指定多个排序键"></a>指定多个排序键</h3><p>规则是优先使用左侧的键，如果该列存在相同值的话，再接着参考右侧的键.</p><h3 id="null-的顺序"><a href="#null-的顺序" class="headerlink" title="null 的顺序"></a>null 的顺序</h3><p>使用含有 null 的列作为排序键时，null 会在结果的开头或末尾汇总显示。</p><h3 id="在排序键中使用显示用的别名"><a href="#在排序键中使用显示用的别名" class="headerlink" title="在排序键中使用显示用的别名"></a>在排序键中使用显示用的别名</h3><p>order by 子句中允许使用别名。</p><p>如:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select product_id <span class="hljs-keyword">as</span> <span class="hljs-built_in">id</span>, product_name, sale_price <span class="hljs-keyword">as</span> sp, purchase_price<br>  <span class="hljs-keyword">from</span> Product<br>  order <span class="hljs-keyword">by</span> sp, <span class="hljs-built_in">id</span>;<br></code></pre></td></tr></table></figure><p>使用 having 子句时 select 语句的顺序:</p><p>from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt; order by</p><h3 id="order-by-子句中可以使用的列"><a href="#order-by-子句中可以使用的列" class="headerlink" title="order by 子句中可以使用的列"></a>order by 子句中可以使用的列</h3><p>可以使用在 select 子句中未使用的列和聚合函数。</p><h3 id="不要使用列编号"><a href="#不要使用列编号" class="headerlink" title="不要使用列编号"></a>不要使用列编号</h3><p><mark>列编号</mark>是指 select 子句中的列按照从左到右的顺序进行排序时所对应的编号(1, 2, 3,…).</p><h1 id="第4章-数据更新"><a href="#第4章-数据更新" class="headerlink" title="第4章 数据更新"></a>第4章 数据更新</h1><h2 id="4-1-数据的插入-insert语句的使用方法"><a href="#4-1-数据的插入-insert语句的使用方法" class="headerlink" title="4-1 数据的插入(insert语句的使用方法)"></a>4-1 数据的插入(insert语句的使用方法)</h2><h3 id="什么是-insert"><a href="#什么是-insert" class="headerlink" title="什么是 insert"></a>什么是 insert</h3><p><code>create table</code> 语句只负责创建表，但创建出的表中并没有数据。</p><h3 id="insert-语句的基本语法"><a href="#insert-语句的基本语法" class="headerlink" title="insert 语句的基本语法"></a>insert 语句的基本语法</h3><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">table</span> name<span class="hljs-operator">&gt;</span> (column1, column2, ...) <span class="hljs-keyword">values</span> (value1, value2, ...);<br></code></pre></td></tr></table></figure><p>将列名和值用逗号分开，分别括在()内，这种形式称为<mark>清单</mark>.</p><p>表名后面的列清单和 value 子句中的值清单的列数必须保持一致。</p><p>原则上，执行一次 insert 语句会插入一行数据。</p><h3 id="列清单的省略"><a href="#列清单的省略" class="headerlink" title="列清单的省略"></a>列清单的省略</h3><p>对表进行全列 insert 时，可以省略表名后的列清单。</p><h3 id="插入-null"><a href="#插入-null" class="headerlink" title="插入 null"></a>插入 null</h3><p>直接在 values 子句的值清单中写入 null.</p><p>想要插入 null 的列一定不能设置 not null 约束.</p><h3 id="插入默认值"><a href="#插入默认值" class="headerlink" title="插入默认值"></a>插入默认值</h3><p>在 create table 语句中设置 <code>default</code> 约束。</p><p>默认值的使用方法通常有显式和隐式两种.</p><ul><li>显式，在 <code>values</code> 子句中指定 <code>default</code> 关键字。 <code>values (&#39;0007&#39;, default, ...)</code></li><li>隐式，省略设定了默认值的列，列和值都要忽略<br>一般使用显式。</li></ul><h3 id="从其他表复制数据"><a href="#从其他表复制数据" class="headerlink" title="从其他表复制数据"></a>从其他表复制数据</h3><p>执行 <code>insert ... select</code> 语句。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">insert <span class="hljs-keyword">into</span> <span class="hljs-title">Productcopy</span> (<span class="hljs-params">product_id, product_name, product_type, sale_price</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">select</span> product_id, product_name, product_type, sale_price</span><br><span class="hljs-function"><span class="hljs-keyword">from</span> Product</span>;<br></code></pre></td></tr></table></figure><p>insert 语句的 select 语句中，可以使用 where 子句或者 group by 子句等人和语法(使用 order by 子句并不会产生任何效果).</p><h2 id="4-2-数据的删除-delete语句的使用方法"><a href="#4-2-数据的删除-delete语句的使用方法" class="headerlink" title="4-2 数据的删除(delete语句的使用方法)"></a>4-2 数据的删除(delete语句的使用方法)</h2><h3 id="drop-table-语句和-delete-语句"><a href="#drop-table-语句和-delete-语句" class="headerlink" title="drop table 语句和 delete 语句"></a>drop table 语句和 delete 语句</h3><ul><li>drop table 语句可以将表完全删除</li><li>delete 语句会留下表(容器), 而删除表中的全部数据</li></ul><h3 id="delete-语句的基本语法"><a href="#delete-语句的基本语法" class="headerlink" title="delete 语句的基本语法"></a>delete 语句的基本语法</h3><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> &lt;<span class="hljs-keyword">table</span> <span class="hljs-type">name</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="指定删除对象的-delete-语句-搜索型delete"><a href="#指定删除对象的-delete-语句-搜索型delete" class="headerlink" title="指定删除对象的 delete 语句(搜索型delete)"></a>指定删除对象的 delete 语句(搜索型delete)</h3><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> &lt;<span class="hljs-keyword">table</span> <span class="hljs-type">name</span>&gt;<br>  <span class="hljs-keyword">where</span> &lt;expr&gt;;<br></code></pre></td></tr></table></figure><p>delete 语句中不能使用 <code>group by</code>、<code>having</code>和 <code>order by</code>.</p><h2 id="4-3-数据的更新-update语句的使用方法"><a href="#4-3-数据的更新-update语句的使用方法" class="headerlink" title="4-3 数据的更新(update语句的使用方法)"></a>4-3 数据的更新(update语句的使用方法)</h2><h3 id="update-语句的基本语法"><a href="#update-语句的基本语法" class="headerlink" title="update 语句的基本语法"></a>update 语句的基本语法</h3><p>用于更改数据.</p><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> &lt;<span class="hljs-keyword">table</span> <span class="hljs-type">name</span>&gt;<br>  <span class="hljs-keyword">set</span> &lt;<span class="hljs-keyword">column</span> <span class="hljs-type">name</span>&gt; = &lt;expr&gt;;<br></code></pre></td></tr></table></figure><p>将更新对象的列和更新后的值都记述在<code>set</code>子句中。</p><p>设置一整列.</p><h3 id="指定条件的-uupdate-语句-搜索型update"><a href="#指定条件的-uupdate-语句-搜索型update" class="headerlink" title="指定条件的 uupdate 语句(搜索型update)"></a>指定条件的 uupdate 语句(搜索型update)</h3><p>使用 <code>where</code> 子句:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> &lt;<span class="hljs-keyword">table</span> <span class="hljs-type">name</span>&gt;<br>  <span class="hljs-keyword">set</span> &lt;<span class="hljs-keyword">column</span> <span class="hljs-type">name</span>&gt; = &lt;expr&gt;<br>  <span class="hljs-keyword">where</span> &lt;expr&gt;;<br></code></pre></td></tr></table></figure><h3 id="使用-null-进行更新"><a href="#使用-null-进行更新" class="headerlink" title="使用 null 进行更新"></a>使用 null 进行更新</h3><p>将赋值表达式右边的值直接写为 null。</p><p>使用 update 语句可以将值清空为 null(但只限于未设置 not null 约束的列).</p><h3 id="多列更新"><a href="#多列更新" class="headerlink" title="多列更新"></a>多列更新</h3><p>两种写法:</p><p>第一种:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> &lt;<span class="hljs-keyword">table</span> <span class="hljs-type">name</span>&gt;<br>  <span class="hljs-keyword">set</span> &lt;<span class="hljs-keyword">column</span> <span class="hljs-type">name</span>&gt; = &lt;<span class="hljs-keyword">value</span>&gt;<br>  <span class="hljs-keyword">set</span> &lt;<span class="hljs-keyword">column</span> <span class="hljs-type">name</span>&gt; = &lt;<span class="hljs-keyword">value</span>&gt;<br>              .<br>              .<br>              .<br>  <span class="hljs-keyword">where</span> &lt;expr&gt;<br></code></pre></td></tr></table></figure><p>第二种:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">update <span class="hljs-variable">&lt;table name&gt;</span><br>  <span class="hljs-built_in">set</span> (<span class="hljs-variable">&lt;column name&gt;</span>, <span class="hljs-variable">&lt;column name&gt;</span>, ...) = (<span class="hljs-variable">&lt;value&gt;</span>, <span class="hljs-variable">&lt;value&gt;</span>, ...)<br>  where <span class="hljs-variable">&lt;expr&gt;</span><br></code></pre></td></tr></table></figure><p>通常使用第一种方法。</p><h2 id="4-4-事务"><a href="#4-4-事务" class="headerlink" title="4-4 事务"></a>4-4 事务</h2><h3 id="什么是事务-transaction"><a href="#什么是事务-transaction" class="headerlink" title="什么是事务(transaction)"></a>什么是事务(transaction)</h3><p>事务是需要在同一个处理单元中执行的一系列更新处理的集合。</p><p>一个处理单元就是表之类的，一系列更新处理就是修改操作。</p><h3 id="创建事务"><a href="#创建事务" class="headerlink" title="创建事务"></a>创建事务</h3><p>语法:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">事务开始语句 <span class="hljs-comment">;</span><br>  DML 语句① <span class="hljs-comment">;</span><br>  DML 语句② <span class="hljs-comment">;</span><br>  DML 语句③ <span class="hljs-comment">;</span><br>      .<br>      .<br>      .<br>事务结束语句（COMMIT 或者 ROLLBACK）<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>各个 DBMD 都定义有事务的开始语句:</p><ul><li>PostgreSQL: <code>begin transaction</code></li></ul><p>事务结束语句只有两种且通用:</p><ul><li>commit</li><li>rollback<br>事务开始有默认开始的时间点.</li></ul><h4 id="commit-提交处理"><a href="#commit-提交处理" class="headerlink" title="commit 提交处理"></a>commit 提交处理</h4><p>相当于文件处理中的覆盖处理。</p><h4 id="rollback-取消处理"><a href="#rollback-取消处理" class="headerlink" title="rollback 取消处理"></a>rollback 取消处理</h4><p>相当于文件处理中的放弃保存。</p><h4 id="事务处理何时开始"><a href="#事务处理何时开始" class="headerlink" title="事务处理何时开始"></a>事务处理何时开始</h4><p>实际上，几乎所有的数据库产品的事务都无需开始指令.</p><p>区分事务:</p><ul><li>每条SQL语句就是一个事务(自动提交模式)</li><li>直到用户执行commit或者rollback为止算作一个事务</li></ul><p>默认使用自动提交模式的 DBMS 有 SQL Server、PostgreSQL和MySQL等.</p><h3 id="ACID-特性"><a href="#ACID-特性" class="headerlink" title="ACID 特性"></a>ACID 特性</h3><p>DBMS 的事务都遵循四种特性，将这四种特性的首字母结合起来统称为 ACID 特性。</p><h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性 Atomicity"></a>原子性 Atomicity</h4><p>指事务结束时，其中包含的更新要么全部执行，要么完全不执行。</p><h4 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性 Consistency"></a>一致性 Consistency</h4><p>指事务中包含的处理，要满足数据库提前设置的约束, 如主键约束或者 not null 约束等。</p><h4 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性 Isolation"></a>隔离性 Isolation</h4><p>指的是保证不同事务之间互不干扰的特性。</p><h4 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性 Durability"></a>持久性 Durability</h4><p>指在事务结束后，DBMS 能够保证该时间点的数据状态会被保存的特性。</p><p>常见为将执行记录(日志)保存在存储介质.</p><h1 id="第5章-复杂查询"><a href="#第5章-复杂查询" class="headerlink" title="第5章 复杂查询"></a>第5章 复杂查询</h1><h2 id="5-1-视图"><a href="#5-1-视图" class="headerlink" title="5-1 视图"></a>5-1 视图</h2><h3 id="视图和表"><a href="#视图和表" class="headerlink" title="视图和表"></a>视图和表</h3><p>视图和表的区别: 是否保存了实际数据。</p><p>使用视图时并不会将数据保存到存储设备中, 而且也不会将数据保存到其他任何地方.</p><p> 视图保存的是从表中取出数据所使用的 select 语句.</p><h4 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h4><ul><li>无需保存数据</li><li>将频繁使用的 select 语句保存成视图，就不用重新书写</li></ul><h3 id="创建视图的方法"><a href="#创建视图的方法" class="headerlink" title="创建视图的方法"></a>创建视图的方法</h3><p>使用 <code>create view</code> 语句:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> 视图名称(&lt;视图列名<span class="hljs-number">1</span>&gt;, &lt;视图列名<span class="hljs-number">2</span>&gt;, ......) <br><span class="hljs-keyword">as</span><br>&lt;<span class="hljs-keyword">select</span>语句&gt;<br></code></pre></td></tr></table></figure><p>select 语句中列的排列顺序和视图中列的排列顺序相同.</p><p>视图可以写在 select 语句的 from 中.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name1<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">column</span> name2<span class="hljs-operator">&gt;</span>, ...<br>  <span class="hljs-keyword">from</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">view</span> name<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h4 id="使用视图的查询"><a href="#使用视图的查询" class="headerlink" title="使用视图的查询"></a>使用视图的查询</h4><p>通常为两个步骤:</p><ol><li>执行定义视图的 select 语句</li><li>根据得到的结果，执行在 from 子句中使用的视图的 select 语句</li></ol><p>也就是说使用视图就是把视图放在 from 之后。</p><p>多重视图会降低 SQL 的性能.</p><h3 id="视图的限制1-–-定义视图时不能使用-order-by-子句"><a href="#视图的限制1-–-定义视图时不能使用-order-by-子句" class="headerlink" title="视图的限制1 – 定义视图时不能使用 order by 子句"></a>视图的限制1 – 定义视图时不能使用 order by 子句</h3><h3 id="视图的限制2-–-对视图进行更新"><a href="#视图的限制2-–-对视图进行更新" class="headerlink" title="视图的限制2 – 对视图进行更新"></a>视图的限制2 – 对视图进行更新</h3><p>定义视图的 select 语句满足某些条件，视图就可以被更新(即对视图使用 insert、delete、update等), 几个具有代表性的条件:</p><ol><li>select 子句中未使用 distinct</li><li>from 子句中只有一张表</li><li>未使用 group by 子句</li><li>未使用 having 子句<br>视图和表需要同时进行更新，因此通过汇总得到的视图无法进行更新.</li></ol><p>PostgreSQL 中的视图会被初始设定为只读, 若要允许更新:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">replace</span> rule insert_rule<br><span class="hljs-keyword">as</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">insert</span><br><span class="hljs-keyword">to</span> &lt;<span class="hljs-keyword">view</span> name&gt; <span class="hljs-keyword">do</span> instead<br><span class="hljs-keyword">insert</span>  <span class="hljs-keyword">into</span> ...<br></code></pre></td></tr></table></figure><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>使用 drop view 语句:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">drop</span> <span class="hljs-built_in">view</span> &lt;<span class="hljs-built_in">view</span> name&gt;(&lt;视图列名<span class="hljs-number">1</span>&gt;, ...)<br></code></pre></td></tr></table></figure><p>删除多重视图，即存在关联的视图:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> &lt;<span class="hljs-keyword">view</span> <span class="hljs-type">name</span>&gt; <span class="hljs-keyword">cascade</span>;<br></code></pre></td></tr></table></figure><p><code>cascade</code> 是重叠的意思。</p><h2 id="5-2-子查询"><a href="#5-2-子查询" class="headerlink" title="5-2 子查询"></a>5-2 子查询</h2><p>子查询就是一次性视图。</p><p>子查询将用来定义视图的 select 语句直接用于 from 子句中.</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> product_type, cnt_product<br>  <span class="hljs-keyword">from</span> (<br>    <span class="hljs-keyword">select</span> product_type, <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> cnt_product<br>        <span class="hljs-keyword">from</span> Product<br>        <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> product_type<br>      ) <span class="hljs-keyword">as</span> ProductSum;<br></code></pre></td></tr></table></figure><p>这里的 <code>Productsum</code> 也是一次性名称.</p><p>select 语句的执行顺序，先执行 from 子句中的 select 语句，然后才执行外层的 select 语句。</p><h4 id="增加子查询的层数"><a href="#增加子查询的层数" class="headerlink" title="增加子查询的层数"></a>增加子查询的层数</h4><p>子查询的层数原则上没有限制.</p><p>尽量避免嵌套，其会使可读性和性能变差。</p><h3 id="子查询的名称"><a href="#子查询的名称" class="headerlink" title="子查询的名称"></a>子查询的名称</h3><p>原则上子查询必须设定名称, 需使用 as 关键词.</p><h3 id="标量子查询-scalar-subquery"><a href="#标量子查询-scalar-subquery" class="headerlink" title="标量子查询 scalar subquery"></a>标量子查询 scalar subquery</h3><h4 id="什么是标量"><a href="#什么是标量" class="headerlink" title="什么是标量"></a>什么是标量</h4><p>标量就是单一的意思.</p><p>标量子查询的特殊限制为: 必须而且只能返回1行1列的结果。</p><p>也就是返回表中某一行的某一列的值。</p><p>标量子查询的返回值可以用在 &#x3D; 或者 &lt;&gt; 这样需要单一值的比较运算符中.</p><h4 id="在-where-子句中使用标量子查询"><a href="#在-where-子句中使用标量子查询" class="headerlink" title="在 where 子句中使用标量子查询"></a>在 where 子句中使用标量子查询</h4><p>解决在 where 子句中不能使用聚合函数的问题.</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> product_id, product_name, sale_price<br>  <span class="hljs-keyword">from</span> Product<br>  <span class="hljs-keyword">where</span> sale_price &gt; (<span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(sale_price)<br>                        <span class="hljs-keyword">from</span> Product);<br></code></pre></td></tr></table></figure><p>执行顺序，首先执行内层的子查询，然后执行外层的查询。</p><h3 id="标量子查询的书写位置"><a href="#标量子查询的书写位置" class="headerlink" title="标量子查询的书写位置"></a>标量子查询的书写位置</h3><p>通常任何可以使用单一值的位置都可以使用。几乎所有的地方都可以使用.</p><h3 id="使用标量子查询时的注意事项"><a href="#使用标量子查询时的注意事项" class="headerlink" title="使用标量子查询时的注意事项"></a>使用标量子查询时的注意事项</h3><p>即该子查询不能返回多行结果。</p><h2 id="5-3-关联子查询"><a href="#5-3-关联子查询" class="headerlink" title="5-3 关联子查询"></a>5-3 关联子查询</h2><h3 id="普通子查询和关联子查询的区别"><a href="#普通子查询和关联子查询的区别" class="headerlink" title="普通子查询和关联子查询的区别"></a>普通子查询和关联子查询的区别</h3><h4 id="使用关联子查询的解决方案"><a href="#使用关联子查询的解决方案" class="headerlink" title="使用关联子查询的解决方案"></a>使用关联子查询的解决方案</h4><p>在子查询中添加的 where 子句的条件.</p><h3 id="关联子查询也是用来对集合进行切分的"><a href="#关联子查询也是用来对集合进行切分的" class="headerlink" title="关联子查询也是用来对集合进行切分的"></a>关联子查询也是用来对集合进行切分的</h3><h3 id="结合条件一定要写在子查询中"><a href="#结合条件一定要写在子查询中" class="headerlink" title="结合条件一定要写在子查询中"></a>结合条件一定要写在子查询中</h3><p>关联子查询就是有一个关联条件。</p><p>关联名称存在作用域.</p><h1 id="第6章-函数、谓词、CASE表达式"><a href="#第6章-函数、谓词、CASE表达式" class="headerlink" title="第6章 函数、谓词、CASE表达式"></a>第6章 函数、谓词、CASE表达式</h1><h2 id="6-1-各种各样的函数"><a href="#6-1-各种各样的函数" class="headerlink" title="6-1 各种各样的函数"></a>6-1 各种各样的函数</h2><h3 id="函数的种类"><a href="#函数的种类" class="headerlink" title="函数的种类"></a>函数的种类</h3><p>大致可以分为:</p><ul><li>算数函数</li><li>字符串函数</li><li>日期函数</li><li>转换函数</li><li>聚合函数</li></ul><h3 id="算数函数"><a href="#算数函数" class="headerlink" title="算数函数"></a>算数函数</h3><ul><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li>&#x2F;<br><code>numeric</code>数据类型, 格式为(全体位数，小数位数).</li></ul><h4 id="ABS-–-绝对值"><a href="#ABS-–-绝对值" class="headerlink" title="ABS – 绝对值"></a>ABS – 绝对值</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ABS</span><span class="hljs-params">(数值)</span></span><br></code></pre></td></tr></table></figure><p><code>abs</code> 是计算绝对值(absolute value)的函数.</p><p><code>abs</code> 计算出某一列的绝对值。</p><p>绝大多数函数对于 null 都返回null.</p><h4 id="MOD-–-求余"><a href="#MOD-–-求余" class="headerlink" title="MOD – 求余"></a>MOD – 求余</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">MOD</span><span class="hljs-params">(被除数，除数)</span></span><br></code></pre></td></tr></table></figure><p>只能对整数类型的列使用 <code>MOD</code> 函数。</p><h4 id="ROUND-–-四舍五入"><a href="#ROUND-–-四舍五入" class="headerlink" title="ROUND – 四舍五入"></a>ROUND – 四舍五入</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ROUND</span></span>(对象数值，保留小数的位数)</span><br></code></pre></td></tr></table></figure><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><h4 id="–-拼接"><a href="#–-拼接" class="headerlink" title="|| – 拼接"></a>|| – 拼接</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">字符串<span class="hljs-number">1</span> <span class="hljs-string">|| 字符串2</span><br></code></pre></td></tr></table></figure><h4 id="LENGTH-–-字符串长度"><a href="#LENGTH-–-字符串长度" class="headerlink" title="LENGTH – 字符串长度"></a>LENGTH – 字符串长度</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">LENGTH</span></span>(字符串)</span><br></code></pre></td></tr></table></figure><p><code>LENGTH</code> 是以字节为单位.</p><h4 id="LOWER-–-小写转换"><a href="#LOWER-–-小写转换" class="headerlink" title="LOWER – 小写转换"></a>LOWER – 小写转换</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">LOWER</span><span class="hljs-params">(字符串)</span></span><br></code></pre></td></tr></table></figure><h4 id="UPPER-–-大写转换"><a href="#UPPER-–-大写转换" class="headerlink" title="UPPER – 大写转换"></a>UPPER – 大写转换</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">UPPER</span><span class="hljs-params">(字符串)</span></span><br></code></pre></td></tr></table></figure><h4 id="REPLACE-–-字符串替换"><a href="#REPLACE-–-字符串替换" class="headerlink" title="REPLACE – 字符串替换"></a>REPLACE – 字符串替换</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">REPLACE</span></span>(对象字符串，替换前字符串，替换后字符串)</span><br></code></pre></td></tr></table></figure><h4 id="SUBSTRING-–-字符串截取"><a href="#SUBSTRING-–-字符串截取" class="headerlink" title="SUBSTRING – 字符串截取"></a>SUBSTRING – 字符串截取</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">SUBSTRING</span></span>(对象字符串 <span class="hljs-variable">from</span> 截取的起始位置 <span class="hljs-variable">for</span> 截取的字符数)</span><br></code></pre></td></tr></table></figure><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><h4 id="CURRENT-DATE-–-当前日期"><a href="#CURRENT-DATE-–-当前日期" class="headerlink" title="CURRENT_DATE – 当前日期"></a>CURRENT_DATE – 当前日期</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">current_date</span><br></code></pre></td></tr></table></figure><h4 id="CURRENT-TIME-–-当前时间"><a href="#CURRENT-TIME-–-当前时间" class="headerlink" title="CURRENT_TIME – 当前时间"></a>CURRENT_TIME – 当前时间</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">current_time</span><br></code></pre></td></tr></table></figure><h4 id="CURRENT-TIMESTAMP-–-当前日期和时间"><a href="#CURRENT-TIMESTAMP-–-当前日期和时间" class="headerlink" title="CURRENT_TIMESTAMP – 当前日期和时间"></a>CURRENT_TIMESTAMP – 当前日期和时间</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">current_timestamp</span><br></code></pre></td></tr></table></figure><h4 id="EXTRACT-–-截取日期元素"><a href="#EXTRACT-–-截取日期元素" class="headerlink" title="EXTRACT – 截取日期元素"></a>EXTRACT – 截取日期元素</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">EXTRACT</span><span class="hljs-params">(日期元素 from 日期)</span></span><br></code></pre></td></tr></table></figure><p>year, month, day, hour, minute, second.</p><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p>转换在 SQL 中主要有两层意思:</p><ol><li>数据类型的转换，即 cast</li><li>值的转换<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cast</span><span class="hljs-params">(转换前的值 as 想要转换的数据类型)</span></span><br></code></pre></td></tr></table></figure></li></ol><h4 id="COALESCE-–-将-null-转换为其他值"><a href="#COALESCE-–-将-null-转换为其他值" class="headerlink" title="COALESCE – 将 null 转换为其他值"></a>COALESCE – 将 null 转换为其他值</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">coalesce</span><span class="hljs-params">(数据<span class="hljs-number">1</span>，数据<span class="hljs-number">2</span>，...)</span></span><br></code></pre></td></tr></table></figure><p>返回可变参数中左侧开始第一个不是 null 的值。</p><p>感觉不是转换。</p><h2 id="6-2-谓词"><a href="#6-2-谓词" class="headerlink" title="6-2 谓词"></a>6-2 谓词</h2><h3 id="什么是谓词-predicate"><a href="#什么是谓词-predicate" class="headerlink" title="什么是谓词(predicate)"></a>什么是谓词(predicate)</h3><p>谓词是函数的一种，是需要满足特定条件的函数，该条件就是返回值是真值(true)。</p><p>&#x3D;, &lt;, &gt;, &lt;&gt; 等比较运算符，其正式名称就是比较谓词.</p><h3 id="LIKE-谓词-–-字符串的部分一致查询"><a href="#LIKE-谓词-–-字符串的部分一致查询" class="headerlink" title="LIKE 谓词 – 字符串的部分一致查询"></a>LIKE 谓词 – 字符串的部分一致查询</h3><p>部分一致大体可以分为:</p><ul><li>前方一致</li><li>中间一致</li><li>后方一致<br>部分一致，即字符串中的一部分相同。</li></ul><h4 id="前方一致查询"><a href="#前方一致查询" class="headerlink" title="前方一致查询"></a>前方一致查询</h4><p>用来查询的字符串，与查询对象的起始部分相同。</p><h4 id="中间一致"><a href="#中间一致" class="headerlink" title="中间一致"></a>中间一致</h4><p>用来查询的字符串，与查询对象的部分相同。</p><h4 id="后方一致"><a href="#后方一致" class="headerlink" title="后方一致"></a>后方一致</h4><p>用来查询的字符串，与查询对象的末尾部分相同。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <br>  <span class="hljs-keyword">from</span> SampleLike<br>  <span class="hljs-keyword">where</span> strcol <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;ddd%&#x27;</span><br></code></pre></td></tr></table></figure><p><code>%</code> 代表”0字符以上的任意字符串”.</p><p><code>_</code> 代表”任意一个字符”.</p><h3 id="BETWEEN-谓词-–-范围查询"><a href="#BETWEEN-谓词-–-范围查询" class="headerlink" title="BETWEEN 谓词 – 范围查询"></a>BETWEEN 谓词 – 范围查询</h3><p>使用3个参数:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> product_name, sale_price<br>  <span class="hljs-keyword">from</span> Product<br> <span class="hljs-keyword">where</span> sale_price <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><h3 id="IS-NULL、IS-NOT-NULL-–-判断是否为-NULL"><a href="#IS-NULL、IS-NOT-NULL-–-判断是否为-NULL" class="headerlink" title="IS NULL、IS NOT NULL – 判断是否为 NULL"></a>IS NULL、IS NOT NULL – 判断是否为 NULL</h3><h3 id="IN-谓词-–-OR-的简便用法"><a href="#IN-谓词-–-OR-的简便用法" class="headerlink" title="IN 谓词 – OR 的简便用法"></a>IN 谓词 – OR 的简便用法</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">select</span> product_name, purchase_price<br>  <span class="hljs-keyword">from</span> Product<br> <span class="hljs-keyword">where</span> purchase_price I<span class="hljs-meta">N</span>(320, 500, 5000)<br></code></pre></td></tr></table></figure><p>其否定形式为 <code>NOT IN</code>.</p><p>IN 和 NOT IN 无法取出 NULL 数据。</p><h3 id="使用子查询作为-IN-谓词的参数"><a href="#使用子查询作为-IN-谓词的参数" class="headerlink" title="使用子查询作为 IN 谓词的参数"></a>使用子查询作为 IN 谓词的参数</h3><h4 id="IN-和子查询"><a href="#IN-和子查询" class="headerlink" title="IN 和子查询"></a>IN 和子查询</h4><p>IN(NOT IN)谓词，可以使用子查询作为其参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">select</span> product_name, <span class="hljs-function">sale_price</span><br><span class="hljs-function">  <span class="hljs-keyword">from</span> Product</span><br><span class="hljs-function"> <span class="hljs-keyword">where</span> product_id <span class="hljs-title">IN</span> (<span class="hljs-params"><span class="hljs-keyword">select</span> product_id </span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">from</span> ShopProduct</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">where</span> shop_id = <span class="hljs-string">&#x27;000C&#x27;</span></span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="NOT-IN-和子查询"><a href="#NOT-IN-和子查询" class="headerlink" title="NOT IN 和子查询"></a>NOT IN 和子查询</h4><p>语法和 IN 一致。</p><h3 id="EXIST-谓词"><a href="#EXIST-谓词" class="headerlink" title="EXIST 谓词"></a>EXIST 谓词</h3><h4 id="EXISTS谓词的使用方法"><a href="#EXISTS谓词的使用方法" class="headerlink" title="EXISTS谓词的使用方法"></a>EXISTS谓词的使用方法</h4><p>谓词的作用就是 “判断是否存在满足某种条件的记录”</p><h5 id="EXIST-的参数"><a href="#EXIST-的参数" class="headerlink" title="EXIST 的参数"></a>EXIST 的参数</h5><p>EXIST 左侧并没有参数.</p><p>EXIST 是只有1个参数的谓词，右侧参数通常为一个子查询。</p><h5 id="子查询中的-select"><a href="#子查询中的-select" class="headerlink" title="子查询中的 select *"></a>子查询中的 select *</h5><p>EXIST 只关心记录是否存在。</p><p>在 EXIST 的子查询中，常常书写 <code>select *</code>.</p><h5 id="NOT-EXIST"><a href="#NOT-EXIST" class="headerlink" title="NOT EXIST"></a>NOT EXIST</h5><p>与 EXIST 相反，当”不存在”满足子查询中指定条件的记录时返回真。</p><h2 id="6-3-CASE-表达式"><a href="#6-3-CASE-表达式" class="headerlink" title="6-3 CASE 表达式"></a>6-3 CASE 表达式</h2><h3 id="什么是-CASE-表达式"><a href="#什么是-CASE-表达式" class="headerlink" title="什么是 CASE 表达式"></a>什么是 CASE 表达式</h3><p>case 作为条件分支。</p><h3 id="CASE-表达式的语法"><a href="#CASE-表达式的语法" class="headerlink" title="CASE 表达式的语法"></a>CASE 表达式的语法</h3><p>CASE 表达式的语法分为:</p><ul><li>简单 case 表达式</li><li>搜索 case 表达式<br>搜索表达式包含了简单 case 表达式的全部功能。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">case when <span class="hljs-tag">&lt;<span class="hljs-name">求值表达式</span>&gt;</span> then <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>     when <span class="hljs-tag">&lt;<span class="hljs-name">求值表达式</span>&gt;</span> then <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>     when <span class="hljs-tag">&lt;<span class="hljs-name">求值表达式</span>&gt;</span> then <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>                .<br>                . <br>                . <br>     else <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>end<br></code></pre></td></tr></table></figure><code>when</code> 子句中的”&lt;求值表达式&gt;”就是类似”列 &#x3D; 值”</li></ul><p>直到返回为真为止.</p><h3 id="CASE-表达式的使用方法"><a href="#CASE-表达式的使用方法" class="headerlink" title="CASE 表达式的使用方法"></a>CASE 表达式的使用方法</h3><p><code>else</code>子句省略不写时会默认为<code>else null</code>.</p><h4 id="CASE-表达式的书写位置"><a href="#CASE-表达式的书写位置" class="headerlink" title="CASE 表达式的书写位置"></a>CASE 表达式的书写位置</h4><p><code>CASE</code> 是一个表达式，可以写在任意位置。</p><h3 id="简单-CASE-表达式"><a href="#简单-CASE-表达式" class="headerlink" title="简单 CASE 表达式"></a>简单 CASE 表达式</h3><p>会受条件的约束.</p><p>语法:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">case <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>     when <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span> then <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>     when <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span> then <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>     when <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span> then <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>                .<br>                . <br>                . <br>     else <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br>end<br></code></pre></td></tr></table></figure><p>和搜索 case 表达式的不同之处在于，求值表达式变成了 case 后的表达式和 when 后面的表达式.</p><h3 id="特定的-case-表达式"><a href="#特定的-case-表达式" class="headerlink" title="特定的 case 表达式"></a>特定的 case 表达式</h3><h1 id="第7章-集合运算"><a href="#第7章-集合运算" class="headerlink" title="第7章 集合运算"></a>第7章 集合运算</h1><h2 id="7-1-表的加减法"><a href="#7-1-表的加减法" class="headerlink" title="7-1 表的加减法"></a>7-1 表的加减法</h2><h3 id="什么是集合运算"><a href="#什么是集合运算" class="headerlink" title="什么是集合运算"></a>什么是集合运算</h3><p>集合在数据库中表示 <mark>记录的集合</mark>.</p><p>集合运算就是对满足同一规则的记录进行的加减等四则运算。</p><p>通过集合运算，可以得到两张表中记录的集合或者公共记录的集合。</p><p>用于集合运算的运算符称为 <mark>集合运算符</mark>.</p><h3 id="表的加法-–-UNION"><a href="#表的加法-–-UNION" class="headerlink" title="表的加法 – UNION"></a>表的加法 – UNION</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product<br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product2<br></code></pre></td></tr></table></figure><p>结果会包含两张表的全部内容。也就是并集.</p><p>集合运算符也会除去重复的记录。</p><h3 id="集合运算的注意事项"><a href="#集合运算的注意事项" class="headerlink" title="集合运算的注意事项"></a>集合运算的注意事项</h3><h4 id="1-作为运算对象的记录的列数必须相同"><a href="#1-作为运算对象的记录的列数必须相同" class="headerlink" title="1 作为运算对象的记录的列数必须相同"></a>1 作为运算对象的记录的列数必须相同</h4><p>也就是 select 后的列数。</p><h4 id="2-作为运算对象的记录中列的类型必须一致"><a href="#2-作为运算对象的记录中列的类型必须一致" class="headerlink" title="2 作为运算对象的记录中列的类型必须一致"></a>2 作为运算对象的记录中列的类型必须一致</h4><p>相同位置上的列必须是同一数据类型。</p><h4 id="3-可以使用任何-select-语句，但-order-by-子句只能在最后使用一次。"><a href="#3-可以使用任何-select-语句，但-order-by-子句只能在最后使用一次。" class="headerlink" title="3 可以使用任何 select 语句，但 order by 子句只能在最后使用一次。"></a>3 可以使用任何 select 语句，但 order by 子句只能在最后使用一次。</h4><h3 id="包含重复行的集合运算-–-ALL-选项"><a href="#包含重复行的集合运算-–-ALL-选项" class="headerlink" title="包含重复行的集合运算 – ALL 选项"></a>包含重复行的集合运算 – ALL 选项</h3><p>在 UNION 后 加 ALL 就会保留重复行.</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product2;<br></code></pre></td></tr></table></figure><h3 id="选取表中公共部分-–-INTERSECT"><a href="#选取表中公共部分-–-INTERSECT" class="headerlink" title="选取表中公共部分 – INTERSECT"></a>选取表中公共部分 – INTERSECT</h3><p>选取两个记录集合中公共部分的交集(INTERSECT).</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product<br><span class="hljs-keyword">INTERSECT</span><br><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product2<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> product_id;<br></code></pre></td></tr></table></figure><p>保留重复项同样可以使用 <code>INTERSECT ALL</code>.</p><h3 id="记录的减法-–-EXCEPT"><a href="#记录的减法-–-EXCEPT" class="headerlink" title="记录的减法 – EXCEPT"></a>记录的减法 – EXCEPT</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product<br><span class="hljs-keyword">EXCEPT</span><br><span class="hljs-keyword">select</span> product_id, product_name<br>  <span class="hljs-keyword">from</span> Product2<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> product_id;<br></code></pre></td></tr></table></figure><p>结果只包含Product表中记录除去Product2表中记录之后的剩余部分。</p><h2 id="7-2-联结-以列为单位对表进行联结"><a href="#7-2-联结-以列为单位对表进行联结" class="headerlink" title="7-2 联结(以列为单位对表进行联结)"></a>7-2 联结(以列为单位对表进行联结)</h2><h3 id="什么是联结"><a href="#什么是联结" class="headerlink" title="什么是联结"></a>什么是联结</h3><p>UNION 和 INTERSECT 等会导致记录行数的增减。</p><p>联结(join)运算就是将其他表中的列添加过来。</p><h3 id="内联结-–-INNER-JOIN"><a href="#内联结-–-INNER-JOIN" class="headerlink" title="内联结 – INNER JOIN"></a>内联结 – INNER JOIN</h3><h4 id="内联结要点1-–-from-子句"><a href="#内联结要点1-–-from-子句" class="headerlink" title="内联结要点1 – from 子句"></a>内联结要点1 – from 子句</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> ShopProduct <span class="hljs-keyword">AS</span> SP <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Product <span class="hljs-keyword">AS</span> P<br></code></pre></td></tr></table></figure><h4 id="内联结要点2-–-on-子句"><a href="#内联结要点2-–-on-子句" class="headerlink" title="内联结要点2 – on 子句"></a>内联结要点2 – on 子句</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ON <span class="hljs-keyword">SP</span>.product_id <span class="hljs-operator">=</span> P.product_id<br></code></pre></td></tr></table></figure><p>起到 where 的作用.</p><p>ON 子句需书写到 from 和 where 之间。</p><h4 id="内联结要点3-–-select-子句"><a href="#内联结要点3-–-select-子句" class="headerlink" title="内联结要点3 – select 子句"></a>内联结要点3 – select 子句</h4><p>由于多表联结时容易发生混乱, 因此采用 “&lt;表的别名&gt;.&lt;列名&gt;” 的形式来指定列。</p><p>其实只有同时存在于两张表中的列必须使用这种形式。</p><h4 id="内联结和-where-子句结合使用"><a href="#内联结和-where-子句结合使用" class="headerlink" title="内联结和 where 子句结合使用"></a>内联结和 where 子句结合使用</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">select <span class="hljs-built_in">SP</span>.<span class="hljs-keyword">shop_id, </span><span class="hljs-built_in">SP</span>.<span class="hljs-keyword">shop_name, </span><span class="hljs-built_in">SP</span>.product_id, P.product_name, P.sale_price<br>  from <span class="hljs-keyword">ShopProduct </span>AS <span class="hljs-built_in">SP</span> INNER <span class="hljs-keyword">JOIN </span>Product AS P<br>    ON <span class="hljs-built_in">SP</span>.product_id = P.product_id<br>  where <span class="hljs-built_in">SP</span>.<span class="hljs-keyword">shop_id </span>= <span class="hljs-string">&#x27;000A&#x27;</span>;<br></code></pre></td></tr></table></figure><p>使用联结运算将满足相同规则的表联结起来，WHERE、GROUP BY、HAVING、ORDER BY等工具都可以正常使用。</p><p>这张表只在 select 语句执行期间存在，select 语句执行之后就会消失。如果希望继续使用这张表，需将其创建为视图.</p><h3 id="外联结-–-OUTER-JOIN"><a href="#外联结-–-OUTER-JOIN" class="headerlink" title="外联结 – OUTER JOIN"></a>外联结 – OUTER JOIN</h3><p>实现”从两张表中取出”的就是联结功能。</p><p>外联结也是通过 ON 子句的联结键将两张表进行联结，并从两张表中同时选取相应的列。</p><h4 id="外联结要点1-–-选取出单张表中全部的信息"><a href="#外联结要点1-–-选取出单张表中全部的信息" class="headerlink" title="外联结要点1 – 选取出单张表中全部的信息"></a>外联结要点1 – 选取出单张表中全部的信息</h4><p>内联结只能选取同时存在于两张表中的数据。</p><p>对于外联结，只要数据存在于某一张表中，就能够读取出来。</p><p>外联结名称的又来也跟 null 有关，即”结果中包含原表中不存在的信息”.</p><h4 id="外联结要点2-–-每张表都是主表吗"><a href="#外联结要点2-–-每张表都是主表吗" class="headerlink" title="外联结要点2 – 每张表都是主表吗?"></a>外联结要点2 – 每张表都是主表吗?</h4><p>最终的结果中会包含主表的所有数据。</p><p>指定主表的关键词是 <code>left</code> 和 <code>right</code>.</p><h4 id="3张以上的表的联结"><a href="#3张以上的表的联结" class="headerlink" title="3张以上的表的联结"></a>3张以上的表的联结</h4><p>原则上联结表的数量并没有限制。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> ShopProduct <span class="hljs-keyword">as</span> SP <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Product <span class="hljs-keyword">as</span> P<br>  <span class="hljs-keyword">ON</span> SP.product_id = P.product_id<br>      <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> InventoryProduct <span class="hljs-keyword">as</span> IP<br>          <span class="hljs-keyword">ON</span> SP.product_id = IP.product_id<br></code></pre></td></tr></table></figure><h3 id="交叉联结-–-CROSS-JOIN-笛卡尔积"><a href="#交叉联结-–-CROSS-JOIN-笛卡尔积" class="headerlink" title="交叉联结 – CROSS JOIN(笛卡尔积)"></a>交叉联结 – CROSS JOIN(笛卡尔积)</h3><p>交叉联结是所有联结的基础.</p><p>交叉联结时无法使用内联结和外联结中所有的 ON 子句，这是因为交叉联结是对两张表中的全部记录进行交叉组合。</p><p>结果中的记录数通常是两张表中行数的乘积。</p><h3 id="联结的特定语法和过时语法"><a href="#联结的特定语法和过时语法" class="headerlink" title="联结的特定语法和过时语法"></a>联结的特定语法和过时语法</h3><h3 id="关系除法"><a href="#关系除法" class="headerlink" title="关系除法"></a>关系除法</h3><p>集合运算中的除法通常称为<mark>关系除法</mark>.</p><h1 id="第8章-SQL高级处理"><a href="#第8章-SQL高级处理" class="headerlink" title="第8章 SQL高级处理"></a>第8章 SQL高级处理</h1><h2 id="8-1-窗口函数"><a href="#8-1-窗口函数" class="headerlink" title="8-1 窗口函数"></a>8-1 窗口函数</h2><h3 id="什么是窗口函数"><a href="#什么是窗口函数" class="headerlink" title="什么是窗口函数"></a>什么是窗口函数</h3><p>窗口函数也称为OLAP函数(Online Analytical Processing).</p><h3 id="窗口函数的语法"><a href="#窗口函数的语法" class="headerlink" title="窗口函数的语法"></a>窗口函数的语法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;窗口函数&gt; <span class="hljs-keyword">OVER</span> ([<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> &lt;列清单&gt;]<br>                        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> &lt;排序用列清单&gt;)<br></code></pre></td></tr></table></figure><p>其中，<code>[]</code>中的内容可以省略。</p><h4 id="能够作为窗口函数使用的函数"><a href="#能够作为窗口函数使用的函数" class="headerlink" title="能够作为窗口函数使用的函数"></a>能够作为窗口函数使用的函数</h4><p>窗口函数大体分为两种:</p><ul><li>能够作为窗口函数的聚合函数(SUM、AVG、COUNT、MAX、MIN)</li><li>RANK、DENSE_RANK、ROW_NUMBER等专用窗口函数</li></ul><h3 id="语法的基本使用方法-–-使用-RANK-函数"><a href="#语法的基本使用方法-–-使用-RANK-函数" class="headerlink" title="语法的基本使用方法 – 使用 RANK 函数"></a>语法的基本使用方法 – 使用 RANK 函数</h3><p><mark>PARTITION BY</mark> 设定排序的对象范围。用于在横向上对表进行分组。</p><p><mark>ORDER BY</mark> 指定按照哪一列、何种顺序进行排序. 与 select 语句末尾的 order by 一样，可以通过关键词 ASC&#x2F;DESC 来指定升序和降序。决定纵向排序的规则。</p><p>通过 PARTITION BY 分组后的记录的集合可以称为窗口。窗口的意思为范围。</p><p>窗口函数兼具分组和排序两种功能。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> product_name, product_type, sale_price,<br>       RANK() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> product_type<br>                         <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sale_price) <span class="hljs-keyword">AS</span> ranking<br>  <span class="hljs-keyword">FROM</span> Product;<br></code></pre></td></tr></table></figure><h3 id="无需指定-PARTITION-BY"><a href="#无需指定-PARTITION-BY" class="headerlink" title="无需指定 PARTITION BY"></a>无需指定 PARTITION BY</h3><p>不指定时将整个表作为一个大的窗口使用.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> product_name, product_type, sale_price,<br>       RANK() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sale_price) <span class="hljs-keyword">AS</span> ranking <span class="hljs-keyword">FROM</span> Product;<br></code></pre></td></tr></table></figure><p>将表中数据分为多个部分时使用 PARTITION BY.</p><h3 id="专用窗口函数的种类"><a href="#专用窗口函数的种类" class="headerlink" title="专用窗口函数的种类"></a>专用窗口函数的种类</h3><p>代表性的专用窗口函数:</p><ul><li>RANK函数, 计算排序时，如果存在相同位次的记录，则会跳过之后的位次。如: 1位, 1位, 1位, 4位</li><li>DENDE_RANK, 不会跳过位次.如:1位, 1位, 1位, 2位</li><li>ROW_NUMBER函数，赋予唯一的连续位次. 如: 1位, 2位, 3位</li></ul><p>专用窗口函数无需参数，因此通常括号中都是空的。</p><h3 id="窗口函数的适用范围"><a href="#窗口函数的适用范围" class="headerlink" title="窗口函数的适用范围"></a>窗口函数的适用范围</h3><p>原则上窗口函数只能在 select 子句中使用。</p><p>在 select 子句之外”使用窗口函数是没有意义的”.</p><h3 id="作为窗口函数使用的聚合函数"><a href="#作为窗口函数使用的聚合函数" class="headerlink" title="作为窗口函数使用的聚合函数"></a>作为窗口函数使用的聚合函数</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> product_id, product_name, sale_price, <br>      <span class="hljs-built_in">SUM</span> (sale_price) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> product_id) <span class="hljs-keyword">AS</span> current_sum <span class="hljs-keyword">FROM</span> Product;<br></code></pre></td></tr></table></figure><p>形成 <mark>累计</mark> 的统计方法。</p><p>以”自身记录(当前记录)”作为基准进行统计，就是将聚合函数作为窗口函数使用的最大特征。</p><h3 id="计算移动平均"><a href="#计算移动平均" class="headerlink" title="计算移动平均"></a>计算移动平均</h3><p>在窗口中指定更加详细的汇总范围的备选功能，即<mark>框架</mark>.</p><p>也就是可以指定那几行进行汇总。</p><h4 id="指定框架"><a href="#指定框架" class="headerlink" title="指定框架"></a>指定框架</h4><p>使用 ROW 和 PRECEDING 两个关键词，将框架指定为 “截止到之前~行”.</p><p>如”ROW 2 PRECEDING”:</p><ul><li>自身(当前记录)</li><li>之前1行的记录</li><li>之前2行的记录<br>这样的统计方法称为<mark>移动平均</mark>(moving average).</li></ul><p>关键词FOLLOWING指”截止到之后~行”.</p><p>主要是要找到当前行。</p><h4 id="将当前记录的前后行作为汇总对象"><a href="#将当前记录的前后行作为汇总对象" class="headerlink" title="将当前记录的前后行作为汇总对象"></a>将当前记录的前后行作为汇总对象</h4><p>同时使用 PRECEDING 和 FOLLOWING.</p><h3 id="两个-ORDER-BY"><a href="#两个-ORDER-BY" class="headerlink" title="两个 ORDER BY"></a>两个 ORDER BY</h3><p>使用窗口函数时必须要在 OVER 子句中使用 ORDER BY. 但其只是用来决定窗口函数按照什么样的顺序进行计算。</p><p>在 select 语句的最后使用 order by 子句保证排序记录。</p><h2 id="8-2-GROUPING-运算符"><a href="#8-2-GROUPING-运算符" class="headerlink" title="8-2 GROUPING 运算符"></a>8-2 GROUPING 运算符</h2><h3 id="同时得到合计行"><a href="#同时得到合计行" class="headerlink" title="同时得到合计行"></a>同时得到合计行</h3><h3 id="ROLLUP-–-同时得出合计和小计"><a href="#ROLLUP-–-同时得出合计和小计" class="headerlink" title="ROLLUP – 同时得出合计和小计"></a>ROLLUP – 同时得出合计和小计</h3><p>GROUPING 运算符包含以下3种:</p><ul><li>ROLLUP</li><li>CUBE</li><li>GROUPING SETS</li></ul><h4 id="ROLLUP-的使用方法"><a href="#ROLLUP-的使用方法" class="headerlink" title="ROLLUP 的使用方法"></a>ROLLUP 的使用方法</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> product_type, SUM(sale_price) <span class="hljs-keyword">AS</span> sum_price<br>    <span class="hljs-keyword">FROM</span> Product<br>  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">ROLLUP</span>(product_type);<br></code></pre></td></tr></table></figure><p>GROUP BY() 被称为<mark>超级分组记录(super group row)</mark>.</p><p>超级分组记录默认使用 NULL 作为聚合键。</p><h4 id="将”登记日期”添加到聚合键中"><a href="#将”登记日期”添加到聚合键中" class="headerlink" title="将”登记日期”添加到聚合键中"></a>将”登记日期”添加到聚合键中</h4><h3 id="GROUPING函数-–-让NULL更加容易分辨"><a href="#GROUPING函数-–-让NULL更加容易分辨" class="headerlink" title="GROUPING函数 – 让NULL更加容易分辨"></a>GROUPING函数 – 让NULL更加容易分辨</h3><p><code>GROUPING</code>函数 – 用来判断超级分组记录的 NULL 的特定函数。</p><p>在其参数列的值为超级分组记录所产生的 NULL 时返回1，其他情况返回0.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> GROUOING(product_type) <span class="hljs-keyword">AS</span> product_type<br>        GROUPING(regist_date) <span class="hljs-keyword">AS</span> regist_date, SUM(sale_price) <span class="hljs-keyword">AS</span> sum_price<br>        <span class="hljs-keyword">FROM</span> Product<br>      <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">ROLLUP</span>(product_type, regist_date);<br></code></pre></td></tr></table></figure><h3 id="CUBE-–-用数据来搭积木"><a href="#CUBE-–-用数据来搭积木" class="headerlink" title="CUBE – 用数据来搭积木"></a>CUBE – 用数据来搭积木</h3><h1 id="第9章-通过应用程序连接数据库"><a href="#第9章-通过应用程序连接数据库" class="headerlink" title="第9章 通过应用程序连接数据库"></a>第9章 通过应用程序连接数据库</h1><h2 id="9-1-数据库世界和应用程序世界的连接"><a href="#9-1-数据库世界和应用程序世界的连接" class="headerlink" title="9-1 数据库世界和应用程序世界的连接"></a>9-1 数据库世界和应用程序世界的连接</h2><h3 id="数据库和应用程序之间的关系"><a href="#数据库和应用程序之间的关系" class="headerlink" title="数据库和应用程序之间的关系"></a>数据库和应用程序之间的关系</h3><p>系统 &#x3D; 应用 + 数据库</p><h3 id="驱动-–-两个世界之间的桥梁"><a href="#驱动-–-两个世界之间的桥梁" class="headerlink" title="驱动 – 两个世界之间的桥梁"></a>驱动 – 两个世界之间的桥梁</h3><p>驱动，实际上就是连接的意思。</p><p>驱动，用于解决更换编程语言或者DBMS而导致从头开始修改应用和SQL语句。</p><p>驱动是用来连接应用和数据库的非常小的特殊程序。</p><h3 id="驱动的种类"><a href="#驱动的种类" class="headerlink" title="驱动的种类"></a>驱动的种类</h3><p>DBMS 和编程语言的不同，使用的驱动程序也不一样。</p><p>现在广泛使用的驱动标准主要有 ODBC(Open DataBase Connectivity) 和 JDBC(Java Data Base Connectivity).</p><p><a href="https://jdbc.postgresql.org/download.html">下载 Driver 的网站</a></p><p><code>.jar</code> 扩展名是 Java 的可执行文件的扩展名。</p><h2 id="9-2-Java-基础知识"><a href="#9-2-Java-基础知识" class="headerlink" title="9-2  Java 基础知识"></a>9-2  Java 基础知识</h2><p><code>src</code> 是 <code>源代码</code>(source) 的简称。</p><p>SQL 中的字符串是使用单引号(‘)括起来的。</p><h3 id="编译和程序执行"><a href="#编译和程序执行" class="headerlink" title="编译和程序执行"></a>编译和程序执行</h3><p>使用 javac 进行编译:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">javac</span> <span class="hljs-regexp">*.java</span><br></code></pre></td></tr></table></figure><p>编译成功后会生成<code>.class</code>文件，其为可执行文件，称为”类文件”.</p><h4 id="使用-java-命令执行程序"><a href="#使用-java-命令执行程序" class="headerlink" title="使用 java 命令执行程序"></a>使用 java 命令执行程序</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">java <span class="hljs-tag">&lt;<span class="hljs-name">类名</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="大小写错误"><a href="#大小写错误" class="headerlink" title="大小写错误"></a>大小写错误</h4><p>Java 区分大小写。</p><h4 id="使用全角空格"><a href="#使用全角空格" class="headerlink" title="使用全角空格"></a>使用全角空格</h4><p>源代码中不能使用全角空格。</p><h4 id="源文件的文件名和类名不一致"><a href="#源文件的文件名和类名不一致" class="headerlink" title="源文件的文件名和类名不一致"></a>源文件的文件名和类名不一致</h4><p>文件名必须和源代码第1行的类名一致。</p><h4 id="命令名和文件名错误"><a href="#命令名和文件名错误" class="headerlink" title="命令名和文件名错误"></a>命令名和文件名错误</h4><h2 id="9-3-通过-Java-联结-PostgreSQL"><a href="#9-3-通过-Java-联结-PostgreSQL" class="headerlink" title="9-3 通过 Java 联结 PostgreSQL"></a>9-3 通过 Java 联结 PostgreSQL</h2><h3 id="执行-SQL-语句的-Java-程序"><a href="#执行-SQL-语句的-Java-程序" class="headerlink" title="执行 SQL 语句的 Java 程序"></a>执行 SQL 语句的 Java 程序</h3><h3 id="Java-是如何从数据库中获取数据的"><a href="#Java-是如何从数据库中获取数据的" class="headerlink" title="Java 是如何从数据库中获取数据的"></a>Java 是如何从数据库中获取数据的</h3>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图灵机</title>
    <link href="/2022/08/07/%E5%9B%BE%E7%81%B5%E6%9C%BA/"/>
    <url>/2022/08/07/%E5%9B%BE%E7%81%B5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%9B%BE%E7%81%B5%E6%9C%BA/2112989?fr=aladdin">reference</a></p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宏 学习 Notes</title>
    <link href="/2022/08/07/%E5%AE%8F-%E5%AD%A6%E4%B9%A0-Notes/"/>
    <url>/2022/08/07/%E5%AE%8F-%E5%AD%A6%E4%B9%A0-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://onevcat.com/2014/01/black-magic-in-macro/">reference</a></p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>C中宏分两类: </p><ul><li>对象宏(object-like macro)</li><li>函数宏(function-like macro)</li></ul>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macro c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GNU m4 教程 Notes</title>
    <link href="/2022/08/07/GNU-m4-%E6%95%99%E7%A8%8B-Notes/"/>
    <url>/2022/08/07/GNU-m4-%E6%95%99%E7%A8%8B-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000004104696">reference</a></p><h1 id="GNU-m4-简介"><a href="#GNU-m4-简介" class="headerlink" title="GNU m4 简介"></a>GNU m4 简介</h1><p>m4 是一种宏处理器, 它扫描用户输入的文本并将其输出, 期间如果遇到宏就将其展开后输出.</p><p>除展开宏, m4 内建的宏能够加载文件, 执行Shell命令, 做整数运算, 操纵文本, 形成递归等.</p><h1 id="m4-基本工作过程"><a href="#m4-基本工作过程" class="headerlink" title="m4 基本工作过程"></a>m4 基本工作过程</h1><p>在”C Programming Language” 中将<strong>流</strong>(stream), 定义为与磁盘或其它外围设备关联的数据的源或目的地. 也就可以理解为文件.</p><p>由此, 输入流就是与磁盘或其他外围设备关联的数据的源. </p><p>输出流就是与磁盘或其他外围设备关联的数据的源或目的地.</p><h1 id="m4-工作空间"><a href="#m4-工作空间" class="headerlink" title="m4 工作空间"></a>m4 工作空间</h1><p>需要一个来<mark>状态寄存器</mark>判断当前从输入流中读取的文本是宏还是非宏.</p><p>有一个缓存空间, 用于提高文本效率. 其容量为512KB, 当它满了的时候, m4会自动将其中的内容妥善保存到一份临时文件中备用. 这里官方的概念为转移(Diversion).</p><p>使用<code>divert</code>宏, 在各缓存中切换, 有十种级别的缓存.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">divert</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span><br></code></pre></td></tr></table></figure><p>最后, m4会将各个缓存中的文本汇总到0号缓存中.</p><p>缓存的汇总过程是按照缓存级别进行的. 最后会将0号缓存中的内容依序发送到输出流中.</p><p>文本流经m4的过程不可逆.</p><p>逆向工程能在一定程度上复原某个程序的代码, 但它却永远无法基于宏的展开重现宏的定义.</p><h1 id="暗黑缓存"><a href="#暗黑缓存" class="headerlink" title="暗黑缓存"></a>暗黑缓存</h1><p>编号为负数, 不限数量.</p><p>m4 不会将暗黑缓存汇总的内容发送到输出流.</p><p>暗黑缓存的主要作用是作为宏定义的空间.</p><p>长度为零的字符串被发送到输出流, 不会对其产生影响.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">divert</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">define</span><span class="hljs-params">(say_hello_world, Hello World!)</span></span><br>say_hello_world<br></code></pre></td></tr></table></figure><p><code>divert(0)</code> 及其他语句后面有一个换行符, 会对输出产生影响.</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">$ <span class="hljs-name">m4</span> hello.<span class="hljs-name">m4</span><br></code></pre></td></tr></table></figure><p>使用暗黑缓存以避免一个换行符的影响:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">divert</span><span class="hljs-params">(-<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">define</span><span class="hljs-params">(say_hello_world, Hello World!)</span></span><br><span class="hljs-function"><span class="hljs-title">divert</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span><br>say_hello_world<br></code></pre></td></tr></table></figure><p>调用时避免换行符的影响:</p><ul><li>divert(0)后不换行</li><li>使用m4内建的dnl宏<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">divert</span><span class="hljs-params">(-<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">define</span><span class="hljs-params">(say_hello_world, Hello World!)</span></span><br><span class="hljs-function"><span class="hljs-title">divert</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span><span class="hljs-title">dnl</span></span><br>say_hello_world<br></code></pre></td></tr></table></figure></li></ul><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p><code>define</code>关键字用于定义宏:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">define</span><span class="hljs-params">(hello, HELLO)</span></span><br></code></pre></td></tr></table></figure><p>前一个是宏, 后一个是展开的值.</p><p><code>define</code>本身就是一个宏, 也会被m4展开, 只不过它的展开结果是一个空字符串.</p><h1 id="有参数的宏"><a href="#有参数的宏" class="headerlink" title="有参数的宏"></a>有参数的宏</h1><p>宏可以有参数.</p><p>遵循POSIX标准的m4, 允许一个宏最多有9个参数. 在宏体中可使用<code>$1</code>,…,<code>$9</code>来引用. GNU的m4不限制宏的参数数量.</p><p><mark>注意</mark>, c宏与m4宏的调用有点区别. 在C中, 调用一个宏, 宏名与其后的”(“可以有空格, 而m4宏的调用不允许这样.</p><p>m4的宏体是一个带引号的字符串, 做引号与<code>~</code>同键, 有引号与<code>&quot;</code>同键.</p><p><code>,</code>会被m4捕获为宏参数分隔符, 而引号可使之逃逸.</p><h1 id="宏的陷阱"><a href="#宏的陷阱" class="headerlink" title="宏的陷阱"></a>宏的陷阱</h1><p>m4允许宏的重定义, 结果是新的宏定义会覆盖旧的.</p><p>m4的宏命名规则: 只允许使用字母, 数字以及下划线构造宏名, 并且宏名只能以字母或下划线开头.</p><p>对宏进行重定义时, 需要借助引号.</p><p>引号的作用:</p><ul><li>m4 将一切没有引号的文本都视为宏。对于已定义的宏，m4 会将其展开；对于未定义的宏，m4 会按其字面将其输出。</li><li>加了引号的文本，m4 不再检测它们是不是宏，而是将其作为普通文本按字面输出。</li></ul><p>也就是, 加了引号的文本, 会被m4认为普通字符输出.</p><h1 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h1><p>m4输入流原理:<br>m4 对输入流是以记号（Token）为单元进行读取的。一般情况下，m4 会将读取的每个记号直接发送到输出流，但是当 m4 发现某个单词是已定义的宏名时，它会将这个宏展开。在对宏进行展开的过程中，m4 可能会需要读入更多的文本以获取宏的参数。宏展开的结果会被插入到输入流剩余部分的前端，也就是说，宏展开后所得到的文本会被 m4 重新读取，解析为记号，继续处理。</p><p>在宏参数列表中, 在<code>,</code>之后的空格是无意义的字符.</p><p>空的字符串, 虽然不具备被 m4 发送到输出流的资格, 但是它可以作为其他记号的边界记号使用.</p><h1 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h1><p><code>#</code> 是行注释符, m4 的注释文本也会被发送到输出流.</p><p>可使用<code>changecom</code>宏修改 m4 默认的注释符:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">changecom</span>(`@@&#x27;)<br></code></pre></td></tr></table></figure><p>使用块注释符:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">changecom</span><span class="hljs-params">(/*,*/)</span></span><br></code></pre></td></tr></table></figure><p>不回显注释文本, 使用<code>dnl</code>:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">define(<span class="hljs-symbol">`VERSION&#x27;</span>,<span class="hljs-symbol">`A1&#x27;</span>)<br><span class="hljs-keyword">VERSION</span> dnl <span class="hljs-keyword">VERSION</span> <span class="hljs-symbol">`quote&#x27;</span> unmatched`<br></code></pre></td></tr></table></figure><h1 id="引号-逃逸以及非ASCII字符"><a href="#引号-逃逸以及非ASCII字符" class="headerlink" title="引号, 逃逸以及非ASCII字符"></a>引号, 逃逸以及非ASCII字符</h1><p>使用<code>changequote</code>宏修改m4默认的引号定界符:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">changequote</span><span class="hljs-params">(&lt;!,!&gt;)</span></span><br></code></pre></td></tr></table></figure><p>不向其提供参数, 即恢复默认引号定界符.</p><h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p><code>ifdef</code>宏用于判断宏是否定义, <code>ifelse</code>宏判断表达式的真假.</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">ifdef</span>(`a&#x27;, b)<br></code></pre></td></tr></table></figure><p>如果<code>a</code>是已定义宏, 那么这条语句的展开结果是<code>b</code>.<br><code>ifelse(a,b,c,d)</code>会比较字符串<code>a</code>与<code>b</code>是否相同, 如果它们相同, 这条语句的展开结果是字符串<code>c</code>, 否则则展开为字符串<code>d</code>.</p><p><code>ifelse</code>可以支持多个分支.</p><h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><p>m4内建宏<code>eval</code>, 对整型数的运算表达式进行求值.</p><p>在<code>m4</code>中可以通过<code>esyscmd</code>宏访问Shell.</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>m4会将当前宏的展开结果插入到待读取的输入流的前端.</p>]]></content>
    
    
    <categories>
      
      <category>GNU m4</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Debugging with GDB v8.3.1 Notes</title>
    <link href="/2022/08/07/Debugging-with-GDB-v8-3-1-Notes/"/>
    <url>/2022/08/07/Debugging-with-GDB-v8-3-1-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="1-A-Simple-GDB-Session"><a href="#1-A-Simple-GDB-Session" class="headerlink" title="1 A Simple GDB Session"></a>1 A Simple GDB Session</h1><p>区分<code>next</code>和<code>step</code>:</p><ul><li><code>next</code> 用在执行整个程序</li><li><code>step</code> 用在进入到一个函数的内部程序</li></ul><p><code>continue</code>应该是使暂停的程序继续运行.</p><h1 id="2-Getting-In-and-Out-of-GDB"><a href="#2-Getting-In-and-Out-of-GDB" class="headerlink" title="2 Getting In and Out of GDB"></a>2 Getting In and Out of GDB</h1><p>The command-line options described here are designed to cover a variety of situations.</p><p>You can start with both an executeble program and a core file specified:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">gdb <span class="hljs-keyword">program</span> core<br></code></pre></td></tr></table></figure><p>第二个 argument 可以改为 process ID, 以此 debug a running process:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gdb</span> program <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h3 id="2-1-1-Choosing-Files"><a href="#2-1-1-Choosing-Files" class="headerlink" title="2.1.1 Choosing Files"></a>2.1.1 Choosing Files</h3><p>If you prefer, you can flag option arguments with ‘–’ rather than ‘-‘.</p><h3 id="2-1-2-Choosing-Modes"><a href="#2-1-2-Choosing-Modes" class="headerlink" title="2.1.2 Choosing Modes"></a>2.1.2 Choosing Modes</h3><h3 id="2-1-3-What-GDB-Does-During-Startup"><a href="#2-1-3-What-GDB-Does-During-Startup" class="headerlink" title="2.1.3 What GDB Does During Startup"></a>2.1.3 What GDB Does During Startup</h3><p>The GDB init file are normally called <code>.gdbinit</code>.</p><h2 id="2-2-Quitting-GDB"><a href="#2-2-Quitting-GDB" class="headerlink" title="2.2 Quitting GDB"></a>2.2 Quitting GDB</h2><h2 id="2-3-Shell-Commands"><a href="#2-3-Shell-Commands" class="headerlink" title="2.3 Shell Commands"></a>2.3 Shell Commands</h2><p>Using shell command during debugging:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">!<span class="hljs-keyword">command</span>-<span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><p>可直接使用<code>make</code>:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">make</span> <span class="hljs-keyword">make</span>-<span class="hljs-keyword">args</span><br></code></pre></td></tr></table></figure><h2 id="2-4-Logging-Output"><a href="#2-4-Logging-Output" class="headerlink" title="2.4 Logging Output"></a>2.4 Logging Output</h2><p>保存 the output of GDB commands to a file.</p><h1 id="3-GDB-Commands"><a href="#3-GDB-Commands" class="headerlink" title="3 GDB Commands"></a>3 GDB Commands</h1><h2 id="3-1-Command-Syntax"><a href="#3-1-Command-Syntax" class="headerlink" title="3.1 Command Syntax"></a>3.1 Command Syntax</h2><p>A blank line as input to GDB means to repeat the previous command. User-defined commands can disable this feature.</p><h2 id="3-2-Command-Completion"><a href="#3-2-Command-Completion" class="headerlink" title="3.2 Command Completion"></a>3.2 Command Completion</h2><p>按<code>M-?</code>和按两次<code>TAB</code>作用相同.</p><h2 id="3-3-Getting-Help"><a href="#3-3-Getting-Help" class="headerlink" title="3.3 Getting Help"></a>3.3 Getting Help</h2><p>Using <code>help</code>.</p><p><code>help class</code>, 输入<code>help</code>后出现的是<code>class</code>, <code>help class</code> 会显示这个class中的命令.</p><p><code>apropos args</code>, the <code>apropos</code> command searches through all of the GDB commands, and their documentation, for the <mark>regular expression</mark> specified in <code>args</code>.</p><p><code>complete args</code>, the <code>complete args</code> command lists all the possible completions for the beginning of a command.</p><p>除了<code>help</code>, <code>info</code> 和 <code>show</code> 都能够给出 the state of your program, or the state of GDB itself.</p><ul><li>list, 用于 describing the state of your program, 如<code>info args</code>, <code>info registers</code>, <code>info breakpoints</code>.</li><li>set, 用于 assign an environment variable.</li><li>show, 用于 describing the state of GDB itself. To display all the settable parameters and their current values, you can use <code>show</code> with no argument or <code>info set</code>.</li></ul><h1 id="4-Running-Programs-Under-GDB"><a href="#4-Running-Programs-Under-GDB" class="headerlink" title="4 Running Programs Under GDB"></a>4 Running Programs Under GDB</h1><h2 id="4-1-Compiling-for-Debugging"><a href="#4-1-Compiling-for-Debugging" class="headerlink" title="4.1 Compiling for Debugging"></a>4.1 Compiling for Debugging</h2><p>在编译时使用<code>-g</code>选项.</p><p>Some compilers are unable to handle the <code>-g</code> and <code>-O</code> options together.</p><p>Always use <code>-g</code> whenever you compile a program is recommended.</p><p><code>DWARF</code> is currently the most expressive and best supported debugging format in GDB.</p><h2 id="4-2-Starting-your-Program"><a href="#4-2-Starting-your-Program" class="headerlink" title="4.2 Starting your Program"></a>4.2 Starting your Program</h2><ul><li>start, this command does the equivalent of setting a temporary breakpoint at the beginning of the main procedure and then invoking the <code>run</code> command.</li></ul><h2 id="4-3-Your-Program’s-Arguments"><a href="#4-3-Your-Program’s-Arguments" class="headerlink" title="4.3 Your Program’s Arguments"></a>4.3 Your Program’s Arguments</h2><p>The arguments to your program can be specified by the arguments of the <code>run</code> command.</p>]]></content>
    
    
    <categories>
      
      <category>GDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装Python包</title>
    <link href="/2022/08/06/%E5%AE%89%E8%A3%85Python%E5%8C%85/"/>
    <url>/2022/08/06/%E5%AE%89%E8%A3%85Python%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-pip"><a href="#使用-pip" class="headerlink" title="使用 pip"></a>使用 pip</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> matplotlib<br></code></pre></td></tr></table></figure><h1 id="使用-python"><a href="#使用-python" class="headerlink" title="使用 python"></a>使用 python</h1><p>下载源代码后:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> setup.<span class="hljs-keyword">py</span> install<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vim 中的正则 Notes</title>
    <link href="/2022/08/06/Vim-%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99-Notes/"/>
    <url>/2022/08/06/Vim-%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="非捕获型括号"><a href="#非捕获型括号" class="headerlink" title="非捕获型括号"></a>非捕获型括号</h1><p>在括号前加<code>%</code>:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-meta">%</span><span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><h1 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h1><p>使用<code>\c</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Writing fraction in LaTeX</title>
    <link href="/2022/08/05/Writing-fraction-in-LaTeX/"/>
    <url>/2022/08/05/Writing-fraction-in-LaTeX/</url>
    
    <content type="html"><![CDATA[<p>use:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">\frac</span><span class="hljs-template-variable">&#123;&#125;</span><span class="hljs-template-variable">&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>第一个<code>&#123;&#125;</code>为分子, 后一个为分母.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>简单高效LaTeX Notes</title>
    <link href="/2022/08/04/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88LaTeX-Notes/"/>
    <url>/2022/08/04/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88LaTeX-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-写给读者"><a href="#第1章-写给读者" class="headerlink" title="第1章 写给读者"></a>第1章 写给读者</h1><p>Macro 是一个计算机概念, 指用单个命令或操作完成一系列底层命令或操作的组合.</p><p>LaTeX 在 TeX 的基础上定义了众多的宏命令.</p><p>TeX 系统允许你以数字参数的方式把排版内容写到任意的位置.</p><p>LaTeX 生成的文件格式一般是 pdf 和dvi 格式. LaTeX 无法生成 doc 或者 docx 格式的文件, 因为那是微软的商用格式, 两者的工作机理也完全不同.</p><h1 id="第2章-LaTeX-环境配置"><a href="#第2章-LaTeX-环境配置" class="headerlink" title="第2章 LaTeX 环境配置"></a>第2章 LaTeX 环境配置</h1><p><a href="https://tug.org/texlive/">下载 TeX Live</a><br><a href="https://www.texstudio.org/">安装TeX Studio</a></p><h2 id="2-3-TeX-Live-本地宏包管理"><a href="#2-3-TeX-Live-本地宏包管理" class="headerlink" title="2.3 TeX Live 本地宏包管理"></a>2.3 TeX Live 本地宏包管理</h2><p>使用 TeX Live manager, 使用<code>tlmgr</code>命令.</p><h2 id="2-6-编译文档"><a href="#2-6-编译文档" class="headerlink" title="2.6 编译文档"></a>2.6 编译文档</h2><h3 id="2-6-2-错误的排查"><a href="#2-6-2-错误的排查" class="headerlink" title="2.6.2 错误的排查"></a>2.6.2 错误的排查</h3><p>可以翻阅文件夹中的日志记录(log 文件), 来找到 Warnings 开头的记录, 或者 Overfull&#x2F;Underfull 开头的记录.</p><ul><li>由于 LaTeX 的编译原理(第一次生成 aux 文件, 第二次再引用它), 目录想要合理显示, 需要连续编译两次.</li></ul><p>一个用于排查语法错误的宏包: syntonly. 加载此宏包后, 可以在导言区加入<code>\syntaxonly</code>命令, LaTeX 会只排查语法而不生成任何文档.</p><h3 id="2-6-3-TeX帮助资源"><a href="#2-6-3-TeX帮助资源" class="headerlink" title="2.6.3 TeX帮助资源"></a>2.6.3 TeX帮助资源</h3><p>使用 <code>texdoc</code> 命令:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>texdoc ctex<br></code></pre></td></tr></table></figure><h3 id="2-6-4-TeX-使用工具"><a href="#2-6-4-TeX-使用工具" class="headerlink" title="2.6.4 TeX 使用工具"></a>2.6.4 TeX 使用工具</h3><ul><li>手写符号识别, <a href="http://detexify.kirelabs.org/classify.html">Detexify</a>.</li><li>公式截图识别, <a href="https://mathpix.com/">Snip</a></li></ul><h1 id="第3章-LaTeX-基础"><a href="#第3章-LaTeX-基础" class="headerlink" title="第3章 LaTeX 基础"></a>第3章 LaTeX 基础</h1><h2 id="认识-LaTeX"><a href="#认识-LaTeX" class="headerlink" title="认识 LaTeX"></a>认识 LaTeX</h2><h3 id="3-1-1-命令与环境"><a href="#3-1-1-命令与环境" class="headerlink" title="3.1.1 命令与环境"></a>3.1.1 命令与环境</h3><p>LaTeX 中的命令通常是由一个反斜杠加命令名称, 再加上花括号内的参数构成的.</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">\documentclass</span><span class="hljs-template-variable">&#123;ctexart&#125;</span><br></code></pre></td></tr></table></figure><p>如果一些选项是备选的, 那么通常会在花括号前用方括号标出:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">\documentclass<span class="hljs-selector-attr">[a4paper]</span>&#123;ctexart&#125;<br></code></pre></td></tr></table></figure><p>注意: 不带参数的命令后面如果想打印空格, 请在一对内部为空的话括号后键入空格, 否则空格会被忽略.</p><h3 id="3-1-2-保留字符"><a href="#3-1-2-保留字符" class="headerlink" title="3.1.2 保留字符"></a>3.1.2 保留字符</h3><p>在LaTeX中有特殊含义的字符:</p><ul><li><h1 id="：自定义命令时，用于标明参数序号。"><a href="#：自定义命令时，用于标明参数序号。" class="headerlink" title="：自定义命令时，用于标明参数序号。"></a>：自定义命令时，用于标明参数序号。</h1></li><li>$ ：数学环境命令符。</li><li>% ：注释符，其后的该行命令都会视为注释。如果在行末添加这</li><li>个命令，可以防止 LaTeX 在行末插入一些奇怪的空白符。</li><li>^ ：数学环境中的上标命令符。</li><li>&amp; ：表格环境中的跳列符。</li><li>_ ：数学环境中的下标命令符。</li><li>{ 与 } ：用于标记命令的必选参数，或者标记某一部分命令使</li><li>其成为一个整体。</li><li>\ ：用于开始 LaTeX 命令。</li></ul><p>可用<code>\</code>来转义输出.</p><p>输出<code>\</code>可用<code>\texttt</code>:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\texttt&#123;char92&#125;</span> <span class="hljs-comment">#\texttt&#123;char[92]&#125;</span><br><span class="hljs-keyword">or</span><br><span class="hljs-string">\texttt&#123;char`\\&#125;</span> <span class="hljs-comment">#需转义的字符需添加反斜线</span><br></code></pre></td></tr></table></figure><h3 id="3-1-3-导言区"><a href="#3-1-3-导言区" class="headerlink" title="3.1.3 导言区"></a>3.1.3 导言区</h3><p>任何一个LaTeX文档都应该有的结构:</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery">\documentclass[options]<span class="hljs-built_in">&#123;doc</span>-class&#125;<br>\begin<span class="hljs-built_in">&#123;document</span>&#125;<br>  ...<br>\<span class="hljs-keyword">end</span><span class="hljs-built_in">&#123;document</span>&#125;<br></code></pre></td></tr></table></figure><p>可以把导言区视为模板的定义.</p><p>在导言区最常见的是宏包的加载工作:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">\usepackage&#123;<span class="hljs-keyword">package</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-4-文件输出"><a href="#3-1-4-文件输出" class="headerlink" title="3.1.4 文件输出"></a>3.1.4 文件输出</h3><h2 id="3-2-标点与强调"><a href="#3-2-标点与强调" class="headerlink" title="3.2 标点与强调"></a>3.2 标点与强调</h2><p>在文本中使用<code>$$</code>书写数学符号.</p><p>如果在 LaTeX 中直接输入大于号, 小于号而不把它们放在数学环境中, 它们并不会被正确地打印.</p><h3 id="3-2-1-引号"><a href="#3-2-1-引号" class="headerlink" title="3.2.1 引号"></a>3.2.1 引号</h3><p>英文的单引号不是两个<code>&#39;</code>, 左引号是<code>\``, 而右引号是</code>‘&#96;.</p><h3 id="3-2-2-短横-省略号与破折号"><a href="#3-2-2-短横-省略号与破折号" class="headerlink" title="3.2.2 短横, 省略号与破折号"></a>3.2.2 短横, 省略号与破折号</h3><p>英文的省略号使用<code>\ldots</code>命令, 而不是三个句点.</p><h3 id="3-2-3-强调-粗与斜"><a href="#3-2-3-强调-粗与斜" class="headerlink" title="3.2.3 强调: 粗与斜"></a>3.2.3 强调: 粗与斜</h3><p>使用 <code>\emph&#123;text&#125;</code> 命令.</p><p>如果对一段已经这样转换为斜体的文本再使用这个命令, 它就会取消斜体.</p><h3 id="3-2-4-下划线与删除线"><a href="#3-2-4-下划线与删除线" class="headerlink" title="3.2.4 下划线与删除线"></a>3.2.4 下划线与删除线</h3><p>使用 <code>ulem</code> 宏包的 <code>uline</code> 命令.</p><h2 id="3-3-格式控制"><a href="#3-3-格式控制" class="headerlink" title="3.3 格式控制"></a>3.3 格式控制</h2><h3 id="3-3-1-空格-换行与分段"><a href="#3-3-1-空格-换行与分段" class="headerlink" title="3.3.1 空格, 换行与分段"></a>3.3.1 空格, 换行与分段</h3><p>在 LaTeX 中, 多个空格会被视为一个, 多个换行也会被视为一个.</p><p>宏包 <code>lettrine</code> 能够生成首字下沉的效果:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">\lettrine</span><span class="hljs-template-variable">&#123;T&#125;</span><span class="hljs-template-variable">&#123;his&#125;</span><br></code></pre></td></tr></table></figure><h2 id="3-4-字体与颜色"><a href="#3-4-字体与颜色" class="headerlink" title="3.4 字体与颜色"></a>3.4 字体与颜色</h2><p>宋体, 黑体, 楷体属于字族; 加粗, 加斜属于字系和字形; 五号, 小四号属于字号. 这三者大概可以并称为字体.</p><h2 id="3-5-引用与注释"><a href="#3-5-引用与注释" class="headerlink" title="3.5 引用与注释"></a>3.5 引用与注释</h2><h1 id="第4章-数学排版"><a href="#第4章-数学排版" class="headerlink" title="第4章 数学排版"></a>第4章 数学排版</h1><h1 id="第5章-LaTeX-进阶"><a href="#第5章-LaTeX-进阶" class="headerlink" title="第5章 LaTeX 进阶"></a>第5章 LaTeX 进阶</h1><h2 id="5-1-自定义命令与环境"><a href="#5-1-自定义命令与环境" class="headerlink" title="5.1 自定义命令与环境"></a>5.1 自定义命令与环境</h2><p>自定义命令:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">\<span class="hljs-keyword">new</span><span class="hljs-type">command</span>&#123;cmd&#125;[args][<span class="hljs-keyword">default</span>]&#123;def&#125;<br></code></pre></td></tr></table></figure><ul><li>cmd ：新定义的命令，不能与现有命令重名。</li><li>args ：参数个数。</li><li>default ：首个参数，即 #1 的默认值。你可以定义只有一个</li><li>参数且参数含默认值的命令。</li><li>def ：定义的具体内容。参数 1 以 #1 代替，参数 2 以 #2 代替，以此类推。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LaTeX</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Writing Greek Alphabet in LaTeX</title>
    <link href="/2022/08/04/Writing-Greek-Alphabet-in-LaTeX/"/>
    <url>/2022/08/04/Writing-Greek-Alphabet-in-LaTeX/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/zhouchen1998/article/details/119324338">reference</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fix the error:UnboundLocalError: local variable num_rolls referenced before assignment</title>
    <link href="/2022/08/03/Fix-the-error-UnboundLocalError-local-variable-num-rolls-referenced-before-assignment/"/>
    <url>/2022/08/03/Fix-the-error-UnboundLocalError-local-variable-num-rolls-referenced-before-assignment/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法图解 Notes</title>
    <link href="/2022/08/03/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3-Notes/"/>
    <url>/2022/08/03/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="1-2-二分查找"><a href="#1-2-二分查找" class="headerlink" title="1.2 二分查找"></a>1.2 二分查找</h2><h3 id="1-2-2-运行时间"><a href="#1-2-2-运行时间" class="headerlink" title="1.2.2 运行时间"></a>1.2.2 运行时间</h3><p>如果最多猜测的次数与列表长度相同,这被称为线性时间(linear time).</p><h2 id="1-3-大O表示法"><a href="#1-3-大O表示法" class="headerlink" title="1.3 大O表示法"></a>1.3 大O表示法</h2><p>大O表示法指出了算法有多快.</p><p>使用大O表示法, 这个运行时间为O(n).</p><p>大O表示法指的并非以秒为单位的速度, 大O表示法让你能够比较操作数,它指出了算法运行时间的增速.</p><p>O(n), 这里的<code>n</code>为操作数, 之所以称为大O表示法, 是因为操作数前有个大O.</p><h3 id="1-3-3-大O表示法指出了最糟情况下的运行时间"><a href="#1-3-3-大O表示法指出了最糟情况下的运行时间" class="headerlink" title="1.3.3 大O表示法指出了最糟情况下的运行时间"></a>1.3.3 大O表示法指出了最糟情况下的运行时间</h3><p>简单查找的运行时间为O(n), 二分查找的运行时间为$\logn$.</p><h3 id="1-3-5-旅行商"><a href="#1-3-5-旅行商" class="headerlink" title="1.3.5 旅行商"></a>1.3.5 旅行商</h3><p>计算机科学领域非常著名的旅行商问题.</p><p>找到最短旅程的方案.</p><h1 id="第2章-选择排序"><a href="#第2章-选择排序" class="headerlink" title="第2章 选择排序"></a>第2章 选择排序</h1><h2 id="2-2-数组和链表"><a href="#2-2-数组和链表" class="headerlink" title="2.2 数组和链表"></a>2.2 数组和链表</h2><p>O(n) 是线性时间.</p><p>O(1) 是常量时间.</p><p>数组在随机读取上更快.</p><p>链表在插入上更快.</p><h3 id="2-2-4-在中间插入"><a href="#2-2-4-在中间插入" class="headerlink" title="2.2.4 在中间插入"></a>2.2.4 在中间插入</h3><h3 id="2-2-5-删除"><a href="#2-2-5-删除" class="headerlink" title="2.2.5 删除"></a>2.2.5 删除</h3><h2 id="2-3-选择排序"><a href="#2-3-选择排序" class="headerlink" title="2.3 选择排序"></a>2.3 选择排序</h2><p>一般 O($\frac{n^2}{2}$) 写为 O($n^2$), 这个$\frac{1}{2}$一般会省略. </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">selectionSort</span>(arr):<br>  newArr = []<br>  for i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)):<br>      smallest = <span class="hljs-built_in">findSmallest</span>(arr)<br>      newArr.<span class="hljs-built_in">append</span>(arr.<span class="hljs-built_in">pop</span>(smallest))<br>return newArr<br></code></pre></td></tr></table></figure><p> 看来<code>pop</code>可以弹出任意的元素.</p><h1 id="第3章-递归"><a href="#第3章-递归" class="headerlink" title="第3章 递归"></a>第3章 递归</h1><p>如果使用循环, 程序的性能可能更高; 如果使用递归, 程序可能更容易理解.</p><h2 id="3-2-基线条件和递归条件"><a href="#3-2-基线条件和递归条件" class="headerlink" title="3.2 基线条件和递归条件"></a>3.2 基线条件和递归条件</h2><p>编写递归函数, 必须告诉它何时停止递归. 因此, 每个递归函数都有两部分:</p><ul><li>base case, 基线条件, 指函数不再调用自己</li><li>recursive case, 递归条件, 指函数调用自己</li></ul><h2 id="3-3-栈"><a href="#3-3-栈" class="headerlink" title="3.3 栈"></a>3.3 栈</h2><p>一个重要的编程概念–call stack, 调用栈. 其只有两个操作, push, 压入和pop, 弹出.</p><p>计算机使用一个栈来表示这些内存块.</p><p>一个重要概念: 调用另一个函数时, 当前函数暂停并处于未完成状态, 该函数的所有变量的值都还在内存中.</p><h3 id="3-3-2-递归调用栈"><a href="#3-3-2-递归调用栈" class="headerlink" title="3.3.2 递归调用栈"></a>3.3.2 递归调用栈</h3><p>栈在递归中扮演着重要角色.</p><h1 id="第4章-快速排序"><a href="#第4章-快速排序" class="headerlink" title="第4章 快速排序"></a>第4章 快速排序</h1><p>Divide and Conquer, D&amp;C, 一种递归式问题解决方法.</p><p>D&amp;C 的工作原理:</p><ol><li>找出简单的基线条件</li><li>确定如何缩小问题的规模, 使其符合基线条件<br>D&amp;C 并非可用于解决问题的算法, 而是一种解决问题的思路.</li></ol><p>编写<mark>涉及数组</mark>的递归函数时, 基线条件通常是数组为空或只包含一个元素.</p><p>在很多用循环解决的方案中, 可以考虑使用递归.</p><h2 id="4-2-快速排序"><a href="#4-2-快速排序" class="headerlink" title="4.2 快速排序"></a>4.2 快速排序</h2><p>工作原理:</p><ol><li>从数组中选择一个元素, 这个元素被称为基准值(pivot).</li><li>找出比基准值小的元素以及比基准值大的元素. 这被称为分区(partitioning).</li><li>对这两个子数组进行快速排序.<br>任何元素用作基准值都可行.</li></ol><p><mark>归纳证明</mark>, 一种证明算法行之有效的方式, 分为两步: 基线条件和归纳条件.</p><h2 id="4-3-再谈大O表示法"><a href="#4-3-再谈大O表示法" class="headerlink" title="4.3 再谈大O表示法"></a>4.3 再谈大O表示法</h2><p>快速排序的独特之处在于,其速度取决于选择的基准值.</p><h3 id="4-3-1-比较合并排序和快速排序"><a href="#4-3-1-比较合并排序和快速排序" class="headerlink" title="4.3.1 比较合并排序和快速排序"></a>4.3.1 比较合并排序和快速排序</h3><h3 id="4-3-2-平均情况和最糟情况"><a href="#4-3-2-平均情况和最糟情况" class="headerlink" title="4.3.2 平均情况和最糟情况"></a>4.3.2 平均情况和最糟情况</h3><h1 id="第5章-散列表"><a href="#第5章-散列表" class="headerlink" title="第5章 散列表"></a>第5章 散列表</h1><p>Hashtable, 就是哈希表.</p><h2 id="5-1-散列函数"><a href="#5-1-散列函数" class="headerlink" title="5.1 散列函数"></a>5.1 散列函数</h2><p>对于同样的输入, 散列表必须返回同样的输出.</p><h2 id="5-2-应用案例"><a href="#5-2-应用案例" class="headerlink" title="5.2 应用案例"></a>5.2 应用案例</h2><h3 id="5-2-1-将散列表用于查找"><a href="#5-2-1-将散列表用于查找" class="headerlink" title="5.2.1 将散列表用于查找"></a>5.2.1 将散列表用于查找</h3><p>散列表能够模拟映射关系.</p><h3 id="5-2-2-防止重复"><a href="#5-2-2-防止重复" class="headerlink" title="5,2,2 防止重复"></a>5,2,2 防止重复</h3><h3 id="5-2-3-用作缓存"><a href="#5-2-3-用作缓存" class="headerlink" title="5.2.3 用作缓存"></a>5.2.3 用作缓存</h3><h2 id="5-3-冲突"><a href="#5-3-冲突" class="headerlink" title="5.3 冲突"></a>5.3 冲突</h2><p>要明白散列表的性能, 需了解什么是冲突. Collision: 给两个键分配的位置相同.</p><p>最简单的解决方法: 如果两个键映射到了同一个位置, 就在这个位置存储一个链表.</p><p>最理想的情况是, 散列函数将键均匀地映射到散列表的不同位置.</p><p>如果散列表存储的链表很长, 散列表的速度将急剧下降.</p><h2 id="5-4-性能"><a href="#5-4-性能" class="headerlink" title="5.4 性能"></a>5.4 性能</h2><p>在平均情况下, 无论散列表包含多少个元素, 从中获取数据所需的时间都相同, 为O(1)–常量时间.</p><p>在最糟情况下, 散列表所有操作的运行时间都为O(n)–线性时间.</p><p>为避免冲突, 需要有:</p><ul><li>较低的填装因子</li><li>良好的散列函数</li></ul><h3 id="5-4-1-填装因子"><a href="#5-4-1-填装因子" class="headerlink" title="5.4.1 填装因子"></a>5.4.1 填装因子</h3><p>计算:<br>$\frac{element number}{position number}$</p><p>填装因子大于1意味着商品数量超过了数组的位置数, 一旦填装因子开始增大, 你就需要在散列表中添加位置, 这被称为调整长度(resizing).</p><p>一个经验规则: 一旦填装因子大于0.7, 就调整散列表的长度.</p><h3 id="5-4-2-良好的散列函数"><a href="#5-4-2-良好的散列函数" class="headerlink" title="5.4.2 良好的散列函数"></a>5.4.2 良好的散列函数</h3><p>良好的散列函数让数组中的值呈均匀分布.</p><p>糟糕的散列函数让值扎堆, 导致大量冲突.</p><h1 id="第6章-广度优先搜索"><a href="#第6章-广度优先搜索" class="headerlink" title="第6章 广度优先搜索"></a>第6章 广度优先搜索</h1><p>Breadth-first search, BFS. 用于找出两样东西之间的最短距离.</p>]]></content>
    
    
    <categories>
      
      <category>Arithmetic</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Solved: /usr/bin/python3: No module named pip error on Linux</title>
    <link href="/2022/08/01/Solved-usr-bin-python3-No-module-named-pip-error-on-Linux/"/>
    <url>/2022/08/01/Solved-usr-bin-python3-No-module-named-pip-error-on-Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p><a href="https://stackoverflow.com/questions/44622182/python-3-6-no-module-named-pip">reference1</a></p><p>manually install <code>pip</code>:</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">wget</span> <span class="hljs-string">https</span>://<span class="hljs-string">bootstrap</span>.<span class="hljs-string">pypa</span>.<span class="hljs-string">io</span>/<span class="hljs-built_in">get-pip.py</span><br><span class="hljs-string">sudo</span> <span class="hljs-string">python3</span> <span class="hljs-built_in">get-pip.py</span><br></code></pre></td></tr></table></figure><p>In Debian distributions:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">python</span>-pip ##for python2<br><br>sudo apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">python3</span>-pip ##for <span class="hljs-keyword">python3</span><br></code></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p><a href="https://www.cyberithub.com/solved-usr-bin-python3-no-module-named-pip-error-on-linux/">reference2</a></p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>电路分析导论</title>
    <link href="/2022/08/01/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%AF%BC%E8%AE%BA%20Notes/"/>
    <url>/2022/08/01/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%AF%BC%E8%AE%BA%20Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-绪论"><a href="#Chapter-1-绪论" class="headerlink" title="Chapter 1 绪论"></a>Chapter 1 绪论</h1><h2 id="1-3-测量单位与单位制"><a href="#1-3-测量单位与单位制" class="headerlink" title="1.3 测量单位与单位制"></a>1.3 测量单位与单位制</h2><p>米最初被定义为沿海平面从地球赤道到地球南极或北极距离的一千万分之一。</p><p>现在的米是参照真空中的光速定义的，光速为299792458m&#x2F;s.</p><p>千克定义为1cm^3纯净水在4oc时质量的1000倍.</p><p>秒最初的定义为平均太阳日的86400分之一.</p><p>1967年, 秒被重新定义为铯原子电磁辐射(能级跃迁)周期的9192631770倍.</p><h1 id="Chapter-2-电压和电流"><a href="#Chapter-2-电压和电流" class="headerlink" title="Chapter 2 电压和电流"></a>Chapter 2 电压和电流</h1><p>每一电子层所存在的最多电子数量可用2n^2来计算.</p><h2 id="2-3-电压"><a href="#2-3-电压" class="headerlink" title="2.3 电压"></a>2.3 电压</h2><p>一般地,每个电压源都是靠分离正电荷和负电荷来建立电压的.</p><p>6.242 x 10^18 个电子所带的总电荷量称为1库仑(C).</p><p>如果在两点之间移动1库仑(C)的负电荷, 刚好消耗了1焦耳(J)的能量, 则这两点之间就有1伏特(V)的电压.</p>]]></content>
    
    
    <categories>
      
      <category>Circuit Analysis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Engineering a compiler Notes</title>
    <link href="/2022/08/01/Engineering-a-compiler-Notes/"/>
    <url>/2022/08/01/Engineering-a-compiler-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-Overview-of-Compilation"><a href="#Chapter-1-Overview-of-Compilation" class="headerlink" title="Chapter 1 Overview of Compilation"></a>Chapter 1 Overview of Compilation</h1><p>Compilers are computer programs that translate a program written in one language into a program written in another language.</p><h2 id="1-1-INTRODUCTION"><a href="#1-1-INTRODUCTION" class="headerlink" title="1.1 INTRODUCTION"></a>1.1 INTRODUCTION</h2><p>The compiler has a <mark>front end</mark> to deal with the source language, which focus on understanding the source-language program, and it has a <mark>back end</mark> to deal with the target language, which focus on mapping programs to the target machine.</p><p>Many research compilers produce C program as their output. Because compilers for C are available on most computers.</p><p>Two fundamental principles:<br>    - The compiler must preserve the meaning of the program being compiled.<br>    - The compiler must improve the input program in some discernible way.</p><h2 id="1-2-COMPILER-STRUCTURE"><a href="#1-2-COMPILER-STRUCTURE" class="headerlink" title="1.2 COMPILER STRUCTURE"></a>1.2 COMPILER STRUCTURE</h2><p>A compiler uses some sets of data structures to represent the code it processes. That form is called an <mark>intermediate representation</mark>.</p><p><mark>Two-phase compiler</mark>, 只有 front end 和 back end.<br><mark>Three-phase compiler</mark>, 有 front end, optimizer 和 back end.</p><h2 id="1-3-OVERVIEW-OF-TRANSLATION"><a href="#1-3-OVERVIEW-OF-TRANSLATION" class="headerlink" title="1.3 OVERVIEW OF TRANSLATION"></a>1.3 OVERVIEW OF TRANSLATION</h2><p><mark>Notation</mark><br>A compiler translates a program written in one notation into an equivalent program written in another notation.</p><h3 id="1-3-1-The-Front-End"><a href="#1-3-1-The-Front-End" class="headerlink" title="1.3.1 The Front End"></a>1.3.1 The Front End</h3><h4 id="Cheching-Syntax"><a href="#Cheching-Syntax" class="headerlink" title="Cheching Syntax"></a>Cheching Syntax</h4><p>The source language is a set, usually infinite, of strings defined by some finite set of rules, called a grammar.</p><p>The scanner takes a stream of characters and converts it to a stream of classified words.</p><p>The actual spelling of the words might be stored in a hash table and represented in the pairs with an integer index.</p><p>The process of automatically finding derivations is called <mark>parsing</mark>.</p><h4 id="Intermediate-Representations"><a href="#Intermediate-Representations" class="headerlink" title="Intermediate Representations"></a>Intermediate Representations</h4><p>Compilers use a variety of different kinds of IR.</p><h3 id="1-3-2-The-Optimizer"><a href="#1-3-2-The-Optimizer" class="headerlink" title="1.3.2 The Optimizer"></a>1.3.2 The Optimizer</h3><p>The optimizer analyzes the IR form of the code to discover facts about that context and uses that contextual knowledge to rewrite the code so that it computes the same answer in a more efficient way.</p><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><h4 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h4><h3 id="1-3-3-The-Back-End"><a href="#1-3-3-The-Back-End" class="headerlink" title="1.3.3 The Back End"></a>1.3.3 The Back End</h3><p>The compiler’s back end traverses the IR form of the code and emits code for the target machine.</p><p><code>ILOC</code>–”intermediate language for an optimizing compiler”, is a notation fo low-level examples.</p><h4 id="Instruction-Selection"><a href="#Instruction-Selection" class="headerlink" title="Instruction Selection"></a>Instruction Selection</h4><p>Instruction selection maps each IR operation, in its context, into one or more target machine operations.<br><mark>Virtual register</mark><br>A symbolic register name that the compiler uses to indicate that a value can be stored in a register.</p><p>意思就是选择最合适的 instruction, 所以叫 instruction selector, 比如一个 source code, mapping to 一个 machine code, 有几种选择, 这时 instruction selector 会选择最好的一个. </p><h4 id="Register-Allocation"><a href="#Register-Allocation" class="headerlink" title="Register Allocation"></a>Register Allocation</h4><p>The register allocator must map those virtual registers onto actual target-machine registers.</p><p>The optimization would increase demand for registers but eliminate a later instruction. 意思就是把前面计算的值用于后面的计算.</p><h4 id="Instruction-Scheduling"><a href="#Instruction-Scheduling" class="headerlink" title="Instruction Scheduling"></a>Instruction Scheduling</h4><p>To reorder operation.</p><p>It attempts to minimize the number of cycles wasted waiting for operands.</p><h4 id="Interactions-Among-Code-Generation-Components"><a href="#Interactions-Among-Code-Generation-Components" class="headerlink" title="Interactions Among Code-Generation Components"></a>Interactions Among Code-Generation Components</h4><h2 id="1-4-SUMMARY-AND-PERSPECTIVE"><a href="#1-4-SUMMARY-AND-PERSPECTIVE" class="headerlink" title="1.4 SUMMARY AND PERSPECTIVE"></a>1.4 SUMMARY AND PERSPECTIVE</h2><h1 id="Chapter-2-Scanners"><a href="#Chapter-2-Scanners" class="headerlink" title="Chapter 2 Scanners"></a>Chapter 2 Scanners</h1><p>The scanner is the only pass in the compiler to touch every character in the input program.</p><p>The regular expression, a notation used to describe the valid words in a programming laguage.</p><h2 id="2-1-INTRODUCTION"><a href="#2-1-INTRODUCTION" class="headerlink" title="2.1 INTRODUCTION"></a>2.1 INTRODUCTION</h2><p>The scanner, 也就是 lexical analyzer, reads a stream of characters and produces a stream of words.</p><h3 id="Conceptual-Roadmap"><a href="#Conceptual-Roadmap" class="headerlink" title="Conceptual Roadmap"></a>Conceptual Roadmap</h3><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><mark>Syntactic category</mark>, a classification of words according to their grammatical usage.</p><p><mark>Microsyntax</mark>, the lexical structure of a language, which specifies how to group characters into words and how to separate words that run together.</p><p>In most languages, blanks and punctuation marks terminate a word.</p><p><mark>Keyword</mark>, a word that is reserved for a particular syntactic purpose and, thus, cannot be used as an identifier.</p><p>Both generated and hand-crafted scanners can be implemented to require just O(1) time per character.</p><h2 id="2-2-RECONGNIZING-WORDS"><a href="#2-2-RECONGNIZING-WORDS" class="headerlink" title="2.2 RECONGNIZING WORDS"></a>2.2 RECONGNIZING WORDS</h2><p>The recognizer takes one transition per input character.</p><h3 id="2-2-1-A-Formalism-for-Recognizers"><a href="#2-2-1-A-Formalism-for-Recognizers" class="headerlink" title="2.2.1 A Formalism for Recognizers"></a>2.2.1 A Formalism for Recognizers</h3><p><mark>Finite automation</mark>, a formalism for recogmizers that has a finite set of states, an alphabet, a transition function, a start state, and one or more accepting states. A finite automaton(FA) is a five-tuple($S, \epsilon, \delta, s_0, S_A$).</p><p>有一个 error state $s_e$.</p><h3 id="2-2-2-Recognizing-More-Complex-Words"><a href="#2-2-2-Recognizing-More-Complex-Words" class="headerlink" title="2.2.2 Recognizing More Complex Words"></a>2.2.2 Recognizing More Complex Words</h3><p>Syntactic category 和 lexeme.</p><h2 id="2-3-REGULAR-EXPRESSION"><a href="#2-3-REGULAR-EXPRESSION" class="headerlink" title="2.3 REGULAR EXPRESSION"></a>2.3 REGULAR EXPRESSION</h2><p>The language described by an RE is called a <mark>regular languages</mark>.</p><p>Simple recognizers have simple RE specifications.</p><h3 id="2-3-1-Formalizing-the-Notation"><a href="#2-3-1-Formalizing-the-Notation" class="headerlink" title="2.3.1 Formalizing the Notation"></a>2.3.1 Formalizing the Notation</h3><p>An RE  is built up from three basic operations:</p><ol><li>Alternation, R|S</li><li>Concatenation, RS</li><li>Closure, $R^*$</li></ol><p>Regular expression are used in many applications to specify patterns in character strings.</p><p>Parentheses have highest precedence, followed by closure, concatenation, and alternation, in that order.</p><h3 id="2-3-2-Examples"><a href="#2-3-2-Examples" class="headerlink" title="2.3.2 Examples"></a>2.3.2 Examples</h3><p>The point is critical: the cost of operating an FA is proportional to the length of the input, not to the length or complexity of the RE that generates the FA.</p><h3 id="2-3-3-Closure-Properties-of-REs"><a href="#2-3-3-Closure-Properties-of-REs" class="headerlink" title="2.3.3 Closure Properties of REs"></a>2.3.3 Closure Properties of REs</h3><p>Regular expressions are closed under many operations–that is, if we apply the operation to an RE or a collection of REs, the result is an RE.</p><h2 id="2-4-FROM-REGULAR-EXPRESSION-TO-SCANNER"><a href="#2-4-FROM-REGULAR-EXPRESSION-TO-SCANNER" class="headerlink" title="2.4 FROM REGULAR EXPRESSION TO SCANNER"></a>2.4 FROM REGULAR EXPRESSION TO SCANNER</h2><p>The goal of out work with finite automata is to automate the derivation of executable scanners from a collection of REs.</p><p>Deterministic FAs, or DFAs. Kleene’s construction derives an RE from a DFA.</p><p>Nondeterministic FAs, or NFAs. Thompson’s construction derives an NFA from an RE.</p><h3 id="2-4-1-Nondeterministic-Finite-Automata"><a href="#2-4-1-Nondeterministic-Finite-Automata" class="headerlink" title="2.4.1 Nondeterministic Finite Automata"></a>2.4.1 Nondeterministic Finite Automata</h3><p>An FA that includes states such as $s_0$ that have multiple transitions on a single character is called a <mark>nondeterministic finite automaton</mark>. Its an FA thats allows transitions on the empty string, $\epsilon$, and states that have multiple transitions on the same character.</p><p>An FA with unique character transitions in each state is called a <mark>deterministic finite automaton</mark>. Its an FA where the transition function is single-valued. DFAs do not allow $\epsilon$-transitions.</p><p>NFA 的行为:</p><ul><li>Each time the NFA must make a nondeterministic choice, it follows the transition that leads to an accepting state for the input string, if such a transition exists. 也就是说NFA会把一条路线走完.</li><li>NFA 会 clones itself to pursue each possible transition. At any point, we call the specific set of states in which the NFA is active its <mark>configuration</mark>. 也就是其中某一条.</li></ul><h4 id="Equivalence-of-NFAs-and-DFAs"><a href="#Equivalence-of-NFAs-and-DFAs" class="headerlink" title="Equivalence of NFAs and DFAs"></a>Equivalence of NFAs and DFAs</h4><p>NFAs and DFAs are equivalent in their expressive power. Any DFA is a special case of an NFA.</p><h3 id="2-4-2-Regular-Expression-to-NFA-Thompson’s-Construction"><a href="#2-4-2-Regular-Expression-to-NFA-Thompson’s-Construction" class="headerlink" title="2.4.2 Regular Expression to NFA: Thompson’s Construction"></a>2.4.2 Regular Expression to NFA: Thompson’s Construction</h3><p>Deriving an NFA from the RE.</p><p>因为 NFA 要尝试所有情况, 因此 NFA 需要 $\epsilon$ transformation. 在每一个分支处都需要 $\epsilon$ transformation.</p><p>Each NFA has one start state and one accepting state of NFAs for some component REs.</p><p>An $\epsilon$-transition always connects two states.</p><p>The NFA also contains many $\epsilon$-moves that are obviously unneeded.</p><h3 id="2-4-3-NFA-to-DFA-The-Subset-Construction"><a href="#2-4-3-NFA-to-DFA-The-Subset-Construction" class="headerlink" title="2.4.3 NFA to DFA: The Subset Construction"></a>2.4.3 NFA to DFA: The Subset Construction</h3><p>DFA executions is much easier to simulate than NFA.</p><p>The algorithm that constructs a DFA from an NFA is called <mark>subset construction</mark>.</p><p><mark>Valid configuration</mark>, configuration of an NFA that can be reached by some input string.</p><h3 id="2-4-5-Using-a-DFA-as-a-Recognizer"><a href="#2-4-5-Using-a-DFA-as-a-Recognizer" class="headerlink" title="2.4.5 Using a DFA as a Recognizer"></a>2.4.5 Using a DFA as a Recognizer</h3><h2 id="2-5-IMPLEMENTING-SCANNERS"><a href="#2-5-IMPLEMENTING-SCANNERS" class="headerlink" title="2.5 IMPLEMENTING SCANNERS"></a>2.5 IMPLEMENTING SCANNERS</h2><p>最后一部似乎是 convert the DFA into executable code.</p><p>Three implementation strategies for converting a DFA into executable code:</p><ul><li>a table-driven scanner</li><li>a direct-coded scanner</li><li>a hand-coded sanner<br>All of these scanners operate in the same manner, by simulating the DFA.<br>The three implementation strategies differ in the details of their runtime cost.</li></ul><h3 id="2-5-1-Table-Driven-Scanners"><a href="#2-5-1-Table-Driven-Scanners" class="headerlink" title="2.5.1 Table-Driven Scanners"></a>2.5.1 Table-Driven Scanners</h3>]]></content>
    
    
    <categories>
      
      <category>Compiler Theory</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CS61A Python Notes</title>
    <link href="/2022/07/31/CS61A-Python-Notes/"/>
    <url>/2022/07/31/CS61A-Python-Notes/</url>
    
    <content type="html"><![CDATA[<p><a href="textbook">http://composingprograms.com/pages/13-defining-new-functions.html</a></p><h1 id="Chapter-1-Building-Abstractions-with-Functions"><a href="#Chapter-1-Building-Abstractions-with-Functions" class="headerlink" title="Chapter 1: Building Abstractions with Functions"></a>Chapter 1: Building Abstractions with Functions</h1><h2 id="1-1-Getting-Started"><a href="#1-1-Getting-Started" class="headerlink" title="1.1 Getting Started"></a>1.1 Getting Started</h2><h3 id="1-1-4-First-Example"><a href="#1-1-4-First-Example" class="headerlink" title="1.1.4 First Example"></a>1.1.4 First Example</h3><p><mark>Statement</mark> describe actions. statement are not evaluated but executed.</p><p><mark>Expression</mark> describe computations.<br>All expressions can use function call notation.</p><h2 id="1-2-Elements-of-Programming"><a href="#1-2-Elements-of-Programming" class="headerlink" title="1.2 Elements of Programming"></a>1.2 Elements of Programming</h2><p>Data is stuff that we want to manipulate, and functions describe the rules for manipulating the data.</p><h3 id="1-2-3-Importing-Library-Functions"><a href="#1-2-3-Importing-Library-Functions" class="headerlink" title="1.2.3 Importing Library Functions"></a>1.2.3 Importing Library Functions</h3><p>Import from the <code>math</code> module:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt </span><br></code></pre></td></tr></table></figure><p>The interpreter must maintain some sort of memory that keeps track of the names, values, and bindings. This memory called a <mark>environment</mark>.</p><p>We can use assignment statements to give new names to existing functions.</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">f</span> <span class="hljs-operator">=</span> max<br></code></pre></td></tr></table></figure><p>Assining multiple values to multiple names in a single statement:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">area</span>, circumference = <span class="hljs-literal">pi</span> * radius * radius, <span class="hljs-number">2</span> * <span class="hljs-literal">pi</span> * radius<br></code></pre></td></tr></table></figure><h3 id="1-2-5-Evaluating-Nested-Expressions"><a href="#1-2-5-Evaluating-Nested-Expressions" class="headerlink" title="1.2.5 Evaluating Nested Expressions"></a>1.2.5 Evaluating Nested Expressions</h3><p>To evaluate a call expression, Python will do the following:<br>    1. Evaluate the operator and operand subexpressions, then<br>    2. Apply the function that is the value of the operator subexpression to the arguments that are the values of the operand subexpressions.</p><h3 id="1-2-6-The-Non-Pure-Print-Function"><a href="#1-2-6-The-Non-Pure-Print-Function" class="headerlink" title="1.2.6 The Non-Pure Print Function"></a>1.2.6 The Non-Pure Print Function</h3><p>Distinguish between two types of functions:</p><p><mark>Pure functions</mark>: Functions have some input(their arguments) and reutrn some output(the result of applying them).</p><p><mark>Non-pure functions</mark>: make some change to the state of the interpreter or computer, a common side effect is to generate additional output beyond the return value.</p><p><code>None</code> is a special Python value that represents nothing.</p><p>Be careful with <code>print</code>. The fact that it returns <code>None</code> means that it should not be the expression in an assignment statement.</p><h2 id="1-3-Defining-New-Functions"><a href="#1-3-Defining-New-Functions" class="headerlink" title="1.3 Defining New Functions"></a>1.3 Defining New Functions</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;&gt;&gt; def square(<span class="hljs-keyword">x</span>):<br>        return <span class="hljs-keyword">mul</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">x</span>)<br></code></pre></td></tr></table></figure><p>The <code>x</code> in this definitions is called a “formal parameter”</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def &lt;name&gt;(&lt;formal parameters&gt;):<br>    <span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">return</span> expression&gt;<br></code></pre></td></tr></table></figure><h3 id="1-3-1-Environments"><a href="#1-3-1-Environments" class="headerlink" title="1.3.1 Environments"></a>1.3.1 Environments</h3><p>An <mark>environments</mark> in which an expression is evaluated consists of a sequence of frames.</p><p>Each <mark>frame</mark> contains bindings, each of which associates a name with its corresponding value.<br>There is a global environment.</p><p>The name appearing in the function is called the <code>intrinsic name</code>.<br>The name in a frame is a <code>bound name</code>.<br>Different names may refer to the same function, but that function itself has only one intrinsic name.</p><p>A description of the formal parameters of a function is called the <mark>function’s signature</mark>.</p><h3 id="1-3-2-Calling-User-Defined-Functions"><a href="#1-3-2-Calling-User-Defined-Functions" class="headerlink" title="1.3.2 Calling User-Defined Functions"></a>1.3.2 Calling User-Defined Functions</h3><p>Applying a user-defined function introduces a second <mark>local frame</mark>, which is only accessible to that function.</p><p><mark>Name Evaluation</mark>. A name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found.</p><p>Names are bound to values, which are distributed across many independent local frames, along with a single global frame that contains shared names. A new local frame is introduced every time a function is called.</p><h3 id="1-3-4-Local-Names"><a href="#1-3-4-Local-Names" class="headerlink" title="1.3.4 Local Names"></a>1.3.4 Local Names</h3><h3 id="1-3-5-Choosing-Names"><a href="#1-3-5-Choosing-Names" class="headerlink" title="1.3.5 Choosing Names"></a>1.3.5 Choosing Names</h3><h3 id="1-3-6-Functions-as-Abstractions"><a href="#1-3-6-Functions-as-Abstractions" class="headerlink" title="1.3.6 Functions as Abstractions"></a>1.3.6 Functions as Abstractions</h3><p>The three core attributes of a function: The <mark>domain</mark> of a function is the set of arguments it can take. The <mark>range</mark> of a function is the set of value it can return. The <mark>indent</mark> of a function is the relationship it computes between inputs and output.</p><h3 id="1-3-7-Operators"><a href="#1-3-7-Operators" class="headerlink" title="1.3.7 Operators"></a>1.3.7 Operators</h3><p>The <code>//</code> operator, rounds the result down to an integer.</p><p>The operator can be seen as shorthand for function, like: <code>+</code> is the shorthand of <code>add()</code>.</p><h2 id="1-4-Designing-Function"><a href="#1-4-Designing-Function" class="headerlink" title="1.4 Designing Function"></a>1.4 Designing Function</h2><p>The qualities of good functions all reinforce the idea that functions are abstractions.<br>    - Each function should have exactly one job<br>    - Don’t repeat yourself is a central tenet of software engineering<br>    - Functions should be defined generally</p><h3 id="1-4-1-Documentation"><a href="#1-4-1-Documentation" class="headerlink" title="1.4.1 Documentation"></a>1.4.1 Documentation</h3><p>Dostring, using triple quoted. The first line describes the job of the function in one line. The following lines can describe arguments and clarify the behavior of the function. 这是制作<code>help</code>页，when you call <code>help</code> with the name of a function as an argument, you see its docstring.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pressure</span>(<span class="hljs-params">v, t, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Compute the pressure in pascals of an ideal gas.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law</span><br><span class="hljs-string"></span><br><span class="hljs-string">        v -- volume of gas, in cubic meters</span><br><span class="hljs-string">        t -- absolute temperature in degrees kelvin</span><br><span class="hljs-string">        n -- particles of gas</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        k = <span class="hljs-number">1.38e-23</span>  <span class="hljs-comment"># Boltzmann&#x27;s constant</span><br>        <span class="hljs-keyword">return</span> n * k * t / v<br></code></pre></td></tr></table></figure><p><mark>Comments</mark> use <code>#</code>.</p><h3 id="1-4-2-Default-Argument-Values"><a href="#1-4-2-Default-Argument-Values" class="headerlink" title="1.4.2 Default Argument Values"></a>1.4.2 Default Argument Values</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> pressure(v, t, n=<span class="hljs-number">6</span>.<span class="hljs-number">022</span>e23)<br></code></pre></td></tr></table></figure><h2 id="1-5-Control"><a href="#1-5-Control" class="headerlink" title="1.5 Control"></a>1.5 Control</h2><p>Python code is a sequence of statements.</p><p><mark>Practical Guidance</mark><br>When indenting a suite, all lines must be indented the same amount and in the same way(use spaces, not tabs). Any variation in indentation will cause an error.</p><h3 id="1-5-3-Defining-Functions-II-Local-Assignment"><a href="#1-5-3-Defining-Functions-II-Local-Assignment" class="headerlink" title="1.5.3 Defining Functions II: Local Assignment"></a>1.5.3 Defining Functions II: Local Assignment</h3><p>The process of function application terminates whenever the first <code>return</code> statement is excuted.</p><h3 id="1-5-4-Conditional-Statements"><a href="#1-5-4-Conditional-Statements" class="headerlink" title="1.5.4 Conditional Statements"></a>1.5.4 Conditional Statements</h3><p><mark>Conditional statements</mark></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">if</span> <span class="hljs-symbol">&lt;expression&gt;</span>:<br>     <span class="hljs-symbol">&lt;suite&gt;</span><br>elif <span class="hljs-symbol">&lt;expression&gt;</span>:<br>     <span class="hljs-symbol">&lt;suite&gt;</span><br><span class="hljs-keyword">else</span>:<br>     <span class="hljs-symbol">&lt;suite&gt;</span>]<br></code></pre></td></tr></table></figure><p>Python includes several false value, including 0, None, and the boolean value false.</p><p>The built-in comparison operations: &lt;, &gt;, &gt;&#x3D;, &lt;&#x3D;, &#x3D;&#x3D;, !&#x3D;.</p><p>Three basic logical operators are also built into Python: and, or, not.</p><p>Functions that perform comparisons and return boolean values typically begin with <code>is</code>.</p><h3 id="1-5-5-Iteration"><a href="#1-5-5-Iteration" class="headerlink" title="1.5.5 Iteration"></a>1.5.5 Iteration</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">while</span> <span class="hljs-symbol">&lt;expression&gt;</span>:<br>  <span class="hljs-symbol">&lt;suite&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-5-6-Testing"><a href="#1-5-6-Testing" class="headerlink" title="1.5.6 Testing"></a>1.5.6 Testing</h3><p><mark>Assertions</mark>. Programmers use <code>assert</code> statements to verify expectations, such as the output of a function being tested.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">assert</span> fib(<span class="hljs-number">8</span>) == <span class="hljs-number">13</span>, &#x27;The <span class="hljs-number">8</span>th Fibonacci number should be <span class="hljs-number">13</span>&#x27;<br></code></pre></td></tr></table></figure><p>如果为 false 则打印后面的 expression.</p><p><code>doctest</code> module. 利用 docstring 来测试.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_naturals</span>(<span class="hljs-params">n</span>):<br>      <span class="hljs-string">&quot;&quot;&quot;Return the sum of the first n natural numbers.</span><br><span class="hljs-string"></span><br><span class="hljs-string">      &gt;&gt;&gt; sum_naturals(10)</span><br><span class="hljs-string">      55</span><br><span class="hljs-string">      &gt;&gt;&gt; sum_naturals(100)</span><br><span class="hljs-string">      5050</span><br><span class="hljs-string">      &quot;&quot;&quot;</span><br>      total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>      <span class="hljs-keyword">while</span> k &lt;= n:<br>          total, k = total + k, k + <span class="hljs-number">1</span><br>      <span class="hljs-keyword">return</span> total<br></code></pre></td></tr></table></figure><p>Starting Python with the doctest command line option:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> -<span class="hljs-keyword">m</span> doctest <span class="hljs-symbol">&lt;python_source_file&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-6-Higher-Order-Functions"><a href="#1-6-Higher-Order-Functions" class="headerlink" title="1.6 Higher-Order Functions"></a>1.6 Higher-Order Functions</h2><p>Functions that manipulate functions are called higher-order functions.</p><p>Frames which are no longer needed are removed to save space.</p><p>在函数被调用时才会创建 local frame.</p><h3 id="1-6-1-Functions-as-Arguments"><a href="#1-6-1-Functions-as-Arguments" class="headerlink" title="1.6.1 Functions as Arguments"></a>1.6.1 Functions as Arguments</h3><h3 id="1-6-2-Functions-as-General-Methods"><a href="#1-6-2-Functions-as-General-Methods" class="headerlink" title="1.6.2 Functions as General Methods"></a>1.6.2 Functions as General Methods</h3><h3 id="1-6-3-Defining-Functions-III-Nested-Definitions"><a href="#1-6-3-Defining-Functions-III-Nested-Definitions" class="headerlink" title="1.6.3 Defining Functions III: Nested Definitions"></a>1.6.3 Defining Functions III: Nested Definitions</h3><p>To place function definitions inside the body of other definitions:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt</span>(<span class="hljs-params">a</span>):<br>       <span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt_update</span>(<span class="hljs-params">x</span>):<br>           <span class="hljs-keyword">return</span> average(x, a/x)<br>       <span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt_close</span>(<span class="hljs-params">x</span>):<br>           <span class="hljs-keyword">return</span> approx_eq(x * x, a)<br>       <span class="hljs-keyword">return</span> improve(sqrt_update, sqrt_close)<br></code></pre></td></tr></table></figure><p><mark>Lexical scope</mark><br>A discipline of sharing names among nested definitions. The inner functions have access to the names in the environment where they are defined.</p><p>Two extensions to the environment model:<br>    - Each user-defined function has a parent environment: the environment in which it was defined<br>    - When a user-defined function is called, its local frame extends its parent environment.</p><h3 id="1-6-4-Functions-as-Returned-Values"><a href="#1-6-4-Functions-as-Returned-Values" class="headerlink" title="1.6.4 Functions as Returned Values"></a>1.6.4 Functions as Returned Values</h3><h3 id="1-6-5-Example-Newton’s-Method"><a href="#1-6-5-Example-Newton’s-Method" class="headerlink" title="1.6.5 Example: Newton’s Method"></a>1.6.5 Example: Newton’s Method</h3><h3 id="1-6-6-Currying"><a href="#1-6-6-Currying" class="headerlink" title="1.6.6 Currying"></a>1.6.6 Currying</h3><p>We can use higher-order function to convert a function that takes multiple arguments into a chain of functions that each take a single argument.</p><p>Currying is a transformation, like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">curried_pow</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">y</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(x, y)<br>        <span class="hljs-keyword">return</span> h<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>curried_pow(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)<br><span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><p><mark>Extended Environments</mark><br>An environment can consist of an arbitrarily long chain of frames, which always concludes with the global frame.</p><h3 id="1-6-7-Lambda-Expressions"><a href="#1-6-7-Lambda-Expressions" class="headerlink" title="1.6.7 Lambda Expressions"></a>1.6.7 Lambda Expressions</h3><p>匿名函数. 为了更简洁。</p><p>A lambda expression evaluates to a function that has a single return expression as its body. Assignment and control statements are not allowed.</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">lambda</span>            <span class="hljs-variable">x</span>            :          <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-title">g</span>(<span class="hljs-variable">x</span>))</span><br><span class="hljs-string">&quot;A function that    takes x    and returns     f(g(x))&quot;</span><br></code></pre></td></tr></table></figure><h3 id="1-6-8-Abstractions-and-First-Class-Functions"><a href="#1-6-8-Abstractions-and-First-Class-Functions" class="headerlink" title="1.6.8 Abstractions and First-Class Functions"></a>1.6.8 Abstractions and First-Class Functions</h3><h3 id="1-6-9-Function-Decorators"><a href="#1-6-9-Function-Decorators" class="headerlink" title="1.6.9 Function Decorators"></a>1.6.9 Function Decorators</h3><p>The decorator symbol <code>@</code>.</p><p><code>@</code> 后面跟一个 expression, this expression is evaluated first, the <code>def</code> statement second, and finally the result of evaluating the decorator expression is applied to the newly defined function, and the result if bound to the name in the <code>def</code> statement.</p><p>作用:</p><ol><li>使函数的功能得到补充，而同时不用修改函数本身的代码</li><li>增加函数执行前、后的行为，而不需对调用函数的代码做任何改变。</li></ol><p>感觉就是在当前函数的基础上添加功能。减少重复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">fn</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt; &#x27;</span>, fn, <span class="hljs-string">&#x27;(&#x27;</span>, x, <span class="hljs-string">&#x27;)&#x27;</span>)<br>            <span class="hljs-keyword">return</span> fn(x)<br>        <span class="hljs-keyword">return</span> wrapped<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>@trace<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">triple</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x<br></code></pre></td></tr></table></figure><p>在调用<code>triple</code>时就会同时执行<code>trace</code>和<code>triple</code>中的内容。</p><h2 id="1-7-Recursive-Functions"><a href="#1-7-Recursive-Functions" class="headerlink" title="1.7 Recursive Functions"></a>1.7 Recursive Functions</h2><p>The operators <code>%</code> and <code>//</code> can be used to separate a number into two parts: its last digit and all but its last digit.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">18117</span> % <span class="hljs-number">10</span></span><br>7<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">18117</span> // <span class="hljs-number">10</span></span><br>1811<br></code></pre></td></tr></table></figure><p>The process of excuting the body of a recursive function may in turn require applying that function again.</p><h3 id="1-7-1-The-Anatomy-of-Recursive-Functions"><a href="#1-7-1-The-Anatomy-of-Recursive-Functions" class="headerlink" title="1.7.1 The Anatomy of Recursive Functions"></a>1.7.1 The Anatomy of Recursive Functions</h3><p>A common pattern: the body begins with a base case, a conditional statement that define the behavior of the function for the inputs that are simplest to process.</p><h3 id="1-7-2-Mutual-Recursion"><a href="#1-7-2-Mutual-Recursion" class="headerlink" title="1.7.2 Mutual Recursion"></a>1.7.2 Mutual Recursion</h3><p>A recursive procedure is divided among two functions that call each other.</p><h3 id="1-7-3-Printing-in-Recursive-Functions"><a href="#1-7-3-Printing-in-Recursive-Functions" class="headerlink" title="1.7.3 Printing in Recursive Functions"></a>1.7.3 Printing in Recursive Functions</h3><h3 id="1-7-4-Tree-Recursion"><a href="#1-7-4-Tree-Recursion" class="headerlink" title="1.7.4 Tree Recursion"></a>1.7.4 Tree Recursion</h3><p>A function with multiple recursive calls is said to be <mark>tree recursive</mark> because each call branches into multiple smaller calls, each of which branches into yes smaller calls, just as the branches of a tree become smaller but more numerous as they extend from the trunk.</p><h3 id="1-7-5-Example-Partitions"><a href="#1-7-5-Example-Partitions" class="headerlink" title="1.7.5 Example: Partitions"></a>1.7.5 Example: Partitions</h3><h2 id="Project-1-The-Game-of-Hog"><a href="#Project-1-The-Game-of-Hog" class="headerlink" title="Project 1: The Game of Hog"></a>Project 1: The Game of Hog</h2><h1 id="Champter-2-Building-Abstractions-with-Data"><a href="#Champter-2-Building-Abstractions-with-Data" class="headerlink" title="Champter 2: Building Abstractions with Data"></a>Champter 2: Building Abstractions with Data</h1><h2 id="2-1-Introduction"><a href="#2-1-Introduction" class="headerlink" title="2.1 Introduction"></a>2.1 Introduction</h2><h3 id="2-1-1-Native-Data-Types"><a href="#2-1-1-Native-Data-Types" class="headerlink" title="2.1.1 Native Data Types"></a>2.1.1 Native Data Types</h3><p>The built-in <code>type</code> function allows us inspect the class of any value.</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell">&gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">type</span>(2)</span><br>&lt;<span class="hljs-keyword">class</span> &#x27;int&#x27;&gt;<br></code></pre></td></tr></table></figure><p>Native data types have the following properties:</p><ol><li>There are expressions that evaluate to value of native types, called <code>literals</code></li><li>There are built-in functions and operators to manipulate values of native types.</li></ol><p>Python has three native numeric types: integers(int), real numbers(float), and complex numbers(complex).</p><p><code>int</code> objects represent integers exactly, without any approximation or limits on their size.</p><p><code>float</code> objects have minimum and maximum values.</p><h2 id="2-2-Data-Abstraction"><a href="#2-2-Data-Abstraction" class="headerlink" title="2.2 Data Abstraction"></a>2.2 Data Abstraction</h2><p>Data abstraction isolates how a compound data value is used from the details of how it is constructed.</p><h3 id="2-2-1-Example-Rational-Numbers"><a href="#2-2-1-Example-Rational-Numbers" class="headerlink" title="2.2.1 Example: Rational Numbers"></a>2.2.1 Example: Rational Numbers</h3><p>Dividing integers produces a <code>float</code> approximation, losing the exact precision of integers.</p><p>A powerful strategy for designing programs: wishful thinking.</p><h3 id="2-2-2-Pairs"><a href="#2-2-2-Pairs" class="headerlink" title="2.2.2 Pairs"></a>2.2.2 Pairs</h3><p>Python provides a compound structure called a <code>list</code>.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;&gt;&gt; <span class="hljs-selector-attr">[10, 20]</span><br><span class="hljs-selector-attr">[10, 20]</span><br></code></pre></td></tr></table></figure><p>Two ways to 使用 the elements in <code>list</code>:</p><ol><li>assignment, 赋值</li><li>element selection operator, 使用 index</li></ol><p>The equivalent function for element selection operator is called <code>getitem</code>.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> getitem</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">getitem(pair, <span class="hljs-number">0</span>)</span><br>10<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">getitem(pair, <span class="hljs-number">1</span>)</span><br>20<br></code></pre></td></tr></table></figure><h3 id="2-2-3-Abstraction-Barriers"><a href="#2-2-3-Abstraction-Barriers" class="headerlink" title="2.2.3 Abstraction Barriers"></a>2.2.3 Abstraction Barriers</h3><p>These functions are called by a higher level and implemented using a lower level of abstraction.</p><p>The fewer functions that depend on a particular representation, the fewer changes are required when one wants to change that representation. 也就是用函数去构建另一个函数.</p><h3 id="2-2-4-The-Properties-of-Data"><a href="#2-2-4-The-Properties-of-Data" class="headerlink" title="2.2.4 The Properties of Data"></a>2.2.4 The Properties of Data</h3><h2 id="2-3-Sequences"><a href="#2-3-Sequences" class="headerlink" title="2.3 Sequences"></a>2.3 Sequences</h2><p>Sequences is a collection of behavious that are shared among several different types of data.</p><ul><li>Length</li><li>Element selection</li></ul><h3 id="2-3-1-Lists"><a href="#2-3-1-Lists" class="headerlink" title="2.3.1 Lists"></a>2.3.1 Lists</h3><p>A list value is a sequence that can have arbitrary length.</p><p>The built-in <code>len</code> function returns the length of a sequence.</p><p>Lists can be added together and multiplied by integer:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;&gt;&gt; <span class="hljs-selector-attr">[2, 7]</span> + digits * <span class="hljs-number">2</span><br><span class="hljs-selector-attr">[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]</span><br></code></pre></td></tr></table></figure><h3 id="2-3-2-Sequence-Iteration"><a href="#2-3-2-Sequence-Iteration" class="headerlink" title="2.3.2 Sequence Iteration"></a>2.3.2 Sequence Iteration</h3><p>The <code>for</code> statement:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">s, value</span>):<br>      <span class="hljs-string">&quot;&quot;&quot;Count the number of occurrences of value in sequence s.&quot;&quot;&quot;</span><br>      total = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> s:<br>          <span class="hljs-keyword">if</span> elem == value:<br>              total = total + <span class="hljs-number">1</span><br>      <span class="hljs-keyword">return</span> total<br><br></code></pre></td></tr></table></figure><p>The <name> will be bound to the last element of the sequence after the <code>for</code> statement is executed.</p><p>The pattern of binding multiple names to multiple values in a fixed-length sequence is called <code>sequence unpacking</code>:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;&gt;&gt; for <span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> y in pairs:<br>      if <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> y:<br>          same_count <span class="hljs-operator">=</span> same_count + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>A <mark>range</mark> is another built-in type of sequence in Python, which represents a range of integers.</p><p>Ranges are created with <code>range</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># Includes 1, but not 10</span><br><span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>Calling the <code>list</code> constructor on a range evaluates to a list:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>))</span><br>[5, 6, 7]<br></code></pre></td></tr></table></figure><p>A common convention is to use a single underscore character for the name in the <code>for</code> header if the name is unused in the suite:</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">&gt;&gt;&gt; for _ in range(<span class="hljs-number">3</span>):<br>        print(<span class="hljs-string">&#x27;Go Bears!&#x27;</span>)<br><br>Go Bears!<br>Go Bears!<br>Go Bears!<br></code></pre></td></tr></table></figure><h3 id="2-3-3-Sequence-Processing"><a href="#2-3-3-Sequence-Processing" class="headerlink" title="2.3.3 Sequence Processing"></a>2.3.3 Sequence Processing</h3><p>List Comprehensions:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">odds = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">[x+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> odds]</span><br>[2, 4, 6, 8, 10]<br></code></pre></td></tr></table></figure><p>The general form is:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">[<span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">expression</span>&gt;</span> for <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span> in <span class="hljs-tag">&lt;<span class="hljs-name">sequence</span> <span class="hljs-attr">expression</span>&gt;</span> if <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">expression</span>&gt;</span>]<br></code></pre></td></tr></table></figure><p><mark>Aggregation</mark>, to aggregate all value in a sequence into a single value.<br><mark>Higher-Order Functions</mark><br><mark>Conventional Names</mark><br>In Python programs, it is more common to use list comprehension directly rather than higher-order functions, but both approaches to sequence processing are widely used.</p><h3 id="2-3-4-Sequence-Abstraction"><a href="#2-3-4-Sequence-Abstraction" class="headerlink" title="2.3.4 Sequence Abstraction"></a>2.3.4 Sequence Abstraction</h3><p><mark>Membership</mark>, A value can be tested for membership in a sequence. 就是看一个元素是否在 list 中. </p><p>Python has two operators <code>in</code> and <code>not in</code>:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">digits</span><br>[1, 8, 2, 8]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">2</span> <span class="hljs-keyword">in</span> digits</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">1828</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> digits</span><br>True<br></code></pre></td></tr></table></figure><p><mark>Slicing</mark>, sequences contain smaller sequences within them. 就是把 list 拆分.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;&gt;&gt; digits<span class="hljs-selector-attr">[0:2]</span><br><span class="hljs-selector-attr">[1, 8]</span><br>&gt;&gt;&gt; digits<span class="hljs-selector-attr">[1:]</span><br><span class="hljs-selector-attr">[8, 2, 8]</span><br></code></pre></td></tr></table></figure><h3 id="2-3-5-Strings"><a href="#2-3-5-Strings" class="headerlink" title="2.3.5 Strings"></a>2.3.5 Strings</h3><p>The constructor <code>str</code>.</p><p>String literals are surrounded by either single or double quotation marks.</p><p>Strings have a length and they support element selection.</p><p>Like lists, strings can also be combined via addtion and multiplication:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"> &gt;&gt;&gt; <span class="hljs-string">&#x27;Berkeley&#x27;</span> + <span class="hljs-string">&#x27;, CA&#x27;</span><br><span class="hljs-string">&#x27;Berkeley, CA&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Shabu &#x27;</span> * <span class="hljs-number">2</span><br><span class="hljs-string">&#x27;Shabu Shabu &#x27;</span><br></code></pre></td></tr></table></figure><p><mark>Membership</mark>, it matches substrings rather than elements:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;here&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Where&#x27;s Waldo?&quot;</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><mark>Multiple Literals</mark>, use triple quoting.<br><mark>String Coerction</mark>, a string can be created from any object in Python by calling the <code>str</code> constructor function.</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">str</span>(<span class="hljs-number">2</span>) + <span class="hljs-string">&#x27; is an element of &#x27;</span> + <span class="hljs-title">str</span>(<span class="hljs-variable">digits</span>)</span><br><span class="hljs-string">&#x27;2 is an element of [1, 8, 2, 8]&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-6-Trees"><a href="#2-3-6-Trees" class="headerlink" title="2.3.6 Trees"></a>2.3.6 Trees</h3><p>The data abstraction for a <code>tree</code> consists of the constructor <code>tree</code> and theselectors <code>label</code> and <code>branches</code>.</p><p>A tree is well-formed only if it has a root label and all branches are also trees.</p><p>The <code>type</code> function:</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">if</span> <span class="hljs-keyword">type</span>(tree) != list or len(tree) &lt; 1:<br>          return <span class="hljs-type">False</span><br></code></pre></td></tr></table></figure><p><code>tree</code> 是 nested list, 第一个元素为 root&#x2F;label, 后面的为 branches.<br><mark>Patition trees</mark>, </p><h3 id="2-3-7-Linked-Lists"><a href="#2-3-7-Linked-Lists" class="headerlink" title="2.3.7 Linked Lists"></a>2.3.7 Linked Lists</h3><p>A linked list is a pair containing the first element of the sequence and the rest of the sequence. The second element is also a linked list.</p><p>Linked list have recursive structure: the rest of a linked list is a linked list or ‘empty’. 这个 ‘empty’ 是字符串 ‘empty’.</p><h2 id="2-4-Mutable-Data"><a href="#2-4-Mutable-Data" class="headerlink" title="2.4 Mutable Data"></a>2.4 Mutable Data</h2><p>One powerful technique for creating modular programs is to incorporate data that may change state over time.</p><p>Adding state to data is a central ingredient of a paradigm called object-oriented programming.</p><h3 id="2-4-1-The-Object-Metaphor"><a href="#2-4-1-The-Object-Metaphor" class="headerlink" title="2.4.1 The Object Metaphor"></a>2.4.1 The Object Metaphor</h3><p>The distinguish between functions and data: functions performed operations and data were operated upon.</p><p>Objects combine data values with behavior.</p><p>A class represents a kind of value. Individual dates are called instances of that class.</p><p>Objects have <mark>attributes</mark>, which are named values that are part of the object. We use dot notation to designated an attribute of an object.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">expression</span>&gt;</span>.<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Objects also have <mark>methods</mark>, which are function-valued attributes.</p><p>In fact, all values in Python are objects. That is, all values have behavior and attributes. They act like the values they represent.</p><h3 id="2-4-2-Sequence-Objects"><a href="#2-4-2-Sequence-Objects" class="headerlink" title="2.4.2 Sequence Objects"></a>2.4.2 Sequence Objects</h3><p>Instances of primitive built-in values such as numbers are immutable. The values themsleves cannot change over the course of program execution.</p><p>Mutable objects are used to represent values that change over time.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">  &gt;</span><span class="language-bash">&gt;&gt; suits.pop()             <span class="hljs-comment"># Remove and return the final element</span></span><br>&#x27;myriad&#x27;<br><span class="hljs-meta prompt_">  &gt;</span><span class="language-bash">&gt;&gt; suits.remove(<span class="hljs-string">&#x27;string&#x27;</span>)  <span class="hljs-comment"># Remove the first element that equals the argument</span></span><br><span class="hljs-meta prompt_">  &gt;</span><span class="language-bash">&gt;&gt; suits.append(<span class="hljs-string">&#x27;cup&#x27;</span>)              <span class="hljs-comment"># Add an element to the end</span></span><br><span class="hljs-meta prompt_">  &gt;</span><span class="language-bash">&gt;&gt; suits.extend([<span class="hljs-string">&#x27;sword&#x27;</span>, <span class="hljs-string">&#x27;club&#x27;</span>])  <span class="hljs-comment"># Add all elements of a sequence to the end</span></span><br></code></pre></td></tr></table></figure><p>当<code>suits = chinese</code> 这里 <code>suits</code> 相当于 <code>chinese</code> 这个列表的引用, 修改 <code>suits</code> 会引起 <code>chinese</code> 的值改变.</p><p>但:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">suits</span> <span class="hljs-operator">=</span> list(chinese)<br></code></pre></td></tr></table></figure><p>就不会将二者联系在一起.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">suits.insert(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Joker&#x27;</span>)  <span class="hljs-comment"># Insert an element at index 2, shifting the rest</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">nest[<span class="hljs-number">0</span>].pop(<span class="hljs-number">2</span>)</span><br>&#x27;Joker&#x27;<br></code></pre></td></tr></table></figure><p>To test whether two objects are the same, Python includes two comparison operator, called <mark>is</mark> and <mark>is not</mark>, that test whether two expressions in fact evaluate to the identical object.</p><p>Two onjects are identical if they are equal in their current value, and any change to one will always be reflected in the other.</p><p>区分 <code>==</code> 和 <code>is</code>.</p><p><mark>Tuples</mark><br>An instance of the built-in <code>tuple</code> type, is an immutable sequence. 使用 parentheses.</p><p>tuple也是 finite length and support element selection:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">code = (<span class="hljs-string">&quot;up&quot;</span>, <span class="hljs-string">&quot;up&quot;</span>, <span class="hljs-string">&quot;down&quot;</span>, <span class="hljs-string">&quot;down&quot;</span>) + (<span class="hljs-string">&quot;left&quot;</span>, <span class="hljs-string">&quot;right&quot;</span>) * <span class="hljs-number">2</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(code)</span><br>8<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">code[<span class="hljs-number">3</span>]</span><br>&#x27;down&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">code.count(<span class="hljs-string">&quot;down&quot;</span>)</span><br>2<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">code.index(<span class="hljs-string">&quot;left&quot;</span>)</span><br>4<br></code></pre></td></tr></table></figure><p>While it is not possible to change which elements are in a tuple, it is possible to change the value of a mutable element contained within a tuple.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">nest = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-selector-attr">[30, 40]</span>)<br><span class="hljs-number">2</span>nest<span class="hljs-selector-attr">[2]</span><span class="hljs-selector-class">.pop</span>()<br></code></pre></td></tr></table></figure><h3 id="2-4-3-Dictionaries"><a href="#2-4-3-Dictionaries" class="headerlink" title="2.4.3 Dictionaries"></a>2.4.3 Dictionaries</h3><p>A dictionary contains key-value pairs, where both keys and values are objects.</p><p>The purpose of a dictionary is  to provide an abstraction for storing and retrieving values that are indexed not by consecutive integers, but by descriptive keys.</p><p>Adding new key-value pairs and changing the existing value for a key can both be achieved with assignment statements:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>numerals[<span class="hljs-string">&#x27;I&#x27;</span>] = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>numerals[<span class="hljs-string">&#x27;L&#x27;</span>] = <span class="hljs-number">50</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>numerals<br>&#123;<span class="hljs-string">&#x27;I&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;X&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;L&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;V&#x27;</span>: <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>Dictionaries are unordered collections of key-value pairs.</p><p>The methods <code>keys</code>, <code>values</code>, and <code>items</code> all return iterable values.</p><p>A list of key-value pairs can be converted into a dictionary by calling the <code>dict</code> constructor function:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;&gt;&gt; <span class="hljs-title function_">dict</span>(<span class="hljs-params">[(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">16</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">25</span>)]</span>)<br>&#123;<span class="hljs-number">3</span>: <span class="hljs-number">9</span>, <span class="hljs-number">4</span>: <span class="hljs-number">16</span>, <span class="hljs-number">5</span>: <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><p>Restrictions:</p><ul><li>A key of a dictionary cannot be or contain a mutable value.</li><li>There can be at most one value for a given key.</li></ul><p>A  useful method implemented by dictionaries is get, which returns either the value for a key, if the key is present, or a default value. The arguments to get are the key and the default value.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">numerals.get(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0</span>)</span><br>0<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">numerals.get(<span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-number">0</span>)</span><br>5<br></code></pre></td></tr></table></figure><p>Dictionaries also have a comprehension syntax analogous to those of lists. A key expression and a value expression are separated by a colon. Evaluating a dictionary comprehension creates a new dictionary object.</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;&gt;&gt; &#123;<span class="hljs-keyword">x</span>: <span class="hljs-keyword">x</span>*<span class="hljs-keyword">x</span> for <span class="hljs-keyword">x</span> in range(<span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">6</span>)&#125;<br>&#123;<span class="hljs-number">3</span>: <span class="hljs-number">9</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span>: <span class="hljs-number">16</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span>: <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-4-Local-State"><a href="#2-4-4-Local-State" class="headerlink" title="2.4.4 Local State"></a>2.4.4 Local State</h3><p>Lists and dictionaries have local state: they are changing values that have some particular contents at any point in the execution of a program.</p><p>The <code>nonlocal</code> statement indicates that the name appears somewhere in the environment other than the first(local) frame or the last(global) frame. 也就是说, 假如有个<code>test</code>变量在这个函数之外已经被定义了, 然而要在这个函数里面修改这个<code>test</code>的值, 如果<code>nonlocal test</code>, 那么这个<code>test</code>就不是函数里面的局部变量,而是外面那个.</p><p><code>nonlocal</code>用于声明外部函数的局部变量.</p><p>high-order function, 就是把需要多个参数的一个函数拆分为, 每次只需要一个参数的迭代函数.</p><p>Assignment has a dual role: they either created new bindings or re-bound existing names.</p><p>Python has an unusual restriction regarding the lookup of names: within the body of a function, all instances of a name must refer to the same frame.</p><p>Adding a <code>nonlocal</code> statement can correct the <code>UnboundLocalError: local variable &#39;balance&#39; referenced before assignment</code> error.</p><h3 id="2-4-5-The-Benefits-of-Non-Local-Assignment"><a href="#2-4-5-The-Benefits-of-Non-Local-Assignment" class="headerlink" title="2.4.5 The Benefits of Non-Local Assignment"></a>2.4.5 The Benefits of Non-Local Assignment</h3><h3 id="2-4-6-The-Cost-of-Non-Local-Assignment"><a href="#2-4-6-The-Cost-of-Non-Local-Assignment" class="headerlink" title="2.4.6 The Cost of Non-Local Assignment"></a>2.4.6 The Cost of Non-Local Assignment</h3><p>Our values did not change, only our names and bindings changed.</p><p>We must be very careful to understand the effect of a change on other names that might refer to thos  values.</p><p><mark>Only function calls</mark> can introduce new frames.</p><h3 id="2-4-7-Implementing-Lists-and-Dictionaries"><a href="#2-4-7-Implementing-Lists-and-Dictionaries" class="headerlink" title="2.4.7 Implementing Lists and Dictionaries"></a>2.4.7 Implementing Lists and Dictionaries</h3><p>Two empty lists are not identical values.</p><p>A general pattern in programming: the function is a dispatch function and its arguments are first a message, followed by additional arguments to parameterize that method.</p><p><mark>Linked list</mark>, 是链表.</p><h3 id="2-4-9-Propagating-Constraints"><a href="#2-4-9-Propagating-Constraints" class="headerlink" title="2.4.9 Propagating Constraints"></a>2.4.9 Propagating Constraints</h3><p>Mutable data allows us to simulate systems with change, but also allows us to build new kinds of abstractions.</p><p>A <mark>connector</mark> is an object that “holds” a value and may participate in one or more constraints. </p><h2 id="2-5-Object-Oriented-Programming"><a href="#2-5-Object-Oriented-Programming" class="headerlink" title="2.5 Object-Oriented Programming"></a>2.5 Object-Oriented Programming</h2><p>Objects have local state that is not directly accessible from the global environment.</p><p>Each objects bundles together local state and behavior in a way that abstracts the complexity of both.</p><p>Every object also has a type, called its <code>class</code>.</p><h3 id="2-5-1-Objects-and-Classes"><a href="#2-5-1-Objects-and-Classes" class="headerlink" title="2.5.1 Objects and Classes"></a>2.5.1 Objects and Classes</h3><p>A class serves as a template for all objects whose type is that class.</p><p>Every object is an instance of some particular class.</p><p>The syntax in Python for instantiating a class is identical to the syntax of calling a function:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-variable">a</span> = <span class="hljs-function"><span class="hljs-title">Account</span>(<span class="hljs-string">&#x27;Kirk&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>The attributes specific tot a particular object, as opposed to all objects of a class, are called <mark>instance attributes</mark>. Instance attributes may also be called field, properties, or instance variable.</p><p>Functions that operate on the object or perform object-specific computations are called <mark>methods</mark>. Methods are invoked on a particular object.</p><h3 id="2-5-2-Defining-Classes"><a href="#2-5-2-Defining-Classes" class="headerlink" title="2.5.2 Defining Classes"></a>2.5.2 Defining Classes</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> &lt;<span class="hljs-symbol">name</span>&gt;:<br>    &lt;<span class="hljs-symbol">suite</span>&gt;<br></code></pre></td></tr></table></figure><p>The method that initializes objects has a special name in Python, <code>_init_</code>, and is called the <em>constructor</em> for the class.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt;&gt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>:<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, account_holder</span>):<br>          <span class="hljs-variable language_">self</span>.balance = <span class="hljs-number">0</span><br>          <span class="hljs-variable language_">self</span>.holder = account_holder<br></code></pre></td></tr></table></figure><p>第一个<code>self</code>参数是 bound to the newly created object. 使用<code>self</code>是一个 convention.</p><p>第二个参数是我们传入的.</p><p>Object identity is compared using the <code>is</code> and <code>is not</code> operators.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> a<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> b<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>Binding an object to a new name using assignment does not create a new object:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">c = a</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">c <span class="hljs-keyword">is</span> a</span><br>True<br></code></pre></td></tr></table></figure><p>Methods’definition:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>:<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, account_holder</span>):<br>          self.balance = <span class="hljs-number">0</span><br>          self.holder = account_holder<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">deposit</span>(<span class="hljs-params">self, amount</span>):<br>          self.balance = self.balance + amount<br>          <span class="hljs-keyword">return</span> self.balance<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">withdraw</span>(<span class="hljs-params">self, amount</span>):<br>          <span class="hljs-keyword">if</span> amount &gt; self.balance:<br>              <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Insufficient funds&#x27;</span><br>          self.balance = self.balance - amount<br>          <span class="hljs-keyword">return</span> self.balance<br></code></pre></td></tr></table></figure><p>注意都有<code>self</code> 参数.</p><h3 id="2-5-3-Message-Passing-and-Dot-Expressions"><a href="#2-5-3-Message-Passing-and-Dot-Expressions" class="headerlink" title="2.5.3 Message Passing and Dot Expressions"></a>2.5.3 Message Passing and Dot Expressions</h3><p>Dot notation is a syntactic feature of Python that formalizes the message passing metaphor.</p><p><em>Dot expression</em>, consists of an expression, a dot, and a name.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">expression</span>&gt;</span> . <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span><br></code></pre></td></tr></table></figure><p>The built-in function <code>getattr</code> will return an attribute for an object by name:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">getattr</span>(spock_account, <span class="hljs-string">&#x27;balance&#x27;</span>)</span><br>10<br></code></pre></td></tr></table></figure><p>To test whether an object has a named attribute with <code>hasattr</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(spock_account, <span class="hljs-string">&#x27;deposit&#x27;</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><em>Methods and function</em>. WWhen a method is invoked on an object, that object is implicitly passed as the first argument to the method. As a result, the object is bound to the parameter <code>self</code>.</p><p>We can call <code>deposit</code>(example in the text) in two ways: as a function and as a bound method.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">Account.deposit(spock_account, <span class="hljs-number">1001</span>)  <span class="hljs-comment"># The deposit function takes 2 arguments</span></span><br>1011<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spock_account.deposit(<span class="hljs-number">1000</span>)           <span class="hljs-comment"># The deposit method takes 1 argument</span></span><br>2011<br></code></pre></td></tr></table></figure><p>也就是说, 使用 dot operator 是自动传入<code>self</code>参数.</p><p><em>Naming Conventions</em>, 首字母大写.</p><p>Python’s convention dictates that if an attribute name starts with an underscore, it should only be accessed within methods of the class itself, rather than by users of the class.</p><h3 id="2-5-4-Class-Attributes"><a href="#2-5-4-Class-Attributes" class="headerlink" title="2.5.4 Class Attributes"></a>2.5.4 Class Attributes</h3><p>Some attribute values are shared across all objects of a given class. Such attributes are associated with the class itself, rather than any individual instance of the class. 也就是说这个 attribute 是和整个 class 关联在一起的. 使用class改变. <mark>class attributes</mark> may also be called class variables or static variables.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">Account.interest = <span class="hljs-number">0.05</span>  <span class="hljs-comment"># changing the class attribute</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spock_account.interest     <span class="hljs-comment"># changes instances without like-named instance attributes</span></span><br>0.05<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">kirk_account.interest     <span class="hljs-comment"># but the existing instance attribute is unaffected</span></span><br>0.08<br></code></pre></td></tr></table></figure><p>分有 class attribute 和 instance attribute.</p><p>Instance attributes are found before class attributes, just as local names have priority over global in an environment.</p><h3 id="2-5-5-Inheritance"><a href="#2-5-5-Inheritance" class="headerlink" title="2.5.5 Inheritance"></a>2.5.5 Inheritance</h3><p>Two classes may have similar attributes, but one represents a special case of the othor.</p><p>The terms <mark>parent class</mark> and superclass are also used for the base class, while <mark>child class</mark> is also used for the subclass.</p><h3 id="2-5-6-Using-Inheritance"><a href="#2-5-6-Using-Inheritance" class="headerlink" title="2.5.6 Using Inheritance"></a>2.5.6 Using Inheritance</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-symbol">CheckingAccount</span>(<span class="hljs-symbol">Account</span>):<br></code></pre></td></tr></table></figure><p>Placing an expression that evaluates to the base class in parentheses after the class name. subclass 可以覆盖 superclass 的 attributes.</p><p>To look up a name in a class:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span> If <span class="hljs-keyword">it</span> names <span class="hljs-keyword">an</span> attribute <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> class, <span class="hljs-literal">return</span> <span class="hljs-keyword">the</span> attribute <span class="hljs-built_in">value</span>.<br><span class="hljs-number">2.</span> Otherwise, look up <span class="hljs-keyword">the</span> name <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> base class, <span class="hljs-keyword">if</span> there is <span class="hljs-literal">one</span>.<br></code></pre></td></tr></table></figure><p>An <mark>object interface</mark> is a collection of attributes and conditions on those attributes.</p><h3 id="2-5-7-Multiple-Inheritance"><a href="#2-5-7-Multiple-Inheritance" class="headerlink" title="2.5.7 Multiple Inheritance"></a>2.5.7 Multiple Inheritance</h3><p>Python supports the concept of a subclass inheriting attributes from multiple base classes, a language feature called <mark>multiple inheritance</mark>. 也就是说从多个 class 中继承.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-symbol">AsSeenOnTVAccount</span>(<span class="hljs-symbol">CheckingAccount, <span class="hljs-symbol">SavingsAccount</span></span>):<br></code></pre></td></tr></table></figure><p>在继承图中, Python resolves names from left to right, then upwards.</p><p>Python resolves this name using a recursive algorithm called the C3 Method Resolution Ordering.</p><h3 id="2-5-8-The-Role-of-Objects"><a href="#2-5-8-The-Role-of-Objects" class="headerlink" title="2.5.8 The Role of Objects"></a>2.5.8 The Role of Objects</h3><p>The Python object system is designed to make data abstraction and message passing both convenient and flexible.</p><h2 id="2-6-Implementing-Classes-and-Objects"><a href="#2-6-Implementing-Classes-and-Objects" class="headerlink" title="2.6 Implementing Classes and Objects"></a>2.6 Implementing Classes and Objects</h2><p>Programs can be object-oriented, even in programming languages that do not have a built-in object system.</p><h3 id="2-6-1-Instances"><a href="#2-6-1-Instances" class="headerlink" title="2.6.1 Instances"></a>2.6.1 Instances</h3><p>An instance has named attributes, such as the balance of an account, which can be set and retrieved.</p><h3 id="2-6-2-Classes"><a href="#2-6-2-Classes" class="headerlink" title="2.6.2 Classes"></a>2.6.2 Classes</h3><p>A class is also an object, both in Python’s object system and the system we are implementing here.</p><p>In Python, classes do have classes, almost all classes share the same class, called <code>type</code>.</p><h2 id="2-7-Object-Abstraction"><a href="#2-7-Object-Abstraction" class="headerlink" title="2.7 Object Abstraction"></a>2.7 Object Abstraction</h2><p>A central concept in object abstraction is a <mark>generic function</mark>, which is a function that can accept values of multiple different types.</p><p>Three different techniques for implementing generic functions:</p><ul><li>shared interfaces</li><li>type dispatching</li><li>type coercion</li></ul><h3 id="2-7-1-String-Conversion"><a href="#2-7-1-String-Conversion" class="headerlink" title="2.7.1 String Conversion"></a>2.7.1 String Conversion</h3><p>Python simulates that all objects should produce two different string representations:</p><ul><li>humen-interpretable text</li><li>Python-interpretable expression<br>The constructor <code>str</code> returns a human-readable string. The <code>repr</code> function returns a Python expression that evaluates to an equal object.<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tues = date(<span class="hljs-number">2011</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">repr</span>(tues)</span><br>&#x27;datetime.date(2011, 9, 12)&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">str</span>(tues)</span><br>&#x27;2011-09-12&#x27;<br></code></pre></td></tr></table></figure>The <code>repr</code> function always invokes a method called <code>_repr_</code> on its argument:<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&gt;&gt;&gt; tues.__repr__()<br>&#x27;datetime.date(<span class="hljs-number">2011</span>, 9, 12)&#x27;<br></code></pre></td></tr></table></figure>The <code>str</code> function always invokes a method called <code>_str_</code> on its argument:<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&gt;&gt;&gt; tues.__str__()<br>&#x27;<span class="hljs-number">2011-09-12</span>&#x27;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-7-2-Special-Methods"><a href="#2-7-2-Special-Methods" class="headerlink" title="2.7.2 Special Methods"></a>2.7.2 Special Methods</h3><p>In Python, certain special names are invoked by the Python interpreter in special circumstances. For example, the <code>_init_</code> method of a class is automatically invoked whenever an object is constructed.</p><p>定义<code>_bool_</code>来判断一个object的 true or false.</p><p>The <code>len</code> function invokes the <code>_len_</code> method of its argument to determine its length.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">&#x27;Go Bears!&#x27;</span>._len_()</span><br>9<br></code></pre></td></tr></table></figure><p>Python uses a sequence’s length to determine its truth value, if it does not provide a <code>_bool_</code> method. Empty sequences are false, while non-empty sequences are true:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>([])<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;Go Bears!&#x27;</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>The <code>_getitem_</code> method is invoked by the element selection operator, but it can also be invoked directly:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Go Bears!&#x27;</span>[<span class="hljs-number">3</span>]<br><span class="hljs-string">&#x27;B&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Go Bears!&#x27;</span>.__getitem__(<span class="hljs-number">3</span>)<br><span class="hljs-string">&#x27;B&#x27;</span><br></code></pre></td></tr></table></figure><p>Using <code>_call_</code> method we can define a class that behaves like functions:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt;&gt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adder</span>(object):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, n</span>):<br>            <span class="hljs-variable language_">self</span>.n = n<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, k</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.n + k<br><br>&gt;&gt;&gt; add_three_obj = Adder(<span class="hljs-number">3</span>)<br>&gt;&gt;&gt; add_three_obj(<span class="hljs-number">4</span>)<br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="2-7-3-Multiple-Representations"><a href="#2-7-3-Multiple-Representations" class="headerlink" title="2.7.3 Multiple Representations"></a>2.7.3 Multiple Representations</h3><p>How numbers can be added or multiplied is abstracted by the method names add and mul:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt;&gt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>:<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, other</span>):<br>          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.add(other)<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, other</span>):<br>          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.mul(other)<br></code></pre></td></tr></table></figure><p><mark>Special method names</mark><br>和行为挂钩, 比如:<code>_add_</code> 和 <code>+</code> 相关, 做<code>+</code>运算时会自动调用<code>_add_</code>.</p><p>An <mark>interface</mark> is a set of shared attribute names, along with a specification of their behavior.</p><p>The <code>@property</code> decorator allows functions to be called without call expression syntax. 也就是调用 method 时后面不用加括号.</p><p>Multiple representations of data, 也就是一种数据用多种表示方法.</p><h3 id="2-7-4-Generic-Functions"><a href="#2-7-4-Generic-Functions" class="headerlink" title="2.7.4 Generic Functions"></a>2.7.4 Generic Functions</h3><p>Generic functions are methods or functions that apply to arguments of different types.</p><p>The built-in function <code>isinstance</code> takes an object and a class. It returns true if the object has a class that either is or inherits from the given class.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">c = ComplexRI(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">isinstance</span>(c, ComplexRI)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">isinstance</span>(c, Complex)</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">isinstance</span>(c, ComplexMA)</span><br>False<br></code></pre></td></tr></table></figure><p>使用 <code>type_tag</code> attribute.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">Rational.type_tag = <span class="hljs-string">&#x27;rat&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">Complex.type_tag = <span class="hljs-string">&#x27;com&#x27;</span></span><br></code></pre></td></tr></table></figure><h4 id="Coercion"><a href="#Coercion" class="headerlink" title="Coercion"></a>Coercion</h4><p>Often the different data types are not completely independent, and there may be ways by which objects of one type may be viewed as being of another type. This process is called <mark>coercion</mark>.</p><p>Here is a typical coercion function, which transforms a rational number to a complex number with zero imaginary part:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&gt;&gt;&gt; def rational<span class="hljs-constructor">_to_complex(<span class="hljs-params">r</span>)</span>:<br>        return <span class="hljs-constructor">ComplexRI(<span class="hljs-params">r</span>.<span class="hljs-params">numer</span><span class="hljs-operator">/</span><span class="hljs-params">r</span>.<span class="hljs-params">denom</span>, 0)</span><br></code></pre></td></tr></table></figure><p>It is not generally possible to coerce an arbitrary data object of each type into all other types.</p><p>This coercion scheme has some advantages over the method of defining explicit cross-type operations.</p><p>Although we still need to write coercion functions to relate the types, we need to write only one function for each pair of types rather than a different function for each set of types and each generic operation.</p><p>Some more sophisticeted coercion schemes do nut just try to coerce one type into another, but instead may try to coerce two different types each into a third common type.</p><h2 id="2-8-Efficiency"><a href="#2-8-Efficiency" class="headerlink" title="2.8 Efficiency"></a>2.8 Efficiency</h2><h3 id="2-8-1-Measuring-Efficiency"><a href="#2-8-1-Measuring-Efficiency" class="headerlink" title="2.8.1 Measuring Efficiency"></a>2.8.1 Measuring Efficiency</h3><p>Inspecting how many times <code>fib</code> is called:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">f</span>):<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">counted</span>(<span class="hljs-params">*args</span>):<br>          counted.call_count += <span class="hljs-number">1</span><br>          <span class="hljs-keyword">return</span> f(*args)<br>      counted.call_count = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">return</span> counted<br>      &gt;&gt;&gt; fib = count(fib)<br><span class="hljs-meta">&gt;&gt;&gt; </span>fib(<span class="hljs-number">19</span>)<br><span class="hljs-number">4181</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>fib.call_count<br><span class="hljs-number">13529</span><br></code></pre></td></tr></table></figure><h4 id="Space"><a href="#Space" class="headerlink" title="Space"></a>Space</h4><p>The interpreter preserves all active environment and all values and frames referenced by those environments.</p><p>An environment is active if it provides the evaluation context for some expression being evaluated. An environment becomes inactive whenever the function call for which its first frame was ceated finally returns.</p><h3 id="2-8-2-Memoization"><a href="#2-8-2-Memoization" class="headerlink" title="2.8.2 Memoization"></a>2.8.2 Memoization</h3><p>Tree-recursive computational processes can often be made more efficient through memoization.</p><p>A memoized function will store the return value for any arguments it has previously received. 就是以前计算过的值在 recursive computation 中不会被计算第二次.</p><h3 id="2-8-3-Orders-of-Growth"><a href="#2-8-3-Orders-of-Growth" class="headerlink" title="2.8.3 Orders of Growth"></a>2.8.3 Orders of Growth</h3><h2 id="2-9-Recursive-Objects"><a href="#2-9-Recursive-Objects" class="headerlink" title="2.9 Recursive Objects"></a>2.9 Recursive Objects</h2><p>Objects can have other objects as attribute values. When an object of some class has an attribute value of that same class, it is a recursive object.</p><h3 id="2-9-1-Linked-List-Class"><a href="#2-9-1-Linked-List-Class" class="headerlink" title="2.9.1 Linked List Class"></a>2.9.1 Linked List Class</h3><p>The empty list is a special case of a linked list that has no first element or rest.</p><p>A linked list is a sequence: it has a finite length and supports element selection by index.</p><p>These bulit-in functions invoke special method names of a class: length is computed by <code>_len_</code> and element selection is computed by <code>_getitem_</code>.</p><h3 id="2-9-3-Sets"><a href="#2-9-3-Sets" class="headerlink" title="2.9.3 Sets"></a>2.9.3 Sets</h3><p>Sets are unordered collections, and so the printed ordering may differ from the element ordering in the set literal.</p><p>Python sets support a vatiety of operations, including membership tests, length computation, and the standard set operations of union and intersection.</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">3</span> <span class="hljs-keyword">in</span> s</span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(s)</span><br>4<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s.union(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;)</span><br>&#123;1, 2, 3, 4, 5&#125;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s.intersection(&#123;<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;)</span><br>&#123;3, 4&#125;<br><br></code></pre></td></tr></table></figure><p>Sets comparison:</p><ul><li>isdisjoint</li><li>issubset</li><li>issuperset<br>Mutable, change one element at a time:</li><li>add</li><li>remove</li><li>discard</li><li>pop<br>Multi-element mutations:</li><li>clear</li><li>update</li></ul><h1 id="Chapter-3-Interpreting-Computer-Programs"><a href="#Chapter-3-Interpreting-Computer-Programs" class="headerlink" title="Chapter 3: Interpreting Computer Programs"></a>Chapter 3: Interpreting Computer Programs</h1><h2 id="3-1-Introduction"><a href="#3-1-Introduction" class="headerlink" title="3.1 Introduction"></a>3.1 Introduction</h2><h3 id="3-1-1-Programming-Language"><a href="#3-1-1-Programming-Language" class="headerlink" title="3.1.1 Programming Language"></a>3.1.1 Programming Language</h3><h2 id="3-2-Functional-Programming"><a href="#3-2-Functional-Programming" class="headerlink" title="3.2 Functional Programming"></a>3.2 Functional Programming</h2>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CS143 Notes</title>
    <link href="/2022/07/30/CS143-Notes/"/>
    <url>/2022/07/30/CS143-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="p7-Lexical-Analysis"><a href="#p7-Lexical-Analysis" class="headerlink" title="p7 Lexical Analysis"></a>p7 Lexical Analysis</h1><p>Token classes correspond to sets of strings.</p><p>Identifier: strings of letters of digits, starting with a letter.</p><p>Integer: a non-empty string of digits.</p><p>Keyword:</p><p>Whitespace: a non-empty sequence of blanks, newlines, and tabs.</p><p>Classify program substrings according to role.</p><p>&lt;class,string&gt; 这个东西称为 token.</p><p>如果有一段代码:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span>(<span class="hljs-attribute">i</span>==j)<br>  <span class="hljs-attribute">z</span>=0;<br><span class="hljs-keyword">else</span><br>  <span class="hljs-attribute">z</span>=1;<br></code></pre></td></tr></table></figure><p>在 Lexical Analyser 看来就是:</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-symbol">\t</span>if(i==j)<span class="hljs-symbol">\n</span><span class="hljs-symbol">\t</span><span class="hljs-symbol">\t</span>z=0;<span class="hljs-symbol">\n</span><span class="hljs-symbol">\t</span>else<span class="hljs-symbol">\n</span><span class="hljs-symbol">\t</span><span class="hljs-symbol">\t</span>z=1;<br></code></pre></td></tr></table></figure><p>Often the punctuation marks of the language are in token classes all by themselves.</p><p>连在一起的 whitespace 会被 group 为一个 token.</p><p>An implementation must do two things:</p><ol><li>Recognize substrings corresponding to tokens.<ul><li>The lexemes(the substrings are called lexemes)</li></ul></li><li>Identify the token class of each lexeme.</li></ol><p>&lt;token class, lexeme&gt; – a token,</p><h1 id="p8-Lexical-Analysis-Example"><a href="#p8-Lexical-Analysis-Example" class="headerlink" title="p8 Lexical Analysis Example"></a>p8 Lexical Analysis Example</h1><p>FORTRAN rule: Whitespace is insignificant.</p><p><code>VAR1</code> is the same as <code>VA</code>  <code>R1</code>.</p><p>Lookahead, in order to understand the role of something as we are going left to right.</p><p>One of the goal in the design of lexical system is to minimize the amount of lookahead or bound the amount of lookahead that is required.</p><p>重点:</p><ol><li>The goal is to partition the string. This is implemented by reading left-to-right, recongnizing one token at a time.</li><li>Lookahead may be required to decide where one token ends and the next token begins.</li></ol><h1 id="p9-Regular-Languages"><a href="#p9-Regular-Languages" class="headerlink" title="p9 Regular Languages"></a>p9 Regular Languages</h1><p>Summarize:<br>    - Regular expressions specify regular languages<br>    - Five constructs:<br>        - Two base cases: empty and 1-character strings<br>        - Three compound expressions: union, concatenation, iteration.</p><h1 id="p10-Formal-Languages"><a href="#p10-Formal-Languages" class="headerlink" title="p10 Formal Languages"></a>p10 Formal Languages</h1><p>A formal language is just any set of strings over some alphabet.</p><p>如:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Alphabet</span> <span class="hljs-operator">=</span> English<br>characters<br><br><span class="hljs-attribute">Language</span> <span class="hljs-operator">=</span> English<br>sentences<br><br><span class="hljs-attribute">Alphabet</span> <span class="hljs-operator">=</span> ASCII<br><span class="hljs-attribute">Language</span> <span class="hljs-operator">=</span> C programs<br></code></pre></td></tr></table></figure><p>Meaning function L maps syntax to semantics:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">L</span><span class="hljs-params">(e)</span></span> = M<br></code></pre></td></tr></table></figure><p><mark>Meaning is many to one</mark>, syntax 对 semantic 是多对一。</p><h1 id="p11-Lexical-Specification"><a href="#p11-Lexical-Specification" class="headerlink" title="p11 Lexical Specification"></a>p11 Lexical Specification</h1><p>Whitespace: a non-empty sequences of blanks, newlines, and tabs.</p><h1 id="p12-Lexical-Specification"><a href="#p12-Lexical-Specification" class="headerlink" title="p12 Lexical Specification"></a>p12 Lexical Specification</h1><p>“Maximal Munch”. 取长的 string.</p><p>When there is more than one token class to which a string might belong, 通过优先级，choose the one listed first.</p><p><mark>If no rule matches:</mark><br>Making a <code>Error</code> regex for all strings not in the lexical specification. And put it last in priority.</p><p><mark>Summarise</mark><br>Regular expressions are a concise notation for string patterns.</p><p>Use in lexical analysis requires small extensions:<br>    - To resolve ambiguities: match as long as possible; highest priority match<br>    - To handle errors</p><h1 id="p13-Finite-Automata"><a href="#p13-Finite-Automata" class="headerlink" title="p13 Finite Automata"></a>p13 Finite Automata</h1>]]></content>
    
    
    <categories>
      
      <category>Compiler Theory</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Using bang in Unix to repeat command</title>
    <link href="/2022/07/29/Using-bang-in-Unix-to-repeat-command/"/>
    <url>/2022/07/29/Using-bang-in-Unix-to-repeat-command/</url>
    
    <content type="html"><![CDATA[<p>举个例子:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>!l<br></code></pre></td></tr></table></figure><p>会重复上一个以<code>l</code>开头的命令。</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cool language Notes</title>
    <link href="/2022/07/29/Cool-language-Notes/"/>
    <url>/2022/07/29/Cool-language-Notes/</url>
    
    <content type="html"><![CDATA[<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">i : <span class="hljs-type">IO</span> &lt;- <span class="hljs-keyword">new</span> IO;<br></code></pre></td></tr></table></figure><p><code>new</code> 用于创建 object , 后一个<code>IO</code>是 object的类型。<code>&lt;-</code> 似乎是赋值的意思。</p><p>用<code>let ...  in</code>创建local variable.</p><p><code>if then else</code> statement.</p><p>The last statement of the block is the value of the block. 这个和perl中一样.</p><p><code>=</code> 在COOL中是比较operator.</p><p>The special value <code>void</code> is a member of all types and is used as the default initialzation for variable. There is no name for void.</p><p><code>isvoid</code> expr, which tests whether a value is void.</p><p>A dispatch to or case on void generates a runtime error.</p><p>A statement o  an expression block has to be included in its own set of curly braces. 如:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span>(): Int &#123; &#123; <span class="hljs-selector-tag">i</span><span class="hljs-selector-class">.out_string</span>(&quot;Hello World!&quot;); <span class="hljs-number">1</span>; &#125; &#125;;<br></code></pre></td></tr></table></figure><p>第一个 curly braces is the body of the <code>main</code> program, and the second braces means a block of expression.</p><h1 id="6-Method"><a href="#6-Method" class="headerlink" title="6 Method"></a>6 Method</h1><p>The type of the method body must conform to th  declared return type.</p><h1 id="7-Expressions"><a href="#7-Expressions" class="headerlink" title="7 Expressions"></a>7 Expressions</h1><h2 id="7-2-Identifiers"><a href="#7-2-Identifiers" class="headerlink" title="7.2 Identifiers"></a>7.2 Identifiers</h2><p>It is an error to assign to <code>self</code> or bind <code>self</code> in a <code>let</code>, a <code>case</code>, or as a formal parameter.</p><p>It is also illegal to have attributes named self.</p><h2 id="7-4-Dispatch"><a href="#7-4-Dispatch" class="headerlink" title="7.4 Dispatch"></a>7.4 Dispatch</h2><p>就是 method call.</p><p>The value of the expression is the value returned by the method invocation.</p><p>Inferring accurate static types for dispatch expression is what justifies including SELF_TYPE in the Cool type system.</p><p>Three ways to dispatch:</p><pre><code class="hljs">- &lt;expr&gt;.&lt;id&gt;(&lt;expr&gt;,...,&lt;expr&gt;)- &lt;id&gt;(&lt;expr&gt;,...,&lt;expr&gt;)- &lt;expr&gt;@&lt;type&gt;.id(&lt;expr&gt;,...,&lt;expr&gt;)</code></pre><h2 id="7-5-Conditionals"><a href="#7-5-Conditionals" class="headerlink" title="7.5 Conditionals"></a>7.5 Conditionals</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> &lt;<span class="hljs-built_in">expr</span>&gt; <span class="hljs-keyword">then</span> &lt;<span class="hljs-built_in">expr</span>&gt; <span class="hljs-keyword">else</span> &lt;<span class="hljs-built_in">expr</span>&gt; <span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>The predicate is evaluated first, if the predicate is true, then the <code>then</code> branch is evaluated. If the predicate is false, then the <code>else</code> branch is evaluated.</p><h2 id="7-6-Loops"><a href="#7-6-Loops" class="headerlink" title="7.6 Loops"></a>7.6 Loops</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> &lt;<span class="hljs-built_in">expr</span>&gt; loop &lt;<span class="hljs-built_in">expr</span>&gt; pool<br></code></pre></td></tr></table></figure><p>If the predicate is false, the loop terminates and <code>void</code> is returned.</p><h2 id="7-7-Blocks"><a href="#7-7-Blocks" class="headerlink" title="7.7 Blocks"></a>7.7 Blocks</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&#123; <span class="hljs-tag">&lt;<span class="hljs-name">expr</span>&gt;</span>; ... <span class="hljs-tag">&lt;<span class="hljs-name">expr</span>&gt;</span>; &#125;<br></code></pre></td></tr></table></figure><p>The static type of a block is the static type of the last expression.</p><p><mark>Semi-colons</mark> are used as terminators in lists of expressions and not as expression separators. Semi-colons also terminate other Cool constructs. 这句话的意思是，每一个 semicolon 表示一个 expression 的结束，然后会按顺序执行下一个 expression.</p><p>Block 里面的每一个 expression 都要有 semicolon, body 里面只有一个 expression 且不用 semicolon.</p><h2 id="7-8-Let"><a href="#7-8-Let" class="headerlink" title="7.8 Let"></a>7.8 Let</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">let</span> <span class="hljs-symbol">&lt;id1&gt;</span>: <span class="hljs-symbol">&lt;type1&gt;</span> [ &lt;- <span class="hljs-symbol">&lt;expr&gt;</span> ], ..., <span class="hljs-symbol">&lt;idn&gt;</span>: <span class="hljs-symbol">&lt;typen&gt;</span> [ &lt;- <span class="hljs-symbol">&lt;exprn&gt;</span> ] in <span class="hljs-symbol">&lt;expr&gt;</span><br></code></pre></td></tr></table></figure><p>The value of the let is the value of the body.</p><p>If an identifier is defined multiple times in a let, later bindings hide earlier ones.</p><h2 id="7-9-Case"><a href="#7-9-Case" class="headerlink" title="7.9 Case"></a>7.9 Case</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">case</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">expr0</span>&gt;</span> of </span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">id1</span>&gt;</span>: </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">type1</span>&gt;</span> =&gt; </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">expr1</span>&gt;</span>;</span><br><span class="language-xml"></span><br><span class="language-xml">    ...</span><br><span class="language-xml"></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">idn</span>&gt;</span>: </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">typen</span>&gt;</span> =&gt; </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">exprn</span>&gt;</span>;</span><br><span class="language-xml">esac</span><br></code></pre></td></tr></table></figure><p>The result of the case is the value of <exprk>.</p><p><code>case</code> 是根据<code>&lt;expr0&gt;</code> 和 <code>&lt;idn&gt;</code> 的 <code>type</code> 来决定是否执行。</p><h2 id="7-10-New"><a href="#7-10-New" class="headerlink" title="7.10 New"></a>7.10 New</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">isvoid <span class="hljs-built_in">expr</span><br></code></pre></td></tr></table></figure><h2 id="7-12-Arithmetic-and-Comparison-Operations"><a href="#7-12-Arithmetic-and-Comparison-Operations" class="headerlink" title="7.12 Arithmetic and Comparison Operations"></a>7.12 Arithmetic and Comparison Operations</h2><p>Four binary arithmetic operations: +, -, *, &#x2F;.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">expr1 <span class="hljs-tag">&lt;<span class="hljs-name">op</span>&gt;</span> expr2<br></code></pre></td></tr></table></figure><p>The static types of the two sub-expression must be <code>Int</code>. The static type of the expression is <code>Int</code>. Cool has only integer division.</p><p>Cool has only three comparison operations: &lt;, &lt;&#x3D;, &#x3D;.</p><p>The expression <code>~&lt;expr&gt;</code> is the integer complement of <expr>.</p><p>The expression <code>not &lt;expr&gt;</code> is the boolean complement of <expr>.</p><h1 id="8-Basic-Classes"><a href="#8-Basic-Classes" class="headerlink" title="8 Basic Classes"></a>8 Basic Classes</h1><h2 id="8-1-Object"><a href="#8-1-Object" class="headerlink" title="8.1 Object"></a>8.1 Object</h2><p>The <code>Object</code> class is the root of the inheritance graph.</p><h2 id="8-2-IO"><a href="#8-2-IO" class="headerlink" title="8.2 IO"></a>8.2 IO</h2><p>A class can make use of the methods in the IO class by inheriting from IO. It is an error to redifine the IO class.</p><h2 id="8-3-Int"><a href="#8-3-Int" class="headerlink" title="8.3 Int"></a>8.3 Int</h2><p>The default initilization for variables of type Int is 0(not void).</p><h2 id="8-4-String"><a href="#8-4-String" class="headerlink" title="8.4 String"></a>8.4 String</h2><p>The default initilization for variables of type String is “”(not void).</p><h2 id="8-5-Bool"><a href="#8-5-Bool" class="headerlink" title="8.5 Bool"></a>8.5 Bool</h2><p>The Bool class provides <code>true</code> and <code>dault</code>. The default initilization for variables of type Bool is false(not void).</p><h1 id="9-Main-Class"><a href="#9-Main-Class" class="headerlink" title="9 Main Class"></a>9 Main Class</h1><p>Every program  must have a class <code>Main</code>. The <code>Main</code> class must have a method <code>main</code> that takes no formal parameters. The <code>main</code> method must be defined in class <code>Main</code>. </p><h1 id="10-Lexical-Structure"><a href="#10-Lexical-Structure" class="headerlink" title="10 Lexical Structure"></a>10 Lexical Structure</h1><p>The lexical units of Cool are integers, type identifiers, object identifiers, special notation, strings, key-words, and white space.</p><h2 id="10-2-Strings"><a href="#10-2-Strings" class="headerlink" title="10.2 Strings"></a>10.2 Strings</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-comment">&quot;This \</span><br><span class="hljs-keyword">is</span> OK<span class="hljs-comment">&quot;</span><br></code></pre></td></tr></table></figure><p>A string may not contain EOF, A string may not contain the null(character \0).</p><h2 id="10-3-Comments"><a href="#10-3-Comments" class="headerlink" title="10.3 Comments"></a>10.3 Comments</h2><p>There are two forms of comments:</p><pre><code class="hljs"> --(*...*)</code></pre><h1 id="11-Cool-Syntax"><a href="#11-Cool-Syntax" class="headerlink" title="11 Cool Syntax"></a>11 Cool Syntax</h1><h1 id="12-Type-Rules"><a href="#12-Type-Rules" class="headerlink" title="12 Type Rules"></a>12 Type Rules</h1><h2 id="12-1-Type-Environments"><a href="#12-1-Type-Environments" class="headerlink" title="12.1 Type Environments"></a>12.1 Type Environments</h2><p>Three parts: a method environment M, an object environment O, and the name of the current class in which the expression appears. The method environment and object environment are both functions(also called mappings).</p><h2 id="12-2-Type-Checking-Rules"><a href="#12-2-Type-Checking-Rules" class="headerlink" title="12.2 Type Checking Rules"></a>12.2 Type Checking Rules</h2><h1 id="13-Operational-Semantics"><a href="#13-Operational-Semantics" class="headerlink" title="13 Operational Semantics"></a>13 Operational Semantics</h1><p>The context has three components:<br>    - an environment<br>    - a store<br>    - a self object</p><h2 id="13-1-Environment-and-the-Store"><a href="#13-1-Environment-and-the-Store" class="headerlink" title="13.1 Environment and the Store"></a>13.1 Environment and the Store</h2><p>An environment is a mapping of variable identifiers to locations.</p><p>To describe the environment:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">E</span> = [a:l1,b:l2]<br></code></pre></td></tr></table></figure><p>This environment maps a to location l1, and b to location l2.</p><p>The store(memory) maps location to values. Intuitively, a store tells us what value is stored in a given memory location.</p><p>A store is similar to an environment:</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">S = [<span class="hljs-function"><span class="hljs-title">l1</span> -&gt;</span> <span class="hljs-number">55</span>, <span class="hljs-function"><span class="hljs-title">l2</span> -&gt;</span> <span class="hljs-number">77</span>]<br></code></pre></td></tr></table></figure><h2 id="13-2-Syntax-for-Cool-Objects"><a href="#13-2-Syntax-for-Cool-Objects" class="headerlink" title="13.2 Syntax for Cool Objects"></a>13.2 Syntax for Cool Objects</h2><p>Every Cool value is an object.</p><h2 id="13-3-Class-definitions"><a href="#13-3-Class-definitions" class="headerlink" title="13.3 Class definitions"></a>13.3 Class definitions</h2><p>Two mappings, called class and implementation, are associated with class definitions.</p><p>The default initializing for a variable or attribute is the default of its type.</p>]]></content>
    
    
    <categories>
      
      <category>Cool</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Compilers Priciples, Techniques, &amp; Tools Notes</title>
    <link href="/2022/07/28/Compilers-Priciples-Techniques-Tools-Notes/"/>
    <url>/2022/07/28/Compilers-Priciples-Techniques-Tools-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1 Introduction"></a>Chapter 1 Introduction</h1><h2 id="1-1-Language-Processors"><a href="#1-1-Language-Processors" class="headerlink" title="1.1 Language Processors"></a>1.1 Language Processors</h2><h3 id="1-1-1-Exercises-for-Section-1-1"><a href="#1-1-1-Exercises-for-Section-1-1" class="headerlink" title="1.1.1 Exercises for Section 1.1"></a>1.1.1 Exercises for Section 1.1</h3><p>编译器和解释器的区别:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">编译器工作时，返回低级的代码，如machine language.<br><br>解释器工作时，产生机器码交给硬件直接执行，然后返回结果.<br></code></pre></td></tr></table></figure><h2 id="1-2-The-Structure-of-a-Compiler"><a href="#1-2-The-Structure-of-a-Compiler" class="headerlink" title="1.2 The Structure of a Compiler"></a>1.2 The Structure of a Compiler</h2><p>Two parts to this mapping: analysis and synthesis. </p><p>The analysis part also collects information about the source program and stores it in a data structure called a <code>symbol table</code>.</p><p>The analysis part is often called the front end of the compiler, the synthesis part is the back end.</p><p>The analysis part <mark>breaks up</mark> the source program into constituent pieces and imposes a grammatical structure on them.</p><p>The synthesis part <mark>constructs</mark> the desired target program.</p><h3 id="1-2-1-Lexical-Analysis"><a href="#1-2-1-Lexical-Analysis" class="headerlink" title="1.2.1 Lexical Analysis"></a>1.2.1 Lexical Analysis</h3><p>For each lexeme, the lexical analyzer produces as output a token of the form:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;token-<span class="hljs-type">name</span>, <span class="hljs-keyword">attribute</span>-<span class="hljs-keyword">value</span>&gt;<br></code></pre></td></tr></table></figure><p>Lexical analysis divides program text into “words” or “tokens”.</p><h3 id="1-2-2-Syntax-Analysis"><a href="#1-2-2-Syntax-Analysis" class="headerlink" title="1.2.2 Syntax Analysis"></a>1.2.2 Syntax Analysis</h3><p>A typical representation is a <mark>syntax tree</mark> in which each interior node represents an operation and the children of the node represent the arguments of the operation.</p><p>The tree shows the order in which the operations in the assignment.</p><h3 id="1-2-3-Semantic-Analysis"><a href="#1-2-3-Semantic-Analysis" class="headerlink" title="1.2.3 Semantic Analysis"></a>1.2.3 Semantic Analysis</h3><p>An important part of semantic snalysis is type checking, where the compiler checks that each operator has matching operands.</p><p>The operator inttofloat, which explicity converts its integer argument into a floating-point number.</p><h3 id="1-2-4-Intermediate-Code-Generation"><a href="#1-2-4-Intermediate-Code-Generation" class="headerlink" title="1.2.4 Intermediate Code Generation"></a>1.2.4 Intermediate Code Generation</h3><p>Syntax trees are a form of intermediate representation.</p><p>The intermediate representation should have two important properties:</p><pre><code class="hljs">- it should be easy to produce- it should be easy to translate into the target machine</code></pre><h3 id="1-2-5-Code-Optimization"><a href="#1-2-5-Code-Optimization" class="headerlink" title="1.2.5 Code Optimization"></a>1.2.5 Code Optimization</h3><p>To improve the intermediate code so that better target code will result.</p><h3 id="1-2-6-Code-Generation"><a href="#1-2-6-Code-Generation" class="headerlink" title="1.2.6 Code Generation"></a>1.2.6 Code Generation</h3><p>The code generator takes as input an intermediate representation of the source program and maps it into the target language.</p><p>The <code>F</code> in each instruction tells us that it deals with floating-point numbers.</p><h3 id="1-2-7-Symbol-Table-Management"><a href="#1-2-7-Symbol-Table-Management" class="headerlink" title="1.2.7 Symbol-Table Management"></a>1.2.7 Symbol-Table Management</h3><p>An essential function of a compiler is to record the variable names used in the source program and collect information about the storage allocated for a name.</p><p>The symbol table is a data structure containing a record for each variable name, with field for the attributes of the name.</p><h3 id="1-2-8-The-Grouping-of-Phases-into-Passes"><a href="#1-2-8-The-Grouping-of-Phases-into-Passes" class="headerlink" title="1.2.8 The Grouping of Phases into Passes"></a>1.2.8 The Grouping of Phases into Passes</h3><h3 id="1-2-9-Compiler-Construction-Tools"><a href="#1-2-9-Compiler-Construction-Tools" class="headerlink" title="1.2.9 Compiler-Construction Tools"></a>1.2.9 Compiler-Construction Tools</h3><h2 id="1-3-The-Evolution-of-Programming-Languages"><a href="#1-3-The-Evolution-of-Programming-Languages" class="headerlink" title="1.3 The Evolution of Programming Languages"></a>1.3 The Evolution of Programming Languages</h2><h3 id="1-3-1-The-Move-to-Higher-level-Language"><a href="#1-3-1-The-Move-to-Higher-level-Language" class="headerlink" title="1.3.1 The Move to Higher-level Language"></a>1.3.1 The Move to Higher-level Language</h3><p>Initially, The instructions in an assembly language were just mnemonic representations of machine instructions. Later, macro instructions were added to assembly languages.</p><p>First-generation languages are the machine languages.</p><p>Second-generation the assembly languages.</p><p>Third-generation the higher-level languages.</p><p>Fourth-generation are languages designed for special application.</p><h3 id="1-3-2-Impact-on-Compilers"><a href="#1-3-2-Impact-on-Compilers" class="headerlink" title="1.3.2 Impact on Compilers"></a>1.3.2 Impact on Compilers</h3><h2 id="1-4-The-Science-of-Building-a-Compiler"><a href="#1-4-The-Science-of-Building-a-Compiler" class="headerlink" title="1.4 The Science of Building a Compiler"></a>1.4 The Science of Building a Compiler</h2><h3 id="1-4-2-The-Science-of-Code-Optimization"><a href="#1-4-2-The-Science-of-Code-Optimization" class="headerlink" title="1.4.2 The Science of Code Optimization"></a>1.4.2 The Science of Code Optimization</h3><h2 id="1-5-Applications-of-Compiler-Technology"><a href="#1-5-Applications-of-Compiler-Technology" class="headerlink" title="1.5 Applications of Compiler Technology"></a>1.5 Applications of Compiler Technology</h2><h3 id="1-5-1-Implementation-of-High-Level-Programming-Languages"><a href="#1-5-1-Implementation-of-High-Level-Programming-Languages" class="headerlink" title="1.5.1 Implementation of High-Level Programming Languages"></a>1.5.1 Implementation of High-Level Programming Languages</h3><p>Optimizing compilers include techniques to improve the performance of generated code, thus offsetting the inefficiency introduced by high-level abstractions.</p><p>The key ideas behind object orientation are:</p><pre><code class="hljs">1. Data abstraction2. Inheritance of properties</code></pre><p>Java has a built-in garbage-collection facility that automatically frees the memory of variable that are no longer in use.</p><h3 id="1-5-2-Optimizations-for-Computer-Architectures"><a href="#1-5-2-Optimizations-for-Computer-Architectures" class="headerlink" title="1.5.2 Optimizations for Computer Architectures"></a>1.5.2 Optimizations for Computer Architectures</h3><p>Two basic techniques:</p><pre><code class="hljs">- parallelism- memory hierarchies</code></pre><h3 id="1-5-4-Program-Translations"><a href="#1-5-4-Program-Translations" class="headerlink" title="1.5.4 Program Translations"></a>1.5.4 Program Translations</h3><h3 id="1-5-5-Software-Productivity-Tools"><a href="#1-5-5-Software-Productivity-Tools" class="headerlink" title="1.5.5 Software Productivity Tools"></a>1.5.5 Software Productivity Tools</h3><h2 id="1-6-Programming-Language-Basics"><a href="#1-6-Programming-Language-Basics" class="headerlink" title="1.6 Programming Language Basics"></a>1.6 Programming Language Basics</h2><h3 id="1-6-1-The-Static-x2F-Dynamic-Distinction"><a href="#1-6-1-The-Static-x2F-Dynamic-Distinction" class="headerlink" title="1.6.1 The Static&#x2F;Dynamic Distinction"></a>1.6.1 The Static&#x2F;Dynamic Distinction</h3><p>If a language uses a policy that allow the compiler to decide an issue, then we say that the language uses a <mark>static</mark> policy or that the issue can be decided at compile time. 意思是需要手动设置吗。</p><p>The scope of declarations. A language uses static scope or lexical scope if it is possible to determine the scope of a declaration by looking only at the program.</p><p>Otherwise, the language uses dynamic scope.</p><p>The compiler to determine the location in memory where the declared variable can be found.</p><h3 id="1-6-2-Environments-and-States"><a href="#1-6-2-Environments-and-States" class="headerlink" title="1.6.2 Environments and States"></a>1.6.2 Environments and States</h3><p>The association of names with locations in memory and then with values can be described by two mappings that change as the program runs. </p><p>The <mark>environment</mark> is a mapping from names to locations in the store.</p><p>The <mark>state</mark> is a mapping from locations in store to their values.</p><h3 id="1-6-4-Explicit-Access-Control"><a href="#1-6-4-Explicit-Access-Control" class="headerlink" title="1.6.4 Explicit Access Control"></a>1.6.4 Explicit Access Control</h3><p>Classes and structures introduce a new scope for their members.</p><h4 id="Declarations-and-Definitions"><a href="#Declarations-and-Definitions" class="headerlink" title="Declarations and Definitions"></a>Declarations and Definitions</h4><p>Declarations tell us about the types of things, while definitions tell us about their values.</p><h3 id="1-6-6-Parameter-Passing-Mechanisms"><a href="#1-6-6-Parameter-Passing-Mechanisms" class="headerlink" title="1.6.6 Parameter Passing Mechanisms"></a>1.6.6 Parameter Passing Mechanisms</h3><p>The strict call-by-value requires that the caller copy the entire actual parameter into the soace belonging to the corresponding formal parameter.</p><h1 id="Chapter-2-A-Simple-Symtax-Directed-Translator"><a href="#Chapter-2-A-Simple-Symtax-Directed-Translator" class="headerlink" title="Chapter 2 A Simple Symtax-Directed Translator"></a>Chapter 2 A Simple Symtax-Directed Translator</h1><h2 id="2-1-Introduction"><a href="#2-1-Introduction" class="headerlink" title="2.1 Introduction"></a>2.1 Introduction</h2><p>A notation in which operators appear after their operands.</p><p>Two forms of intermediate code are:<br>    - abstract syntax trees<br>    - simply syntax trees<br>represents the hierarchical syntactic structure of the source program.</p><p><mark>Three-address code</mark><br>The form:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">x</span><span class="hljs-operator">=</span>y op y<br></code></pre></td></tr></table></figure><p><code>op</code> is a binary operator, y and z are addressed for operands, and x is the address for the result of the operation.</p><h2 id="2-2-Syntax-Definition"><a href="#2-2-Syntax-Definition" class="headerlink" title="2.2 Syntax Definition"></a>2.2 Syntax Definition</h2><p>A grammar naturally describes the hierarchical structure of most programming language constructs.</p><p>Such a rule is called a <mark>production</mark>. In a production, lexical elements like the keyword <code>if</code> and the parentheses are called <mark>terminals</mark>. Variable like <code>expr</code> and <code>stmt</code> represent sequences of terminals and are called <mark>nonterminals</mark>.</p><h3 id="2-2-3-Parse-Trees"><a href="#2-2-3-Parse-Trees" class="headerlink" title="2.2.3 Parse Trees"></a>2.2.3 Parse Trees</h3><p>A <mark>parse tree</mark> pictorially shows how the start symble of a grammar derives a string in the language.</p>]]></content>
    
    
    <categories>
      
      <category>Compiler Theory</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The Elements of Computing System Notes</title>
    <link href="/2022/07/26/The-Elements-of-Computing-System-Notes/"/>
    <url>/2022/07/26/The-Elements-of-Computing-System-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h1><h2 id="Hello-World-Below"><a href="#Hello-World-Below" class="headerlink" title="Hello, World Below"></a>Hello, World Below</h2><h2 id="Nand-to-Tetris"><a href="#Nand-to-Tetris" class="headerlink" title="Nand to Tetris"></a>Nand to Tetris</h2><h2 id="Abstraction-and-Implementation"><a href="#Abstraction-and-Implementation" class="headerlink" title="Abstraction and Implementation"></a>Abstraction and Implementation</h2><p>Abstraction describes what the module does, and implementation describes how it does it.</p><p>The RAM contains billions of registers, yet any of them can be accessed directly.</p><p>The RAM storage and direct-access capabilities will be relized using registers and multiplexers.</p><h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><h2 id="The-Road-Ahead"><a href="#The-Road-Ahead" class="headerlink" title="The Road Ahead"></a>The Road Ahead</h2><h1 id="1-Boolean-Logic"><a href="#1-Boolean-Logic" class="headerlink" title="1 Boolean Logic"></a>1 Boolean Logic</h1><p>Elementary logic gates.</p><p>Nand, Not, And, Or, and Xor.</p><p>Multiplexer and Demultiplexer.</p><h2 id="1-1-Boolean-Algebra"><a href="#1-1-Boolean-Algebra" class="headerlink" title="1.1 Boolean Algebra"></a>1.1 Boolean Algebra</h2><p>A Boolean function is a function that operates on binary inputs and returns binary outputs.</p><p>The name of the Nand operator is shorthand for Not-And.</p><p>The Xor operator–shorthand for exclusive or.</p><p>The Nor gate derives its name from Not-Or.</p><p>Any Boolean function can be realized using Nand gates only.</p><h3 id="Truth-Tables-and-Boolean-Expressions"><a href="#Truth-Tables-and-Boolean-Expressions" class="headerlink" title="Truth Tables and Boolean Expressions"></a>Truth Tables and Boolean Expressions</h3><p>A turth table is often a convenient means for describing some states of nature.</p><p>The ability to simplify a Boolean expression is the first step toward hardware optimization.</p><h2 id="1-2-Logic-Gates"><a href="#1-2-Logic-Gates" class="headerlink" title="1.2 Logic Gates"></a>1.2 Logic Gates</h2><p>Computer scientist don not have to worry about physical artifacts.</p><h3 id="Primitive-and-Composite-Gates"><a href="#Primitive-and-Composite-Gates" class="headerlink" title="Primitive and Composite Gates"></a>Primitive and Composite Gates</h3><p>Any given logic gate can be viewed from two different perspectives:</p><pre><code class="hljs">- internal- external</code></pre><h2 id="1-3-Hardware-Construction"><a href="#1-3-Hardware-Construction" class="headerlink" title="1.3 Hardware Construction"></a>1.3 Hardware Construction</h2><h3 id="1-3-1-Hardware-Description-Language"><a href="#1-3-1-Hardware-Description-Language" class="headerlink" title="1.3.1 Hardware Description Language"></a>1.3.1 Hardware Description Language</h3><p>p42</p>]]></content>
    
    
    <categories>
      
      <category>Compiler Theory</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Using dd command</title>
    <link href="/2022/07/24/Using-dd-command/"/>
    <url>/2022/07/24/Using-dd-command/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiao_yi_xiao/article/details/119325002">rference</a></p><h1 id="首先查找-U-盘设备"><a href="#首先查找-U-盘设备" class="headerlink" title="首先查找 U 盘设备"></a>首先查找 U 盘设备</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo fdisk -l<br></code></pre></td></tr></table></figure><h1 id="卸载-U-盘"><a href="#卸载-U-盘" class="headerlink" title="卸载 U 盘"></a>卸载 U 盘</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo umount <span class="hljs-regexp">/dev/</span>sda1<br></code></pre></td></tr></table></figure><h1 id="使用-dd-命令制作启动盘"><a href="#使用-dd-命令制作启动盘" class="headerlink" title="使用 dd 命令制作启动盘"></a>使用 dd 命令制作启动盘</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo dd <span class="hljs-attribute">if</span>=xxx.iso <span class="hljs-attribute">of</span>=U盘路径 <span class="hljs-attribute">status</span>=progress<br></code></pre></td></tr></table></figure><p>注意不要填上数字，要写成如: <code>/dev/sda</code>.</p><p>这里 <code>status=LEVEL</code>, 是和报错相关.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>An Introduction to GCC Notes</title>
    <link href="/2022/07/23/An-Introduction-to-GCC-Notes/"/>
    <url>/2022/07/23/An-Introduction-to-GCC-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1: Introduction"></a>Chapter 1: Introduction</h1><h1 id="Chapter-2-Compiling-a-C-program"><a href="#Chapter-2-Compiling-a-C-program" class="headerlink" title="Chapter 2: Compiling a C program"></a>Chapter 2: Compiling a C program</h1><p>The <code>-o</code> option is usually given as the last argument on the command line.</p><p>If the <code>-o</code> option is omitted, the output is written to a default file called ‘a.out’.</p><p>Always using <code>-Wall</code> option.</p><p>The messages produced by GCC always have th  form:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">file</span>:<span class="hljs-built_in">line</span>-<span class="hljs-built_in">number</span>:message<br></code></pre></td></tr></table></figure><p>The linker fills in these missing addresses when it produces the executable.</p><h3 id="2-4-1-Creating-object-file-from-source-files"><a href="#2-4-1-Creating-object-file-from-source-files" class="headerlink" title="2.4.1 Creating object file from source files"></a>2.4.1 Creating object file from source files</h3><p>The command-line option <code>-c</code> is used to compile a source file to an object file.</p><h3 id="2-4-2-Creating-executables-from-object-files"><a href="#2-4-2-Creating-executables-from-object-files" class="headerlink" title="2.4.2 Creating executables from object files"></a>2.4.2 Creating executables from object files</h3><p>Use gcc to link the object files together and fill in the missing addresse of external functions.</p><p>A separate program, linker ld.</p><h3 id="2-4-3-Link-order-of-object-files"><a href="#2-4-3-Link-order-of-object-files" class="headerlink" title="2.4.3 Link order of object files"></a>2.4.3 Link order of object files</h3><p>The object file which contains the definition of a function should appear after any files which call that function.</p><h2 id="2-5-Recompiling-and-relinking"><a href="#2-5-Recompiling-and-relinking" class="headerlink" title="2.5 Recompiling and relinking"></a>2.5 Recompiling and relinking</h2><p>Linking is faster than compilation.</p><h2 id="2-6-Linking-with-external-libraries"><a href="#2-6-Linking-with-external-libraries" class="headerlink" title="2.6 Linking with external libraries"></a>2.6 Linking with external libraries</h2><p>A library is a collection of precompiled object files which can be linked into programs.</p><p>Libraries are typically stored in special archive files with the extension <code>.a</code>, refferred to as static libraries.</p><p>They are created from object files with a saparate tool, <mark>the GNU archiver ar</mark>, and used by the linker to resolve references to functions at compile-time.</p><p>The standard system libraries are usually found in the directories <code>/usr/lib</code> and <code>/lib</code>.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ gcc -Wall calc.c <span class="hljs-regexp">/usr/</span>lib/libm.a -o calc<br></code></pre></td></tr></table></figure><p>The library <code>libm.a</code> contains object files for all the mathematical functions.</p><p>使用缩写, the compiler option <code>-lNAME</code> will attempt to link object files with a library file <code>libNAME.a</code> in the standard library directories.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc -Wall calc.c -lm -o calc<br></code></pre></td></tr></table></figure><h3 id="2-6-1-Link-order-of-libraries"><a href="#2-6-1-Link-order-of-libraries" class="headerlink" title="2.6.1 Link order of libraries"></a>2.6.1 Link order of libraries</h3><p>Searching from left to right. 左边缺少的到右边找。</p><h2 id="2-7-Using-library-header-files"><a href="#2-7-Using-library-header-files" class="headerlink" title="2.7 Using library header files"></a>2.7 Using library header files</h2><p>In order to declare function arguments and return values with the correct types. 没有声明，参数的类型会出错。</p><h1 id="Chapter-3-Compilation-options"><a href="#Chapter-3-Compilation-options" class="headerlink" title="Chapter 3: Compilation options"></a>Chapter 3: Compilation options</h1><p>By default, gcc searches the following directories for header files:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/usr/</span>local/<span class="hljs-keyword">include</span><br><span class="hljs-regexp">/usr/i</span>nclude<br></code></pre></td></tr></table></figure><p>For libraries:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local/lib<br><span class="hljs-regexp">/usr/</span>lib<br></code></pre></td></tr></table></figure><p>Local 的优先级更高。</p><p>You should never place the absolute paths of header files in <code>#include</code> statement.</p><p><code>-I</code> option or <code>INCLUDE_PATH</code> variable. 可指定额外的<code>#include</code> 路径。</p><p><code>-L</code> option or <code>LIBRARY_PATH</code> variable. 可指定额外的 link path.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ gcc -Wall -I<span class="hljs-regexp">/opt/g</span>dbm-<span class="hljs-number">1.8</span>.<span class="hljs-number">3</span><span class="hljs-regexp">/include -L/</span>opt<span class="hljs-regexp">/gdbm-1.8.3/</span>lib demain.c -lgdbm<br></code></pre></td></tr></table></figure><p>若设置了<code>C_INCLUDE_PATH</code> 或 <code>CPLUS_INCLUDE_PATH</code> 或 <code>LIBRARY_PATH</code> 就不用使用<code>-I</code>和<code>-L</code>选项。</p><h3 id="3-1-3-Extended-search-paths"><a href="#3-1-3-Extended-search-paths" class="headerlink" title="3.1.3 Extended search paths"></a>3.1.3 Extended search paths</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">DIR1<span class="hljs-selector-pseudo">:DIR</span>2<span class="hljs-selector-pseudo">:DIR</span>3:...<br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ gcc -I. -I/<span class="hljs-meta">opt</span>/<span class="hljs-meta">include</span><br></code></pre></td></tr></table></figure><p>多次使用<code>-I</code> or <code>-L</code>.</p><p>查找顺序:</p><pre><code class="hljs">1. command-line option `-I` and `-L`, from left to right2. directories specified by environment variables, such as C_INLUDE_PATH and LIBRARY_PATH3. default system directories</code></pre><h2 id="3-2-Shared-libraries-and-static-libraries"><a href="#3-2-Shared-libraries-and-static-libraries" class="headerlink" title="3.2 Shared libraries and static libraries"></a>3.2 Shared libraries and static libraries</h2><p>External libraries are usually provided in two forms:</p><pre><code class="hljs">1. static libraries, &#39;.a&#39; file2. shared libries, &#39;.so&#39; file</code></pre><p>Dynamic linking makes executable files smaller and saves disk space.</p><p>shared libraries 比 static library 更好。</p><p>Shared object file is used in preference to the static library.</p><p>static library 包含所有的function的machine code, 而 shared object file 只包含一部分。</p><p>By default, the loader searches for shared libraries only in a predefined set of system deirectories.</p><p>Setting load path: use variable <code>LD_LIBRARY_PATH</code></p><p>Adding new:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=/opt/gdbm-1.8.3/lib:<span class="hljs-variable">$LD_LIBRARY_PATH</span></span><br></code></pre></td></tr></table></figure><p>Option <code>-static</code> to avoid using shared library.</p><h2 id="3-3-C-language-standards"><a href="#3-3-C-language-standards" class="headerlink" title="3.3 C language standards"></a>3.3 C language standards</h2><p>Controling the dialect of C, use <code>-ansi</code> and <code>-pedantic</code>.</p><p>针对与C版本之间的差异。</p><h3 id="3-3-1-ANSI-x2F-ISO"><a href="#3-3-1-ANSI-x2F-ISO" class="headerlink" title="3.3.1 ANSI&#x2F;ISO"></a>3.3.1 ANSI&#x2F;ISO</h3><p>A valid ANSI&#x2F;ISO program may be incompatible with the extention in GNU C.</p><p><code>_GNU_SOURCE</code>, which enable extensions in the GNU C library.</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> gcc -Wall -ansi -D_GNU_SOURCE <span class="hljs-built_in">pi</span>.c<br></code></pre></td></tr></table></figure><h3 id="3-3-3-Selecting-special-standards"><a href="#3-3-3-Selecting-special-standards" class="headerlink" title="3.3.3 Selecting special standards"></a>3.3.3 Selecting special standards</h3><p>The special language standard used by GCC can be controled with the ‘-std’ option.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">-std</span>=c99<br></code></pre></td></tr></table></figure><h2 id="3-4-Warning-options-in-Wall"><a href="#3-4-Warning-options-in-Wall" class="headerlink" title="3.4 Warning options in -Wall"></a>3.4 Warning options in -Wall</h2><p>Warning options can also be selected individually. 如:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Wcomment</span><br><br><span class="hljs-deletion">-Wformat</span><br><br>...<br></code></pre></td></tr></table></figure><h2 id="3-5-Additional-warning-options"><a href="#3-5-Additional-warning-options" class="headerlink" title="3.5 Additional warning options"></a>3.5 Additional warning options</h2><p><code>-W</code> a general option similar to <code>-Wall</code>.</p><h1 id="4-Using-the-preprocessor"><a href="#4-Using-the-preprocessor" class="headerlink" title="4 Using the preprocessor"></a>4 Using the preprocessor</h1><p>The GNU C preprocessor cpp.</p><p>It expands macros in source files before they are compiled.</p><h2 id="4-1-Defining-macro"><a href="#4-1-Defining-macro" class="headerlink" title="4.1 Defining macro"></a>4.1 Defining macro</h2><p>The gcc option <code>-DNAME</code> defines a preprocessor macro NAME from the command line.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc -Wall -DTEST dtest.c<br></code></pre></td></tr></table></figure><p>gcc 自动定义的 macro, with a double-underscore prefix <code>__</code>:</p><p>查看:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ cpp -dM <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h2 id="4-2-Macro-with-values"><a href="#4-2-Macro-with-values" class="headerlink" title="4.2 Macro with values"></a>4.2 Macro with values</h2><p><code>-DNAME=VALUE</code>:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ gcc -Wall <span class="hljs-attribute">-DNUM</span>=100 dtestval.c<br></code></pre></td></tr></table></figure><p>It is a good idea to surround macros by parenthesses.</p><p>When a macro is defined with <code>-D</code> alone, gcc used a default value of 1.</p><p>Empty value:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">-DNAME</span>=<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>Define a macro message:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">-DNAME</span>=<span class="hljs-string">&quot;\&quot;Hello, World!\&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="4-3-Preprocessing-source-files"><a href="#4-3-Preprocessing-source-files" class="headerlink" title="4.3 Preprocessing source files"></a>4.3 Preprocessing source files</h2><p>To see the effect of the preprocessor on source file directly, using the <code>-E</code> option.</p><p><code>-save-temps</code> option, the preprocessed output will be available in the file <code>hello.i</code>.</p><h1 id="5-Compiling-for-debugging"><a href="#5-Compiling-for-debugging" class="headerlink" title="5 Compiling for debugging"></a>5 Compiling for debugging</h1><p><code>-g</code> option to store additional debugging information in object files and executables.</p><p>GNU Debugger gdb.</p><p>Storing the names of functions and variables, with their corresponding source code line-numbers.</p><h2 id="5-1-Examining-core-files"><a href="#5-1-Examining-core-files" class="headerlink" title="5.1 Examining core files"></a>5.1 Examining core files</h2><p>The core file can be used to find the line where the program stopped, and the values of its variables at that point.</p><p>A null pointer will only cause a problem at run-time, so the option <code>-Wall</code> does not produce any warning.</p><p>Whenever the error message <code>core dumped</code> is displayed, the operating system should produce a file called <code>core</code> in the current directory.</p><p>The term <code>segmentation fault</code> refers to the fact that the program tried to access a restricted memory <code>segment</code> outside the area of memory which had been allocated to it.</p><p>In the GNU Bash shell the command <code>ulimit -c</code> control the maximum size of core files.</p><p>Any size to be written:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ulimit</span> -c unlimited</span><br></code></pre></td></tr></table></figure><p>only apply to the current shell.</p><p>Loading the core file into the GNU Debugger gdb:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> gdb EXEECUTABLE-<span class="hljs-keyword">FILE</span> CORE-<span class="hljs-keyword">FILE</span><br></code></pre></td></tr></table></figure><p>both the original executable file and the core file are required for debugging.</p><h1 id="6-Compiling-with-optimization"><a href="#6-Compiling-with-optimization" class="headerlink" title="6 Compiling with optimization"></a>6 Compiling with optimization</h1><h2 id="6-1-Source-level-optimization"><a href="#6-1-Source-level-optimization" class="headerlink" title="6.1 Source-level optimization"></a>6.1 Source-level optimization</h2><p>Two type:</p><pre><code class="hljs">- common subexpression elimination- function inlining</code></pre><h3 id="6-1-1-Common-subexpression-elimination"><a href="#6-1-1-Common-subexpression-elimination" class="headerlink" title="6.1.1 Common subexpression elimination"></a>6.1.1 Common subexpression elimination</h3><p>Reusing already-computed results.<br>如:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">x = cos(<span class="hljs-name">v</span>)*(<span class="hljs-number">1</span>+sin(<span class="hljs-name">u/2</span>)) + sin(<span class="hljs-name">w</span>)*(<span class="hljs-number">1</span>-sin(<span class="hljs-name">u/2</span>))<br></code></pre></td></tr></table></figure><p>重写为:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">t</span> = <span class="hljs-built_in">sin</span>(u/<span class="hljs-number">2</span>);<br>x = <span class="hljs-built_in">cos</span>(v)*(<span class="hljs-number">1</span>+<span class="hljs-built_in">t</span>) + <span class="hljs-built_in">sin</span>(w)*(<span class="hljs-number">1</span>-<span class="hljs-built_in">t</span>);<br></code></pre></td></tr></table></figure><p>可以 increase the speed and reduces the size of the code.</p><h3 id="6-1-2-Function-inlining"><a href="#6-1-2-Function-inlining" class="headerlink" title="6.1.2 Function inlining"></a>6.1.2 Function inlining</h3><p>Increase the efficiency of frequently-called functions.</p><p>Replacing calls to a function by the code of the function itself.</p><p>Eliminating the function call.</p><p>The function being suitably small.</p><h2 id="6-2-Speed-space-tradeoffs"><a href="#6-2-Speed-space-tradeoffs" class="headerlink" title="6.2 Speed-space tradeoffs"></a>6.2 Speed-space tradeoffs</h2><p>Choose between speed and memory is referred to as speed-space tradeoffs.</p><h3 id="6-2-1-Loop-unrolling"><a href="#6-2-1-Loop-unrolling" class="headerlink" title="6.2.1 Loop unrolling"></a>6.2.1 Loop unrolling</h3><p>将循环拆开，这样可以减少测试的时间:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 8; i++) &#123;</span><br>  y[i] <span class="hljs-operator">=</span> i<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>改为:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">y[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">3</span>] <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">4</span>] <span class="hljs-operator">=</span> <span class="hljs-number">4</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">5</span>] <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">6</span>] <span class="hljs-operator">=</span> <span class="hljs-number">6</span><span class="hljs-comment">;</span><br>y[<span class="hljs-number">7</span>] <span class="hljs-operator">=</span> <span class="hljs-number">7</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="6-3-Scheduling"><a href="#6-3-Scheduling" class="headerlink" title="6.3 Scheduling"></a>6.3 Scheduling</h2><p>The results become available to later instructions at the right time.</p><h2 id="6-4-Optimization-levels"><a href="#6-4-Optimization-levels" class="headerlink" title="6.4 Optimization levels"></a>6.4 Optimization levels</h2><p>Numbered from 0-3.</p><p>The command line option <code>-oLEVEL</code>.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-string">&#x27;-o0&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">no</span> <span class="hljs-string">&#x27;-o&#x27;</span>, <span class="hljs-keyword">default</span>: <span class="hljs-keyword">perform</span> <span class="hljs-keyword">no</span> optimization.<br><br> <span class="hljs-string">&#x27;-o1&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;-o&#x27;</span>, <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> require <span class="hljs-keyword">any</span> speed-space tradeoffs, smaller <span class="hljs-keyword">and</span> faster than <span class="hljs-keyword">with</span> <span class="hljs-string">&#x27;-o0&#x27;</span><br><br> <span class="hljs-string">&#x27;-o2&#x27;</span>, it provide maximum optimization <span class="hljs-keyword">without</span> increasing the executable size.<br><br> <span class="hljs-string">&#x27;-o3&#x27;</span>, may increase the speed but increase the size.<br><br> <span class="hljs-string">&#x27;-funroll-loops&#x27;</span>, turns <span class="hljs-keyword">on</span> <span class="hljs-keyword">loop</span>-unrolling.<br><br> <span class="hljs-string">&#x27;-os&#x27;</span>, produce the smallest possible executable.<br></code></pre></td></tr></table></figure><p>The cost of optimization includes greater complexity in debugging, and increased time and memory requirements during compilation.</p><h2 id="6-5-Examples"><a href="#6-5-Examples" class="headerlink" title="6.5 Examples"></a>6.5 Examples</h2><p>The run-time of the program can be measured using the <code>time</code> command in the GNU Bash shell.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>time ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>Optimizations may not necessarity make a program faster in every case.</p><h2 id="6-6-Optimization-and-debugging"><a href="#6-6-Optimization-and-debugging" class="headerlink" title="6.6 Optimization and debugging"></a>6.6 Optimization and debugging</h2><h2 id="6-7-Optimization-and-compiler-warning"><a href="#6-7-Optimization-and-compiler-warning" class="headerlink" title="6.7 Optimization and compiler warning"></a>6.7 Optimization and compiler warning</h2><p><code>-Wall</code> 应该看成，<code>-W</code> 和 <code>all</code>.</p><h1 id="7-Compiling-a-C-program"><a href="#7-Compiling-a-C-program" class="headerlink" title="7 Compiling a C++ program"></a>7 Compiling a C++ program</h1><p>It compiles C++ source code directly into assembly language.</p><h2 id="7-1-Compiling-a-simple-C-program"><a href="#7-1-Compiling-a-simple-C-program" class="headerlink" title="7.1 Compiling a simple C++ program"></a>7.1 Compiling a simple C++ program</h2><p>Using <code>g++</code> instead of <code>gcc</code>.<br>p56</p><h1 id="9-Troubleshooting"><a href="#9-Troubleshooting" class="headerlink" title="9 Troubleshooting"></a>9 Troubleshooting</h1><p>To display a complete list of options for gcc and its associated program:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -v --<span class="hljs-built_in">help</span></span><br></code></pre></td></tr></table></figure><h1 id="10-Compiler-related-tools"><a href="#10-Compiler-related-tools" class="headerlink" title="10 Compiler-related tools"></a>10 Compiler-related tools</h1><p>GNU archiver <mark>ar</mark>, for creating libaries, and the GNU profiling and coverage testing programs, <mark>gprof</mark> and <mark>gcov</mark>.</p><h2 id="10-1-Creating-a-library-with-the-GNU-archiver"><a href="#10-1-Creating-a-library-with-the-GNU-archiver" class="headerlink" title="10.1 Creating a library with the GNU archiver"></a>10.1 Creating a library with the GNU archiver</h2><p>Combining a collection of object files into a single archive file.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ ar <span class="hljs-literal">cr</span> libhello.<span class="hljs-keyword">a</span> hello_fn.o bye_fn.o<br></code></pre></td></tr></table></figure><p>The option <code>cr</code> stands for “create and replace”. ar does not require a prefix ‘-‘ for its options.</p><p>The first argument ‘libhello.a’ is the name of the library, The remaining arguments are the name of the object files to be copied into the library.</p><p>option <code>t</code>, list the object file in an existing library:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ ar t libhello<span class="hljs-selector-class">.a</span><br>hello_fn<span class="hljs-selector-class">.o</span><br>bye_fn.o<br></code></pre></td></tr></table></figure><h2 id="10-2-Using-the-profiler-gprof"><a href="#10-2-Using-the-profiler-gprof" class="headerlink" title="10.2 Using the profiler gprof"></a>10.2 Using the profiler gprof</h2><p>Measuring the performance of a program.</p><p>To use profiling, the program must be compiled and linked with the <code>-pg</code> profiling option:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc -Wall -c -pg collatz.c<br><span class="hljs-variable">$ </span>gcc -Wall -pg collatz.o<br></code></pre></td></tr></table></figure><p>If the program consists of more than one source file then the ‘-pg’ option should be used when compiling each source file, and used again when linking the object files to create the final executable.</p><p>The executable must be run to create the profiling data:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h2 id="10-3-Converage-testing-with-gcov"><a href="#10-3-Converage-testing-with-gcov" class="headerlink" title="10.3 Converage testing with gcov"></a>10.3 Converage testing with gcov</h2><p>It analyses the number of times each line of a program is executed during a run.</p><p>To find areas of the code which are not used, or which are not exercised in testing.</p><h1 id="11-How-the-compiler-works"><a href="#11-How-the-compiler-works" class="headerlink" title="11 How the compiler works"></a>11 How the compiler works</h1><p>The GNU Compiler, gcc or g++.</p><p>The GNU Assembler, as.</p><p>The GNU Linker, ld.</p><h2 id="11-1-An-overview-of-the-compilation-process"><a href="#11-1-An-overview-of-the-compilation-process" class="headerlink" title="11.1 An overview of the compilation process"></a>11.1 An overview of the compilation process</h2><p>The following stages:</p><pre><code class="hljs">- preprocessing (to expand macros)- compilation (from source code to assembly language)- assembly (from assembly language to machine code)- linking (to create the final executable)</code></pre><p>Can be seen using the ‘-v’ option described earlier.</p><h2 id="11-2-The-preprocessor"><a href="#11-2-The-preprocessor" class="headerlink" title="11.2 The preprocessor"></a>11.2 The preprocessor</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cpp</span> hello.c &gt; hello.i<br></code></pre></td></tr></table></figure><h2 id="11-3-The-compiler"><a href="#11-3-The-compiler" class="headerlink" title="11.3 The compiler"></a>11.3 The compiler</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc -Wall -S hello.i<br></code></pre></td></tr></table></figure><h2 id="11-4-The-assembler"><a href="#11-4-The-assembler" class="headerlink" title="11.4 The assembler"></a>11.4 The assembler</h2><p>Convert assembly language into machine code and generate an object file.</p><p>When there are calls to external functions in the assembly source file, the assembler leaves the addresses of the external functions undefined.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span><span class="hljs-keyword">as</span> hello.s -o hello.o<br></code></pre></td></tr></table></figure><h2 id="11-5-The-linker"><a href="#11-5-The-linker" class="headerlink" title="11.5 The linker"></a>11.5 The linker</h2><p>The linking of object files to create an executable.</p><p>The entire linking process is handled transparently by gcc when invoked as follows:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>gcc hello.o<br></code></pre></td></tr></table></figure><h1 id="12-Examining-compiled-files"><a href="#12-Examining-compiled-files" class="headerlink" title="12 Examining compiled files"></a>12 Examining compiled files</h1><h2 id="12-1-Identifying-files"><a href="#12-1-Identifying-files" class="headerlink" title="12.1 Identifying files"></a>12.1 Identifying files</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>file a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h2 id="12-2-Examining-the-symble-table"><a href="#12-2-Examining-the-symble-table" class="headerlink" title="12.2 Examining the symble table"></a>12.2 Examining the symble table</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>nm a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h2 id="12-3-Finding-dynamically-linked-libraries"><a href="#12-3-Finding-dynamically-linked-libraries" class="headerlink" title="12.3 Finding dynamically linked libraries"></a>12.3 Finding dynamically linked libraries</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ldd a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>GCC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Adding something to man page</title>
    <link href="/2022/07/22/Adding-something-to-man-page/"/>
    <url>/2022/07/22/Adding-something-to-man-page/</url>
    
    <content type="html"><![CDATA[<p>Adding things into &#x2F;usr&#x2F;local&#x2F;man.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LaTex入门</title>
    <link href="/2022/07/21/LaTeX%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/21/LaTeX%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-熟悉LaTec"><a href="#第一章-熟悉LaTec" class="headerlink" title="第一章 熟悉LaTec"></a>第一章 熟悉LaTec</h1><p><code>\documentclass&#123;article&#125;</code>声明文档的类型是<code>article</code>.</p><p><code>\begin&#123;document&#125;</code>和<code>\end&#123;document&#125;</code>标识出正文的范围。</p><p>使用<code>\documentclass[UTF8]&#123;ctexart&#125;</code>可显示中文。</p><p><code>\section&#123;&#125;</code>声明了一节的标题.</p><p><code>\[</code>和<code>\]</code>包裹的数学公式。</p><p>LATAX的命令以反斜线<code>\</code>开头。</p><p>严格来说, LaTex不是标记语言，而是主要基于字符串代换的宏语言。</p><h2 id="1-2-从一个例子说起"><a href="#1-2-从一个例子说起" class="headerlink" title="1.2 从一个例子说起"></a>1.2 从一个例子说起</h2><h3 id="1-2-2-从提纲开始"><a href="#1-2-2-从提纲开始" class="headerlink" title="1.2.2 从提纲开始"></a>1.2.2 从提纲开始</h3><p><code>%</code>开头的是注释。</p><p>单个换行并不会使文字另起一段。</p><p>LaTex会忽略每行开始的所有空格。</p><p><code>\footnote&#123;&#125;</code>脚注命令。花括号内的部分是命令的参数，也就是脚注的内容。</p><p><code>emph</code>命令改变字体形状，表示强调。</p><p><code>quote</code>环境，以<code>\begin&#123;quote&#125;</code>和<code>\end&#123;quote&#125;</code>为起止位置。</p><p><code>begin&#123;&#125;</code>命令的参数是环境？</p><p><code>abstract</code>环境，<code>begin&#123;abstract&#125;</code>.</p><p>分组限定了声明的作用范围，一个LaTex环境自然就是一个分组。</p><p>LaTex环境的一般格式:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">\<span class="hljs-keyword">begin</span>&#123;环境名&#125;<br>...<br>\<span class="hljs-keyword">end</span>&#123;环境名&#125;<br></code></pre></td></tr></table></figure><p>带参数或可选参数的环境:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">\<span class="hljs-keyword">begin</span>&#123;环境名&#125;[可选参数]其他参数<br>...<br>\<span class="hljs-keyword">end</span>&#123;环境名&#125;<br></code></pre></td></tr></table></figure><p>定理环境，是一类环境，需在导言区做定义:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">\newtheorem</span><span class="hljs-template-variable">&#123;thm&#125;</span><span class="hljs-template-variable">&#123;定理&#125;</span><br></code></pre></td></tr></table></figure><p>最后一个花括号<code>&#123;&#125;</code>是可选参数，也就是名字。</p><p>使用:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">\<span class="hljs-keyword">begin</span>&#123;thm&#125;[勾股定理]<br>...<br>\<span class="hljs-keyword">end</span>&#123;thm&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-5-遭遇数学公式"><a href="#1-2-5-遭遇数学公式" class="headerlink" title="1.2.5 遭遇数学公式"></a>1.2.5 遭遇数学公式</h3><p>最简单的方法, 使用<code>$...$</code>:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-keyword">$a</span>+b$</span><br></code></pre></td></tr></table></figure><p>称<code>行内公式(inline formula)</code>.</p><p>“列表公式”使用<code>equation</code>环境:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">\<span class="hljs-keyword">begin</span>&#123;equation&#125;<br>  a(b+<span class="hljs-keyword">c</span>) <span class="hljs-operator">=</span> ab + ac<br>\<span class="hljs-keyword">end</span>&#123;equantion&#125;<br></code></pre></td></tr></table></figure><p>键盘上没有的符号需要使用命令来输入。</p><p>上标结构:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AB</span>^<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>下标结构:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">AB_2<br></code></pre></td></tr></table></figure><p>参数是多个字符就是用花括号<code>&#123;&#125;</code>.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>^&#123;<span class="hljs-number">10</span>&#125;<br></code></pre></td></tr></table></figure><p>角度的符号使用上标表示:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>^\circ<span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><h3 id="1-2-6-使用图表"><a href="#1-2-6-使用图表" class="headerlink" title="1.2.6 使用图表"></a>1.2.6 使用图表</h3><h4 id="插图"><a href="#插图" class="headerlink" title="插图"></a>插图</h4><p>两种方式:</p><pre><code class="hljs">1. 插入事先准备好的图片2. 使用LaTex代码直接在文档中画图</code></pre><p>大部分情况都是使用插入外部图片的方式。</p><p>使用<code>\usepackage</code>引入宏包, 插入图片使用<code>graphicx</code>宏包。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">\usepackage</span><span class="hljs-template-variable">&#123;graphicx&#125;</span><br></code></pre></td></tr></table></figure><p><code>figure</code>环境，即浮动体环境。</p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>使用<code>tabular</code>环境确定表格的行、列对齐模式和表格线。</p><p><code>tabular</code>环境有一个参数。</p><h3 id="1-2-7-自动化工具"><a href="#1-2-7-自动化工具" class="headerlink" title="1.2.7 自动化工具"></a>1.2.7 自动化工具</h3><p>使用<code>\bibliographystyle</code>声明参考文献的格式。</p><p>使用<code>\bibliography</code>命令要求打印出参考文献列表.</p><p>使用<code>BIBTEX</code>处理参考数据库，即<code>.bib</code>文件：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@ARTICLE</span><span class="hljs-template-variable">&#123;quanjing,</span><br><span class="hljs-template-variable">  author = &#123;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  publisher = </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  title = </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal = </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year = </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume = </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number = </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p><code>BIBTEX</code>是一个专用于处理LATEX文档文献列表的程序。</p><p>引用文献的方法:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">\<span class="hljs-selector-tag">cite</span>&#123;name&#125;<br></code></pre></td></tr></table></figure><p>用<code>lable</code>定义的标签也能被引用。</p><h1 id="第二章-组织你的文本"><a href="#第二章-组织你的文本" class="headerlink" title="第二章 组织你的文本"></a>第二章 组织你的文本</h1><h2 id="2-1-文字与符号"><a href="#2-1-文字与符号" class="headerlink" title="2.1 文字与符号"></a>2.1 文字与符号</h2>]]></content>
    
    
    <categories>
      
      <category>LaTeX</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Practical Vim Notes</title>
    <link href="/2022/07/20/Practical-Vim-Notes/"/>
    <url>/2022/07/20/Practical-Vim-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第12章"><a href="#第12章" class="headerlink" title="第12章"></a>第12章</h1><p><code>\c</code>之前的模式忽略大小写。</p><p><code>\x</code>代表完整的字符集[0-9a-fA-F]</p><p><code>&lt;</code>和<code>&gt;</code>用于匹配单词的边界。</p><p><code>\_s</code>匹配空白字符或换行符。</p><p><code>%()</code>非捕获型括号。</p><p><code>\zs</code>标志匹配的起始，<code>\ze</code>标志匹配的结束。类似于perl中的环视。</p><p>与Perl正则语法的对比<code>:h perl-patterns</code></p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux System Programming</title>
    <link href="/2022/07/18/Linux-System-Programming/"/>
    <url>/2022/07/18/Linux-System-Programming/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-入门和基本概念"><a href="#第一章-入门和基本概念" class="headerlink" title="第一章 入门和基本概念"></a>第一章 入门和基本概念</h1><h2 id="1-2-API和ABI"><a href="#1-2-API和ABI" class="headerlink" title="1.2 API和ABI"></a>1.2 API和ABI</h2><h3 id="1-2-2-ABI"><a href="#1-2-2-ABI" class="headerlink" title="1.2.2 ABI"></a>1.2.2 ABI</h3><p>ABI和体系结构紧密联系，绝大多数ABI表示了机器级概念.</p><p>通常通过机器体系结构名称来称呼这些ABI，如Alpha或x86-64。</p><p>ABI是操作系统和体系结构共同提供的功能.</p><h2 id="1-4-Linux编程的概念"><a href="#1-4-Linux编程的概念" class="headerlink" title="1.4 Linux编程的概念"></a>1.4 Linux编程的概念</h2><h3 id="1-4-1-文件和文件系统"><a href="#1-4-1-文件和文件系统" class="headerlink" title="1.4.1 文件和文件系统"></a>1.4.1 文件和文件系统</h3><p>在Linux内核中，文件用一个整数表示(C语言的int类型), 称文件描述符.</p><p>普通文件包含以字节流(即线性数组)组织的数据.</p><p>索引节点inode(information node). 包含和文件关联的元数据，其中包括文件数据在磁盘上的存储位置.</p><p>索引节点是UNIX文件在磁盘上的实际物理对象，也是在Linux内核中通过数据结构表示的概念实体.</p><h4 id="目录和链接"><a href="#目录和链接" class="headerlink" title="目录和链接"></a>目录和链接</h4><p>目录是可读名称到索引编号之间的映射.</p><p>名称和索引节点之间的配对称为链接(link).</p><p>可以把目录看作普通的文件，其区别在于它包含文件名到索引节点的映射. 内核1直接通过该映射把文件名解析为索引节点.</p><p>Linux内核也采用缓存(denty cache)存储目录的解析结果，以便后续访问更快地提供查询结果.</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>当不同名称的多个链接映射到同一个索引节点时，我们称该链接为硬链接(hard link).</p><p>每个索引节点包含链接计数(link count)， 记录该索引节点在文件系统中的链接数，只有当link count is 0, 索引节点及其相关数据才会从文件系统中真正删除。</p><h5 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h5><p>Symbolic links.</p><p>为了实现跨文件系统链接。</p><p>有自己的索引节点和数据块.</p><h5 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h5><p>Special file. 指以文件来表示的内核对象。特殊应该是指访问方式特殊.</p><p>Linux只支持四种special file:</p><pre><code class="hljs">1. 块设备文件2. 字符设备文件3. 命名管道4. UNIX域套接字</code></pre><p>字符设备作为线性字节队列来访问。</p><p>块设备作为字节数组来访问。</p><p>命名管道(named pipes), 通过FIFO特殊文件来访问.</p><p>套接字(socket)使用socket文件进行交互.</p><h4 id="文件系统和命名空间"><a href="#文件系统和命名空间" class="headerlink" title="文件系统和命名空间"></a>文件系统和命名空间</h4><p>有些操作系统会把不同的磁盘和驱动划分为独立的命名空间。<br>添加和删除文件系统的操作为挂载(mounting)和卸载(unmounting).</p><p>Linux系统必定有个根文件系统.</p><p>块设备的最小寻址单位是扇区(sector).</p><p>文件系统中的最小逻辑寻址单元是块(block), 其大小一般是2的指数倍乘以扇区大小。</p><p>页(page)是内存的最小寻址单元.</p><h3 id="1-4-2-进程"><a href="#1-4-2-进程" class="headerlink" title="1.4.2 进程"></a>1.4.2 进程</h3><p>进程不仅包含目标代码，它还包括数据、资源、状态和虚拟计算机。</p><p>在Linux下，最常见的格式称”可执行和可链接的格式(Executable and Linkable Format, ELF)”.</p><p>C标准规定了C变量的默认值为0.</p><p>bss的取名存在历史遗留原因，是block started by symbol.</p><p>进程资源以及该进程相关的数据和统计保存在内核中该进程的进程描述符中.</p><h4 id="进程层次结构"><a href="#进程层次结构" class="headerlink" title="进程层次结构"></a>进程层次结构</h4><p>在Linux中，进程树的根是第一个进程，称为init进程，通常为init程序。</p><p>如果父进程先于子进程终止，内核会将init进程指定为它的父进程。</p><p>在Linux内核中，uid是用户的唯一标识.</p><h3 id="1-4-4-权限"><a href="#1-4-4-权限" class="headerlink" title="1.4.4 权限"></a>1.4.4 权限</h3><p>特殊文件忽略执行权限.</p><p>对于目录，读权限表示允许列出目录的内容，写权限表示允许在目录中添加新的链接，执行权限表示允许在路径中输入和使用该目录.</p><h3 id="1-4-5-信号"><a href="#1-4-5-信号" class="headerlink" title="1.4.5 信号"></a>1.4.5 信号</h3><p>信号一般用于通知进程发生了某些事件，如段错误或用户按下Ctrl+C。</p><p>每个信号是由一个数值常量和文本名表示。如SIGHUP用于表示终端挂起，在x86-64体系结构上值为1.</p><h3 id="1-4-6-进程间通信"><a href="#1-4-6-进程间通信" class="headerlink" title="1.4.6 进程间通信"></a>1.4.6 进程间通信</h3><p>Linux支持的进程间通信机制包括管道，命名管道，信号量，消息队列，共享内存和快速用户空间互斥。</p><h3 id="1-4-8-Error-Handling"><a href="#1-4-8-Error-Handling" class="headerlink" title="1.4.8 Error Handling"></a>1.4.8 Error Handling</h3><p>Special variable，errno.</p><p>函数通过特殊返回值(通常为1)来通知函数调用发生错误.</p><p>变量errno用于定位错误的原因。</p><p>errno定义在&lt;errno.h&gt;.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> errno;<br></code></pre></td></tr></table></figure><h4 id="把errno值转化为对应的文本"><a href="#把errno值转化为对应的文本" class="headerlink" title="把errno值转化为对应的文本"></a>把errno值转化为对应的文本</h4><p>Using the function <code>perror()</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span></span>;<br></code></pre></td></tr></table></figure><h1 id="CHAPTER-2-File-I-x2F-O"><a href="#CHAPTER-2-File-I-x2F-O" class="headerlink" title="CHAPTER 2 File I&#x2F;O"></a>CHAPTER 2 File I&#x2F;O</h1><p>最简单及最常见的文件交互方式–系统调用。</p><p>内核会为每个进程维护一个打开文件的列表，称文件表(file table)</p><p>每个Linux进程可达开得文件数是有上限的.</p><p>每个进程至少包括三个文件描述符: 0, 1, 2</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">0</span>表示<span class="hljs-keyword">stdin</span><br><span class="hljs-number">1</span>表示<span class="hljs-keyword">stdout</span><br><span class="hljs-number">2</span>表示<span class="hljs-keyword">stderr</span><br></code></pre></td></tr></table></figure><p>几乎任何能够读写的东西都可以通过文件描述符来访问.</p><p>关于文件的读写都要判断文件是否成功打开。</p><h3 id="2-1-2-新建文件的所有者"><a href="#2-1-2-新建文件的所有者" class="headerlink" title="2.1.2 新建文件的所有者"></a>2.1.2 新建文件的所有者</h3><p>文件所有者的uid即创建该文件的进程的有效uid.</p><p>文件所属组默认情况下使用创建进程的有效gid.</p><h3 id="2-1-3-文件权限"><a href="#2-1-3-文件权限" class="headerlink" title="2.1.3 文件权限"></a>2.1.3 文件权限</h3><p>创建文件时，参数mode提供了新建文件的权限.</p><h3 id="The-creat-function"><a href="#The-creat-function" class="headerlink" title="The creat() function"></a>The creat() function</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">crear</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">int</span> mode)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">open</span> <span class="hljs-params">(name, O_WRONLY | O_CREAT | O_TRUNC, mode)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>没有数据可读和到达数据结尾是两个不同的概念。</p><h3 id="Reading-All-the-Bytes"><a href="#Reading-All-the-Bytes" class="headerlink" title="Reading All the Bytes"></a>Reading All the Bytes</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stata">ssize_t <span class="hljs-keyword">ret</span>;<br><br><span class="hljs-keyword">while</span> (len != 0 &amp;&amp; (<span class="hljs-keyword">ret</span> = <span class="hljs-keyword">read</span> (fd, buf, len)) != 0) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span> == -1) &#123;<br>                <span class="hljs-keyword">if</span> (errno == EINTR)<br>                        <span class="hljs-keyword">continue</span>;<br>                perror (<span class="hljs-string">&quot;read&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        len -= <span class="hljs-keyword">ret</span>;<br>        buf += <span class="hljs-keyword">ret</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-3-Nonblocking-Reads"><a href="#2-2-3-Nonblocking-Reads" class="headerlink" title="2.2.3 Nonblocking Reads"></a>2.2.3 Nonblocking Reads</h3><p>当以非阻塞模式读文件时，必须检查<code>EAGAIN</code>, 否则可能因为丢失数据导致严重后果.</p><h3 id="2-2-5-read-调用的大小限制"><a href="#2-2-5-read-调用的大小限制" class="headerlink" title="2.2.5 read()调用的大小限制"></a>2.2.5 read()调用的大小限制</h3><p>在32位系统上，size_t和ssize_t对应的C类型通常是unsigned int和int.</p><h2 id="2-3-Writing-with-write"><a href="#2-3-Writing-with-write" class="headerlink" title="2.3 Writing with write()"></a>2.3 Writing with write()</h2><h3 id="2-3-6-write-行为"><a href="#2-3-6-write-行为" class="headerlink" title="2.3.6 write()行为"></a>2.3.6 write()行为</h3><p>内核把写操作推迟到系统空闲时期，批处理很多写操作，称延迟写.</p><p>为了保证数据按时写入，内核设置了”最大缓存时效(maximum buffer age)”</p><h2 id="2-4-同步I-x2F-O"><a href="#2-4-同步I-x2F-O" class="headerlink" title="2.4 同步I&#x2F;O"></a>2.4 同步I&#x2F;O</h2><p>牺牲性能换来同步操作，控制数据何时写到磁盘。</p><h3 id="2-4-1-fsync-and-fdatasync"><a href="#2-4-1-fsync-and-fdatasync" class="headerlink" title="2.4.1 fsync() and fdatasync()"></a>2.4.1 fsync() and fdatasync()</h3><p>fsync():</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fsync</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><p>fdatasync():</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>这两个函数不能保证已经更新的包含该文件的目录项会同步到磁盘上. 为了保证1对目录项的更新也都同步到磁盘上，必须对文件目录也调用<code>fsync()</code>进行同步。</p><p>返回值和错误码，同时设置<code>errno</code>的值。</p><p>在POSIX标准中，fysnc()是必要的，而fdarasync()是可选的。</p><h3 id="2-4-2-sync"><a href="#2-4-2-sync" class="headerlink" title="2.4.2 sync()"></a>2.4.2 sync()</h3><p><code>sync()</code>系统调用用来对磁盘上的所有缓冲区进行同步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sync</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>关于同步时注意数据和元数据是否都写入。</p><h3 id="2-4-3-O-SYNC标志位"><a href="#2-4-3-O-SYNC标志位" class="headerlink" title="2.4.3 O_SYNC标志位"></a>2.4.3 O_SYNC标志位</h3><p>系统调用open()可以使用O_SYNC标志位，表示该文件的所有I&#x2F;O操作都需要同步。</p><h2 id="2-6-关闭文件"><a href="#2-6-关闭文件" class="headerlink" title="2.6 关闭文件"></a>2.6 关闭文件</h2><p>系统调用<code>close()</code>会取消当前进程的文件描述符fd与其关联的文件之间的映射。</p><p>关闭文件操作并非意味着该文件的数据已经被写到磁盘。</p><p>当关闭指向某个文件的最后一个文件描述符时，内核中表示该文件的数据结构就释放了。</p><h2 id="2-7-用lseek-查找"><a href="#2-7-用lseek-查找" class="headerlink" title="2.7 用lseek()查找"></a>2.7 用lseek()查找</h2><p>设置文件位置, 应该就是文件操作的位置.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> pos, <span class="hljs-type">int</span> origin)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="2-7-1-在文件末尾后查找"><a href="#2-7-1-在文件末尾后查找" class="headerlink" title="2.7.1 在文件末尾后查找"></a>2.7.1 在文件末尾后查找</h3><p>在UNIX文件系统上，空洞不占用任何物理磁盘空间。</p><h2 id="2-8-定位读写"><a href="#2-8-定位读写" class="headerlink" title="2.8 定位读写"></a>2.8 定位读写</h2><p>在读写操作时，都把文件位置作为参数，在完成时，不会更新文件位置指针。</p><h2 id="2-9-文件截短"><a href="#2-9-文件截短" class="headerlink" title="2.9 文件截短"></a>2.9 文件截短</h2><p>将给定文件截短为参数len指定的长度。</p><p>大多数的行为:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">成功时返回<span class="hljs-number">0</span>,出错时返回-<span class="hljs-number">1</span>并设置相应的errno值.<br></code></pre></td></tr></table></figure><h2 id="2-10-Multiplexed-I-x2F-O"><a href="#2-10-Multiplexed-I-x2F-O" class="headerlink" title="2.10 Multiplexed I&#x2F;O"></a>2.10 Multiplexed I&#x2F;O</h2><p>允许应用同时在多个文件描述符上阻塞，可能意思就是，当在一个文件描述符上阻塞时，可以切换到处理另外一个文件描述符。</p><p>设计原则:</p><pre><code class="hljs">1. 当任何一个文件描述符I/O就绪时进行通知2. 在有可用文件描述符之前一直就处于睡眠状态3. 当有文件描述符可用时唤醒4. 处理所有I/O就绪的文件描述符，没有阻塞5. 返回第一步，重新开始</code></pre><p>Linux有三种方案:select, poll and epoll.</p><h3 id="2-10-1-select"><a href="#2-10-1-select" class="headerlink" title="2.10.1 select()"></a>2.10.1 select()</h3><p>监测readfds集合中的文件描述符是否有可以不阻塞就读取。</p><p>在调用返回时，如果文件描述符比如7还在集合中，它在I&#x2F;O读取时不会阻塞.</p><h2 id="2-11-Kernel-Internals"><a href="#2-11-Kernel-Internals" class="headerlink" title="2.11 Kernel Internals"></a>2.11 Kernel Internals</h2><p>内核中的三个主要子系统: 虚拟文件系统(VFS), 页缓存(page cache), 页回写(page writeback).</p><h3 id="2-11-1-虚拟文件系统"><a href="#2-11-1-虚拟文件系统" class="headerlink" title="2.11.1 虚拟文件系统"></a>2.11.1 虚拟文件系统</h3><p>虚拟文件系统调用文件系统函数并操作文件系统的数据。</p><p>其系统调用可以在任意媒介的任意文件系统上读，工具可以从任何一个文件系统拷贝到另一个上.</p><h3 id="2-11-2-页缓存"><a href="#2-11-2-页缓存" class="headerlink" title="2.11.2 页缓存"></a>2.11.2 页缓存</h3><p>为什么是”页”缓存，”页”是内存寻址的最小单位。</p><p>将最近在磁盘文件系统上访问过的数据放在内存中.</p><p>利用了”时间局限性原理”即刚被访问的资源在不久后再次访问的概率很高。</p><p>“空间局部性”即数据往往是连续访问的。就是在每次读取时多读几个比特.</p><h3 id="2-11-3-页回写"><a href="#2-11-3-页回写" class="headerlink" title="2.11.3 页回写"></a>2.11.3 页回写</h3><p>将磁盘文件和内存数据同步的过程为”回写(writeback)”.</p><p>触发条件:</p><pre><code class="hljs">1. 当空闲内存小于预定的阈值，&quot;脏&quot;缓冲区就会写道磁盘上，这样被清理的缓冲区会被移除，释放内存空间。2. 当&quot;脏&quot;缓冲区的时长超过预定的阈值时，该缓冲区就会写到磁盘。通过这种方式，可以避免数据一直是&quot;脏&quot;数据。</code></pre><p>延迟写在电源出故障时可能会丢失数据。</p><h1 id="第三章-缓冲I-x2F-O"><a href="#第三章-缓冲I-x2F-O" class="headerlink" title="第三章 缓冲I&#x2F;O"></a>第三章 缓冲I&#x2F;O</h1><p>块是I&#x2F;O中的基本概念。</p><p>也许你只想读取一个字节，实际上要读取整个块.</p><h2 id="3-1-用户缓冲I-x2F-O"><a href="#3-1-用户缓冲I-x2F-O" class="headerlink" title="3.1 用户缓冲I&#x2F;O"></a>3.1 用户缓冲I&#x2F;O</h2><p><mark>只有当数据量大小达到文件系统块大小的整数倍时，才会执行真正的I&#x2F;O操作。</mark></p><p>为了利用性能提升的优势，需要预先了解物理快大小，块大小不是磁盘块的整数倍会导致不对齐操作。</p><h2 id="3-2-标准I-x2F-O"><a href="#3-2-标准I-x2F-O" class="headerlink" title="3.2 标准I&#x2F;O"></a>3.2 标准I&#x2F;O</h2><p>实现了跨平台的用户缓冲解决方案。</p><h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><p>标准I&#x2F;O程序集通过操作文件指针(file pointer)，文件指针和文件描述符是一一映射。</p><p>文件指针是由指向类型定义FILE的指针表示，其定义在&lt;stdio.h&gt;中。</p><h4 id="FILE为什么全部大写"><a href="#FILE为什么全部大写" class="headerlink" title="FILE为什么全部大写"></a>FILE为什么全部大写</h4><p>历史遗留原因，以前通过宏实现。</p><p>在标准I&#x2F;O中，打开的文件称为”流(stream)”. </p><p>输入流，应该看作输入到流。</p><h2 id="3-3-打开文件"><a href="#3-3-打开文件" class="headerlink" title="3.3 打开文件"></a>3.3 打开文件</h2><p>通过<code>fopen()</code>.</p><p><code>fopen()</code>执行成功时，返回一个合法的FILE指针，失败时，返回NULL,并相应设置errno值.</p><h2 id="3-4-通过文件描述符打开流"><a href="#3-4-通过文件描述符打开流" class="headerlink" title="3.4 通过文件描述符打开流"></a>3.4 通过文件描述符打开流</h2><p>通过<code>fdopen()</code>把一个已经打开的文件描述符(fd)转换成流。</p><h2 id="3-5-关闭流"><a href="#3-5-关闭流" class="headerlink" title="3.5 关闭流"></a>3.5 关闭流</h2><p>使用<code>fclose()</code>函数。</p><p>成功时返回0, 失败时返回EOF并且相应的设置errno.</p><p>讨论了三个读写方式: 单个字符，字符串，二进制.</p><h2 id="3-6-向流中写数据"><a href="#3-6-向流中写数据" class="headerlink" title="3.6 向流中写数据"></a>3.6 向流中写数据</h2><h3 id="3-6-1-对齐的讨论"><a href="#3-6-1-对齐的讨论" class="headerlink" title="3.6.1 对齐的讨论"></a>3.6.1 对齐的讨论</h3><p>所有的机器设计都有数据对齐的要求。</p><p>处理器都以特定的粒度来访问内存, 例如2, 4, 8 或 16字节。</p><p>编译器自动对其数据.</p><p>因为变量长度、对齐等等的不同，一个程序写入的二进制数据对于另外一个程序可能是不可读的。</p><h2 id="3-7-定位流"><a href="#3-7-定位流" class="headerlink" title="3.7 定位流"></a>3.7 定位流</h2><p><code>fseek()</code>函数，操纵流指向文件中由offset和whence指定的位置。</p><p><code>rewind()</code>函数，将位置重置到流初始位置.</p><p>理解C函数库维持的缓冲区和内核拥有的缓冲区的区别。前者保留在用户空间中。</p><h2 id="3-10-控制缓冲"><a href="#3-10-控制缓冲" class="headerlink" title="3.10 控制缓冲"></a>3.10 控制缓冲</h2><p>一些选项:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">不缓冲，数据直接提交到内核<br><br>行缓冲，每当遇到换行符，缓冲区被提交到内核<br><br>块缓冲，适用于文件，默认的所有的和文件相关的流都是块缓冲<br></code></pre></td></tr></table></figure><p>流是不是一个缓冲区。</p><h2 id="3-11-线程安全"><a href="#3-11-线程安全" class="headerlink" title="3.11 线程安全"></a>3.11 线程安全</h2><p>线程的定义是共享统一地址空间的多个进程。</p><p>一个线程要想执行任何I&#x2F;O请求，必须首先获得锁并且成为所有者线程。</p><h1 id="第四章-高级文件I-x2F-O"><a href="#第四章-高级文件I-x2F-O" class="headerlink" title="第四章 高级文件I&#x2F;O"></a>第四章 高级文件I&#x2F;O</h1><p>Linux提供的高级I&#x2F;O系统调用:</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">散布<span class="hljs-operator">/</span>聚集<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-variable">Scatter</span><span class="hljs-operator">/</span><span class="hljs-variable">gather</span> <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-variable">epoll</span><br><br>内存映射<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><br><br>文件<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>提示<br><br>异步<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><br></code></pre></td></tr></table></figure><h2 id="4-1-散步-x2F-聚集I-x2F-O"><a href="#4-1-散步-x2F-聚集I-x2F-O" class="headerlink" title="4.1 散步&#x2F;聚集I&#x2F;O"></a>4.1 散步&#x2F;聚集I&#x2F;O</h2><p>命名原由，数据被散布到一个缓冲区向量，或者从一个缓冲区向量聚集.</p><p>其在单次系统调用中操作多个缓冲区的I&#x2F;O.</p><p>每个iovec结构体描述一个独立的缓冲区，我们称其为段(segment).</p><p>一组segment的集合称为向量(vector). 每个段描述了所要读写的缓冲区的地址和长度。</p><h2 id="4-2-Event-Poll接口"><a href="#4-2-Event-Poll接口" class="headerlink" title="4.2 Event Poll接口"></a>4.2 Event Poll接口</h2><p>Event Poll(epoll)机制。p96</p><h3 id="4-2-4-边沿触发事件和水平触发事件"><a href="#4-2-4-边沿触发事件和水平触发事件" class="headerlink" title="4.2.4 边沿触发事件和水平触发事件"></a>4.2.4 边沿触发事件和水平触发事件</h3><p>水平出发，在一个状态发生时触发。</p><p>边沿触发，状态改变时产生。</p><h2 id="4-3-存储映射"><a href="#4-3-存储映射" class="headerlink" title="4.3 存储映射"></a>4.3 存储映射</h2><p>除标准I&#x2F;O之外的另一种I&#x2F;O方式，应用程序将文件映射到内存中。</p><h3 id="4-3-1-1-页大小"><a href="#4-3-1-1-页大小" class="headerlink" title="4.3.1.1 页大小"></a>4.3.1.1 页大小</h3><p>页是内存映射的基本块，同时也是进程地址空间的基本块。</p><p>mmap()在处理大文件，或者在文件的大小恰好被page大小整除时优势明显。</p><h2 id="4-5-Synchronized-Synchronous-and-Asynchronous-Operations"><a href="#4-5-Synchronized-Synchronous-and-Asynchronous-Operations" class="headerlink" title="4.5 Synchronized, Synchronous, and Asynchronous Operations"></a>4.5 Synchronized, Synchronous, and Asynchronous Operations</h2><p>Synchronous写操作在数据全部写到内核缓冲区之前是不会返回的。</p><p>Asynchronous写操作在用户空间还有数据时可能就返回了。</p><h2 id="4-6-I-x2F-O调度器和I-x2F-O性能"><a href="#4-6-I-x2F-O调度器和I-x2F-O性能" class="headerlink" title="4.6 I&#x2F;O调度器和I&#x2F;O性能"></a>4.6 I&#x2F;O调度器和I&#x2F;O性能</h2><p>硬盘和系统中其他部分的性能差距比较大。</p><p>I&#x2F;O调度器尽力将硬盘访问的性能损失控制在最小。</p><p>硬盘基于柱面(cylinders), 磁头(heads), 和扇区(section)的几何寻址方式，称CHS寻址。</p><p>现代系统通过块号与CHS地址的映射寻址。</p><h3 id="4-6-2-调度器功能"><a href="#4-6-2-调度器功能" class="headerlink" title="4.6.2 调度器功能"></a>4.6.2 调度器功能</h3><p>实现两个基本操作: </p><pre><code class="hljs">1. 合并(merging), 将两个或多个相邻的I/O请求的过程合并为一个。2. 排序(sorting), 选取两个操作中相对更重要的一个，并按块号递增的顺序重新安排等待的I/O请求。</code></pre><h3 id="4-6-3-改进读请求"><a href="#4-6-3-改进读请求" class="headerlink" title="4.6.3 改进读请求"></a>4.6.3 改进读请求</h3><h4 id="4-6-3-1-Deadline算法"><a href="#4-6-3-1-Deadline算法" class="headerlink" title="4.6.3.1 Deadline算法"></a>4.6.3.1 Deadline算法</h4><p>在I&#x2F;O请求上加入了最后期限，调度器是一个程序。</p><h4 id="4-6-3-2-Anticipatory算法"><a href="#4-6-3-2-Anticipatory算法" class="headerlink" title="4.6.3.2 Anticipatory算法"></a>4.6.3.2 Anticipatory算法</h4><p>和 Deadline 一样开始，但具有预测机制。</p><h4 id="4-6-3-3-CFQ-I-x2F-O调度器"><a href="#4-6-3-3-CFQ-I-x2F-O调度器" class="headerlink" title="4.6.3.3 CFQ I&#x2F;O调度器"></a>4.6.3.3 CFQ I&#x2F;O调度器</h4><h4 id="4-6-3-4-Noop-I-x2F-O调度器"><a href="#4-6-3-4-Noop-I-x2F-O调度器" class="headerlink" title="4.6.3.4 Noop I&#x2F;O调度器"></a>4.6.3.4 Noop I&#x2F;O调度器</h4><h3 id="4-6-4-选择和配置你的I-x2F-O调度器"><a href="#4-6-4-选择和配置你的I-x2F-O调度器" class="headerlink" title="4.6.4 选择和配置你的I&#x2F;O调度器"></a>4.6.4 选择和配置你的I&#x2F;O调度器</h3><p>目录<code>/sys/block/device/queue/iosched</code></p><h3 id="4-6-5-优化I-x2F-O性能"><a href="#4-6-5-优化I-x2F-O性能" class="headerlink" title="4.6.5 优化I&#x2F;O性能"></a>4.6.5 优化I&#x2F;O性能</h3><h4 id="4-6-5-1-用户空间I-x2F-O调度"><a href="#4-6-5-1-用户空间I-x2F-O调度" class="headerlink" title="4.6.5.1 用户空间I&#x2F;O调度"></a>4.6.5.1 用户空间I&#x2F;O调度</h4><p>以有利于寻址操作的顺序提交, 可按照以下方式:</p><pre><code class="hljs">1. 完整路径2. inode编号3. 文件的物理块</code></pre><p>文件i的inode序号 &lt; 文件j的inode号</p><p>通常意味着：</p><p>文件i的物理块 &lt; 文件j的物理块</p><h1 id="第五章-进程管理"><a href="#第五章-进程管理" class="headerlink" title="第五章 进程管理"></a>第五章 进程管理</h1><p>进程是UNIX系统中仅次于文件的基本抽象概念.</p><p>进程不仅仅包含汇编代码，它由数据、资源、状态和一个虚拟的计算机组成。</p><h2 id="5-1-进程ID"><a href="#5-1-进程ID" class="headerlink" title="5.1 进程ID"></a>5.1 进程ID</h2><p>简称pid.</p><p>本质上将，大多数代码会假设内核不会重用已经用过的pid值。</p><p>空闲进程(idle process)，当没有其他进程运行时，内核所运行的进程，其pid是0.</p><p>内核必须寻找一个适合的init程序。<br>查找位置和顺序:</p><pre><code class="hljs">1. /sbin/init2. /etc/init3. /bin/init4. /bin/sh, 当内核没有找到init时，内核会尝试运行它.</code></pre><p>所以内核似乎也就是个程序。</p><h3 id="5-1-1-分配进程ID"><a href="#5-1-1-分配进程ID" class="headerlink" title="5.1.1 分配进程ID"></a>5.1.1 分配进程ID</h3><p>缺省最大为32768.</p><p>设置<code>/proc/sys/kernel/pid_max</code>来修改。</p><p>内核不会重用以前已经分配过的值。</p><h3 id="5-1-2-进程体系"><a href="#5-1-2-进程体系" class="headerlink" title="5.1.2 进程体系"></a>5.1.2 进程体系</h3><p>父进程号(ppid).</p><p>每个进程都被一个用户和一个组拥有。</p><p>每个子进程都继承了父进程的用户和组。</p><p>所有与管道相关的命令都属于同一个进程组。</p><h3 id="5-1-3-pid-t"><a href="#5-1-3-pid-t" class="headerlink" title="5.1.3 pid_t"></a>5.1.3 pid_t</h3><p>在Linux通常是C语言中的int类型。</p><p>系统调用似乎就是系统编程中的函数.</p><h2 id="5-2-运行新进程"><a href="#5-2-运行新进程" class="headerlink" title="5.2 运行新进程"></a>5.2 运行新进程</h2><p><code>fork()</code>基本上就是复制父进程。</p><h3 id="5-2-1-exec系列系统调用"><a href="#5-2-1-exec系列系统调用" class="headerlink" title="5.2.1 exec系列系统调用"></a>5.2.1 exec系列系统调用</h3><p>没有单一的exec系统调用，而是一组exec函数构成。</p><p>可变长参数以<code>NULL</code>结尾。</p><h3 id="5-2-2-fork-系统调用"><a href="#5-2-2-fork-系统调用" class="headerlink" title="5.2.2 fork()系统调用"></a>5.2.2 fork()系统调用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/type.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>创建了一个子进程后，父进程会没有任何改变的继续运行下去，<code>execv()</code>会使子进程去运行<code>/bin/windlass</code></p><h4 id="5-2-2-1-写时复制"><a href="#5-2-2-1-写时复制" class="headerlink" title="5.2.2.1 写时复制"></a>5.2.2.1 写时复制</h4><p>早期UNIX系统为逐页复制。</p><p>现代UNIX系统如Linux，采用写时复制。</p><p>如果一个进程要修改自己的那份资源，那就复制一份，修改别的资源时只需要指向那个资源的指针。意思就是并不是完全复制父进程，部分资源就是指向父进程的资源，只有当要使用那份资源时才会复制。</p><p>好处: 如果进程从来就不需要修改资源，则不需要进行复制。</p><p>在<code>fork()</code>调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页。</p><p><mark>理解:</mark><br>所以共享地址空间的意思就是是同一段代码。</p><h4 id="5-2-2-2-vfork"><a href="#5-2-2-2-vfork" class="headerlink" title="5.2.2.2 vfork()"></a>5.2.2.2 vfork()</h4><h2 id="5-3-终止进程"><a href="#5-3-终止进程" class="headerlink" title="5.3 终止进程"></a>5.3 终止进程</h2><p>POSIX和C89都定义了终止当前进程的标准函数:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br>void <span class="hljs-keyword">exit</span>(int status);<br></code></pre></td></tr></table></figure><p>vfork()的使用者终止进程时必须使用<code>_exit()</code>, 而不是<code>exit()</code>.</p><h3 id="5-3-1-其他终止进程的方式"><a href="#5-3-1-其他终止进程的方式" class="headerlink" title="5.3.1 其他终止进程的方式"></a>5.3.1 其他终止进程的方式</h3><p>在<code>main()</code>函数返回时明确给出一个状态值，或者调用<code>exit()</code>是个良好的变成习惯。</p><h3 id="5-3-2-atexit"><a href="#5-3-2-atexit" class="headerlink" title="5.3.2 atexit()"></a>5.3.2 atexit()</h3><p>用来注册一些在进程结束时要调用的函数。</p><p>函数调用的顺序和注册顺序相反。也就是这些函数存储在栈中。</p><h3 id="5-3-4-SIGCHLD"><a href="#5-3-4-SIGCHLD" class="headerlink" title="5.3.4 SIGCHLD"></a>5.3.4 SIGCHLD</h3><p>当一个子进程终止时，内核会向其父进程发送SIGCHILD信号。</p><h2 id="5-4-等待终止的子进程"><a href="#5-4-等待终止的子进程" class="headerlink" title="5.4 等待终止的子进程"></a>5.4 等待终止的子进程</h2><p>处于这种状态的进程叫做僵死(zombie)进程，保留最小的概要信息。</p><p>只要父进程获取了子进程的信息，子进程就会消失，否则一直保持僵死状态。</p><p><code>wait()</code>返回已i终止子进程的pid.</p><h3 id="5-4-1-等待特定的进程"><a href="#5-4-1-等待特定的进程" class="headerlink" title="5.4.1 等待特定的进程"></a>5.4.1 等待特定的进程</h3><p><code>waitpid()</code>系统调用。</p><h3 id="5-4-1-等待特定进程"><a href="#5-4-1-等待特定进程" class="headerlink" title="5.4.1 等待特定进程"></a>5.4.1 等待特定进程</h3><h3 id="5-4-5-僵死进程"><a href="#5-4-5-僵死进程" class="headerlink" title="5.4.5 僵死进程"></a>5.4.5 僵死进程</h3><p>只要有进程结束了，内核就会遍历它的所有子进程，并且把他们的父进程重新设置为<code>init</code>进程。这保证了系统中没有不存在父进程的进程。</p><h2 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h2><p>用户ID和组ID分别用C语言deuid_t和gid_t这两个类型表示。</p><p>数字表示和字符表示是映射关系.</p><p>在Linux中，一个进程的用户ID和组ID代表这个进程可以执行哪些操作。</p><p>最好采用”最小权限”原则。</p><h3 id="5-5-1-实际用户-组-ID、有效用户-组-ID和保护设置用户-组-ID"><a href="#5-5-1-实际用户-组-ID、有效用户-组-ID和保护设置用户-组-ID" class="headerlink" title="5.5.1 实际用户(组)ID、有效用户(组)ID和保护设置用户(组)ID"></a>5.5.1 实际用户(组)ID、有效用户(组)ID和保护设置用户(组)ID</h3><p>与进程相关的用户ID有四个:</p><pre><code class="hljs">1. 实际用户ID, 运行这个进程的那个用户的uid2. 有效用户ID, 当前进程所使用的用户ID, 权限验证一般使用的值。3. 保存设置用户ID, 是进程原先的有效用户ID4. 文件系统用户ID</code></pre><h2 id="5-6-会话和进程组"><a href="#5-6-会话和进程组" class="headerlink" title="5.6 会话和进程组"></a>5.6 会话和进程组</h2><p>每个进程都属于某个进程组。</p><p>进程组的主要特征: 信号可以发送给进程中所有进程，这个信号可以使同一个进程组中的所有进程终止、停止或者继续运行。</p><p>每个进程组都由进程组ID(pgid)唯一标识。</p><p>进程组ID就是组长进程的ID. 只要进程组中还有一个进程存在，则该进程组就存在。</p><p>一个会话就是一个或多个进程组，会话的功能和shell差不多。</p><p>进程组提供了向其中所有进程发送信号的机制，会话则将登录与控制终端联系起来。</p><p>进程组中直接与用户打交道并且控制终端为前台进程组，其他都是后台进程组。</p><p>守护进程会创建自己的会话。</p><h2 id="5-7-守护进程"><a href="#5-7-守护进程" class="headerlink" title="5.7 守护进程"></a>5.7 守护进程</h2><p>守护进程运行在后台，不与任何控制终端相关联。</p><p>习惯上守护进程的名字通常以d结尾。</p><p>这个名字来源于麦克斯韦妖(Maxwell’s demon). 希腊神话中的demon是神的助手，做一些奥林匹斯山的居民自己不愿意做的事.</p><p>守护进程的两个基本要求:</p><pre><code class="hljs">1. 必须是init进程的子进程2. 不与任何控制终端相关联</code></pre><h1 id="第六章-高级进程管理"><a href="#第六章-高级进程管理" class="headerlink" title="第六章 高级进程管理"></a>第六章 高级进程管理</h1><h2 id="6-1-进程调度"><a href="#6-1-进程调度" class="headerlink" title="6.1 进程调度"></a>6.1 进程调度</h2><p>进程调度器是把有限的处理器资源分配给进程的内核子系统，是内核中决定哪个进程可以运行的组件。</p><p>多任务操作系统可以分为两大类:</p><pre><code class="hljs">1. 协同式2. 抢占式</code></pre><p>Linux实现了后一种形式的多任务，调度器可以要求一个进程停止运行，处理器转而运行另一个程序。</p><p>在协同多任务系统中，一个进程持续运行直到它自发停止。</p><h3 id="6-1-1-大O记法"><a href="#6-1-1-大O记法" class="headerlink" title="6.1.1 大O记法"></a>6.1.1 大O记法</h3><p>形式地定义:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">if f(<span class="hljs-keyword">x</span>) is O(g(<span class="hljs-keyword">x</span>))<br><br>then<br><br>存在<span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">x</span><span class="hljs-number">1</span> such that f(<span class="hljs-keyword">x</span>) &lt;<span class="hljs-operator">=</span> <span class="hljs-keyword">c</span> * g(<span class="hljs-keyword">x</span>)<span class="hljs-punctuation">,</span> 对于任意<span class="hljs-keyword">x</span>&gt;<span class="hljs-keyword">x</span><span class="hljs-number">1</span>都成立<br></code></pre></td></tr></table></figure><h3 id="6-1-2-时间片"><a href="#6-1-2-时间片" class="headerlink" title="6.1.2 时间片"></a>6.1.2 时间片</h3><p>进程不一定要在一次运行中耗光所有时间片。</p><h3 id="6-1-3-I-x2F-O约束进程-VS-处理器约束进程"><a href="#6-1-3-I-x2F-O约束进程-VS-处理器约束进程" class="headerlink" title="6.1.3 I&#x2F;O约束进程 VS 处理器约束进程"></a>6.1.3 I&#x2F;O约束进程 VS 处理器约束进程</h3><p>持续地消耗所有可用时间片的进程称为”处理器约束进程”.</p><p>多数时间处于等待资源的阻塞状态的进程称为”I&#x2F;O约束进程”.</p><h3 id="6-1-4-抢占调度"><a href="#6-1-4-抢占调度" class="headerlink" title="6.1.4 抢占调度"></a>6.1.4 抢占调度</h3><p>UNIX调度中一条重要原则: 所有的进程必须运行。</p><h3 id="6-1-5-线程"><a href="#6-1-5-线程" class="headerlink" title="6.1.5 线程"></a>6.1.5 线程</h3><p>本质上，内核没有线程概念，对于Linux内核来说，所有的线程都是独立的进程。</p><p>共享同一地址空间，即同样的动态内存，映射文件，目标代码等。</p><h2 id="6-2-让出处理器"><a href="#6-2-让出处理器" class="headerlink" title="6.2 让出处理器"></a>6.2 让出处理器</h2><h2 id="6-3-进程优先级"><a href="#6-3-进程优先级" class="headerlink" title="6.3 进程优先级"></a>6.3 进程优先级</h2><p>历史上, Unix把这个优先级称为”nice value”.</p><p>Linux调度器基于这样的原则来调度: 高优先级的程序总是先运行。 同时，nice值也指明了进程的时间片长度。</p><p>合法的优先级在-20到19之间，默认为零。nice值越低, 优先级越高，时间片越长.</p><h3 id="6-3-3-I-x2F-O优先级"><a href="#6-3-3-I-x2F-O优先级" class="headerlink" title="6.3.3 I&#x2F;O优先级"></a>6.3.3 I&#x2F;O优先级</h3><h3 id="6-4-处理器亲和度"><a href="#6-4-处理器亲和度" class="headerlink" title="6.4 处理器亲和度"></a>6.4 处理器亲和度</h3><p>进程调度器必须解决两个问题:</p><pre><code class="hljs">1. 必须充分利用系统的处理器2. 尽量避免处理器空闲</code></pre><p>如果进程曾在某一CPU上运行，进程调度器还应该尽量把它放在同一CPU上。</p><p>处理器亲和度表明一个进程停留在统一处理器上的可能性。</p><p>“软亲和度(soft affinity)”表明调度器持续调度进程到同一处理器上的自然倾向。</p><p>“硬亲和度(hard affinity)”描述了强制内核保证进程到处理器的绑定。</p><h2 id="6-5-实时系统"><a href="#6-5-实时系统" class="headerlink" title="6.5 实时系统"></a>6.5 实时系统</h2><p>如果一个系统受到操作期限(请求与响应之间的最小量和命令次数)的支配，就称该系统是”实时”的。</p><h3 id="6-5-1-软硬实时系统"><a href="#6-5-1-软硬实时系统" class="headerlink" title="6.5.1 软硬实时系统"></a>6.5.1 软硬实时系统</h3><p>硬实时系统对于操作期限要求非常严格，超过期限就会产生失败。</p><p>软实时系统不认为超过期限是一个严重的失败。</p><h3 id="6-5-2-延时，抖动和截止期限"><a href="#6-5-2-延时，抖动和截止期限" class="headerlink" title="6.5.2 延时，抖动和截止期限"></a>6.5.2 延时，抖动和截止期限</h3><h1 id="第七章-文件与目录管理"><a href="#第七章-文件与目录管理" class="headerlink" title="第七章 文件与目录管理"></a>第七章 文件与目录管理</h1><h2 id="7-1-文件及其元数据"><a href="#7-1-文件及其元数据" class="headerlink" title="7.1 文件及其元数据"></a>7.1 文件及其元数据</h2><p>inode存储了与文件有关的元数据, 如文件的访问权限，最后访问时间，所有者，所有组，大小以及文件数据的存储位置。</p><p>结构stat存储了文件信息. </p><h1 id="第八章-内存管理"><a href="#第八章-内存管理" class="headerlink" title="第八章 内存管理"></a>第八章 内存管理</h1><h2 id="8-1-进程地址空间"><a href="#8-1-进程地址空间" class="headerlink" title="8.1 进程地址空间"></a>8.1 进程地址空间</h2><p>虚拟地址空间(virtual address space)是线性的，从0开始，到某个最大值。</p><h3 id="8-1-1-页和页面调度"><a href="#8-1-1-页和页面调度" class="headerlink" title="8.1.1 页和页面调度"></a>8.1.1 页和页面调度</h3><p>虚拟空间由许多页组成。</p><p>每个页面都只有无效(invalid)和有效(valid)两种状态。</p><p>一般来说虚拟存储器总比物理内存大。</p><h3 id="8-1-2-存储器区域"><a href="#8-1-2-存储器区域" class="headerlink" title="8.1.2 存储器区域"></a>8.1.2 存储器区域</h3><p>内核将具有某些相同特征的页组织成块(blocks), 这些块叫做存储器区域(memory regions), 段(segments), 或者映射(mappings).</p><p>在每个进程中都可以见到的存储器区段:</p><pre><code class="hljs">  - 文本段(text segment).  - 堆栈段(stack).  - 数据段(data segment)，又叫堆(heap).  - BSS段(bss segment).  - 大多数地址空间含有很多映射文件.</code></pre><h2 id="8-2-动态内存分配"><a href="#8-2-动态内存分配" class="headerlink" title="8.2 动态内存分配"></a>8.2 动态内存分配</h2><p>C不支持动态内存的变量。</p><p>C提供了一种机制在动态内存中分配一个足够大的空间保存结构体<code>pirate_ship</code>.</p><p>调用<code>malloc()</code>时，C都会自动地把返回值由void指针转变为需要的类型，但是C++并不提供这种自动转换。</p><p>许多程序都定义和使用封装后的<code>malloc()</code>, 当<code>malloc()</code>返回NULL时就打印错误和终止程序，根据约定，程序员们把这个封装叫做<code>xmalloc()</code>:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* like malloc(), but terminates on failure */</span><br>void *xmalloc(size_t size)<br>&#123;<br>  void *p;<br>  p = malloc(size);<br>  <span class="hljs-keyword">if</span> (!p) &#123;<br>    perror(<span class="hljs-string">&quot;xmalloc&quot;</span>);<br>    <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>  &#125;<br>  return p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-1-数组分配"><a href="#8-2-1-数组分配" class="headerlink" title="8.2.1 数组分配"></a>8.2.1 数组分配</h3><p><code>calloc</code>将分配区域全部用0进行初始化。</p><p>可定义一个简单的接口:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">malloc0</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, size);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-2-调整已分配内存大小"><a href="#8-2-2-调整已分配内存大小" class="headerlink" title="8.2.2 调整已分配内存大小"></a>8.2.2 调整已分配内存大小</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><p>如果size是0, 效果就会跟在ptr上调用free()相同。</p><p>如果ptr是NULL，结果就会跟malloc()一样。</p><h3 id="8-2-3-动态内存的释放"><a href="#8-2-3-动态内存的释放" class="headerlink" title="8.2.3 动态内存的释放"></a>8.2.3 动态内存的释放</h3><p>自动内存分配，当栈不在使用，空间被自动释放。</p><p>动态内存将永久占有一个进程地址空间的一部分，直到它被显式地释放。</p><p>当整个进程都退出时，所有动态和静态的存储器都荡然无存。 </p><p>调用free()时并不需要检查ptr是否为NULL.</p><h3 id="8-2-4-对齐"><a href="#8-2-4-对齐" class="headerlink" title="8.2.4 对齐"></a>8.2.4 对齐</h3><p>数据的对齐(alignment)是指数据地址和硬件确定的内存块之间的关系。</p><p>一个变量的地址是它大小的倍数时，就叫做自然对齐(naturally aligned).</p><p>在编写可移植的代码的时候，对齐的问题一定要注意，所有的类型都应该保持自然对齐。</p><h4 id="8-2-4-1-预对齐内存的分配"><a href="#8-2-4-1-预对齐内存的分配" class="headerlink" title="8.2.4.1 预对齐内存的分配"></a>8.2.4.1 预对齐内存的分配</h4><p>大多数情况下，编译器和C库会自动处理对齐问题。</p><h4 id="8-2-4-2-其它对齐问题"><a href="#8-2-4-2-其它对齐问题" class="headerlink" title="8.2.4.2 其它对齐问题"></a>8.2.4.2 其它对齐问题</h4><p>非标准类型，四条有用的规则:</p><pre><code class="hljs">- 一个结构的对齐要求和它成员中最大的那个类型是一样的。- 结构体也引入了对填充的要求，以此来保证每一个成员都符合各自的对其要求。注意一下结构体中成员变量的顺序, 来减少填充所导致的空间浪费。- 一个联合的对齐和联合里最大的类型一致。- 一个数组的对齐和数组里的元素类型一致。</code></pre><h2 id="8-3-数据段的管理"><a href="#8-3-数据段的管理" class="headerlink" title="8.3 数据段的管理"></a>8.3 数据段的管理</h2><p>堆和栈的分界线叫做中断(break)或中断点(break point).</p><h2 id="8-4-匿名存储器映射"><a href="#8-4-匿名存储器映射" class="headerlink" title="8.4 匿名存储器映射"></a>8.4 匿名存储器映射</h2><p>实现malloc()最经典方法就是将数据段分为一系列的大小为2的幂的块，返回最小的符合要求的那个块来满足请求。</p><p>释放则是简单的将这块区域标记为未使用.</p><p>一个匿名内存映射只是一块已经用0初始化的大的内存块，以供用户使用，其不基于堆。因其和基于文件的映射相似，但并不基于文件，所以称为匿名。</p><p>匿名内存映射用于满足大的分配。</p><h3 id="8-4-1-创建匿名存储器映射"><a href="#8-4-1-创建匿名存储器映射" class="headerlink" title="8.4.1 创建匿名存储器映射"></a>8.4.1 创建匿名存储器映射</h3><h2 id="8-5-高级存储器分配"><a href="#8-5-高级存储器分配" class="headerlink" title="8.5 高级存储器分配"></a>8.5 高级存储器分配</h2><h2 id="8-6-调试内存分配"><a href="#8-6-调试内存分配" class="headerlink" title="8.6 调试内存分配"></a>8.6 调试内存分配</h2><h2 id="8-7-基于栈的分配"><a href="#8-7-基于栈的分配" class="headerlink" title="8.7 基于栈的分配"></a>8.7 基于栈的分配</h2><p>栈，用来存放程序的自动变量(automatic variables).</p><h2 id="8-9-存储器操作"><a href="#8-9-存储器操作" class="headerlink" title="8.9 存储器操作"></a>8.9 存储器操作</h2><h2 id="8-10-内存锁定"><a href="#8-10-内存锁定" class="headerlink" title="8.10 内存锁定"></a>8.10 内存锁定</h2><h3 id="8-11-1-超量使用和内存耗尽"><a href="#8-11-1-超量使用和内存耗尽" class="headerlink" title="8.11.1 超量使用和内存耗尽"></a>8.11.1 超量使用和内存耗尽</h3><p>分配到的内存比实际物理内存甚至比可用的交换空间多得多叫超量使用(overcommitment).</p><p>当超量使用导致内存不足以满足一个请求时, 我们就说发生了内存耗尽(OOM)(out of memory). 为了处理OOM，内核会使用killer挑选一个进程并终止它。</p><h1 id="第九章-信号"><a href="#第九章-信号" class="headerlink" title="第九章 信号"></a>第九章 信号</h1><p>信号是提供处理异步事件机制的软件中断。</p><h2 id="9-1-信号概念"><a href="#9-1-信号概念" class="headerlink" title="9.1 信号概念"></a>9.1 信号概念</h2><p>信号有一个非常明确的生命周期。</p><h3 id="9-1-1-信号标识符"><a href="#9-1-1-信号标识符" class="headerlink" title="9.1.1 信号标识符"></a>9.1.1 信号标识符</h3><p>每个信号都有一个以<code>SIG</code>为前缀的符号名称。</p><p>这些信号都在<code>&lt;signal.h&gt;</code>头文件中定义的。</p><p>信号被预处理程序简单的定义为正整数，也就是说，每个信号都与一个正整数标识符相关联。</p><p>一个好的程序员因该总是使用信号的可读名称。</p><h2 id="9-2-基本信号管理"><a href="#9-2-基本信号管理" class="headerlink" title="9.2 基本信号管理"></a>9.2 基本信号管理</h2><h2 id="9-9-结论"><a href="#9-9-结论" class="headerlink" title="9.9  结论"></a>9.9  结论</h2><p>信号是从内核接受许多通知的唯一方式。</p><p>信号还是UNIX(Linux)终止进程和管理父&#x2F;子进程关系的方式。</p><h1 id="第十章-时间"><a href="#第十章-时间" class="headerlink" title="第十章 时间"></a>第十章 时间</h1>]]></content>
    
    
    <categories>
      
      <category>Operate System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux Command Line and Shell Scripting Bible Notes</title>
    <link href="/2022/07/17/Linux-Command-Line-and-Shell-Scripting-Bible-Notes/"/>
    <url>/2022/07/17/Linux-Command-Line-and-Shell-Scripting-Bible-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第十一章-构建基本脚本"><a href="#第十一章-构建基本脚本" class="headerlink" title="第十一章 构建基本脚本"></a>第十一章 构建基本脚本</h1><h2 id="11-4-使用变量"><a href="#11-4-使用变量" class="headerlink" title="11.4 使用变量"></a>11.4 使用变量</h2><p>多个命令在同一行执行，使用分号隔开:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> ; <span class="hljs-built_in">who</span></span><br></code></pre></td></tr></table></figure><p>如果文本文件开头的最前面两个字符是<code>#!</code>，那么后面跟着的就是用来执行这个文件的程序路径.</p><p>shell 通过PATH环境变量来查找命令.</p><p>引用当前目录下的文件，可以使用shell中使用单点操作符:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./test1</span><br></code></pre></td></tr></table></figure><p>对于文件而言，全权限值为666, 对于目录而言，全权限值为777.</p><p>默认权限值为全权限值减去umask变量的值.</p><h3 id="11-4-2-用户变量"><a href="#11-4-2-用户变量" class="headerlink" title="11.4.2 用户变量"></a>11.4.2 用户变量</h3><p>在变量、等号和值之间不能出现空格.</p><p>shell 脚本会自动决定变量值的数据类型.</p><p>引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时不要使用美元符:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">value1</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">value2</span>=<span class="hljs-variable">$value1</span><br></code></pre></td></tr></table></figure><p>没有美元符，shell会将变量名解释成普通的文本字符串.</p><h3 id="11-4-3-命令替换"><a href="#11-4-3-命令替换" class="headerlink" title="11.4.3 命令替换"></a>11.4.3 命令替换</h3><p>命令替换允许你将shell命令的输出赋给变量, 有两个格式:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">反引号字符<span class="hljs-comment">(`)</span><br>$<span class="hljs-comment">()</span>格式<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">testing</span>=`date`<br><span class="hljs-attr">testing</span>=$(date)<br></code></pre></td></tr></table></figure><p>命令替换会创建一个子shell来运行对应的命令.</p><h2 id="11-5-重定向输入和输出"><a href="#11-5-重定向输入和输出" class="headerlink" title="11.5 重定向输入和输出"></a>11.5 重定向输入和输出</h2><h2 id="11-7-执行数学运算"><a href="#11-7-执行数学运算" class="headerlink" title="11.7 执行数学运算"></a>11.7 执行数学运算</h2><h3 id="11-7-1-expr命令"><a href="#11-7-1-expr命令" class="headerlink" title="11.7.1 expr命令"></a>11.7.1 expr命令</h3><p>expr命令允许在命令行上处理数学表达式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">expr</span> 1 + 5</span><br></code></pre></td></tr></table></figure><p>对于那些容易被shell错误解释的字符，在它们传入expr命令之前，需要使用shell的转义字符将其标出来:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">expr</span> 1 \* 5</span><br></code></pre></td></tr></table></figure><h3 id="11-7-2-使用方括号"><a href="#11-7-2-使用方括号" class="headerlink" title="11.7.2 使用方括号"></a>11.7.2 使用方括号</h3><p>在bash中，在将一个数学运算结果赋给某个变量时，可以使用美元符和方括号($[ operation ])将数学表达式围起来:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>var1=<span class="hljs-variable">$[</span><span class="hljs-number">1</span> + <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>不用担心shell会误解.</p><p>bash shell 数学运算符只支持整数运算.</p><p>z shell 提供了完整的浮点运算。</p><h3 id="11-7-3-浮点解决方案"><a href="#11-7-3-浮点解决方案" class="headerlink" title="11.7.3 浮点解决方案"></a>11.7.3 浮点解决方案</h3><p>使用bash内建的计算器bc.</p><p>可以在shell提示符下通过<code>bc</code>命令访问bash计算器.</p><p>浮点运算是由内建变量<code>scale</code>控制，用于设置你希望在计算结果中保留的小数位数.</p><p>使用<code>-q</code>命令行选项可以不显示bash计算器的欢迎信息.</p><h4 id="在脚本中使用bc"><a href="#在脚本中使用bc" class="headerlink" title="在脚本中使用bc"></a>在脚本中使用bc</h4><p>利用命令替换, 基本格式如下:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">variable=<span class="hljs-constructor">$(<span class="hljs-params">echo</span> <span class="hljs-string">&quot;options; expression&quot;</span> | <span class="hljs-params">bc</span>)</span><br></code></pre></td></tr></table></figure><p>使用那联输入重定向(inline input redirection), 需指定一个文本标记来划分输入数据的开始和结尾，文本标记可以为任意字符串:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &lt;&lt; <span class="hljs-string">marker</span><br><span class="hljs-string">data</span><br><span class="hljs-string">marker</span><br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">variable=$(bc &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">options</span><br><span class="hljs-string">statements</span><br><span class="hljs-string">expressions</span><br><span class="hljs-string">EOF</span><br>)<br></code></pre></td></tr></table></figure><p>在bash计算器中创建的变量只在bash计算其中有效，不能在shell脚本中使用.</p><h2 id="11-8-退出脚本"><a href="#11-8-退出脚本" class="headerlink" title="11.8 退出脚本"></a>11.8 退出脚本</h2><p>退出状态码(exit status)，一个0～255的整数值.</p><h3 id="11-8-1-查看退出状态码"><a href="#11-8-1-查看退出状态码" class="headerlink" title="11.8.1 查看退出状态码"></a>11.8.1 查看退出状态码</h3><p>变量<code>$?</code>来保存上个已执行命令的退出状态码.</p><p>成功结束的命令的退出状态码是0.</p><p>无效命令会返回一个exit status为127.</p><p>exit status为126表示用户没有执行命令的正确权限。</p><h3 id="11-8-2-exit命令"><a href="#11-8-2-exit命令" class="headerlink" title="11.8.2 exit命令"></a>11.8.2 exit命令</h3><p>指定exit status退出.</p><h1 id="第12章-使用结构化命令"><a href="#第12章-使用结构化命令" class="headerlink" title="第12章 使用结构化命令"></a>第12章 使用结构化命令</h1><h2 id="12-1-使用if-then语句"><a href="#12-1-使用if-then语句" class="headerlink" title="12.1 使用if-then语句"></a>12.1 使用if-then语句</h2><p>格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span> <br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>查看<code>if</code>后面<code>command</code>的exit status, 是0, 则执行.</p><p><code>then</code>部分可以有多条命令.</p><h2 id="12-2-if-then-else语句"><a href="#12-2-if-then-else语句" class="headerlink" title="12.2 if-then-else语句"></a>12.2 if-then-else语句</h2><p>格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">else</span> <br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">if</span><br></code></pre></td></tr></table></figure><p><code>else</code>部分也可以包含多条命令.</p><h2 id="12-3-嵌套if"><a href="#12-3-嵌套if" class="headerlink" title="12.3 嵌套if"></a>12.3 嵌套if</h2><p>使用嵌套的<code>if-then</code>语句.</p><p>使用<code>elif</code>语句:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span><br>   commands<br><span class="hljs-keyword">elif</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span> <br>   commands<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h2 id="12-4-test-命令"><a href="#12-4-test-命令" class="headerlink" title="12.4 test 命令"></a>12.4 test 命令</h2><p>运用<code>test</code>命令通过<code>if-then</code>语句测试其他条件.</p><p>如果<code>test</code>命令中列出的条件成立，<code>test</code>命令就会退出并返回exit status 0.</p><p>格式:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">test </span>condition<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> condition<br><span class="hljs-keyword">then</span><br>   commands<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>如果不写test命令的<code>condition</code>部分，它会以非零的退出状态码退出，并执行else语句快.</p><p>可以用test命令确定变量中是否有内容.</p><p>另一种测试方法，不需用test命令:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span><span class="hljs-meta"> [ condition ]</span><br><span class="hljs-attribute">then</span><br>   <span class="hljs-attribute">commands</span><br><span class="hljs-attribute">fi</span><br></code></pre></td></tr></table></figure><p>注意第一个方括号之后和第二个方括号之前必须加上一个空格.</p><p>test命令可以判断三类条件:</p><pre><code class="hljs">1. 数值比较2. 字符串比较3. 文件比较</code></pre><h3 id="12-4-1-数值比较"><a href="#12-4-1-数值比较" class="headerlink" title="12.4.1 数值比较"></a>12.4.1 数值比较</h3><p>不能在test命令中使用浮点值。</p><h3 id="12-4-2-字符串比较"><a href="#12-4-2-字符串比较" class="headerlink" title="12.4.2 字符串比较"></a>12.4.2 字符串比较</h3><pre><code class="hljs">1. 比较时大于号和小于号必须转义。2. 大于和小于顺序和sort命令采取的不同。比较使用的是ASCII顺序, 小写大于大写。sort命令使用的是本地英语，小写字母出现在大写字母之前.</code></pre><p>使用<code>-n</code>和<code>-z</code>参数检查一个变量是否含有数据:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">if</span> [ -n <span class="hljs-variable">$var1</span> ]<br></code></pre></td></tr></table></figure><p>空的和未初始化的变量会对shell脚本测试造成灾难性的影响.</p><h3 id="12-4-3-文件比较"><a href="#12-4-3-文件比较" class="headerlink" title="12.4.3 文件比较"></a>12.4.3 文件比较</h3><p>测试Linux文件系统上文件和目录的状态.</p><p>还是使用参数比较.</p><h2 id="12-5-复合条件测试"><a href="#12-5-复合条件测试" class="headerlink" title="12.5 复合条件测试"></a>12.5 复合条件测试</h2><p>有两种布尔运算符可用:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">[ co<span class="hljs-symbol">ndition1</span> ] || [ co<span class="hljs-symbol">ndition2</span> ]<br>[ co<span class="hljs-symbol">ndition1</span> ] &amp;&amp; [ co<span class="hljs-symbol">ndition2</span> ]<br></code></pre></td></tr></table></figure><h2 id="12-6-if-then-的高级特性"><a href="#12-6-if-then-的高级特性" class="headerlink" title="12.6 if-then 的高级特性"></a>12.6 if-then 的高级特性</h2><p>bash shell 提供了两项可在 if-then 语句中使用的高级特性:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 用于数学表达式的双括号<br><span class="hljs-bullet">2.</span> 用于高级字符串处理功能的双方括号<br></code></pre></td></tr></table></figure><h3 id="12-6-1-使用双括号"><a href="#12-6-1-使用双括号" class="headerlink" title="12.6.1 使用双括号"></a>12.6.1 使用双括号</h3><p>格式:</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(( expression ))<br></code></pre></td></tr></table></figure><p>不需要将双括号中表达式里的大于号转义。</p><h3 id="12-6-2-使用双方括号"><a href="#12-6-2-使用双方括号" class="headerlink" title="12.6.2 使用双方括号"></a>12.6.2 使用双方括号</h3><p>格式:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[ expression ]]</span><br></code></pre></td></tr></table></figure><p>这里的<code>expression</code>使用了test命令中的标准字符串比较，但它提供了模式匹配 pattern matching.</p><p>这里用双等号<code>==</code>其右侧为一个正则表达式.</p><h2 id="12-7-case-命令"><a href="#12-7-case-命令" class="headerlink" title="12.7 case 命令"></a>12.7 case 命令</h2><p>case 命令采用列表格式来检查单个变量的多个值。</p><p>格式：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">case <span class="hljs-keyword">variable</span> in <br>pattern1 | <span class="hljs-comment">pattern2) command1</span>;;<br>pattern3) command2;;<br><span class="hljs-comment">*) default command3;;</span><br>esac<br></code></pre></td></tr></table></figure><p>case 命令会将指定的变量与不同模式进行比较，如果变量和模式是匹配的，那么shell会执行该模式指定的命令.</p><h1 id="13-更多的结构化命令"><a href="#13-更多的结构化命令" class="headerlink" title="13 更多的结构化命令"></a>13 更多的结构化命令</h1><h2 id="13-1-for-命令"><a href="#13-1-for-命令" class="headerlink" title="13.1 for 命令"></a>13.1 for 命令</h2><p>格式:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">for</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">in</span> list <br><span class="hljs-keyword">do</span><br>    commands<br>done<br></code></pre></td></tr></table></figure><h3 id="13-1-2-读取列表中的复杂值"><a href="#13-1-2-读取列表中的复杂值" class="headerlink" title="13.1.2 读取列表中的复杂值"></a>13.1.2 读取列表中的复杂值</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 使用转义字符来将单引号转义<br><span class="hljs-bullet">2.</span> 使用双引号来定义用到单引号的值<br></code></pre></td></tr></table></figure><p>如:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> I don<span class="hljs-string">\&#x27;t</span> know <span class="hljs-literal">it</span> <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;this&#x27;ll&quot;</span> work<br></code></pre></td></tr></table></figure><p>在某个值的两边使用双引号时，shell并不会将双引号当成值的一部分.</p><h3 id="13-1-3-从变量读取列表"><a href="#13-1-3-从变量读取列表" class="headerlink" title="13.1.3 从变量读取列表"></a>13.1.3 从变量读取列表</h3><h3 id="13-1-4-从命令读取值"><a href="#13-1-4-从命令读取值" class="headerlink" title="13.1.4 从命令读取值"></a>13.1.4 从命令读取值</h3><h3 id="13-1-5-更改字段分隔符"><a href="#13-1-5-更改字段分隔符" class="headerlink" title="13.1.5 更改字段分隔符"></a>13.1.5 更改字段分隔符</h3><p>环境变量<code>IFS</code>, Internal Field Separator. 定义了bash shell 用作字段分隔符的一系列字符.</p><p>默认为:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">空格<br>制表符<br>换行符<br></code></pre></td></tr></table></figure><p>更改为只识别换行符:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IFS</span>=$<span class="hljs-string">&#x27;\n&#x27;</span><br></code></pre></td></tr></table></figure><p>在改变IFS之前保存原来的IFS值:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">IFS.<span class="hljs-attribute">OLD</span>=<span class="hljs-variable">$IFS</span><br><span class="hljs-attribute">IFS</span>=$&#x27;\n&#x27;<br><span class="hljs-built_in">..</span>.<br><span class="hljs-attribute">IFS</span>=IFS.OLD<br></code></pre></td></tr></table></figure><p>指定多个字符:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IFS</span>=$<span class="hljs-string">&#x27;\n&#x27;</span>:<span class="hljs-comment">;&quot;</span><br></code></pre></td></tr></table></figure><p>直接串起来.</p><h2 id="13-2-C语言风格的for命令"><a href="#13-2-C语言风格的for命令" class="headerlink" title="13.2 C语言风格的for命令"></a>13.2 C语言风格的for命令</h2><p>和C语言风格的类似，但有一些细微的不同, 基本格式:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">for <span class="hljs-comment">(( variable assignment ; condition ; iteration process )</span>)<br><span class="hljs-keyword">do</span><br>... <br><span class="hljs-keyword">do</span><span class="hljs-symbol">ne</span><br></code></pre></td></tr></table></figure><p>没有遵循bash shell标准的for命令:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 变量赋值可以有空格<br><span class="hljs-bullet">2.</span> 条件中变量不以美元符开头<br><span class="hljs-bullet">3.</span> 迭代过程的算式未用expr命令格式<br></code></pre></td></tr></table></figure><h2 id="13-3-while-命令"><a href="#13-3-while-命令" class="headerlink" title="13.3 while 命令"></a>13.3 while 命令</h2><p>格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">test</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">do</span><br>  other commmand<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="13-3-2-定义多个测试命令"><a href="#13-3-2-定义多个测试命令" class="headerlink" title="13.3.2 定义多个测试命令"></a>13.3.2 定义多个测试命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span><br>       [ <span class="hljs-variable">$var1</span> -ge 0 ]<br></code></pre></td></tr></table></figure><p>只有最后一个测试命令的exit status用来决定退出.</p><p>每个测试命令都出现在单独的一行。</p><p>在每次迭代中所有的测试命令都会被执行, 包括测试命令失败的那一次迭代，其测试条件依然会全部执行.</p><h2 id="13-4-until-命令"><a href="#13-4-until-命令" class="headerlink" title="13.4 until 命令"></a>13.4 until 命令</h2><p>只有测试命令的exit status不为0, bash shell才会执行循环内的命令，其工作模式和while相反, 即测试条件成功时退出.</p><p>格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">until <span class="hljs-built_in">test</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">do</span><br>  other commands<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="13-7-控制循环"><a href="#13-7-控制循环" class="headerlink" title="13.7 控制循环"></a>13.7 控制循环</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">break</span>, 终止某层循环<br><span class="hljs-keyword">continue</span>, 终止某次循环<br></code></pre></td></tr></table></figure><p>特殊用法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">break</span> n<br></code></pre></td></tr></table></figure><p>n指定了要跳出的循环层级, 默认情况下n为1.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">continue</span> n<br></code></pre></td></tr></table></figure><h2 id="13-8-处理循环的输出"><a href="#13-8-处理循环的输出" class="headerlink" title="13.8 处理循环的输出"></a>13.8 处理循环的输出</h2><p>通过在done命令之后添加一个处理命令实现:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> /home/rich/*<br><span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> ]<br>  <span class="hljs-keyword">then</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a directory&quot;</span><br>  <span class="hljs-keyword">elif</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a file&quot;</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span> &gt; output.txt<br></code></pre></td></tr></table></figure><h2 id="13-9-实例"><a href="#13-9-实例" class="headerlink" title="13.9 实例"></a>13.9 实例</h2><h3 id="13-9-1-查找可执行文件"><a href="#13-9-1-查找可执行文件" class="headerlink" title="13.9.1 查找可执行文件"></a>13.9.1 查找可执行文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># finding files in the PATH</span><br><br>IFS=:<br><span class="hljs-keyword">for</span> folder <span class="hljs-keyword">in</span> <span class="hljs-variable">$PATH</span><br><span class="hljs-keyword">do</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$folder</span>:&quot;</span><br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-variable">$folder</span>/*<br>    <span class="hljs-keyword">do</span> <br>        <span class="hljs-keyword">if</span> [ -x <span class="hljs-variable">$file</span> ]<br>        <span class="hljs-keyword">then</span> <br>           <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;   <span class="hljs-variable">$file</span>&quot;</span><br>        <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="13-9-2-创建多个用户账户"><a href="#13-9-2-创建多个用户账户" class="headerlink" title="13.9.2 创建多个用户账户"></a>13.9.2 创建多个用户账户</h3><p>把数据从文件中送入while命令, 在while命令尾部使用一个重定向符就可以了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># process new user accounts</span><br><br>input=<span class="hljs-string">&quot;users.csv&quot;</span><br><span class="hljs-keyword">while</span> IFS=<span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-built_in">read</span> -r userid name<br><span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;adding <span class="hljs-variable">$userid</span>&quot;</span><br>  useradd -c <span class="hljs-string">&quot;<span class="hljs-variable">$name</span>&quot;</span> -m <span class="hljs-variable">$userid</span><br><span class="hljs-keyword">done</span> &lt; <span class="hljs-string">&quot;<span class="hljs-variable">$input</span>&quot;</span><br></code></pre></td></tr></table></figure><h1 id="第十四章-处理用户输入"><a href="#第十四章-处理用户输入" class="headerlink" title="第十四章 处理用户输入"></a>第十四章 处理用户输入</h1><h2 id="14-1-命令行参数"><a href="#14-1-命令行参数" class="headerlink" title="14.1 命令行参数"></a>14.1 命令行参数</h2><h3 id="14-1-1-读取参数"><a href="#14-1-1-读取参数" class="headerlink" title="14.1.1 读取参数"></a>14.1.1 读取参数</h3><p>positional parameter, 位置参数，一个特殊变量，由bash shell分配给输入到命令行的所有参数.</p><p>$0是程序名，$1是第一个参数，直到$9.</p><p>将文本字符串作为参数传递时，引号并非数据得一部分, 它们只是表明数据的起始位置.</p><p>在第九个变量之后，必须在变量数字周围加上花括号, 如${10}.</p><h3 id="14-1-2-读取脚本名"><a href="#14-1-2-读取脚本名" class="headerlink" title="14.1.2 读取脚本名"></a>14.1.2 读取脚本名</h3><p>当传给$0变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量$0就会使用整个路径.</p><p><code>basename</code>命令会返回不包含路径的脚本名.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">name</span>=$(basename <span class="hljs-variable">$0</span>)<br></code></pre></td></tr></table></figure><h3 id="14-1-3-测试参数"><a href="#14-1-3-测试参数" class="headerlink" title="14.1.3 测试参数"></a>14.1.3 测试参数</h3><p>在使用参数前一定要检查其中是否存在数据。</p><h2 id="14-2-特殊参数变量"><a href="#14-2-特殊参数变量" class="headerlink" title="14.2 特殊参数变量"></a>14.2 特殊参数变量</h2><h3 id="14-2-1-参数统计"><a href="#14-2-1-参数统计" class="headerlink" title="14.2.1 参数统计"></a>14.2.1 参数统计</h3><p>特殊变量<code>$#</code>记录命令行参数的个数.</p><p>通过使用前测试参数的总数:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">if</span> [ <span class="hljs-symbol">$</span># -<span class="hljs-keyword">ne</span> <span class="hljs-number">2</span> ]<br></code></pre></td></tr></table></figure><p>同时，<code>$&#123;!#&#125;</code>表示最后一个命令行参数. 在花括号内不能使用美元符号，需将其替换为<code>!</code>.</p><h3 id="14-2-2-抓取所有的数据"><a href="#14-2-2-抓取所有的数据" class="headerlink" title="14.2.2 抓取所有的数据"></a>14.2.2 抓取所有的数据</h3><p><code>$*</code>变量会将命令行上提供的所有参数当作一个单词保存.</p><p><code>$@</code>变量会将命令行上提供的所有参数当作统一字符串中的多个独立的单词.</p><p>注意使用时添加双引号.</p><h2 id="14-3-移动变量"><a href="#14-3-移动变量" class="headerlink" title="14.3 移动变量"></a>14.3 移动变量</h2><p><code>shift</code>命令，将每个参数变量向左移动一个位置，$0不会改变.</p><p>给<code>shift</code>命令提供参数，可以一次移动多个位置.</p><h2 id="14-4-处理选项"><a href="#14-4-处理选项" class="headerlink" title="14.4 处理选项"></a>14.4 处理选项</h2><p>选项是跟在单破折号后面的单个字母，他能改变命令的行为。</p><h3 id="14-4-1-查找选项"><a href="#14-4-1-查找选项" class="headerlink" title="14.4.1 查找选项"></a>14.4.1 查找选项</h3><p>用<code>case</code>语句来判断某个参数是否为选项.</p><h4 id="分离选项和参数"><a href="#分离选项和参数" class="headerlink" title="分离选项和参数"></a>分离选项和参数</h4><p>shell会用双破折号(–)来表明选项列表结束，其后的参数会被当作参数处理而不是选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">  <br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># extracting command line options as parameters</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">echo</span> <br><span class="hljs-keyword">while</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]<br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span> <br>        -a) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -a option&quot;</span> ;; <br>        -b) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -b option&quot;</span> ;;<br>        -c) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found the -c option&quot;</span> ;;<br>        --) <span class="hljs-built_in">shift</span><br>            <span class="hljs-built_in">break</span> ;;<br>         *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> is not an option&quot;</span> ;;<br>     <span class="hljs-keyword">esac</span><br>     <span class="hljs-built_in">shift</span><br> <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>利用<code>shift</code>每调用一个选项就移除一个。</p><p>在Linux中，合并选项是一个很常见的做法。</p><h3 id="14-4-2-使用getopt命令"><a href="#14-4-2-使用getopt命令" class="headerlink" title="14.4.2 使用getopt命令"></a>14.4.2 使用getopt命令</h3><p>getopt命令可以识别命令行参数.</p><p>getopt命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">getopt optstring parameters</span><br></code></pre></td></tr></table></figure><p>在每个需要参数值的选项字母后面加一个冒号:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">getopt ab:<span class="hljs-built_in">cd</span> -a -b test1 -<span class="hljs-built_in">cd</span> test2 testt3</span><br></code></pre></td></tr></table></figure><h1 id="第19章-初识-sed-和-gawk"><a href="#第19章-初识-sed-和-gawk" class="headerlink" title="第19章 初识 sed 和 gawk"></a>第19章 初识 sed 和 gawk</h1><h2 id="19-1-文本处理"><a href="#19-1-文本处理" class="headerlink" title="19.1 文本处理"></a>19.1 文本处理</h2><h3 id="19-1-1-sed-编辑器"><a href="#19-1-1-sed-编辑器" class="headerlink" title="19.1.1 sed 编辑器"></a>19.1.1 sed 编辑器</h3><p>sed 编辑器被称作流编辑器 (stream editor), 和交互式编辑器 (如 vim) 恰好相反.</p><p>sed 编辑器的操作:</p><ol><li>一次从输入中读取一行数据</li><li>根据所提供的编辑器命令匹配数据</li><li>按照命令修改流中的数据</li><li>将新的数据输出到 STDOUT</li></ol><p>命令格式:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">sed options <span class="hljs-keyword">script</span> <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><p>可用选项:</p><ul><li><code>-e script</code>   在处理输入时，将 script 中指定的命令添加到已有的命令中</li><li><code>-f file</code>     在处理输入时，将 file 中指定的命令添加到已有的命令中</li><li><code>-n</code>          不产生命令输出，使用 print 命令来完成输出</li></ul><p>sed 编辑器并不会修改文本文件的数据，它只会将修改后的数据发送到 STDOUT.</p><p>替换命令, 如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is a test&quot;</span> | sed <span class="hljs-string">&#x27;s/test/big test/&#x27;</span></span> <br></code></pre></td></tr></table></figure><h4 id="执行多个命令"><a href="#执行多个命令" class="headerlink" title="执行多个命令"></a>执行多个命令</h4><p>执行多个命令时使用 <code>-e</code> 选项:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed -e <span class="hljs-string">&#x27;s/brown/green/; s/dog/cat/&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>命令用分号 <code>;</code> 隔开，且必须位于命令末尾，不能有空格.</p><h4 id="多行命令"><a href="#多行命令" class="headerlink" title="多行命令"></a>多行命令</h4><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed -e &#x27;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/brown/green/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/fox/elephant/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/dog/cat/<span class="hljs-string">&#x27; data1.txt</span></span><br></code></pre></td></tr></table></figure><h4 id="从文件中获取命令"><a href="#从文件中获取命令" class="headerlink" title="从文件中获取命令"></a>从文件中获取命令</h4><p>每个命令占一行，可以给文件添加后缀 <code>.sed</code></p><h3 id="19-1-2-gawk-程序"><a href="#19-1-2-gawk-程序" class="headerlink" title="19.1.2 gawk 程序"></a>19.1.2 gawk 程序</h3><p>在所有的发行版中都没有默认安装 gawk 程序。</p><p>gawk 是原始 awk 的 GNU 版本。</p><p>gawk 提供了一种编程语言。</p><p>基本格式:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">gawk <span class="hljs-keyword">option</span> program <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>可用选项:</p><ul><li><code>-F FS</code>, 指定行中划分数据字段的字段分隔符</li><li><code>-f file</code>, 从指定的文件中读取程序</li><li><code>-v var=value</code>, 定义 gawk 程序中的一个变量及其默认值</li><li><code>-mf N</code>, 指定要处理文件中的最大字段数</li><li><code>-mr N</code>, 指定数据文件中的最大数据行数</li><li><code>-W keyword</code>, 指定 gawk 中兼容模式或警告等级</li></ul><p>gawk 的脚本用一对花括号来定义，必须把脚本命令放在一对花括号中 <code>&#123;&#125;</code>.</p><p>gawk 命令行假定脚本是单个文本字符串, 因此还需要把脚本放到单引号中:</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">$ gawk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Hello World&quot;</span>&#125;&#x27;<br></code></pre></td></tr></table></figure><p>gawk 会从 STDIN 等待输入数据。</p><p>gawk 会对数据中的每行文本执行程序.</p><p>使用 <code>Ctrl + D</code> 终止程序.</p><h4 id="使用数据字段变量"><a href="#使用数据字段变量" class="headerlink" title="使用数据字段变量"></a>使用数据字段变量</h4><p>gawk 会给一行中的每个数据元素分配一个变量, 默认为:</p><ul><li><code>$0</code>, 代表整个文本行</li><li><code>$1</code>, 代表文本行中的第1个数据字段</li><li><code>$2</code>, 代表文本行中的第2个数据字段</li><li><code>$n</code>, 代表文本行中的第n个数据字段<br>在文本行中，每个数据字段都是通过<mark>字段分隔符</mark>划分的。默认为任意的空白字符.</li></ul><h4 id="在程序脚本中使用多个命令"><a href="#在程序脚本中使用多个命令" class="headerlink" title="在程序脚本中使用多个命令"></a>在程序脚本中使用多个命令</h4><p>使用分号 <code>;</code> 分隔.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">$ gawk <span class="hljs-string">&#x27;&#123;<span class="hljs-subst">$4</span>=&quot;Christine&quot;; print <span class="hljs-subst">$0</span>&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>一次一行:</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ gawk &#x27;&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">$<span class="hljs-number">4</span>=<span class="hljs-string">&quot;Christine</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">print $0&#125;&#x27;</span></span><br></code></pre></td></tr></table></figure><h4 id="从文件中读取程序"><a href="#从文件中读取程序" class="headerlink" title="从文件中读取程序"></a>从文件中读取程序</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> gawk <span class="hljs-operator">-F</span>: <span class="hljs-operator">-f</span> script2.gawk /etc/passwd<br></code></pre></td></tr></table></figure><p>脚本文件中一条命令一行，不需要分号，但需要一对花括号.</p><h4 id="在读取数据前运行脚本"><a href="#在读取数据前运行脚本" class="headerlink" title="在读取数据前运行脚本"></a>在读取数据前运行脚本</h4><p>gawk 允许指定程序脚本何时运行。</p><p><code>BEGIN</code> 关键词，让程序在读取数据前运行脚本 </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ gawk <span class="hljs-symbol">&#x27;BEGIN</span> &#123;print <span class="hljs-string">&quot;Hello World&quot;</span>&#125;&#x27;<br></code></pre></td></tr></table></figure><h4 id="在处理数据后运行脚本"><a href="#在处理数据后运行脚本" class="headerlink" title="在处理数据后运行脚本"></a>在处理数据后运行脚本</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">$ gawk &#x27;<span class="hljs-type">END</span> &#123;print <span class="hljs-string">&quot;End of File&quot;</span>&#125;&#x27; <span class="hljs-class"><span class="hljs-keyword">data</span>.txt</span><br></code></pre></td></tr></table></figure><h2 id="19-2-sed-编辑器基础"><a href="#19-2-sed-编辑器基础" class="headerlink" title="19.2 sed 编辑器基础"></a>19.2 sed 编辑器基础</h2><h3 id="19-2-1-更多的替换选项"><a href="#19-2-1-更多的替换选项" class="headerlink" title="19.2.1 更多的替换选项"></a>19.2.1 更多的替换选项</h3><h4 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h4><p>替换命令在替换多行文本时能够正常工作，但默认情况下它只替换每行中出现的第一处.</p><p>四种替换标签 (substitution flag):</p><ul><li>数字，表明新文本将替换地挤出模式匹配的地方</li><li>g, 表明新文本将会替换所有匹配的文本</li><li>p, 表明输出修改过的行, 通常和 <code>-n</code> 选项一起用</li><li>w file, 将替换结果写到文件中<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ sed &#x27;s/<span class="hljs-keyword">test</span>/trial/w <span class="hljs-keyword">test</span>.txt&#x27; data.txt<br></code></pre></td></tr></table></figure>这里的 <code>test.txt</code> 是指定的用来保存的文件.</li></ul><h4 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h4><p>sed 允许选择其他字符作为替换命令中的分隔符:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sed <span class="hljs-string">&#x27;s!/bin/bash!/bin/csh!&#x27;</span> <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure><p>这里用 <code>!</code> 作为分隔符.</p><h3 id="19-2-2-使用地址"><a href="#19-2-2-使用地址" class="headerlink" title="19.2.2 使用地址"></a>19.2.2 使用地址</h3><p>使用行寻址 (line addressing), 将命令作用于特定行或某些行.</p><p>两种形式:</p><ul><li>以数字形式表示行区间</li><li>用文本模式来过滤出行</li></ul><p>格式均为:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[address]</span>command<br></code></pre></td></tr></table></figure><p>或:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">address &#123;<br>  comma<span class="hljs-symbol">nd1</span><br>  comma<span class="hljs-symbol">nd2</span><br>  comma<span class="hljs-symbol">nd3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>sed 编辑器会将指定的每条命令作用到匹配指定地址的行上.</p><h4 id="数字形式的行寻址"><a href="#数字形式的行寻址" class="headerlink" title="数字形式的行寻址"></a>数字形式的行寻址</h4><p>可以是行号，也可以是区间:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2s/dog/cat/&#x27;</span> data.txt<br><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2,3s/dog/cat/&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>美元符 <code>$</code> 是特殊地址，表示最后一行.</p><h4 id="使用文本模式过滤器"><a href="#使用文本模式过滤器" class="headerlink" title="使用文本模式过滤器"></a>使用文本模式过滤器</h4><p>格式为:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/pattern/</span>command<br></code></pre></td></tr></table></figure><p>必须用正斜线 <code>/</code> 将指定的 <code>pattern</code> 封起来，sed 编辑器会将命令作用到包含指定文本模式的行上.</p><p>如:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sed <span class="hljs-string">&#x27;/Samantha/s/bash/csh/&#x27;</span> <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure><p>在前面的文本模式中可以使用正则表达式.</p><h4 id="命令组合"><a href="#命令组合" class="headerlink" title="命令组合"></a>命令组合</h4><p>在单行执行多条命令:</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed &#x27;2&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/fox/elephant/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/dog/cat/</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; data.txt</span></span><br></code></pre></td></tr></table></figure><h3 id="19-2-3-删除行"><a href="#19-2-3-删除行" class="headerlink" title="19.2.3 删除行"></a>19.2.3 删除行</h3><p>删除命令 <code>d</code>, 它会删除匹配指定寻址模式的所有行。</p><p>删除所有行:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>指定行号:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;3d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>指定区间:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2.3d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>使用文本模式:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;/pattern/d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>使用两个文本模式删除某个区间，第一个文本模式会打开”删除”功能，第二个文本模式匹配结束后会关闭”删除”功能:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;/1/,/3/d&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><h3 id="19-2-4-插入和附加文本"><a href="#19-2-4-插入和附加文本" class="headerlink" title="19.2.4 插入和附加文本"></a>19.2.4 插入和附加文本</h3><ul><li>插入 (insert) 命令 (i) 会在指定行前增加一个新行</li><li>附加 (append) 命令 (a) 会在指定行后增加一个新行<br>格式:<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;[address]command\ new_line_contents&#x27;</span><br></code></pre></td></tr></table></figure>注意这里是反斜线.</li></ul><p>如:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;3i\ This is an insert line&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>这样写更清晰:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;3i\</span><br><span class="hljs-string">&gt; This is an insert line&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><h3 id="19-2-5-修改行"><a href="#19-2-5-修改行" class="headerlink" title="19.2.5 修改行"></a>19.2.5 修改行</h3><p>修改 (change) 命令允许修改数据流中整行文本的内容，其跟插入和附加命令的工作机制一样.</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ sed &#x27;<span class="hljs-number">3</span>c\<br>&gt; This <span class="hljs-keyword">is</span> a changed <span class="hljs-literal">line</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">text</span>&#x27; data.txt<br></code></pre></td></tr></table></figure><p>也可以用文本模式寻址:</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ sed &#x27;/pattern/c\<br>&gt; This <span class="hljs-keyword">is</span> a changed <span class="hljs-literal">line</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">text</span>&#x27; data.txt<br></code></pre></td></tr></table></figure><p>若用区间会出问题:</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ sed &#x27;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>\c<br>&gt; This <span class="hljs-keyword">is</span> a <span class="hljs-keyword">new</span> <span class="hljs-literal">line</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">text</span>&#x27; data.txt<br></code></pre></td></tr></table></figure><p>其会把 <code>2,3</code> 区间的行改为一行.</p><h3 id="19-2-6-转换命令"><a href="#19-2-6-转换命令" class="headerlink" title="19.2.6 转换命令"></a>19.2.6 转换命令</h3><p>转换 (transform) 命令 (y) 是唯一可以处理单个字符的 sed 编辑器命令。</p><p>格式:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[address]y<span class="hljs-regexp">/inchars/</span>outchars/<br></code></pre></td></tr></table></figure><p>不要把 <code>inchars</code> 和 <code>outchars</code> 看做一个单词，应为一个个字符，其映射为一一对应，个数不一致会报错:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;y/123/456&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>文件里面所有的 <code>1</code> 会被替换为 <code>4</code>.</p><h3 id="19-2-7-回顾打印"><a href="#19-2-7-回顾打印" class="headerlink" title="19.2.7 回顾打印"></a>19.2.7 回顾打印</h3><p>用于打印数据流中的信息:</p><ul><li>p命令用来打印文本行</li><li>等号 (&#x3D;) 用来打印行号</li><li>1 (小写的L) 用来列出行</li></ul><h4 id="打印行"><a href="#打印行" class="headerlink" title="打印行"></a>打印行</h4><p>打印指定行地址的行:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed -n <span class="hljs-string">&#x27;2,3p&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>打印包含文本模式匹配上的行:</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed -n &#x27;/pattern/&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">p</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">s/line/test/p</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; data.txt</span></span><br></code></pre></td></tr></table></figure><h4 id="打印行号"><a href="#打印行号" class="headerlink" title="打印行号"></a>打印行号</h4><p>使用 <code>=</code>:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> <span class="hljs-keyword">set</span> <span class="hljs-string">&#x27;=&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><p>sed 在实际文本出现之前打印出行号。</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ set -n &#x27;/number 4/&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">=</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">p</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; data.txt</span></span><br></code></pre></td></tr></table></figure><h4 id="列出行"><a href="#列出行" class="headerlink" title="列出行"></a>列出行</h4><p>列出 (list) 命令 (l) 可以打印数据流中的文本和不可打印的 ASCII 字符。</p><p>任何不可打印字符要么在其八进制值前加一个反斜线，要么使用 C 语言风格的命名法, 如 <code>\t</code>.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span> data.txt<br>This  line  contains  tabs<br><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span> sed <span class="hljs-literal">-n</span> <span class="hljs-string">&#x27;l&#x27;</span> data.txt<br>This\tline\tcontains\ttabs<span class="hljs-variable">$</span><br></code></pre></td></tr></table></figure><h3 id="19-2-8-使用-sed-处理文件"><a href="#19-2-8-使用-sed-处理文件" class="headerlink" title="19.2.8 使用 sed 处理文件"></a>19.2.8 使用 sed 处理文件</h3><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sed <span class="hljs-string">&#x27;2.3w test.txt&#x27;</span> data.txt<br></code></pre></td></tr></table></figure><h4 id="从文件读取数据"><a href="#从文件读取数据" class="headerlink" title="从文件读取数据"></a>从文件读取数据</h4><p>读取 (read) 命令 (r) 允许将一个独立文件中的数据插入到数据流中。</p><p>格式:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[address]</span>r filename<br></code></pre></td></tr></table></figure><p>sed 编辑器会将文件中的文本插入到指定地址之后.</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">$ sed &#x27;/LIST/&#123;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">r detail.<span class="hljs-property">txt</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">d</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&#125;<span class="hljs-string">&#x27; notice.std</span></span><br></code></pre></td></tr></table></figure><p>前面的文本模式对后面的命令都起效果.</p><h1 id="第20章-正则表达式"><a href="#第20章-正则表达式" class="headerlink" title="第20章 正则表达式"></a>第20章 正则表达式</h1><h2 id="20-1-什么是正则表达式"><a href="#20-1-什么是正则表达式" class="headerlink" title="20.1 什么是正则表达式"></a>20.1 什么是正则表达式</h2><h3 id="20-1-1-定义"><a href="#20-1-1-定义" class="headerlink" title="20.1.1 定义"></a>20.1.1 定义</h3><p>正则表达式是你所定义的模式模板 (pattern template), Linux 工具可以用它来过滤文本.</p>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sentences</title>
    <link href="/2022/07/16/Sentences/"/>
    <url>/2022/07/16/Sentences/</url>
    
    <content type="html"><![CDATA[<p>所谓青春，指的不是人生中的某个时期，而是你的心境。</p>]]></content>
    
    
    <categories>
      
      <category>Sentences</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Operating Systems Design and Implementation Note</title>
    <link href="/2022/07/15/Operating-Systems-Design-and-Implementation-Note/"/>
    <url>/2022/07/15/Operating-Systems-Design-and-Implementation-Note/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-进程"><a href="#第二章-进程" class="headerlink" title="第二章 进程"></a>第二章 进程</h1><h2 id="2-1-进程介绍"><a href="#2-1-进程介绍" class="headerlink" title="2.1 进程介绍"></a>2.1 进程介绍</h2><h3 id="2-1-5-进程的状态"><a href="#2-1-5-进程的状态" class="headerlink" title="2.1.5 进程的状态"></a>2.1.5 进程的状态</h3><p>调度器，决定哪个进程应当运行，以及它运行多长时间.</p><p>一些动作，诸如保存寄存器值和设置栈指针等无法用C语言描述，所以用一个短小的汇编语言例程来完成.</p><h3 id="2-1-7-线程"><a href="#2-1-7-线程" class="headerlink" title="2.1.7 线程"></a>2.1.7 线程</h3><p>它们共享相同的地址空间.</p><p>观察进程的一种方式是把进程视为一组相关资源的集合。</p><p>进程用来集合资源，而线程是CPU中调度的实体.</p><p>进程有进程表，线程有线程表.</p><h3 id="2-2-2-临界区"><a href="#2-2-2-临界区" class="headerlink" title="2.2.2 临界区"></a>2.2.2 临界区</h3><p>避免竞争条件, 防止多个进程同时访问共享数据.</p><p>这里把对共享内存进行访问的程序片段称为 critical region 或 critical section.</p><h4 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h4><p>Test and Lock，它将一个存储器字读到寄存器中，然后在该内存地址上存一个非零值. 该指令结束之前其他处理机构均不允许访问该存储器.</p><p>有忙等待的缺点.</p><p>通过TSL指令来确保同一时刻只有一个CPU在对信号量进行操作.</p><h3 id="2-2-6-Mutex"><a href="#2-2-6-Mutex" class="headerlink" title="2.2.6 Mutex"></a>2.2.6 Mutex</h3><p>互斥, Mutex. </p><p>是一个可以处于两态之一的变量: 解锁和加锁. 常用一个二进制位或整数表示.</p><p>加锁即非零，表示已被占用。</p><p>解锁为0.</p><p><mark>死锁 dead lock</mark><br>两个进程永远的阻塞.</p><h3 id="2-2-7-管程"><a href="#2-2-7-管程" class="headerlink" title="2.2.7 管程"></a>2.2.7 管程</h3><p>monitor, 管程，是由过程、变量及数据结构等组成的集合.</p><p>任意时刻管程中只能有一个活跃进程.</p><h2 id="2-3-Classical-IPC-Problems"><a href="#2-3-Classical-IPC-Problems" class="headerlink" title="2.3 Classical IPC Problems"></a>2.3 Classical IPC Problems</h2><h3 id="2-3-1-哲学家进餐问题"><a href="#2-3-1-哲学家进餐问题" class="headerlink" title="2.3.1 哲学家进餐问题"></a>2.3.1 哲学家进餐问题</h3><p>所有的程序都在运行，但却无法取得进展称 starvation 饥饿.</p><p>需保证既不会发生死锁又不会发生饥饿.</p><p>信号量的使用.</p><p>critical region 的运用.</p><h3 id="2-3-2-读者-写者问题"><a href="#2-3-2-读者-写者问题" class="headerlink" title="2.3.2 读者-写者问题"></a>2.3.2 读者-写者问题</h3><h2 id="2-4-Scheduling"><a href="#2-4-Scheduling" class="headerlink" title="2.4 Scheduling"></a>2.4 Scheduling</h2><p>Scheduler，调度器，在操作系统中决定先运行哪一个进程.</p><p>admission scheculer, 准入调度器，决定哪些作业允许进入系统.</p><p>三级调度: 准入调度器， CPU调度器， 内存调度器.</p><h3 id="2-4-3-交互式系统中的调度"><a href="#2-4-3-交互式系统中的调度" class="headerlink" title="2.4.3 交互式系统中的调度"></a>2.4.3 交互式系统中的调度</h3><h4 id="时间片论转调度-Round-Robin-Scheduling"><a href="#时间片论转调度-Round-Robin-Scheduling" class="headerlink" title="时间片论转调度 Round-Robin Scheduling"></a>时间片论转调度 Round-Robin Scheduling</h4><p>每个进程被分配一个时间片.</p><h4 id="优先级调度-Priority-Scheduling"><a href="#优先级调度-Priority-Scheduling" class="headerlink" title="优先级调度 Priority Scheduling"></a>优先级调度 Priority Scheduling</h4><p>每个进程被赋予一个优先级，率先运行优先级最高的就绪进程.</p><p>优先级可以为静态或动态.</p><h3 id="2-4-4-实时系统调度-Scheduling-in-Real-Time-Systems"><a href="#2-4-4-实时系统调度-Scheduling-in-Real-Time-Systems" class="headerlink" title="2.4.4 实时系统调度 Scheduling in Real-Time Systems"></a>2.4.4 实时系统调度 Scheduling in Real-Time Systems</h3><p>通常分为: 硬实时和软实时.</p><h2 id="2-5-MINIX-3-进程概述"><a href="#2-5-MINIX-3-进程概述" class="headerlink" title="2.5 MINIX 3 进程概述"></a>2.5 MINIX 3 进程概述</h2><p>汇编语言负责内核直接与硬件交互的最底层部分，这部分不能用C实现.</p><p>进程都潜在具有一定的特权，这是第二层、第三层和第四层内的进程真正的不同之处.</p><p>理解 kernel call 和 POSIX system call 的区别非常重要.</p><p>内核调用是由系统服务提供的以使驱动程序和服务器完成工作的底层函数.</p><p>POSIX系统调用是由POSIX规范定义的高层调用.</p><p>在init进程运行之前，就有一些系统进程已经运行了.</p><p>在类UNIX系统中，init被赋予的PID为1.</p><p>rc脚本的一个重要功能是检查可能由上次系统崩溃所引起的文件系统错误.</p><p>一个进程的所有信息都保存在进程表中，进程表划分成为内核、内存管理器和文件系统三部分, 分别拥有它们各自所需要的那些域.</p><h3 id="2-5-3-MINIX-3-中的进程间通信"><a href="#2-5-3-MINIX-3-中的进程间通信" class="headerlink" title="2.5.3 MINIX 3 中的进程间通信"></a>2.5.3 MINIX 3 中的进程间通信</h3><p>阻塞：正在执行的进程由于发生某事而暂时无法继续执行.</p><h3 id="2-5-4-MINIX-3-中的进程调度"><a href="#2-5-4-MINIX-3-中的进程调度" class="headerlink" title="2.5.4 MINIX 3 中的进程调度"></a>2.5.4 MINIX 3 中的进程调度</h3><p>中断系统能使多道程序操作系统持续不断地工作,</p><p>任务通常有最高的优先级，驱动程序次之，服务器再次，最后是用户进程。</p><p>只有当所有的系统进程都无事可做时，用户进程才能运行。系统进程不会被用户进程阻止运行.</p><h2 id="2-6-MINIX-3-中进程的实现"><a href="#2-6-MINIX-3-中进程的实现" class="headerlink" title="2.6 MINIX 3 中进程的实现"></a>2.6 MINIX 3 中进程的实现</h2><p>“过程”、“函数”、以及“例程”可以混用。</p><p>每一个C编译器都会到一个默认的头文件目录中去查找include文件，大多数情况下，这个目录是<code>/usr/include/</code>.</p><p>当一个<code>include</code>文件是在一个小于号和一个大于号之间<code>&lt;&gt;</code>被引用时，编译器则到默认头文件目录或者一个指定目录中去查找该文件.</p><p><code>&quot;&quot;</code>中是本地头文件.</p><p><code>src</code>目录应该是<code>source</code>源代码目录.</p><p>通常情况下，操作系统中的三大块通用的程序只有<code>/src/lib/</code>目录中的库程序.</p><p>特性测试宏，feature test macro, 如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _ANSI</span><br></code></pre></td></tr></table></figure><p>在编译一个C程序时，数据结构、参数以及函数返回值在引用它们的代码之前必须是已知的。因此C允许在定义之前使用函数原型来声明一个函数的参数和返回值.</p><p>在一次编译中，一个头文件应该仅被包含一次, 使用:&#96;&#96;&#96;<br>  #ifndef …<br>  …<br>  #endif</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs prolog">所有的类型名都以<span class="hljs-string">&quot;_t&quot;</span>结尾，这不仅是一种习惯，而且是<span class="hljs-symbol">POSIX</span>标准规定.<br><br>对于编译器，首字母大写的所有类型都等价于int类型.<br>### <span class="hljs-number">2.6</span><span class="hljs-number">.4</span> <span class="hljs-symbol">MINIX</span> <span class="hljs-number">3</span> 头文件<br>以下划线开头可以降低冲突的可能性.<br><br>对于磁盘的缓存来说，用于文件系统的缓存容量是越大越好.<br><br>声明被包含于两个以上的文件中，则有些链接程序将会把它认做变量多重定义错误.<br>### <span class="hljs-number">2.6</span><span class="hljs-number">.6</span> 引导<span class="hljs-symbol">MINIX</span> <span class="hljs-number">3</span><br>未分区磁盘，第一个扇区是引导块。<br><br>已分区磁盘，第一个扇区是主引导记录(含分区表)，又称主引导程序. 通常有且只有一个分区被表示为活动状态.<br><br>一个<span class="hljs-symbol">MINIX</span>分区与一个未分区的<span class="hljs-symbol">MINIX</span> <span class="hljs-number">3</span> 软盘结构相同.<br><br>在装入操作系统之前无法通过目录和文件名来定位一个文件.<br><br>通常<span class="hljs-string">`#include`</span>用来包含头文件, 但也可以用来选择源代码的适当部分.<br></code></pre></td></tr></table></figure><p>  #include &lt;minix&#x2F;config.h&gt;<br>  #if _WORD_SIZE &#x3D;&#x3D; 2<br>  #include “mpx88.s”<br>  #else<br>  #include “mpx386.s”<br>  #endif</p><pre><code class="hljs">在C语言中`a[i]`只是`*(a+i)`的另一种写法.## 3 Input/Output操作系统的主要功能之一是控制所有的输入/输出设备.### 3.1.1 I/O设备大致分为两类: 1. block device, 块设备 2. character device, 字符设备块设备将信息存储在固定大小的块中，每个块都有自己的地址。数据块的大小通常在512字节到32768字节之间。块设备的基本特征是每个块都能够独立于其他块而读写。磁盘是常用的块设备.字符设备发送或接受的是字符流，而不考虑任何块结构。字符设备无法编址，也不存在任何寻址操作。打印机、网络接口、鼠标以及大多数与磁盘不同的设备均可被视为字符设备.时钟的全部功能就是按照预先定义的时间间隔发出中断.文件系统仅仅控制抽象的块设备，而把与设备无关的部分留给较底层软件，即设备驱动程序(device driver)去处理。### 3.1.2 设备控制器I/O设备通常由一个机械部件和一个电子部件组成。电子部件称为 device controller，设备控制器或 adapter, 适配器. 机械部件则是设备本身.操作系统大多与控制器之间通信，而非设备本身.preamble，前导符是磁盘格式化时写进去的，他包括柱面数和扇区数、扇区大小之类的数据，还包括同步信息。在对检验和进行校验并证明数据快没有错误后，字节快将被复制到主存中.### 3.1.3 内存映射I/O每个控制器都有一些用来与CPU通信的寄存器。除了这些控制寄存器之外，许多设备还有一个操作系统可以读写的数据缓冲区.CPU与控制寄存器和设备的数据缓冲区进行通信的方法: 1. 分配I/O端口号, 内存和I/O的地址空间是不同的 2. 内存映射I/O, I/O寄存器是内存地址空间的一部分. 每个控制寄存器被分配唯一的一个内存地址，而且不会有内存分配这一地址. 通常分配给控制寄存器的地址位于地址空间的顶端.### 3.1.4 中断 p154</code></pre>]]></content>
    
    
    <categories>
      
      <category>Operate System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Game Scripting Mastery Note</title>
    <link href="/2022/07/15/Game-Scripting-Mastery-Note/"/>
    <url>/2022/07/15/Game-Scripting-Mastery-Note/</url>
    
    <content type="html"><![CDATA[<h1 id="CHAPTER-1-AN-INTRODUCTION-TO-SCRIPTING"><a href="#CHAPTER-1-AN-INTRODUCTION-TO-SCRIPTING" class="headerlink" title="CHAPTER 1 AN INTRODUCTION TO SCRIPTING"></a>CHAPTER 1 AN INTRODUCTION TO SCRIPTING</h1><h2 id="WHAT-IS-SCRIPTING"><a href="#WHAT-IS-SCRIPTING" class="headerlink" title="WHAT IS SCRIPTING?"></a>WHAT IS SCRIPTING?</h2><h2 id="STRUCTURED-GAME-CONTENT-–-A-SIMPLE-APPROACH"><a href="#STRUCTURED-GAME-CONTENT-–-A-SIMPLE-APPROACH" class="headerlink" title="STRUCTURED GAME CONTENT – A SIMPLE APPROACH"></a>STRUCTURED GAME CONTENT – A SIMPLE APPROACH</h2><h2 id="IMPROVING-THE-METHOD-WITH-LOGICAL-AND-PHYSICAL-SEPARATION"><a href="#IMPROVING-THE-METHOD-WITH-LOGICAL-AND-PHYSICAL-SEPARATION" class="headerlink" title="IMPROVING THE METHOD WITH LOGICAL AND PHYSICAL SEPARATION"></a>IMPROVING THE METHOD WITH LOGICAL AND PHYSICAL SEPARATION</h2>]]></content>
    
    
    <categories>
      
      <category>Compiler Theory</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Using cd command in Vim</title>
    <link href="/2022/07/15/Using-cd-command-in-Vim/"/>
    <url>/2022/07/15/Using-cd-command-in-Vim/</url>
    
    <content type="html"><![CDATA[<p>You can use <code>cd</code> command in Vim.</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The file with .bat postfix</title>
    <link href="/2022/07/13/The-file-with-bat-postfix/"/>
    <url>/2022/07/13/The-file-with-bat-postfix/</url>
    
    <content type="html"><![CDATA[<p><code>bat</code>文件是<code>dos</code>下的批处理文件，是无格式的文本文件，包含一条或多条命令。扩展名通常为<code>.bat</code>或<code>.cmd</code>, 就是脚本文件.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hex Editing in Vim</title>
    <link href="/2022/07/13/Hex-Editing-in-Vim/"/>
    <url>/2022/07/13/Hex-Editing-in-Vim/</url>
    
    <content type="html"><![CDATA[<p>Adding a plugin named ‘fidian hexmode’, you can see this in Github.</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>30天自制操作系统</title>
    <link href="/2022/07/13/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/07/13/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="第1天-从计算机结构到汇编程序入门"><a href="#第1天-从计算机结构到汇编程序入门" class="headerlink" title="第1天 从计算机结构到汇编程序入门"></a>第1天 从计算机结构到汇编程序入门</h1><p>软盘的原理是把二进制的0和1转换为磁极的N极和S极.</p><p>不能仅以0和1来表达的内容，都不能以电信号的形式传递给CPU.</p><p><code>DB</code> 指令是”defined byte” 的缩写，也就是往文件里直接写入1个字节的指令.</p><p><code>RESB</code>指令是”reserve byte”的缩写，用于开辟字节内存.</p><p><code>$</code>这里指一个变量，告诉我们这一行现在的字节数.<br><mark>提问</mark><br>软盘的格式化是在干嘛.</p><h2 id="启动区"><a href="#启动区" class="headerlink" title="启动区"></a>启动区</h2><p>计算机读写软盘的时候是以512字节为一个单位进行读写，而不是一个字节一个字节地读写.</p><p>第一个扇区为启动区，会检查其最后两个字节的内容是否为<code>0x55AA</code>来确定这个扇区的开头是否为启动程序。</p><h2 id="IPL"><a href="#IPL" class="headerlink" title="IPL"></a>IPL</h2><p>Initial Program Loader的缩写。启动程序加载器。用于读入程序.</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>boot，是bootstrap的缩写，有“自力更生完成任务”的含义。</p><p>矛盾的操作系统自动启动机制被称为bootstrap方式.</p><h1 id="第2天-汇编语言学习与Makefile入门"><a href="#第2天-汇编语言学习与Makefile入门" class="headerlink" title="第2天 汇编语言学习与Makefile入门"></a>第2天 汇编语言学习与Makefile入门</h1><p><code>ORG</code>指令，源于”origin”, 指明把这些机器语言指令装载到内存中的哪个地址.</p><p>8个代表性的寄存器的名称:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">AX</span>    accumulator, 累加器<br><span class="hljs-built_in">CX</span>    counter, 计数寄存器<br><span class="hljs-built_in">DX</span>    data, 数据寄存器<br><span class="hljs-built_in">BX</span>    base, 基址寄存器<br><span class="hljs-built_in">SP</span>    stack pointer, 栈指针寄存器<br><span class="hljs-built_in">BP</span>    base pointer, 基址指针寄存器<br><span class="hljs-built_in">SI</span>    source index, 源变址寄存器<br><span class="hljs-built_in">DI</span>    destination index, 目的变址寄存器<br></code></pre></td></tr></table></figure><p>都是16位寄存器. 名称中的X表示扩展(extend)的意思，因为以前的寄存器是8位.</p><p>8个8位寄存器:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">AL</span>    accumulator low, 累加寄存器低位<br><span class="hljs-built_in">CL</span>    counter low, 计数寄存器低位<br><span class="hljs-built_in">DL</span>    data low, 数据寄存器低位<br><span class="hljs-built_in">BL</span>    base low, 基质寄存器低位<br><span class="hljs-number">AH</span>    accumulator high, 累加寄存器高位<br><span class="hljs-number">CH</span>    count high, 计数寄存器低位<br><span class="hljs-number">DH</span>    data high, 数据寄存器低位<br><span class="hljs-number">BH</span>    base high, 基址寄存器低位<br></code></pre></td></tr></table></figure><p>电脑是32位的使用32位寄存器:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">EAX</span>, <span class="hljs-built_in">ECX</span>, <span class="hljs-built_in">EDX</span>, <span class="hljs-built_in">EBX</span>, <span class="hljs-built_in">ESP</span>, EXP, <span class="hljs-built_in">ESI</span>, <span class="hljs-built_in">EDI</span><br></code></pre></td></tr></table></figure><p>在16位寄存器的名字前面加上一个E, 字母E来源于”Extend”.</p><p><code>EAX</code>的低16位就是<code>AX</code>但是高16位没有名称.</p><p>段寄存器，16位寄存器:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">ES</span>    extra <span class="hljs-meta">segment</span>, 附加段寄存器<br><span class="hljs-built_in">CS</span>    code <span class="hljs-meta">segment</span>, 代码段寄存器<br><span class="hljs-built_in">SS</span>    stack <span class="hljs-meta">segment</span>, 栈段寄存器<br><span class="hljs-built_in">DS</span>    data <span class="hljs-meta">segment</span>, 数据段寄存器<br><span class="hljs-built_in">FS</span>    <span class="hljs-meta">segment</span> part <span class="hljs-number">2</span>, 没有名称<br><span class="hljs-built_in">ES</span>    <span class="hljs-meta">segment</span> part <span class="hljs-number">3</span>, 没有名称<br></code></pre></td></tr></table></figure><p>在汇编语言中，所有标号都仅仅是单纯的数字。每个标号对应的数字，是由汇编语言编译器根据ORG指令计算出来的。编译器计算出的”标号的地方对应的内存地址”就是那个标号的值.</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">SI</span>,msg<br></code></pre></td></tr></table></figure><p>这里的<code>msg</code>是一个标号, 实际上<code>SI</code>的值为标号代表的地址.</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">SI</span>,[msg]<br></code></pre></td></tr></table></figure><p><code>[]</code>表示内存.</p><h2 id="内存-Memory"><a href="#内存-Memory" class="headerlink" title="内存 Memory"></a>内存 Memory</h2><p>内存是CPU的外部存储器.</p><p>使用内存的速度慢很多.</p><p>BYTE, WORD, DWORD 都是汇编语言保留字. 相邻指的是地址增加方向的相邻.</p><p>只有BX, BP, SI, DI 可用于指定内存地址.</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">BX</span>, <span class="hljs-built_in">DX</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>, <span class="hljs-built_in">BYTE</span>[<span class="hljs-built_in">BX</span>]<br></code></pre></td></tr></table></figure><p>注意位数要相同. 违反这一规则的话，汇编语言就找不到相对应的机器语言.</p><p><code>CMP</code>指令和<code>JE</code>指令:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">JE</span> fin<br></code></pre></td></tr></table></figure><p><code>INT</code>指令是软件中断指令，源自”interrupt”.</p><p><code>BIOS</code>程序，”Basic Input Output System”，其中写入了操作系统开发人员常用的一些程序，位于电脑主板上的ROM单元里。</p><p>电脑的设定画面也在<code>BIOS</code>中.</p><p><code>HLT</code>指令，让CPU停止动作，但不彻底，即没断电，使其进入待机状态。只要外部状态变化，就会继续执行程序。其源自英文”halt”.</p><p>在内存的<code>0xf0000</code>号附近，还存放这BIOS程序本身.</p><p>0x00007c00-0x00007dff : 启动区内容的装载地址. 程序中ORG指令的值就是这个数字. 这个数字没有什么特别之处，只是最初的规定.</p><h1 id="第3天-进入32位模式并导入C语言"><a href="#第3天-进入32位模式并导入C语言" class="headerlink" title="第3天 进入32位模式并导入C语言"></a>第3天 进入32位模式并导入C语言</h1><p>调用BIOS中的程序是，其会根据寄存器中的值来作出相应的反应.</p><p>从外到内，柱面号增大。</p><p><code>C0-H0-S1</code> 柱面0, 磁头1, 扇区1.</p><h2 id="32位模式"><a href="#32位模式" class="headerlink" title="32位模式"></a>32位模式</h2><p>指CPU的模式，CPU有16位和32位两种模式。16位模式使用AX和CX等寄存器。32位使用EAX和ECX等寄存器。</p><p>16位和32位模式产生的机器语言的命令代码不一样。</p><p>CPU的自我保护功能在16位下不能使用.</p><p><code>VRAM</code>指显卡内存(vedio RAM).</p><p><code>goto</code>指令实际上会被编译成<code>JMP</code>指令.</p><p>C语言中不能使用<code>HLT</code>, 也没有相当与<code>DB</code>的命令.</p><p>gcc 是以 gas 汇编语言为基础.</p><p>目标文件是一种特殊的机器语言文件，必须与其他文件链接(link)后才能变成真正可以执行的机器语言.</p><p>C语言有一些局限性，不可能只用C语言来编写所有的程序，所以其中有一部分必须用汇编来写，然后链接到C语言写的程序上.</p><p><mark>映像文件</mark><br>大概是，不是文件本来的状态，而是一种替代形式. </p><h1 id="第4天-C语言与画面显示练习"><a href="#第4天-C语言与画面显示练习" class="headerlink" title="第4天 C语言与画面显示练习"></a>第4天 C语言与画面显示练习</h1><p>CPU(英特尔系列):</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">8086 </span>-&gt; <span class="hljs-number">80186</span> -&gt; <span class="hljs-number">286</span> -&gt; <span class="hljs-number">386</span> -&gt; <span class="hljs-number">486</span> -&gt; Pentium -&gt; Per<br></code></pre></td></tr></table></figure><p>到286为止CPU是16位，386以后CPU是32位.</p><h2 id="挑战指针"><a href="#挑战指针" class="headerlink" title="挑战指针"></a>挑战指针</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">char</span> *p;  <span class="hljs-comment">//用于BYTE类地址</span><br><span class="hljs-type">short</span> *p; <span class="hljs-comment">//用于WORD类地址</span><br><span class="hljs-type">int</span> *p; <span class="hljs-comment">//用于DWORD类地址</span><br></code></pre></td></tr></table></figure><p>但是，以上变量<code>p</code>都是4字节.</p><p><code>cast</code>在英文中的原意有压入模具，让材料成为某种特定的形状.</p>]]></content>
    
    
    <categories>
      
      <category>Operate System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Programming Perl Notes</title>
    <link href="/2022/07/12/Programming-Perl-Notes/"/>
    <url>/2022/07/12/Programming-Perl-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="CHAPTER-10-Packages"><a href="#CHAPTER-10-Packages" class="headerlink" title="CHAPTER 10 Packages"></a>CHAPTER 10 Packages</h1><p>在Perl中, 命名空间称为包(package).</p><p>一个文件可以有多个包，一个包也可以跨多个文件。</p><p>若要在文件中放一个包，文件名需要和包名相同, 并使用<code>.pm</code>扩展名, 这是<code>perl module</code>的缩写。</p><p>模块(module)是Perl中可重用的基本单位。</p><p>若要使用模块，需要使用<code>use</code>命令，这是一个编译指令，可以控制从模块导入子例程和变量.</p><p>The typical class is implemented by a module that defines a package with the same name as the class.</p><p>重用的含义大概就是直接使用别人制作好的软件.</p><p><mark>the current package</mark><br>As Perl encounter a chunk of code, it is compiled into the current package. 初始的当前包 is called “main”.</p><p>当前包确定了要使用哪个符号表来查找变量，子例程，I&#x2F;O handles, and formats.</p><h2 id="Symbol-Tables"><a href="#Symbol-Tables" class="headerlink" title="Symbol Tables"></a>Symbol Tables</h2><p>包的内容统称为符号表(Symbol Table)</p>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Master Regular Expressions</title>
    <link href="/2022/07/08/Master-Regular-Expressions/"/>
    <url>/2022/07/08/Master-Regular-Expressions/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction-to-Regular-Expression"><a href="#1-Introduction-to-Regular-Expression" class="headerlink" title="1 Introduction to Regular Expression"></a>1 Introduction to Regular Expression</h1><h2 id="The-Language-Analogy"><a href="#The-Language-Analogy" class="headerlink" title="The Language Analogy"></a>The Language Analogy</h2><p>Full regular expressions are composed of two types of characters:</p><pre><code class="hljs">1. The special characters are called metacharacters2. The rest are called literal or normal text characters. </code></pre><p>文件名模式的元字符要少于正则表达式。</p><h2 id="单词分界符"><a href="#单词分界符" class="headerlink" title="单词分界符"></a>单词分界符</h2><p>在<code>egrep</code>分界符为<code>\&lt;</code>和<code>\&gt;</code>.</p><p>区分元字符和元字符序列，<code>&lt;</code>和<code>&gt;</code>本身不是元字符.</p><h2 id="流派"><a href="#流派" class="headerlink" title="流派"></a>流派</h2><p>指每样工具支持的元字符和其他特性各不相同.</p><h1 id="2-Extended-Introductory-Examples"><a href="#2-Extended-Introductory-Examples" class="headerlink" title="2 Extended Introductory Examples"></a>2 Extended Introductory Examples</h1><p>Perl 和 egrep 不属于同一个流派，而且 Perl 提供的元字符远远多于 egrep.</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">% perl -<span class="hljs-keyword">One</span> &#x27;<span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$ARGV\n&quot;</span> <span class="hljs-keyword">if</span> s/ResetSize<span class="hljs-comment">//ig != s/SetSize/ig&#x27; *</span><br></code></pre></td></tr></table></figure><p>在 Perl 中，变量不需要事先声明就能使用.</p><p>把<code>=~</code>读做match会比较省事。</p><p>Perl 一般不区分整数和浮点数.</p><h2 id="Adding-Commas-to-a-Number-with-Lookaround"><a href="#Adding-Commas-to-a-Number-with-Lookaround" class="headerlink" title="Adding Commas to a Number with Lookaround"></a>Adding Commas to a Number with Lookaround</h2><p>Lookaround match position within the text. 环视比 anchors 更通用.</p><p>Lookahead 从左向右查看文本. 是从head看，那就是从左往右.</p><p>Positive lookaround, 从左向右查看文本，查看当前位置右边。使用 special sequence <code>(?=...)</code>表示。</p><p>lookbehind, 从behind开始看，从右往左查看文本. 查看当前文本左边。Using special sequence <code>(?&lt;=...)</code>. 可以把<code>&lt;=</code>看作箭头指向左边所以匹配左侧.</p><p>环视表示的是找到一个位置并从这里开始匹配，如:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-params">...</span><span class="hljs-keyword">by</span> Jeffrey Friedl.<br></code></pre></td></tr></table></figure><p>使用<code>(?=Jeffrey)Jeff</code>, 即从<code>(?=Jeffrey)</code>一个字符的右边是<code>Jeffrey</code>的位置开始匹配<code>Jeff</code>. 也就是从<code>by</code>后面的那个空格字符开始匹配.</p><p>环视匹配的内容不是匹配文本.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">s/(?&lt;=\bJeff)(?=s\b)/&#x27;/g<br></code></pre></td></tr></table></figure><p>结合非捕获型括号:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">s/(<span class="hljs-string">?&lt;</span>=\d)(<span class="hljs-string">?=</span>(<span class="hljs-string">?:\d\d\d</span>)+<span class="hljs-variable">$)</span><br></code></pre></td></tr></table></figure><p>Negtive lookahead <code>(?!...)</code> 和 negtive lookbehind <code>(?&lt;!...)</code>, 就是把等号 <code>=</code> 换成了 <code>!</code> .</p><p>当 their subexpression is not able to match, 成功的位置. 即周围不是什么时匹配的位置.</p><p>可以处理一侧匹配，一侧不匹配的情况.</p><p>Using <code>(?&lt;!\w)(?=\w)|(?&lt;=\w)(?!\w)</code> as a replacement for <code>\b</code>.</p><h3 id="Commafication-without-lookbehind"><a href="#Commafication-without-lookbehind" class="headerlink" title="Commafication without lookbehind"></a>Commafication without lookbehind</h3><p>注意 Lookbehind is not as widely supported as lookahead.</p><h2 id="Text-to-HTML-转换"><a href="#Text-to-HTML-转换" class="headerlink" title="Text-to-HTML 转换"></a>Text-to-HTML 转换</h2><h1 id="3-Overview-of-Regular-Expression-Features-and-Flavors"><a href="#3-Overview-of-Regular-Expression-Features-and-Flavors" class="headerlink" title="3 Overview of Regular Expression Features and Flavors"></a>3 Overview of Regular Expression Features and Flavors</h1><p>“Global Regular Expression Print” 即 grep.</p><p>egrep 即 “extend grep”.</p><h2 id="POSIX-标准化的尝试"><a href="#POSIX-标准化的尝试" class="headerlink" title="POSIX 标准化的尝试"></a>POSIX 标准化的尝试</h2><p>POSIX 把常见的流派分为两大类:</p><pre><code class="hljs">1. Basic Regular Expresion (BREs)2. Extended Regular Expresion (EREs)</code></pre><p><code>PCRE</code> 正则表达式库。</p><h2 id="字符串，-字符编码和匹配模式"><a href="#字符串，-字符编码和匹配模式" class="headerlink" title="字符串， 字符编码和匹配模式"></a>字符串， 字符编码和匹配模式</h2><h3 id="作为正则表达式的字符串"><a href="#作为正则表达式的字符串" class="headerlink" title="作为正则表达式的字符串"></a>作为正则表达式的字符串</h3><p>除了 Perl, awk, sed 之外的大多数语言的正则引擎接收的是以普通字符串形式提供的正则表达式.</p><p>在字符串文字中，必须使用两个紧挨在一起的反斜线才能表示正则表达式中的反斜线。如为了表示正则表达式中的<code>\n</code>, 必须在字符串中使用<code>\\n</code>.</p><p>处理分为了两部分，语言的字符串处理和正则引擎处理.</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>规定了不同数值的字节应该如何解释.</p><h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>It’s a logical mapping between a number and a character.</p><p>这里的 number 称为 code point 常为 hexadecimal 加上“U+” 在前面. 如<code>U+c0B5</code>.</p><h5 id="Characters-versus-combining-character-sequences"><a href="#Characters-versus-combining-character-sequences" class="headerlink" title="Characters versus combining-character sequences"></a>Characters versus combining-character sequences</h5><p>一个字符，可能由两个 code point 来表示. 一个 base character, 一个 combining character.</p><p>Unicode offers  a number of combining characters that are intended to follow a base character.</p><p>两个代码点的字符后面跟一个量词，量词可能作用与第二个代码点.</p><h1 id="4-The-Mechanics-of-Expression-Processing"><a href="#4-The-Mechanics-of-Expression-Processing" class="headerlink" title="4 The Mechanics of Expression Processing"></a>4 The Mechanics of Expression Processing</h1><h2 id="Regex-Engine-Types"><a href="#Regex-Engine-Types" class="headerlink" title="Regex Engine Types"></a>Regex Engine Types</h2><p>分为两类:<br>    1. DFA<br>    2. NFA</p><p>测试了一下，Vim使用的是传统型NFA. egrep 是DFA。</p><p>Two all-encompassing rules:<br>    1. The match that begins earliest (leftmost) wins.<br>    2. The standard quantifiers (*, +, ?, and {m,n}) are greedy.</p><p>如果不能在最开始的位置匹配成功，就会从字符串下一个位置重新开始匹配.</p><p>Backreference 只对NFA引擎有效.</p><p>DFA引擎匹配速度更快。</p><h2 id="Regex-Directed-Versus-Text-Directed"><a href="#Regex-Directed-Versus-Text-Directed" class="headerlink" title="Regex-Directed Versus Text-Directed"></a>Regex-Directed Versus Text-Directed</h2><p>The two basic engine types 反映了算法的差异.</p><p>NFA engine “regex-directed”.</p><p>DFA engine “text-directed”.</p><h3 id="First-Thoughts-NFA-and-DFA-in-Comparison"><a href="#First-Thoughts-NFA-and-DFA-in-Comparison" class="headerlink" title="First Thoughts: NFA and DFA in Comparison"></a>First Thoughts: NFA and DFA in Comparison</h3><p>NFA, Nondeterministic Finite Automaton, 字符串中的字符可能会匹配多次。</p><p>DFA, Deterministic Finite Automaton, 字符串中的字符只会匹配一次.</p><p>不同的表达式会以不同的方式控制引擎.</p><p>DFA keeps track of all matches simultaneously.</p><h3 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h3><p>It’s the essence of an NFA engine. 在面临作出选择的情形是会记住未选的结构. 如量词和多选结构(|).</p><h4 id="Two-Important-Points-on-Backtracking"><a href="#Two-Important-Points-on-Backtracking" class="headerlink" title="Two Important Points on Backtracking"></a>Two Important Points on Backtracking</h4><p>   1.The engine always choose to first make the attempt for greedy quantifiers, and to first skip the attempt for lazy ones. 当量词是greedy时，会尝试匹配，是lazy时会跳过.<br>   2.The most recently saved option is the one returned to when a local failure forces backtracking. They’re used LIFO(last in first out).</p><h3 id="Saved-State"><a href="#Saved-State" class="headerlink" title="Saved State"></a>Saved State</h3><p>This is the basis for NFA matching.</p><p>greedy 量词和 lazy 量词的保存状态不同. 前者在量词作用的pattern后面，后者在前面.</p><h3 id="Backtracking-and-Greediness"><a href="#Backtracking-and-Greediness" class="headerlink" title="Backtracking and Greediness"></a>Backtracking and Greediness</h3><h4 id="Star-plus-and-their-backtracking"><a href="#Star-plus-and-their-backtracking" class="headerlink" title="Star, plus, and their backtracking"></a>Star, plus, and their backtracking</h4><p>每测试一项都会保留一个状态.</p><p>需注意:<br>    1. Backtracking 机制不但需要重新计算正则表达式和文本的对应位置，也需要维护括号内的子表达式所匹配的文本状态.<br>    2. 星号(或其他人和greedy量词)限定的部分不受后面元素的影响，而是匹配尽可能多的内容.</p><p>DFA 只有 greedy 的量词.</p><h3 id="Problem-of-Greediness"><a href="#Problem-of-Greediness" class="headerlink" title="Problem of Greediness"></a>Problem of Greediness</h3><p>不要过分依赖<code>.*</code>, 可能会出问题.</p><p>忽略量词有时可以替代排除类.</p><p>使用排除环视，可以得到与排除型字符组相当的结果.</p><h3 id="The-Essence-of-Greediness-Laziness-and-Backtracing"><a href="#The-Essence-of-Greediness-Laziness-and-Backtracing" class="headerlink" title="The Essence of Greediness, Laziness, and Backtracing"></a>The Essence of Greediness, Laziness, and Backtracing</h3><p>在匹配失败后，就会尝试另外的分支.</p><p>无论是匹配优先还是忽略优先，只要引擎报告匹配失败，它就必然尝试了所有的可能.</p><p>匹配优先和忽略优先区别于测试路径的先后顺序。</p><h3 id="Possessive-Quantifiers-and-Atomic-Grouping"><a href="#Possessive-Quantifiers-and-Atomic-Grouping" class="headerlink" title="Possessive Quantifiers and Atomic Grouping"></a>Possessive Quantifiers and Atomic Grouping</h3><h4 id="Atomic-grouping-with-gt-…"><a href="#Atomic-grouping-with-gt-…" class="headerlink" title="Atomic grouping with (?&gt;…)"></a>Atomic grouping with (?&gt;…)</h4><p>Atomic grouping 即放弃其中的 saved state. </p><h4 id="The-essence-of-atomic-grouping"><a href="#The-essence-of-atomic-grouping" class="headerlink" title="The essence of atomic grouping"></a>The essence of atomic grouping</h4><p>匹配优先和忽略优先都不会影响需要检测路径的本身，而只会影响检测的顺序。如果不能匹配，无论是匹配优先还是忽略优先的顺序，最终每条路径都会被测试.</p><h4 id="Possessive-Quantifiers-and-m-n"><a href="#Possessive-Quantifiers-and-m-n" class="headerlink" title="Possessive Quantifiers, ?+, *+, ++, and {m,n}+"></a>Possessive Quantifiers, <code>?+, *+, ++, and &#123;m,n&#125;+</code></h4><p>Possessive quantifiers are much like greedy quantifiers 但是它们从不交还已经匹配的字符.</p><p>每当做选择时都会创建 saved state.</p><p>Possessive quantifiers 不会创建 saved state.</p><h3 id="The-Backtracking-of-Lookaround"><a href="#The-Backtracking-of-Lookaround" class="headerlink" title="The Backtracking of Lookaround"></a>The Backtracking of Lookaround</h3><p>Lookaround is closely related to atomic grouping and possessive quantifiers.</p><p>There are four types of lookaround:</p><pre><code class="hljs">1. positive2. negetive   flavors of lookahead and lookbehind</code></pre><p>在NFA的世界中包含了 saved state 和 backtracking.</p><p>只要环视结构的匹配尝试结束，它就不会留下任何 saved state.</p><h3 id="Is-Alternation-Greedy"><a href="#Is-Alternation-Greedy" class="headerlink" title="Is Alternation Greedy"></a>Is Alternation Greedy</h3><p>多选结构是按顺序排列的。</p><p>如果多选分支是有序的，而能够匹配同样文本的多选分支又不止一个，就要小心安排多选分支的先后顺序.</p><p>匹配日期时的拆分方法.</p><h2 id="NFA-DFA-and-POSIX"><a href="#NFA-DFA-and-POSIX" class="headerlink" title="NFA, DFA and POSIX"></a>NFA, DFA and POSIX</h2><h3 id="The-Longest-Leftmost"><a href="#The-Longest-Leftmost" class="headerlink" title="The Longest-Leftmost"></a>The Longest-Leftmost</h3><h3 id="POSIX-and-the-Longest-Leftmost-Rule"><a href="#POSIX-and-the-Longest-Leftmost-Rule" class="headerlink" title="POSIX and the Longest-Leftmost Rule"></a>POSIX and the Longest-Leftmost Rule</h3><p>POSIX标准规定，如果在字符串的某个位置存在多个可能的匹配，应当返回的是最长的匹配.</p><h2 id="Summary-NFA-and-DFA-in-Comparison"><a href="#Summary-NFA-and-DFA-in-Comparison" class="headerlink" title="Summary: NFA and DFA in Comparison"></a>Summary: NFA and DFA in Comparison</h2><h3 id="DFA-versus-NFA-Differences-in-the-pre-use-compile"><a href="#DFA-versus-NFA-Differences-in-the-pre-use-compile" class="headerlink" title="DFA versus NFA: Differences in the pre-use compile"></a>DFA versus NFA: Differences in the pre-use compile</h3><p>NFA 的编译过程通常1要快一些，需要的内存也更少一些.</p><h3 id="DFA-versus-NFA-Differences-in-match-speed"><a href="#DFA-versus-NFA-Differences-in-match-speed" class="headerlink" title="DFA versus NFA: Differences in match speed"></a>DFA versus NFA: Differences in match speed</h3><p>一般来说，DFA 的速度和正则表达式无关，而NFA 中两者直接关联.</p><h3 id="DFA-versus-NFA-Differences-in-what-is-matched"><a href="#DFA-versus-NFA-Differences-in-what-is-matched" class="headerlink" title="DFA versus NFA: Differences in what is matched"></a>DFA versus NFA: Differences in what is matched</h3><p>DFA(或者POSIX NFA) 返回最左边的最长的匹配文本. 传统型NFA 可能返回同样的结果，当然也可能是别的文本.</p><h3 id="DFA-versus-NFA-Differences-in-capabilities"><a href="#DFA-versus-NFA-Differences-in-capabilities" class="headerlink" title="DFA versus NFA: Differences in capabilities"></a>DFA versus NFA: Differences in capabilities</h3><p>NFA 能提供一些 DFA 不支持的功能.</p><h3 id="DFA-versus-NFA-Differences-in-ease-of-implementation"><a href="#DFA-versus-NFA-Differences-in-ease-of-implementation" class="headerlink" title="DFA versus NFA: Differences in ease of implementation"></a>DFA versus NFA: Differences in ease of implementation</h3><p>The soul of NFA matching is backtracking.</p>]]></content>
    
    
    <categories>
      
      <category>Regex</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>刻意练习笔记</title>
    <link href="/2022/07/05/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/05/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="心理表征"><a href="#心理表征" class="headerlink" title="心理表征"></a>心理表征</h2><p>心理表征是一种与我们大脑正在思考的某个物体、某个观点、某些信息或者其他任何事物相对应的心理结构，或具体或抽象。</p>]]></content>
    
    
    <categories>
      
      <category>Books</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Learning Perl Notes</title>
    <link href="/2022/07/04/Learning-Perl-Notes/"/>
    <url>/2022/07/04/Learning-Perl-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="第四章-子程序"><a href="#第四章-子程序" class="headerlink" title="第四章 子程序"></a>第四章 子程序</h1><p>区分子程序和内置函数，子程序是由用户定义的，而函数则不一定.</p><p>一般的变量都是全局变量.</p><p>要注意检查返回值。 </p><p>特殊的数组变量<code>@_</code>用于存放参数列表。</p><p><code>my</code> 操作符，创建私有变量。</p><p>直接使用数组“名称”来取得数组元素的个数。</p><h2 id="pop-and-push-shift-and-unshift"><a href="#pop-and-push-shift-and-unshift" class="headerlink" title="pop and push, shift and unshift"></a>pop and push, shift and unshift</h2><p>pop and push do things to the end of an array.</p><p>shift and unshift do things to the start of an array.</p><h2 id="The-if-Control-Structure"><a href="#The-if-Control-Structure" class="headerlink" title="The if Control Structure"></a>The if Control Structure</h2><p>The if control structure must have those block curly braces around the conditional code.</p><p><code>foreach</code> 也必须要有花括号.</p><h2 id="Notes-on-Lexical-my-Variables"><a href="#Notes-on-Lexical-my-Variables" class="headerlink" title="Notes on Lexical (my) Variables"></a>Notes on Lexical (my) Variables</h2><p>Those lexical variables can actully be used in any block.</p><p>区分:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">my</span><span class="hljs-params">(<span class="hljs-variable">$num</span>)</span></span><br>my <span class="hljs-variable">$num</span><br></code></pre></td></tr></table></figure><p>上下文含义不同。</p><p>最好对每一个新变量都使用my声明,</p><p>Perl中的默认变量<code>$_</code>.</p><p>如果编译器在调用子程序前看到过子程序的定义或者Perl通过语法规则判断它只能是子程序调用，就可以省略<code>&amp;</code>.</p><h2 id="持久性私有变量"><a href="#持久性私有变量" class="headerlink" title="持久性私有变量"></a>持久性私有变量</h2><p>Using <code>state</code> to define.</p><p>不能在列表上下文中初始化数组和哈希类型的state变量.</p><p>Using <code>Ctrl-D</code> to stop getting values from <STDIN>.</p><h2 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h2><p>One string can be seen as one element of an array.</p><p>Can’t use defined(@array).</p><p>检查一个变量是否初始化</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">defined</span> <span class="hljs-variable">$var</span>) <br></code></pre></td></tr></table></figure><p>检查一个数组是否为空</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> (<span class="hljs-variable">@array</span>) &#123;<span class="hljs-selector-tag">return</span>&#125;;<br></code></pre></td></tr></table></figure><h1 id="CHAPTER-5-Input-and-Output"><a href="#CHAPTER-5-Input-and-Output" class="headerlink" title="CHAPTER 5 Input and Output"></a>CHAPTER 5 Input and Output</h1><p>需要知道那些情况会返回<code>undef</code>.</p><p>判断是否到文件末尾</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">defined</span>(<span class="hljs-variable">$line</span> = &lt;<span class="hljs-variable constant_">STDIN</span>&gt;))<br></code></pre></td></tr></table></figure><p>or </p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">while</span> <span class="hljs-comment">(&lt;STDIN&gt;)</span><br></code></pre></td></tr></table></figure><p>There is no connection between the line-input operator and Perl’s favorite default variable.</p><h2 id="Input-from-the-Diamond-Operator"><a href="#Input-from-the-Diamond-Operator" class="headerlink" title="Input from the Diamond Operator"></a>Input from the Diamond Operator</h2><p>The diamond operator: &lt;&gt;, it’s actually a special kind of line-input operator.</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">./mytac <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><p>and the mytac file:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">print</span> <span class="hljs-keyword">reverse</span> &lt;&gt;;<br></code></pre></td></tr></table></figure><p>file:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-literal">one</span><br><span class="hljs-literal">two</span><br><span class="hljs-literal">three</span><br></code></pre></td></tr></table></figure><p>will print:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-literal">three</span><br><span class="hljs-literal">two</span><br><span class="hljs-literal">one</span><br></code></pre></td></tr></table></figure><p>The invocation arguments 大抵是命令行参数。</p><p><code>-</code> 连字符通常代表标准输入流。</p><p>钻石操作符从指定位置读取，如命令行参数。</p><p>不加参数时，chomp会直接作用在<code>$_</code>上.</p><p>The invocation arguments 存储在<code>@ARGV</code>中.</p><p>可重新初始化<code>@ARGV</code>:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">@ARGV = <span class="hljs-keyword">qw</span><span class="hljs-comment"># larry moe curly #;</span><br></code></pre></td></tr></table></figure><p>Perl把数组内插到字符串中时，会在每个元素之间加上空格。</p><p><mark>为何输出结果先发送至缓冲区</mark><br>访问磁盘缓慢且效率低.</p><p><code>print &lt;&gt;;</code> 相当于Unix下的cat命令.</p><p><code>print sort &lt;&gt;;</code> 相当于Unix下的sort命令.</p><p>一条规则：假如它看起来像函数调用，它就是一个函数调用.</p><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p>区分：<code>print @array;</code> 和 <code>print &quot;@array&quot;;</code></p><p>The front one print a list of items, the next one print a string. 后者有分隔符.</p><h3 id="用printf格式化输出"><a href="#用printf格式化输出" class="headerlink" title="用printf格式化输出"></a>用printf格式化输出</h3><p>要输出恰当的数字形式，可以使用<code>%g</code>, 可以把<code>g</code>看作”Good conversion for this number”</p><p><code>printf</code>最常用在字段式的数据输出上，指定字段宽度，默认为右对齐。</p><p>A <code>*</code> inside the format string takes the next argument as a width:</p><h3 id="Arrays-and-printf"><a href="#Arrays-and-printf" class="headerlink" title="Arrays and printf"></a>Arrays and printf</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;The items are:\n&quot;</span>.(<span class="hljs-string">&quot;%10s\n&quot;</span> <span class="hljs-keyword">x</span> @items), @items;<br><span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;%*s&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;wilma&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="Filehandles"><a href="#Filehandles" class="headerlink" title="Filehandles"></a>Filehandles</h3><p>A name of a connection(和文件名区分). The connection is between your Perl process and the outside world.</p><p>感觉可以把这个看作<code>link</code>. 和文件操作符也挺像的.</p><p>Recommend to use all uppercase letters in the name of your filehandle.</p><p>Six special filehandle nemes:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">STDIN</span><br><span class="hljs-attribute">STDOUT</span><br><span class="hljs-attribute">STDERR</span><br><span class="hljs-attribute">DATA</span><br><span class="hljs-attribute">ARGV</span><br><span class="hljs-attribute">ARGVOUT</span><br></code></pre></td></tr></table></figure><h3 id="打开filehandle"><a href="#打开filehandle" class="headerlink" title="打开filehandle"></a>打开filehandle</h3><p>使用<code>open</code> operator.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> CONFIG, <span class="hljs-string">&#x27;&lt;dino&#x27;</span>;<br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $selected_output = <span class="hljs-string">&#x27;my_output&#x27;</span>;<br><span class="hljs-keyword">open</span> LOG, <span class="hljs-string">&quot;&gt; $selected_output&quot;</span>;<br></code></pre></td></tr></table></figure><p>三参数写法：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> BEDROCK, <span class="hljs-string">&#x27;&lt;&#x27;</span>, $file_name;<br></code></pre></td></tr></table></figure><p>以特定编码写数据到某个文件：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">open <span class="hljs-built_in">LOG</span>, <span class="hljs-string">&#x27;&gt;&gt;:encoding(UTF-8)&#x27;</span>, <span class="hljs-symbol">$file</span>_name;<br></code></pre></td></tr></table></figure><p>layer, 层的概念和编码转换略有不同，我们可以选择不同的层叠加起来(就是因为能叠加才叫做层)，产生不同的效果.</p><p>判断执行：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">my $success = open <span class="hljs-keyword">LOG</span>, <span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;logfile&#x27;</span>;<br><span class="hljs-keyword">if</span> (! $success) &#123;<br>    <span class="hljs-params">...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>open</code>的返回值，如果为真则为成功，为假则为失败。</p><h3 id="关闭filehandle"><a href="#关闭filehandle" class="headerlink" title="关闭filehandle"></a>关闭filehandle</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">close BEDROCK<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><mark>Small Conclusion</mark><br>filehandle, 用于在Perl程序中操作外部文件。</p><h3 id="用die处理致命错误"><a href="#用die处理致命错误" class="headerlink" title="用die处理致命错误"></a>用die处理致命错误</h3><p><code>die</code> 命令能中止程序并发出错误信息告知原因。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span> (! <span class="hljs-keyword">open</span> LOG, <span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;logfile&#x27;</span>) &#123;<br>    <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Cannot create logfile: $!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>$!</code> 为特殊变量，存放解释性的系统错误信息。只有在系统服务请求失败后才有用。</p><p>程序名保存在特殊变量<code>$0</code>中。</p><p>若在<code>die</code>后面加上换行符，就不会显示行号和文件名。</p><h3 id="用warn送出警告信息"><a href="#用warn送出警告信息" class="headerlink" title="用warn送出警告信息"></a>用warn送出警告信息</h3><p>产生警告信息，不会中止程序. </p><h3 id="自动检测致命错误"><a href="#自动检测致命错误" class="headerlink" title="自动检测致命错误"></a>自动检测致命错误</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">use autodie<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="使用filehandle"><a href="#使用filehandle" class="headerlink" title="使用filehandle"></a>使用filehandle</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @line = &lt;STDIN&gt;;<br><span class="hljs-keyword">if</span> (! <span class="hljs-keyword">open</span> PASSWD, <span class="hljs-string">&quot;/etc/passwd&quot;</span>) &#123;<br>    <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;How did you get logged in? ($!)&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">while</span> (&lt;PASSWD&gt;) &#123;<br>    <span class="hljs-keyword">chomp</span>;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Using in <code>print</code>:</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-built_in">print</span> <span class="hljs-built_in">LOG</span> <span class="hljs-string">&quot;Captain&#x27;s log, stardate 3.14159\n&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="改变默认的文件输出句柄"><a href="#改变默认的文件输出句柄" class="headerlink" title="改变默认的文件输出句柄"></a>改变默认的文件输出句柄</h3><p>使用<code>select</code>:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @line = &lt;STDIN&gt;;<br><span class="hljs-keyword">select</span> BEDROCK;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;I hope&quot;</span>;<br><br></code></pre></td></tr></table></figure><p>特殊变量<code>$|</code>设置为1,使默认句柄在每次进行输出操作后立刻刷新缓冲区。</p><h3 id="用say函数输出"><a href="#用say函数输出" class="headerlink" title="用say函数输出"></a>用say函数输出</h3><p>会自动添加换行符。</p><h3 id="标量变量中的filehandle"><a href="#标量变量中的filehandle" class="headerlink" title="标量变量中的filehandle"></a>标量变量中的filehandle</h3><p>裸字bareword, 即像<code>STDIN</code>这种直接使用，而不是存储在变量中.</p><p>使用前需确保变量为空，以用来存放filehandle. 有人喜欢在变量名后面添加<code>_fh</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @line = &lt;STDIN&gt;;<br><span class="hljs-keyword">my</span> $rocks_fh;<br><span class="hljs-keyword">open</span> $rocks_fh, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;rocks.txt&#x27;</span>;<br><br></code></pre></td></tr></table></figure><p>使用花括号，Perl会知道这个变量是filehandle: <code>print &#123; $rock_fh &#125;;</code></p><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h3><p><code>&lt;STDIN&gt;</code> 只接受一行的输入。</p><p>从标准输入中获取多行:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">my <span class="hljs-meta">@line</span> = <span class="hljs-variable">&lt;STDIN&gt;</span>;<br></code></pre></td></tr></table></figure><p><code>print</code> 的一种用法:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;the first string &quot;</span>, <span class="hljs-string">&quot;, the second string &quot;</span>;<br></code></pre></td></tr></table></figure><h1 id="CHAPTER-6-Hash"><a href="#CHAPTER-6-Hash" class="headerlink" title="CHAPTER 6 Hash"></a>CHAPTER 6 Hash</h1><p>哈希是一种数据结构。<br>和数组的区别：</p><pre><code class="hljs">1. 可以容纳任意多的值2. 用名字检索，键和值，键唯一。3. 没有顺序。</code></pre><p>键总会被转换为字符串。</p><p>哈希是从<code>awk</code>语言中引入的.</p><p>哈希是从键到值的单行道，无法从值反推出其键.</p><h2 id="访问哈希元素"><a href="#访问哈希元素" class="headerlink" title="访问哈希元素"></a>访问哈希元素</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-built_in">hash</span>&#123;<span class="hljs-variable">$some_key</span>&#125;</span><br></code></pre></td></tr></table></figure><p>注意，使用的是花括号.</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-symbol">$family</span>_name&#123;<span class="hljs-string">&#x27;fred&#x27;</span>&#125; = <span class="hljs-string">&#x27;flintstone&#x27;</span>;<br><span class="hljs-symbol">$family</span>_name&#123;<span class="hljs-string">&#x27;barney&#x27;</span>&#125; = <span class="hljs-string">&#x27;rubble&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><p>哈希有自己的名称空间.</p><p>美元符号和花括号，显示一个哈希元素。</p><p>赋值时会<mark>创建哈希元素</mark>：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-symbol">$family</span>_name&#123;<span class="hljs-string">&#x27;wilma&#x27;</span>&#125; = <span class="hljs-string">&#x27;flintstone&#x27;</span>;<br></code></pre></td></tr></table></figure><p>增加了一个新的键值对.</p><h2 id="访问整个哈希"><a href="#访问整个哈希" class="headerlink" title="访问整个哈希"></a>访问整个哈希</h2><p>赋值, 必须是偶数个：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">%some_hash = (<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">35</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-number">12.4</span>);<br></code></pre></td></tr></table></figure><p>在列表上下文中，哈希的值是简单的键-值对列表.</p><p>unwinding the hash – turning it back into a list of key-value pairs.</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@any_array</span> = %some_hash;<br></code></pre></td></tr></table></figure><p>顺序可能错乱.</p><h3 id="Hash-Assignment"><a href="#Hash-Assignment" class="headerlink" title="Hash Assignment"></a>Hash Assignment</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> %new_hash = %old_hash;<br></code></pre></td></tr></table></figure><p>Perl 会先unwind the <code>%old_hash</code> into a list of key-vaule pairs, 然后赋给<code>%new_hash</code>.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> %inverse_hash = <span class="hljs-keyword">reverse</span> %any_hash;<br></code></pre></td></tr></table></figure><p>键值会反转.</p><p>一个Perl的rule: The last in wins.</p><h2 id="The-Big-Arrow"><a href="#The-Big-Arrow" class="headerlink" title="The Big Arrow"></a>The Big Arrow</h2><p>The Big Arrow (&#x3D;&gt;), it’s just a different way to “spell” a comma. 在Perl中，可以使用胖箭头代替逗号.</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">my %last_name = ( <span class="hljs-comment"># a hash may be a lexical variable</span><br>    <span class="hljs-string">&#x27;fred&#x27;</span> =&gt; <span class="hljs-string">&#x27;flintstone&#x27;</span>,<br>    <span class="hljs-string">&#x27;dino&#x27;</span> =&gt; undef,<br>    <span class="hljs-string">&#x27;barney&#x27;</span> =&gt; <span class="hljs-string">&#x27;rubble&#x27;</span>,<br>)<br></code></pre></td></tr></table></figure><p>在使用<code>fat array</code>时，可以省略键两侧的引号：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">my %last_name = ( <span class="hljs-comment"># a hash may be a lexical variable</span><br>    fred =&gt; <span class="hljs-string">&#x27;flintstone&#x27;</span>,<br>    dino =&gt; undef,<br>    barney =&gt; <span class="hljs-string">&#x27;rubble&#x27;</span>,<br>)<br></code></pre></td></tr></table></figure><p>Simple string without quote marks is called a bareword.</p><h2 id="Hash-Function"><a href="#Hash-Function" class="headerlink" title="Hash Function"></a>Hash Function</h2><p>在数组上下文中：<br><code>keys</code> function, return a list of all the keys in a hash.</p><p><code>values</code> function, return a list of corresponding values.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> %hash = (<span class="hljs-string">&#x27;a&#x27;</span> =&gt; <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span> =&gt; <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span> =&gt; <span class="hljs-number">3</span>,);<br><span class="hljs-keyword">my</span> @k = <span class="hljs-keyword">keys</span> %hash;<br><span class="hljs-keyword">my</span> @v = <span class="hljs-keyword">values</span> %hash;<br><br></code></pre></td></tr></table></figure><p>在标量上下文中：<br>返回数量。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $count = <span class="hljs-keyword">keys</span> %hash; <br></code></pre></td></tr></table></figure><p>将哈希作为Boolean：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> (%<span class="hljs-built_in">hash</span>) [<br>  <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;That was a true value!\n&quot;</span>;<br>]<br></code></pre></td></tr></table></figure><p>当至少有一对时为真.</p><h3 id="The-each-Function"><a href="#The-each-Function" class="headerlink" title="The each Function"></a>The each Function</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">while</span> ( ($key, $value) = <span class="hljs-keyword">each</span> %hash ) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$key =&gt; $value\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="The-exists-Function"><a href="#The-exists-Function" class="headerlink" title="The exists Function"></a>The exists Function</h3><p>To see whether a key exists in the hash.</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">exists</span> $books&#123;<span class="hljs-string">&quot;dino&quot;</span>&#125;) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Hey, there&#x27;s a library card for dino!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="The-delete-Function"><a href="#The-delete-Function" class="headerlink" title="The delete  Function"></a>The delete  Function</h3><p>The delete function removes the given key (and its corresponding value).</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $person = <span class="hljs-string">&quot;betty&quot;</span>;<br><span class="hljs-keyword">delete</span> $books&#123;$person&#125;;<br></code></pre></td></tr></table></figure><h3 id="Hash-Element-Interpolation"><a href="#Hash-Element-Interpolation" class="headerlink" title="Hash Element Interpolation"></a>Hash Element Interpolation</h3><p>The magical charaacters that need blackslashing in double quotes: <code>$</code> and <code>@</code>, <code>&quot;</code> and <code>\</code>.</p><h3 id="The-ENV-hash"><a href="#The-ENV-hash" class="headerlink" title="The %ENV hash"></a>The %ENV hash</h3><p>%ENV hash stores the info of environment.<br>You can see a PATH key in %ENV:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;PATH is <span class="hljs-variable">$ENV</span>&#123;PATH&#125;\n&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise"></a>Exercise</h2><p>The <code>chomp</code> function is vital to get input from <code>&lt;STDIN&gt;</code>.</p><p>给哈希赋值使用的是<code>()</code>是列表，使用哈希的时候用<code>&#123;&#125;</code>花括号.</p><p>把未定义的值当成数字使用时，Perl会自动将它转换成0.</p><p>不能对哈希使用<code>push</code>等操作。</p><p>使用<code>my</code>声明多个变量：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">my</span>(<span class="hljs-variable">@words</span>, %count, $word);<br></code></pre></td></tr></table></figure><h1 id="CHAPTER-7-Regular-Expressions"><a href="#CHAPTER-7-Regular-Expressions" class="headerlink" title="CHAPTER 7 Regular Expressions"></a>CHAPTER 7 Regular Expressions</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$_</span> = <span class="hljs-string">&quot;yabba dabba doo&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/abba/</span>) &#123;<br>  print <span class="hljs-string">&quot;It matched!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在字符串中匹配到其中的一部分。</p><p><mark>Interpolating</mark> a variable into a pattern:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">while</span> ( &lt;STDIN&gt; ) &#123;<br>   chomp;<br>   <span class="hljs-keyword">if</span> ( /<span class="hljs-variable">$ARGV</span>[0]/ ) &#123;<br>     <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;\tMatches\n&quot;</span>;<br>   &#125;<br>   <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;\tDoesn&#x27;t match\n&quot;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="The-Wildcard"><a href="#The-Wildcard" class="headerlink" title="The Wildcard"></a>The Wildcard</h2><p>The dot <code>.</code> matches any single character except a newline. <code>\N</code>也有同样的效果。</p><p>The backslash<code>\</code>也是metacharacter.</p><h2 id="Unicode属性"><a href="#Unicode属性" class="headerlink" title="Unicode属性"></a>Unicode属性</h2><p><mark>匹配属性</mark></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">\p&#123;<span class="hljs-keyword">PROPERTY</span><span class="hljs-title"></span>&#125;<br></code></pre></td></tr></table></figure><p><code>p</code> 改为大写表示相反的含义。 </p><h2 id="Quantifier"><a href="#Quantifier" class="headerlink" title="Quantifier"></a>Quantifier</h2><p>如<code>*</code>和<code>+</code>.</p><p><code>?</code>.</p><h2 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h2><p><code>\A</code> anchor matches at the absolute beginning of a string.</p><p><code>\z</code> matches the end of the string.<br><code>\Z</code> allows an optional newline after it.</p><p><code>^</code> caret, match the beginning of line.<br><code>$</code> match the end of line.</p><h3 id="Word-Anchors"><a href="#Word-Anchors" class="headerlink" title="Word Anchors"></a>Word Anchors</h3><p><code>\b</code>.</p><p>like:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/\bfred\b/</span><br></code></pre></td></tr></table></figure><p>It matches at the start or end of a group of <code>\w</code> characters.</p><p>The <mark>nonword-boundary anchor</mark><br><code>\B</code>.</p><h2 id="模式分组"><a href="#模式分组" class="headerlink" title="模式分组"></a>模式分组</h2><p>使用小括号<code>()</code>. 圆括号也是元字符。</p><p><mark>back reference</mark><br>为什么叫 back reference , 可能是要往回看括号里面的内容，所以是“back”.</p><p>用括号捕获，反斜线加数字引用。引用的含义是再次匹配括号的内容。要忽略嵌套.</p><p>通过左括号判断次序。</p><p>新的写法：<code>\g&#123;N&#125;</code>, N为组号。使用perl5.10。</p><p><mark>relative back reference</mark>相对反向引用。<br>使用负数，从当前位置往前数.</p><h2 id="择一匹配"><a href="#择一匹配" class="headerlink" title="择一匹配"></a>择一匹配</h2><p>竖线<code>|</code>.</p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>character class, <code>[]</code>.</p><p>脱字符<code>^</code>.</p><h2 id="字符集的简写"><a href="#字符集的简写" class="headerlink" title="字符集的简写"></a>字符集的简写</h2><p>如 <code>\d</code> 表示任意一个数字。</p><p><code>\R</code>匹配任意一种断行符。</p><p><code>\w</code>匹配单词字符。</p><p><code>\s</code>匹配空白字符。</p><h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise"></a>Exercise</h2><p>反向引用引用的是匹配到的值。</p><h1 id="CHAPTER-8-Matching-with-Regular-Expressions"><a href="#CHAPTER-8-Matching-with-Regular-Expressions" class="headerlink" title="CHAPTER 8 Matching with Regular Expressions"></a>CHAPTER 8 Matching with Regular Expressions</h1><h2 id="Matches-with-m-x2F-x2F"><a href="#Matches-with-m-x2F-x2F" class="headerlink" title="Matches with m&#x2F;&#x2F;"></a>Matches with m&#x2F;&#x2F;</h2><p><code>/pattern/</code> is a short cut of <code>m/pattern/</code>, pattern match operator. 模式匹配。</p><p>可以使用不同的分界符：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">m</span><span class="hljs-params">(fred)</span></span><br>m&lt;fred&gt;<br>m&#123;fred&#125;<br>...<br></code></pre></td></tr></table></figure><p>使用<code>/pattern/</code>可省略<code>m</code>.</p><h2 id="Match-Modifier"><a href="#Match-Modifier" class="headerlink" title="Match Modifier"></a>Match Modifier</h2><p>Sometimes called flags.</p><h3 id="Case-Insentive-Matching-with-i"><a href="#Case-Insentive-Matching-with-i" class="headerlink" title="Case-Insentive Matching with /i"></a>Case-Insentive Matching with <code>/i</code></h3><p>Using <code>/i</code> modifier.</p><h3 id="Matching-Any-Character-with-s"><a href="#Matching-Any-Character-with-s" class="headerlink" title="Matching Any Character with /s"></a>Matching Any Character with <code>/s</code></h3><p>让<code>.</code>能够匹配换行符。Using <code>/s</code>.</p><p>v5.12新增<code>\N</code>代表<code>\n</code>的补集。</p><h3 id="Adding-Whitespace-with-x"><a href="#Adding-Whitespace-with-x" class="headerlink" title="Adding Whitespace with \x"></a>Adding Whitespace with <code>\x</code></h3><p>让正则表达式中的whitespace不起作用:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/ -? [0-9]+ \.? [0-9] /</span>x<br></code></pre></td></tr></table></figure><p>不会匹配其中的空格.如果要匹配whitespace可以使用<code>\s</code>或escape a literal space.</p><h3 id="Combining-Option-Modifiers"><a href="#Combining-Option-Modifiers" class="headerlink" title="Combining Option Modifiers"></a>Combining Option Modifiers</h3><p>使用多个modifier, like:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/barney.*fred/i</span>s) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Choosing-a-Character-Interpretation"><a href="#Choosing-a-Character-Interpretation" class="headerlink" title="Choosing a Character Interpretation"></a>Choosing a Character Interpretation</h3><p>在 Perl v5.14 中添加的特性，选择解释方式like:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/\w+/</span>a  <span class="hljs-comment">#use the ASCII interpretation of character classes</span><br><span class="hljs-regexp">/\w+/u</span>  <span class="hljs-comment">#use Unicode</span><br><span class="hljs-regexp">/\w+/</span>l  <span class="hljs-comment">#respect the locale</span><br></code></pre></td></tr></table></figure><p><mark>case fold</mark><br>In Unicode, lowercasing is not one-to-one.</p><p>只对应ASCII字符的大小写:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/k/</span>aai<br></code></pre></td></tr></table></figure><p>用两个<code>\a</code>modifier.</p><p>使用<code>chr()</code> to ensure we get the right bit pattern regardless of the encoding issues:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">$_ = &lt;STDIN&gt;;<br><span class="hljs-keyword">my</span> $OE = <span class="hljs-keyword">chr</span>( <span class="hljs-number">0xBC</span> );<br><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/$OE/i</span>) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Found $OE\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Beginning-and-End-of-Line-Anchors"><a href="#Beginning-and-End-of-Line-Anchors" class="headerlink" title="Beginning and End-of-Line Anchors"></a>Beginning and End-of-Line Anchors</h3><p>如果没有<code>\m</code>那么<code>^</code>和<code>$</code>就和<code>\A</code>和<code>\Z</code>一样.</p><h2 id="The-Binding-Operator"><a href="#The-Binding-Operator" class="headerlink" title="The Binding Operator =~"></a>The Binding Operator <code>=~</code></h2><p>正则表达式默认作用于<code>$_</code>.</p><p>不再使用 default string , using <code>=~</code> tells Perl to match the pattern on the right against the string on the left:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">my</span> <span class="hljs-variable">$some_other</span> = <span class="hljs-string">&quot;I dream of betty rubbls,&quot;</span>;<br><span class="hljs-attribute">if</span> (<span class="hljs-variable">$some_other</span> =<span class="hljs-regexp">~ /\brub\b)</span> &#123;<br>  <span class="hljs-attribute">print</span> <span class="hljs-string">&quot;Aye, there&#x27;s the rub.\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>If there’s no binding operator, the expression uses <code>$_</code> by default.</p><p>只有<code>&lt;STDIN&gt;</code>单独出现在控制语句中，<code>$_</code>才会自动存储.</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">my <span class="hljs-symbol">$li</span>kes_perl = &lt;STDIN&gt; =~ <span class="hljs-regexp">/\byes\b/i</span>;<br></code></pre></td></tr></table></figure><h2 id="The-Match-Variables"><a href="#The-Match-Variables" class="headerlink" title="The Match Variables"></a>The Match Variables</h2><p>Each regular expression capture holds part of the original string, not part of the pattern.</p><p>They are named like <code>$1</code>.</p><p><mark>The difference of <code>\4</code> and <code>$4</code></mark><br><code>\4</code> refers back to the capture during the pattern while it is trying to match.</p><p><code>$4</code> refers to the capture of an already completed pattern match.</p><p>Empty string 和 undef 是不同的，if you have three or fewer sets of parentheses in the pattern, $4 will be undef.</p><h2 id="The-Persistence-of-Captures"><a href="#The-Persistence-of-Captures" class="headerlink" title="The Persistence of Captures"></a>The Persistence of Captures</h2><p>These capture variables generally stay around until the next successful pattern match.</p><p>If you need a capture for more than a few lines, it’s generally best to copy it into an ordinary variable.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $wilma_word = $1;<br></code></pre></td></tr></table></figure><h2 id="Noncapturing-Parentheses"><a href="#Noncapturing-Parentheses" class="headerlink" title="Noncapturing Parentheses"></a>Noncapturing Parentheses</h2><p>Adding <code>?:</code> after the opening parenthesis, which tell Perl you only want to use these parenthesis fo grouping.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/(?:bronto)?saurus (steak|burger)/</span>) &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Fred wants a $1\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>\n</code>flag, which is added in v5.22, 可以把所有括号转换为noncapturing groups.</p><p>命名match variable, adding in Perl v5.10.<br>匹配到的内容存放在hash<code>%+</code>中:</p><p>在regex中用<code>?&lt;LABEL&gt;PATTERN</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">use</span> v5.<span class="hljs-number">10</span>;<br><br><span class="hljs-attribute">my</span> <span class="hljs-variable">$names</span> = <span class="hljs-string">&#x27;Fred or Barney&#x27;</span>;<br><span class="hljs-attribute">if</span> ( <span class="hljs-variable">$names</span> =<span class="hljs-regexp">~ m/(?&lt;name1&gt;\w+)</span> (?:and|or) (?&lt;name2&gt;\w+)/) &#123;<br>  <span class="hljs-attribute">say</span> <span class="hljs-string">&quot;I saw $+&#123;name1&#125; and $+&#123;name2&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>\g&#123;lable&#125;</code> to back reference. 因为没有数字标记.</p><h2 id="The-Automatic-Match-Variables"><a href="#The-Automatic-Match-Variables" class="headerlink" title="The Automatic Match Variables"></a>The Automatic Match Variables</h2><p>为了避免和自己命名的容易重合，many of Perl’s build-in variables 具有奇怪的名字.</p><p>Three automatic match variables: <code>$&amp;</code>, <code>$上飘</code> and <code>$&#39;</code>.</p><p><code>$&amp;</code> stores the actually matched pattern.</p><p><code>$上飘</code> stores whatever came before the matched session. </p><p><code>$&#39;</code> stores whatever came after the matched session.</p><p>所以就是前中后. They will stay around until the next successful pattern match. 使用这些automatic match variable 会让程序变慢.</p><p>在 v5.10 或更高版本中，可使用:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$&#123;^PREMATCH&#125;</span> <span class="hljs-variable">$&#123;^MATCH&#125;</span> <span class="hljs-variable">$&#123;^POSTMATCH&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Precedence"><a href="#Precedence" class="headerlink" title="Precedence"></a>Precedence</h2><p>关于两个之间的结合。</p><p>只有四个level.</p><pre><code class="hljs">1.parentheses () 2.quantifier *, + and ?, &#123;n,m&#125;3.anchors and sequence \A, \Z, \z, ^, $, \b, \B4.vertical bar |5.so-called atoms</code></pre><h2 id="A-Pattern-Test-Program"><a href="#A-Pattern-Test-Program" class="headerlink" title="A Pattern Test Program"></a>A Pattern Test Program</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">while</span> (&lt;&gt;) &#123;    <span class="hljs-comment"># take one input line at a time</span><br>  <span class="hljs-keyword">chomp</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/YOUR_PATTERN_GOES_HERE/</span>) &#123;<br>     <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Matched: |$上飘&lt;$&amp;&gt;$&#x27;|\n&quot;</span>;  <span class="hljs-comment"># the special match vars</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;No match: |$_|\n&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise"></a>Exercise</h2><h1 id="CHAPTER-9-Processing-Text-with-Regular-Expressions"><a href="#CHAPTER-9-Processing-Text-with-Regular-Expressions" class="headerlink" title="CHAPTER 9 Processing Text with Regular Expressions"></a>CHAPTER 9 Processing Text with Regular Expressions</h1><h2 id="Substitutions-with-s-x2F-x2F-x2F"><a href="#Substitutions-with-s-x2F-x2F-x2F" class="headerlink" title="Substitutions with s&#x2F;&#x2F;&#x2F;"></a>Substitutions with s&#x2F;&#x2F;&#x2F;</h2><p>This simply replaces whatever part of a variable matches the pattern with a replacement string.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$_ = <span class="hljs-string">&quot;He&#x27;s out bowing with Barney tonight.&quot;</span>;<br><span class="hljs-regexp">s/Barney/Fred/</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$_\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>Using Boolean value to judge:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">$_ = <span class="hljs-string">&quot;fred flinnstone&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-regexp">s/fred/wilma/</span>) &#123;<br>   <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Successfully rep;aced fred with wilma.&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Globale-Replacements-with-x2F-g"><a href="#Globale-Replacements-with-x2F-g" class="headerlink" title="Globale Replacements with &#x2F;g"></a>Globale Replacements with &#x2F;g</h3><p>like:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">s</span>/\<span class="hljs-selector-tag">A</span>\<span class="hljs-selector-tag">s</span>+|\<span class="hljs-selector-tag">s</span>+\<span class="hljs-selector-tag">z</span><span class="hljs-comment">//g</span><br></code></pre></td></tr></table></figure><h3 id="Different-Delimiters"><a href="#Different-Delimiters" class="headerlink" title="Different Delimiters"></a>Different Delimiters</h3><p>Using <code>#</code> like:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">s<span class="hljs-meta">#\Ahttps:<span class="hljs-comment">//#http://#</span></span><br></code></pre></td></tr></table></figure><p>使用成对的delimiters需分别括住:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">s</span><span class="hljs-template-variable">&#123;fred&#125;</span><span class="hljs-template-variable">&#123;barney&#125;</span><span class="language-xml">;</span><br></code></pre></td></tr></table></figure><h3 id="Nondestructive-Substitutions"><a href="#Nondestructive-Substitutions" class="headerlink" title="Nondestructive Substitutions"></a>Nondestructive Substitutions</h3><p>复制一份:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $original = <span class="hljs-string">&#x27;Fred ate 1 rid&#x27;</span>;<br><span class="hljs-keyword">my</span> $copy = $original;<br>$copy =~ <span class="hljs-regexp">s/\d+ ribs?/10 ribs/</span>;<br></code></pre></td></tr></table></figure><p>Adding in Perl 5.14, 使用<code>\r</code>modifier可保留original strng alone and return a modified copy of it:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">14</span>;<br><br><span class="hljs-keyword">my</span> $copy = $original =~ <span class="hljs-regexp">s/\d+ ribs?/10 ribs/r</span>;<br></code></pre></td></tr></table></figure><p><code>=~</code> is higher precedence than the <code>=</code>.</p><h3 id="Case-Shifting"><a href="#Case-Shifting" class="headerlink" title="Case Shifting"></a>Case Shifting</h3><p>Using <code>\U</code> forces what follows to all uppercase:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$_</span> = <span class="hljs-string">&quot;I saw Barney with Fred,&quot;</span>;<br>s<span class="hljs-regexp">/(fred|barney)/</span>\U<span class="hljs-variable">$1</span>/gi;<br></code></pre></td></tr></table></figure><p>The <code>\L</code> escape forces lowercase.</p><p>Turning off case shifting with <code>\E</code>.</p><p>When written in lowercase (<code>\l</code> and <code>\u</code>), they affect only the next character,</p><p>Using <code>\u</code> with <code>\L</code> means “all lowercase, but capitalize the first letter.”.</p><p>These escape sequences are avaliable in any double-quotish string:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Hello, \L\u<span class="hljs-variable">$name</span>\E, would you like to play a game?\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>Functions <code>lc</code>, <code>uc</code>, <code>fc</code>, <code>lcfirst</code>, and <code>ucfirst</code>. like:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $start = <span class="hljs-string">&quot;Fred&quot;</span>;<br><span class="hljs-keyword">my</span> $uncapp = <span class="hljs-keyword">lc</span>( $start );<br></code></pre></td></tr></table></figure><h3 id="Metaquoting"><a href="#Metaquoting" class="headerlink" title="Metaquoting"></a>Metaquoting</h3><p>太多的backslashes会很乱。Using <code>\Q</code>和<code>\E</code>.</p><p><code>\Q</code> quote everything after it. 也可以用<code>quotemeta</code>function:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $profix = <span class="hljs-keyword">quotemeta</span>( $input_pattern );<br><span class="hljs-keyword">if</span> ( <span class="hljs-regexp">s/$prefix(Fred)/$1/</span> ) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Replaced $1\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="The-split-Operator"><a href="#The-split-Operator" class="headerlink" title="The split Operator"></a>The split Operator</h2><p>It looks like this:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @field = <span class="hljs-keyword">split</span> <span class="hljs-regexp">/separator/</span>, $string;<br></code></pre></td></tr></table></figure><p>就是根据指定的分隔符来分割。返回一个list.</p><p>一个rule, leading empty fields are always returned, but trailing empty fields are discarded.</p><p>if you want the trailing empty field, give splite a third argument of -1.</p><p>The dafault for splite is to break up <code>$_</code> on whitespace:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @fields = <span class="hljs-keyword">split</span>;<br></code></pre></td></tr></table></figure><h2 id="The-join-Function"><a href="#The-join-Function" class="headerlink" title="The join Function"></a>The join Function</h2><p>The join function looks like this:</p><p><code>join</code> 的第一个参数是string.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $result = <span class="hljs-keyword">join</span> $glue, @pieces;<br></code></pre></td></tr></table></figure><p>用<code>$glue</code>中的内容来连接<code>@pieces</code>中的元素. 返回resulting string.</p><p>Using <code>split</code> and <code>join</code> to work together.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> @values = <span class="hljs-keyword">split</span> <span class="hljs-regexp">/:/</span>, $x;<br><span class="hljs-keyword">my</span> $z = <span class="hljs-keyword">join</span> <span class="hljs-string">&quot;-&quot;</span>, @values;<br></code></pre></td></tr></table></figure><h2 id="m-x2F-x2F-in-List-Context"><a href="#m-x2F-x2F-in-List-Context" class="headerlink" title="m&#x2F;&#x2F; in List Context"></a>m&#x2F;&#x2F; in List Context</h2><p>When a pattern match <code>m//</code> is used in a list context, the return value is a list of the capture variables created in the match, or an empty list if the match failed.</p><p>返回捕获组。也可用于分离:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $text = <span class="hljs-string">&quot;Fred dropped a 5 ton granite block on Mr.Slate&quot;</span>;<br><span class="hljs-keyword">my</span> @words = ($text =~ <span class="hljs-regexp">/([a-z]+)/ig</span>);<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Result: @words\n&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="More-Powerful-Regular-Expressions"><a href="#More-Powerful-Regular-Expressions" class="headerlink" title="More Powerful Regular Expressions"></a>More Powerful Regular Expressions</h2><h3 id="Nongreedy-Quantifier"><a href="#Nongreedy-Quantifier" class="headerlink" title="Nongreedy Quantifier"></a>Nongreedy Quantifier</h3><p>Adding <code>?</code> after the quantifier</p><p>匹配as few as possible, like:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">my</span> <span class="hljs-variable">$text</span> = <span class="hljs-string">&#x27;&lt;b&gt;Fred&lt;/b&gt; and &lt;b&gt;Barney&lt;/b&gt;&#x27;</span>;<br><span class="hljs-attribute">my</span> <span class="hljs-variable">$match_count</span> = <span class="hljs-variable">$text</span> =<span class="hljs-regexp">~ s|&lt;b&gt;(.*?)&lt;/b&gt;|\U<span class="hljs-variable">$1</span>|g</span>;<br><span class="hljs-attribute">print</span> <span class="hljs-string">&quot;<span class="hljs-variable">$match_count</span>: <span class="hljs-variable">$text</span>\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>会匹配到两个而不是一个.</p><h3 id="Fancier-Word-Boundaries"><a href="#Fancier-Word-Boundaries" class="headerlink" title="Fancier Word Boundaries"></a>Fancier Word Boundaries</h3><p>Adding in Perl 5.22, adding curly braces to denote:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">22</span>;<br><br><span class="hljs-keyword">my</span> $string = <span class="hljs-string">&quot;this doesn&#x27;t capitalize correctly.&quot;</span>;<br>$string =~ <span class="hljs-regexp">s/\b&#123;wb&#125;(\w)/\U$1/g</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$string\n&quot;</span>;<br></code></pre></td></tr></table></figure><p><code>\b&#123;wb&#125;</code> 用于单词.<br><code>\b&#123;sb&#125;</code> 用于句号.<br><code>\b&#123;lb&#125;</code> knows where to insert the newlines.</p><h3 id="Matching-Multiple-Line-Text"><a href="#Matching-Multiple-Line-Text" class="headerlink" title="Matching Multiple-Line Text"></a>Matching Multiple-Line Text</h3><p>Using <code>^</code> and <code>$</code> for whole string.</p><p>Adding <code>\m</code> for one line.</p><h3 id="Updating-Many-Files"><a href="#Updating-Many-Files" class="headerlink" title="Updating Many Files"></a>Updating Many Files</h3><p>Perl’s own <code>localtime</code> function.</p><p>The special variable <code>$^I</code>. By default it’s undef, when there’s a string in <code>$^I</code>, that string is used as a backup filename’s extension. 即该字符串就会变成备份文件的扩展名，新的内容会output到以原来的文件名为名的文件中.</p><p>Perl没有实际修改一个文件, 它创建了一个新文件并传入更新的内容.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#! /usr/bin/perl -w</span><br><br><span class="hljs-keyword">use</span> strict;<br><br><span class="hljs-keyword">chomp</span>(<span class="hljs-keyword">my</span> $date = <span class="hljs-string">`date`</span>);<br>$^I = <span class="hljs-string">&quot;.bak&quot;</span>;<br><br><span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>  <span class="hljs-regexp">s/\AAuthor:.*/Author: Randal L. Schwartz/</span>;<br>  <span class="hljs-regexp">s/\APhone:.*\n//</span>;<br>  <span class="hljs-regexp">s/\ADate:.*/Date: $date/</span>;<br>  <span class="hljs-keyword">print</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="In-Place-Editing-from-the"><a href="#In-Place-Editing-from-the" class="headerlink" title="In-Place Editing from the"></a>In-Place Editing from the</h3><p>Some options:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-p    Telling Perl <span class="hljs-keyword">to</span> write a program <span class="hljs-keyword">for</span> you like:<br><span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>   <span class="hljs-built_in">print</span> ;<br>&#125;<br><br>-n    Leaving out the automatic <span class="hljs-built_in">print</span> statement.<br><br>-i.bak    <span class="hljs-keyword">To</span> <span class="hljs-built_in">get</span> a backupfile, <span class="hljs-keyword">if</span> you don<span class="hljs-string">&#x27;t, using -i alone.</span><br><span class="hljs-string"></span><br><span class="hljs-string">-w    Turning on the warnings.</span><br><span class="hljs-string"></span><br><span class="hljs-string">-e    says &quot;executable code follows&quot; 代码会添加到print之前.</span><br></code></pre></td></tr></table></figure><p>for example:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ perl -<span class="hljs-selector-tag">p</span> -<span class="hljs-selector-tag">i</span><span class="hljs-selector-class">.bak</span> -w -e <span class="hljs-string">&#x27;s/Randall/Randal/g&#x27;</span> fred*.dat<br></code></pre></td></tr></table></figure><h2 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise"></a>Exercise</h2><p>打开文件，需要判断是否成功打开。</p><h1 id="CHAPTER-10-More-Control-Structures"><a href="#CHAPTER-10-More-Control-Structures" class="headerlink" title="CHAPTER 10 More Control Structures"></a>CHAPTER 10 More Control Structures</h1><h2 id="The-unless-Control-Structure"><a href="#The-unless-Control-Structure" class="headerlink" title="The unless Control Structure"></a>The unless Control Structure</h2><p>Executing a block of code only whe n the conditional is false:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">unless</span> ($fred =~ <span class="hljs-regexp">/\A[A-Z_]\w*\z/i</span>) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The value of ...&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="The-else-Clause-with-unless"><a href="#The-else-Clause-with-unless" class="headerlink" title="The else Clause with unless"></a>The else Clause with unless</h3><p>The syntax is:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso">unless () &#123;<br>  <span class="hljs-params">...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-params">...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="The-until-Control-Structure"><a href="#The-until-Control-Structure" class="headerlink" title="The until Control Structure"></a>The until Control Structure</h2><p>Revers  the condition of a while loop.</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">until</span> ($j &gt; $i) &#123;<br>  $j *= <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Statement-Modifiers"><a href="#Statement-Modifiers" class="headerlink" title="Statement Modifiers"></a>Statement Modifiers</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;<span class="hljs-variable">$n</span> is a negative number.\n&quot;</span> <span class="hljs-keyword">if</span> <span class="hljs-variable">$n</span> &lt; 0; <br></code></pre></td></tr></table></figure><p>Perl 还是会evaluated first.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">&amp;error(<span class="hljs-string">&quot;Invalid input&quot;</span>) <span class="hljs-keyword">unless</span> &amp;valid($input);<br>$i *= <span class="hljs-number">2</span> <span class="hljs-keyword">until</span> $i &gt; $j;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot; &quot;</span>, ($n += <span class="hljs-number">2</span>) <span class="hljs-keyword">while</span> $n &lt; <span class="hljs-number">10</span>;<br>&amp;greet($_) <span class="hljs-keyword">foreach</span> @person;<br></code></pre></td></tr></table></figure><h2 id="The-Naked-Block-Control-Structure"><a href="#The-Naked-Block-Control-Structure" class="headerlink" title="The Naked Block Control Structure"></a>The Naked Block Control Structure</h2><p>The so-called “naked” block  is one without a keyword or condition.</p><p>like:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Please enter a number: &quot;</span>;<br>  <span class="hljs-keyword">chomp</span>(<span class="hljs-keyword">my</span> $n = &lt;STDIN&gt;);<br>  <span class="hljs-keyword">my</span> $root = <span class="hljs-keyword">sqrt</span> $n;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The square root of $n is $root.\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不是loop，只运行一次.</p><h2 id="The-elsif-Clause"><a href="#The-elsif-Clause" class="headerlink" title="The elsif Clause"></a>The elsif Clause</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span> ( ! <span class="hljs-keyword">defined</span> $dino ) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The value is undef.\n&quot;</span>;<br>&#125; <span class="hljs-keyword">elsif</span> ($dino =~ <span class="hljs-regexp">/^-?\d+\.?$/</span>) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;The value is an integer.\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Autoincrement-and-Autodecrement"><a href="#Autoincrement-and-Autodecrement" class="headerlink" title="Autoincrement and Autodecrement"></a>Autoincrement and Autodecrement</h2><p>The autoincrement operator <code>++</code>.</p><p>The autodecrement operator <code>--</code>.</p><h2 id="The-for-Control-Structure"><a href="#The-for-Control-Structure" class="headerlink" title="The for Control Structure"></a>The for Control Structure</h2><p>like C:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (initialization<span class="hljs-comment">; test; increment) &#123;</span><br>body<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="The-Secret-Connection-Between-foreach-and-for"><a href="#The-Secret-Connection-Between-foreach-and-for" class="headerlink" title="The Secret Connection Between foreach and for"></a>The Secret Connection Between foreach and for</h2><p>Inside the Perl parser, the keyword foreach is exactly equivalent tp the keyword for.</p><p>If it find semicolons, it’s the C-style for.</p><h2 id="The-last-Operator"><a href="#The-last-Operator" class="headerlink" title="The last Operator"></a>The last Operator</h2><p>Like <code>break</code> operator in C.</p><p>The last operator immediately ends execution of the loop.</p><h2 id="The-next-Operator"><a href="#The-next-Operator" class="headerlink" title="The next Operator"></a>The next Operator</h2><p>Like <code>continue</code> operator in C.</p><p>开始下一轮循环.</p><h2 id="The-redo-Operator"><a href="#The-redo-Operator" class="headerlink" title="The redo Operator"></a>The redo Operator</h2><p>重新开始循环.</p><h2 id="Labeled-Block"><a href="#Labeled-Block" class="headerlink" title="Labeled Block"></a>Labeled Block</h2><p>Lables in Perl are like other identifiers.</p><p>Recommending to make them to be all uppercase.</p><p>To lable a loop block, just put the label and a colon in front of the loop:</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">LINE</span>: <span class="hljs-keyword">while</span> (&lt;&gt;) &#123;<br>  <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">split</span>) &#123;<br>    last <span class="hljs-keyword">LINE</span> <span class="hljs-keyword">if</span> /__END__/<span class="hljs-comment">;</span><br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>You may use lable after <code>lasr</code>, <code>next</code>, or <code>redo</code>.</p><h2 id="The-Conditional-Operator"><a href="#The-Conditional-Operator" class="headerlink" title="The Conditional Operator"></a>The Conditional Operator</h2><p>C语言有的东西，Perl基本上也有.</p><p>The conditional operator: <code>?:</code>.</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">expression ? <span class="hljs-keyword">if</span>_<span class="hljs-literal">true</span>_expr : <span class="hljs-keyword">if</span>_<span class="hljs-literal">false</span>_expr<br></code></pre></td></tr></table></figure><h2 id="Logical-Operators"><a href="#Logical-Operators" class="headerlink" title="Logical Operators"></a>Logical Operators</h2><p>Logical AND operator <code>&amp;&amp;</code> and logical OR operator <code>||</code>.</p><h2 id="The-Value-of-a-Short-Circuit-Operator"><a href="#The-Value-of-a-Short-Circuit-Operator" class="headerlink" title="The Value of a Short-Circuit Operator"></a>The Value of a Short-Circuit Operator</h2><p>Using logical OR operator to selecting a default value:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $last_name = $last_name&#123;$someone&#125; || <span class="hljs-string">&#x27;(No last name)&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="The-defined-or-Operator"><a href="#The-defined-or-Operator" class="headerlink" title="The defined-or Operator"></a>The defined-or Operator</h2><p>The defined-or operator <code>//</code>. Adding in perl 5.10:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">use v5.<span class="hljs-number">10</span>;<br><br>my <span class="hljs-variable">$last_name</span> = <span class="hljs-variable">$last_name</span>&#123;<span class="hljs-variable">$someone</span>&#125; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;(No last name)&#x27;</span>;<br></code></pre></td></tr></table></figure><p>Set a value when there isn’t one already:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> v5.<span class="hljs-number">10</span>;<br><span class="hljs-keyword">use</span> warning;<br><br><span class="hljs-keyword">my</span> $name;<br><span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;%s&quot;</span>, $name // <span class="hljs-string">&#x27;&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="Control-Structure-Using-Partial-Evaluation-Operators"><a href="#Control-Structure-Using-Partial-Evaluation-Operators" class="headerlink" title="Control Structure Using Partial-Evaluation Operators"></a>Control Structure Using Partial-Evaluation Operators</h2><p><code>&amp;&amp;</code>, <code>||</code>, <code>//</code>, and <code>?:</code> are share a peculiar property: depending upon the value on the left side, they may or may not evaluate an expression. They are sometimes called partial-evaluation operator.</p><h2 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise"></a>Exercise</h2><p>使用<code>say</code>函数要添加<code>use v5.10</code>.</p><h1 id="CHAPTER-11-Perl-Modules"><a href="#CHAPTER-11-Perl-Modules" class="headerlink" title="CHAPTER 11 Perl Modules"></a>CHAPTER 11 Perl Modules</h1><h2 id="Finding-Modules"><a href="#Finding-Modules" class="headerlink" title="Finding Modules"></a>Finding Modules</h2><p>Modules come in two types:</p><pre><code class="hljs">  1. Come with Perl  2. Get from CAPN  3. Vendor modules</code></pre><h3 id="Check-if-it-is-already-installed"><a href="#Check-if-it-is-already-installed" class="headerlink" title="Check if it is already installed"></a>Check if it is already installed</h3><p>One way, read with <code>perldoc</code>:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>perldoc <span class="hljs-title class_">Digest</span>::<span class="hljs-title class_">SHA</span><br></code></pre></td></tr></table></figure><h3 id="Give-details-on-a-module"><a href="#Give-details-on-a-module" class="headerlink" title="Give details on a module"></a>Give details on a module</h3><p>Using <code>capn</code> command:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>cpan -D <span class="hljs-title class_">Digest</span>::<span class="hljs-title class_">SHA</span><br></code></pre></td></tr></table></figure><h2 id="Install-Modules"><a href="#Install-Modules" class="headerlink" title="Install Modules"></a>Install Modules</h2><p>If you use <code>ExtUtils::MakeMaker</code>.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>perl Makefile.PL<br><span class="hljs-variable">$ </span>make install<br></code></pre></td></tr></table></figure><p>Special another directory with an <code>INSTALL_BASE</code> argument to Makefile.PL:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$ perl Makefile.PL INSTALL_BASE=<span class="hljs-regexp">/Users/</span>fred/lib<br></code></pre></td></tr></table></figure><p>Using another module <code>Module::Build</code></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>perl Build.PL<br><span class="hljs-variable">$ </span>./Build install<br></code></pre></td></tr></table></figure><p>Specify an alternate installation directory:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$ perl Build.PL --install_base=<span class="hljs-regexp">/Users/</span>fred/lib<br></code></pre></td></tr></table></figure><p>The <code>.pm</code> file extension stands for “Perl Module”.</p><p>启用perl自己的shell来满足依赖:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">perl</span> -MCPAN -<span class="hljs-keyword">e</span> <span class="hljs-keyword">shell</span><br></code></pre></td></tr></table></figure><p>使用<code>cpan</code>来下载, 后面跟模块:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>cpan <span class="hljs-title class_">Module</span>::<span class="hljs-title class_">CoreList</span> <span class="hljs-title class_">LWP</span> <span class="hljs-title class_">CGI</span>::<span class="hljs-title class_">Prototype</span><br></code></pre></td></tr></table></figure><p>使用 Perl Package Manager (PPM) 来下载:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ppm time::<span class="hljs-title class_">Moment</span><br></code></pre></td></tr></table></figure><p>使用<code>cpanm</code>(for cpanminus):</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>cpanm <span class="hljs-title class_">DBI</span> <span class="hljs-title class_">WWW</span>::<span class="hljs-title class_">Mechanize</span><br></code></pre></td></tr></table></figure><h2 id="Using-Your-Own-Directories"><a href="#Using-Your-Own-Directories" class="headerlink" title="Using Your Own Directories"></a>Using Your Own Directories</h2><p>Using <code>local::lib</code>.</p><p>To see what they set by loading the module on the command line:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>perl -<span class="hljs-symbol">Mlocal:</span>:<span class="hljs-class"><span class="hljs-keyword">lib</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Perl</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Learn-Vim-On-Github</title>
    <link href="/2022/07/04/Learn-Vim-On-Github/"/>
    <url>/2022/07/04/Learn-Vim-On-Github/</url>
    
    <content type="html"><![CDATA[<!-- toc --><hr><h2 id="Buffers-Windows-and-Tabs"><a href="#Buffers-Windows-and-Tabs" class="headerlink" title="Buffers, Windows and Tabs"></a>Buffers, Windows and Tabs</h2><h3 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h3><p>use <code>:buffers</code> to see all the buffers.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span> Create buffer. Each <span class="hljs-built_in">time</span> you <span class="hljs-built_in">open</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">file</span>, Vim <span class="hljs-built_in">create</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> buffer <span class="hljs-keyword">for</span> that <span class="hljs-built_in">file</span>.<br><span class="hljs-number">2.</span> Delete buffer. use `:bdelete`.<br><span class="hljs-comment">### Windows</span><br>A window is how you are viewing <span class="hljs-keyword">a</span> buffer through. You are looking <span class="hljs-keyword">at</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> buffer, displayed through <span class="hljs-keyword">a</span> window.<br></code></pre></td></tr></table></figure><p>If two windowes display the same buffer, when typing on one window, the other window will update in real-time.</p><h3 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h3><p>A collection of windows or it can be seen as a layout for windows.</p><p>It’s something we always see on the head of the screen.</p><p>run <code>gT</code> to go to next tab page.</p><h2 id="Searching-Files"><a href="#Searching-Files" class="headerlink" title="Searching Files"></a>Searching Files</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>:find</code> find file in <code>path</code>. <code>set path?</code>.</p><p>  path&#x3D;.,&#x2F;usr&#x2F;include,,</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">- `.` <span class="hljs-keyword">the</span> <span class="hljs-built_in">directory</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> currently opened <span class="hljs-built_in">file</span>.<br>- `,` <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> current <span class="hljs-built_in">file</span>.<br></code></pre></td></tr></table></figure><p>modify the paths.<br><mark>Add</mark></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:<span class="hljs-built_in">set</span> path+=app/controllers<br></code></pre></td></tr></table></figure><p>Add entire project directories:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">:<span class="hljs-built_in">set</span> path+=<span class="hljs-variable">$</span>&#123;<span class="hljs-built_in">PWD</span>&#125;/**<br></code></pre></td></tr></table></figure><p><code>**</code> means search recursively</p><h3 id="Grep"><a href="#Grep" class="headerlink" title="Grep"></a>Grep</h3><ul><li>Internal grep <code>:vimgrep</code>. Using <code>/pattern/</code>.</li><li>External grep <code>:grep</code>. Using <code>&quot;pattern&quot;</code>.</li></ul><h4 id="quickfix-command"><a href="#quickfix-command" class="headerlink" title="quickfix command"></a>quickfix command</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> <span class="hljs-code">`:copen`</span><br><span class="hljs-bullet">-</span> <span class="hljs-code">`:cclose`</span><br><span class="hljs-bullet">-</span> <span class="hljs-code">`:cnext`</span><br><span class="hljs-bullet">-</span> <span class="hljs-code">`:cprevious`</span><br><span class="hljs-bullet">-</span> <span class="hljs-code">`:colder`</span><br><span class="hljs-bullet">-</span> <span class="hljs-code">`:cnewer`</span><br></code></pre></td></tr></table></figure><h3 id="Netrw"><a href="#Netrw" class="headerlink" title="Netrw"></a>Netrw</h3><p><code>netrw</code> is Vim’s built-in file exploer.</p><p>I use NERDTree.</p><h3 id="Fzf"><a href="#Fzf" class="headerlink" title="Fzf"></a>Fzf</h3><p>fzf means “command-line fuzzy finder”.<br>Two plugin:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>fzf.vim<br><span class="hljs-bullet">- </span>ripgrep.vim<br></code></pre></td></tr></table></figure><p>It can have powerful usage when it is combined with ripgrep.</p><p>Actully, I use Ack instead of these two.</p><h2 id="Vim-Grammar"><a href="#Vim-Grammar" class="headerlink" title="Vim Grammar"></a>Vim Grammar</h2><p>Grammer rule in Vim language.</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">verb + <span class="hljs-built_in">noun</span><br></code></pre></td></tr></table></figure><h2 id="Moving-in-a-File"><a href="#Moving-in-a-File" class="headerlink" title="Moving in a File"></a>Moving in a File</h2><h3 id="Marking-Position"><a href="#Marking-Position" class="headerlink" title="Marking Position"></a>Marking Position</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">ma    Mark position <span class="hljs-keyword">with</span> mark <span class="hljs-string">&quot;a&quot;</span><br>\`a`    Jump <span class="hljs-keyword">to</span> <span class="hljs-literal">line</span> <span class="hljs-keyword">and</span> colume <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-symbol">&#x27;a</span>    Jump <span class="hljs-keyword">to</span> <span class="hljs-literal">line</span> <span class="hljs-string">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p>Lowercase alphabets are local marks and uppercase alphabets are global marks.</p><p>Global mark can travel across files.</p><p>To view all marks, use <code>:marks</code>.</p><h3 id="Jump"><a href="#Jump" class="headerlink" title="Jump"></a>Jump</h3><p>Read <code>:help jump-motions</code> </p><h2 id="The-Dot-Command"><a href="#The-Dot-Command" class="headerlink" title="The Dot Command"></a>The Dot Command</h2><p>The dot command <code>.</code> repeats the last change.</p><h3 id="What’s-a-change"><a href="#What’s-a-change" class="headerlink" title="What’s a change"></a>What’s a change</h3><p>Any time you update the content of the current buffer, like adding, modifying or deleting.</p><h2 id="Registers"><a href="#Registers" class="headerlink" title="Registers"></a>Registers</h2><p>Using register in insert mode <code>Ctrl-r</code></p><h3 id="Ten-Register-Types"><a href="#Ten-Register-Types" class="headerlink" title="Ten Register Types"></a>Ten Register Types</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>. The unnamed register <span class="hljs-string">&quot;&quot;</span> <br><span class="hljs-number">2</span>. The numbered <span class="hljs-keyword">registers</span> (<span class="hljs-comment">&quot;0-9).</span><br><span class="hljs-number">3</span>. The small <span class="hljs-keyword">delete</span> register (<span class="hljs-comment">&quot;-).</span><br><span class="hljs-number">4</span>. The named <span class="hljs-keyword">registers</span> (<span class="hljs-comment">&quot;a-z).</span><br><span class="hljs-number">5</span>. The <span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span> <span class="hljs-keyword">registers</span> (<span class="hljs-string">&quot;:, &quot;</span>.,<span class="hljs-built_in">and</span> <span class="hljs-comment">&quot;%).</span><br><span class="hljs-number">6</span>. The alternate <span class="hljs-keyword">file</span> register (<span class="hljs-comment">&quot;#).</span><br><span class="hljs-number">7</span>. The expression register (<span class="hljs-comment">&quot;=).</span><br><span class="hljs-number">8</span>. The selection <span class="hljs-keyword">registers</span> (<span class="hljs-string">&quot;* and &quot;</span>+).<br><span class="hljs-number">9</span>. The black hole register (<span class="hljs-comment">&quot;_).</span><br><span class="hljs-number">10</span>.The <span class="hljs-keyword">last</span> <span class="hljs-built_in">search</span> pattern register (<span class="hljs-comment">&quot;/).</span><br></code></pre></td></tr></table></figure><p>The rule of thumb is, if an operator can remove a text, it probably stores the text to registers.</p><p>To paste the text from register a, do <code>&quot;ap</code>.</p><p>The general syntax to get the content from a specific register is <code>&quot;a</code>.<br>Can I say the motion like <code>y d p</code> are registers?</p><h3 id="The-Non-zero-Numbered-Registers"><a href="#The-Non-zero-Numbered-Registers" class="headerlink" title="The Non-zero Numbered Registers"></a>The Non-zero Numbered Registers</h3><p>Store the deleted text.</p><h3 id="The-Small-Delete-Register"><a href="#The-Small-Delete-Register" class="headerlink" title="The Small Delete Register"></a>The Small Delete Register</h3><p>Changes less than one line are stored in the small delete register <code>&quot;-</code></p><h3 id="The-Named-Regiter"><a href="#The-Named-Regiter" class="headerlink" title="The Named Regiter"></a>The Named Regiter</h3><p>You have to explicitly tell Vim to use the named register.</p><p>To yank a word into regiter a <code>&quot;ayiw</code></p><p><mark>small conclusion</mark><br>To use the register, you may follow, <code>&quot;(registername)+motion</code>, like <code>&quot;ap</code>, <code>a</code> is the name of the register, <code>p</code> is the paste motion.</p><p>All twenty-six alphabetical charactors can be used as the named registers.</p><p><mark>Uppercase</mark> version of register is ok.</p><h3 id="The-Read-only-Register"><a href="#The-Read-only-Register" class="headerlink" title="The Read-only Register"></a>The Read-only Register</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">. Stores <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> inserted <span class="hljs-keyword">text</span><br>: Stores <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> executed <span class="hljs-keyword">command</span><span class="hljs-title">-line</span><br>% Stores <span class="hljs-keyword">the</span> name <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> current <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><h3 id="The-Expression-Register"><a href="#The-Expression-Register" class="headerlink" title="The Expression Register"></a>The Expression Register</h3><p>To get value from other rigister <code>&quot;=@a</code></p><h3 id="The-Selection-Register"><a href="#The-Selection-Register" class="headerlink" title="The Selection Register"></a>The Selection Register</h3><p>quotestar <code>&quot;*</code> and quoteplus <code>&quot;+</code> are connected to your clipboard.</p><h3 id="Clear-a-Register"><a href="#Clear-a-Register" class="headerlink" title="Clear a Register"></a>Clear a Register</h3><p><code>qaq</code> Let Vim to record an empty macro in the register a.</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">call</span> <span class="hljs-built_in">setreg</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;hello register a&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>:let @a = &#39;&#39;</code>.</p><h3 id="Viewing-the-Registers"><a href="#Viewing-the-Registers" class="headerlink" title="Viewing the Registers"></a>Viewing the Registers</h3><p><code>:register</code> to view all registers, <code>:register a</code> only view register a.</p><h3 id="Putting-the-Content-of-a-Register"><a href="#Putting-the-Content-of-a-Register" class="headerlink" title="Putting the Content of a Register"></a>Putting the Content of a Register</h3><p>Use <code>:put</code> command. like <code>:put a</code></p><h2 id="Micros"><a href="#Micros" class="headerlink" title="Micros"></a>Micros</h2><p>Using Vim macros, you can record actions and store them inside Vim register.</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal">qa  To Start recording a <span class="hljs-function"><span class="hljs-keyword">macro</span> <span class="hljs-title">in</span></span> register a <br>q(<span class="hljs-keyword">while</span> recording)  Stop recording <span class="hljs-function"><span class="hljs-keyword">macro</span> </span><br></code></pre></td></tr></table></figure><p>Execute a macro:<br><code>@a  Execute macro from register a</code><br><code>@@  Execute the last executed macros</code><br><mark>Small Conclusion</mark><br>Macro is still using registers. Some differences, the <code>@</code> can execute commands.<br>Macro execution automatically ends when it encounters an error.</p><h3 id="Command-Line-Macro"><a href="#Command-Line-Macro" class="headerlink" title="Command Line Macro"></a>Command Line Macro</h3><p>You can run <code>normal! @a</code>.</p><p>execute macro between line 2 and 3, run <code>:2, 3 normal @a</code>.</p><p><code>99@a</code> will execute macro for 99 times, but most of the time it will ends early.</p><p><code>:g/pattern/normal @a</code> it executes the command you give on lines that match the pattern.</p><p>A useful key <code>~</code> toggle the case of the character under the cursor.</p><h3 id="Appending-a-Macro"><a href="#Appending-a-Macro" class="headerlink" title="Appending a Macro"></a>Appending a Macro</h3><p>Append a named register by using its uppercased symbal. If you want to add action to register a macro, using register A.</p><h3 id="Amending-a-Macro"><a href="#Amending-a-Macro" class="headerlink" title="Amending a Macro"></a>Amending a Macro</h3><p><mark>Small Conclusion</mark><br>Some macro can resolve the lack of the key to replace the mapping.<br><code>^[</code> is Vim’s internal code representation of <code>&lt;Esc&gt;</code>.</p><p>Find the other internal code representation of some keys.</p><p>one way: <code>:let @a=</code></p><h3 id="Macro-Redundancy"><a href="#Macro-Redundancy" class="headerlink" title="Macro Redundancy"></a>Macro Redundancy</h3><p>To duplicate a macro in register a to register z <code>:let @z=@a</code></p><p>Almost everything that you can do in Vim can be replicated with macros.</p><h2 id="Undo"><a href="#Undo" class="headerlink" title="Undo"></a>Undo</h2><p>Vim undoes a single “change” at a time. When you enter the insert mode until you exit it count a change.</p><p><code>undolevels</code> option.</p><p>Undo breakpoint.</p><h3 id="Undo-Tree"><a href="#Undo-Tree" class="headerlink" title="Undo Tree"></a>Undo Tree</h3><p>Every time you press <code>u</code> and then make a different change, Vim store the previous state’s text by creating an “undo branch”.</p><p>Typing <code>g+</code> can go to a newer state and <code>g-</code> can go to a previous state.</p><p>Adding plugin vim-mundo.</p><p>To use undo tree, enter <code>undolist</code>.</p><h4 id="Usage-of-mundo"><a href="#Usage-of-mundo" class="headerlink" title="Usage of mundo"></a>Usage of mundo</h4><p><a href="https://simnalamburt.github.io/vim-mundo/">office document</a><br>Your current position in the undo tree is marked with an <code>@</code> character. </p><p>Pressing <code>p</code> to preview the diff.  </p><h3 id="Persistent-Undo"><a href="#Persistent-Undo" class="headerlink" title="Persistent Undo"></a>Persistent Undo</h3><p><code>:wundo &#123;my-undo-file&#125;</code> to create a undo file, adding <code>!</code> to overwrite.</p><p><code>rundo &#123;file&#125;</code> to reading the undo file.</p><h3 id="Time-Travel"><a href="#Time-Travel" class="headerlink" title="Time Travel"></a>Time Travel</h3><p><code>:earlier 10s</code> back to 10 seconds ago.<br><code>:earlier 2</code> 2 changes ago<br><code>:earlier 10f</code> 10 saves ago</p><p><code>:later 10s</code>.</p><h2 id="Visual-Mode"><a href="#Visual-Mode" class="headerlink" title="Visual Mode"></a>Visual Mode</h2><p>Pressing <code>gU</code> to uppercase the selected text.</p><h3 id="Incrementing-Numbers"><a href="#Incrementing-Numbers" class="headerlink" title="Incrementing Numbers"></a>Incrementing Numbers</h3><p><code>Ctrl-A</code> command to increse, <code>Ctrl-X</code> command to decrese</p><p><code>g Ctrl-A</code> 递增，<code>g Ctrl-X</code> 递减.</p><h3 id="Selecting-the-Last-Visual-Mode-Area"><a href="#Selecting-the-Last-Visual-Mode-Area" class="headerlink" title="Selecting the Last Visual Mode Area"></a>Selecting the Last Visual Mode Area</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">`&lt;  Go <span class="hljs-keyword">to</span> the <span class="hljs-keyword">first</span> place of the <span class="hljs-keyword">previous</span> <span class="hljs-keyword">visual</span> <span class="hljs-keyword">mode</span> <span class="hljs-keyword">highlight</span><br>`&gt;  Go <span class="hljs-keyword">to</span> the <span class="hljs-keyword">last</span> place of the <span class="hljs-keyword">previous</span> <span class="hljs-keyword">visual</span> <span class="hljs-keyword">mode</span> <span class="hljs-keyword">highlight</span><br></code></pre></td></tr></table></figure><p>Deleting an inner word use <code>viwd</code></p><h2 id="Search-and-Substitude"><a href="#Search-and-Substitude" class="headerlink" title="Search and Substitude"></a>Search and Substitude</h2><p><code>/</code> can also be done with <code>?</code></p><p>Add case sensitivity: <code>:set ignorecase</code></p><h3 id="Repeating-Search"><a href="#Repeating-Search" class="headerlink" title="Repeating Search"></a>Repeating Search</h3><p>Repeating the previous search with <code>//</code>.</p><p>To see all search history, running <code>:history /</code>.</p><p><code>:set wrapscan</code> option to make Vim to search back at the top of the file when you reach the end of the file.</p><h3 id="Searching-for-Alternative-Words"><a href="#Searching-for-Alternative-Words" class="headerlink" title="Searching for Alternative Words"></a>Searching for Alternative Words</h3><p>Using <code>|</code> pattern, like <code>/\vhello|world</code></p><h3 id="Setting-the-Start-and-End-of-a-Match"><a href="#Setting-the-Start-and-End-of-a-Match" class="headerlink" title="Setting the Start and End of a Match"></a>Setting the Start and End of a Match</h3><p>Using <code>\zs</code> to set starting of a match and <code>\ze</code> to set ending of a match</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">/11</span>\zsvim\ze22<br></code></pre></td></tr></table></figure><p>Matching the strings start with 11 and end with 22.</p><h3 id="Searching-for-Repeating-Characters"><a href="#Searching-for-Repeating-Characters" class="headerlink" title="Searching for Repeating Characters"></a>Searching for Repeating Characters</h3><p>Passing <code>count</code> to your search.</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;n,m&#125;</span><br></code></pre></td></tr></table></figure><p>four different variations of the <code>count</code> syntax.</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;n&#125;</span><span class="language-xml">, /[0-9]\</span><span class="hljs-template-variable">&#123;2\&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;n,m&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;,m&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;n,&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Predefined-Character-Ranges"><a href="#Predefined-Character-Ranges" class="headerlink" title="Predefined Character Ranges"></a>Predefined Character Ranges</h3><p>Full list inside <code>:h /character-classes</code></p><h3 id="Basic-Substitution"><a href="#Basic-Substitution" class="headerlink" title="Basic Substitution"></a>Basic Substitution</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">:s<span class="hljs-regexp">/&#123;old-pattern&#125;/</span>&#123;<span class="hljs-keyword">new</span>-pattern&#125;/<br></code></pre></td></tr></table></figure><h3 id="Substitution-Range"><a href="#Substitution-Range" class="headerlink" title="Substitution Range"></a>Substitution Range</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">:[range]s<span class="hljs-regexp">/old/</span><span class="hljs-keyword">new</span>/<br></code></pre></td></tr></table></figure><p>example:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">:<span class="hljs-number">3</span>,<span class="hljs-number">5</span>s<span class="hljs-regexp">/let/</span>const/<br></code></pre></td></tr></table></figure><p>To substisude on lines three to five.</p><p>Range variation:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">:,<span class="hljs-number">3</span>s<span class="hljs-regexp">/let/</span>const/<br>:<span class="hljs-number">1</span>,s<span class="hljs-regexp">/let/</span>const/<br>:<span class="hljs-number">3</span>s<span class="hljs-regexp">/let/</span>const/<br></code></pre></td></tr></table></figure><p><code>%</code> always means the entire file. <code>%ss/let/const/</code></p><h3 id="Substitude-Flags"><a href="#Substitude-Flags" class="headerlink" title="Substitude Flags"></a>Substitude Flags</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&amp;    Reuse the flags <span class="hljs-keyword">from</span> the previous substitute command.<br>g    Replace <span class="hljs-keyword">all</span> matches <span class="hljs-keyword">in</span> the <span class="hljs-type">line</span>.<br>c    Ask <span class="hljs-keyword">for</span> substitution confirmation.<br>e    Prevent error message <span class="hljs-keyword">from</span> displaying <span class="hljs-keyword">when</span> substitution fails.<br>i    <span class="hljs-keyword">Perform</span> <span class="hljs-keyword">case</span> insensitive substitution.<br>I    <span class="hljs-keyword">Perform</span> <span class="hljs-keyword">case</span> sensitive substitution.<br></code></pre></td></tr></table></figure><h3 id="Changing-the-Delimiter"><a href="#Changing-the-Delimiter" class="headerlink" title="Changing the Delimiter"></a>Changing the Delimiter</h3><p>You can change the delimiter with any single-byte characters.o</p><h3 id="Substituting-Across-Multiple-Files"><a href="#Substituting-Across-Multiple-Files" class="headerlink" title="Substituting Across Multiple Files"></a>Substituting Across Multiple Files</h3><p><code>:args</code> and <code>:argdo</code> are useful tools to apply command line commands across multiple files.</p><h3 id="args-and-argdo"><a href="#args-and-argdo" class="headerlink" title=":args and :argdo"></a><code>:args</code> and <code>:argdo</code></h3><p><code>:args</code> is argument list. <code>:argdo</code> execute {cmd} for each file in the argument list.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">:<span class="hljs-comment">[range]</span>argdo<span class="hljs-comment">[!]</span> &#123;cmd&#125;<br></code></pre></td></tr></table></figure><h2 id="The-Global-Command"><a href="#The-Global-Command" class="headerlink" title="The Global Command"></a>The Global Command</h2><p>Repeating the last change with the dot command <code>.</code>, Replaying actions with macros <code>q</code>, storing texts in the registers <code>&quot;</code>.</p><h3 id="Global-Command-Overview"><a href="#Global-Command-Overview" class="headerlink" title="Global Command Overview"></a>Global Command Overview</h3><p>Both Ex commmands and command-line commands are the same. They are the commands that start with a colon <code>:</code>.</p><p>They are called Ex because they originally came from the Ex text editor.</p><p>Check out <code>:h ex-cmd-index</code></p><p>Syntax:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/pattern/command</span><br></code></pre></td></tr></table></figure><p>The global command works by executing <code>command</code> against each line that matches the pattern.</p><p>When running the <code>g</code> command, Vim makes two scans across file.</p><h3 id="Inverse-Match"><a href="#Inverse-Match" class="headerlink" title="Inverse Match"></a>Inverse Match</h3><p>To run the global command on non-matching lines.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g!/pattern/command</span><br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:v/pattern/command</span><br></code></pre></td></tr></table></figure><h3 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h3><p>Same pattern system as the substitude command.</p><h3 id="Passing-a-Range"><a href="#Passing-a-Range" class="headerlink" title="Passing a Range"></a>Passing a Range</h3><p>If no range are given, by default it affects the entire file.</p><p>Symbles as range:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">.   means <span class="hljs-keyword">the</span> current <span class="hljs-built_in">line</span>. .,<span class="hljs-number">3</span><br>$   means <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> <span class="hljs-built_in">line</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span><br>+n means n <span class="hljs-keyword">lines</span> <span class="hljs-keyword">after</span> <span class="hljs-keyword">the</span> current <span class="hljs-built_in">line</span>. <span class="hljs-number">3</span>,.+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="Executing-a-Macro"><a href="#Executing-a-Macro" class="headerlink" title="Executing a Macro"></a>Executing a Macro</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/const/normal</span> <span class="hljs-variable">@a</span><br></code></pre></td></tr></table></figure><h3 id="Recursive-Global-Command"><a href="#Recursive-Global-Command" class="headerlink" title="Recursive Global Command"></a>Recursive Global Command</h3><p>The global command itself is a type of a command-line command.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/console/g/two/d</span><br></code></pre></td></tr></table></figure><h3 id="Changing-the-Delimiter-1"><a href="#Changing-the-Delimiter-1" class="headerlink" title="Changing the Delimiter"></a>Changing the Delimiter</h3><p>Still, you can use any single byte character except for alphabets, numbers, <code>&quot;</code>, <code>|</code> and <code>\</code></p><p>like <code>:g@console@d</code></p><h3 id="The-Default-Command"><a href="#The-Default-Command" class="headerlink" title="The Default Command"></a>The Default Command</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/console</span><br></code></pre></td></tr></table></figure><p>as </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/console/p</span><br></code></pre></td></tr></table></figure><p>The syntax:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/re/p</span><br></code></pre></td></tr></table></figure><p><code>grep</code> got its name there.</p><h3 id="Black-Hole-Delete"><a href="#Black-Hole-Delete" class="headerlink" title="Black Hole Delete"></a>Black Hole Delete</h3><p>Make Vim not store your deleted lines into the registers.</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:g/console/d_</span><br></code></pre></td></tr></table></figure><h3 id="Reduce-Multiple-Empty-Lines-to-One-Empty-Line"><a href="#Reduce-Multiple-Empty-Lines-to-One-Empty-Line" class="headerlink" title="Reduce Multiple Empty Lines to One Empty Line"></a>Reduce Multiple Empty Lines to One Empty Line</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-symbol">:g/^</span><span class="hljs-variable">$/</span>,<span class="hljs-regexp">/./</span>-1j<br></code></pre></td></tr></table></figure><p><code>j</code> is the <code>join</code> command.<br>Another form of global command:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-symbol">:g/pattern1/</span>,<span class="hljs-regexp">/pattern2/command</span><br></code></pre></td></tr></table></figure><h3 id="Advanced-Sort"><a href="#Advanced-Sort" class="headerlink" title="Advanced Sort"></a>Advanced Sort</h3><p>You can give a range:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">:<span class="hljs-number">2</span>,<span class="hljs-number">3</span><span class="hljs-built_in">sort</span><br></code></pre></td></tr></table></figure><h2 id="External-Commands"><a href="#External-Commands" class="headerlink" title="External Commands"></a>External Commands</h2><h3 id="The-Bang-Command"><a href="#The-Bang-Command" class="headerlink" title="The Bang Command"></a>The Bang Command</h3><p><code>!</code> can do three things. <code>:r</code> is the <code>:read</code> command.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span> Reading <span class="hljs-keyword">the</span> STDOUT <span class="hljs-keyword">of</span> <span class="hljs-keyword">a</span> Command Into Vim. <br>   :r !cmd<br><span class="hljs-number">2.</span> Writing <span class="hljs-keyword">the</span> Buffer Content Into <span class="hljs-keyword">an</span> External Command. <br>   :w !cmd<br><span class="hljs-number">3.</span> Executing <span class="hljs-keyword">an</span> External Command.<br>   :!cmd<br></code></pre></td></tr></table></figure><p>The bang <code>!</code> always stay before the cmd.</p><h3 id="Filtering-Texts"><a href="#Filtering-Texts" class="headerlink" title="Filtering Texts"></a>Filtering Texts</h3><p>If you give <code>!</code> a range, it can be used to filter texts.</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure"><span class="hljs-symbol">:.!</span><br></code></pre></td></tr></table></figure><p>executes the filter command on the current line.</p><p><code>:%!</code> executes the filter command on all lines.</p><h3 id="Normal-Mode-Command"><a href="#Normal-Mode-Command" class="headerlink" title="Normal Mode Command"></a>Normal Mode Command</h3><p>Vim has a filter operater <code>!</code> in the normal mode.</p><h2 id="Command-line-Mode"><a href="#Command-line-Mode" class="headerlink" title="Command-line Mode"></a>Command-line Mode</h2><p>To leave the command-line mode, you can use <code>&lt;esc&gt;</code>, <code>Ctrl-C</code> or <code>Ctrl-[</code>.</p><h3 id="Repeating-the-Previous-Command"><a href="#Repeating-the-Previous-Command" class="headerlink" title="Repeating the Previous Command"></a>Repeating the Previous Command</h3><p>Running <code>@:&lt;mark&gt;&lt;mark&gt;</code>.</p><h3 id="Command-line-Mode-Shortcuts"><a href="#Command-line-Mode-Shortcuts" class="headerlink" title="Command-line Mode Shortcuts"></a>Command-line Mode Shortcuts</h3><p>To go to the start of the line, use <code>Ctrl-B</code></p><p>To go to the end of the line, use <code>Ctrl-E</code></p><p>To edit the command like you would a normal textfile use <code>Ctrl-F</code>.</p><h3 id="Register-and-Autocomplete"><a href="#Register-and-Autocomplete" class="headerlink" title="Register and Autocomplete"></a>Register and Autocomplete</h3><p>Everything that you can get from the register in the insert mode, you can do the same from the command-line mode.</p><p>Using <code>Ctrl-R</code> to insert the content of register.</p><h3 id="History-Window-and-Command-line-Window"><a href="#History-Window-and-Command-line-Window" class="headerlink" title="History Window and Command-line Window"></a>History Window and Command-line Window</h3><p>To open the command-line history, run <code>:his :</code>.</p><p>Reusing the command, run <code>q:</code> and choose.</p><p>To open the search history, run <code>:his /</code> or <code>his ?</code>.</p><p>Edit past history, run <code>q/</code> or <code>q?</code>.</p><p>check out <code>:h ex-cmd</code> or <code>:h index</code>.</p><h2 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h2><h3 id="Tag-Generator"><a href="#Tag-Generator" class="headerlink" title="Tag Generator"></a>Tag Generator</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ctags</span> = C <span class="hljs-literal">on</span>ly<br><span class="hljs-attr">ptags</span> = Perl<br></code></pre></td></tr></table></figure><p>There are many Tag Generator, almost for different language.</p><p>Install the universal ctags, which is still maintained.</p><h3 id="Tags-Anatomy"><a href="#Tags-Anatomy" class="headerlink" title="Tags Anatomy"></a>Tags Anatomy</h3><p>Four components: </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> tagname<br><span class="hljs-bullet">2.</span> tagfile<br><span class="hljs-bullet">3.</span> tagaddress<br><span class="hljs-bullet">4.</span> tag options<br></code></pre></td></tr></table></figure><p>The content of the tag file depends on which generator you use.</p><p>A tag file must have either one of those format:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">1. </span><span class="hljs-template-variable">&#123;tagname&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;TAB&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;tagfile&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;TAB&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;tagaddress&#125;</span><span class="language-xml"></span><br><span class="language-xml">2. </span><span class="hljs-template-variable">&#123;tagname&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;TAB&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;tagfile&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;TAB&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;tagaddress&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;term&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;fild&#125;</span><span class="language-xml"> ..</span><br></code></pre></td></tr></table></figure><h3 id="The-Tag-File"><a href="#The-Tag-File" class="headerlink" title="The Tag File"></a>The Tag File</h3><p>Run <code>set tags?</code>.</p><p>To add a new tag file location:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> <span class="hljs-keyword">tags</span>+=path/<span class="hljs-keyword">to</span>/my/<span class="hljs-keyword">tags</span>/<span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><h3 id="Generating-Tags-for-a-Large-Project"><a href="#Generating-Tags-for-a-Large-Project" class="headerlink" title="Generating Tags for a Large Project"></a>Generating Tags for a Large Project</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ctags -R <span class="hljs-attribute">--exclude</span>=.git <span class="hljs-attribute">--exclude</span>=vendor <span class="hljs-attribute">--exclude</span>=node_modules<br></code></pre></td></tr></table></figure><h3 id="Tags-Navigation"><a href="#Tags-Navigation" class="headerlink" title="Tags Navigation"></a>Tags Navigation</h3><p>The tag jump key <code>Ctrl-]</code> or run <code>:tag name</code> </p><h3 id="Tag-Priority"><a href="#Tag-Priority" class="headerlink" title="Tag Priority"></a>Tag Priority</h3><p>Some tags have higher priorities.</p><p>check out <code>:h tag-priority</code>.</p><h3 id="Selective-Tag-Jumps"><a href="#Selective-Tag-Jumps" class="headerlink" title="Selective Tag Jumps"></a>Selective Tag Jumps</h3><p>run <code>:tselect name</code></p><p>Normal mode key for <code>tjump</code> : <code>g Ctrl-]</code>.</p><h3 id="Automatic-Tag-Generation"><a href="#Automatic-Tag-Generation" class="headerlink" title="Automatic Tag Generation"></a>Automatic Tag Generation</h3><p>Using <code>autocmd</code>:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">autocmd</span> BufWritePost \*.rb <span class="hljs-keyword">silent</span> !ctags -R .<br></code></pre></td></tr></table></figure><p>One plugin vim-gutemtags. </p><h2 id="Fold"><a href="#Fold" class="headerlink" title="Fold"></a>Fold</h2><p>Executing a fold from the command-line mode:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">:,+<span class="hljs-number">1</span><span class="hljs-built_in">fold</span><br></code></pre></td></tr></table></figure><h3 id="Syntax-Fold"><a href="#Syntax-Fold" class="headerlink" title="Syntax Fold"></a>Syntax Fold</h3><p>It is determined by syntax language highlighting.</p><p>Check out <code>:h syntax.txt</code></p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>Running <code>:vimdiff</code> command to show the differences between multiple files. or <code>vim -d file1.txt file2.txt</code></p><p>Go to the next diff with <code>]c</code>.</p><p>Jump to the previous diff window, use [c</p><p>One plugin ‘tpope&#x2F;vim-fugitive’</p><h2 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h2><p>Vim has a <code>:make</code> command to run a makefile.</p><h2 id="Views-Sessions-and-Viminfo"><a href="#Views-Sessions-and-Viminfo" class="headerlink" title="Views, Sessions, and Viminfo"></a>Views, Sessions, and Viminfo</h2><p>To store the current change of settings, folds, buffers, layouts, etc.</p><h3 id="Configuring-View-Attributes"><a href="#Configuring-View-Attributes" class="headerlink" title="Configuring View Attributes"></a>Configuring View Attributes</h3><p>Tell View to remember the <code>localoptions</code>, run <code>:set viewoptions+=localoptions</code></p><h3 id="Saving-the-View"><a href="#Saving-the-View" class="headerlink" title="Saving the View"></a>Saving the View</h3><p>Run <code>:mkview</code></p><h3 id="Loading-the-View-File"><a href="#Loading-the-View-File" class="headerlink" title="Loading the View File"></a>Loading the View File</h3><p>Run <code>:loadview</code></p><h3 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h3><p>View saves the settings of a window, a Session saves the infomation of all windows (including the layout). </p><h4 id="Save-a-Session"><a href="#Save-a-Session" class="headerlink" title="Save a Session"></a>Save a Session</h4><p>Run <code>:mksession</code>.</p><p>A Session file is saved in the current directory or you can choose.</p><h4 id="Loading-a-Session"><a href="#Loading-a-Session" class="headerlink" title="Loading a Session"></a>Loading a Session</h4><p>To load a Session, run</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">source</span> Session.<span class="hljs-keyword">vim</span><br></code></pre></td></tr></table></figure><h3 id="Viminfo"><a href="#Viminfo" class="headerlink" title="Viminfo"></a>Viminfo</h3><p>Session stores the “external” attributes and Viminfo the “internal” attributes.</p><p>One Viminfo file per computer.</p><p>Default location: <code>~/.viminfo</code></p><h2 id="Multiple-File-Operations"><a href="#Multiple-File-Operations" class="headerlink" title="Multiple File Operations"></a>Multiple File Operations</h2><p>Vim has eight ways to execute commands across multiple files:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">  <br>arg <span class="hljs-title function_">list</span> <span class="hljs-params">(argdo)</span><br>buffer <span class="hljs-title function_">list</span> <span class="hljs-params">(bufdo)</span><br>window <span class="hljs-title function_">list</span> <span class="hljs-params">(windo)</span><br>tab <span class="hljs-title function_">list</span> <span class="hljs-params">(tabdo)</span><br>quickfix <span class="hljs-title function_">list</span> <span class="hljs-params">(cdo)</span><br>quickfix list <span class="hljs-title function_">filewise</span> <span class="hljs-params">(cfdo)</span><br>location <span class="hljs-title function_">list</span> <span class="hljs-params">(ldo)</span><br>location list <span class="hljs-title function_">filewise</span> <span class="hljs-params">(lfdo)</span><br></code></pre></td></tr></table></figure><p>Same idea: make a list of their respective categories then pass them the command that you want to run.</p><h2 id="Vimrc"><a href="#Vimrc" class="headerlink" title="Vimrc"></a>Vimrc</h2><h3 id="Organizing-Vimrc"><a href="#Organizing-Vimrc" class="headerlink" title="Organizing Vimrc"></a>Organizing Vimrc</h3><p>Two ways to keep your vimrc to look clean:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Splite your vimrc <span class="hljs-keyword">into</span> several <span class="hljs-built_in">files</span><br>Fold your vimrc <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><p>Using <code>:source</code> to splite.</p><h2 id="Vim-packages"><a href="#Vim-packages" class="headerlink" title="Vim packages"></a>Vim packages</h2><p>Vim’s own built-in plugin manager called packages.</p><p><mark>the <code>version</code> command</mark><br>you can get some function of your vim.</p><h2 id="Vim-Runtime"><a href="#Vim-Runtime" class="headerlink" title="Vim Runtime"></a>Vim Runtime</h2><p>To see your run time path, run <code>:set runtimepath?</code></p><h3 id="Filetype-Detection"><a href="#Filetype-Detection" class="headerlink" title="Filetype Detection"></a>Filetype Detection</h3><p>Two ways to detecte:</p><p>  file name<br>  file content</p><p><code>:setfiletype type</code> will work only there is no type is set.</p><h4 id="Filetype-File"><a href="#Filetype-File" class="headerlink" title="Filetype File"></a>Filetype File</h4><p>Create a <code>filetype.vim</code> in the root directory <code>~/.vim/filetype.vim</code>.</p><p>To prevent running multiple times:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-function"><span class="hljs-title">exists</span>(<span class="hljs-string">&quot;did_load_filetypes&quot;</span>)</span><br>  <span class="hljs-variable">finish</span><br><span class="hljs-variable"><span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>finish</code> is a Vim command to stop running the rest of the script.</p><h4 id="File-Type-Script"><a href="#File-Type-Script" class="headerlink" title="File Type Script"></a>File Type Script</h4><p>Based on the file content.</p><p>Adding a <code>scripts.vim</code> file (<code>~/.vim/scripts.vim</code>)</p><p>I suppose you can use other name instead of <code>scripts.vim</code></p><h2 id="Vimscript-Basic-Data-Types"><a href="#Vimscript-Basic-Data-Types" class="headerlink" title="Vimscript Basic Data Types"></a>Vimscript Basic Data Types</h2><h3 id="Following-Along-With-Ex-Mode"><a href="#Following-Along-With-Ex-Mode" class="headerlink" title="Following Along With Ex Mode"></a>Following Along With Ex Mode</h3><p>The Ex mode is like an extended command-line mode (it’s like typing command-line mode commands non-stop), run <code>Q</code> or <code>gQ</code> to enter.</p><p><mark>somethings I’m curious about</mark><br>Before some command, there is a <code>g</code> like <code>gQ</code>.</p><p><code>g</code> was just an empty slot, it means nothing.</p><p>To clear your message history, run:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">:messages clear<br></code></pre></td></tr></table></figure><h3 id="Double-vs-Single-Quotes"><a href="#Double-vs-Single-Quotes" class="headerlink" title="Double vs Single Quotes"></a>Double vs Single Quotes</h3><p>Single quotes display characters literally.</p><p>Double quotes accept special characters.</p><p>List use <code>[]</code></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">Dictionary use `&#123;&#125;`<br>### Special Primitives<br>Vim has <span class="hljs-keyword">special</span> primetives:<br></code></pre></td></tr></table></figure><p>  v:false<br>  v:true<br>  v:none<br>  v:null</p><pre><code class="hljs">`v:` is Vim&#39;s built-in variable.</code></pre>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>About-ack</title>
    <link href="/2022/07/03/About-ack/"/>
    <url>/2022/07/03/About-ack/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p><a href="https://beyondgrep.com/">reference</a></p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ack is a grep-like source code search tool.</p><p>It uses the perl style regex grammer.</p><hr><h2 id="ack-vim"><a href="#ack-vim" class="headerlink" title="ack.vim"></a>ack.vim</h2><p>You can search on <a href="https://vimawesome.com/">https://vimawesome.com/</a>.</p><hr><h2 id="Some-Syntax"><a href="#Some-Syntax" class="headerlink" title="Some Syntax"></a>Some Syntax</h2><p><code>!</code> before <code>:Ack</code>, the Vim will not jump to the first occurrence.</p>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>end of the stream or a document separator is expected</title>
    <link href="/2022/07/02/end-of-the-stream-or-a-document-separator-is-expected/"/>
    <url>/2022/07/02/end-of-the-stream-or-a-document-separator-is-expected/</url>
    
    <content type="html"><![CDATA[<p>After analysing the error output, I delete the <code>&#123;&#125;</code> in the file, and it’s fixxed.</p>]]></content>
    
    
    <categories>
      
      <category>Errors</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Learn C in Linux</title>
    <link href="/2022/07/02/CinLinux/"/>
    <url>/2022/07/02/CinLinux/</url>
    
    <content type="html"><![CDATA[<h1 id="第十章-gdb"><a href="#第十章-gdb" class="headerlink" title="第十章 gdb"></a>第十章 gdb</h1><p><code>help</code> command, the output is the main type of a class of commands.</p><p><code>list</code> command 一次只列10行. 可以用函数名。</p><p>按回车键表示重复上一条命令。</p><p>在调试时也需要源文件。</p><p><code>#0</code>, <code>#1</code> 是栈帧编号。</p><p>未初始化的变量具有不确定的值。</p><p><code>$1</code> 保存着gdb中的中间结果。</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul><li>backtrace(bt)</li><li>finish</li><li>frame(f)</li><li>info(i) locals</li><li>list(l)</li><li>list 行号</li><li>list 函数名</li><li>next(n)</li><li>print(p)</li><li>quit(q)</li><li>set var</li><li>start</li><li>step(s)</li></ul><h2 id="10-2-断点"><a href="#10-2-断点" class="headerlink" title="10.2 断点"></a>10.2 断点</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Use Leaderf in Vim</title>
    <link href="/2022/07/01/Use-Leaderf-in-Vim/"/>
    <url>/2022/07/01/Use-Leaderf-in-Vim/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Use Perl to Write Vimscript</title>
    <link href="/2022/07/01/Use-Perl-to-Write-Vimscript/"/>
    <url>/2022/07/01/Use-Perl-to-Write-Vimscript/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
